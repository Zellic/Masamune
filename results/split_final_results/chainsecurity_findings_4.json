[{"title": "7.4   Incorrect Comment in finalizeChange", "body": "  POA Network - POSDAO -   22  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \fThe  comment  in  the  else  if  branch  suggest,  it  is  only  been  executed  in  case  of  malicious  validator reporting.  But the code is also executed in case of mining address changes.    The code comments were corrected and elaborated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.5   Incorrect Description", "body": "  In StakingAuRaBase the function description of _stake(address, address, uint256) is  // @dev The internal function used by the `_stake` and `moveStake` functions.  But function is also used in initialValidatorStake, _addPool.    The code comments were corrected and elaborated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.6   Make onTokenTransfer() External", "body": "  Function StakingAuraTokens.onTokenTransfer() has visibility public. This means the function can be called externally and internally from within the contract.  Inside this function the calldata is read. This is the data passed alongside the call to the contract and remains unchanged if another function within the contract executes another contract as on a bytecode level  this  is  only  a  JUMP.  Function  onTokenTransfer  is  currently  only  called  from  externally  and  not internally  from  within  the  StakingAuraTokens  contract.  Hence,  the  calldata  consists  of  the  function arguments  as  expected.  Due  to  the  dependency  on  calldata  the  functions  visibility  may  be  external instead of public to avoid the function being called from within the contract accidentally during future code changes.    The function visibility as well as the reads from memory were changed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.7   Multiplication After Division", "body": "  In ValidatorSetAuRa.reportMaliciousCallable() a multiplication is performed after a division:  POA Network - POSDAO -   23  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \faverageReportsNumber = (reportsTotalNumber - reportsNumber) / (validatorsNumber - 1) [...] reportsNumber > validatorsNumber * 50 && reportsNumber > averageReportsNumber * 10  Due to possible precision loss, this should be avoided.    The multiplication is now done before division.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.8   No Indexed Fields for ReportedMalicious", "body": "  The  ReportedMalicious  event  has  multiple  fields  that  might  be  worth  indexing.  No  field  is  indexed. POA Network might re-evaluate if this is desired.    The event has now indexed fields.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.9   Unchecked Return Value of Transfer", "body": "  BlockRewardAuRaTokens.transferReward()  In  and StakingAuRaTokens._sendWithdrawnStakeAmount()  the  boolean  return  value  of  the  call  to erc677TokenContract.transfer() is ignored.  While  most  ERC-20  Tokens  (ERC-677  implements  the  ERC-20  Standard)  and  the  ERC677  token implementation  available  in  the  repository  revert  upon  failure,  the  standard  does  not  require  this  and returning false instead of reverting is valid according to the standard. As the POSDAO system is highly customizable the situation may arises where a token contract not reverting on failure is used.  Similarly  return  TokenMinter.mintReward() is also ignored.  value   the   of   the   call   to   tokenContract.mint()   inside    The transfer functions are wrapped into a require. The mint function remained as it is since it is called by the BlockReward.reward function which is critically sensible for reverting according to POA network.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.10   certify Missing Sanity Check", "body": "  The Certifier implements certify. The function allows certifying the same address multiple times. The Confirmed event would be emitted misleadingly multiple times.  POA Network - POSDAO -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  An appropriate sanity check was added.  POA Network - POSDAO -   25  \f8   Notes  We leverage this section to highlight potential pitfalls which are fairly common when working Distributed Ledger Technologies. As such technologies are still rather novel not all developers might yet be aware of these  pitfalls.  Hence,  the  mentioned  topics  serve  to  clarify  or  support  the  report,  but  do  not  require  a modification  inside  the  project.  Instead,  they  should  raise  awareness  in  order  to  improve  the  overall understanding for users and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "8.1   Avoiding Function Identifier Clashes", "body": "  The current proxy scheme is vulnerable to duplicated 4-byte function identifiers which could result in a function  identifer  clash.  POA  Network  prevents  this  by  using  an  off-chain  script  to  check  for  clashes. There are also on-chain solutions like the upgradable transparent proxy solution by OpenZeppelin which might be worth considering.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "8.2   ERC677 Standard Is a DRAFT", "body": "  The ERC677 standard is based on a eip having draft status since it's creation in 2017. Such standards are subject to changes before the eip's status is finalized.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "8.3   Most of the RedBlackTree Library Functions", "body": " Unused  Following function of the RedBlockTree Library are unused and hence dead code.  BokkyPooBahsRedBlackTreeLibrary.first() BokkyPooBahsRedBlackTreeLibrary.getEmpty() BokkyPooBahsRedBlackTreeLibrary.getNode() BokkyPooBahsRedBlackTreeLibrary.isEmpty(uint256) BokkyPooBahsRedBlackTreeLibrary.next() BokkyPooBahsRedBlackTreeLibrary.treeMinimum()  Note as the functions are not used within the POSDAO system these were not reviewed as part of this audit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "8.4   Pragma Experimental ABIEncoderV2", "body": "  Contract  TxPriority  uses  pragma  experimental  ABIEncoderV2.  In  the  compiler  version choosen the new ABI encoder is still considered to be experimental.  POA Network - POSDAO -   26  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f8.5   UTF-8 Charset  The validator and the staking contract allow names to be set for pools. The charset for string is UTF-8. UTF-8  has  some  similar  looking  characters,  which  for  a  human  reader  some  of  these  letters  are indistinguishable.  This allows so called visual spoofing of names. Users and front-end developper should excercise extra caution.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "8.6   Unreliable Event Emission When Mining", "body": " Address Is Changed  When reporting a malicious validator, the mining address is used and the following event emitted.  The  _maliciousMiningAddress  might  change  between  multiple  reportings.  Hence,  the  mining address is no reliable information to process from across multiple events.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "8.7   Unused Code _removeMaliciousValidator", "body": "  The  ValidatorSetAuRa  contract  implements  the  function  _removeMaliciousValidator.  This function is not called at all. The only function it appears is in _removeMaliciousValidators. But it is commented  out  there.  Furthermore,  the  function  _removeMaliciousValidators  does  not  do anything  except  for  setting  lastChangeBlock.  Hence,  also  removeMaliciousValidators  is basically only setting this variable.  This also affects parts of reportMalicious. We were verbally informed that client is aware of this and this will be fixed for the final review. Else, this would turn into an issue.  POA Network - POSDAO -   27  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "5.1   Consistency on Zero Amount Transfers", "body": "  The  function  BasicDelegationPod._updateBalances  does  not  trigger  mint/burn/transfer  of delegation shares (an ERC20Pods token) on 0 amount. The ERC20 standard specifies Note Transfe rs of 0 values MUST be treated as normal transfers and fire the Transfer even t..  1inch - Delegation -   9  SecurityDesignCorrectnessCriticalHighMediumLowDesignLowVersion2           \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Possible Frontrunning on Registration    Pod.updateBalances() Cannot Transfer ERC20Pods   -Severity Findings   Allowances Not Completely Disabled   -Severity Findings   Broken C-E-I Pattern   Inconsistency and Zero Address Check on register()    No Event upon Registering Delegatee   0  2  1  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "6.1   Possible Frontrunning on Registration", "body": "  If  a  delegatee  already  deployed  its  DelegatedShare  contact  on  its  own  and  want  to  register  it  with register(IDelegatedShare  shareToken,  address  defaultFarm),  another  user  could  front run the transaction and register the already deployed contract in place of the true delegatee, who won't be able to register the contract for itself.  This can become problematic if the DelegatedShare contract already has some accounting done.    The  register(IDelegatedShare  shareToken,  address  defaultFarm)  function  has  been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "6.2   Pod.updateBalances() Cannot Transfer", "body": " ERC20Pods  least  one  pod   involved):  Using   Pod.updateBalances() cannot transfer (including mint or burn) tokens of another ERC20Pods (with to at  updateBalances() of a pod is executed with _POD_CALL_GAS_LIMIT amount of gas. Currently this value is hardcoded to 200_000. A transfer of an ERC20Pods within updateBalances() would trigger _updateBalances()  of  this  ERC20Pods.  The  current  call  executing  with  this  amount  of  gas  cannot forward another 200_000 gas and hence the execution reverts.  implementation  of  ERC20Pods   the  default   the  call   1inch - Delegation -   10  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrectedDesignHighVersion1CodeCorrected                 \ffunction _updateBalances(address pod, address from, address to, uint256 amount) private {      bytes4 selector = IPod.updateBalances.selector;      bytes4 exception = InsufficientGas.selector;       assembly {  // solhint-disable-line no-inline-assembly          let ptr := mload(0x40)          mstore(ptr, selector)          mstore(add(ptr, 0x04), from)          mstore(add(ptr, 0x24), to)          mstore(add(ptr, 0x44), amount)           if lt(div(mul(gas(), 63), 64), _POD_CALL_GAS_LIMIT) {              mstore(0, exception)              revert(0, 4)          }          pop(call(_POD_CALL_GAS_LIMIT, pod, 0, ptr, 0x64, 0, 0))      }  The design of RewardableDelegationPod however requires this and hence cannot work.  Despite   Within  RewardableDelegationPod.updateBalances()  the  call  to  the  DelegatedShare  token (which  is  ERC20Pods,  and  the  accounts  are  connected  to  at  least  the  farm  pod)  is  wrapped  within try/catch.  with best  effort  of  having  consistent  shares  the  accounting  is  totally  off.  A  transfer  of  the underlying  ERC20Pod  which  triggers  RewardableDelegationPod.updateBalances()  will  never successfully execute registration[_delegate].burn(from, amount)/ registration[_del egate].mint(from,  amount).  These  calls  only  succeed  when  updateBalances()  is  called  with sufficient gas, e.g. using DelegatedShare.addPod().  annotated   function   being   itself   the     The  root  of  the  issue  has  been  addressed  in  ERC20Pods.  The  amount  of  gas  for  each  of  the  calls  in ERC20Pods._updateBalances()  is  no  longer  hardcoded  in  ERC20Pods  but  passed  as  constructor parameter.  The  ERC20Pods  that  is  DelegatedShare  has  a  fixed  100_000  gas  for  each  of  the in callbacks.  ERC20Pods->RewardableDelegationPod->ERC20Pods``, developers must be careful to set the correct amount of gas in each of them for the system to work.  ERC20Pods   stacked   When   two   like   are   function  RewardableDelegationPod.updateBalances  has  been  updated   to  call The  mint()/burn() without try/catch blocks so that every call to DelegatedShare.mint()/burn() must be successful.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "6.3   Allowances Not Completely Disabled", "body": "  BasicDelegationPod  overwrites  and  inhibits  functions  transfer,  transferFrom  and  approve.  The increaseAllowance  and  decreaseAllowance  functions  inherited  from  OpenZeppelin's  ERC20 implementation are not overridden and hence can be used.    The functions increaseAllowance and decreaseAllowance have been explicitely disabled.  1inch - Delegation -   11  CorrectnessMediumVersion1CodeCorrected          \f6.4   Broken C-E-I Pattern  in  The  check-effects-interaction  pattern  delegated  mapping  after  _updateAccountingOnDelegate, this could lead to reentrancy or other unexpected behaviors.  function  BasicDelegationPod.delegate.  The upon contract   interaction   possible   updated   is   is   a     The mapping update and event have been moved before the call to _updateAccountingOnDelegate.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "6.5   Inconsistency and Zero Address Check on ", "body": " register()  In function register(IDelegatedShare shareToken, address defaultFarm), it is possible to provide  shareToken=address(0),  this  would  allow  one  user  to  add  a  default  farm  for  the  zero address, and to call on of the register() functions once again, which should not be possible.    The  register(IDelegatedShare  shareToken,  address  defaultFarm)  function  has  been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "6.6   No Event upon Registering Delegatee", "body": "  Events  are  used  to  be  informed  of  or  to  keep  track  of  transactions  changing  the  state  of  a  contract. Generally, any important state change should emit an event.  Both functions used to register delegatees do not emit an event, hence for an observer it`s hard to track new delegatees.    Two  events  RegisterDelegatee  and  DefaultFarmSet  have  been  added,  and  are  emitted  resp. when a new delegatee registers, and when a default farm is added.  1inch - Delegation -   12  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "7.1   Users Must Add Farm if Default Farm Is", "body": " Updated  The deployed DelegatedShare contracts may not have a farm associated with them directly. If a farm is added later on, the users must either re-delegate or manually add the farm Pod on the DelegatedShare contract themselves.  possible   using It's  DelegatedShare.remove/removeAll()  but  still  keep  delegating  to  this  delegatee.  Users  must  be careful and understand the consequences of their actions.  remove   himself   default   from   farm   user   the   for   an   to   1inch - Delegation -   13  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-delegation/"}, {"title": "5.1   Certain Inputs Unchecked in Constructor", "body": "  When  new  fees  are  committed  through  the  commit_new_fee  function  they  are  checked  against  the respective  maximum  values  to  prevent  mistakes.  However,  when  the  fees  are  initially  set  inside  the constructor no such check is performed. Hence, initial fees might be outside the permitted value range.  Similarly,  when  the  amplification  factor  is  changed  through  ramping,  it's  value  range  is  checked. However, during the constructor this check for the amplification factor does not take place.  Risk  accepted:  As  deployment  is  a  rare  event  and  as  deployed  contracts  will  be  checked  by  the development team, there is no immediate need to add these checks. An incorrect contract can be \"killed\".  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "5.2   Ramping Down Might Incentivize Delayed", "body": " Liquidity  While  the  amplification  factor  is  ramping  down  in  an  imbalanced  pool,  liquidity  providers  have  an incentive to wait before providing extra liquidity. This is because they will receive more liquidity tokens in the  future  for  the  same  liquidity.  In  the  extreme  case  of  a  maximally  sharp  ramp  down  and  a  very imbalanced pool, waiting for ten minutes provides roughly 0.14% additional liquidity tokens.  However, this only holds as long as no further fees are accumulated during this time and as long as no re-balancing takes place inside the pool and hence constitutes a fairly unlikely scenario.  Curve.Finance - Curve ETH/sETH -   9  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedSecurityLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                   \fRisk accepted: As mentioned above this only applies for very sharp ramps. As the DAO will control the parameter  of  these  ramps,  the  DAO  can  also  ensure  that  the  sharpness  is  low  enough  to  avoid  any issues.  Curve.Finance - Curve ETH/sETH -   10    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Reentrancies   -Severity Findings   Redundant Use of RATES and PRECISION    _xp and _xp_mem Redundant Array Access    get_D Should Handle the Case of Non-convergence   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "6.1   Reentrancies", "body": "  0  0  1  3  1. During the execution of remove_liquidity and remove_liquidity_imbalance multiple asset transfers are made. One of these assets is ETH, while the others are ERC-20 tokens. The transfer of  ETH  can  lead  to  the  following  reentrancy.  Through  the  transfer  of  ETH,  the  execution  might reenter the contract and call donate_admin_fees. Note that this requires owner privileges. Inside donate_admin_fees, the internal balances mapping for the ERC-20 tokens will be updated as follows:  self.balances[i] = ERC20(coin).balanceOf(self)  This assignment is incorrect in this context as the contract still holds the tokens that are about to be transferred  due  is  complete: self.balances[i] > ERC20(coin).balanceOf(self). This breaks an important invariant in the contract.  liquidity.  Hence,  after   transaction   removed   the   the   to   2. During the call to withdraw_admin_fees an ETH transfer takes place. The transfer of ETH can lead  to  the  following  reentrancy.  Through  the  transfer  of  ETH,  the  execution  might  reenter  the contract  and  call  donate_admin_fees.  Note  that  this  requires  owner  privileges,  but  these  were already needed for withdraw_admin_fees. As a result, the admin fees for some of the coins will be  donated  while  the  admin  fees  for  other  coins  will  be  withdrawn,  leading  to  a  state  that  is  only reachable through a reentrancy.  3. Certain admin functions have no reentrancy protection. Hence, they can be called in a reentrancy from any of the functions that transfers ETH. However, for those reentrancies the only effects are incorrectly  ordered  events.  As  an  example,  a  NewFee  event  could  be  emitted  in  between  multiple events belonging to a remove_liquidity call.  Code  corrected:  Additional  Reentrancy  Guards  were  added.  These  now  also  cover  the  functions donate_admin_fees and apply_new_fee among others.  Curve.Finance - Curve ETH/sETH -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedSecurityMediumVersion1CodeCorrected        \f6.2   Redundant Use of RATES and PRECISION  RATES  is  a  constant  vector  containing  in  all  cells  the  value  10**18.  PRECISION  is  a  constant  of  value 10**18.  There are cases, such as in exchange, where the value of a cell of RATES is divided by PRECISION. This division is redundant.  rates: uint256[N_COINS] = RATES # Both multiplication with rates[i] and division with PRECISION can be avoided x: uint256 = xp[i] + dx * rates[i] / PRECISION   The code was changed accordingly to remove the redundancies and to save gas.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "6.3   _xp and _xp_mem Redundant Array Access", "body": "  In  both  _xp  and  _xp_mem  the  array  results  is  initialized  with  the  array  RATES.  However,  results later  ends  up  equal  to  self.balance.  This  is  because  of  the  multiplication  (with  result[i])  and  a redundant division (with LENDING_PRECISION). Note, that RATES equals to LENDING_PRECISION for all i. In the general case this code is useful, however for this token pair, it provides no additional value. RATES and LENDING_PRECISION are constants, the gas overhead is fairly low.  result: uint256[N_COINS] = RATES for i in range(N_COINS):     result[i] = result[i] * self.balances[i] / LENDING_PRECISION return result   The code was changed accordingly to remove the redundancy and to save gas.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "6.4   get_D Should Handle the Case of", "body": " Non-convergence  The calculation of the invariant D is limited to 255 steps. If there is no convergence then a wrong invariant is returned. The invariant is used to mint liquidity provider tokens. Thus, incorrect number of tokens can be minted. For the case of non-convergence, a verification step of the computed solution could be added.  Code  corrected:  The  new  implementation  reverts  in  case  of  non-convergence.  This  ensures  that  no faulty results are used for further computation.  Curve.Finance - Curve ETH/sETH -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f7   Notes  We leverage this section to highlight further findings that are not necessarily issues.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "7.1   Content of Events", "body": "  The events RemoveLiquidityImbalance and AddLiquidity contain the value D1 which represents the intermediate calculation of the invariant. Including D2 might be more helpful.  The  event  RemoveLiquidityOne  does  not  include  the  information  which  coin  was  removed  from liquidity. That might be relevant information.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "7.2   Fee Avoidance", "body": "  It  is  theoretically  possible  to  avoid  fee  payments  completely  by  repeatedly  exchanging,  adding  or removing such small amounts that fees are zero due to arithmetic errors. This results in a loss of fees for both  fees  will  be overcompensated  by  the  additional  gas  costs.  Hence,  such  a  scenario  would  only  be  realistic  in  the context of Zero-Gasprice Transactions.  liquidity  providers  and  admins.  However,   in  almost  all  cases   the  saved   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "7.3   Incentive to Remove Liquidity", "body": "  There  might  be  an  incentive  for  liquidity  providers  to  remove  liquidity  while  the  amplification  factor  is ramped  down.  In  case  of  a  really  imbalanced  pool  and  a  very  rapid  ramping  down  of  the  amplification factor,  the  following  sequence  might  leave  the  liquidity  provider  with  more  liquidity  tokens  that  they started with:  1. Remove liquidity by withdrawing only the non-scarce asset  2. Wait for the ramping to continue  3. Re-add the removed asset to regain liquidity tokens  In case of a very imbalanced pool and a sharp ramp, the liquidity provider could end up with 0.14% more liquidity tokens than they started with by waiting just ten minutes in step 2. This, however, only works if no other transactions take place inside the pool.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "7.4   Inefficiencies When Removing Single Coin", "body": "  When removing just a single coin from the pool liquidity, the remove_liquidity_one_coin function can  be  used.  However,  the remove_liquidity_imbalance function and just setting all values except for the desired one to zero. In  our  limited  experiments,  the  biggest  difference  occurred  when  remove_liquidity_imbalance provided 0.00008% additionally withdrawn assets.  in  certain  cases   less  efficient   than  using   function   this   is   Curve.Finance - Curve ETH/sETH -   13  NoteVersion2NoteVersion1NoteVersion1NoteVersion1              \fis   the   difference   Hence,  the remove_liquidity_one_coin  function  is  generally  expected  to  have  lower  gas  costs.  Finally,  it  is functions  as fee  important  remove_liquidity_one_coin  will  coin,  while remove_liquidity_one_coin will pay a roughly equivalent amount of fees in all coins.  two  the  for  the  withdrawn   is  different  in   structure  only   and  mostly   Furthermore,   negligible.   to  note   small   fees   very   that   pay   the   Curve.Finance - Curve ETH/sETH -   14  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-curve-eth-seth/"}, {"title": "5.1   Inefficient Defaulting to _newton_y", "body": "  The analytical solution implemented in get_y defaults back to the iterative _newton_y in the following situation:  CS-TRICRYPTO-NG-001  if sqrt_arg > 0:     sqrt_val = convert(isqrt(convert(sqrt_arg, uint256)), int256) else:     return [self._newton_y(_ANN, _gamma, x, _D, i), 0]  However, this means that the _newton_y starts over from scratch and has to recalculate everything from the initial values. Instead, a new method could be written that uses the existing values for a, b, c, and d which calculates K0 using Newton's method to solve the equation: 0 + cK0 + d = 0  0 + bK 2  aK 3  Then,  the  value  for  y  could  be  determined  from  this  result.  This  way,  the  get_y  function  can  return  a useful value for K0 instead of just defaulting to 0. This value can then be used as an initial guess for the next call to newton_D, saving further gas in the future.  Acknowledged:  Defaulting  to  _newton_y()  is  rare  when  running  the  new  code  on  historic  tricrypto  data,  so  Curve accepts the risk of incurring more gas costs in rare edge cases.  Curve - tricrypto-ng -   12  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedCodePartiallyCorrectedRiskAcceptedDesignLowVersion1Acknowledged              \f5.2   Typo in Event, Unused Variables  Event  UpdatePoolImplementation  first  argument  called _implementtion_id.  Field  token  in  struct  PoolArray  of  CurveTricryptoFactory  is  unused. Argument calc_price of _calc_withdraw_one_coin() is unused.  in  CurveTricryptoFactory  has   CS-TRICRYPTO-NG-002  Code partially corrected:  The token field of the PoolArray struct was removed. The calc_price argument was removed from the _calc_withdraw_one_coin() function.  The first argument of the UpdatePoolImplementation event was changed to _implemention_id, which is still spelled incorrectly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "5.3   CREATE in Pool Deployment Could Reuse", "body": " Addresses on Different Chains  If  the  address  of  the  pool  factory  is  the  same  on  two  blockchains,  then  the  deployment  addresses  of pools will match on different chains, even if the pool parameters are different (different coins). This can result in user mistakes or scam attempts.  CS-TRICRYPTO-NG-003  Risk accepted:  Curve accepts the risk of pool contracts on different chains having the same address.  Curve - tricrypto-ng -   13  DesignLowVersion1CodePartiallyCorrectedSecurityLowVersion1RiskAccepted                \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  5  10  -Severity Findings  -Severity Findings   Loss of Precision in get_p() for Some Values of A   -Severity Findings   First Depositor Can Manipulate the Share Value to Steal Future Deposits    Safety Parameters Differ Between Factory, Swap, and Math Contract    Simpler Price Calculations    Unsafe Operations    _log2() Returns Incorrect Results   -Severity Findings   Admin Can Set Unsafe Parameters Through commit_new_parameters()    Fee on remove_liquidity_one_coin() Is Computed on Initial Balance   Incomplete Validation of Coins in Factory   Initial Value K0_prev Recalculated Needlessly    Magic Number 10000 Used Instead of Constant A_MULTIPLIER    Math Implementation Cannot Be Upgraded in the Factory    No Getter for Length of Markets List in Factory    Pool Registered Twice in the Markets List for Each Key    Possible Precision Loss in get_y    Redundant Asserts in Call to _newton_y()   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.1   Loss of Precision in get_p() for Some Values", "body": " of A  Line 851 of CurveCryptoMathOptimized3.vy performs a division of ANN by 10000:  CS-TRICRYPTO-NG-014  unsafe_div(ANN, 10000)  Value ANN ranges from 2700 to 270000000. The division can incur a substantial loss of precision that affects the return value of get_p(). With ANN = 1707629, the current USDT/WBTC/WETH A value, a price error of close to 1% is returned by get_p()  Curve - tricrypto-ng -   14  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected          \f  The  order  of  operation  has  been  modified  so  that  the  division  by  10000  is  performed  when  the denominator has sufficient precision. The relative loss of precision on the c coefficient is now at most of 1e-5.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.2   First Depositor Can Manipulate the Share", "body": " Value to Steal Future Deposits  A malicious user can mint a single wei of shares before any deposit exists, then increase the price of the single  share  through  a  direct  transfer  to  the  pool  followed  by  calling  claim_admin_fees(),  which sweeps unaccounted tokens and recomputes D. The next depositors will suffer severe rounding errors on the number of shares they receive.  The shares distributed for the next deposits are calculated according to  CS-TRICRYPTO-NG-004  d_token = token_supply * D / old_D - token_supply ... d_token -= 1  Since  token_supply  will  be  1,  if  D  is  between  2*old_D  and  3*old_D,  the  tokens  received  by  the victim  will  round  down  to  zero,  but  their  deposit  will  still  be  transferred  to  the  pool.  old_D  is  under complete control of the attacker, who can steal legitimate deposits by investing half of the deposit value.    The  share  value  manipulation  was  enabled  by  being  able  to  call  claim_admin_fees()  to  increase significantly the value of single shares, when the total supply is low. claim_admin_fees() now will not gulp tokens when the total supply is below 10**18. This makes the attack unfeasible, while not affecting general operation, since the total supply in normal conditions will be in the order of magnitude of the D parameter, which is between 10**17 (generally more) and 10**33.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.3   Safety Parameters Differ Between Factory,", "body": " Swap, and Math Contract  CS-TRICRYPTO-NG-016  Safety bounds on pools parameters are different in the factory and the math contract.  Some are more restrictive in the factory:  1. MAX_GAMMA is 2*10**16 in the factory and swap, and 5*10**16 in MATH  2. MIN_A is 27000 in the factory and 2700 in MATH and swap  Some are less restrictive in the factory, which may lead to the deployment of invalid pools:  1. MAX_A is 27*10**9 in the factory, but 27*10**7 in MATH and swap  Curve - tricrypto-ng -   15  SecurityMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  1. MAX_GAMMA is 5*10**16 across all contracts.  2. MIN_A is 2700 across all contracts.  3. MAX_A is 27 * 10**7 across all contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.4   Simpler Price Calculations", "body": "  The  derivation  of  the  price  calculations  leads  to  more  expensive  calculations  than  necessary.  The  gas costs  of  the  get_p  can  be  greatly  reduced  by  simplifying  the  formula  for  the  price.  For  example,  by defining the value G as follows:  The formula for the price of y with respect to x becomes:  G \u22c5 K0 = 2K0  3 \u2212 K0  2(2\u03b3 + 3) + (\u03b3 + 1)2  CS-TRICRYPTO-NG-017  An efficient implementation of this formula can reduce the costs of the price calculation by around 66%.  py = x y \u22c5  G \u22c5 K0 + N NA\u03b32K0 G \u22c5 K0 + N NA\u03b32K0  y D x D    The suggested formula was implemented in get_p. The _snekmate_mul_div function was removed as it was no longer used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.5   Unsafe Operations", "body": "  Some  multiplications  in  the  get_y  function  are  performed  using  unsafe_mul.  However,  several  of these can potentially overflow:  1. The following multiplication in the calculation of b can overflow:  CS-TRICRYPTO-NG-019  unsafe_mul(unsafe_mul(unsafe_div(D**2, x_j), gamma**2), ANN)  For example with the following values:  D=10**33, x_j=10**31, gamma=5*10**16, ANN=2.7*10**8  In this case, the result is greater than 2**255 and hence overflows the int256 type.    The outermost unsafe_mul, where the second factor is ANN, which could cause an overflow, has been replaced with a safe multiplication.  2. This multiplication occurs when calculating delta1:  unsafe_mul(9, a * c)  Curve - tricrypto-ng -   16  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \fIt can overflow when 2**255 / 9 < a*c < 2**255 / 3. Previously, only the multiplication of 3a * c is done using overflow checks.    The expression is now evaluated as 3 * (unsafe_mul(3, a) * c), which is safe.  3. Again in the calculation of delta1:  unsafe_mul(27, a**2)  This can overflow when a**2 is close to 2^255, but not greater. For example, this can occur when b is very close to zero.    The expression has been replaced with 27 * a**2, which is safe.  4. Lastly, the following multiplication in the calculation of sqrt_arg could potentially overflow when  delta0**2 is close to 2^255:  unsafe_mul(4, delta0**2)    The expression has been replaced with 4 * delta0**2, which is safe.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.6   _log2() Returns Incorrect Results", "body": "  Results of function _log2() in CurveCryptoMathOptimized3 are off by one.  CS-TRICRYPTO-NG-009  Example:  In [2]: math.log2_(2**1) Out[2]: 0  In [3]: math.log2_(2**2) Out[3]: 1  In [4]: math.log2_(2**130) Out[4]: 129  In [5]: math.log2_(2**255) Out[5]: 254  In [6]: math.log2_(2**256-1) Out[6]: 254  The only values for which a correct result is produced are x = 0, and x in [2**128, 2**129-1]  In [7]: math.log2_(2**0) Out[7]: 0  In [8]: math.log2_(2**128)  Curve - tricrypto-ng -   17  CorrectnessMediumVersion1CodeCorrected        \fOut[8]: 128  In [9]: math.log2_(2**129-1) Out[9]: 128    The  custom  _log2()  implementation  has  been  replaced  with  Snekmate  log_2().  The  new implementation is correct, except for the value of log2(0), which evaluates to 0 but which ought to be undefined.  In  the  context  where  _snekmate_log_2()  is  used,  which  is  evaluation  of  the  cube  root, returning 0 for log2(0) leads to the correct result.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.7   Admin Can Set Unsafe Parameters Through ", "body": " commit_new_parameters()  The  same  bounds  are  not  applied  when  setting  parameters  at  commit_new_parameters().  CS-TRICRYPTO-NG-005  initialization  or  with  mid_fee can be set down to 0 through commit_new_parameters(), but must be at least MIN_FEE in deploy_pool().  allowed_extra_profit  can  be  set  commit_new_parameters(), but it can be at most 10**16 with deploy_pool().  to  values  between  10**16  and  10**18   through  Specification changed:  The  MIN_FEE  check  has  been  allowed_extra_profit has been increased from 10**16 to 10**18  removed   from   the   factory.  Max  value   for  parameter  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.8   Fee on remove_liquidity_one_coin() Is", "body": " Computed on Initial Balance  The fee for remove_liquidity_one_coin() is computed in _calc_withdraw_one_coin() at line 1349 as  CS-TRICRYPTO-NG-015  fee: uint256 = self._fee(xp)  At  this  point,  xp  is  still  the  unchanged  balance  of  the  pool.  Removing  liquidity  with  one  coin  from  a perfectly  balanced  pool,  and  making  it  unbalanced,  will  ask  for  mid_fee.  Making  an  unbalanced  pool balanced by removing liquidity will ask for out_fee. This is the opposite of what should happen.    Curve - tricrypto-ng -   18  DesignLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1CodeCorrected                \fA  rough  but  gas  inexpensive  calculation  of  the  resulting  balance  is  performed,  for  the  purpose  of calculating the fee. The fee calculation is not exact but more accurate than in the previous version.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.9   Incomplete Validation of Coins in Factory", "body": "  Coins in a pool shouldn't be duplicated, the following line in CurveTricryptoFactory.vy asserts it:  CS-TRICRYPTO-NG-008  assert _coins[0] != _coins[1] and _coins[1] != _coins[2], \"Duplicate coins\"  However,  the  case  where  coins[0]  ==  coins[2]  is  not  covered.  Therefore,  a  pool  could  be deployed with the same coin listed twice.    The missing check has been included.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.10   Initial Value K0_prev Recalculated", "body": " Needlessly  The value K0_prev is used to compute an initial value for newton_D(). In _exchange(), K0_prev is first computed during the call to MATH.get_y(), but is discarded and the same value is recomputed a few lines later in MATH.get_K0_prev(). This is unnecessary since the same value is returned during both calls.  The method get_K0_prev() of CurveCryptoMathOptimized3 is redundant.  CS-TRICRYPTO-NG-018    The  K0_prev  value  obtained  from  MATH.get_y()  is  now  used.  The  get_K0_prev  function  was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.11   Magic Number 10000 Used Instead of", "body": " Constant A_MULTIPLIER  Despite  the  constant  A_MULTIPLIER  being  defined,  code  in  CurveCryptoMathOptimized3.vy  at lines 737, 766, 835, 851 uses the magic number 10000 directly.  CS-TRICRYPTO-NG-010    Curve - tricrypto-ng -   19  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe magic numbers have been replaced with the constant.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.12   Math Implementation Cannot Be Upgraded in", "body": " the Factory  New  pool  implementations  can  be  deployed  in  the  factory,  but  the  math  implementation  can't  be changed.  The  event  UpdatePoolImplementation  is  unused.  A  new  pool  implementation  using another math contract could still be added to the factory, by changing the hardcoded value of the math contract in the pool implementation's constructor, instead of receiving it from the factory.  CS-TRICRYPTO-NG-011    Function  set_math_implementation  has  been  introduced  in  the  factory  so  that  the  admin  can change the math implementations of newly deployed pools.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.13   No Getter for Length of Markets List in", "body": " Factory  Private variable self.market_counts does not have a getter. The only way to know how many pools have been deployed for a coin pair is to iterate find_pool_for_coins() until a zero value is returned.  CS-TRICRYPTO-NG-012    Public function get_market_counts has been introduced to return the market count for a token couple.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.14   Pool Registered Twice in the Markets List for", "body": " Each Key  The following logic includes pools in the self.markets[key] list of the factory:  CS-TRICRYPTO-NG-013  for coin_a in _coins:     for coin_b in _coins:          if coin_a == coin_b:             continue          key: uint256 = (             convert(coin_a, uint256) ^ convert(coin_b, uint256)  Curve - tricrypto-ng -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f        length = self.market_counts[key]         self.markets[key][length] = pool         self.market_counts[key] = length + 1  Each coin pair is iterated twice, first as (A,B) and then as (B,A). The keys for the two pairs are the same. As a consequence, each pool is included twice for a certain key.    The code has been refactored so that the three token couples are now individually added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.15   Possible Precision Loss in get_y", "body": "  In the get_y function, additional precision is added conditionally:  CS-TRICRYPTO-NG-007  d0: int256 = abs(unsafe_mul(3, a) * c / b - b)  # <------------ a is smol.  divider: int256 = 0 if d0 > 10**48:     divider = 10**30 elif d0 > 10**44:     divider = 10**26 elif d0 > 10**40:     divider = 10**22 elif d0 > 10**36:     divider = 10**18 elif d0 > 10**32:     divider = 10**14 elif d0 > 10**28:     divider = 10**10 elif d0 > 10**24:     divider = 10**6 elif d0 > 10**20:     divider = 10**2 else:     divider = 1  additional_prec: int256 = 0 if abs(a) > abs(b):     additional_prec = abs(unsafe_div(a, b))     a = unsafe_div(unsafe_mul(a, additional_prec), divider)     b = unsafe_div(b * additional_prec, divider)     c = unsafe_div(c * additional_prec, divider)     d = unsafe_div(d * additional_prec, divider) else:     additional_prec = abs(unsafe_div(b, a))     a = unsafe_div(unsafe_mul(a, additional_prec), divider)     b = unsafe_div(b * additional_prec, divider)     c = unsafe_div(c * additional_prec, divider)     d = unsafe_div(d * additional_prec, divider)  Curve - tricrypto-ng -   21  DesignLowVersion1CodeCorrected        \fHowever,  there  are  some  cases  where  divider  >  additional_prec  and  a  precision  loss  occurs instead. For example, when b \u00bb a, divider can still be as large as 10**18, but additional_prec will be 1. Therefore, up to 18 decimals are removed from a, b, c and d, resulting in a precision loss.  It  should  be  considered  whether  it  is  necessary  to  adjust  the  decimals  in  the  case  where divider > additional_prec.    The  additional  precision  calculations  were  incorrect  in  the  original  version.  The  else  branch  has  been updated to the following:  else:     additional_prec = abs(unsafe_div(b, a))     a = unsafe_div(a / additional_prec, divider)     b = unsafe_div(unsafe_div(b, additional_prec), divider)     c = unsafe_div(unsafe_div(c, additional_prec), divider)     d = unsafe_div(unsafe_div(d, additional_prec), divider)  Curve also provided an explanation for the precision adjustment:  The idea behind this is that a is always high-precision constant 10**36 / 27 while b, c, and d may have  excessive  or  insufficient  precision,  so  we  compare  b  to  a  and  add  or  remove  precision  via additional_prec. But we should also take into account not only difference between a and other coefficients, but their value by themselves (10**36 precision will lead to overflow if coin values are overflow.  The reduce  high),  divider > additional_prec case is fine unless it produces vulnerability.  use  divider   precision   so  we   avoid   and   to   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.16   Redundant Asserts in Call to _newton_y()", "body": "  The arguments of get_y() are checked to be in a reasonable range through the following asserts:  # Safety checks assert _ANN > MIN_A - 1 and _ANN < MAX_A + 1, \"dev: unsafe values A\" assert _gamma > MIN_GAMMA - 1 and _gamma < MAX_GAMMA + 1, \"dev: unsafe values gamma\" assert _D > 10**17 - 1 and _D < 10**15 * 10**18 + 1, \"dev: unsafe values D\"  CS-TRICRYPTO-NG-006  The same checks are duplicated when entering the internal function _newton_y(), which is only called in the body of get_y()    The redundant asserts were removed from _newton_y().  Curve - tricrypto-ng -   22  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "7.1   Funds Could Be Transferred Before Callback", "body": "  When  using  exchange_extended(),  a  callback  to  the  caller  is  executed  to  transfer  the  inbound exchange  amount.  The  callback  is  executed  before  the  outgoing  tokens  are  received  by  the  user. Executing  the  callback  after  the  outgoing  tokens  have  been  received  would  allow  more  flexible  use cases, by acting as a flashloan.  Curve - tricrypto-ng -   23  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-tricrypto-ng/"}, {"title": "6.1   Curve Price Oracle Manipulation", "body": "  When estimating the value of a Curve LP token, get_virtual_price() is queried which describes the value increase through fees since the pool was created. The function may return a manipulated value for some  pools  where  transfers  have  callbacks  or  other  callbacks  to  users  are  made  (e.g.  ETH,  ERC677, ERC223, ERC777, ...) as the state of the pool may be inconsistent during the callback.  Due to the limiter of the Pricefeed which enforces that the price remains within a certain bound, Gearbox is largely protected hence the low severity rating. Nevertheless, the manipulated state of the Curve pool could be detected (at this point the pool's reentrancy lock is set) by the pricefeed.  Curve  is  aware  of  this  issue  and  new  pools  are  no  longer  affected.  Existing  pools  however  remain vulnerable. This issue is currently being addressed and affects various integrations. As of today not all have  been  fixed  hence  please  treat  this  issue  confidential  for  the  time  being.  Full  public  disclosure  is expected to be released soon.  Gearbox Protocol responded as follows:  Due to the LP price limiters, the attacker cannot practically inflate the asset value more than 2% of its real value. This discrepancy can be included in the asset's LT - the LT represents the maximal asset price drop during the liquidation period, but is not dependent on whether this price drop comes from actual market conditions, or price manipulation within a bound known in advance.  Gearbox Protocol - Gearbox V2 -   13  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedCodePartiallyCorrectedSecurityLowVersion1Acknowledged             \f6.2   Enable Supported Token on Any CreditAccount  CreditFacade.addCollateral() allows anyone to deposit funds on behalf of another credit account owner. Using this function has a different effect compared to simply transferring the funds to the credit account directly: It additionally enables the token for this credit account.  This may be a risk factor: If there is ever a bad token supported by a CreditManager, this immediately affects  all  CreditAccounts  of  this  CreditManager.  Users  are  not  safe  when  they  don't  hold  the  affected token.  Code partially corrected:  CreditFacade.addCollateral()  is  now  only  allowed  for  users  for  which  are  authorized  in  the transferAllowed mapping.  Gearbox Protocol notes:  This change should address an attacker sending a bad token to other users in order to break health factor calculation. However, there still remains a narrow vector whereas a token that was already on Credit Account is broken and reverts on balanceOf() (for example, stETH and SNX use proxies, and can be potentially changed to a broken implementation contract).  Currently,  this  is  not  addressed,  however,  should  this  transpire,  CreditFacade  could  be  quickly updated  to  ignore  this  token  (or  error-handle)  in  calcTotalValue(),  which  would  allow  to  liquidate affected positions.  Gearbox Protocol - Gearbox V2 -   14  SecurityLowVersion1CodePartiallyCorrected        \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  3  22  -Severity Findings  -Severity Findings  -Severity Findings   Multicall Actions During Pauses    Pricefeed of Oracle May Be Updated    Unable to Handle Missing Return Value   -Severity Findings   CumulativeDrop Calculation Rounding   twvUSD Contains Value in Underlying    Free Flashloan upon Open/Close    Adapters Ignore User Input    Add Token Without Liquidation Threshold    Checking for Valid Token Indices for Curve Pools Is Too Loose    Credit Accounts Give Very High Approval to Contract    CreditAccount Calls approve() on Unsupported Token    Curve Registry    CurveV1 Adapters: TokenOut Might Not Be Enabled at CreditAccount    Duplicate Error Code Used   Incorrect Comment After Refactoring   Incorrect Descriptions    Outdated Function Description    PriceOracle: Unused Timestamp    Read-only Reentrancy    Redundant Event Emission    Redundant Initialization    Reentrancy Into CreditFacade    Sanity Check of New Pricefeed    Unused allowedContractsSet    YearnV2Adapter: Different Behavior of Functions   Gearbox Protocol - Gearbox V2 -   15  CriticalHighMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedAcknowledgedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected       \f7.1   Multicall Actions During Pauses  During  a  liquidation,  the  liquidator  can  call  CreditFacade._multicall.  When  this  happens,  the ownership  of  the  credit  account  is  temporarily  passed  to  the  CreditFacade  to  allow  it  to  properly interact with the adapters. By using this feature, liquidators can swap tokens of the credit account to the underlying and, thus, they don't have to supply the underlying by themselves. This is a useful feature for any  liquidator,  even  for  the  emergency  ones.  During  pauses,  however,  the  functionality  of  the  credit manager is limited. One of the limitations is that CreditManager.transferAccountOwnership fails. This means that the liquidators cannot make any calls to the adapters.    The CreditManager now allows multiple calls to be made while the system is paused as long as the call is related to an emergency liquidation (whenNotPausedOrEmergency).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.2   Pricefeed of Oracle May Be Updated", "body": "  PriceOracle._addPriceFeed() is annotated with  /// @dev Sets price feed if it doesn't exist. If price feed is already set, it changes nothing /// This logic is done to protect Gearbox from priceOracle attack /// when potential attacker can get access to price oracle, change them to fraud ones /// and then liquidate all funds  The function does not enforce this, a second call to this function allows to update the pricefeed for the token.  Specification changed:  The description was erroneous and it was intended for the function to update the existing price feed. The description was updated to reflect that.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.3   Unable to Handle Missing Return Value", "body": "  to  Gearbox  V1  safeApprove()  has  been  replaced  by  approve()  function Compared  CreditAccount.approveToken. The interface inherited expects a boolean return value as defined in the ERC-20 specification. However, there are tokens such as USDT or OMG which do not adhere to this specification and have no return value on approve() and transfer.  in   Calling CreditAccount.approveToken() with these tokens will revert as the function call does not return the expected return value. Hence it's not possible for the new credit accounts to give approval on such tokens.    Gearbox Protocol - Gearbox V2 -   16  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChangedDesignMediumVersion1CodeCorrected                      \fThe  new  CreditAccount  implementation  no  longer  features  an  approveToken  function.  Approvals through  CreditManager.approveCreditAccount()  now  use  the  execute  function  of  the CreditAccount  which  allows  arbitrary  calls.  This  works  for  both,  the  new  implementation  and  the  old already deployed credit accounts.  If present, the returned boolean is checked. In case the approval is unsuccessful the code attempts to reset the approval to 0 before attempting the to approve the intended amount. This accounts for some token implementations enforcing this.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.4   CumulativeDrop Calculation Rounding", "body": "  The new fast collateral check is described as follows:  The fast check now ensures that the HF has not decreased significantly, rather than pure collateral value. The decrease is also tracked cumulatively across multiple swaps (hence the sum) - as soon as liquidationFee of cumulative loss is occurred, a full collateral check is performed and the cumulative sum is reset.  The computation is done as follows:  // compute cumulative price drop in PERCENTAGE FORMAT uint256 cumulativeDrop = PERCENTAGE_FACTOR -     ((amountOutCollateral * PERCENTAGE_FACTOR) / amountInCollateral) +     cumulativeDropAtFastCheck[creditAccount]; // F:[CM-36]  ...  if (cumulativeDrop <= slot0.feeLiquidation) {     cumulativeDropAtFastCheck[creditAccount] = cumulativeDrop; // F:[CM-36]     return; }  PERCENTAGE_FACTOR is 10`000. This allows precision up to 2 decimals. Resulting rounding errors per division might be up to 0.009999% Drops up to 0.009999...% per fast check are not detected nor added to cumulativeDropAtFastCheck. This may be done repeatedly.  Hence the requirement  The decrease is also tracked cumulatively across multiple swaps (hence the sum) - as soon as liquidationFee of cumulative loss is occured, a full collateral check is performed  strictly  speaking  does  not  hold.  Other  protocols,  e.g.  Maker  work  with  significant  higher  precision internally.  Is the resulting precision sufficient / can the potential loss be tolerated?  The new fast check compares cumulativeDrop and feeLiquidation. While both are percentages, they are different: The feeLiquidation will be taken from the actual total value while the cumulative drop has  been  calculated  taking  into  account  the  liquidation  thresholds.  Given  the  liquidation  thresholds  are strictly lower than 100% there is a safety margin before the system takes a loss.    The precision of the calculation was increased in RAY. The relevant code snippet now looks like this:  Gearbox Protocol - Gearbox V2 -   17  CorrectnessLowVersion3CodeCorrected        \f// compute cumulative price drop in WAD FORMAT        uint256 cumulativeDropRAY = RAY -            ((amountOutCollateral * RAY) / amountInCollateral) +            cumulativeDropAtFastCheckRAY[creditAccount]; // F:[CM-36]         // if it drops less that feeLiquiodation - we just save it till next check        // otherwise new fullCollateral check is required        if (            cumulativeDropRAY <=            (slot0.feeLiquidation * RAY) / PERCENTAGE_FACTOR        ) {            cumulativeDropAtFastCheckRAY[creditAccount] = cumulativeDropRAY; // F:[CM-36]            return;        }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.5   twvUSD Contains Value in Underlying", "body": "  The  public  function  CreditFacade.calcCreditAccountHealthFactor()  calculates  the  health factor in percent:  function calcCreditAccountHealthFactor(address creditAccount)     public     view     override     returns (uint256 hf) {     (, uint256 twvUSD) = calcTotalValue(creditAccount); // F:[FA-42]     (, uint256 borrowAmountWithInterest) = creditManager     .calcCreditAccountAccruedInterest(creditAccount); // F:[FA-42]     hf = (twvUSD * PERCENTAGE_FACTOR) / borrowAmountWithInterest; // F:[FA-42] }  The  naming  of  the  variable  twvUSD  is  misleading  since  the  total  weighted  value  returned  by calcTotalValue()  is  in  the  underlying.  Note  that  it  has  to  be  in  the  underlying  for  the  calculation hf = (twvUSD * PERCENTAGE_FACTOR) / borrowAmountWithInterest to be correct.    twvUSD was renamed into twv.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.6   Free Flashloan upon Open/Close", "body": "   introduced a protection which prevents free flashloans by increasing/decreasing debt within the same multicall. A variable within _multicall() tracks whether debt has already been increased in this call and if true prevents reducing debt.  This prevention however is not effective in a corner case:   When  a  new  credit  account  has  just  been  opened  through  openCreditAccountMulticall()  debt can be reduced within the multicall (free flashloan).  Gearbox Protocol - Gearbox V2 -   18  CorrectnessLowVersion3CodeCorrectedDesignLowVersion2CodeCorrectedVersion2                \f  The  internal  variable  tracking  whether  debt  has  already  been  increased  is  now  an  additional  input parameter for _multicall(). This allows the calling function openCreditAccountMulticall() to pass the information that debt has already been increased and hence the prevention also works in this corner case described in the issue above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.7   Adapters Ignore User Input", "body": "  The design of the Adapters is that they implement the same interface as the contract they connect to.  Illustrated  with  the  following  examples  taken  from  the  YearnV2  adapter  this  issue  highlights  that  user inputs are sometimes silently ignored:  /// @dev Deposit credit account tokens to Yearn /// @param amount in tokens function deposit(uint256 amount, address)     external     override     nonReentrant     returns (uint256) {     address creditAccount = creditManager.getCreditAccountOrRevert(         msg.sender     ); // F:[AYV2-4]      return _deposit(creditAccount, amount); // F:[AYV2-7,12] }  deposit() allows the user to specify the address of the recipient of the yVault shares. Obviously, this is not allowed as the funds must remain with the CreditAccount. The implementation uses \"safe defaults\", and ignores the user input. This behavior should be documented.  A more critical example is function withdraw and parameter maxLoss. The user may intend to set the acceptable maxLoss to a lower value. The implementation of the adapter however ignores this value and proceeds with the default. The result may be unexpected for the user.  function withdraw(     uint256 maxShares,     address,     uint256 maxLoss ) public override nonReentrant returns (uint256 shares) {     address creditAccount = creditManager.getCreditAccountOrRevert(         msg.sender     ); // F:[AYV2-4]      return _withdraw(creditAccount, maxShares); // F:[AYV2-9,14] }  Gearbox Protocol - Gearbox V2 -   19  DesignLowVersion1CodeCorrected        \f  There  is  now  a  withdraw()  override  that  correctly  passes  maxLoss  to  the  corresponding withdraw(uint256,address,uint256)  internal function  _withdrawMaxLoss function.  the  Yearn  vault,  using  an   in   Note: There are other adapter functions where the inputs are ignored - this happens in 2 cases:   The  adapter  passes  unmodified  msg.data  to  the  target  contract,  and  doesn\u2019t  need  some  of  the  inputs for adapter-specific operations;   The  input  is  the  recipient  address,  which  is  always  replaced  by  the  credit  account  address  (same  cases as the deposit(uint256,address) function described in the original issue).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.8   Add Token Without Liquidation Threshold", "body": "  Configurators may add a token to a credit manager using the function addTokenAllowedList. Initially, this token has a liquidation threshold of zero, the configurator must set a liquidation threshold using the function setLiquidationThreshold.  When no liquidation threshold is set for a token, the balance of this token that the credit accounts hold doesn't count towards the weighted value.    The  function  in  question  is  now  called  CreditConfigurator.addCollateralToken().  It  now accepts  uint16  liquidationThreshold  as  input  and  calls  _setLiquidationThreshold() immediately after adding the token. _setLiquidationThreshold() checks that the passed LT value is larger than 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.9   Checking for Valid Token Indices for Curve", "body": " Pools Is Too Loose  When translating the token index required in Curve pools to the token as known to Gearbox, the following require is executed:  function _get_token(int128 i) internal view returns (address) {     require(i <= int128(uint128(N_COINS)), \"Incorrect index\");     return (i == 0) ? token0 : token1; }  This  check  passes  for  invalid  values  like  negative  indices  and  exactly  one  index  too  high,  e.g.  i  =  2 passes for pools with N_COINS = 2 like in this example, although only i = 0 and i = 1 should pass. While  in  our  understanding  Curve  will  fail  when  called  with  invalid  tokens,  it  is  safer  to  ensure  that  no wrong token indices can be passed to not have to rely on Curve preventing execution with those indices.    Gearbox Protocol - Gearbox V2 -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fThe code has been refactored, the __getToken() function in CurveV1AdapterBase is strict and reverts for invalid indices.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.10   Credit Accounts Give Very High Approval to", "body": " Contract  Credit accounts give very high (25% of uint96.max) approval to the contracts adapters connect to. This approval remains even when the credit account is returned to the factory or being assigned to the next user.  Giving  excess  approvals  introduces  a  risk:  The  third  party  system  must  be  fully  trusted  and reviewed  that  these  approvals  cannot  be  accessed  when  not  called  by  the  holder  of  the  funds.  If  this does not hold, e.g. due to a bug, the funds of credit accounts are at risk.  One  https://medium.com/gelato-network/sorbet-finance-vulnerability-post-mortem-6f8fba78f109  example   where   such   loss   bug   led   to   a   of   funds:  Gearbox uses a trust-minimized approach by validating effects of adapters for token transfers instead of relying on correct execution. The recently discovered UniswapV3 bug would also have been prevented in case targeted allowances are given. Infinite approvals can undermine this approach. Approving only the necessary  funds  each  time  also  saves  gas  as  the  increased  allowance  is  reset  to  the  original  value, resulting in a refund which is significantly larger than the overhead cost of calling into a \"hot\" contract.    Gearbox Protocol responded:  For more fine-grained security configuration, there are now 2 allowance models:  1. Max allowance For highly-trusted protocols (such as Curve or Uniswap) approvals are always set to  type(uint256).max.  For  swap-like  operations  the AbstractAdapter._executeMaxAllowanceFastCheck()  function.  After  each  operation,  the system  returns  allowance  to  the  maximal  possible  value.  This  significantly  improves  UX  for WalletConnect usage, since users wouldn\u2019t have  is  encapsulated   logic   this   in   to approve tokens in the Uniswap/Curve interface after each transaction.  2.  Limited  allowance  For  other  protocols,  approvals  are  set  to  the  available  balance  on  the  Credit Account  before  the  operation,  and  then  reset  to  1  in  the  end.  This  would  prevent  an  attacker  from withdrawing assets from Credit Accounts, if they manage to compromise the target contracts.  and   safe   fastCheck  Maximal  AbstractAdapter._executeMaxAllowanceFastCheck()  AbstractAdapter._safeExecuteFastCheck(),  fullCollateralCheck operations have to be done manually within adapter functions.  respectively.   allowances   operations   for   are   set   Allowances   in and for  This mitigation still allowed to be circumvented in the following way:  The limited allowance approach for semi-trusted third-party contracts might be circumvented: Using CreditFacade.approve() the current owner of a credit contract may approve a supported token for any supported target contract. Such an approval remains when the credit account is returned to the factory and still exists when the credit account is assigned to the next user.  Gearbox Protocol further improved the security in the following way:  In order to improve the security of the CreditFacade.approve() function, upgradeableContracts was added  to  the  Credit  Facade.  This  is  a  list  of  contracts  with  practices  potentially  detrimental  to  Gearbox Protocol - Gearbox V2 -   21  SecurityLowVersion1CodeCorrected        \fsecurity.  This  includes  upgradeable  contracts,  contracts  that  can  make  arbitrary  calls  (even  with admin-only access), etc.  approve  now  reverts  when  called  on  a  contract  in  upgradeableContracts.  Currently,  the  Gearbox team  intends  to  include  only  Lido  into  the  list,  as  no  other  supported  contracts  appear  to  be upgradeable, or able to call transferFrom on CA assets.  To additionally secure assets accounts that don't belong to the attacker but have allowances (e.g., some non-zero allowances may remain after previous use), the first iteration of the Universal Adapter was implemented, which allows users to revoke all allowances on a newly-opened account.  Note:  CreditFacade.approve  is  mainly  used  to  support  WalletConnect  with  dApp  frontends.  Most frontends require non-zero allowance of a token to the contract, and do not allow any further action before  approve  is  called.  Thus,  a  function  to  set  allowance  separately  from  adapter  actions  is required.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.11   CreditAccount Calls approve() on", "body": " Unsupported Token  CreditManager.approveCreditAccount() approves token transfers on behalf of a credit account. The function calls the CreditAccount which then executes a call to the given tokens approve() function.  The function is annotated with:  /// @dev Approve tokens for credit account. Restricted for adapters only  Note that the comment is incorrect as it can also be called by the CreditFacade.  While  CreditFacade.approve()  does  check  whether  the  token  to  be  approved  is  supported,  the adapters  generally  do  not  check  this.  CreditManager.approveCreditAccount()  itself  does  not perform such a check on the given token address.  The lack of token validation may be used in an exploit.  Note the following should also be taken into account:   CreditAccounts  may  receive  other  tokens  e.g.  as  an  airdrop.  How  should  users  be  able  to  access/trade them?   A token may have been \"forbidden\". Does this only apply to a new incoming asset or does this also  block usage as an outgoing asset?    Token being supported is now checked in CreditManager.approveCreditAccount(). This means that the token will be verified regardless of whether the call comes from the CreditFacade or an adapter.  On additional notes:  CreditFacade  now  has  an  enableToken()  function  which  allows  the  Credit  Account  owner  to  enable any  token  and  include  it  in  the  collateral  computation,  as  long  as  this  token  is  supported  by  the  Credit Manager and is not forbidden. This can be used to handle airdropped tokens.  Whether  the  token  is  forbidden  is  only  checked  when  a  new  token  comes  in  and  is  being  enabled  (in CreditManager.checkAndEnableToken()). Whether an outgoing token is forbidden is not checked. This is  Gearbox Protocol - Gearbox V2 -   22  SecurityLowVersion1CodeCorrected        \fdeliberately done in order to allow positions in a forbidden token to be unwound after it was forbidden, by selling the token on Uniswap, closing/liquidating the account, etc.  outdated: annotation  The  /// @dev Approve tokens for credit account. Restricted for adapters only. The CreditFacade is also eligible to call this function.  function   is   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.12   Curve Registry", "body": "  The factory contract CurveLPFactory which deploys the curve price feeds has the address of the Curve registry hardcoded. Similarly, CurveV1_Base uses the hardcoded address.  According to the Curve Documentation of their registry contracts, the central source of truth in the Curve system  is  the  address  provider.  That  contract  allows  changing  the  registry  through  set_address() when the id parameter is set to zero. Currently, the oracle stores the registry as an immutable. Hence, in case the registry changes, the contract will utilize a wrong registry.    The Curve Registry is no longer used either by the price feeds or CurveV1_Base and hence this issue no longer applies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.13   CurveV1 Adapters: TokenOut Might Not Be", "body": " Enabled at CreditAccount  The  implementation  of  the  CurveV1_2/3/4  adapters  bears  the  risk  that  after  a  successful  action,  the incoming tokens might not be enabled at the CreditAccount.  Consider the following function:  function remove_liquidity(     uint256 amount,     uint256[N_COINS] memory min_amounts ) external virtual nonReentrant {     address creditAccount = creditManager.getCreditAccountOrRevert(         msg.sender     ); // F:[ACV1_2-3]      _enable_tokens(creditAccount, min_amounts);     _executeFullCheck(creditAccount, msg.data); //F:[ACV1_2-5,6] }  Parameter  min_amounts  serves  as  slippage  protection.  The  adapter  uses  it  to  enable  the  incoming tokens using the internal _enable_tokens function:  function _enable_tokens(     address creditAccount,     uint256[N_COINS] memory amounts ) internal {  Gearbox Protocol - Gearbox V2 -   23  CorrectnessLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                \f    if (amounts[0] > 1) {         creditManager.checkAndEnableToken(creditAccount, token0); //F:[ACV1_2-5,6]     }      if (amounts[1] > 1) {         creditManager.checkAndEnableToken(creditAccount, token1); //F:[ACV1_2-5,6]     } }  If  the  user  didn't  set  the  slippage  protection  (which  shouldn't  be  done  as  it  makes  the  transaction vulnerable to being sandwiched, resulting in worse exchange rates) the token might not be enabled in the credit account. This may remain undetected when the remaining assets at the credit account suffice to reach  a  health  factor  >  1.  Closing  such  a  credit  account  likely  leaves  those  tokens  behind  and  a  later borrower who realizes this could collect them. Also, if such a credit account becomes unhealthy and is liquidated, a liquidator could collect the tokens.    The function now enables all tokens of the pool, regardless of the min_amounts array. This is correct, since remove_liquidity() transfers tokens based on the current inventory of the pool, so there are only two scenarios in which it can return less than 2 tokens:  the user burns a very small amount of the LP token;  the pool is 100% unbalanced, which should not be practically achievable in Curve.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.14   Duplicate Error Code Used", "body": "  The library Errors contains error messages encoded as short strings to save on deployment cost and two  distinct  errors, contract  CC_INCORRECT_TOKEN_CONTRACT  and  CM_TOKEN_IS_ALREADY_ADDED,  which  prevents  users  from exactly determining the cause of the error.  size.  One  of   the  error   is  used   \"CFH\",   codes,   for     Text errors are being replaced with explicit Exceptions that are now being thrown on errors or constraint with in  violations.  IErrors.IncorrectTokenContractException  and ICreditManagerV2Exceptions.TokenAlreadyAddedException.  particular,   replaced   question   errors   were   In   In  the  current  version  of  the  code  the  library  Errors.sol  is  still  imported  and  used  by  several  system contracts, the duplicate error described above however has been corrected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.15   Incorrect Comment After Refactoring", "body": "  in  CreditManager.manageDebt  mentions   function  sometimes  shifts A  comment  newBorrowedAmount. This comment refers to a previous version of the code and isn't describing the current system.  that   the   Gearbox Protocol - Gearbox V2 -   24  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                  \f  The comment has been removed  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.16   Incorrect Descriptions", "body": "  PriceOracle:   The  function  description  of  addPriceFeed  in  both  the  contract  and  the  interface  definition  incorrectly mentions Eth  /// @param priceFeed Address of chainlink price feed token => Eth  In GearboxV2 the Chainlink pricefeed used is supposed to return a value in USD.  the return value in convertedToUSD() is incorrectly described as:  /// @return Amount converted to tokenTo asset  the  description  for  parameter  token  should  read  to  instead  of  from  in  the  convertFromUSD()` function   The description of fastCheck() is incorrect.   Not all functions in the interface are annotated.  CreditFacade:   The  description  of  both  functions  closeCreditAccount  and  liquidateCreditAccount  mention the outdated sendAllAssets.  CreditManager:   fastCollateralCheck still mentions WETH instead of USD   closeCreditAccount description mentions if sendAllAssets is true, this no longer exists.  Specification changed:  The aforementioned description issues have been rectified.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.17   Outdated Function Description", "body": "  There are frequent cases in which comments refer to previous functionality in the code which now has been  changed.  As  an  example,  the  description  of  function  closeCreditAccount  in  both  contracts, CreditFacade  and  CreditManager  describe  sendAllAssets  which  no  longer  exists.  Similarly  this applies  to  the  function  liquidateCreditAccount  of  the  CreditFacade  in  which  skipTokenMask allows this behavior now. .  Gearbox Protocol - Gearbox V2 -   25  CorrectnessLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1Speci\ufb01cationChanged                  \fSpecification changed:  Function annotations have been brought up-to-date.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.18   PriceOracle: Unused Timestamp", "body": "  function _getPrice(address token) internal view returns (uint256) {     require(         priceFeeds[token] != address(0),         Errors.PO_PRICE_FEED_DOESNT_EXIST     );      (         ,         //uint80 roundID,         int256 price, //uint startedAt, , //uint80 answeredInRound         ,         uint256 timeStamp,      ) = AggregatorV3Interface(priceFeeds[token]).latestRoundData();      return uint256(price); }  }  latestRoundData()  returns  several  values,  all  unused  values  except  timesTamp  are  dropped.  The value for timeStamp is handled but remains unused.    PriceOracle.getPrice()  now  uses  roundId,  answer,  updatedAt  and  answereInRound  to perform sanity checks on round data. The unused startedAt value is dropped.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.19   Read-only Reentrancy", "body": "  When  integrating  with  Gearbox,  developers  should  be  aware  of  read-only  reentrancy  opportunities. Assume a credit account (CA) which is controlled by a protocol (P) integrating with Gearbox and holds WETH, and a malicious user (E). Assume now that at some point the account becomes liquidatable:   E liquidates the account by calling CreditFacade.liquidateCreditAccount where the to  address is a smart contract controlled by E and convertWETH is true.   During  closure,  CreditManager.closeCreditAccount  is  called,  which  converts  WETH  to  ETH and sends it to to as seen in the following snippet:  Gearbox Protocol - Gearbox V2 -   26  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f_transferAssetsTo(creditAccount, to, convertWETH, enabledTokensMask);   At this point, the control of the execution flow is passed to the smart contract of to address.   The smart contract makes a call to P which queries the state of CA. CA will seem like it holds less value than it actually used to at the beginning of the transaction. The reason is that its state hasn't been fully updated but part of its holdings has been sent to another address.   Based  on  this  intermediate  state  of  the  CA,  P  might  proceed  incorrectly  and  end  up  in  an  unexpected state.    The line ` delete creditAccounts[borrower]; // F:[CM-9] ` was moved to the beginning of the function, right after the Credit Account for the borrower is first retrieved. This will make any calls to CreditManager.getCreditAccountOrRevert() in the middle of closeCreditAccount execution fail, since the record no longer exists in the mapping.  While  third-party  protocols  that  directly  query  the  state  through  a  saved  CA  address  may  still  be vulnerable, we will advise all integrators to use CreditManager.getCreditAccountOrRevert() to retrieve the address dynamically, as a security best practice.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.20   Redundant Event Emission", "body": "  When CreditFacade._disableToken is called, a TokenDisabled event is emitted even if the token was already disabled.    CreditManager.disableToken()  now  returns  whether  the  token  was  actually  disabled.  This  is  used  in CreditFacade._disableToken() to emit the event conditionally.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.21   Redundant Initialization", "body": "  In CreditConfigurator.constructor the following line can be found:  creditManager.upgradePriceOracle(address(creditManager.priceOracle())); // F:[CC-1]  This line upgrades the price oracle of the CreditManager with the same price oracle. Hence, this call is redundant.    The line has been deleted.  Gearbox Protocol - Gearbox V2 -   27  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f7.22   Reentrancy Into CreditFacade  The new CreditFacade featuring the new multicall functionality allows executing multiple actions including calls  to  the  adapters.  A  health  check  of  the  credit  account  is  only  done  once  after  all  calls  have  been executed,  not  in  between  calls.  In  between  calls  credit  accounts  may  be  in  an  unhealthy  state.  The internal  multicall  function  of  CreditFacade  itself  is  not  protected  against  reentrancy,  nor  are  some functions  of  the  CreditFacade  using  this  multicall  functionality.  Reentrancy  protection  is  present  in  the called  adapter  and  during  the  execution  of  certain  functions  of  the  CreditManager.  Note  that  the reentrancy  protection  used  works  per  contract:  Reentrancy  into  the  specific  contract  is  locked  at  the beginning of the function and the lock is released when the function call completes.  Aside  from  certain  functions  of  the  CreditFacade  itself  (which  are  handled  differently),  multicall  allows calling any function on external contracts which are valid adapters.  Furthermore, note that attacks are limited as credit account cannot be returned in the very same block it has been borrowed.  Nevertheless, extra care should be taken especially as untrusted code can be reached via the adapters. It might be more cautious to prevent reentrancy into the CreditFacade as this is not intended to be done.  Code corrected and Acknowledged:  All  remaining  non-restricted  CreditFacade  functions  have  been  covered  with  a  nonReentrant  modifier. This ensures that:   At most one multicall can be performed within a single transaction (internal _multicall() can only be  called from non-reentrant functions);   Only one of debt-managing functions (addCollateral, increaseDebt and decreaseDebt) can be called externally  within  a  single  transaction  (internal  counterparts  can  be  called  multiple  times  within  a multicall, barring flash loan protections).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.23   Sanity Check of New Pricefeed", "body": "  PriceOracle._addPriceFeed() contains the following sanity check:  require(     AggregatorV3Interface(priceFeed).decimals() == 8,     Errors.PO_AGGREGATOR_DECIMALS_SHOULD_BE_8 ); // F:[PO-2]  This check helps to ensure that the intended kind of pricefeeds returning a price with 8 decimal is passed, which USD-denominated Chainlink pricefeeds do.  The  sanity  check  could  be  enhanced  to  check  if  the  pricefeed  actually  implements  the  required functionality of the AggregatorV3Interface, notably whether function latestRoundData is implemented which is the function called by the PriceOracle to query the price.    _addPriceFeed() now performs extensive sanity checks on the newly added feed and token:  Gearbox Protocol - Gearbox V2 -   28  SecurityLowVersion1AcknowledgedCodeCorrectedDesignLowVersion1CodeCorrected                \fChecks that neither feed nor token are zero addresses; Checks that the token is a contract; Checks that the  price  feed  is  a  contract;  Checks  that  the  token  implements  decimals();  Checks  that  the  feed implements decimals() and it is equal to 8; Checks that the feed implements dependsOnAddress(); Checks  implements latestRoundData() (and performs sanity checks on the answer if skipPriceCheck() == false);  implements  skipPriceCheck();  Checks   feed   feed   that   that   the   the   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.24   Unused allowedContractsSet", "body": "  EnumerableSet.AddressSet  private  allowedContractsSet;  defined  in  the  CreditFacade  is unused. The very same variable exists in the CreditConfigurator where it actually is used.    Removed unused variable and corresponding getters.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "7.25   YearnV2Adapter: Different Behavior of", "body": " Functions  Functions  transfer  and  transferFrom  approve() however behaves differently simply returns true.  revert  with  Errors.NOT_IMPLEMENTED.  Function    approve(),  transfer()  and  transferFrom()  of  the  YearnV2Adapter  now  return  false  without doing anything.  Gearbox Protocol - Gearbox V2 -   29  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "8.1   Airdrops", "body": "  CreditAccounts may be eligible for airdrops, e.g. as they may have held a certain token when a snapshot was taken or as they may have interacted with a DeFi system a certain amount of times.  Users of a credit account must be aware that they lose participation in the airdrop when they return the credit account (close/liquidation).  At the moment when the information about an airdrop becomes public, this credit account may be in use or in the queue at the factory.  Depending on the value of the airdrop users may attempt to retrieve this credit account. The governance has the option to take out such accounts directly. Generally, airdrops can only be claimed by the credit account if this process can be triggered by a third party. Airdrops requiring the credit account to call a specific function generally won't work as no adapter supporting this exists.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "8.2   Free Flashloans", "body": "  Gearbox prevents users from increasing and decreasing their debt during a multicall and thus taking a free  flashloan.  However,  a  user  could  still  create  a  contract  that  executes  two  separate  multicalls,  one that  includes  a  debt  increase  and  one  that  includes  a  debt  decrease.  This  way,  a  free  loan  is  still possible.  It  is  important  to  note  that  the  amount  to  be  borrowed  during  the  loan  is  still  limited  by  the checks performed when an amount is borrowed from the pool.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "8.3   Renouncing Ownership", "body": "  In  Gearbox,  transfers  of  ownership  take  place  in  two  steps.  First,  the  previous  owner  defines  the  new owner  (pendingOwner)  and  the  new  owner  claims  the  ownership.  The  Claimable  contract  extends Ownable  meaning  that  the  old  owner  can  renounce  ownership.  Users  should  note  that  ownership renounce is ignored if a pending owner has been already defined since Claimable.claimOwnership does not check if the ownership has been renounced before.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "8.4   _safeTokenTransfer - Call to External", "body": " Address  When the boolean parameter convertToETH is set to true, WETH is unwrapped into Ether. This Ether is transferred  to  the  recipient  using  a  call,  the  gas  amount  passed  is  not  restricted.  At  this  point,  the execution may reach untrusted code.  Gearbox Protocol - Gearbox V2 -   30  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fThe function name \"safeTokenTransfer\" is due to the usage of OpenZeppelins SafeERC20 library. One must be careful to not misinterpret the function name and assume using this function is \"safe\" under all circumstances.  Gearbox Protocol - Gearbox V2 -   31  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2/"}, {"title": "5.1   Rounding Error Leads to Blocked Queue", "body": "  Rounding errors can block the processing of an operation eventually blocking the whole system. There are multiple instances of this issue.  CS-APYF-001   Redeeming  a  small  amount  through  the  master  vault  could  round  down  to  zero  one  of  the shares  computation  per  chain.  However,  a  zero  amount  shares  redemption  on ApyFlow.redeem()  reverts  because  a  computation  uses  the  number  of  shares  as  a denominator. The following computation fails in ApyFlow._redeem():  uint256 processedPricePerToken = (valueInAsset * (10 ** decimals())) / shares;  In BaseConcentratedLiquidityStrategy._redeem(), a rounding error in the calculation of the liquidity to be removed can lead the system to block as UniswapV3/QuickswapV3 does not allow removing 0 liquidity:      uint128 liquidity = uint128(     (_getPositionData().liquidity * shares) / totalSupply() );  In  BaseConcentratedLiquidityStrategy._deposit(),  a  the calculation of the liquidity to be added can lead the system to block as UniswapV3/QuickswapV3 does not allow adding 0 liquidity.  rounding  error   in    The same issues as above appears in BaseHedgedConcentratedLiquidityStrategy.  yldr.com - yldr.com -   14  SecurityDesignCorrectnessCriticalHighMediumAcknowledgedAcknowledgedLowDesignMediumVersion2Acknowledged              \fAcknowledged:  yldr.com replied:  There always will be ways of making deposit/redeem revert at some step of processing and block the queue.  Such  attacks  are  non-profitable  and  relatively  expensive  for  an  attacker  and  considered non-likely.  Even  if  attacks  will  happen,  we  have  admin  functionality  which  allows  skipping  of  such malicious operations or funds recovery in case of vault becoming fully non-functionable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "5.2   Inflating Shares Price", "body": "  The  exchange  rate  for  all  ApyFlowVault  contracts  depends  on  some  balances  of  the  assets  in  the smart contract. Consequently, any asset donation will be taken into account and increase the exchange rate of the vault, and the value of the shares.  A vault with a very small or equal to zero totalSupply, is therefore vulnerable to a price inflation attack.  A malicious user could first mint a small number of shares and then send a great amount of assets to the smart contract.  CS-APYF-002  subsequent   Any  computation assets.mulDiv(totalSupply_,  totalAssets_)  round  to  zero  if  the  deposit  amount  is  smaller than  the  exchange  rate,  leading  to  assets  being  transferred  to  the  contract  but  no  shares  minted  in exchange.  deposit   would   make   the   Even if the amount is greater than the exchange rate, the rest of the division would not be accounted for because  of  the  rounding  error,  leading  to  a  partial  donation  of  the  funds  to  the  current  vault  shares holders.  Client acknowledged and replied:  Our standard procedure is to deposit a small amount of funds (5-100 USD) into each newly created vault to test if it's functionable and to avoid an inflation attack.  yldr.com - yldr.com -   15  SecurityMediumVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Minting More Shares    Price Manipulation   -Severity Findings   A Deposit Could Be Stuck Because of Slippage    Fees Are Not Properly Harvested    Missing Calculation    Aave.ltv Cannot Be Updated   -Severity Findings   Underflow in Deposit Blocks the System    Zero Redemption Blocks the System    Dust in Deposits   Idling Assets Unused in readdLiquidity()    Leftovers Are Not Handled    Queue Processing Is Slow    Redemption of Small Amounts Is Impossible    SlaveCrossLedgerVault With a Zero Portfolio Score    Unused Function    minimumOperationValue Could Block Redeems   -Severity Findings   Discrepancy Between Computed and Actual Price per Token    Queue Could Be Stuck Because of Small-Amount Swaps   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.1   Minting More Shares", "body": "  2  4  10  2  The  _startDeposit()  function  in  the  MasterCrossLedgerVault  iterates  over  each  chain  and deposits  an  amount  proportional  to  their  associated  portfolio  score  returned  by  the  oracle.  In  the  case where the amount destined to this chain rounds down to zero, the chain is ignored in _deposit() and the loop continues and no message is sent to and received from the chain. This can allow a malicious user to mint more shares than the value they deposited.  The amount of shares minted is computed in the MasterCrossLedgerVault as follows:  CS-APYF-027  yldr.com - yldr.com -   16  CriticalCodeCorrectedCodeCorrectedHighCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedSecurityCriticalVersion2CodeCorrected         \fuint256 totalAssetsBefore = totalAssetsBeforeDeposit[opId]; uint256 totalAssetsAfter = totalAssetsAfterDeposit[opId]; uint256 deposited = totalAssetsAfter - totalAssetsBefore; uint256 shares; if (totalSupply() == 0) {     shares = totalAssetsAfter; } else {     shares = (deposited * totalSupply()) / totalAssetsBefore; }  For  a  fair  computation  of  the  shares,  totalAssetsBefore  should  denote  the  full  value  of  all  assets across all chains. totalAssetsBeforeDeposit[opId] is increased after a message is received from a slave chain that contains the total value of the assets held on the chain before the deposit of the user's assets. As no deposit is performed on the slave chain no such message is received.  The  next  important  aspect  to  understand  is  the  deposited  amount  does  not  depend  on  the  actual amount deposited by the user when the initiate the deposit. If the attacker donates to a pool used by an asset converter in the same transaction, the asset converter can receive a higher amount of the output token  than  the  current  price.  This  allows  the  attacker  to  take  advantage  of  the  rounding  down  errors caused  by  the  small  amount  originally  deposited  while  they  eventually  deposit  a  big  amount  to  the system.  Since the shares minted depend on the ratio deposited/totalAssetsBefore, the attacker is able to mint  a  big  amount  of  shares  as  they  increased  deposited  (by  manipulating  the  pool)  while  keeping totalAssetsBefore low (by skipping chains).  The  attacker  can  now  redeem  their  shares.  Redemption  works  a  bit  differently  than  depositing:  It  just iterates over all chains without taking into account the portfolio score but instead provides them with a relative  proportion  (shares  &  totalSupply),  so  that  each  SlaveCrossLedgerVault  can  use  this proportion to compute how many assets to redeem.  However,  for  totalAssetsBefore  to  be  updated  by  a  slave  vault,  a  cross-chain  deposit  must  have occurred, which isn't the case when the argument is zero in _deposit().  To sum up the attack, the attacker would:  1. Call  MasterCrossLedgerVault.deposit()  with  a  small  amount.  This  makes  every amount  round  down  to  zero  except  for  one  chain  which  would  have  a  very  small  amount deposited.  2. Increase this deposited amount by for example manipulating a liquidity pool.  3. Steal funds by directly redeeming the inflated number of shares minted.    A  new  type  of  message  has  been  introduced:  ZERO_DEPOSIT  to  handle  the  case  where  the  amount rounds down to zero. This allows chains to communicate their total assets even though no funds were deposited during the operation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.2   Price Manipulation", "body": "  CS-APYF-026  yldr.com - yldr.com -   17  DesignCriticalVersion1CodeCorrected        \fConcentrated liquidity strategies must be able to compute the price and value of their liquidity position for price  range  adaptation  and  accounting  purposes.  However,  current  price  computations  only  use manipulable pool data, which can consequently not be relied on to provide real market price and value.  Such manipulation leads to critical issues:  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.2.1   Manipulate the price range rebalance process:", "body": " The concentrated liquidity strategies should automatically adapt their price range when the current pool price  function readdLiquidity(),  which  heavily  depends  on  the  current  pool  tick.  The  pool  tick  is  heavily manipulable  and  could  be  used  by  an  attacker  to  make  the  strategy  provide  liquidity  at  a  manipulated price.  the  currently  set  range.  This  process  happens   is  above  or  under   the   in   function readdLiquidity() public virtual {     ...     (int24 currentTick, ) = _getPoolData();     int24 tickLowerToRebalance = data.tickLower + ticksUntilRebalance;     int24 tickUpperToRebalance = data.tickUpper - ticksUntilRebalance;     bool isInRebalanceRange = (tickLowerToRebalance > currentTick) || (tickUpperToRebalance < currentTick);     ...     require(         isInRebalanceRange ||             (pricePerTokenAfter >= (lastPricePerToken * 1001) / 1000)     );  An example attack flow on a USDC-WETH pool strategy:  1. Borrow a lot of ETH in a flash loan  2. Sell all ETH in the strategy's pool: Price and tick are now manipulated, price of ETH related to  USDC is much lower than the real market price  3. Call readdLiquidity() on the strategy: The current tick is now in the rebalance range, and  the function executes and moves liquidity around the current tick  4. Buy back ETH in the pool with every USDC received from step 2: Liquidity moved in step 3 is now  at  a  very  advantageous  price  for  the  attacker,  who  makes  a  profit  out  of  the  strategy's funds.  5. Repeat  Note that this attack depends on the strategy's liquidity size, as well as the pool's size and the fees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.2.2   Manipulate the strategy's exchange rate:", "body": " The shares exchange rate depends on the totalAssets() function that computes the total value of the strategy's funds.  function totalAssets() public view override returns (uint256) {     ...     (uint256 amount0, uint256 amount1) = LiquidityAmounts         .getAmountsForLiquidity(             sqrtPriceX96,             sqrtPriceAX96,             sqrtPriceBX96,             _getPositionData().liquidity         );     uint256 valueInUSD;     valueInUSD += pricesOracle.convertToUSD(token0(), amount0);     valueInUSD += pricesOracle.convertToUSD(token1(), amount1);  yldr.com - yldr.com -   18  \fHere,  amount0  and  amount1  will  depend  on  sqrtPriceX96,  which  is  the  current  price  of  the  pool. These amounts will then be converted to their real current market value in USD (which may not be close to the pool price).  Note that at any point in time, some assets might be idling in the smart contract.  This issue could lead to multiple consequences:   An attacker could potentially lower the price of the liquidity position and deposit assets that will be overvalued proportionally to the liquidity position, resulting in some extra shares being minted to the attacker.  Inflating the value of the strategy shares if they are used in an external protocol (for example as collateral).   Front-running a user deposit/redeem could become profitable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.2.3   Forced slippage:", "body": " readdLiquidity() is allowed to execute only if either the price of the pool is out of the current liquidity range or if the price per token after execution has increased. However, being able to manipulate the price of the liquidity pool makes it possible to execute the function on request.  An attacker could use this ability to force the pool to lose value in fees and slippage because of swaps happening during execution.  Note  that  this  list  of  potential  consequences  isn't  exhaustive  as  most  function  that  rely  on totalAssets() are vulnerable.    BaseConcentratedLiquidityStrategy.checkDeviation()   been The  modifier  implemented.  The  modifier  checks  whether  the allowedPoolOracleDeviation from the price reported by an external oracle. If this condition is not true the execution reverts. This means that users are unable to redeem and withdraw their assets during this period of time. Moreover, deposits iniated from the Master vault will be blocked for this period.  the  price  of  a  pool  deviates  more   than   has   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.3   A Deposit Could Be Stuck Because of", "body": " Slippage  In  MasterCrossLedgerVault,  processing  a  deposit  operation  in  the  queue  starts  by  swapping  the deposited  asset  with  the  main  asset  of  the  vault.  To  swap  in  between  assets,  the  vault  uses  an AssetConverter, which checks that the slippage does not exceed a fixed value.  CS-APYF-014  function _startDeposit(     ... ) internal {     uint256 mainAssetValue = assetConverter.safeSwap(         params.asset,         address(mainAsset),         params.value     );  yldr.com - yldr.com -   19  DesignHighVersion1CodeCorrected         \f    ... }  However,  in  the  case  of  a  big  deposit  where  the  deposited  asset  is  not  the  same  as  the  main  asset, swapping could be impossible without causing a greater slippage than the maximum expected one.  In  this  case,  the  vault  operations  would  be  stuck  and  could  not  continue  to  process  normally  until  the slippage is changed in the asset converter.    The swap is now executed before the operation is queued.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.4   Fees Are Not Properly Harvested", "body": "  CS-APYF-018  be   The ApyFlow smart contract has a feeInPpm used to compute a fee applied over all vault profit and that calling will  recomputePricePerTokenAndHarvestFee(),  which  computes  the  revenue  across  all  vaults,  and applies the fee by minting a proportional share amount.  the  feeTreasury.  These   harvested   sent   fees   can   be   by   to   Let's take a look at how it works internally:   function recomputePricePerTokenAndHarvestFee() public {     uint256 _totalAssets = totalAssets();     uint256 _totalSupply = totalSupply();      uint256 newPricePerToken = pricePerToken();     if (newPricePerToken > lastPricePerToken) {         ... // Fee shares computation         _mint(feeTreasury, shares);          lastPricePerToken = newPricePerToken;         emit FeeHarvested(fee, block.timestamp);     } }  lastPricePerToken is used to know whether or not the price per token increased since the last time fees  were  minted.  Note  that  after  minting  the  fees,  the  last  price  per  token  is  updated  to newPricePerToken, which was computed before fees were minted.  However,  because  of  the  new  shares,  the  pricePerToken  just  decreased  which  isn't  accounted  for when assigning lastPricePerToken.  lastPricePerToken is now greater than pricePerToken, meaning that no fees will be applied until the price per token reaches again the lastPricePerToken.    lastPricePerToken is now updated with the most recent value of pricePerToken() which includes the harvested fees.  yldr.com - yldr.com -   20  CorrectnessHighVersion1CodeCorrected          \f6.5   Missing Calculation  BaseHedgedConcentratedLiquidityStrategy._readdLiquidity()  calculates  the  amount  to be withdrawn from Aave which is stored in amountToWithdraw. However, this variable is only declared but not assigned, which initializes it to zero.  CS-APYF-023    The missing computation was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.6   Aave.ltv Cannot Be Updated", "body": "  When HedgedBaseConcentratedLiquidityStrategy is initialized, the AaveLibrary.Data is set which stores the aimed ltv of the Aave position. ltv can never be updated. This can be problematic. The ltv on Aave can be different or change during the lifetime of the strategy. This means that the tvl on the strategy can be greater than the actual tvl on Aave. When the strategy tries to borrow from Aave, the transaction will revert as the strategy will request more to borrow. This limitation of the strategy can prevent deposits and redemptions in the whole system as for a system-wide operation to succeed all the operation in all vaults should succeed. Another important point is that in AaveV3, if tvl is 0 for a specific collateral this collateral cannot be withdrawn.  CS-APYF-025    function  HedgedBaseConcentratedLiquidityStrategy.updateAaveLTV()  has  been  The  added. The owner of the smart contract can now set a new ltv value.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.7   Underflow in Deposit Blocks the System", "body": "  A  user  can  submit  a  0  deposit  which  can  be  added  to  the  queue.  This  will  eventually  execute _depositLocal  for  assets  ==  0  which  eventually  calls  _decreaseOpIdToActionsCount  which decreases  opIdToActionsCount  which  is  0.  This  means  that  the  operation  will  revert.  Note  that  the owners at this point cannot call setNewNextOperation as the queue is busy.  CS-APYF-017    The  opIdToActionsCount  is  now  incremented  before  the  rest  of  the  deposit  logic,  which  fixes  the underflow case.  yldr.com - yldr.com -   21  CorrectnessHighVersion1CodeCorrectedDesignHighVersion1CodeCorrectedDesignMediumVersion2CodeCorrected                        \f6.8   Zero Redemption Blocks the System  A  user  can  create  a  request  to  redeem  0  shares  from  MasterCrossLedgerVault  which  will  be successfully  added  to  the  queue.  Such  a  request  can  be  fully  processed  up  until  _completeRedeem which will calculate the pricePerToken. However, this calculation will revert blocking the completion of the  operation  since  0  shares  are  in  the  denominator.  Note  that  the  owners  at  this  point  cannot  call setNewNextOperation as the queue is busy.  Please note that the pricePerToken cannot be removed as the following issue will be enabled:  CS-APYF-010   Assume a system with one slave chain with a score higher than the master chain.   A user deposits a very small amount such that the deposited amount for the master chain is zero  and non-zero for the slave chain.   opIdToActionsCount[opId] is increased once for the operation on the slave chain   depositLocal()   is   then  executed  and  since  assets   is  0   for   the   local  chain  _finalizeCurrentAction() is called.   Then,   _decreaseOpIdToActionsCount()   is   called   which   sets  opIdToActionsCount[opId] to 0 which successfully calls _completeOperation().   operationsQueue.currentOperation  is  set  to  0  which  allows  the  next  operation  to  be  executed.    Zero shares redemption is not allowed anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.9   Dust in Deposits", "body": "  In  MasterCrossLedgerVault  and  ApyFlow,  deposited  assets  are  split  based  on  a  portfolio  score. However,  it  could  be  that  there  are  some  dust  amounts  left  in  these  smart  contracts  due  to  rounding errors.  MasterCrossLedgerVault's dust would be unrecoverable for the user. ApyFlow's dust is accounted as a donation to the current shareholders.  The  last  deposited  amount  (local  deposit)  could  be  calculated  as  the  remaining  available  amount  and thus dust would be avoided.  CS-APYF-016    MasterCrossLedgerVault  now  correctly  handles  deposit  dust  by  minting  the  appropriate  shares amount and a new dustAmount variable has been introduced to keep track of the current dust and split it accordingly on redeems.  ApyFlow now also correctly takes dust into account.  yldr.com - yldr.com -   22  DesignMediumVersion2CodeCorrectedDesignMediumVersion1CodeCorrected                \f6.10   Idling Assets Unused in readdLiquidity()  CS-APYF-024  in   and Both  BaseHedgedConcentratedLiquidityStrategy  invested  when readdLiquidity  is  called  even  though  they  are  accounted  in  totalAssets().  This  results  in  the strategy giving up on some yield.  BaseConcentratedLiquidityStratey   idle  assets  are  not   the   In BaseConcentratedLiquidityStrategy._readdLiquidity(), only assets accounted for in _redeem() will be deposited back. However, some idling assets might be present in the strategy and will stay idling even after the exection of readdLiquidity().   BaseHedgedConcentratedLiquidityStrategy._readdLiquidity()   all concentrated liquidity and adapts its debt and collateral to approach the target ltv. To compute the amount of assets that are available in the vaults, the function calls _totalAssets(), which computes the total value in the Aave position, and then accounts for the token balances of the concentrated liquidity pool. However, note that it is possible that the main vault asset isn't equal to  either  token  of  the  liquidity  pool.  In  this  case,  idling  assets  present  in  the  vault  are  not accounted for, which will lead to a smaller Aave position than expected after execution.  redeems     During  _readdLiquidity()  the  total  balance  of  asset  held  by  the  contract  (not  just  the  amount redeemed) is used in the new deposit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.11   Leftovers Are Not Handled", "body": "  The execution of BaseHedgedConcentratedLiquidityStrategy._readdLiquidity() can leave the  contract  with  some  extra  token0  and  token1  idling  in  the  smart  contract.  This  happens  because swaps of tokens can return a greater amount of assets than what is needed.  The  assets  which  are  not  of  type  asset  will  not  be  accounted  for  in  totalAssets().  This  could potentially reduce the value of the vault's shares until the next _harvest() function execution, which will swap them back to asset.  CS-APYF-013    The leftovers are converted to the underlying asset at the end of the execution.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.12   Queue Processing Is Slow", "body": "  MasterCrossLedgerVault's  operation  queue  is  very  slow  to  process,  as  each  operation  must  pass messages across multiple chains.  Waiting time for an operation to execute could be days or even weeks depending on usage.  CS-APYF-021  yldr.com - yldr.com -   23  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                       \fEven  with  a  reasonably  big  minimumOperationValue,  a  wealthy  malicious  user  could  also  easily increase processing time by days, or even weeks.    MasterCrossLedgerVault.setNewNextOperation()  was  introduced.  The  owner  of  the  contract can arbitrarily set the next operation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.13   Redemption of Small Amounts Is Impossible", "body": "  In MasterCrossLedgerVault, a deposit or a redemption is accepted only if the amount is greater than the minimumOperationValue:  CS-APYF-011  require(     shares / 10 ** decimals() >= minimumOperationValue,     \"Redeem value is lower than minimum\" );  However, users might be willing to partially redeem their position. In some cases it could leave them with an  amount  of  shares  that  is  smaller  than  the  minimumOperationValue,  making  it  impossible  to redeem the rest of the funds unless they deposit again to reach the minimum operation value.    The minimumOperationValue was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.14   SlaveCrossLedgerVault With a Zero Portfolio", "body": " Score  The _startDeposit() function in the MasterCrossLedgerVault iterates over each chain and deposits an amount proportional to their associated portfolio score returned by the oracle. In the case where either a  chain  has  a  score  of  zero  or  the  amount  destinated  to  this  chain  rounds  down  to  zero,  the  loop continues to iterate and ignores this chain:  CS-APYF-029  for (uint256 i = 0; i < chains.length(); i++) {     uint256 chainId = chains.at(i);     uint256 score = oracle.portfolioScore(chainId);     uint256 amountToSend = (mainAssetValue * score) / totalScore;     **if (amountToSend == 0) continue;**     _deposit(opId, chainId, amountToSend, params.slippage); }  Let's also recall how the amount of shares to be minted is computed in the MasterCrossLedgerVault:  yldr.com - yldr.com -   24  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \fuint256 totalAssetsBefore = totalAssetsBeforeDeposit[opId]; uint256 totalAssetsAfter = totalAssetsAfterDeposit[opId]; uint256 deposited = totalAssetsAfter - totalAssetsBefore; uint256 shares; if (totalSupply() == 0) {     shares = totalAssetsAfter; } else {     shares = (deposited * totalSupply()) / totalAssetsBefore; }  For  a  fair  computation  of  the  shares,  totalAssetsBefore  should  denote  the  full  value  of  all  assets across  all  chains.  This  is  important  because  redeeming  works  a  bit  differently  than  depositing.  It  just iterates over all chains without taking into account the portfolio score but instead provides them with a relative  proportion  (shares  &  totalSupply),  so  that  each  SlaveCrossLedgerVault  can  use  this proportion to compute how many assets to redeem.  However,  for  totalAssetsBefore  to  be  updated  by  a  slave  vault,  a  cross-chain  deposit  must  have occurred, which isn't the case when amountToSend == 0.  If a portfolio score of a chain has been set to zero, but some assets are still waiting to be redeemed on the  slave  vault,  then  funds  would  be  incorrectly  distributed  to  new  master  vault  depositors.  A  new depositor would receive shares relative to the total assets of all chains except the ones with zero scores, but redeeming these shares would still withdraw funds on the zero-score chain.    Version 2:  yldr.com replied:  We have restricted setting 0 score for chains. All chains should be removed instead of zeroing their scoring  CrossLedgerOracle.updateDataBatch()  is  implemented  to  revert  if  a  score  is  set  to  0  for  any chain of a slave vault.  Version 3:  Setting a score of 0 for a chain is now allowed because zero amounts are now properly handled during operations execution.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.15   Unused Function", "body": "  WormholeBridgeAdapter.adjustAmount() is never used.  CS-APYF-015    adjustAmount() is now used to round down the last decimals of the amount sent over the wormhole bridge. This is done as the wormhole bridge performs a similar operation.  yldr.com - yldr.com -   25  CorrectnessMediumVersion1CodeCorrected          \f6.16   minimumOperationValue Could Block Redeems  The minimumOperationValue variable exists as a lower limit of how many assets one can deposit or redeem on MasterCrossLedgerVault. It is denominated in US dollars, and can be compared against deposited assets as long as these are stablecoins pegged to the USD and decimals are adapted.  On redeems, however, minimumOperationValue is compared against a master vault shares amount, which has a varying price:  CS-APYF-022  require(     shares / 10 ** decimals() >= minimumOperationValue,     \"Redeem value is lower than minimum\" );  Assuming that shares accrue in value over time, the minimum value that a user must have deposited to be able to redeem will also increase with time. Note that shares might also decrease in value over time.  A  user  could  deposit  but  isn't  able  to  redeem  afterward  because  one  share  is  more  valuable  than  one token of the deposited asset. This would lock users' funds until they deposit again to reach the minimum value.    The minimumOperationValue was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.17   Discrepancy Between Computed and Actual", "body": " Price per Token  In  CrossLedgerVault.processAction(),  the  user-specified  slippage  is  checked  against  the received  assets  to  make  sure  it  is  acceptable  for  this  action.  When  redeeming,  expectedAssets  is computed  with  feeInclusivePricePerToken()  of  the  underlying  root  vault,  which  for  now  doesn't contain the harvested rewards of the underlying vaults.  CS-APYF-019  However,  it  might  be  the  case  that  on  redemptions,  rewards  are  harvested,  which  changes  the pricePerToken  the redemption  feeInclusivePricePertoken()  will  return  a  smaller  price  per  token  than  it  should  have,  which would allow a bigger slippage than desired.  Consequently,   happens.   before   the     The expected assets are now computed after the redemption so that harvested rewards are accounted.  yldr.com - yldr.com -   26  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f6.18   Queue Could Be Stuck Because of Small-Amount Swaps  In CrossLedgerVault.processAction(), the amount to deposit or redeem could be small, and lead to  some  rounding  errors  depending  on  the  pool  used  to  swap  assets  in  vaults.  Depending  on  the rounding  error,  the  slippage  might  happen  to  always  be  greater  than  expected,  which  would  block  the queue.  CS-APYF-012    The  amount  received  is  always  increased  by  100  wei  so  that  low  amounts  cannot  make  the  slippage check fail.  Note that this means bypassing the user-defined accepted slippage for small deposits.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.19   Redundant Storage", "body": "  Redundant storage is used in some places. More specifically:  CS-APYF-028   CrossLedgerVault.addChain() sets lzChainIdToChainId. However, mapping is never  used.   CrossLedgerVault.chains variable is only of use in the MasterCrossLedgerVault, not  in the slave vaults.   WormholeBridgeAdapter.isRootChain variable is never used.    The redundancies have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "6.20   Variables Could Be Immutable", "body": "  The following variables are only set on construction and never written to afterwards.  CS-APYF-020   WormholeBridgeAdapter.workerImplementation   PosBridgeAdapter.isRootChain   PosBridgeAdapter.asset   PosBridgeAdapter.workerImplementation   PosBridgeAdapter.dstChainId   PosBridgeAdapter.crossLedgerVault  yldr.com - yldr.com -   27  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                  \f PosBridgeAdapter.rootChainManager  Setting  these  to  immutable  will  insert  them  into  the  bytecode  at  compilation  time,  leading  to  cheaper reads compared to storage.    The variables are now immutable.  yldr.com - yldr.com -   28  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "7.1   Code Consistency", "body": "  logic  situations.  The lack  consistency  when  dealing  with  similar  Some  code  areas  BaseHedgedConcentratedLiquidityStrategy swaps assets from one token to another in order to supply an appropriate amount to Aave and eventually to the LP position. In multiple cases, extra care is taken so that no underflows take place. For example in _redeem() the amount to swap is bounded by the available collateralAmount:  CS-APYF-003  amountToSwap = Math.min(amountToSwap, collateralAmount);  While similar logic is implemented in most cases, there are cases where it's not implemented:  In  _readdLiquidity()  the  case  where  currentDebt  >  neededDebt  and tokenToBorrowBalacne  <  amountToRepay,  collateralBalance  is  assumed  to  be greater than amountToSwap.  in   In  _readdLiquidity()  in  the  case  where  currentCollateral  <  neededCollateral and  collateralBalance  <  amountToSupply,  tokenToBorrowBalance  is  assumed  to be greater than amountToSwap.  Enforcing  code  consistency  when  handling  specific  similar  cases  helps  to  secure  the  code  flow  and  to make it more understandable. Adding internal functions for specific tasks could help to properly split the logic.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "7.2   Missing Natspec", "body": "  Most functions are missing proper documentation and description.  Natspec  help  the  end  users  to  interact  with  smart  contracts  as  they  produce  messages  that  can  be shown  to  the  end  user  (the  human)  at  the  time  that  they  will  interact  with  the  contract  (i.e.  sign  a transaction).  CS-APYF-004  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "7.3   Missing Sanity Checks", "body": "   During a rebalance operation in MasterCrossLedgerVault, the REBALANCE_ROLE specifies the percentage of shares to be moved from one chain to another. This happens assuming that the total supply  of  shares  is  1000.  However,  no  sanity  check  guarantees  that  the  shareToRebalance  is  CS-APYF-005  yldr.com - yldr.com -   29  InformationalVersion1InformationalVersion1InformationalVersion1            \fless than 1000. Note that the accepted slippage and both the source and destination chain id are also  specified  but  not  sanity  checked,  which  in  the  worst  case  (slippage  input  error)  could  lead  to some loss of assets.   MasterCrossLedgerVault.setNewNextOperation()  allows  the  owner  to  set  the  next operation  id,  however,  this  value  isn't  sanity  checked  and  could  point  to  an  already  processed operation.   The beneficiery for deposits and redemptions is not checked to be non-zero.  In ApyFlow.setNewFeeDestination(), the newFeeDestination is not sanitized.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "7.4   No Events for Important State Changing", "body": " Operations  Some examples are:  CS-APYF-006   MasterCrossLedgerVault.addToken()   MasterCrossLedgerVault.removeToken()   MasterCrossLedgerVault.setNewMinimumOperationValue()   MasterCrossLedgerVault.setNewMinSlippageProvider()   CrossLedgerVault.addChain()   CrossLedgerVault.removeChain()   CrossLedgerVault.updateBridgeAdapter()   SuperAdminControl.call()  Events indicate major state changes. Hence, it might be useful for users to listen to certain events. Note that events do increase the gas costs slightly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "7.5   Redundant Operations", "body": "  There are multiple instances of redundant operations:  CS-APYF-007   CrossLedgerVault.transferCompleted()   reads   bridgeAdapterToChainId.  However, this value is never used.   MasterCrossLedgerVault._startDeposit()  calculates  the  total  score  by  reading  the respective scores of all chains. Then, to calculate the respective deposits, the scores are read again.   BaseConcentratedLiquidityStrategy._redeem()   calls  _collect()  which   is  guaranteed to have been called before because of the harvesting mechanism.  yldr.com - yldr.com -   30  InformationalVersion1InformationalVersion1           \f7.6   Unreachable Operation  CrossLedgerVault._depositLocal() handles the case where assets == 0. However, this case is  unreachable.  _deposit()  returns  if  amount  ==  0.  If  the  deposited  amount  to  another  chain  is  0, then no deposit to that chain is actually executed.  CS-APYF-008  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "7.7   Unused Variables and Function", "body": "  Some  variables  are  unused  and  could  be  removed  either  from  the  parameter  list  of  the  respective functions or the function implementation:  CS-APYF-009   sentTransfers in MasterCrossledgerVault._startDeposit()   SlaveCrossLedgerVault._transferCompleted()'s parameter transferId   CrossLedgerVault._blockingLzReceive()'s parameter srcLzChainId  Note also that the function WormholeBridgeAdapter.adjustAmount() isn't used anywhere.  yldr.com - yldr.com -   31  InformationalVersion1InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.1   Asset Converters Can Always Be Frontrun", "body": "  Asset converters are used all across the protocol to swap between different assets.  It is important to note that at any point in time these swaps can be frontrun, and will especially be when the swapped amount is big enough.  Also note that the asset converter implements a slippage check to avoid big losses.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.2   Asset Converters and Liquidity Provision", "body": "  Strategy vaults such as UniswapV3 can invest assets in LP positions of some pools. As the users deposit one specific asset, part of the deposited amount should be converted into another asset. For example, a user submits USDC only and a part of it is swapped to ETH for the two assets to be deposited together to an  LP  position  in  an  ETH-USDC  pool.  For  the  required  swap,  there's  no  guarantee  that  the  same ETH-USDC pool is not going to be used. This means that swaps needed to be performed can alter the price offered by the pool where the LP position is going to be opened. Furthermore, when the swapped amounts are big, for example during rebalances (calls to readdLiquidity), the deviation of the price of the pool can be significant. As these rebalances require two steps (redeem and deposit) which both check  for  a  potential  price  deviation  between  pools  and  oracles,  such  deviation  can  block  the  deposit step and thus block the whole rebalance process.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.3   Fees Accounting Is Based on Variable ", "body": " pricePerToken  Fees accounting in ApyFlow is based on the variable pricePerToken. This variable can vary in both direction because of ApyFlow's underlying strategies.  However,  fees  are  only  harvested  if  pricePerToken  has  increased  since  last  harvesting.  This mechanism makes it so that fees will only apply on the vault's total profit, but not on yields.  For example, let's say both pricePerToken and lastPricePerToken are equal to 1.1. A strategy suffers a big loss, which decreases the price per token to 1. Strategies still produce some yield, which make  the  pricePerToken  grow  back  to  1.05  after  a  few  days.  No  fees  will  be  applied  to  this  0.05 growth in the price per token.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.4   Fees Depend on the Converter", "body": "  yldr.com - yldr.com -   32  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fIn  ApyFlow.redeem()  fees  are  a  portion  of  the  assets  sent  to  the  user.  However,  assets  are dependent on the assetConverter. Should the converter swap the assets with the maximum allowed slippage the fees earned by the system will be reduced.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.5   Gas Limitations", "body": "  In  the  ApyFlow  smart  contract,  each  underlying  vault  in  its  vaults  array  is  a  SingleAssetVault which also contains an array of underlying vaults. In the case of a relatively high number of underlying vaults,  gas  costs  can  increase  significantly  even  exceeding  the  gas  limit.  In  that  case,  any  deposit  or redemption could block which could lead to blocking the entire system.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.6   Liquidation Consequences", "body": "  In  the  BaseHedgedConcentratedLiquidityStrategy  smart  contract,  a  loan  is  taken  on  Aave  to distribute the liquidity position risk evenly. During high price-volatility periods, a vault could therefore risk getting liquidated.  A liquidation would have multiple consequences:   A sudden decrease in the price per token value.   A potential risk of being unable to call readdLiquidity() due to the current price per token being smaller  than  lastPricePerToken,  if  the  pool  price  returned  out  of  the  rebalance  range  after liquidation.  Note  that  yldr.com  will  configure  hedged  vaults  so  that  the  risk  is  very  low  and  vaults  should  be monitored.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.7   Slippage on Swaps Is Expected to Be", "body": " Relatively Small  With the current cross-ledger architecture, some token swaps will happen during operations through the asset  converter  smart  contract.  Note  that  this  asset  converter  has  a  fixed  slippage  tolerance  set  and reverts if it is not respected.  Consequently,  slippage  tolerance  should  be  properly  set  so  that  it  isn't  likely  to  block  any  cross-ledger action.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "8.8   Supported Tokens", "body": "  The  system  only  supports  standard  ERC20  tokens  without  special  behaviors,  especially  tokens  with callbacks  (ERC777)  which  would  allow  arbitrary  code  execution.  More  explicitly,  tokens  with  two  entry points should also be avoided.  Tokens with fees or any rebasing mechanism aren't supported.  yldr.com - yldr.com -   33  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f8.9   Tokens Assumption  Some parts of the code implicitly assume that some assets are the same, without ever checking if it is the case or handling the case where they are different.  the  collateral  and The  hedged  concentrated  liquidity  strategy  sometimes  assumes  tokenToBorrow  tokens  must  be  equal  to  the  liquidity  pool  tokens.  It  also  assumes  that  the collateral token is the same as the main asset of the vault.  that   These incomplete assumptions increase the code complexity and can lead to some complex errors.  yldr.com - yldr.com -   34  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yldr-com/"}, {"title": "5.1   Inconsistent Decimals of LP Token", "body": "  The  function  ERC20RootVault.deposit  performs  the  following  checks  when  new  LP  tokens  are minted to a user:  require(lpAmount + balanceOf[msg.sender] <= params.tokenLimitPerAddress, ExceptionsLibrary.LIMIT_OVERFLOW); require(lpAmount + totalSupply <= params.tokenLimit, ExceptionsLibrary.LIMIT_OVERFLOW);  The LP tokens distributed by root vaults do not have pre-defined number of decimals but depend on the token amounts of the first deposit, hence making difficult to set the params tokenLimitPerAddress and tokenLimit in advance.  Acknowledged:  Mellow Finance - Mellow Vaults -   13  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedCorrectnessLowVersion5Acknowledged            \fMellow Finance acknowledges the issue and will take care to set the proper limits after initial LP shares are minted and the respective decimals are known:  We don\u2019t intend to stand limits in advance of the launch of the system, we rather want to stand them as MaxUint256 initially and then have a possibility to set meaningful values based on the supply of lp tokens during the work of the system.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.2   Performance Fee in Specific Setups", "body": "  The  performance  fee  is  charged  in  ERC20RootVault  only  if  the  price  of  LP  tokens  has  increased  in value, which is calculated in the statement:  uint256 lpPriceD18 = FullMath.mulDiv(tvlToken0, CommonLibrary.D18, baseSupply);  However, in specific setups where the token0 is of high value but has low decimals, while the token1 is of low value but with many decimals, the variable baseSupply would inherit the decimals of token1. Therefore, in such setups it is possible that the statement above returns lpPriceD18 equal to zero.  Acknowledged:  Mellow  Finance  has  decided  to  keep  the  code  unchanged  as  they  only  will  use  only  verified  token combinations that this issue does not occur. The response:  We decided that this situation would not be possible when calculating the performance fee, since we agreed to use only verified tokens, for which the difference between decimals would be less than 18.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.3   Possible Optimization in AggregateVault", "body": "  The function AggregateVault._push performs the following actions:  1. Approves allowance with safeIncreaseAllowance for each token to destVault.  2. Calls destVault.transferAndPush, which transfers tokenAmounts to the ERC20Vault.  3. Resets approval to destVault for all tokens to 0.  Given that the _push function moves tokens to the ERC20Vault and allowance in the end should be 0, the  function  can  be  revised  to  be  more  efficient.  For  instance,  safeIncreaseAllowance  performs additional  operations  and  is  useful  when  the  existing  allowance  is  not  zero  and  should  be  considered. Also,  the  function  consumes  in  step  2  the  allowance  given  earlier,  hence  the  last  for-loop  might  be omitted.  Code partially correct:  The  function  AggregateVault._push  is  made  more  efficient  by  performing  the  external  calls safeIncreaseAllowance  and  safeApprove  only  for  tokens  that  non-zero  amounts  are  being  Mellow Finance - Mellow Vaults -   14  DesignLowVersion5AcknowledgedDesignLowVersion5CodePartiallyCorrected                \ftransferred (tokenAmounts[i] > 0). However, for the other tokens two external calls are performed for updating the allowance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.4   Possible Optimization on Deposits and", "body": " Withdrawals  The function ERC20RootVault.deposit can be optimized to be more gas efficient by transferring the tokens directly from the user to the ERC20Vault. Currently, the tokens are first transferred from the user to the root vault:  for (uint256 i = 0; i < tokens.length; ++i) {     ...     IERC20(tokens[i]).safeTransferFrom(msg.sender, address(this), normalizedAmounts[i]); }  and then, in AggregateVault._push tokens are transferred again:  for (uint256 i = 0; i < _vaultTokens.length; i++) {     IERC20(_vaultTokens[i]).safeIncreaseAllowance(address(destVault), tokenAmounts[i]); }  Similarly,  the  function  ERC20RootVault.withdraw  can  be  made  more  efficient  if  the  tokens  are transferred directly from the sub-vaults to the user instead of transferring to the root vault first and then to the user.  Acknowledged:  Client acknowledges the optimization possibility but prefers to keep the code unchanged:  The main idea behind this behavior is for the root vault to be responsible for pushing tokens onto different vaults. We consider the current design to be clearer with pushing with the ```AggregateVault._push``` method.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.5   Redundant Calculation of LP Amounts", "body": "  The  function  ERC20RootVault.deposit  calculates  the  LP  amount  that  is  rewarded  to  the  user  two times:  {     ...     (preLpAmount, isSignificantTvl) = _getLpAmount(maxTvl, tokenAmounts, supply);     for (uint256 i = 0; i < tokens.length; ++i) {         normalizedAmounts[i] = _getNormalizedAmount(...);         ...     } } actualTokenAmounts = _push(normalizedAmounts, vaultOptions); (uint256 lpAmount, ) = _getLpAmount(maxTvl, actualTokenAmounts, supply);  Mellow Finance - Mellow Vaults -   15  DesignLowVersion5AcknowledgedDesignLowVersion5Acknowledged                \fInitially,  preLpAmount  is  calculated  based  on  the  tokenAmounts,  then  normalizedAmounts  are returned computed.  Considering  actualTokenAmounts  is redundant.  to  normalizedAmounts.  Hence,  recomputing  lpAmount   that  _push  moves   the  ERC20Vault,   is  equal   tokens   the   to   Acknowledged:  Client acknowledges the redundant calculation of LP amount but prefers to keep the code unchanged as in the future the behavior of ERC20Vault might change, i.e., the returned actualTokenAmounts might not be equal to normalizedAmounts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.6   Broad Access Control for Functions", "body": "  functions  addDepositorsToAllowlist  and  removeDepositorsFromAllowlist   in The  ERC20RootVault  restrict  the  access  control  with  function  _requireAtLeastStrategy.  However, neither MStrategy nor LStrategy call these functions. Similarly, multiple functions in VaultGovernance use the same access control, although they are not called by the strategies.  Acknowledged:  Mellow  Finance  is  aware  that  these  functions  are  not  called  by  smart  contracts  implementing  the strategies, but they can be called by an EOA in case it manages the vault system. Client replied:  The vault system can be managed not by strategy, but by some account. In such a case this account should have the possibility to edit `depositorsAllowList`. These 2 functions exist for this reason.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.7   Redundant Check for baseSupply", "body": "  The  function  ERC20RootVault._chargePerformanceFees  performs  a  check  of  baseSupply  is equal to 0, and returns if this is the case:  if ((performanceFee == 0) || (baseSupply == 0)) {     return; }  However, this check is redundant because _chargeFees performs the same check and returns before calling _chargePerformanceFees.  Acknowledged:  Client acknowledged the redundant check but has decided to keep it as it enhances the readability of the code.  Mellow Finance - Mellow Vaults -   16  DesignLowVersion4AcknowledgedDesignLowVersion4Acknowledged                  \f5.8   Redundant Check for deltaSupply  The function _getBaseParamsForFees performs the following check on withdrawals:  baseSupply = 0; if (supply > deltaSupply) {     baseSupply = supply - deltaSupply; }  The deltaSupply corresponds to the LP shares that a user is burning, which is less than or equal to the balance of that user. Hence, it is always less or equal to the totalSupply.  Acknowledged:  Client acknowledged the redundant check but has decided to keep it as it enhances the readability of the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.9   Redundant Checks on Push Function", "body": "  The  function  IntegrationVault.push  performs  the  following  checks  that  are  always  true  when  a vault is linked to a root vault:  uint256 nft_ = _nft; require(nft_ != 0, ExceptionsLibrary.INIT); IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry; IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_)); // Also checks that the token exists uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault)); require(ownerNft != 0, ExceptionsLibrary.NOT_FOUND);  Acknowledged:  Mellow  Finance  has  decided  to  keep  the  checks  to  prevent  from  pushing  and  pulling  on  uninitialized vaults.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.10   State Updates After Reentrancy Possibility", "body": "  When creating a vault, _mint is called to mint the NFT. This calls the receiver and gives an opportunity to reenter the system.  _safeMint(owner, nft); _vaultIndex[nft] = vault; _nftIndex[vault] = nft; _vaults.push(vault); _topNft += 1; emit VaultRegistered(tx.origin, msg.sender, nft, vault, owner);  Mellow Finance - Mellow Vaults -   17  DesignLowVersion4AcknowledgedDesignLowVersion4AcknowledgedDesignLowVersion4CodePartiallyCorrected                      \fState  updates  and  events  are  emitted  after  the  possible  reentrancy  in  this  function  and  the  calling functions. Coding guidelines suggest following the check-effects-interaction pattern to mitigate reentrancy vulnerabilities.  Code partially corrected:  The  minting  statement  _safeMint  has  been  moved  to  the  end  of  the  function  registerVault. However, state is still updated afterwards in functions createVault of vault governance contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.11   Missing Slippage Protection in _mintNewNft", "body": "  The function _mintNewNft in LStrategy sets the parameters amount0Min and amount1Min of the MintParams to zero, hence disabling any slippage protection. However, the risk exposure in this case is limited as a new position in Uniswap should be open with small amounts minTokenXForOpening. The exact amount depends on admin who sets the otherParams.  Acknowledged:   to check if the variables minTokenXForOpening are smaller Sanity checks were introduced in  than 10**9. This adds another layer of protection to ensure that the number of tokens is relatively low. Still, the number of tokens does not guarantee that the value is small.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.12   UniV3Vault Pulls More Tokens Than", "body": " Requested  UniV3Vault._pullUniV3Nft first calculates the amount of tokens to pull, then decreases the liquidity inside  the  Uniswap  position  and  then  collects  the  tokens.  When  the  earnings  have  not  been  collected before, the last step additionally collects the earnings, returning more tokens than intended.  The function should take the tokens owed into consideration when calculating the amount to pull.  Acknowledged  Mellow  Finance  acknowledged  the  issue  and  replied  that  the  strategy  maintainer  can  call  the collectEarnings function to collect all the fees.  Mellow Finance - Mellow Vaults -   18  SecurityLowVersion1AcknowledgedVersion3CorrectnessLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  5  14  17  -Severity Findings   Mismatch of Specification With Uniswap V3 Oracle    Chainlink Oracle Returns Empty Prices   Incorrect LP Token Calculation in ERC20RootVault    Missing Access Control in UniV3Oracle    UniV3Oracle Returns Reverse Prices for Token Pairs   -Severity Findings  Incorrect TVL Conversion    Adding up Total Value Locked on Different Tokens    Calling _liquidityDelta Incorrectly    Calling _liquidityDelta With Incorrect Inputs   Incorrect Observation Index in _getAverageTick   Incorrect Parameters on externalCall   Insufficient Testing    Opposite Vaults Are Swapped    Possibility to Exit Positions of Any Address    Possible DOS From First Depositor    Setting Wrong State Variable    Wrong Formula in _rebalanceUniV3Liquidity    Wrong TVL Calculation in ERC20RootVault   liquidity Gets Overwritten in the Loop   -Severity Findings   Wrong State Variable Updated   Inconsistent Access Control for Rebalance in LStrategy   Inconsistent Sanity Check on First Deposit's Amounts    Safety Level of Returned Prices Can Silently Downgrade    Unfair Distribution of LP Shares in ERC20RootVault    Conflicting Specifications for MStrategy   Implementation Differs From Specification on _targetTokenRatioD   Incorrect Access of Addresses in EnumerableSet    Missing Checks for Dust Amounts When Rebalancing Pools    Missing Delay Restriction in BaseValidator   Mellow Finance - Mellow Vaults -   19  CriticalCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedHighCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected          \f Missing Sanity Checks in signOrder    No Slippage Protection in Multiple Contracts    Possible Underflow in UniV3Oracle.price    Rebalance in LStrategy Can Leave Tokens in the Vault to Be Closed    Subvault Tokens Are Not Checked in AggregateVault    Transferring Tokens Only to lowerVault    Use of Libraries   -Severity Findings   Missing Sanity Checks for intervalWidthInTicks    Possible Attack by First Depositor    Possible Optimization on _chargePerformanceFees    Possible Violation of the Minimum Token Amounts After the First Deposit    Misleading Function Name and Natspec    Mismatch of Specifications for StrategyParams    Missing Sanity Check for maxSlippageD in MStrategy   41   Missing Sanity Checks for oracleSafetyMask    Possible Struct Optimization in Strategies    Redundant Comparisons    Redundant Storage Read in ERC20Vault._pull    Variables Can Be Declared as Constant   Incorrect Specification for reclaimTokens    Missing Natspec Description for minDeviation    Casting of maxTickDeviation    Check Requirements First    Duplicate Code _permissionIdsToMask    Duplicate Storage Read in Deposit   Inconsistent Specifications   Inefficient Array Shrinking   Inefficient State Variable Packing    Misleading Naming of Variables in UniV3Oracle    Missing Sanity Check in MStrategy.createStrategy    Missing Sanity Checks for Params    Misspelled Variable Names    Possible Struct Optimization    Rebalance in MStrategy Is Inconsistent    Specification for minDeviation Not Enforced    Storing Redundant Data in Storage    Unnecessary Approval to Vault Registry   Mellow Finance - Mellow Vaults -   20  CodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected    \f Unused Constant in ERC20Validator    Unused Event DeployedVault    Unused Function LStrategy._priceX96FromTick    Unused Imports    Wrong Check of Minimum Token Amounts in ERC20RootVault.withdraw    Wrong Specification for YearnVault.tvl    ContractRegistry DOS    ERC20Vault._pull Forces Push of Wrong Amount of Tokens   IntegrationVault._root Does Not Check the NFT of the Root Vault    VaultGovernance.commitInternalParams Does Not Delete Staged Parameters    registry.ownerOf Is Called Twice in IntegrationVault.pull   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.1   Mismatch of Specification With Uniswap V3", "body": " Oracle  The specifications of the function price for oracles are in the interface IOracle as following:  /// @dev The price is token1 / token0 i.e. how many weis of token1 /// required for 1 wei of token0.  function price(     address token0,     address token1,     uint256 safetyIndicesSet ) external view returns (uint256[] memory, uint256[] memory);  According  to  the  specification,  priceA_B  =  price(tokenA,  tokenB)  should  be  the  inverse  of priceB_A  =  price(tokenB,  tokenA),  meaning  relation  should  hold: priceA_B = 1 / priceB_A.  following   the   The  function  UniV3Oracle.price  in    returns  the  same  price  for  a  pair  of  tokens  without differentiating in which denomination token the price should be. Namely, the function returns the same prices  when  calling  price(tokenA,  tokenB)  or  price(tokenB,  tokenA).  This  behavior  is enforced in the first if statement of the function:  if (token0 > token1) {     (token0, token1) = (token1, token0); }    The  Uniswap  V3  Oracle  has  been  revised,  the  Uniswap's  OracleLibrary  is  now  used  and  a  flag isSwapped is added to track the correct denomination of the returned price.  Mellow Finance - Mellow Vaults -   21  CodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessCriticalVersion2CodeCorrectedVersion2           \f6.2   Chainlink Oracle Returns Empty Prices  ChainlinkOracle maintains the mapping oraclesIndex which stores addresses of chainlink oracles for each token. The mapping is populated by the admin through the function _addChainlinkOracles:  function _addChainlinkOracles(address[] memory tokens, address[] memory oracles) internal {     ...     oraclesIndex[token] = oracle;     ... }  The  function  price(token0,token1,safetyIndicesSet)  checks  if  the  mapping  oraclesIndex has the addresses for the respective Chainlink oracles:  if ((address(chainlinkOracle0) != address(0)) || (address(chainlinkOracle1) != address(0))) {         return (pricesX96, safetyIndices); // returns empty values }  The condition above is incorrect as it returns empty values if the Chainlink oracles exist in the mapping. This  makes  the  Chainlink  oracle  -  assumed  to  be  the  safest  by  the  specifications  and  the  code  - unusable.    The above check in function price has been revised to return empty prices only if there is no entry for at least one of the tokens in mapping oraclesIndex:   if ((address(chainlinkOracle0) == address(0)) || (address(chainlinkOracle1) == address(0))) {     return (pricesX96, safetyIndices); }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.3   Incorrect LP Token Calculation in ", "body": " ERC20RootVault  ERC20RootVault._getLpAmount  incorrectly  calculates  the  minimum  of  given  token  amounts.  An attacker can issue more LP tokens than he is entitled to and can then exchange them back for additional tokens.  The following code incorrectly resets the MIN calculation for as many iterations as tokenLpAmount is equal to 0:  for (uint256 i = 0; i < tvlsLength; ++i) {    if ((amounts[i] == 0) || (tvl_[i] == 0)) {       continue;    }     uint256 tokenLpAmount = FullMath.mulDiv(amounts[i], supply, tvl_[i]);    if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {       lpAmount = tokenLpAmount;  Mellow Finance - Mellow Vaults -   22  CorrectnessCriticalVersion1CodeCorrectedCorrectnessCriticalVersion1CodeCorrected              \f   } }  If tokenLpAmount == 0 in the first iteration, lpAmount will be set to 0. If tokenLpAmount > 0 in the next iteration, lpAmount will be set to tokenLpAmount although it is larger than the already set value.  In a later step, ERC20RootVault._getNormalizedAmount normalizes the sent token amounts to the calculated lpAmount. This function however does not increase the normalized amount to a value greater than the sent one. An attacker can therefore exploit this by calling deposit with all token amounts but the last one being set to 0 and then calling withdraw with the LP tokens that have just been minted to obtain his initial investment plus an amount of all other tokens in the Vault equal to the current ratio of tokens.    The  function  _getLpAmount  has  been  refactored  to  set  the  lpAmount  to  the  minimum  of tokenLpAmount calculated on each iteration of the for loop. The flag isLpAmountUpdated is set to true on the first iteration that a non-zero value is assigned to lpAmount.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.4   Missing Access Control in UniV3Oracle", "body": "  The function addUniV3Pools populates the mapping poolsIndex with the address of a Uniswap pool for  a  pair  of  tokens.  The  function  should  be  accessible  only  to  trusted  accounts,  however,  it  does  not implement  any  access  restriction.  As  the  function  is  external  anyone  can  set  arbitrary  addresses  as Uniswap pools, hence freely manipulate the oracle prices.    The updated code resolves the issue by restricting the access to the function addUniV3Pools only to the admin, hence preventing malicious users from setting arbitrary addresses as Uniswap pools:  function addUniV3Pools(IUniswapV3Pool[] memory pools) external {     _requireAdmin();     _addUniV3Pools(pools); }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.5   UniV3Oracle Returns Reverse Prices for", "body": " Token Pairs  The UniV3Oracle computes the price for two tokens using the Uniswap V3 observations. As the tokens in  Uniswap  are  always  sorted  by  their  address  (Token0  <  Token1),  the  function  price  uses  a  flag revTokens to distinguish if the price from Uniswap corresponds to the order of function parameters, or if it should be reversed. The respective code is:  Mellow Finance - Mellow Vaults -   23  SecurityCriticalVersion1CodeCorrectedCorrectnessCriticalVersion1CodeCorrected                \ffunction price(address token0,address token1,uint256 safetyIndicesSet)     external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices) {    ...     bool revTokens = token1 > token0;      for (uint256 i = 0; i < len; i++) {         if (revTokens) {             pricesX96[i] = FullMath.mulDiv(CommonLibrary.Q96, CommonLibrary.Q96, pricesX96[i]);         }         pricesX96[i] = FullMath.mulDiv(pricesX96[i], pricesX96[i], CommonLibrary.Q96);     } }  The flag revToken is set to true if the tokens in the function parameters are ordered as in Uniswap, hence incorrectly reverses the computed price.    The  contract  UniV3Oracle  has  been  refactored  due  to  the  bug  presented  above  and  other  issues reported for this contract. The code above that mistakenly reversed the prices is not present anymore in  , however, another issue has been introduced on the fix.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.6   Incorrect TVL Conversion", "body": "  The function _getTvlToken0 incorrectly converts the TVL amount of a given token i into token 0. The oracle returns a price in x96 format. This price is directly used as if it would be a correctly formatted price to  convert  the  amounts.  As  the  TVL  in  most  cases  will  be  lower  than  the  price  in  x96  format  the calculation will return 0.  tvl0 = tvls[0]; for (uint256 i = 1; i < tvls.length; i++) {     (uint256[] memory prices, ) = oracle.price(tokens[0], tokens[i], 0x28);     require(prices.length > 0, ExceptionsLibrary.VALUE_ZERO);     uint256 price = 0;     for (uint256 j = 0; j < prices.length; j++) {         price += prices[j];     }     price /= prices.length;     tvl0 += tvls[i] / price;  Additionally,  the  calculation  would  be  more  precise  if  the  price  would  be  multiplied  to  convert  the amounts.    The  issue  about  the  conversion  of  TVLs  in  function  _getTvlToken0  has  been  addressed.  The  last statement of the for-loop has been changed:  tvl0 += FullMath.mulDiv(tvls[i], CommonLibrary.Q96, priceX96);  Mellow Finance - Mellow Vaults -   24  Version2CorrectnessHighVersion3CodeCorrected          \f6.7   Adding up Total Value Locked on Different Tokens  function  postPreOrder  calls   The  tvl[0] + tvl[1] (see the issue reported in Calling _liquidityDelta incorrectly).  the   function  _liquidityDelta  with  tvl[0]  and  Additionally, the calculations are performed on tvl with different underlying tokens. Namely, tvl[0] is in the denomination of token0, while tvl[1] in the denomination of token1.    , the first argument tvl[0] is converted into the domination The issue is resolved in code base  of  token1  before  passed  to  _liquidityDelta,  while  the  second  parameter  tvl[1]  remains  in  the denomination of token1.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.8   Calling _liquidityDelta Incorrectly", "body": "  The function postPreOrder in Lstrategy calls _liquidityDelta as follows:  (uint256 tokenDelta, bool isNegative) = _liquidityDelta(     tvl[0],     tvl[0] + tvl[1],     ratioParams.erc20TokenRatioD,     ratioParams.minErc20TokenRatioDeviationD );  As  already  pointed  out  in  the  issue  Calling  _liquidityDelta  with  incorrect  inputs,  the  function _liquidityDelta also performs the addition, hence computing incorrectly the result.    The parameters passed to the function _liquidityDelta have been corrected, namely the addition of tvl[0] + tvl[1] is removed and only tvl[1] is passed as the second argument of the function call.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.9   Calling _liquidityDelta With Incorrect", "body": " Inputs  The function rebalanceERC20UniV3Vaults in LStrategy calls _liquidityDelta as follows:  (capitalDelta, isNegativeCapitalDelta) = _liquidityDelta(     erc20VaultCapital,     erc20VaultCapital + lowerVaultCapital + upperVaultCapital,     ratioParams.erc20UniV3CapitalRatioD,  Mellow Finance - Mellow Vaults -   25  CorrectnessHighVersion1CodeCorrectedVersion2CorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                      \f    ratioParams.minErc20UniV3CapitalRatioDeviationD );  Note  that,  the  first  parameter  is  included  in  the  sum  used  as  the  second  parameter.  However,  the function  _liquidityDelta  also  performs  the  addition  on  the  code  below,  hence  computing targetLowerLiquidity incorrectly:  uint256 targetLowerLiquidity = FullMath.mulDiv(     targetLiquidityRatioD,     lowerLiquidity + upperLiquidity,     DENOMINATOR );    In rebalanceERC20UniV3Vaults the calculation does not add erc20VaultCapital anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.10   Incorrect Observation Index in ", "body": " _getAverageTick  Function _getAverageTick computes the averageTick and the tickDeviation based on the most recent observation and a previous observation referred as observationIndexLast. The latter index is computed as follows:  uint16 observationIndexLast = observationIndex >= oracleObservationDelta     ? observationIndex - oracleObservationDelta     : observationIndex + (type(uint16).max - oracleObservationDelta + 1);  If oracleObservationDelta is larger than observationIndex (e.g., by 1), the code above returns a  value  that  is  close  (or  equal)  to  type(uint16).max.  It  is  very  likely  that  the  Uniswap  pool  has  a smaller  cardinality  of  observations  than  the  computed  observationIndexLast,  hence  0s  would  be returned for this observation.    formula   The  when oracleObservationDelta  >  observationIndex  has  been  revised,  type(uint16).max  has been replaced with observationCardinality.  observationIndexLast   compute   to   obsIdx = 20 delta = 30 card = 50 --- 20 + 50 -30 = 40  obsIdx = 30 delta = 30 card = 50 --- 0  obsIdx = 30 delta = 31 card = 50 --- 30 + 50 -31 = 49  obsIdx = 30 delta = 49 card = 50 --- 30 + 50 - 49 = 31  generalized: obsIdx + card - delta % card  Mellow Finance - Mellow Vaults -   26  CorrectnessHighVersion1CodeCorrected          \f6.11   Incorrect Parameters on externalCall  The function signOrder in LStrategy performs few externalCall s, and for one of them sets the wrong parameters as input:  bytes memory setPresignatureData = abi.encode(SET_PRESIGNATURE_SELECTOR, uuid, signed); erc20Vault.externalCall(cowswap, SET_PRESIGNATURE_SELECTOR, setPresignatureData);  Note  that  the  function  selector  is  part  of  the  abi.encode  and  then  is  set  as  the  second  parameter  in externalCall, which also appends the selector when executing the call, hence causing the external function to always fail:  (bool res, bytes memory returndata) = to.call{value: msg.value}(abi.encodePacked(selector, data));    The  external  call  in  LStrategy.signOrder  does  not  encode  the  SET_PRESIGNATURE_SELECTOR twice anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.12   Insufficient Testing", "body": "  We found an unusual high number of issues that would have been easily detected with proper tests. The current unit and integration tests are insufficient.    The tests have been extended significantly on the latest iterations of the review process to cover more functions and call paths.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.13   Opposite Vaults Are Swapped", "body": "  The  function  _swapVaults  in  LStrategy  should  close  the  position  with  no  liquidity  and  open  a  new one given the price move in positiveTickGrowth. The decision on which vault to close is done in the following if condition:  /// @param positiveTickGrowth `true` if price tick increased ... if (!positiveTickGrowth) {     (fromVault, toVault) = (lowerVault, upperVault); } else {     (fromVault, toVault) = (upperVault, lowerVault); }  The  function  closes  the  fromVault  and  creates  the  new  vault  according  to  the  current  position  of toVault.  However,  the  code  above  assigns  fromVault  wrongly  to  lowerVault  if  the  tick  is  Mellow Finance - Mellow Vaults -   27  CorrectnessHighVersion1CodeCorrectedSecurityHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                      \fdecreasing,  and  vice-versa  if  the  tick  is  increasing.  Given  this  error  and  the  following  requirement,  the function would fail always (as fromVault has all liquidity):  require(fromLiquidity == 0, ExceptionsLibrary.INVARIANT);    The vaults were switched like:  if (!positiveTickGrowth) {         (fromVault, toVault) = (upperVault, lowerVault);     } else {         (fromVault, toVault) = (lowerVault, upperVault);     }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.14   Possibility to Exit Positions of Any Address", "body": "  In  ERC20RootVault.withdraw,  LP  tokens  are  burned  in  a  call  to  _burn  from  the  address  that  is specified  in  the  to  parameter.  Neither  _burn  nor  any  other  statement  in  withdraw  performs  access control checks to verify if the msg.sender is allowed to burn the tokens of the given address. Thus, any user can burn LP tokens of a given address and transfer the underlying tokens to that address.  Finally, an incorrect event is emitted with msg.sender.    . The function withdraw now burns only The issues have been resolved in the updated code  the LP tokens of the msg.sender, while transfers the underlying tokens to the address to specified by the caller.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.15   Possible DOS From First Depositor", "body": "  The first user that calls deposit in ERC20RootVault can choose freely any amount (including zero) for each  vault  token,  while  the  LP  shares  are  set  to  the  largest  amount  by  the  following  loop  in _getLpAmount:  for (uint256 i = 0; i < tvl_.length; ++i) {     if (amounts[i] > lpAmount) {         lpAmount = amounts[i];     } }  However, if the first user (on initialization or whenever totalSupply is zero) chooses to deposit only one token (e.g., token[0]) it makes impossible for other users to deposit other tokens (e.g., token[1]) as the totalSupply is not zero anymore, and _getNormalizedAmount considers the existing TVL:  Mellow Finance - Mellow Vaults -   28  SecurityHighVersion1CodeCorrectedVersion2SecurityHighVersion1CodeCorrected                \f// normalize amount uint256 res = FullMath.mulDiv(tvl_, lpAmount, supply); // if tvl_ == 0, res = 0  The intended use of the function might be that the first deposit is done by a trusted account, but this is not enforced.    A new constant FIRST_DEPOSIT_LIMIT is introduced and a require checks that each token amount is above this limit with tokenAmounts[i] > FIRST_DEPOSIT_LIMIT.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.16   Setting Wrong State Variable", "body": "  The function _setOperatorParams in VaultGovernance, as the name suggests, should update the state variable _operatorParams, instead it overwrites the variable _protocolParams:  function _setOperatorParams(bytes memory params) internal {     _requireAtLeastOperator();     _protocolParams = params; }  This mistake has severe consequences: operator gets admin privileges to set _protocolParams or can set  a  vault  state  to  incorrect  parameters.  Finally,  the  functionality  to  initialize  or  update  the _operatorParams is missing.    The  issue  is  resolved  and  now  the  function  _setOperatorParams  sets  the  operator  params  as intended. The natspec description has been updated accordingly also.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.17   Wrong Formula in ", "body": " _rebalanceUniV3Liquidity  The  function  _rebalanceUniV3Liquidity  in  LStrategy  updates  the  value  of  liquidity  as follows:  liquidity = uint128(     FullMath.mulDiv(         availableBalances[i],         shouldDepositTokenAmountsD[i] - shouldWithdrawTokenAmountsD[i],         DENOMINATOR     ) );  The  formula  above  is  wrong,  it  multiplies  two  amounts  in  token[i],  then  divides  the  result  with DENOMINATOR.  Mellow Finance - Mellow Vaults -   29  CorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                \f  The formula now multiplies with DENOMINATOR and divides by the token amount.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.18   Wrong TVL Calculation in ERC20RootVault", "body": "  ERC20RootVault._getTvlToken0  calculates  the  TVL  of  the  Vault  denominated  in  the  token  at position 0 of an array of tokens. It iterates over all the tokens in the array, but only ever compares token with index 0 to token with index 1. It should, however, compare token with index 0 to the token with the current iteration's index. The function is only used in _calculatePerformanceFees.  for (uint256 i = 1; i < tvls.length; i++) {         (uint256[] memory prices, ) = oracle.price(tokens[0], tokens[1], 0x28);    The issue has been resolved as the correct index is now used when querying the price of tokens inside the loop.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.19   liquidity Gets Overwritten in the Loop", "body": "  The following loop in LStrategy._rebalanceUniV3Liquidity updates the liquidity for vault tokens in a loop:  for (uint256 i = 0; i < 2; i++) {     ...     liquidity = uint128(         FullMath.mulDiv(             availableBalances[i],             shouldDepositTokenAmountsD[i] - shouldWithdrawTokenAmountsD[i],             DENOMINATOR         )     ); }  The  final  value  of  liquidity  after  the  loop  exists  should  be  the  minimum  value  calculated  in  each iteration, however, the loop above overwrites the liquidity on each iteration without performing any check.    In  with liquidity, hence liquidity can only decrease in the loop:    the  potentialLiquidity  is  computed  on  each  iteration  of  the  loop  and  it  is  compared  Mellow Finance - Mellow Vaults -   30  CorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrectedVersion2                \fliquidity = potentialLiquidity < liquidity ? potentialLiquidity : liquidity;  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.20   Wrong State Variable Updated", "body": "  The function LStrategy.rebalanceUniV3Vaults updates the wrong state variable when storing the timestamp of the ongoing rebalance:  require(     block.timestamp >= lastRebalanceUniV3VaultsTimestamp + otherParams.secondsBetweenRebalances,     ExceptionsLibrary.TIMESTAMP ); lastRebalanceERC20UniV3VaultsTimestamp = block.timestamp;  Due to this error the throttling mechanism does not work as expected for the function rebalancing the two function uniswap  vaults.  Furthermore,  rebalanceERC20UniV3Vaults.  throttling  mechanism  of   this  also  affects   the   the     The issue has been fixed and the correct state variable is updated in rebalanceUniV3Vaults:  lastRebalanceUniV3VaultsTimestamp = block.timestamp;  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.21   Inconsistent Access Control for Rebalance in", "body": " LStrategy  The  function  LStrategy.rebalanceERC20UniV3Vaults  restricts  the  access  to  only  accounts  with operator or admin roles. However, functions deposit and withdraw in the ERC20RootVault do not have  any  access  restriction  (unless  the  vault  is  private).  The  root  vault  has  the  operator  role  in LStrategy  and  for  any  deposit  or  withdraw  operation,  the  vault  triggers  the  rebalance  function  in LStrategy, hence circumventing the access control of the rebalance function.  Specification changed:  Mellow Finance has decided to remove the callback feature that triggered the rebalance in LStrategy. Now, the rebalance functions rebalanceERC20UniV3Vaults and rebalanceUniV3Vaults can be called only by whitelisted addresses with either admin or operator role. Note that, the callback feature is still present in ERC20RootVault in case future strategies will support the callback feature.  Mellow Finance - Mellow Vaults -   31  DesignMediumVersion8CodeCorrectedDesignMediumVersion4Speci\ufb01cationChanged                  \f6.22   Inconsistent Sanity Check on First Deposit's Amounts  The  function  ERC20RootVault.deposit  runs  the  following  loop  for  the  first  deposit  (whenever totalSupply  is  0)  to  check  that  all  amounts  are  above  a  threshold  FIRST_DEPOSIT_LIMIT (hard-coded to 10000):  if (totalSupply == 0) {     for (uint256 i = 0; i < tokens.length; ++i) {         require(tokenAmounts[i] > FIRST_DEPOSIT_LIMIT, ExceptionsLibrary.LIMIT_UNDERFLOW);     } }  The  contract  uses  another  set  of  thresholds  per  token  _pullExistentials  which  are  initialized  as: 10**(token.decimals() / 2). Hence for tokens with more than 8 decimals, there is a gap between the two thresholds FIRST_DEPOSIT_LIMIT and _pullExistentials. If the first deposit includes an amount for a token in this gap, the contract does not allow new deposits for the token from other users as the respective TVL will be always below the threshold _pullExistentials. This behavior is enforced in _getLpAmount:  for (uint256 i = 0; i < tvlsLength; ++i) {     if (tvl_[i] < pullExistentials[i]) {         continue;     }     ... }  and in the function _getNormalizedAmount:  if (tvl_ < existentialsAmount) {     // use zero-normalization when all tvls are dust-like     return 0; }    Mellow Finance now requires that the amount in the first deposit is 10 times the _pullExistentials.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.23   Safety Level of Returned Prices Can Silently", "body": " Downgrade  The  function  UniV3Oracle.price  returns  more  than  one  price  depending  on  the  value  of safetyIndicesSet. UniV3Oracle supports 4 safety levels:   Safety level 1: spot price.   Safety level 2: average price based on observations from last 2.5 minutes.  Mellow Finance - Mellow Vaults -   32  DesignMediumVersion4CodeCorrectedSecurityMediumVersion4Speci\ufb01cationChanged              \f Safety level 3: average price based on observations from last 7.5 minutes.   Safety level 4: average price based on observations from last 30 minutes.  If  a  Uniswap  pool  does  not  have  enough  observations  required  for  a  safety  level,  the  oracle  skips  the prices for such safety levels and returns only prices with lower safety levels. The respective code:  for (uint256 i = 2; i < 5; i++) {     ...     (int24 tickAverage, , bool withFail) = OracleLibrary.consult(address(pool), observationTimeDelta);     if (withFail) {         break;     }     ... }  Specifications changed:  The  natspec  description  of  IOracle.priceX96  has  been  updated  to  be  more  explicit  about  this behavior:  /// @notice It is possible that not all indices will have their respective prices returned.  Also, more detailed description has been added in UniV3Oracle.priceX96:  /// If there is no initialized pool for the passed tokens, empty arrays will be     returned. /// Depending on safetyIndicesSet if the 1st bit in safetyIndicesSet is non-zero, then     the response will contain the spot price. /// If there is a non-zero 2nd bit in the safetyIndicesSet and the corresponding     position in the pool was created no later than |l|_OBS_DELTA seconds ago, /// then the average price for the last |l|_OBS_DELTA seconds will be returned. The     same logic exists for the 3rd and MID_OBS_DELTA, and 4th index and |hl|_OBS_DELTA.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.24   Unfair Distribution of LP Shares in", "body": " ERC20RootVault  The  ERC20RootVault  charges  the  management,  protocol  and  performance  fees  by  minting  new  LP shares, hence inflating the total supply. The function _chargeFees is triggered on every deposit (and withdraw) action, hence the total supply of LP shares after a deposit increases more than the amount of LP shares awarded to the depositor. In this way, a second deposit of the same token amounts after the fees have been charged, receives more LP shares than the first one.  For  example,  assume  that  the  ERC20RootVault  has  been  initialized  and  a  first  user  deposits  10 TokenA and 10 TokenB (assuming 0 decimals for simplicity) and receives 10 LP shares. As the fees will be charged on deposit, let's suppose another 1 LP share will be minted, hence in total there are 11 LP shares  minted  after  the  deposit.  If  a  second  user  deposits  the  same  amounts  10  TokenA  and  10 TokenB, the function _getLpAmount will award 11 LP shares to the user although the same amounts were deposited.    Mellow Finance - Mellow Vaults -   33  DesignMediumVersion3CodeCorrected        \fThe  issue  has  been  addressed  by  modifying  the  functions  deposit  to  charge  fees  first  and  then compute the LP shares awarded to the user according to the new LP supply.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.25   Conflicting Specifications for MStrategy", "body": "  The specifications of MStrategy have conflicting instructions. The section \"TickMin and TickMax update\" states:  tickMin and tickMax are initially set to some ad-hoc params. As soon as the current price \u2014 tick is greater than tickMax - tickNeiborhood or less than tickMin + tickNeiborhood  the boundaries of the interval is expanded by tickIncrease amount.  In the rebalance steps, tickNeiborhood is used instead of tickIncrease:  - tick is greater than tickMax - tickNeiborhood then new     boundaries are [tickMin, tickMax + tickNeiborhood]  - tick is less than tickMin + tickNeiborhood then new     boundaries are [tickMin - tickNeiborhood, tickMax]  Specification changed:  The specification was changed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.26   Implementation Differs From Specification", "body": " on _targetTokenRatioD  The specifications use the following formula to compute the portions of tokens in a Uniswap v3 pool: | wx = tick \u2212 tickMax tickMin \u2212 tickMax  However, the implementation uses the following code:  return (uint256(uint24(tick - tickMin)) * DENOMINATOR) / uint256(uint24(tickMax - tickMin));  which corresponds to the following formula: |  wx = tick \u2212 tickMin  tickMax \u2212 tickMin    The  implementation  of  MStrategy._targetTokenRatioD  has  been  updated  to  comply  to  the specification.  Mellow Finance - Mellow Vaults -   34  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                    \f6.27   Incorrect Access of Addresses in  EnumerableSet  Function  commitAllValidatorsSurpassedDelay  in  the  protocol  governance  contract  has  a  for loop that iterates through _stagedValidatorsAddresses and commits the ones for which the delay period has passed. The respective code is:  for (uint256 i; i != length; i++) {     address stagedAddress = _stagedValidatorsAddresses.at(0);     if (block.timestamp >= stagedValidatorsTimestamps[stagedAddress]) {         ...     } }  The variable stagedAddress inside the loop points always to the hard-coded index 0, hence if there is at least one address in staged validators for which the deadline has not passed, the loop will just run until it reaches i==length.    The 0 was replaced by the index variable i. The loop exit conditions were changed to:  uint256 length = _stagedValidatorsAddresses.length(); ... uint256 addressesCommittedLength; for (uint256 i; i != length;) {         address stagedAddress = _stagedValidatorsAddresses.at(i);             ...             addressesCommitted[addressesCommittedLength] = stagedAddress;             ++addressesCommittedLength;             --length;             ...         } else {             ++i;         }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.28   Missing Checks for Dust Amounts When", "body": " Rebalancing Pools  The  function  _rebalancePools  in  MStrategy  rebalances  the  erc20Vault  and  moneyVault  to comply  to  the  specified  ratio  erc20MoneyRatioD.  The  rebalancing  is  performed  always  when  a non-zero amount should be moved from one vault to the other, i.e., even for dust amounts. Considering that pull is relatively costly, the strategy would be more efficient if it performs the rebalancing of the two pools only if a minimum threshold of tokens should be moved.  Mellow Finance - Mellow Vaults -   35  CorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  The updated code does not perform the token transfers if only dust amounts should be moved:  if ((absoluteTokenAmounts[0] < minDeviation) && (absoluteTokenAmounts[1] < minDeviation)) {     return tokenAmounts; }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.29   Missing Delay Restriction in BaseValidator", "body": "  Setting the new params in BaseValidator follows the pattern stage-wait-commit. On staging the new parameters, the respective timestamp is updated:  _stagedValidatorParamsTimestamp = block.timestamp + governance.governanceDelay;  However,  the  admin  of  the  governance  can  commit  the  staged  parameters  at  any  time,  e.g., immediately after staging them, by calling commitValidatorParams as the function does not check if the delay period has passed.    The  block.timestamp >= _stagedValidatorParamsTimestamp.  function   checks   delay   now   the   with   a   require   validating  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.30   Missing Sanity Checks in signOrder", "body": "  The function signOrder in LStrategy performs some sanity checks if the submitted order is in line with the values of the posted preOrder. However, the check for order.receiver is missing, therefore the caller can set any arbitrary address and receive the buyToken.    The  code  doing  the  sanity  checks  for  order  in  signOrder  has  been  moved  to  the  separate  function LStrategyOrderHelper.checkOrder  which  the erc20Vault.  the  receiver   the  check   includes   that   is   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.31   No Slippage Protection in Multiple Contracts", "body": "  push and pull functions in UniV3Vault take options arguments that contain the minimum amount of tokens for slippage protection.  Mellow Finance - Mellow Vaults -   36  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                        \fpush and pull functions in MellowVault take an options argument that contains the minimum amount of LP tokens for slippage protection.  In the following cases, these options are not used:  call    ERC20RootVault.deposit calls AggregateVault._push without options, which could result in described a  of  Vault``s  without  slippage  protection  if  the  first  ``subVault  of  the ERC20RootVault  is  one  of  the  described  Vault  s.  With  the  current  contract  setup,  this  is  not possible though.  _push   one   the   to   of    ERC20RootVault.withdraw calls AggregateVault._pull without options, which could result  in a call to _pull of one of the described ``Vault``s without slippage protection.   MStrategy.manualPull calls pull of an arbitrary Vault without options, which could result in a  call to _pull of one of the described ``Vault``s without slippage protection.   MStrategy._rebalancePools  calls  pull  of  an  arbitrary  Vault  without  options,  which  could  result in a call to _pull of one of the described ``Vault``s without slippage protection.   MStrategy._swapToTarget calls pull of an arbitrary Vault without options, which could result  in a call to _pull of one of the described ``Vault``s without slippage protection.    A new parameter with option for slippage protection was introduced.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.32   Possible Underflow in UniV3Oracle.price", "body": "  The UniV3Oracle computes the price of two tokens based on two observations obs1 and obs0 from the Uniswap. The respective code is:  uint256 obs1 = (uint256(observationIndex) + uint256(observationCardinality) - 1) %                 uint256(observationCardinality); uint256 obs0 = (uint256(observationIndex) + uint256(observationCardinality) - bfAvg) %                 uint256(observationCardinality); int256 tickAverage; {     (uint32 timestamp0, int56 tick0, , ) = IUniswapV3Pool(pool).observations(obs0);     (uint32 timestamp1, int56 tick1, , ) = IUniswapV3Pool(pool).observations(obs1);     uint256 timespan = timestamp1 - timestamp0; // reverts     ... }  The  obj1  points  to  the  previous  observation  (the  one  before  the  most  recent  observation),  while  the obj0 should point to bfAvg observations before obj1. However, in case:  bfAvg == observationCardinality  obj0 would point to the most recent observation, which would have a more recent timestamp than obj1, hence the statement to compute timespan would cause an underflow which reverts.    Mellow Finance - Mellow Vaults -   37  CorrectnessMediumVersion1CodeCorrected        \fThe  possibility  of  the  underflow  as  described  above  has  been  mitigated  in  the  updated  code  as  the bfAvg cannot be equal to obersvationCardinality:  if (observationCardinality <= bfAvg) {     continue; }  Note  that,  the  oracle  does  not  return  a  price  if  for  some  pool  bfAvg  is  equal  to  the  observations cardinality.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.33   Rebalance in LStrategy Can Leave Tokens in", "body": " the Vault to Be Closed  The  internal  function  _rebalanceUniV3Liquidity  should  move  the  desiredLiquidity  from  one vault to the other depending on the price trend. If the price moves outside the range covered by a vault, all liquidity should be moved to the other vault and a new position should be open. However, given that lowerVault and upperVault operate on different price ranges, it means that they have different token ratios.  Hence,  when  moving  tokens  from  one  vault  to  the  other,  the  function  caps  the  liquidity  being transferred to the available balance in the cash position that can fill the token difference of two positions (the relevant code is shown below). However, if the cash position has insufficient balance to cover the difference for the whole liquidity being transferred, fromVault will have some remaining liquidity, hence it cannot be closed. As a consequence, a new Uniswap position cannot be created to cover the price as intended.  uint128 potentialLiquidity = uint128(     FullMath.mulDiv(         availableBalances[i],         DENOMINATOR,         shouldDepositTokenAmountsD[i] - shouldWithdrawTokenAmountsD[i]     ) ); liquidity = potentialLiquidity < liquidity ? potentialLiquidity : liquidity;    The  function  LStrategy._rebalanceUniV3Liquidity  has  been  modified  in    to  withdraw everything from a vault when desiredLiquidity is set to maximum value of uint128, which is the case when a vault is to be closed. The relevant code is:  uint256[] memory withdrawTokenAmounts = fromVault.liquidityToTokenAmounts(     desiredLiquidity == type(uint128).max ? desiredLiquidity : liquidity ); pulledAmounts = fromVault.pull(     address(erc20Vault),     tokens,     withdrawTokenAmounts,     _makeUniswapVaultOptions(minWithdrawTokens, deadline) );  Mellow Finance - Mellow Vaults -   38  DesignMediumVersion1CodeCorrectedVersion3        \fThe array withdrawTokenAmounts will have huge amounts when the desiredLiquidity is set to max uint128, but the pull operation is capped to the existing balance of the fromVault.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.34   Subvault Tokens Are Not Checked in ", "body": " AggregateVault  AggregateVault  requires  the  _vaultTokens  state  array  to  be  initialized  with  the  same  tokens  and the  same  ordering  all  the  subvaults  have  been  initialized  with.  However,  this  is  not  enforced  upon initialization.    When initializing, the vault of the nft is queried in AggregateVault.initialize. The vault's tokens are  queried  afterwards  with  the  call  IIntegrationVault(vault).vaultTokens().  A  loop  checks for each token in the vault if it matches the tokens from the initialization arguments.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.35   Transferring Tokens Only to lowerVault", "body": "  The  following  code  should  transfer  tokens  from  erc20Vault  to  the  two  Uniswap  vaults  with  the respective amounts:  if (!isNegativeCapitalDelta) {     totalPulledAmounts = erc20Vault.pull(         address(lowerVault),         tokens,         lowerTokenAmounts,         _makeUniswapVaultOptions(minLowerVaultTokens, deadline)     );     pulledAmounts = erc20Vault.pull(         address(lowerVault),         tokens,         upperTokenAmounts,         _makeUniswapVaultOptions(minUpperVaultTokens, deadline)     );     for (uint256 i = 0; i < 2; i++) {         totalPulledAmounts[i] += pulledAmounts[i];     } }  Both transfers above are from the erc20Vault to the lowerVault, hence no tokens are transferred to the upperVault.    The  bug  has  been  fixed,  the  code  now  transfers  the  respective  amounts  to  the  lowerVault  and upperVault.  Mellow Finance - Mellow Vaults -   39  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f6.36   Use of Libraries  Mellow Finance often uses own custom code for which battle proof libraries exist. We highly recommend using libraries instead of custom implementations. Especially, when dealing with complex DeFi projects like Uniswap V3.  Code Corrected:  The  code  part  were  most  issues  were  found  was  the  Uniswap  oracle.  In  switched to the libraries provided by uniswap to interact with the oracle.    Mellow  Finance  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.37   Missing Sanity Checks for ", "body": " intervalWidthInTicks  function  LStrategy.updateOtherParams  does  not  perform  any  sanity  check  on  The  the intervalWidthInTicks. However, this parameter should be carefully updated as it affects directly the tick ranges covered by the two Uniswap vaults. For example, if the new width in ticks is the half of the existing one, the range of the new position would be fully covered by the existing vault (created with old width).    In  the  updated  version  of  the  codebase,  the  parameter  intervalWidthInTicks  is  declared  as  an immutable state variable, hence it set in the constructor and cannot be updated later.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.38   Possible Attack by First Depositor", "body": "  The decimals of the LP shares distributed by root vaults are implicitly determined by the token amounts deposited  by  the  first  user.  If  the  totalSupply  ever  goes  to  zero,  or  all  TVLs  are  not  significant,  the next  user  that  performs  a  deposit  would  affect  the  decimals  of  LP  shares.  This  setup  allows  the  first depositor  to  front-run  and  potentially  exploit  the  next  user  depositing  into  the  root  vault.  Consider  the following example.  1. First  Depositors  deposits  10  WBTC  (8  decimals,  so  10**9  wei)  and  10**-9  DAI  (18  decimals,  so  10**9 wei)   Receives 10**9 LP Tokens (= max(10**9, 10**9))  2. Second Depositor also sends a transaction to deposit 10 WBTC and 10**-9 DAI   Expects to receive also 10**9 LP Tokens, hence sets minLpTokens = 10**9  3. First depositor front-runs the transaction and performs these actions:  Mellow Finance - Mellow Vaults -   40  DesignMediumVersion1CodeCorrectedVersion3DesignLowVersion5CodeCorrectedSecurityLowVersion5Speci\ufb01cationChanged                        \f withdraw() => withdraws everything, no fees charged   deposit() => deposit 10**5 WBTC wei and 10**10 DAI wei => Receives 10**10 LP tokens   withdraw() => withdraws ~ 9 * 10**9 LP => TVLs = [10**4 - 1 WBTC wei, 10**9 - 1 USDC  wei]   First depositor still has ~ 10**9 LP  4. Transaction of second depositor is executed   _getLpAmount -> isSignificantTvl == False   Receives 10**9 LP tokens => slippage protection passes   Deposits 10 WBTC and 10**-9 DAI  5. First  depositor  withdraws  their  ~  10**9  LP  and  receives  ~  5  WBTC  (after  depositing  only  0.0001  WBTC)  Specifications changed:  The updated code mitigates the attack presented above by enforcing the first deposit into a root vault to mint  LP  shares  to  address(0).  To  prevent  from  accidentally  depositing  large  amounts  in  the  first deposit  (and  effectively  burning  LP  shares),  the  function  checks  that  all  amounts  being  deposited  are between 10 * _pullExistentials[i] and a full token. Nevertheless, one full token might still have significant value for some tokens, e.g., WBTC or ETH.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.39   Possible Optimization on", "body": " _chargePerformanceFees  The  function  _chargePerformanceFees  in  ERC20RootVault  mints  LP  tokens  to  the  treasury address as follows:  uint256 toMint; if (hwmsD18 > 0) {     toMint = FullMath.mulDiv(baseSupply, lpPriceD18 - hwmsD18, hwmsD18);     toMint = FullMath.mulDiv(toMint, performanceFee, CommonLibrary.DENOMINATOR); } lpPriceHighWaterMarkD18 = lpPriceD18; _mint(treasury, toMint);  The function would be more gas efficient if the minting is executed only for non-zero values, hence only minting when the if-condition is satisfied.    In  the  updated  code,  the  statement  _mint(...)  is  moved  inside  the  if-block,  hence  minting  only non-zero amounts.  Mellow Finance - Mellow Vaults -   41  DesignLowVersion5CodeCorrected          \f6.40   Possible Violation of the Minimum Token Amounts After the First Deposit  The function ERC20RootVault.deposit checks on the first deposit that all token amounts are larger than  a  minimum  value  10  *  _pullExistentials[i].  If  the  TVL  for  a  token  goes  below  the threshold,  users  cannot  make  deposits  for  that  token.  However,  the  first  depositor  can  circumvent  the restriction for the minimum token amounts by performing an withdrawal after the deposit.    The issue presented above is not present anymore in the updated code base as the first deposit always mints LP shares to address(0).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.41   Misleading Function Name and Natspec", "body": "  The function LStrategy.targetPrice returns the price in x96 format. Neither the function name, nor the natspec description clarify the format of the return value. We have reported another issue in a calling function which assumed the price to be returned in a different format.    The codebase has been updated to make more explicit in the function name and natspec description of getTargetPriceX96 that the returned price is in x96 format. Similarly, other functions that return the price in x96 format are renamed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.42   Mismatch of Specifications for", "body": " StrategyParams  The natspec description for the struct StrategyParams states that the params are changed with a delay:  /// @notice Params that could be changed by Strategy or Protocol Governance     with Protocol Governance delay.  while  the  natspec  description  of  the  function  setStrategyParams  states  that  they  are  changed immediately, which is in line with the implementation:  // @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.  Core corrected  The natspec was corrected and does not mention the governance delay.  Mellow Finance - Mellow Vaults -   42  DesignLowVersion5CodeCorrectedCorrectnessLowVersion4CodeCorrectedCorrectnessLowVersion4CodeCorrected                      \f6.43   Missing Sanity Check for maxSlippageD in MStrategy  The function MStrategy.setOracleParams does not check that maxSlippageD is greater than zero, but if it is accidentally set to zero, the following code will revert always: .. code::solidity  require(absoluteDeviation < oracleParams.maxTickDeviation, ExceptionsLibrary.INVARIANT);    The function setOracleParams is updated to include a check that the new maxSlippageD parameter is not zero:  require((params.maxSlippageD > 0) && (params.maxSlippageD <= DENOMINATOR), ExceptionsLibrary.INVARIANT);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.44   Missing Sanity Checks for oracleSafetyMask", "body": "  The  function  LStrategy.updateTradingParams  performs  sanity  checks  on  the  maxSlippageD, orderDeadline and oracle, but no checks are performed for oracleSafetyMask. This parameter should be non-zero for functions that query the oracle to work properly. Additionally, the function could check that at least one oracle with high safety index is included always.    An  additional  check  is  added  when  new  trading  params  are  set  by  the  admin.  The  check  fort  the  new oracle safety mask is: newTradingParams.oracleSafetyMask > 3.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.45   Possible Struct Optimization in Strategies", "body": "  Mellow Finance might want to consider to optimize some structs in the code base. E.g., in:  struct TradingParams {     uint32 maxSlippageD;     uint32 orderDeadline;     uint256 oracleSafetyMask;     IOracle oracle;     ...  struct PreOrder {     address tokenIn;     address tokenOut;     uint256 amountIn;  Mellow Finance - Mellow Vaults -   43  DesignLowVersion4CodeCorrectedDesignLowVersion4CodeCorrectedDesignLowVersion4CodeCorrected                        \f    uint256 minAmountOut;     uint256 deadline; }  struct RatioParams {     int24 tickMin;     int24 tickMax;     uint256 erc20MoneyRatioD;     int24 minTickRebalanceThreshold;     int24 tickNeighborhood;     int24 tickIncrease;     uint256 minErc20MoneyRatioDeviation0D;     uint256 minErc20MoneyRatioDeviation1D; }  Some  of  the  variables  will  not  take  up  a  whole  word  and  could  be  reordered  to  be  packed  tightly  if needed.    The variables in the structs listed above are reordered to be more efficient when stored in storage in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.46   Redundant Comparisons", "body": "  The function Univ3Vault._getMinMaxPrice implements the following code:  minPriceX96 = prices[0]; maxPriceX96 = prices[0]; for (uint32 i = 0; i < prices.length; ++i) {     if (prices[i] < minPriceX96) {         ...  Note that minPriceX96 and maxPriceX96 are assigned to prices[0] before the for-loop, so the first iteration of the loop is redundant.    The for-loop has been updated to start from i = 1 which avoids the redundant checks.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.47   Redundant Storage Read in ", "body": " ERC20Vault._pull  _vaultTokens  is  a  state  variable  that  is  read  multiple  times  in  the  _pull  function  even  though  it  is stored in memory at the beginning of the function in tokens.  Mellow Finance - Mellow Vaults -   44  DesignLowVersion4CodeCorrectedDesignLowVersion4CodeCorrected                \f  The  function  has  been  revised  to  avoid  storage  reads  for  _vaultTokens,  instead  the  value  stored  in memory tokens is now used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.48   Variables Can Be Declared as Constant", "body": "  The variable MAX_ESTIMATED_AAVE_APY in AaveVaultGovernance is declared as immutable and assigned  to  a  constant  in  constructor.  Similarly,  MAX_PROTOCOL_FEE,  MAX_MANAGEMENT_FEE  and MAX_PERFORMANCE_FEE in ERC20RootVaultGovernance can be declared as constants.    All immutable variables listed above are converted to constants.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.49   Incorrect Specification for reclaimTokens", "body": "  The following statement in IntegrationVault regarding the function reclaimTokens is incorrect:  /// `reclaimTokens` for mistakenly transfered tokens (not included into vaultTokens) /// additionally can be withdrawn by the protocol admin  Specification changed:  The statement in IntegrationVault has been changed as:  /// `reclaimTokens` for claiming rewards given by an underlying protocol to erc20Vault      in order to sell them there  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.50   Missing Natspec Description for ", "body": " minDeviation  The  parameter  minDeviation  in  the  function  LStrategy._liquidityDelta  has  no  natspec description.  Code Corrected:  The description for minDeviation was added.  Mellow Finance - Mellow Vaults -   45  DesignLowVersion4CodeCorrectedCorrectnessLowVersion3Speci\ufb01cationChangedCorrectnessLowVersion2CodeCorrected                        \f6.51   Casting of maxTickDeviation  maxTickDeviation  _getAverageTickChecked, the variable is casted as int24:  is  declared  as  uint24   in   the  struct  OracleParams.   In   function  int24 maxDeviation = int24(oracleParams.maxTickDeviation);  For large values of maxTickDeviation, an overflow can happen when casting as int24.    The  deviation  is  now  converted  to  an  absolute  value  and  directly  compared  to  the  maxDeviation without casting it to an int24.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.52   Check Requirements First", "body": "  Multiple functions can be more efficient by checking all requirements first (fail early), before performing expensive operations, such as external calls. We list below some examples (not an exhaustive list):   UniV2Validator: in validate both branches of the if condition require the msg.sender to be the  address  to.  The  function  can  be  optimized  by  checking  the  requirement  first,  and  then performing the call to _verifyPath function.   UniV2Validator:  the  function  _verifyPath  can  be  optimized  by  checking  the  following  requirement first, before making external calls in the loop:  require(vault.isVaultToken(path[path.length - 1]), ExceptionsLibrary.INVALID_TOKEN);   UniV3Validator:  the  function  _verifyMultiCall  can  be  optimized  by  checking  the  following  requirement first, before iterating through path and making external calls:  require(recipient == address(vault), ExceptionsLibrary.INVALID_TARGET);    The  updated  code  expensive for the cases listed above.    performs  the  checks  first  before  executing  other  operations  that  might  be  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.53   Duplicate Code _permissionIdsToMask", "body": "  The  function  revokePermissions  in  the  ProtocolGovernance  contract  implements  the  following loop:  Mellow Finance - Mellow Vaults -   46  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion3DesignLowVersion1CodeCorrected                        \fuint256 diff; for (uint256 i = 0; i < permissionIds.length; ++i) {         diff |= 1 << permissionIds[i]; }  which is a duplicate of the _permissionIdsToMask function.    The code part was replaced by a call to the _permissionIdsToMask function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.54   Duplicate Storage Read in Deposit", "body": "  In ERC20RootVault.deposit the variable totalSupply is read for the check if it is 0 and later again to be loaded into memory.    The redundant storage read is eliminated in the updated code and the value stored in memory supply is used instead.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.55   Inconsistent Specifications", "body": "  In the specifications of struct IProtocolGovernance.Params:   permissionless is described but it's not a member of the struct.   maxTokensPerVault  has  the  description  that  it  stores  the  maximum  tokens  managed  by  the  protocol, not a vault as the name suggests.   protocolTreasury is not described.  In the specifications of unitPrices, the comment staged for commit is wrong.  Specifications changed:  The specifications have been updated in    to address the issues reported above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.56   Inefficient Array Shrinking", "body": "  ProtocolGovernance.addressesByPermission  and ProtocolGovernance.commitAllPermissionGrantsSurpassedDelay  arrays  with extended length and copy the values to a newly generated array with the correct size. This can be more efficiently done with mstore assembly, which is also used in various other places in the code.  create   Mellow Finance - Mellow Vaults -   47  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedVersion2DesignLowVersion1CodeCorrected                        \f  The array is now cut to length via mstore as in other parts of the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.57   Inefficient State Variable Packing", "body": "  lastFeeCharge  and  totalWithdrawnAmountsTimestamp  in  ERC20RootVault  are  declared  as uint256.  Both  are  timestamps;  hence,  it  might  be  more  efficient  to  pack  them  as  uint64.  This  only makes sense if they are used and loaded together, which would be possible in the current code base. Similarly, other structs in other contracts can be more storage-efficient by packing variables together.    Both  variables  lastFeeCharge  and  totalWithdrawnAmountsTimestamp  have  been  declared  as uint64 in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.58   Misleading Naming of Variables in ", "body": " UniV3Oracle  The  function  price  uses  variable  names  that  are  inconsistent  with  the  variable  names  of  Uniswap. Namely,  the  variables  tick0  and  tick1  refer  to  tickCumulative  variables  of  Uniswap  and  not normal ticks.  Similarly,  the  array  pricesX96  temporarily  stores  prices  in  square  root  format  which  are  typically referred to as sqrtPriceX96. These inconsistencies make the reading of the code harder.  Code Corrected:  The variables were renamed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.59   Missing Sanity Check in ", "body": " MStrategy.createStrategy  In MStrategy.createStrategy any token array could be passed in, but the strategy can only handle two tokens. There is no sanity check to limit the number of tokens. The fee parameter is also not checked even though it could only take a limited range of values.    Mellow Finance - Mellow Vaults -   48  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe sanity check on the tokens array is added in the initialize function which is called when a new strategy  is  created.  The  sanity  check  for  the  fee  parameter  is  performed  when  the  pool  address  is queried:  pool = IUniswapV3Pool(factory.getPool(tokens[0], tokens[1], fee_)); require(address(pool) != address(0), ExceptionsLibrary.ADDRESS_ZERO);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.60   Missing Sanity Checks for Params", "body": "  LStrategy.updateRatioParams  and  LStrategy.updateOtherParams  do  not  perform  sanity checks on all the params.  Code Corrected:  Both functions now perform basic sanity checks for the arguments.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.61   Misspelled Variable Names", "body": "  Function  deposit  delayedStaretgyParams.  in  ERC20RootVault  declares  a   variable  with  misspelled  name:  Struct ratioParams in MStrategy declares a variable with misspelled name: tickNeiborhood.    Both variable names have been corrected in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.62   Possible Struct Optimization", "body": "  Mellow Finance might want to consider to optimize some structs in the code base. E.g., in:  struct TradingParams {     uint256 maxSlippageD;     uint256 minRebalanceWaitTime;      ...  struct RatioParams {     uint256 erc20UniV3CapitalRatioD;     uint256 erc20TokenRatioD;     uint256 minErc20UniV3CapitalRatioDeviationD;     uint256 minErc20TokenRatioDeviationD;     uint256 minUniV3LiquidityRatioDeviationD  Mellow Finance - Mellow Vaults -   49  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fSome of the variables will not take up a whole word and could be packed if needed.    The examples above and some other structs were changed. We assume that Mellow Finance evaluated all structs if an optimization is suitable and shall be applied.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.63   Rebalance in MStrategy Is Inconsistent", "body": "  MStrategy provides only one function for rebalancing (rebalance) which calls _rebalancePools to enforce  the  predetermined  ratio  for  the  pools  (erc20Vault  and  moneyVault)  and  then  calls _rebalanceTokens to enforce the token ratio for the erc20Vault. The latter calls _swapToTarget which, in specific cases, pulls tokens from the moneyVault to the erc20Vault:  if (amountIn > erc20Tvl[tokenInIndex]) {     ...     moneyVault_.pull(address(erc20Vault_), tokens_, tokenAmounts, \"\");     ... }  This  transfer  of  tokens  from  moneyVault  to  the  erc20Vault  would  break  the  balance  set  in  the function _rebalancePools called in the beginning of the rebalance process.    The function rebalance has been updated to perform first the rebalance of tokens in the erc20Vault, which includes any potential swap. Afterwards, the function calls _rebalancePools which enforces the predetermined ratio of TVLs for the erc20Vault and moneyVault.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.64   Specification for minDeviation Not", "body": " Enforced  The function rebalanceERC20UniV3Vaults in LStrategy calls the function _liquidityDelta and provides the minimum required deviation for a rebalance to be performed. _liquidityDelta checks the  current  deviation  and  if  it  is  lower  than  the  required  minimum,  it  returns  0.  However,  the  calling function  does  not  check  the  return  value,  hence  continues  the  execution  of  the  function  although  no tokens will be moved.    The  check  below  for  the  return  value  of  the  function  _liquidityDelta  has  been  added.  Now  the function returns immediately if capitalDelta is equal to 0 due to current deviation being smaller than the minimum required deviation:  Mellow Finance - Mellow Vaults -   50  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f(capitalDelta, isNegativeCapitalDelta) = _liquidityDelta(...); if (capitalDelta == 0) {     return (pulledAmounts, false); }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.65   Storing Redundant Data in Storage", "body": "  The function _addUniV3Pools stores two entities in the mapping for each pair of tokens:  poolsIndex[token0][token1] = pool; poolsIndex[token1][token0] = pool;  Given that there is only one Uniswap pool for a pair of tokens and a fee, the tokens can be sorted and stored only once in the mapping: tokenA -> tokenB -> pool, assuming tokenA < tokenB.    The  mapping  poolsIndex  token0 -> token1 -> pool.  now   stores   only   one   entry   for   a   pair   of   tokens  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.66   Unnecessary Approval to Vault Registry", "body": "  Function _initialize in Vault has the following line which gives approval to the vault registry, but it is unnecessary as VaultRegistry is the implementation contract of the NFT token:  registry.setApprovalForAll(address(registry), true);    The statement giving the approval has been removed from the function in   .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.67   Unused Constant in ERC20Validator", "body": "  ERC20Validator declares the following constant, but it is not used:  bytes4 public constant EXCHANGE_SELECTOR = 0x3df02124;    Mellow Finance - Mellow Vaults -   51  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrected                        \fThe constant was removed from the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.68   Unused Event DeployedVault", "body": "  The  contract  VaultGovernance  defines  the  event  DeployedVault  but  it  is  not  used  in  the  current code base.    The updated code emits the event DeployedVault when a new vault is created.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.69   Unused Function ", "body": " LStrategy._priceX96FromTick  The internal function LStrategy._priceX96FromTick is not used in the LStrategy.    The function was removed from the L Strategy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.70   Unused Imports", "body": "  Throughout the code base we found many unused imports. Due to the number of unused imports, the following list is non-exhaustive and list only examples:  -MellowOracle  import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"  import \"../libraries/CommonLibrary.sol\";   UniV2Oracle  import \"../libraries/ExceptionsLibrary.sol\"   UniV3Oracle  import \"../libraries/ExceptionsLibrary.sol\"   LStrategy  import \"../interfaces/IVaultRegistry.sol\"  import \"../interfaces/utils/IContractMeta.sol\"   MStrategy  import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";   CowswapValidator  Mellow Finance - Mellow Vaults -   52  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fimport \"../libraries/CommonLibrary.sol\"  import \"../libraries/PermissionIdsLibrary.sol\"   CurveValidator  import \"../libraries/CommonLibrary.sol\"  import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"  import \"../interfaces/validators/IValidator.sol\";   ERC20Validator  import \"../libraries/CommonLibrary.sol\"   UniV2Validator and UniV3Validator  import \"../interfaces/validators/IValidator.sol\";  import \"../libraries/CommonLibrary.sol\"  import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"   AaveVault  import \"../interfaces/vaults/IVault.sol\"   AggregateVault  import \"../interfaces/vaults/IAggregateVault.sol\";  import \"../libraries/PermissionIdsLibrary.sol\"   ERC20RootVault  import \"../interfaces/utils/IContractMeta.sol\"  Code partially corrected:  The  unused  imports  have  been  removed  from  the  respective  contracts  for  all  examples  listed  above, except for the SafeERC20 import in the MStrategy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.71   Wrong Check of Minimum Token Amounts in ", "body": " ERC20RootVault.withdraw  ERC20RootVault.withdraw  compares  the  token  amounts  a  user  wants  to  receive  at  minimum  with the  calculated  token  amounts,  but  not  the  token  amounts  that  are  actually  returned  after  pulling  from underlying Vault s. This could potentially result in the user receiving less tokens than anticipated.    The actual token amounts pulled from vaults are now validated against the minimum amounts provided by the user: `` require(actualTokenAmounts[i] >= minTokenAmounts[i],...);``  Mellow Finance - Mellow Vaults -   53  CorrectnessLowVersion1CodeCorrected          \f6.72   Wrong Specification for YearnVault.tvl  The specification in YearnVault mentions that YearnVault.tvl returns a cached value when in fact it does not.  Specification changed:  The  specification  has  been  updated  in  removed.    and  the  statement  about  the  cached  value  has  been  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.73   ContractRegistry DOS", "body": "  ContractRegistry.registerContract  checks  that  the  version  of  a  registered  contract  is  always increasing in:  require(newContractVersion > _latestVersion(newContractName), ExceptionsLibrary.INVARIANT);  If a contract is deployed with a version set to max uint, this would be the last contract possible to add to the system. No contracts could be added afterwards.    Mellow  Finance  introduced  major  and  minor  contract  version.  The  16  right  most  bytes  are  the  minor version and the remaining bytes to the right the major version. A require ensures that with each call to registerContract  with newContractVersionMajor - latestContractVersionMajor <= 1.  increase   version   major   only   can   the   by   1   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.74   ERC20Vault._pull Forces Push of Wrong", "body": " Amount of Tokens  In ERC20Vault._pull, if tokens are not pulled to the ERC20RootVault, the receiving Vault is forced to push the received tokens. The token amounts to be pushed are set in actualTokenAmounts, but this variable is never used. Instead tokenAmounts is used.    The  code  has  been  corrected  to  push  into  the  integration  vault  the  amounts  as  stored  in actualTokenAmounts.  Mellow Finance - Mellow Vaults -   54  CorrectnessLowVersion1Speci\ufb01cationChangedVersion3SecurityLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.75   IntegrationVault._root Does Not Check the NFT of the Root Vault  IntegrationVault._root  tries  to  verify  the  initialization  of  a  given  Vault  and  its  corresponding ERC20RootVault with the following code:  require(thisNft + thisOwnerNft != 0, ExceptionsLibrary.INIT);  If thisNft is set (greater than 0) and thisOwnerNft equals 0, no revert will happen. _root is called in pull  only.  pull  already  checks  that  the  argument  thisNft  given  to  _root  is  not  equal  to  0  which renders the require useless.    The  statement  was  changed  and  checks  each  variable  separately  (thisNft != 0) && (thisOwnerNft != 0).  if   it   is  zero   in  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.76   VaultGovernance.commitInternalParams", "body": "  Does Not Delete Staged Parameters  VaultGovernance.commitInternalParams  does  not  delete  the  _stagedInternalParams  state variable.    The state variable _stagedInternalParams is now deleted after it is applied.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "6.77   registry.ownerOf Is Called Twice in", "body": " IntegrationVault.pull  registry.ownerOf  is  called  twice  with  the  same  value  in  IntegrationVault.pull,  inducing unnecessary additional gas costs.    The obvious redundant call to registry.ownerOf was removed. Still, there would be another call in _isApprovedOrOwner.  Mellow Finance - Mellow Vaults -   55  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.1   Approximated TVL for Aave Vaults", "body": "  The function AaveVault.tvl() computes an approximate total value locked (TVL) based on the time passed  since  the  parameter the  estimatedAaveAPY:  function  updateTvls  was  called  and   time   last   the   uint256 apy = IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().estimatedAaveAPY; factor = CommonLibrary.DENOMINATOR + FullMath.mulDiv(apy, timeElapsed, CommonLibrary.YEAR);  Note  that  the  parameter  estimatedAaveAPY  is  set  by  the  protocol  admin  for  all  tokens  of  the  vault, hence the function tvl might return incorrect values if updateTvls is not called frequently.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.2   Balances Are Drained Faster in Vaults With", "body": " Lower Index  AggregateVault._pull pulls funds out of the underlying Vault's by pulling the maximum amount out of  each  Vault  sequentially.  This  drains  funds  faster  from  Vault's  depending  on  their  index  in  the _subvaultNfts state variable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.3   Deposits Can Be Blocked by Updating", "body": " StrategyParams  The function ERC20RootVaultGovernance.setStrategyParams does not perform any sanity check for the new parameters being set, hence if tokenLimitPerAddress or tokenLimit is set to zero, the functionality to deposit is blocked. The sanity checks are not enforced intentionally as the admin might use these parameters to block deposits into a root vault by updating these parameters.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.4   Deprecated Function _setupRole", "body": "  DefaultAccessControl  and  DefaultAccessControlLateInit  use  the  function  _setupRole, which according to its specification is deprecated:  /**  * NOTE: This function is deprecated in favor of {_grantRole}.  */  Mellow Finance - Mellow Vaults -   56  NoteVersion4NoteVersion1NoteVersion1NoteVersion1              \f7.5   Duplicate Declaration of DENOMINATOR  Both MStrategy and LStrategy import CommonLibrary which declares the constant DENOMINATOR, however, they also declare the constant as well.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.6   Dust LP Shares Are Burned", "body": "  If a user decides to redeem its LP shares in a root vault by calling the function withdraw, and if at the time of this action the amount of remaining LP shares represents less than the threshold existentials in underlying tokens, the whole user's LP balance is burned. Put shortly, the function prevents users from leaving dust amounts in LP shares when withdrawing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.7   External Functions in ContractMeta", "body": "  ContractMeta  implements  external  pure  functions,  and  currently  they  are  called  only  by registerContract  in  ContractRegistry.  The  calls  are  performed  as  three  external  calls,  which increase gas costs, as there is no function in ContractMeta returning all values in a single external call.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.8   LP Tokens of the First Deposit Are Burned", "body": "  In  to address(0), practically burning them.   of the code base, the LP tokens of the first user depositing into a root vault are always send  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.9   Locked Token or ETH", "body": "  ERC20 tokens could be accidentally/intentionally sent to any contract. In such cases the tokens will be locked. Only externalCall for intergration vaults offers some functionality to recover funds.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.10   No Checks for Address to on ERC20Token", "body": " Transfer  The functions transfer and transferFrom in ERC20Token do not perform any sanity check for the address to, hence making it possible to burn tokens by sending them to address 0x0.  Mellow Finance - Mellow Vaults -   57  NoteVersion1NoteVersion6NoteVersion1NoteVersion6Version6NoteVersion1NoteVersion1                          \f7.11   Non Canonical Signatures  function   IntegrationVault.isValidSignature   The  function CommonLibrary.recoverSigner to validate signatures if the strategy is an externally owned account. Note  that,  the  function  recoverSigner  does  not  perform  any  sanity  check  on  values  r,  s  and  v  to ensure  that  only  unique  signatures  validate  successfully.  Therefore,  callers  of  this  function  should  be aware of possible attacks (https://swcregistry.io/docs/SWC-117).  library   uses   the   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.12   Non-indexed Event Topics", "body": "  Some  events  have  already  hit  in UnitPricesGovernance have not and do not index the token address. Given that the unit price update could be important to users, making the token address indexed, makes it easier to filter the events for specific tokens.  topics.  But   the  events   limit  of   indexed   three   the   There are some other events like DeployedVault in VaultGovernance, ReclaimTokens and Pull in  IntegrationVault  and  RebalancedUniV3  in  LStrategy  where  one  more  index  could  be  set. Additionally,  some  events  could  emit  the  nft  which  might  be  worth  indexing  (it  e.g.,  is  done  in SetStrategyParams). This is just noted and up to Mellow Finance to decide.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.13   OracleParams in MStrategy", "body": "  Te  admin  of  MStrategy  should  carefully  set  the  OracleParams.  The  admin  should  ensure  that  the Uniswap used for the oracle has enough observations to cover oracleObservationDelta, otherwise the  function  _getAverageTickChecked  called  in  _rebalanceTokens  will  only  use  the  spot  price, hence  making  the  rebalance  function  vulnerable  to  sandwich  attacks.  Additionally,  the  parameter maxTickDeviation should be carefully chosen to enforce proper slippage protection for the rebalance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.14   Performance Fee Capped", "body": "  ERC20RootVault._chargePerformanceFees only charges performance fees for the strategy if the price of LP tokens has reached a new high score. When prices have fallen, the fees are still not charged even when prices climb again until this all-time high has been reached again.  Additionally, if all liquidity providers withdraw their funds and the totalSupply is zero, or all token TVLs are  less  than  _pullExistentials,  the  previous  high  score  lpPriceHighWaterMarkD18  is  not reset, hence performance fees might not be collected as expected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.15   Rebalance of Uniswap Vaults in LStrategy", "body": "  The  function  rebalanceUniV3Vaults  maintains  a  ratio  of  tokens  in  the  two  Uniswap  positions depending  on  the  move  of  the  current  price.  If  the  price  goes  up,  more  tokens  are  transferred  into  the upperVault from the lowerVault, and vice-versa. The function is designed in a way that it tries to add  Mellow Finance - Mellow Vaults -   58  NoteVersion4NoteVersion1NoteVersion5NoteVersion5NoteVersion4                  \fthe same liquidity amount into the destination vault that is removed from the other vault. However, since the two vaults operate in different price ranges, the same liquidity amount translates into different token amounts.  The  token  in  the  cash  position  (erc20Vault)  are  used  to  cover  for  the  difference. Consequently  the  ratio  between  the  cash  position  (erc20Vault)  and  the  money  vaults  (lowerVault and upperVault) is affected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.16   Rollback Individual Validators Not Possible", "body": "  ProtocolGovernance  implements  a  function  to  rollback  all  staged  validators,  but  there  is  no functionality to rollback individual staged validators.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.17   Special Behavior in ERC20Token", "body": "  The function transferFrom has a special behavior when allowance==type(uint256).max, as the allowance  is  never  reduced  when  these  transfers  occur.  This  special  behavior  should  be  properly documented as users should be aware of it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.18   Trust Setup", "body": "  The  system  has  multiple  trusted  roles  and  heavily  relies  on  admin  operations  to  work.  E.g.,  setting oracles and the admin needs to maintain enough funds to open new Uniswap positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.19   Uneven Gas Distribution on deposit and", "body": " withdraw  Fees are not calculated on every transaction. Therefore, some users are burdened with more gas costs than others depending on the time they are performing their withdraw and deposit actions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.20   Unit Prices Amounts", "body": "  The admin in UnitPricesGovernance can set the amounts of a given token that match the value of 1 USD. The prices are set with a delay of 14 days, hence the prices are not supposed to reflect the market price. Note that, for valuable tokens with few decimals, it might be impossible to store the correct token amount that matches 1 USD.  Mellow Finance - Mellow Vaults -   59  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion5                      \f7.21   Unnecessary Creation of Pair  In  UniV3Vault._push  and  UniV3Vault._pullUniV3Nft,  a  Pair  is  created  and  not  used  as  a Pair afterwards. Instead, the particular values are extracted from the Pair, rendering the creation of the Pair useless.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.22   ContractRegistry Functions Truncate", "body": " name  Functions  versions,  versionAddress  and  latestVersion  in  ContractRegistry  truncate  the input parameter name_ to 32 bytes:  bytes32 name = bytes32(bytes(name_));  If these functions are called with name_ longer than 32 bytes, the return value would be based on the truncated input parameter name_, which is inconsistent behavior.  Furthermore,  the  function  latestVersion  parses  the  input  parameter  name_  differently  from  other functions:  bytes32 name = bytes32(abi.encodePacked(name_));  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.23   LStrategy Needs Tokens to Create Uniswap", "body": " Positions  The  function  _mintNewNft  assumes  that  the  strategy  contract  has  enough  balance  to  open  new Uniswap positions as needed, otherwise new Uniswap NFTs cannot be minted:  IERC20(tokens[0]).safeApprove(address(positionManager), minToken0ForOpening); IERC20(tokens[1]).safeApprove(address(positionManager), minToken1ForOpening); (newNft, , , ) = positionManager.mint(     INonfungiblePositionManager.MintParams({         token0: tokens[0],         token1: tokens[1],         fee: poolFee,         tickLower: lowerTick,         tickUpper: upperTick,         amount0Desired: minToken0ForOpening, // required balance         amount1Desired: minToken1ForOpening, // required balance         amount0Min: 0,         amount1Min: 0,         recipient: address(this),         deadline: deadline     }) );  Mellow Finance - Mellow Vaults -   60  NoteVersion1NoteVersion1NoteVersion1          \fMellow  Finance  is  aware  of  this  requirement  and  states  they  will  take  care  that  enough  funds  are available at any point in time. Additionally, a check was added to ensure that the amount of token needed in the contract is very low (less than 10**9) to mitigate that money is lost because of the deactivated slippage protection in the function above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.24   _pullExistentials Are Unevenly", "body": " Distributed in Terms of Value  _pullExistentials  in  AggregateVault  are  set  to  10**(token.decimals()  /  2)  for  each token. This is an uneven distribution considering that tokens may have different value. The existential for USDT for example has a much lower value than the existential for WBTC.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "7.25   addressesByPermission Does Not", "body": " Consider Forced Permissions  The  function  addressesByPermission  in  the  protocol  governance  contract  returns  only  addresses that  explicitly  have  the  permissionId  in  the  mapping  permissionMasks.  However,  if  the permissionId  is  enforced  by  forceAllowMask,  then  all  addresses  are  assumed  to  have  the permission.  Mellow Finance - Mellow Vaults -   61  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mellow-protocol/"}, {"title": "5.1   Effects of Snapshotting at Every Block", "body": "  The HoprToken performs a state snapshot at every block. That has the following effects:  1. Significant extra gas costs for a token transfer compared to regular token implementations. Even if none  of  the  callbacks  are  executed,  there  is  an  expected  overhead  of  69,400  gas  compared  to  a regular ERC-20 token and 62,600 compared to a regular ERC-777 token.  Some addresses, e.g. HoprDistributor or exchange addresses will amass a considerable number of snapshots. This has two additional effects:  2. The overall contracts state size will be rather big. In case that ETH2.0 transitions to stateless clients,  state proofs will be relatively large for all Hopr balances.  3. The  gas  cost  of  calling  balanceOfAt  for  these  contracts  with  many  snapshots  will  continue  to grow.  However,  as  it  only  grows  logarithmically  it  will  foreseeably  not  reach  a  critical  level.  The impact  of  this  is  also  determined  by  whether  balanceOfAt  is  primarily  intended  for  on-chain  or off-chain use.  Risk accepted:  Hoprnet replied:  Due to our approach with our upcoming DAO contract, we require a snapshot on every block.  Hoprnet - Hoprnet Token -   7  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedDesignLowVersion1RiskAccepted             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Burn Function of HoprToken Can Cause Inconsistent Snapshot    Wrong Check in the HoprDistributor claim Function   -Severity Findings   Miners Can Claim With Schedule Violation   -Severity Findings   Multiple Storage Writes    Redundant Condition Check in _valueAt    Snapshot Inefficiency    Superfluous Call to _beforeTokenTransfer    Timestamp Conversion Has Redundant Operation   0  2  1  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.1   Burn Function of HoprToken Can Cause", "body": " Inconsistent Snapshot  interface   The  ERC777  has  a  _beforeTokenTransfer  hook  that  is  called  in  the  burn,  transfer  and  mint functions. Also it introduced _callTokensToSend and _callTokensReceived functions that can call the  registry.  ERC777Snapshot  utilizes _beforeTokenTransfer  to  track  the  snapshots  after  each  balance  change.  Due  to  the  order  of _beforeTokenTransfer  and  _callTokensReceived  functions  in  the  _burn  function,  there  is  a possibility of reentrancy, that can cause the snapshots to be in an inconsistent state.  implementations   in  ERC1820   registered   function _burn(     address from,     uint256 amount,     bytes memory data,     bytes memory operatorData )     internal virtual {     require(from != address(0), \"ERC777: burn from the zero address\");      address operator = _msgSender();      _beforeTokenTransfer(operator, from, address(0), amount);  Hoprnet - Hoprnet Token -   8  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected        \f    _callTokensToSend(operator, from, address(0), amount, data, operatorData);      // Update state variables     _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");     _totalSupply = _totalSupply.sub(amount);      emit Burned(operator, from, amount, data, operatorData);     emit Transfer(from, address(0), amount); }  function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual override {     super._beforeTokenTransfer(operator, from, to, amount);      if (from == address(0)) {         // mint         updateValueAtNow(accountSnapshots[to], balanceOf(to).add(amount));         updateValueAtNow(totalSupplySnapshots, totalSupply().add(amount));     } else if (to == address(0)) {         // burn         updateValueAtNow(accountSnapshots[from], balanceOf(from).sub(amount));         updateValueAtNow(totalSupplySnapshots, totalSupply().sub(amount));     } else if (from != to) {         // transfer         updateValueAtNow(accountSnapshots[from], balanceOf(from).sub(amount));         updateValueAtNow(accountSnapshots[to], balanceOf(to).add(amount));     } }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.1.1   Attack scenario", "body": " Attacker  can  register  a  IERC777Sender  smart  contract  in  the  ERC1820  registry  that  will  transfer  Hopr Tokens  to  the  attacker.  When  this  transfer  happens  in  the  _callTokensToSend  from  ERC1820 registered implementation, the snapshot will be overwritten again, using balanceOf value, that has not been yet updated.  In a trace example above, with green color marked balance updates and with yellow - snapshot updates. Due to dependency of snapshot updates depend on balance updates, the reentrancy issue arise. In the other  ERC777  functions,  such  as  the  transfer  function,  where  the  _callTokensToSend  goes  before any state updates, such a problem does not arise. To avoid the issue, the newly released OpenZeppelin contracts should be used.    Hoprnet - Hoprnet Token -   9  \fThe  HoprToken  now  uses  an  OpenZeppelin  ERC777  implementation  that  does  not  have  a  reentrancy vulnerability in its burn function. The snapshot is now updated after the external call.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.2   Wrong Check in the HoprDistributor claim", "body": " Function  The  claim  function  of  the  HoprDistributor  calls  internal  _claim  function  that  contains  following code:  uint128 newClaimed = _addUint128(allocation.claimed, claimable); // Trying to claim more than allocated assert(claimable <= newClaimed);  This  assertion  can  only  be  violated  if  the  _addUint128  operation  overflows.  But  check  of  overflow  is already  present  the newClaimed  <=  allocation.amount.  The  comment  above  the  assertion  also  describes  the intention.  the  _addUint128.   there  are  no   In  addition,   checks   for   in     The assertion was rewritten. The new assertion checks that the value of newClaimed does not exceed the total allocated amount.  assert(newClaimed <= allocation.amount);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.3   Miners Can Claim With Schedule Violation", "body": "  The  claim  function  calls  the  _getClaimable  function  to  determine  the  amount  users  can  claim depending on the elapsed periods.  for (uint256 i = 0; i < schedule.durations.length; i++) {     uint128 scheduleDeadline = _addUint128(startTime, schedule.durations[i]);      // schedule deadline not passed, exiting     if (scheduleDeadline > _currentBlockTimestamp()) break;     // already claimed during this period, skipping     if (allocation.lastClaim > scheduleDeadline) continue;      claimable = _addUint128(claimable, _divUint128(_mulUint128(allocation.amount, schedule.percents[i]), MULTIPLIER)); }  At the end of claim execution, the allocation.lastClaim is reassigned, to disable repetitive claims for the same period of the schedule.  allocation.lastClaim = _currentBlockTimestamp();  But  if  multiple  claims  will  be  send  with  block.timestamp  equal  to  scheduleDeadline  of  some schedule  period,  multiple  repetitive  claims  of  this  blocks  will  be  possible.  This  will  effectively  allow  the hackers to ignore the schedule. While this operation is hard to time right using regular transaction, miners can craft such transactions.  Hoprnet - Hoprnet Token -   10  SecurityHighVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                \fCombined with nonexistent allocation.amount <= newClaimed check in claim function, this bug also allows to claim more than the allocated amount.    The condition in the loop was rewritten. Now the equality case will be skipped and repetitive claims for the same periods of the schedule are not possible.  if (allocation.lastClaim >= scheduleDeadline) continue;  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.4   Multiple Storage Writes", "body": "  The  addAllocations  function  repeatedly  writes  to  and  reads  from  the  totalToBeMinted  storage variable. This incurs additional gas costs. Note, however, that the additional gas costs will be significantly lowered by the upcoming EIP-2929.    A new variable _totalToBeMinted was introduced. All repetitive operations are performed on it. Thus, gas is saved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.5   Redundant Condition Check in _valueAt", "body": "  The  functions  balanceOfAt  and  totalSupplyAt  of  the  HoprToken  have  following  branching conditions:  if (     (accountSnapshots[_owner].length == 0) ||     (accountSnapshots[_owner][0].fromBlock > _blockNumber) ) {  if (     (totalSupplySnapshots.length == 0) ||     (totalSupplySnapshots[0].fromBlock > _blockNumber) ) {  In addition, both of these public functions rely on internal _valueAt function. Meanwhile the _valueAt has following branching conditions:  if (snapshots.length == 0) return 0;  if (_block < snapshots[0].fromBlock) {  Those conditions are redundant and will never be triggered.  Hoprnet - Hoprnet Token -   11  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  The checks are now performed only inside the _valueAt function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.6   Snapshot Inefficiency", "body": "  Hoprnet implemented the following binary search:  // Binary search of the value in the array     uint256 min = 0;     uint256 max = snapshots.length - 1;     while (max > min) {         uint256 mid = (max + min + 1) / 2;         if (snapshots[mid].fromBlock <= _block) {             min = mid;         } else {             max = mid - 1;         }     }     return snapshots[min].value;  In  case  the  _block  number  matches  the  block  number  of  one  of  the  snapshots,  the  implementation could be optimized. The equality case:  snapshots[mid].fromBlock == _block  is not handled explicitly. Given that in this case, the result has already been found, there is no need for further unnecessary iterations.  Code Corrected:  The code was adjusted and now explicitly checks for equality:  uint256 midSnapshotFrom = snapshots[mid].fromBlock; if (midSnapshotFrom == _block) {     return snapshots[mid].value;  Hence, the inefficiency is gone.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.7   Superfluous Call to _beforeTokenTransfer", "body": "  When  overriding  the  empty  parent  function  _beforeTokenTransfer  from  the  ERC777  template, super._beforeTokenTransfer  gets  called.  This  call  has  no  effect  as  the  parent  is  empty.  Due  to current  state  of  Solidity  compiler,  this  call  will  create  unnecessary  operations  with  no  effects.  Small amount of gas (+-30) will be wasted.    Hoprnet - Hoprnet Token -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fThe superfluous call to the super class was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.8   Timestamp Conversion Has Redundant", "body": " Operation  Function  _currentBlockTimestamp  has  a  modulo  operation  that  can  be  dropped.  The  default behavior of solidity uint128(X) conversion achieves the same result and uses less gas.  function _currentBlockTimestamp() internal view returns (uint128) {     // solhint-disable-next-line     return uint128(block.timestamp % 2 ** 128); }    The superfluous modulo operation was removed.  Hoprnet - Hoprnet Token -   13  DesignLowVersion1CodeCorrected        \f7   Notes  We leverage this section to highlight potential pitfalls which are fairly common when working Distributed Ledger Technologies. As such technologies are still rather novel not all developers might yet be aware of these  pitfalls.  Hence,  the  mentioned  topics  serve  to  clarify  or  support  the  report,  but  do  not  require  a modification  inside  the  project.  Instead,  they  should  raise  awareness  in  order  to  improve  the  overall understanding for users and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "7.1   ERC-20 Approve Race Condition", "body": "  The ERC-20 standard has a well-known race condition for the approve function if both the new and the implementations  add  increaseApproval  and old  approval  are  non-zero.  Hence,  a  decreaseApproval  functions  which  do  not  have  this  issue.  The  Hopr  Token  does  not  have  such functions. Hence, it is up to users and using smart contracts to avoid the issue.  lot   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "7.2   Floating Pragma", "body": "  The solc version is fixed in the hardhat configuration to version 0.6.6. However, the files have a floating pragma.  Furthermore, please note the chosen compiler version 0.6.6 has five known bugs.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "7.3   Ownership Cannot Be Atomically Transferred", "body": "  The specification says:  allow admin to transfer or revoke their ownership  There is no classical role transfer function inside the contract. The admin can add a new admin and later revoke itself, but not perform an atomic role transfer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "7.4   Schedules Are Specified Using UTF-8 Strings", "body": "  The distribution schedules are addressed using UTF-8 strings. UTF-8 strings have well-known security implications, such as characters that look identical to humans, but have a different byte representation or inverse character order. Hence, calls like addAllocations could theoretically be referencing a different schedule than expected.  However, as all of the functions setting up allocations can only be executed by the administrators, there is fairly low risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "7.5   Theoretical Overflow in Binary Search", "body": "  Hoprnet - Hoprnet Token -   14  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \fIn theory the binary search can overflow. This would affect the following computation:  uint mid = (max + min + 1) / 2;  This  could  occur  as  soon  as  snapshots.length  would  be  larger  than  2**255.  As  this  implies  that 2**255 snapshots have been taken, which implies that 2**255 blocks have passed, it is irrelevant in practice.  Hoprnet - Hoprnet Token -   15  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-hoprnet-token/"}, {"title": "6.1   Unprotected Escrow Funds", "body": "  L1DAIBridge.deposit() transfers DAI from a user-specified address from to the L1Escrow contract to lock DAI on layer one. However, a malicious user could specify from to be the L1Escrow contract that holds all of the locked funds. The call to DAI.transferFrom() will succeed since the escrow must have had approved the bridge contract. Ultimately, unbacked DAI could be minted on L2 and funds from the escrow could be stolen.  Consider the following scenario:  1. User calls deposit() with from being the escrow contract.  2. The   to  amount <= allowance[escrow][bridge].  self-transfer   from   and   escrow   succeeds   as   long   as  3. The ceiling check passes as long as balanceOf(escrow) <= ceiling since the balance does  not change.  4. Ultimately, a message to L2 is sent and unbacked DAI on L2 is minted.  5. Repeat the process.  6. Withdraw DAI from L2 to L1, such that the escrow is emptied.  MakerDAO - StarkNet-DAI-Bridge -   12  CriticalCodeCorrectedHighCodeCorrectedMediumCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected            \fThe README.md file in the repository states:  ### Initial configuration      ... Unlimited allowance on `L1Escrow` should be given to `L1DAIBridge`.  Hence an attacker may drain all DAI out of the escrow.  Furthermore, e.g. by frontrunning a deposit transaction or exploiting an unlimited approval given by the user to the bridge it is possible to steal L1 DAI from users. Consider the following scenario:  1. User  A  intends  to  deposit  DAI  to  L2  and  approves  the  bridge  contract.  He  either  gives  an  exact approval  for  the  amount  he  wants  to  deposit  or  may  give  an  unlimited  approval  as  he  trusts  the bridge contract and intends to use it in the future. Next he crafts a transaction to deposit.  2. User B calls deposit() and specifies the from address to be user A. The call succeeds and B receives funds on L2. Note that the DAI locked on L1 are from user A. This transaction frontruns the deposit call coming from user A.  3. User A's deposit is executed but fails due to lack of allowance.  Note that although they are known to be potentially dangerous it is quiet common that users give infinite approval to such systems they trust and intend to interact with frequently.    The  from  parameter  has  been  removed  from  function  deposit.  The  DAI  amount  is  now  transferred from msg.sender to the escrow. Hence the issue described above no longer exists.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.2   L2 DAI Allows Stealing", "body": "  The transfer function of the L2 DAI contract allows stealing tokens from other users. The attack works as follows:  1. Within the amount field of the transfer function the user specifies an invalid Uint256. Note that uint256_check  is  never  called.  To  steal  i  token  wei,  the  attacker  specifies  P-i  to  be amount.low  and  0  to  be  amount.high.  The  low  amount  could  be  interpreted  as  the  negative number -i.  2. The  uint256_le(amount,  sender_balance)  check  will  be  passed  as  it  will  ultimately  compute the following:  1 - is_nn(amount.low - (sender_balance.low+1))  If for example the sender's (attacker's balance) is 0, that check will pass.  3. The  uint256_sub(sender_balance,  amount)  computation  will  result  in  an  increased  sender_balance due to the specially crafted amount.  4. The  uint256_add(recipient_balance,  amount)  computation  will  result  in  a  decreased  recipient_balance due to the specially crafted amount.  Note that the decrease of the recipient_balance is also the increase of the sender_balance. In other words, the sender gains as many tokens as the recipient loses. Or more concisely, the sender can steal all of the tokens of the receiver. So, if i==1 then one token wei is stolen. If i==2 then two wei are stolen.  MakerDAO - StarkNet-DAI-Bridge -   13  SecurityHighVersion1CodeCorrected        \fThe  only  precondition  for  the  attack  is  that  the  uint256_le(amount,  sender_balance)  can  be passed  for  manipulated  amount  values.  Note  that  the  current  hints  prevent  a  proof  generation  for  this attack in uint256_add, but hints can freely be changed and the verifier will accept it.    amount  is  now  validated  in  the  internal  function  _transfer.  Thus,  neither  transfer()  nor transfer_from  can  perform  computations  with  invalid  integers.  Ultimately,  the  Uint256  library functions receive the expected inputs and, thus, perform the documented computations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.3   Frontrun cancelDeposit()", "body": "  L1->L2   After  L1DAIBridge.startDepositCancellation()  L1DAIBridge.cancelDeposit() can be used to complete the cancellation and retrieve the DAI.  initiated  has   cancellation   message   delay   been   time   and   has   the   using passed,  The caller of the function must provide the details to retrieve the message (the amount, the l2Recipient and the nonce) and as parameter l1Recipient any address to receive the funds on L1.  There is no access control, the first caller can retrieve the DAI to any address.    msg.sender  is  now  included  in  payload  of  deposit(),  startDepositCancellation()  and cancelDeposit(). Hence, a successful cancellation requires that the same msg.sender in all three calls of the process. Otherwise, the payload would be different.  payload[3] = uint256(uint160(msg.sender)); StarkNetLike(starkNet).cancelL1ToL2Message(l2DaiBridge, DEPOSIT, payload, nonce);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.4   ForceWithdrawal Needs Prior Approval", "body": "  In  the  case  that  a  user  believes  they  are  censored,  the  user  can  initiate  the  withdrawal  using  the forceWithdraw function of the L1DAIBridge. When the L2 network works as expected, the withdrawal request is handled.  This however has some prerequisites:  1. The  user  needs  to  have  registered  his  L1  address  in  the  L2  registry  prior  to  initiating forceWithdraw(). Note that this may no longer be possible when the L2 network is censoring transactions hence this should be done by the users before receiving DAI on L2.  2. The  execution  of  finalize_force_withdrawal  on  L2  in  case  the  Layer2  network  complies requires  that  the  user  has  previously  given  allowance  to  the  l2_dai_bridge.  Again,  giving  the approval  at  this  point  in  time  may  no  longer  be  possible  in  case  the  L2  network  censors transactions.  MakerDAO - StarkNet-DAI-Bridge -   14  SecurityMediumVersion4CodeCorrectedCorrectnessMediumVersion1CodeCorrectedSpeci\ufb01cationChanged                  \f# check allowance let (contract_address) = get_contract_address() let (allowance : Uint256) = IDAI.allowance(dai, source, contract_address) let (allowance_check) = uint256_le(amount, allowance) if allowance_check == 0:     return () end  This  requirement  is  not  documented  and  may  come  as  a  surprise  for  the  user.  Note  that  for  normal withdrawals  from  L2  using  withdraw  no  such  allowance  is  needed.  Furthermore  without  the  check  in finalize_force_withdrawal  the l2_dai_bridge  is  a  ward  in  the  DAI  contract  and  has  the  privilege  to  burn  the  DAI  of  any  address without the need for an approval.  the  DAI  would  work  as   the  withdrawal   /  burning  of   The case that the L2 network may only censors transactions other than forced withdrawals (in order to avoid detection of the misbehavior) and its implication must be considered.  Overall the ForcedWithdrawal process and it's restrictions is not documented enough.  Code corrected and specification changed:  and   hence   Issue  1)  was  addressed  by  improving  the  documentation.  The  documentation  now  clearly  states  what actions  are  required  before  a  forced  withdrawal  can  be  executed.  The  enhanced  documentation  also resolves 2), note that in the updated code a ward of the DAI contract no longer has the privilege to burn understand  why needed.  DAI  finalize_force_withdrawal  must  check  whether  the  approval  exists:  Burning  without  the allowance would result in the transaction to revert. The prover can't prove failed executions, reverts are indistinguishable  from  censored  messages.  By  checking  the  allowance  and  gracefully  terminate  the transaction  when  no  sufficient  allowance  exist,  the  transaction  can  be  executed.  Hence  the  message from L1 can be processed which allows to clear the message in the StarkNet contract on Ethereum. This proves that the transaction must have been executed on L2.  important   approval   the   It's   to   is   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.5   L2 Address Sanity Checks", "body": "  In StarkNet users do not have addresses. Transactions sent to the network have the 0 address as caller. In  order  to  identify  accounts  via  addresses,  each  user  deploys  his  account  contract  and  interacts  with contracts such as the DAI token using his account-contract.   The deposit() function of the L1DAIBridge contract allows users to deposit with the to address set to 0. The execution of finalize_deposit initiated by the l1_handler on l2 however will fail as minting DAI for the zero address will revert. As a result the deposited DAIs on L1 will be locked in the escrow.  Furthermore, note that to will be received as a felt on L2. Hence, the true to address on L2 will be to  %  R.  Therefore,  it  could  be  possible  to  for  example  specify  address  R  on  L1  which  will  map  to zero-address (similarly R+1 will map to address 1). Users could be protected from errors by restricting the allowed address range on L1.   L2 DAI allows to give approvals specifying the 0 address as caller. All holders of L2 DAI must be aware  that  this  is  very  dangerous  and  means  that  anyone  crafting  an  external  transaction  to  the network can transfer their DAI using this approval.  MakerDAO - StarkNet-DAI-Bridge -   15  DesignMediumVersion1CodeCorrected        \f A user could specify the l2_dai contract as the recipient of the funds on deposit. Since the L1 call would succeed while the L2 call to the l1_handler would fail, the cross-layer message would remain unconsumed.    The code does the following checks now on L1:   to != 0 to ensure that the address is non-zero.   to != l2Dai to prevent a failing mint.   to < SN_PRIME to prevent a possible StarkNet overflow.   All functions related to approvals in the l2 DAI contract now forbid approving the zero-address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.6   Relay Parameter Mismatch", "body": "  The  L1GovernanceRelay  is  used  to  send  messages  to  the  L2  GovernanceRelay  to  execute  spells. However,  the  parameters  sent  by  the  L1  contract  and  the  parameters  the  L2  contract  receives  do  not match. Ultimately, governance spells cannot be relayed to L2.  More specifically, the L1GovernanceRelay sends a message to L2 as follows:  uint256[] memory payload = new uint256[](2); payload[0] = to; payload[1] = selector;  StarkNetLike(starkNet).sendMessageToL2(l2GovernanceRelay, RELAY_SELECTOR, payload);  However, the L2 side of the governance relay consumes the message as follows:  @l1_handler func relay{   syscall_ptr : felt*,   pedersen_ptr : HashBuiltin*,   range_check_ptr  }(    from_address : felt,    target : felt  ):    let (l1_governance_relay) = _l1_governance_relay.read()    assert l1_governance_relay = from_address    let (calldata : felt*) = alloc()    delegate_call(target, EXECUTE_SELECTOR, 0, calldata)    return ()  end  The  arguments  of  the  L1  handler  should  consist  of  the  from_address  and  payload.  However,  the payload created on L1 has two elements. That ultimately lets the execution of a governance spell fail.  MakerDAO - StarkNet-DAI-Bridge -   16  CorrectnessMediumVersion1CodeCorrected        \f  The unused selector was removed from the payload, the payload now contains the spell only.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.7   Unlimited Approvals and the Range of Uint256", "body": "  DAI on L1 supports unlimited approvals using uint256(-1) as magic value. When an approval for this magic value is given, the spender can spend the funds of the token holder without the allowance being reduced.  Similarly  the  DAI  contract  in  cairo  supports  an  unlimited  approval  using  a  different  magic  number.  As Uint256 work differently in cairo, it's possible to define a magic value outside the actual range of Uint256. In cairo, a Uint256 is represented by a struct containing two felt members:  struct Uint256:     # The low 128 bits of the value.     member low : felt     # The high 128 bits of the value.     member high : felt end  However note that a felt can store more than 128 bits, so a Uint256 represented by such a struct may contain a value exceeding the max uint256 value.  The code of the DAI cairo contract, however, takes advantage of this special property of the Uint256 type and defines the magic number for the unlimited approval as:  const MAX_SPLIT = 2**128 let MAX = Uint256(low=MAX_SPLIT, high=MAX_SPLIT)  Note  that  the  common  library  for  Uint256  offers  a  function  uint256_check  which  checks  if  the  given Uint256 is actually valid. The code of the DAI cairo contract uses this function to check whether amounts regarding  balances  are  valid.  In  contrast,  the  code  is  generally  not  using  uint256_check()  when handling or checking approvals. That results in following potentially intended and/or strange behaviour:   Function approve can be used to give allowance for a valid amount, the magic number or an invalid  uint256 value.   Function  increase_allowance  does  not  work  on  such  allowances  due  to  the  carry  over. However,  increasing  with  bad  input  values  could  decrease  the  allowance  (in  a  similar  fashion  as described in L2 DAI allows stealing).   Function  decrease_allowance  works.  However,  note  that  decreasing  to  the  magic  number  results in unlimited approval so that allowance has been increased instead of decreased.  Concluding, the selection of the magic value outside the valid range for Uint256 could lead to unexpected and  undocumented  behaviour  due  to  an  implied  lack  of  Uint256  validity  checks.  Furthermore,  the deviation from L1-DAI's magic value may confuse users.    MAX_SPLIT has been renamed to ALL_ONES and redefined to 2**128-1. Also, uint256_check() is called  now  in  the  functions  approve,  increase_allowance  and  decrease_allowance.  Since  the inputs  are  always  validated  and  allowance  cannot  be  out  of  the  valid  Uint256  range,  the  unintended behaviour cannot occur anymore.  MakerDAO - StarkNet-DAI-Bridge -   17  DesignMediumVersion1CodeCorrected        \f6.8   ERC-20 Functions Have No Return Values  EIP-20  specifies  that  for  example  transfer  has  a  boolean  return  value.  However,  L2  DAI  does  not return anything.    Return values have been implemented for the ERC-20 functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.9   Inconsistent Version Pragma", "body": "  Different  to  the  L1Escrow  contract,  the  L1DAIBridge  and  the  L1GovernanceRelay  contract  feature following version pragma:  This allows the contracts to be compiled with any Solidity version >= 0.7.6 including more recent major version which may feature changes in the syntax.  The Solidity documentation states:  Source files can (and should) be annotated with a version pragma to reject compilation with future compiler versions that might introduce incompatible changes.  For  https://docs.soliditylang.org/en/develop/layout-of-source-files.html#version-pragma  information,   please   more   refer   to:    The pragmas have been changed to:  pragma solidity ^0.7.6;  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.10   Inefficiency in Reading Allowances", "body": "  In  function  burn  of  the  DAI  cairo  contract  the  allowance  is  always  read.  However,  it  is  only  used  if check_allowances  ==  1  is  true.  Thus,  the  efficiency  of  the  functionality  could  be  improved. Similarly, that is the case for transferFrom().    In the updated code wards no longer have special privileges in dai.burn(). Due to the changed code, the issue described above no longer applies.  MakerDAO - StarkNet-DAI-Bridge -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                          \f6.11   Lack of L1-address Sanity Checks on L2  L1 addresses on L2 are of felt type. However, that could ultimately lead to bad user-input on L2 when passing L1 addresses since L1 addresses have 160 bits which is less than the number of bits the felt type is represented with.  For example, in function withdraw() of the L2 bridge contract a user passes an L1 address as felt which could to a bad address being passed to L1.    A check has been added to send_finalize_withdraw() with ensures that the destination is a valid L1 address. This function is used by both, withdraw and finalize_force_withdrawal.  In  the  initial  round  of  fixes  the  assert_l1_address  function  contained  unnecessary  declarations  of local syscall_ptr and local pedersen_ptr which now have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "6.12   Unused Code", "body": "  The L1DAIBridge contract defines the struct SplitUint256. However, it remains unused.    The unused struct was removed.  MakerDAO - StarkNet-DAI-Bridge -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-dai-bridge/"}, {"title": "5.1   Inefficient Transfer Hook", "body": "  The  internal  function  ERC20Farmable.beforeTokenTransfer  is  called  before  any  transfer  logic  is executed. Assuming that user A is farming on n and user B is farming on m farms without any overlap in the sets, then,   m+n addresses are loaded from storage at the very beginning,   m+n external calls are made,   m+n storage writes to corrections,   and more reads and writes.  Furthermore,  m  and  n  are  not  limited.  A  token  transfer  could  end  up  being  very  expensive  without  the user noticing. Hence, token transfers could easily fail by running out of gas.  Risk accepted:  1inch accepts the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "5.2   Insufficient Documentation", "body": "  1inch - Farming -   9  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedAcknowledgedCodePartiallyCorrectedDesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                     \fDocumentation helps users, developers and others to understand a system in a shorter amount of time. Especially if the code is to be used as a library by other developers, it could help these to prevent errors. Otherwise, no assumptions on the code and its behavior can be made.  Currently, code is undocumented. Furthermore, no behavioral description is provided on what to expect from  a  function  call.  For  example,  it  is  undocumented  how  the  libraries  handle  errors  in  external contracts.  Acknowledged:  1inch replied:  Will be improved in the future.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "5.3   Lack of Events", "body": "  Typically,  events  help  track  the  state  of  the  smart  contract.  Some  functions,  such  as  startFarming, emit events while others do not emit any event. Some examples lacking event emissions are:   ERC20Farmable.farm()   ERC20Farmable.claim() and FarmingPool.claim()   ERC20Farmable.exit()   Public checkpointing functions   BaseFarm.setDistributor()  Code partially corrected:  An event has been added only for setDistributor().  1inch - Farming -   10  DesignLowVersion1CodePartiallyCorrected          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  0  7  -Severity Findings  -Severity Findings   Gas Griefing   -Severity Findings  -Severity Findings   Commented Code    Farms Rely on Token to Checkpoint    Gas Inefficiencies   Ineffective period Check   Introduction of Batched Operations    Usage as a Library   farmingCheckpoint() Has No Functionality   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.1   Gas Griefing", "body": "  ERC20Farmable  calls  farm  contracts  in  every  call  to  farmedPerToken()  to  query  information  with IFarm.farmedSinceCheckpointScaled() on how many rewards have been released so far. Even though  that  call  is  handled  with  a  try/catch  block  to  prevent  the  target  contract  from  reverting maliciously, it is still possible that the farm consumes all gas.  1. A malicious farm honeypots users into joining.  2. The malicious farm contract is upgraded through an upgradeability pattern.  3. Every call to farmedSinceCheckpointScaled() consumes all gas.  Now, following is not possible:   any ERC20Farmable transfer from an affected user   any ERC20Farmable transfer to an affected user   exiting the malicious farm   Claiming from the malicious farm  Ultimately, tokens will be locked for affected users.    1inch - Farming -   11  CriticalHighCodeCorrectedMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected           \fThe call to IFarm.famedSinceCheckpointScaled() now has a gas limit. If the gas limit of 200000 is exceeded, the failure is handled by behaving equivalently to a revert in the farm contract.  Additionally, the static-call was wrapped inside an assembly block to prevent the return data bomb issue in the Solidity compiler (documented here: https://github.com/ethereum/solidity/issues/12306).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.2   Commented Code", "body": "  ERC20Farmable._getFarmedSinceCheckpointscaled  contains  commented  code.  Removing  the code could help keep the code cleaner such that it is easier to understand.    Commented out code has been replaced by calls to on onError().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.3   Farms Rely on Token to Checkpoint", "body": "  Farm._updateFarmingState() calls checkpoint() of an external ERC20Farmable contract. Then, the  ERC20Farmable  contract  calls  Farm.farmingCheckpoint().  However,  a  malicious ERC20Farmable  to Farm.farmingCheckpoint(). Hence, the farm checkpoints could remain without updates.  implementation   purposefully   could   leave   call   the   out     farmingCheckpoint has been removed from the farm contracts. Hence, there is no need to call it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.4   Gas Inefficiencies", "body": "  In multiple locations code could be optimized to reduce gas cost. Some examples are:   Function UserAccounting.checkpoint() loads the stored update time and the store farmed per token  value  from  storage.  However,  to  correctly  call  that  function  it  is  required  to  first  call farmedPerToken() which also loads the same variable from storage. Hence, storage reads could be prevented.  In  function  FarmingPool.exit()  balanceOf  is  called  twice.  However,  the  second  time  it  is called it is evident that it must be zero.   _beforeTokenTransfer could exit early for self-transfers.   Casting  period  to  uint40  when  the  input  could  have  been  restricted  to  be  uint40  in  startFarming.    The overall gas consumption has been optimized.  1inch - Farming -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                         \f6.5   Ineffective period Check  FarmAccounting.startFarming() contains following code:  require(period < 2**40, \"FA: Period too large\"); require(amount < 2**176, \"FA: Amount too large\"); (info.finished, info.duration, info.reward) = (uint40(block.timestamp + period), uint40(period), uint176(amount));  However, the first check is insufficient for uint40(block.timestamp + period) not to overflow.    The precondition was changed to:  require(period + block.timestamp <= 2**40, \"FA: Period too large\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.6   Introduction of Batched Operations", "body": "  Assume a user participates in 10 farms for a farmable token. To claim all rewards the user needs to call claim()  multiple  times.  Gas  consumption  could  be  reduced  by  allowing  batched  operations  for ERC20Farmable.    Following batched operations have been introduced:   claimAll: claims on all farms   quitAll: quits all farms  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.7   Usage as a Library", "body": "  ERC20Farmable  is  intended  to  be  used  as  a  library  for  farmable  ERC-20  tokens.  As  such,  some functions may require to be overridden so their functionality can be enhanced. However, no function in the  supplied  codebase  has  a  virtual  modifier,  and  so  child  contracts  cannot  override  any  method, meaning code that inherits from ERC20Farmable cannot extend its core functionality.  On the other hand, for some functions it could make sense to disallow overriding. An example could be farmedPerToken()  which  specifies  the  distribution  among  token  holders.  Allowing  developers  to modify its behaviour could lead to subtle issues that may not be caught during testing.  Assuming there is a use-case of changing the semantics of computing the farmed amount, code would require changes in several functions. First, farmed() would require changes. Second, claim() would require  changes  as  it  calls  UserAccounting.farmed()  instead  of  farmed.  Hence,  wrapping functionality  from  libraries  in  the  abstract  ERC20Farmable  and  using  the  wrapper  functions  internally could ease the overriding process and prevent errors.  1inch - Farming -   13  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fFurthermore, it could be that some functions should not be callable by any child contracts, and there are certain  state  variables  that  should  not  be  set  in  child  contracts.  For  example,  farmTotalSupply  is  a public  variable,  querying  that  value  is  helpful  for  users  interacting  with  the  contract.  However, developers  could  unknowingly  interleave  writes  to  that  variable  in  between  updates  to  it  in  the  internal callflow  which  would  lead  to  inconsistent  state.  In  that  case,  it  could  be  helpful  to  have  a  public  getter while restricting writes in child contracts.  To  summarize,  1inch  provides  a  library  for  staking.  Since  documentation  is  also  part  of  writing  an application library, it would be helpful to explicitly document the overridability and the visibility of functions and variables, as well as their intended use.    The code has been adapted and functions have been marked as virtual.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.8   farmingCheckpoint() Has No Functionality", "body": "  FarmAccounting.farmingCheckpoint()  is  empty  and  has  no  functionality.  The  calls  to  it  further complicate the code. Moreover, replacing farm accounting logic through overriding is not easily possible.  Additionally, Farm._updateFarmingState() lacks checkpointing for a farm's state.    The function has been removed.  1inch - Farming -   14  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "7.1   Calls to Farms", "body": "  Note that the system interacts with untrusted farms and untrusted contracts.  Changes  implemented  or  functionality  in  contracts  inheriting  from  ERC20Farmable  should  ensure  that there  is  no  possibility  of  re-entering  the  ERC20Farmable  contract  when  interacting  with  untrusted contracts since that could lead to possible unwanted modifications of farming state for other farms.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "7.2   farmedSinceCheckpointScaled() Decimals", "body": "  Note that farms may run into issues if a Farm's farmedSinceCheckpointScaled() does not return a value that is in the base of 10**(18 + rewardToken.decimals()):   Assume the call to farmedSinceCheckpointScaled() returns a value in the base of 10**x.   Then,   the   call   to   farmedPerToken  will   return   something   in   the   base   of  10**(x-ERC20Farmable.decimals()) which implies that corrections is in base of 10**x.  In farmed, the subtraction arguments will be both in base 10**x. However, the result of the division will be in the base of 10**(x-18).  Using Farm of 1inch, will ensure that x==18+rewardToken.decimals(). However, if that is not the case, errors could occur.  1inch - Farming -   15  NoteVersion1NoteVersion1       \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-farming/"}, {"title": "6.1   Bypassing Antisnipping Protection", "body": "  The  AntisnippingManager  implements  logic  to  protect  against  so-called  liquidity-snipping  (Just-in-Time Liquidity)  attacks  to  prevent  attackers  from  adding  much  liquidity  before  a  swap  and  removing  it  right afterwards to collect most of the fees while not being exposed to LP risks.  Kyber Network removes the economic incentive of such an attack by locking fees for vestingPeriod which means an immediate withdrawal of liquidity should set the collected fees to zero.  Note,  that  AntiSnipAttack  protection  only  comes  in  play  if  feeGrowthInsideLast  of  the  position manager and the feeGrowthInsideLast of the position are not equal:  if (feeGrowthInsideLast != pos.feeGrowthInsideLast) {     ....     (additionalRTokenOwed, feesBurnable) = AntiSnipAttack.update(  Kyber Network - KyberSwap Elastic -   12  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedSecurityHighVersion1CodeCorrected         \f    ... }  Also, feesBurnable can only be non-zero if liquidity is removed:  if (isAddLiquidity) {     .... } else if (_self.feesLocked > 0) {     feesBurnable = (_self.feesLocked * liquidityDelta) / uint256(currentLiquidity);     _self.feesLocked -= feesBurnable; }  Thus, the following attack is possible:  1. Attacker sees a huge swap and mints an enormous position  2. Swap occurs.  3. An attacker adds a small amount of liquidity. The position's feeGrowthInsideLast is updated.  However, rTokens are now locked.  4. An attacker removes all his liquidity which does not enter the AntiSnipAttack code since there was  no fee growth. Liquidity is withdrawn and rTokens remain locked.  5. After vestingPeriod has passed the attacker can withdraw the newly generated fees.  Even  though  the  attacker  does  not  immediately  withdraw  the  fees,  his  liquidity  came  and  went immediately while generating a temporarily locked profit for the attacker.    In version 3 of the code, the Antisnipping protection logic is triggered on every call of removeLiquidity function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.2   Function Pool.burnRTokens Return Values", "body": "  Function burnRTokens of Pool contract has following definition:  /// @return qty0 token0 quantity sent to the caller for burnt reinvestment tokens /// @return qty1 token1 quantity sent to the caller for burnt reinvestment tokens function burnRTokens(uint256 qty, bool isLogicalBurn)   external   returns (uint256 qty0, uint256 qty1);  However the qty0 and qty1 value are not assigned in the implementation of this function. Thus 0 values will be returned instead.  The position managers rely on these return values as they implement slippage protection as follows:  (amount0, amount1) = pool.burnRTokens(rTokenQty, false); require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Low return amounts');  Ultimately, the transaction will revert if amount0Min > 0 && amount1Min >0 holds.  Kyber Network - KyberSwap Elastic -   13  CorrectnessHighVersion1CodeCorrected        \f  The values are now properly assigned to the return variables.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.3   Locked Funds Remain Locked After ", "body": " vestingPeriod Update  The AntiSnipAttackPositionManager prevents profitable snipping attacks by locking rewards for a certain in amount  of  stored  AntiSnipAttackPositionManager:antiSnipAttack[tokenId].feesLocked.  However,  if vestingPeriod is set to zero, feesLocked remains locked.  in  a  position  with  tokenId  are   time.  The   locked   fees   Assume the following scenario:  1. vestingPeriod = 1 day  2. User mints a position.  3. After 12 hours, the User adds liquidity to a position. Assume that 1 rToken in fees has been earned  totally while half of it is locked.  4. vestingPeriod set to 0.  5. Whenever the user performs a position-modifying action, the following code gets executed.  if (vestingPeriod == 0) return (feesSinceLastAction, 0);  6. Only the newly accumulated fees become claimable while the locked fees remain locked. Hence,  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "0.5 rTokens will be unclaimable.", "body": "  Thus,  changes  to  the  vestingPeriod  can  potentially  allow  users  withdrawal  of  more  fees,  than  it  was intended.  Current  AntiSnipAttackPositionManager  and  AntiSnipAttack  library  rely  on  constant vestingPeriod. To conclude, the AntiSnipAttack library should be aware that the vesting period for fees could change.    If  vestingPeriod  is  zero  and  fees  are  still  locked,  feesLocked  is  added  to  the  claimable  fees  and feesLocked is set to 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.4   Broken/Partial ERC165 Support", "body": "  The  ERC-721  specifies  that  the  ERC-165  interface  must  be  implemented  which  defines  a  standard method to publish and detect what interfaces a smart contract implements.  function supportsInterface(bytes4 interfaceID) external view returns (bool);  The more derived ERC-721 contracts of Kyber Network do not overwrite this function. Hence, querying the  support  of  the  additionally  implemented  interfaces  through  supportsInterface()  will  return false.  Kyber Network - KyberSwap Elastic -   14  CorrectnessHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  The  issue  has  been  addressed.  Function  supportsInterface  will  return  true  for  the  following interfaces.   ERC721Enumerable  IERC721Permit  Thus, they are considered as supported by the contract according to ERC-165.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.5   Function Pool.unlockPool Reentrancy", "body": "  Pools  are  created  in  a  locked  state  and  need  to  be  unlocked  first.  The  unlockPool  function  first removes  the  lock  and  then  perform  the  mintCallback.  The  _initPoolStorage  is  called  after  the callback.  This  is  an  important  function  that  finalizes  the  setup  of  storage  for  the  pool.  This mintCallback after unlock and before _initPoolStorage can be misused by the malicious parties, since  all  pool  functions  will  be  available  during  the  call.  Attacker  can  potentially  misconfigure  or  abuse intermediate state inconsistency for its own profit. In addition, the mintCallback is usually performed to whitelisted position managers, while in this case any contract can be called.    The callback has been removed for unlocking pools. Now, funds have to be transferred to the pool before unlocking the pool.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.6   Function ERC721Permit.permit Payable", "body": "  The  function  permit  has  a  payable  modifier  while  abstract  class  ERC721Permit  does  not  have  any other functions that can withdraw funds. The BasePositionManager that inherits this class has a separate receive function for ether transfers. Hence, the payable modifier could be removed from permit.    The payable modifier was removed from the permit function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.7   Function Pool.burnRTokens Natspec", "body": "  The  burnRTokens  does  not  describe  the  bool  isLogicalBurn  argument  with  a  @param  tag.  This argument greatly influences the result of burn and thus should be described.  Specification changed:  Kyber Network - KyberSwap Elastic -   15  SecurityMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChanged                         \fisLogicalBurn is now documented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.8   Function Pool.burnRTokens Potential", "body": " Reentrancy  Certain  ERC20  tokens  perform  callback  on  token  transfers.  For  example,  ERC777.  Performing  _burn after  transfers  is  then  can  be  recognized  as  a  reentrancy  pattern.  While  the  burnRTokens  and  other Pool contract functions have reentrancy lock protection, there is possibility, that external contracts called during  the  transfer  callback,  might  misinterpret  the  State  of  the  Pool  contract.  For  example,  the reinvestL / totalSupply ratio will be off during this callback.  if (tokenQty > 0) token0.safeTransfer(msg.sender, tokenQty); tokenQty = QtyDeltaMath.getQty1FromBurnRTokens(sqrtP, deltaL); if (tokenQty > 0) token1.safeTransfer(msg.sender, tokenQty);  _burn(msg.sender, _qty);    The transfers have been moved to the very end of the function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.9   Function SwapMath.calcFinalPrice", "body": " Rounding Down  The  calcFinalPrice  calculates  the  final  price  for  swaps,  when  the  used  amount  hits  the  specified amount limit. Depending on the starting price and direction of price movement during the swap, the price needs to be rounded either up or down. If isToken0 == false && isExactInput == true, sqrtP increases and thus price needs to be rounded down, in order not to 'overshoot' the target price.  But the tmp component of the final price is computed with rounding up division operator:  uint256 tmp = FullMath.mulDivCeiling(absDelta, C.TWO_POW_96, currentSqrtP); return FullMath.mulDivFloor(liquidity + tmp, currentSqrtP, liquidity + deltaL);  Thus the returned value with certain chance will be more than intended.    The code has been adjusted such that now division is rounding down.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.10   Gas Inefficiency in insert()", "body": "  Kyber Network - KyberSwap Elastic -   16  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fInsertions  into  the  linked  list  through  LinkedList:insert()  occur  only  in  internal  function PoolTicksState:_updateTickList. In insert() the following storage read occurs:  However,  that  value  corresponds  to  the  last  nextTick  in  _updateTickList.  Thus,  storage  reads could be reduced by passing an additional argument to insert.    insert now takes nextTick as an additional argument, reducing the number of storage reads.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.11   Pool swap Max Tick Distance", "body": "  In the main loop of the swap function, to ensure that the tickOutside value is interpreted correctly the currentTick variable needs to be adjusted if the swap moves the price down:  swapData.currentTick = willUpTick ? tempNextTick : tempNextTick - 1;  the  next   On  MAX_TICK_DISTANCE == 487:  iteration  of   the   loop,   the  new   target   tick  distance  should  not  exceed   the  int24 tempNextTick = swapData.nextTick; if (willUpTick && tempNextTick > C.MAX_TICK_DISTANCE + swapData.currentTick) {     tempNextTick = swapData.currentTick + C.MAX_TICK_DISTANCE; } else if (!willUpTick && tempNextTick < swapData.currentTick - C.MAX_TICK_DISTANCE) {     tempNextTick = swapData.currentTick - C.MAX_TICK_DISTANCE; }  If willUpTick == false and tempNextTick - 1, then the tempNextTick will have at most 488 ticks between the matching tick for sqrtP. Thus, desired Dx*fee / x < 0.0005 ratio can be violated.   The MAX_TICK_DISTANCE was changed to 480. This way the desired Dx*fee / x < 0.0005 ratio will be preserved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.12   Position Manager Storage Access", "body": "  AntiSnipAttackPositionManager  and  BasePositionManager  often  read  same  fields  inside  pos  storage variable  multiple  times  during  the  function  execution.  Since  this  struct  type  variable  is  defined  as  a storage  one,  this  will  lead  to  repeated  reads  from  the  same  work.  More  efficient  approach  would  be utilization of in memory variables.  Position storage pos = _positions[params.tokenId];    Kyber Network - KyberSwap Elastic -   17  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fIn  version  3  of  the  code  the  gas  is  saved  by  utilizing  memory  variable  for  data  access  during  the execution.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.13   Solidity Compiler Pragma", "body": "  The smart contracts inside the repository utilize different compiler pragmas:   pragma solidity >=0.5.0;   pragma solidity >=0.8.0;   pragma solidity ^0.8.0;   pragma solidity >=0.8.0 <0.9.0;   pragma solidity 0.8.9;  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example,  an  outdated  compiler  version  that  might  introduce  bugs  that  affect  the  contract  system negatively.  In  addition,  fixed  pragma  ensures  that  the  testing  and  deployment  performed  on  code  that was compiled by the same compiler version.    Core and periphery contracts use now pragma solidity 0.8.9 while libraries use >=0.8.0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.14   Specification Mismatches in SwapMath", "body": "  Some mismatches between the specifications and code occur in the SwapMath library. Some examples are:   The  Core  Library  Swap  Math  documentation  of  calcReachAmount()  distinguishes  four  cases. However, case 1 & 4 and case 2 & 3 are identical. That mismatches the technical documentation of the swap and the implementation.   The technical documentation does not specify that the absolute value of usedAmount (delta x tmp)  is to be used for the calculation of deltaL.   The technical documentation differs in the mathematical formula for calculating returnedAmount.  Specification changed:  The specification now better reflects the implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.15   flash() Sends Fees to feeTo", "body": "  The natspec documentation of flash() in IPoolActions specifies the following:  Kyber Network - KyberSwap Elastic -   18  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1Speci\ufb01cationChanged                        \f/// @dev Fees collected are distributed to all rToken holders /// since no rTokens are minted from it  However, the fees are transferred to the feeTo address stored in the Factory contract.  Specification changed:  The natspec specification has changed to specify that feeTo receives the fees from the flash loan.  Kyber Network - KyberSwap Elastic -   19  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "7.1   Pools for Tokens With Multiple Addresses", "body": "  The factory creates pools for two token address. It reverts if either the two addresses are identical or the pool has been already initialized for the token pair and the fee. However, some tokens (e.g. TUSD) have two addresses for the token. That allows for the creation of TUSD / TUSD pools, and multiple TUSD / other token pools with the same fee.  Kyber Network - KyberSwap Elastic -   20  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic-legacy/"}, {"title": "6.1   Pull DAI From Vow All at Once", "body": "  During  a  kick()  call,  two  operations  (a  swap  and  a  mint)  on  the  UniswapV2  pair  are  executed consecutively. For each operation, an external call to the vat and daiJoin are invoked beforehand to pull the  required  DAI.  However,  the  pool  state  after  the  swap  can  be  precomputed,  which  means  the  total amount of DAI needed can be precomputed as well. It might be worth to do this to reduce the gas used and hence make the transactions slightly cheaper.  CS-MUF-003    The amount of DAI is now precomputed and pulled once.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-flapperuniv2/"}, {"title": "6.2   Incorrect Comment", "body": "  The comment 997 is the Uniswap LP fee in _getAmountOut() is incorrect. 99.7% represents the amount after deducting the fee, and the fee is 0.3%.  CS-MUF-002  function _getAmountOut(uint256 amtIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amtOut) {     uint256 _amtInFee = amtIn * 997; // 997 is the Uniswap LP fee     amtOut = _amtInFee * reserveOut / (reserveIn * 1000 + _amtInFee); }  Specification changed:  The incorrect comment has been removed.  MakerDAO - FlapperUniV2 -   12  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrectedInformationalVersion1Speci\ufb01cationChanged              \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-flapperuniv2/"}, {"title": "7.1   Revert Reason When FlapperMom Stops", "body": " Flapper  FlapperMom can inhibit FlapperUniV2 in an emergency. It does so by setting the minimum time between two  executions  of  kick()  to  type.max(uint256).  kick()  will  then  revert  due  to  the  addition overflow:  CS-MUF-001  require(block.timestamp >= zzz + hop, \"FlapperUniV2/kicked-too-soon\");  Except when kick() has never been executed before and zzz is still equal to 0, the require statement will cause the revert and emit the error MessageChannel.  MakerDAO - FlapperUniV2 -   13  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-flapperuniv2/"}, {"title": "8.1   More Than bump Amount of DAI Used", "body": "  The Vow contract has been designed and documented with the original Flapper auctioning surplus DAI for MKR tokens in mind.  // Surplus auction function flap() external returns (uint id) {     require(vat.dai(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \"Vow/insufficient-surplus\");     require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \"Vow/debt-not-zero\");     id = flapper.kick(bump, 0); }  By design, the new FlapperUniV2 may utilize up to 2.2 times the bump amount. The Vow contract may not anticipate the Flapper using more than the bump amount of DAI.  Depending  on  the  values  set  for  bump  and  hump,  this  could  result  in  the  Vow  contract  unexpectedly holding  less  than  hump  (surplus  buffer)  amount  of  DAI  after  a  call  to  kick(),  or  a  call  to  kick() unexpectedly reverting if the required amount of DAI is not available.  This behavior is now described in the README.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-flapperuniv2/"}, {"title": "8.2   Unexpected Pair State", "body": "  Generally  it  is  assumed  that  the  free  market  ensures  the  pair  represents  the  current  market  rate. However this can not be relied on as the state of the pair might be changed just before calling kick(). There  are  various  possibilities  why  the  pair  could  be  in  a  state  not  matching  the  current  market  rate. Notably e.g. in case there is an unaccounted donation of tokens in the Uniswap pool (balance > reserve), the flapper will first call sync() on the pair and swap on the updated balances afterwards. This state can also be reached by an attacker donating and calling sync directly. Furthermore the state may be changed by trading.  Generally the possible manipulation is bounded by the following checks:  In case the swapping ratio deviates too much from the reference price feed, kick() will revert.  In case the liquidity of the pool is too shallow and the amount of surplus deposited back goes over 120% of swapped, kick() will also revert.  In theory, the following manipulations by donations are possible:   One can donate within the price tolerance want to make the flapper trade at a bad price.   One  can  intentionally  donate  to  revert  a  kick()  by  pushing  the  price  out  of  the  price  tolerance  want.   One  can  also  donate  to  increase  the  liquidity  and  make  a  kick()  which  was  going  to  revert  (deposited larger than 120% of swapped) succeed.  MakerDAO - FlapperUniV2 -   14  NoteVersion1NoteVersion1        \fMakerDAO is aware and adds the following considerations:  * One can donate within the price tolerance want to make the flapper trade at a bad price - the assumption is that any trade above `want` is viable. It is of course possible for anyone to move the price with a swap, which is probably even more economical than a donation. As long as `want` and `lot` are set correctly both type of attempts should not be economical and are of course known limitations of a permissionless system.  * One can intentionally donate to revert a kick() by pushing the price out of the price tolerance want - same as above, this can happen with a swap and is a known given. Keepers can use flashbots to avoid it.  * One can also donate to increase the liquidity and make a kick() which was going to revert (deposited larger than 120% of swapped) succeed - if the kick succeeds it is intended behavior.  MakerDAO - FlapperUniV2 -   15  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-flapperuniv2/"}, {"title": "6.1   EIP-4626 Non-Compliance", "body": "  The  functions  MultiWithdrawalController.maxWithdraw  and  maxRedeem  return  values  greater than 0 when the withdrawals are not allowed in the current status of the protocol. This is in violation of the following rule:  MUST return the maximum amount of assets that could be transferred from owner through withdraw and  not  cause  a  revert,  which  MUST  NOT  be  higher  than  the  actual  maximum  that  would  be accepted (it should underestimate if necessary).  Additionally,  MultiWithdrawalController._globalMaxWithdraw  sets  the  maximum  amount  of tokens  that  can  be  withdrawn  from  a  tranche.  This  maximum  is  determined  by  the  function TrancheVault.totalAssets.  In  Live  state,  this  function  returns  the  current  waterfall  value  of  the tranche which contains the virtualTokenBalance of the entire portfolio, as well as the value of active loans. The returned value can therefore be higher than the actual amount of assets that are available for withdrawal.    MultiWithdrawalController.maxWithdraw  and  maxRedeem  now  return  0  if  withdrawals  are disallowed in the current status of the protocol.  Archblock - Controllers for TrueFi Carbon -   10  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrected        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/archblock-truefi-controllers-for-truefi-carbon/"}, {"title": "7.1   Redundant Event Emission", "body": "  A manager can configure the floor and the withdrawalAllowed mapping by calling configure. In case  the  parameters  are  the  same  as  the  ones  already  set,  the  execution  of  the  actual  setter  i.e., setFloor and setWithdrawalAllowed, is skipped. However, the manager can call setFloor and setWithdrawalAllowed directly, where there are no checks if the new values are different than the ones stored. In this case, redundant events will be emitted.  Archblock - Controllers for TrueFi Carbon -   11  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/archblock-truefi-controllers-for-truefi-carbon/"}, {"title": "8.1   No Asset Conversion", "body": "  MultiWithdrawalController.onRedeem  does  not  check  whether  the  given  assetAmount  of  an exception  matches  convertToAssets(sharesAmount).  If  the  manager  makes  a  mistake  or  a repayment  is  executed  on  the  contract  between  the  time  the  manager  sends  their  multiRedeem transaction and the time the transaction actually executes, the values will be wrong, resulting in either a loss or a gain for the given lender. This behavior is well documented by the specification provided to us.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/archblock-truefi-controllers-for-truefi-carbon/"}, {"title": "8.2   Redeem Event Emission", "body": "  MultiWithdrawalController.onRedeem  can  be  called  by  any  user  (without  reverting)  using  the following arguments:   sender: The address of the controller contract.   shares: 0.   owner: address(0).  This  emits  a  Redeem  event  every  time.  The  assets  parameter  can  be  completely  arbitrary.  Off-chain systems reading these events should be aware of this behavior.  Archblock - Controllers for TrueFi Carbon -   12  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/archblock-truefi-controllers-for-truefi-carbon/"}, {"title": "5.1   Curve Base Adapter Misconfiguration", "body": "  The Curve base adapter does not sanitize _nCoins and could be initialized with only one coin. Such a misconfiguration  would  not  have  security  implication,  but  the  adapter  is  likely  to  revert  on  most  of  the interactions.  ISSUEIDPREFIX-001  Risk accepted:  Gearbox Protocol states:  This contract is never deployed by itself, and we never have to manually enter the value for this parameter, since it\u2019s defined as constant in derived adapters.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "5.2   Unusable Inherited Functions", "body": "  The contract CurveV1AdapterDeposit inherits CurveV1AdapterBase but the inherited exchange* and  functions  do  not  exist  on  the  Curve's  deposit  zappers.  These  functions  will  be  available  through CurveV1AdapterDeposit but will revert if called.  ISSUEIDPREFIX-002  Risk accepted:  Gearbox Protocol states:  Gearbox Protocol - Gearbox V2.1 -   20  DesignCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedDesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \fPotential costs of changing contracts hierarchy exceed additional deployment costs.  Gearbox Protocol - Gearbox V2.1 -   21    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Wrong WaToken Distribution   -Severity Findings   Compound Adapter's redeemUnderlying() Not Executed   Inheriting ACLTrait Includes Pause/Unpause   -Severity Findings  Inconsistent Test for Reward Token Wrapper    Missing Event    Query of Curve's Tricrypto Pool Virtual Price    BlacklistHelper Claimable Balance Is 1 Wei off    UniswapConnectorChecker Missing Sanity Check   0  1  2  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "6.1   Wrong WaToken Distribution", "body": "  The  exchange  rate  depends  on  the  contract's  balance  of  aTokens  and  the  total  supply  of  the WrappedAtokens:  ISSUEIDPREFIX-016  function exchangeRate() public view override returns (uint256) {     uint256 supply = totalSupply();     if (supply == 0) return WAD;     return (aToken.balanceOf(address(this)) * WAD) / supply; }  In  WrappedAToken.deposit(),  the  exchange  rate  is  computed  after  the  contract  received  the aToken, so its balance has already been updated. This leads to a wrong computation of the distributed shares or WaToken.  function deposit(uint256 assets) external override returns (uint256 shares) {     aToken.transferFrom(msg.sender, address(this), assets);     shares = _deposit(assets); }  function _deposit(uint256 assets) internal returns (uint256 shares) {     shares = (assets * WAD) / exchangeRate();     _mint(msg.sender, shares);  Gearbox Protocol - Gearbox V2.1 -   22  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected          \f    emit Deposit(msg.sender, assets, shares); }  Example:  For simplicity, we assume that the exchange rate of the aToken is 1.  User A deposits 10 aToken, the computed shares are 10 / 1 = 10 since the total supply is 0. After this transaction, the contract has 10 aToken and the total supply is 10.  User  B  deposits  10  aToken,  the  computed  shares  are  10  /  (20  /  10)  =  5  because  the  contract already holds the new 10 aToken. After this transaction, the contract has 20 aToken and the total supply is 15.  If  user  A  or  B  wants  to  withdraw  at  that  point,  each  should  get  their  10  aToken  back.  But  if  user  B withdraws, the computed amount of aToken he will receive is 5 * (20 / 15) = 6.666..., which is clearly not the expected amount.    The updated code does not take the balances into account anymore for the computation of the exchange rate. Now, the exchange rate is computed as the ratio of the current Aave pool's normalized income and the normalized income at WaToken contract deployment.  function exchangeRate() public view override returns (uint256) {     return WAD * lendingPool.getReserveNormalizedIncome(address(underlying)) / _normalizedIncome; }  Doing so, the contract only sees the exchange rate grow, as long as Aave's interest rate is growing, and the shares cannot be maniputaled by users of the WaToken contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "6.2   Compound Adapter's redeemUnderlying()", "body": " Not Executed  ISSUEIDPREFIX-011  the   In  and CompoundV2_CEtherAdapter._redeemUnderlying()  only  encode  the  call  to  the  target  contract, but _execute() is not called:  CompoundV2_CErc20Adapter._redeemUnderlying()   error = abi.decode(_encodeRedeemUnderlying(amount), (uint256));  This has no security implications for Gearbox, but users cannot use this function.    The code has been updated to execute the call:  error = abi.decode(_execute(_encodeRedeemUnderlying(amount)), (uint256));  Gearbox Protocol - Gearbox V2.1 -   23  DesignMediumVersion1CodeCorrected          \f6.3   Inheriting ACLTrait Includes Pause/Unpause  The  AbstractAdapter  (which  is  inherited  by  all  Adapters)  and  the  BlacklistHelper  inherit  ACLTrait.  This abstract contract implements pause functionality:  ISSUEIDPREFIX-009  ///@dev Pause contract function pause() external {     if (!_acl.isPausableAdmin(msg.sender))         revert CallerNotPausableAdminException();     _pause(); }  /// @dev Unpause contract function unpause() external {     if (!_acl.isUnpausableAdmin(msg.sender))         revert CallerNotUnPausableAdminException();      _unpause(); }  Hence  contracts  inheriting  from  ACLTrait  will  have  external  functions  pause  and  unpause  exposed. These  functions  may  make  it  look  like  the  contract  can  be  paused  -  despite  no  function  actually  being pausable.    The  inheritance  from  ACLTrait  has  been  removed  in  the  AbstractAdapter  and  kept  in BlacklistHelper. Gearbox Protocol responded:  Abstract adapter no longer inherits ACL trait (for adapters, it could have potentially caused problems if we introduced some pausable functions, because credit facade is, in fact, a pausable admin, so users would then be able to pause an adapter in the multicall; for blacklist helper there is no risk so no change)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "6.4   Inconsistent Test for Reward Token Wrapper", "body": "  To  check  whether  a  reward  token  is  wrapped,  a  call  to  the  booster()  function  of  the  contract  is performed. If the call succeeds, then the reward token is further unwrapped. However, the test whether the  second  reward  token  is  wrapped  or  not  in  the  constructor  of  ConvexV2_BaseRewardPool  is inconsistent. The check for is using _extraReward1 instead of _extraReward2.  ISSUEIDPREFIX-012    Now booster() is called on _extraReward2.  Gearbox Protocol - Gearbox V2.1 -   24  DesignMediumVersion1CodeCorrectedDesignLowVersion6CodeCorrected                \f6.5   Missing Event  ISSUEIDPREFIX-013  Events should be emitted whenever an important state change happens in a smart contract. Since setting isIncreaseDebtForbidden  in CreditFacade._closeLiquidatedAccount()  is  an  important  state  change,  an  event  may  be useful.  occurred   true   when   pool   loss   the   to   a     If the pool occurred a loss during liquidation, the IncurLossOnLiquidation event is emitted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "6.6   Query of Curve's Tricrypto Pool Virtual Price", "body": "  ISSUEIDPREFIX-014  In  CurveCryptoLPPriceFeed.latestRoundData(),  is  queried  with curvePool.get_virtual_price(),  but  on  the  reference  code  provided  by  Gearbox  Protocol (https://arbiscan.io/address/0x4e828A117Ddc3e4dd919b46c90D4E04678a05504#code#F3#L1)  and notably in the official curve.finance pricefeed template (https://github.com/curvefi/crypto_lp_pricing/blob/b the 6fea6943d5ddf8648f05d442daad284c1757c86/contracts/LPPrice_tricrypto_ethereum.vy#L41),  virtual price is queried from the storage variable with curvePool.virtual_price().  virtual  price   the     function  CurveCryptoLPPriceFeed.latestRoundData  has  been  updated   The  curvePool.virtual_price() instead of curvePool.get_virtual_price().  to  use  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "6.7   BlacklistHelper Claimable Balance Is 1 Wei", "body": " off  In CreditFacade._increaseClaimableBalance(), the parameter balanceBefore has 1 wei too many due to _isBlacklisted(). The claimable amount is computed as balance-balanceBefore and will lack 1 wei.  ISSUEIDPREFIX-010    The  been  helperBalance - helperBalanceBefore + 1;  claimable   amount   has   updated   to   be   computed   as  Gearbox Protocol - Gearbox V2.1 -   25  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f6.8   UniswapConnectorChecker Missing Sanity Check  The constructor of UniswapConnectorChecker accepts an array of addresses as parameter, but the length of the array is never checked to be <=10. So the checker could be deployed with an array of 25 addresses, only the 10 first will be saved in storage, but numConnectors will be 25. This will also incur unnecessary gas cost when getConnectors() is called.  ISSUEIDPREFIX-015    The constructor has been updated to revert if more than 10 addresses are provided.  Gearbox Protocol - Gearbox V2.1 -   26  DesignLowVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "7.1   Code Duplication", "body": "  The  function  CurveV1StETHPoolGateway.remove_liquidity_imbalance  transfers  token0  and token1 in the function's body, but the dedicated function _transferAllTokensOf can be used.  ISSUEIDPREFIX-003  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "7.2   Code Inconsistencies", "body": "  ISSUEIDPREFIX-006  1. For gas optimizations, the system tries to always keep 1 wei in the balances and the standard way in  is  with  balance  <=  1,   however   across   to  BlacklistHelper.claim() the check is amount < 2.  codebase   check   the   it   2. The Lido gateway transfers the full balance instead of balance-1 as everywhere else in the system  (gas optimization).  3. In the adapters, _gearboxAdapterType is sometimes overridden as a constant, and some other times  as  a  function.  For  consistency  across  the  codebase,  one  of  the  two  solutions  should  be chosen.  Code partially corrected:  1. Changed to amount < 1.  2. Not addressed.  3. Not addressed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "7.3   Gas Optimizations", "body": "  1. In UniswapV2Adapter._parseUniV2Path(), path.length could be loaded from memory to a local variable at the beginning of the function and read from the local variable to save a MLOAD.  ISSUEIDPREFIX-007  2. In  UniswapV2Adapter._parseUniV2Path(),   if path.length < 2, path.length > 4, or if one of the hops is not an allowed connector to save some gas.  function   return   could   early   the   3. In   CurveV1AdapterBase,  add/remove_liquidity_one_coin(uint256,uint256,uint256)  do  not  need   functions the  the   the   Gearbox Protocol - Gearbox V2.1 -   27  InformationalVersion1InformationalVersion1CodePartiallyCorrectedInformationalVersion1CodePartiallyCorrected              \fcreditFacadeOnly()  add/remove_liquidity_one_coin(uint256,int128,uint256) have it already.  modifier,   since  Code partially corrected:  1. The length of the array is loaded only once at the beginning of the function and stored in a local  variable.  2. The conditionnal structure has been optimized. However, the function could return early if len > 4  to save some gas in the case of a failure.  3. The   concerned   internal been  _add/remove_liquidity_one_coin(int128) which do not have the creditFacadeOnly() modifier.  functions   updated   have   call   the   to   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "7.4   Unused Constants", "body": "  Some of the defined constants are still declared and imported, but never used. A non-exhaustive list is:  ISSUEIDPREFIX-004   ALL0WANCE_THRESHOLD   EXACT_INPUT   EXACT_OUTPUT  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "7.5   Wrong Comments", "body": "  Some comments in the code are wrong, here is a non-exhaustive list:  1. WstETHGateway: the @notice comment is wrong, the contract does not allow to convert stETH  into WstETH, it allows to provide liquidity to Gearbox's WstETH in the form of sthETH.  2. ACLNonReentrantTrait:  the  comment  of  the  controllerOnly()  modifier  is  incomplete,  it  only covers the case where externalController is false.  ISSUEIDPREFIX-008  3. CreditConfigurator:   in   the   creditManager.upgradeCreditFacade  Connects creditFacade and priceOracle, but only the CreditFacade is connected.  comment   that   has   constructor,  a   the   call   to specifies  4. CurveCryptoLPPriceFeed:  the  @notice  of  the  latestRoundData  function  is  wrong,  the  specified formula is not the one implemented.  5. CreditFacade:   In  _liquidateExpiredCreditAccount   the  comment  \"Checks   if   the  liquidsation . . .\" contains a typo.  6. The  natspec  of  BalancerV2VaultAdapter.batchSwap()  specifies  that  the  assets  must  be ordered.  Nothing  is  enforcing  the  ordering  and  Balancer  V2  does  not  need  to  have  the  assets ordered.  Specifications partially corrected:  Gearbox Protocol - Gearbox V2.1 -   28  InformationalVersion1InformationalVersion1Speci\ufb01cationPartiallyChanged          \f1. Not addressed.  2. The comment has been updated to include the case where externalController is true.  3. Not addressed.  4. The formula in the specification has been updated to match the implementation.  5. The typo has been corrected.  6. The mention of the assets' ordering has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "7.6   safeApprove Can Revert", "body": "  ISSUEIDPREFIX-005  Theoretically,  IERC20.safeApprove()  can  revert  in  WstETHGateway._checkAllowance()  and WaToken.depositUnderlying()  because  the  safeApprove()  function  requires  either  the  current allowance or the value to be 0.  In WstETHGateway, the allowance for the WstETH token is set to type(uint256).max at contract deployment, and is decreased each time WstETHGateway.addLiquidity() is called. Also, each time  WstETHGateway.addLiquidity()  is  called,  the  allowance  check  is  performed,  so  if  the allowance is strictly smaller than the amount. But the maximum allowance is such a big number that this will never happen in practice.  In  WstETHGateway.removeLiquidity()  and  WaToken.depositUnderlying()  set  the allowance for Gearbox's and Aave's lending pool to the exact amount that should be pulled from the contract. The pools are trusted to pull the exact specified amount and not less to set the allowance back  to  0.  If  one  of  the  pool  was  to  be  updated  and  pulls  less  than  the  specified  amount, WstETHGateway.removeLiquidity() and WaToken.depositUnderlying() would revert.  Gearbox Protocol - Gearbox V2.1 -   29  InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "8.1   MetaPool With Underlying", "body": "  Note that there could be a Curve Metapool with a Metabpoolbase which contains an asset which has an underlying. The current CuveV1_Base implementation does not support interaction using the underlying of of one of the assets in the Metapoolbase. Gearbox Protocol stated they do not aim to support this. In practice the two most relevant base pools are 3CRV and crvFRAX, which both don't have underlyings for their assets. If such a metapool was to be added, the swap into an underlying would be supported by the router.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "8.2   Multicall Reverts When Temporarily", "body": " Exceeding TokenLimit  Adapters  don't  disable  tokenIn  when  uncertain  whether  all  balance  was  spent.  Such  tokens  will  be disabled  at  the  end  of  the  multicall  when  the  full  check  is  executed.  There  is  a  corner  case  where  a sequence of multicalls may revert for one credit account (as the limit would be temporarily exceeded) but not for another (where the limit is not exceeded).  This  may  hinder  the  usage  of  predefined  multicall  sequences.  Note  that  the  problem  can  always  be rectified by adding a call to disableToken in between.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "8.3   WrappedAToken: depositUnderlying", "body": " Assumption  It's of uttermost importance that the expected amount of aToken is deposited into the wrapper contract when shares are minted.  As argument assets the user passes the amount of underlying to depositUnderlying(). There is an assumption that when depositing x amount of underlying into Aave, x amount of aTokens is received in exchange. This holds if Aave works correctly as specified.  function depositUnderlying(uint256 assets) external override returns (uint256 shares) {     underlying.safeTransferFrom(msg.sender, address(this), assets);     underlying.safeApprove(address(lendingPool), assets);     lendingPool.deposit(address(underlying), assets, address(this), 0);     shares = _deposit(assets); }  However, this makes the contract vulnerable if Aave doesn't behave as expected.  Gearbox Protocol - Gearbox V2.1 -   30  NoteVersion1NoteVersion1NoteVersion1          \fGearbox Protocol states:  Wrapped aTokens will probably be deployed only for known tokens like WETH or USDC, for which said assumption can be easily validated.  Gearbox Protocol - Gearbox V2.1 -   31  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-v2-1/"}, {"title": "5.1   Staking Does Not Prevent Misbehavior", "body": "  Resolvers have to join a whitelist which is governed by the staking of 1inch tokens.  The documentation states:  The stake determines a resolver\u2019s ability to get orders and ensures that a resolver follow the protocol rules (like in proof of stake model).  On the smart contract level the implementation of the staking does not allow to seize stake of bad actors. Their stake is not at risk and can simply be withdrawn at the end of the lock period hence this staking does not ensure that a resolver follows the protocol rules.  Risk accepted:  1inch states:  They'll need only follow what is required to be able to settle the order batch. Staking is only used as a threshold entry requirement.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "5.2   Missing Events", "body": "  Events  are  used  to  be  informed  of  or  to  keep  track  of  transactions  changing  the  state  of  a  contract. Generally, any important state change should emit an event.  1inch - Limit Order Settlement -   15  SecurityDesignCriticalHighMediumRiskAcceptedLowAcknowledgedDesignMediumVersion1RiskAcceptedDesignLowVersion1Acknowledged                  \fThe functions used for deposits and withdrawals in FeeBank do not emit an event, hence it's hard for an observer to track deposits and withdrawals  Acknowledged:  1inch acknowledged the issue and decided to leave the code as it is.  1inch - Limit Order Settlement -   16    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   St1inch Can Be Locked Indefinitely   -Severity Findings   Resolver Can Set Arbitrary Callback   0  0  1  1  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "6.1   St1inch Can Be Locked Indefinitely", "body": "  It is possible for an attacker to lock the staked amount of 1inch token of any staker by using one of the St1inch.depositFor  functions  for  the  target  address.  By  depositing  a  small  amount  of  tokens  and specifying the duration, one can force a target staker to see its stake locked for more time, preventing the staker to withdraw. The only way to break that attack would be to activate the emergency exit to allow the target staker to withdraw.    The functions St1inch.depositFor and St1inch.depositForWithPermit have been updated so the duration cannot be specified and is hardcoded to be 0. This will only increase the deposited amount and not the timelock duration.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "6.2   Resolver Can Set Arbitrary Callback", "body": "  can   Resolvers  in Settlement._settleOrder()  and  execute  arbitrary  code  which  may  severely  interfere  with  the process.  (interactionTarget   address)   callback   address   called   the   set     The Settlement contract now ensures that the address is the settlement contract itself:  let target := shr(96, calldataload(add(data.offset, interactionOffset))) if iszero(eq(target, address())) {     mstore(0, errorSelector)  1inch - Limit Order Settlement -   17  CriticalHighMediumCodeCorrectedLowCodeCorrectedSecurityMediumVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                \f    revert(0, 4) }  1inch - Limit Order Settlement -   18  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "7.1   Competing Resolvers May Result in Failing", "body": " Transactions  Since resolvers are competing against each other, it may happen that more than one resolver submits the same order in their respective batch, in the same block. In such cases, only the first batch including the order will not revert and all the other resolvers will suffer from pure loss of gas.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "7.2   Gas Optimization", "body": "  Some operations can be in an unchecked block to save gas, examples are:   update of i and addition in FeeBank.gatherFees()   addition in FeeBank._depositFor()   addition in FeeBankCharger.increaseAvailableCredit()   for loop in WhitelistRegistry.register()   WhitelistRegistry._shrinkPoorest()  Intermediary memory variable can save storage reads. Example is:   St1inch._deposit()  does  two  SLOAD  for  deposits[account],  storing  the  updated  deposit  amount in memory will save gas.  Code partially corrected:  The function St1inch._deposit() has been updated to do only one SLOAD for the depositor.  Other gas optimizations have been addressed in future commits.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "7.3   Preview Functions Accept Invalid Durations", "body": "  functions  (previewBalance,  previewPowerOf,previewPowerOfAtTime)  may The  preview  accept  a  duration  parameter  that  may  exceed  the  maximum  locking  period  and  make  the  transaction revert if applied in the St1inch contract.  1inch - Limit Order Settlement -   19  InformationalVersion1InformationalVersion1InformationalVersion1          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "8.1   Allowed Sender of Orders", "body": "  Makers wishing to benefit from the protections of the limit settlement protocol must ensure the order they sign has the settlement contract set as allowed sender.  Technically  the  settlement  contract  allows  resolvers  to  batch  any  orders  which  gives  them  greater freedom  to  aggregate  transactions.  While  execution  of  orders  without  the  allowed  sender  restricted works,  such  orders  can  also  be  executed  through  the  limit  order  protocol  directly  and  hence  lack  the protection limit settlement order offers.  It's vital to understand that this field has to be set correctly or that the protections offered by limit order settlement don't apply. Although this might be obvious there should be documentation emphasizing this. Even the tests within the limit-settlement-order repository use public orders (since allowed sender is not set and hence anyone, not just the settlement contract, can call limitOrderProtocol.fillOrder() for this order).  This is an easy source of errors, hence it`s important to be explicit and not assume users/integrators will understand and do this correctly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "8.2   User Responsibility for Setting Trusted", "body": " Resolvers  Nothing  enforces  the WhitelistRegistry.  It  is  the  user's  responsibility  to  ensure  that  the  resolvers  addresses  they  sign over are trusted.  to  be  actually  part  of   in  Order.interaction   the  resolvers   listed   1inch stated:  That\u2019s also the responsibility of the frontend to provide correct whitelists to the user. And also responsibility of the backend to filter out maliciously created orders without the proper whitelist.  1inch - Limit Order Settlement -   20  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-limit-order-settlement/"}, {"title": "5.1   Approximated Fee Charged in Debt Transfer", "body": "  In function vaultManager.getDebtOut, a fee is charged according to the different borrowFee and repayFee  between  two  vault  managers.  It  will  be  an  approximation  which  slightly  round  if  both borrowFee and repayFee are enabled.  We assume the borrowFee and repayFee are f1 and r1 on vaults A. And f1 and r1 for B as well. We assume f1<f2 and r1>r2. Then if a debt X is transferred from A to B, the following fee will be charged.  \u03b4fee = (f2 \u2212 f1) * X + (  \u2212 r2 (1 \u2212 r1)(1 \u2212 r2) )] * X > = (\u03b4f + \u03b4r) * X  1 \u2212 r2 ) * X  r1 1 \u2212 r1  r1 \u2212 r2  \u03b4fee = [(f2 \u2212 f1) + (  where  \u03b4f = f2 \u2212 f1 \u03b4r = r1 \u2212 r2  This is slightly larger than the formula used in the project given that both f and r are small:  \u03b4fee = (\u03b4f + \u03b4r \u2212 \u03b4r * \u03b4f) * X  Acknowledged  Angle replied:  It is possible that it slightly rounds down, overall we do not expect to have both fees taken up at the same time on the same vaultManager. And as we're aware that it's an approximation, fees should be set accordingly.  Angle - Angle Borrowing Module -   12  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedDesignLowVersion1Acknowledged            \f5.2   Ignored Return Value of _repayDebt  The  return  value  of  the  call  to  _repayDebt  in  the  function  VaultManager.liquidate  is  ignored, although it gives the correct amount of stable coins that need to be burned for the debt payment. Instead amounts[i] is used, as shown below:  if (vault.collateralAmount <= collateralReleased) {    ... } else {     ...     _repayDebt(         vaultIDs[i],         (amounts[i] * liquidationSurcharge) / BASE_PARAMS,         liqData.newInterestAccumulator     ); } ... liqData.stablecoinAmountToReceive += amounts[i];  Acknowledged  Angle replied:  The repayDebt function rounds down the stablecoin amount in the case where it is bigger than the total debt of the vault. In a liquidation setting, the amount in repayDebt is: 'amounts[i]*liquidationSurcharge / BASE_PARAMS' where 'amounts[i]<=maxStablecoinAmountToRepay' and 'maxStablecoinAmountToRepay <= debt of the vault + 1'. As such, in the worse scenario possible, the output value of the repayDebt function will very slightly be rounded down from what should theoretically be taken: we should therefore view this as a slightly higher fee taken by the protocol on the liquidation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "5.3   Possible Gas Optimization in Mappings", "body": "  Several contracts of the system use mappings in the format: mapping(key_type => bool). Solidity uses a word  (256  bits)  for  each  stored  value  and  performs  some  additional  operations  when  operating  bool values  (due  to  masking).  Therefore,  using  uint  instead  of  bool  is  slightly  more  efficient.  A  list  of  such mappings:   isMinter in agToken.   vaultManagerMap in Treasury.   isWhitelisted and _operatorApprovals in VaultManagerStorage.  Acknowledged:  Angle - Angle Borrowing Module -   13  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                \fThe mappings vaultManagerMap, isWhitelisted and _operatorApprovals have been modified and now use uint256 instead of bool as pointed out above.  Only the mapping isMinter remains unchanged because the Angle has already deployed a version of the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "5.4   Unchecked Collateral Amount", "body": "  In  the  contract  VaultManager,  when  a  user  calls  _addCollateral  or  _removeCollateral,  no checks are performed on the collateral amount. Hence, a vault can have an amount of collateral which is below the _dustCollateral parameter.  Acknowledged  Angle replied:  There is no need to check for the `_dustCollateral` parameter when people are adding or removing collateral from their vault. What is important is that people with a debt have an amount of collateral in their vault which is higher than `_dustCollateral` and this can be for sure implemented if `_dust` parameter is set accordingly with the `collateralFactor` parameter and the `_dustCollateral` parameter.  It is not a problem for the protocol if people decide to add collateral little by little or remove their collateral little by little if they are no longer in debt or their debt is small.  Angle - Angle Borrowing Module -   14  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  1  0  3  16  -Severity Findings   Unchecked VaultManager Address   -Severity Findings  -Severity Findings  Inconsistent Access Control   Incorrect Accounting of Global Debt    Stuck Ether   -Severity Findings  Incomplete Specifications BaseReactor    Mismatch of Specifications in _repayDebt    Unclear Specifications for Swap Function   Incomplete Specifications   Inconsistent Error Message    Misleading Function Name    Mismatch of Specifications for Function _isSolvent    Missing Description of Variable Decimals    Missing Sanity Checks on Vault Creation    No Event Emitted on Flashloan's Parameters Update    Possible to Optimize Struct    Precision Loss in Division    Specification Mismatch in _handleRepay    Specification Mismatch setUint64    Unchecked Array Length    Unchecked VaultID When Adding Collateral   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.1   Unchecked VaultManager Address", "body": "  The  fetchSurplusFromVaultManagers  the  contract treasury/Treasury.sol,  as  displayed  below,  input VaultManager  function can  address.  An  accrueInterestToTreasury  which  can  return  arbitrary  numbers  to  maliciously  update  the  state variables surplusBufferValue and badDebtValue.  is  no  check  a   function  of  towards   the  user  a   is  an  external   contract  with   adversary   function   deploy   there   Angle - Angle Borrowing Module -   15  CriticalCodeCorrectedHighMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected             \ffunction fetchSurplusFromVaultManagers(address[] memory vaultManagers) external returns (uint256, uint256) {     (uint256 surplusBufferValue, uint256 badDebtValue) = _fetchSurplusFromList(vaultManagers);     return _updateSurplusAndBadDebt(surplusBufferValue, badDebtValue); }  function _fetchSurplusFromList(address[] memory vaultManagers) internal returns (uint256 surplusBufferValue, uint256 badDebtValue) {     badDebtValue = badDebt;     surplusBufferValue = surplusBuffer;     uint256 newSurplus;     uint256 newBadDebt;     for (uint256 i = 0; i < vaultManagers.length; i++) {         (newSurplus, newBadDebt) = IVaultManager(vaultManagers[i]).accrueInterestToTreasury();         surplusBufferValue += newSurplus;         badDebtValue += newBadDebt;     } }    The  vulnerable  function  fetchSurplusFromVaultManagers  has  been  removed  from  the  updated code. Hence, the functionality to collect the surplus only from a subset of vault managers is not available anymore.  function fetchSurplusFromAll should be called.  the  surplus  accrued  by  all  VaultManager  contracts,   to  collect   In  order   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.2   Inconsistent Access Control", "body": "  The setup of roles for the contract CoreBorrow is implemented in the function initialize. The admin of the GUARDIAN_ROLE is set to GUARDIAN_ROLE, which may lead to an exploit as a malicious guardian can  remove  all  governors  from  the  GUARDIAN_ROLE.  In  such  scenario,  the  functions  addGovernor, isGovernorOrGuardian, and all the functions in other contracts that call isGovernorOrGuardian with  a  governor  address  would  revert,  as  they  no  longer  have  the  GUARDIAN_ROLE,  and  thus  are  no longer the admin of the GUARDIAN_ROLE.  function initialize(address governor, address guardian) public initializer {     require(governor != address(0) && guardian != address(0), \"O\");     require(governor != guardian, \"12\");     _setupRole(GOVERNOR_ROLE, governor);     _setupRole(GUARDIAN_ROLE, guardian);     _setupRole(GUARDIAN_ROLE, governor);     _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);     _setRoleAdmin(FLASHLOANER_TREASURY_ROLE, GOVERNOR_ROLE); }  function addGovernor(address governor) external {     grantRole(GOVERNOR_ROLE, governor);     grantRole(GUARDIAN_ROLE, governor); }  function isGovernorOrGuardian(address admin) external view returns (bool) {     return hasRole(GUARDIAN_ROLE, admin); }    The  issue  has  been  addressed  in  code  ,  the  governor  is  set  as  the  admin  of  the GUARDIAN_ROLE,  hence  a  guardian  cannot  change  anymore  the  roles  of  a  governor  address.  Angle - Angle Borrowing Module -   16  SecurityMediumVersion1CodeCorrectedVersion2        \fFurthermore, the function removeGovernor has been updated to allow a governor address to remove its roles, i.e., revoke its roles as guardian and then as governor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.3   Incorrect Accounting of Global Debt", "body": "  The following issue was reported by Angle during the review process. The function _closeVault in the contract VaultManager.sol does not update the global debt state variable totalNormalizedDebt.    The  function  _closeVault  has  been  revised  to  update  the  global  debt  state  when  a  vault  is  closed: totalNormalizedDebt -= vault.normalizedDebt;.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.4   Stuck Ether", "body": "  The function angle in the contract VaultManager is declared as payable, however the code has no logic to deal with the incoming Ether. Therefore, the Ether sent when calling the function angle is not accounted and gets stuck into the contract.    The  keyword  payable  has  been  removed  from  the  function  VaultManager.angle,  hence  users cannot send Ether to the contract when calling this function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.5   Incomplete Specifications BaseReactor", "body": "  The parameter _protocolInterestShare in BaseReactor._initialize is missing the NatSpec description.    The NatSpec description has been added for the parameter _protocolInterestShare in the function _initialize.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.6   Mismatch of Specifications in _repayDebt", "body": "  The function VaultManager._repayDebt will not revert on a non-existing vault, however the NatSpec comments assume that it will revert.  Angle - Angle Borrowing Module -   17  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedCorrectnessLowVersion2CodeCorrectedCorrectnessLowVersion2CodeCorrected                                \f/// @dev This function will revert if it's called on a vault that does not exist    The sentence above has been removed from the NatSpec of the function _repayDebt.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.7   Unclear Specifications for Swap Function", "body": "  The NatSpec descriptions for parameters in ISwapper.swap are confusing, for example the parameter outTokenOwed has the following description:  @param outTokenOwed Minimum amount of outToken this address should have at the end of the call  It is unclear if this address refers to the contract Swap or to the recipient address.    The NatSpec description for the parameter outTokenOwed has been revised:  @param outTokenOwed Minimum amount of outToken the `outTokenRecipient` address should have at the end of the call.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.8   Incomplete Specifications", "body": "  Several  NatSpec  descriptions  non-exhaustive list:  for   the   function  parameters  are  not  complete.  We  provide  a   The description of `` data`` in VaultManager.liquidate.   supply in BaseReactor._convertToShares.   Return values in BaseReactor._getFutureDebtAndCF.  Specification changed:  The NatSpec descirptions have been added for the examples listed above:  /// @param data Data to pass to the repayment contract in case of... /// @param _supply Optional value of the total supply of the reactor, it is recomputed if zero /// @return futureStablecoinsInVault Future amount of stablecoins borrowed in the vault /// @return collateralFactor Collateral factor of the vault if its debt remains unchanged but `toWithdraw` collateral  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.9   Inconsistent Error Message", "body": "  Angle - Angle Borrowing Module -   18  CorrectnessLowVersion2CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fin  BaseAgTokenSideChain.sol  and The  error  codes  function setTreasury in BaseOracleChainlinkMulti.sol are inconsistent with the respective descriptions in errorMessages.json.  in  modifier  onlyTreasury   Furthermore,  most  of  the  contracts  use  numbers  as  error  messages,  and  the  file  errorMessages.json maps each error code to a meaningful description. However, in BaseReactor the following messages are used:  require((assets = _convertToAssets(shares, usedAssets + looseAssets, 0)) != 0, \"ZERO_ASSETS\"); require(currentAllowance >= shares, \"ERC20: transfer amount exceeds allowance\");    The error messages have been revised on the whole codebase and a new approach is used:  if(!condition) revert CustomErrorMessage();  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.10   Misleading Function Name", "body": "  In  contract  EulerReactor.sol,  the  function  name  _maxStablecoinsAvailable  does  not  match with  the  specifications  and  the  code,  which  returns  the  maximum  amount  of  assets  that  can  be withdrawn.    The function _maxStablecoinsAvailable has been renamed to _maxAmountWithdrawable, and the NatSpec description has been updated accordingly:  @return maxAmount Max amount of assets that can be withdrawn from the reactor  considering Euler liquidity for the stablecoin.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.11   Mismatch of Specifications for Function", "body": " _isSolvent  The NatSpec comment for the function VaultManager._isSolvent states:  /// @notice Verifies whether a given vault is solvent (i.e., should be liquidated or not) ... /// @dev If the oracle value or the interest rate accumulator has not been called at the time of the /// call, this function computes it  The first sentence above states that the function verifies if the vault is solvent, however the function does not verify the vault status, but only computes some parameters.  The second sentence above states that the function computes the interest rate accumulator if it has not been called before, however the implementation does not perform it.  Angle - Angle Borrowing Module -   19  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                \fSpecification changed:  The NatSpec descriptions have been revised to reflect the behavior of the function implementation:  /// @notice Computes the health factor of a given vault. This can later be used to check whether a given vault is solvent  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.12   Missing Description of Variable Decimals", "body": "  The  documentation  pages  state  that  the  codebase  generally  uses  three  bases:  BASE_TOKENS  (18 decimals),  BASE_PARAMS  (9  decimals)  and  BASE_INTEREST  (27  decimals).  However,  to  improve readability and integrations with other systems, the code would benefit from having a description of the expected base for each variable.  Specification changed:  The  NatSpec  descirption  for  VaultManagerStorage.BASE_PARAMS  states  that  unless  specified otherwise all the parameters are in 9 decimals:  /// @notice Base used for parameter computation: almost all the parameters of this contract are set in `BASE_PARAMS`  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.13   Missing Sanity Checks on Vault Creation", "body": "  The  function  VaultManager.angle  does  not  perform  any  sanity  check  on  vault  creation  for  the parameter to, which is the owner of the vault.    The  sanity  check  to  prevent  vaults  being  minted  to  address(0)  has  been  added  into  the  function VaultManagerERC721._mint:  if (to == address(0)) revert ZeroAddress();  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.14   No Event Emitted on Flashloan's Parameters", "body": " Update  The  function  FlashAngle.setFlashLoanParameters  updates  the  fee  and  the  maximum  amount that can be borrowed by the module; however, no event is emitted.  Angle - Angle Borrowing Module -   20  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  The following event will be triggered every time the function is successfully called.  event FlashLoanParametersUpdated(IAgToken indexed stablecoin, uint64 _flashLoanFee, uint256 _maxBorrowable); ... emit FlashLoanParametersUpdated(stablecoin, _flashLoanFee, _maxBorrowable); ...  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.15   Possible to Optimize Struct", "body": "  The struct FlashAngle.StablecoinData can be optimized to occupy 2 storage slots instead of 3 if reordered.    The struct is reordered to occupy 2 storage slots.  struct StablecoinData {     uint256 maxBorrowable;     uint64 flashLoanFee;     address treasury; }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.16   Precision Loss in Division", "body": "  This line below from the function _checkLiquidation of contract VaultManager.sol uses division, which is prone to rounding errors. In this case it is possible to use multiplication as needed to have both sides of the comparison operator in the same decimals instead of using division.  if (currentDebt <= (maxAmountToRepay * surcharge) / BASE_PARAMS + dust)    The updated code avoids the division operator and evaluates the condition as follows:  if (currentDebt * BASE_PARAMS <= maxAmountToRepay * surcharge + dust * BASE_PARAMS) {     ... }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.17   Specification Mismatch in _handleRepay", "body": "  Angle - Angle Borrowing Module -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                        \fThe NatSpec description for the parameter to in VaultManager._handleRepay states:  @param to Address to which stablecoins should be sent  However, the function only sends collateral tokens to the address to:  if (collateralAmountToGive > 0)     collateral.safeTransfer(to, collateralAmountToGive);  Specification changed:  The NatSpec comments has been updated:  @param to Address to which collateral should be sent  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.18   Specification Mismatch setUint64", "body": "  The  function  setUint64  in  the  contract  VaultManager.sol  is  protected  with  the  modifier onlyGovernorOrGuardian,  however,  it  says  When  setting  parameters governance should make sure .... The Angle team should assess and clarify the intended behaviour and update the specification or the modifier accordingly.  the  specification,   in   Specification changed:  The specification is changed to comply with the modifier:  /// @dev When setting parameters governance or the guardian should make sure that...  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "6.19   Unchecked Array Length", "body": "  The  function  angle  in  the  contract  VaultManager  does  not  check  if  the  input  arrays  actions  and datas have the same length and trigger an early revert if the input parameters do not match, thus be more gas efficient.    The  updated  code  performs  a  check  that  arrays  actions  and  datas  have  the  same  length. Furthermore, it also checks that the arrays have a non-zero length:  if (actions.length != datas.length || actions.length == 0)     revert IncompatibleLengths();  Angle - Angle Borrowing Module -   22  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                  \f6.20   Unchecked VaultID When Adding Collateral  The  function  angle  does  not  perform  any  check  to  verify  if  a  vault  exists  when  the  action  is addCollateral. The internal function _addCollateral also does not perform such checks, hence it is  possible  to  add  collateral  to  vaults  that  are  not  created  yet,  or  to  vaults  that  have  been  burned,  i.e., locking tokens.    The  function  _addCollateral  has  been  updated  to  check  if  the  collateral  is  being  added  into  an existing vault:  if (!_exists(vaultID)) revert NonexistentVault();  Angle - Angle Borrowing Module -   23  DesignLowVersion1CodeCorrected      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.1   Default VaultID Value", "body": "  The function angle in the contract vaultManager/VaultManager.sol will use the latest vaultID if the action's parameter vaultID is 0. Users should be aware of this default behavior and be careful to use vaultID = 0 only when the first action of a batch operations is createVault.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.2   Dependency on Freshness of Chainlink Oracle", "body": " Prices  The  Angle  Borrowing  Module  queries  Chainlink  oracles  to  get  the  price  of  an  asset  and  the  function _readChainlinkFeed performs the following sanity checks:  (uint80 roundId, int256 ratio, , uint256 updatedAt, uint80 answeredInRound)     = feed.latestRoundData(); if (ratio <= 0     || roundId > answeredInRound     || block.timestamp - updatedAt > stalePeriod)         revert InvalidChainlinkRate();  If the price is carried over from an old round (answeredInRound < roundID), or the price is outdated (block.timestamp  -  updatedAt  >  stalePeriod),  then  the  function  reverts.  Therefore,  actions that  query  oracles  cannot  be  executed  if  the  returned  price  do  not  pass  the  sanity  checks,  e.g., closeVault,  removeCollateral,  borrow,  getDebtIn,  liquidate.  This  might  become problematic for the system if Chainlink oracles stop working at any point in future for collateral assets.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.3   Event MinterToggled Can Be Emitted Multiple", "body": " Times  In  contract  AgToken.sol,  MinterToggled event without checking if the minter has already been added or removed.  functions  addMinter  and  removeMinter  will  always  emit  a  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.4   Inconsistency Between Debt and Issued", "body": " Stable Coins  Angle - Angle Borrowing Module -   24  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fWhen a user wants to transfer debt from VaultManager B to VaultManager A, the function angle in the contract  VaultManager.sol  does  not  check  if  VaultManager  B  is  a  valid  VaultManager.  If  a  user deploys a contract with the VaultManager interface and set its address as B, then the debt of the user increases without issuing any stable coins.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.5   Repay Fee Calculation", "body": "  The repay fee in the function VaultManager.angle is calculated with the following code:  uint256 stablecoinAmountPlusRepayFee = (stablecoinAmount * BASE_PARAMS) / (BASE_PARAMS - repayFee);  If  the  user  wants  to  repay  100  USDC  when  the  repay  fee  is  3%,  the  formula  above  will  calculate ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "103.0927835052 USDC as the total amount needed to be repaid.", "body": "  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.6   System Inconsistency", "body": "  In contract AgToken.sol, functions burnNoRedeem and burnFromNoRedeem burn the stable tokens and  interact  with  IStableMaster  which  is  not  part  of  the  borrowing  module  reviewed  in  this  audit. Users of the borrowing module have no incentive to call these functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}, {"title": "7.7   Unbounded Loops in Treasury Contract", "body": "  Functions  setTreasury,  _fetchSurplusFromList  and  removeVaultManager  loop  through  the array vaultManagerList. However, there are no bounds on the size of the array, which means there is a possibility that the transaction exceeds the block gas limit. In those cases, the transaction will revert. Hence, the governance should ensure that the number of entries in vaultManagerList is limited so the transaction cost remains under the block gas limit.  Angle - Angle Borrowing Module -   25  NoteVersion2NoteVersion1NoteVersion2            \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-borrowing-module/"}]