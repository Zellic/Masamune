[{"title": "Bypass or reduction on the lockup period of Pool FDTs.", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  shw   # Vulnerability details  ** Editing on a previous submission to clarify more details **  ## Impact  In `Pool.sol`, the lockup restriction of withdrawal (`Pool.sol#396`) can be bypassed or reduced if new liquidity providers cooperate with existing ones.  ## Proof of Concept  1. A liquidity provider, Alice, deposits liquidity assets into the pool and minted some FDTs. She then waits for `lockupPeriod` days and calls `intendToWithdraw` to pass her withdrawal window. Now she is available to receive FDTs from others. 2. A new liquidity provider, Bob, deposits liquidity assets into the pool and minted some FDTs. Currently, he is not allowed to withdraw his funds by protocol design. 3. Bob and Alice agree to cooperate with each other to reduce Bob's waiting time for withdrawal. Bob transfers his FDT to Alice via the `_transfer` function. 4. Alice calls `intendToWithdraw` and waits for the `withdrawCooldown` period. Notice that Alice's `depositDate` is updated after the transfer; however, since it is calculated using a weighted timestamp, the increased amount of lockup time should be less than `lockupPeriod`. In situations where the deposit from Alice is much larger than that from Bob, Alice could only even need to wait for the `withdrawCooldown` period before she could withdraw any funds. 5. Alice then withdraws the amount of FDT that Bob transferred to her and transfers the funds (liquidity assets) to Bob. Bob successfully reduces (or bypasses) the lockup period of withdrawal.  ## Tools Used  None  ## Recommended Mitigation Steps  Force users to wait for the lockup period when transferring FDT to others. Or let the `depositDate` variable record the timestamp of the last operation instead of a weighted timestamp.  "}, {"title": "Functions calculating the value of `BPT` is vulnerable to flash-loan attacks.", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/113", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In `library/PoolLib.sol`, the return value of functions `BPTVal` and `getPoolSharesRequired` are vulnerable by flash-loan attacks. The attacker can inflate the results of these two functions by swapping a large amount of `liquidityAsset` into the pool and swaps back after the functions are called to deceive the pool contract that BPT has a relatively high price.  Although currently `BPTVal` is not used and `getPoolSharesRequired` only affects the required staking amounts of token for a pool delegate, the code is vulnerable and could be misused by anyone in the future.  ## Proof of Concept  In the function `BPTVal`, the value of BPT in units of liquidityAsset is calculated directly from the balance of `liquidityAsset` in the Balancer pool (`PoolLib.sol#331`). For function `getPoolSharesRequired`, the required BPT to be burned also depends on the current balance of `liquidityAsset` in the pool.  ## Tools Used  None  ## Recommended Mitigation Steps  Use the balance of `liquidityAsset` in the previous block to eliminate the possibility of suffering from a flash-loan attack. A time-weight average price can also mitigate the problem.  "}, {"title": "LoanLib.unwind uses globals.fundingPeriod()", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  Every loan has its own fundingPeriod which is set once in the constructor: fundingPeriod          = globals.fundingPeriod(); fundingPeriod in globals can change. It does not effect already deployed Loans. However, in Loan contract function unwind() calls LoanLib.unwind which checks against globals.fundingPeriod():         IGlobals globals = _globals(superFactory);         // Only callable if time has passed drawdown grace period, set in MapleGlobals         require(block.timestamp > createdAt.add(globals.fundingPeriod()), \"Loan:FUNDING_PERIOD_NOT_FINISHED\"); at this time, globals.fundingPeriod() could be different than this specific Loan's fundingPeriod.  ## Recommended Mitigation Steps  Check expiration against local fundingPeriod.   "}, {"title": "Function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker to emit event as the balance of CollateralLocker changes after calling LoanLib.liquidateCollateral.   "}, {"title": "Interface and implementation function declaration differs", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  ILoan.sol: function getNextPayment() external view returns (uint256, uint256, uint256, uint256) Loan.sol: function getNextPayment() public view returns(uint256, uint256, uint256, uint256, bool) Such discrepencies appear because implementation contracts do not inherit the interface explicitly (Loan is ILoan), so it does not give compilation errors if the declaration changes.  ## Recommended Mitigation Steps  Unify the declarations or even better, make the contract inherit from the interface so you can always be sure that these functions are present.  "}, {"title": "Comment indicates that FundsWithdrawn event should be emitted only when _withdrawableDividend > 0", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/96", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  A comment says: \"It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0.\" However, actually, this event is always emitted (no check against 0).   ## Recommended Mitigation Steps Either emit this event if _withdrawableDividend > 0 or remove the comment.    "}, {"title": "Missing index on events", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  Some events have no index: - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.LossesCorrectionUpdated` - `ExtendedFDT.LossesCorrectionUpdated` - `StakeLocker.StakeDateUpdated` - `MapleTreasury.FundsTokenModified` is never used   ## Impact  Off-chain scripts that rely on these events are unable to filter them efficiently.  ## Recommended Mitigation Steps  Add the missing indexes on the events or remove the events if they are not needed on the backend.   "}, {"title": "Missing check on `setManualPrice(int256 _price)`", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `ChainlinkOracle.setManualPrice` function specifies that it can only be called \"if manualOverride == true\".  This is not the case.   ## Impact  Assume an oracle failure happened, and the oracle needs to be manually set to prevent losses. The `setManualPrice` function succeeds and the owner might think that the oracle price is overwritten as the function would fail when `manualOverride` is not `true` according to specification. The protocol would still use the broken chainlink price feed and suffer losses.  ## Recommended Mitigation Steps  Add the missing `require(manualOverride == true, \"manual override not set\")` check.   "}, {"title": "Wrong docs on UsdOracle", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `UsdOracle.sol` contract states:  > UsdOracle is a constant price oracle feed that always returns 1 USD in USDC precision.  The USDC precision is 6, but the oracle returns a precision of 8, so the comment does not match the code.   ## Impact  A wrong precision on the oracle contract could lead to inflated/deflated prices.  ## Recommended Mitigation Steps  It seems that the current contract code assumes a precision of 8 instead of 6 and works correctly. Clarify if the documentation is wrong or the code needs to be updated. If further development is done and the comment is assumed to be correct, one might use 100 times the actual USDC token balance.   "}, {"title": "Chainlink Price data could be stale", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  There is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:   * [\"if answeredInRound < roundId could indicate stale data.\"](https://docs.chain.link/docs/developer-communications#current-notifications)   * [\"A timestamp with zero value means the round is not complete and should not be used.\"](https://docs.chain.link/docs/historical-price-data#solidity)   ## Impact  The price oracle might return unreliable price data which can lead to a variety of different issues in the protocol, for example, for liquidating more staker & lender tokens than required at fair market price.  ## Recommended Mitigation Steps  Add missing checks for stale data. See example [here](https://github.com/cryptexfinance/contracts/blob/master/contracts/oracles/ChainlinkOracle.sol#L58-L65).   "}, {"title": "Unused variable in `PoolLib.handleDefault`", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  Low  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/7b51e901ac50e524369549af70ca9eeb   "}, {"title": "Using precalculated value in the Pool & Loan contracts", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/75", "labels": ["bug", "sponsor confirmed", "resolved", "G (Gas Optimization)"], "target": "2021-04-maple-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  Low, just gas optimizations  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/60973d61b49ff1f5ec83b121b33b30b1  ## Tools Used  Remix  ## Recommended Mitigation Steps  Use constant for unchanging values  "}, {"title": "Inconsistent NatSpec comment in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The isValidDelegateorAdmin() is used for access control on both setLiquidityCap() and claim() but the @dev Natspec comment only specifies setLiquidityCap() which is misleading.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L597  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add claim() as well to @dev on L597.   "}, {"title": "Inconsistent NatSpec comment in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers/requires/checks is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the setAdmin() function which is accessible only by Pool Delegate.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add \u201cCan only called by the pool delegate.\u201d to @dev on L330.   "}, {"title": "Missing event for critical operation of setAdmin change in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Pool can call claim() and setLiquidytCap() along with the Pool Delegate. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   "}, {"title": "Incorrect require error message string in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L167 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.   require(!globals.protocolPaused(), \"PoolFactory:PROTOCOL_PAUSED\");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(!globals.protocolPaused(), \u201cLoanFactory:PROTOCOL_PAUSED\");   "}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L163-L168  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   "}, {"title": "Incorrect require error message string in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L160 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor() || admins[msg.sender], \u201cPoolFactory:UNAUTHORIZED\");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L160  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor() || admins[msg.sender], \u201cLoanFactory:UNAUTHORIZED\");  "}, {"title": "Incorrect require error message string in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L153 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor(), \"PoolFactory:INVALID_GOVERNOR\");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L153  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor(), \u201cLoanFactory:INVALID_GOVERNOR\");   "}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L156-L161  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   "}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L149-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   "}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in LoanFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L133-L139  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   "}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L152-L157  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   "}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L145-L150  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   "}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L138-L143  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   "}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function unpause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers unpaused state. Returns functionality for certain functions. Only Governor can call this function.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L130-L136  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   "}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L122-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   "}, {"title": "Inconsistent NatSpec comment in StakeLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidPoolDelegate() is not about pause/unpause but about msg.sender being a valid Pool Delegate, which is used to check if msg.sender can set lockup period and open staking to public in StakeLocker.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L302-L307  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidPoolDelegate().   "}, {"title": "Inconsistent NatSpec comment in StakeLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the pull() function of StakeLocker.sol which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L125-L132  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add \u201cOnly Pool can call this function.\u201d to @dev on L126.   "}, {"title": "Missing event for critical operation of Pool Delegate validity change in MapleGlobals.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Pool delegates are trusted actors (see https://github.com/maple-labs/maple-core/wiki/Security#trust-assumptions) and so any change (additions/removals) in their validity should be recorded for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L232-L239  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log pool delegate validity change in setPoolDelegateAllowlist function.   "}, {"title": "Missing event for critical operation of setAdmin change for Protocol admin in MapleGlobals.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol admin defined in MapleGlobals can pause/unpause all important functionalities of the protocol. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L148-L156  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   "}, {"title": "Mirrored admin variables in global context, Pool, PoolFactory, Loan and LoanFactory may make it confusing for deployment and maintenance", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The access control model for the different contracts and how they interact is confusing and may cause issues during deployment and maintenance. Multiple contracts have the notion of admin(s), all of which use setAdmin function to update admin status. This mirroring and reuse of the admin variable is susceptible to accidents.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L20 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L55 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L19 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L58 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L27  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Rename the different admin variables e.g. adminGlobal, adminPool, adminLoan. Document the access control roles, hierarchy and interactions explicitly.   "}, {"title": "Inconsistent NatSpec comment in DebtLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the claim() function which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLocker.sol#L44-L54  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add \u201cOnly called by the pool contract.\u201d to @dev on L45.   "}, {"title": "Missing event for critical operation of setAdmin change in Loan.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Loan can pause/unpause the fundLoan operation along with the borrower. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L409-L413  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   "}, {"title": "Missing event for critical operation of new Liquidity locker creation in LiquidityLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LiquidityLockerFactory.sol#L19-L24  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   "}, {"title": "Missing event for critical operation of new Funding locker creation in FundingLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/FundingLockerFactory.sol#L21-L26  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   "}, {"title": "Missing event for critical operation of new Debt locker creation in DebtLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLockerFactory.sol#L19-L23  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   "}, {"title": "Typo NULL_TRASNFER_DST", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact  A require statement in the function transfer in LiquidityLocker.sol contains a typo. TRASNFER should be TRANSFER  ## Proof of Concept  LiquidityLocker.sol: function transfer(address dst, uint256 amt) external isPool { LiquidityLocker.sol:    require(dst != address(0), \"LiquidityLocker:NULL_TRASNFER_DST\");  ## Tools Used  Editor  ## Recommended Mitigation Steps  Fix typo   "}, {"title": "Unused definition of enum", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact  LoanLib.sol has a definition of enum State and Loan.sol has the same definition. The LoanLib.sol does not seem to be used This means dead code and could be confusing.  ## Proof of Concept  Loan.sol:       enum State { Ready, Active, Matured, Expired, Liquidated } LoanLib.sol:    enum State { Ready, Active, Matured, Expired, Liquidated }  ## Tools Used  grep \"enum\" *.sol -S  ## Recommended Mitigation Steps  Remove the unused definition from LoanLib.sol (or make sure there is just one definition for the enum and include that elsewhere)  "}, {"title": "Declare functions `external` to save gas", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/11", "labels": ["bug", "sponsor confirmed", "resolved", "G (Gas Optimization)"], "target": "2021-04-maple-findings", "body": "# Handle  JMukesh   # Vulnerability details  // All these function described should be declared  external, as functions that are never called by the contract should be declared external to save gas.                 In fundingLockerFactory.sol --> newLocker(){} In LatefeeCalc.sol          --> getlateFee(){] In Loan.sol                 --> MakeFullPayment(){} In library/Loanlib.sol      --> getNextPayment(){} In library/Util.sol         --> calcMinAmount(){} In token/BasicFDT.sol       --> withdrawnFundsOf(){} In MapleTreasury.sol        --> reclaimERC20(){}                                distributeToHolder(){}                                convertERC20(){}  In Pool.sol                 --> claimablefunds(){}                             --> BPTval(){} In Poollib,sol              --> validateDeactivation(){}                                isWithdrawAllowed(){}                                getInitialStakeRequirements(){}                                ecognizedLossesOf(){} In Premiumcal.sol            --> getPremium(){} In Repayment.sol            -->  getNextPayment(){}     "}, {"title": "MapleTreasury does not emit an event when MapleGlobals address is updated", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Its impact will be limited since we will not able tract the change of address off-chain but on-chain we can which will consume gas  ## Proof of Concept In file MapleTreasury.sol has no event, so it is difficult to track off-chain changes of  Address of new MapleGlobals contract     ## Tools Used  slither  ## Recommended Mitigation Steps  add event for setting global address  "}, {"title": "`UniswapAnchoredView`'s `PriceUpdated` event is never fired", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/38", "labels": ["bug", "duplicate", "disagree with severity", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  `UniswapAnchoredView`'s `PriceUpdated` event is never fired.  ## Impact  Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps  Use it or remove it.   "}, {"title": "UniswapConfig getters return wrong token config if token config does not exist", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/37", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.  The same issue occurs also for:  - `getTokenConfigByCToken` - `getTokenConfigByUnderlying`  ## Impact  When encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token. This leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.  ## Recommended Mitigation Steps  Fix the non-existence check.   "}, {"title": "Usage of `address.transfer`", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `transfer` function is used in `Maximillion.sol` to send ETH to an account.  ## Impact  It is performed with a fixed amount of GAS and might fail if GAS costs change in the future or if a smart contract's fallback function handler is complex.  ## Recommended Mitigation Steps  Consider using the lower-level `.call{value: value}` instead and checking its success return value.  "}, {"title": "function getUnderlyingPrice compares against \"cETH\"", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact contract CompoundLens functions cTokenMetadata and cTokenBalances compare against \"bETH\" while contract SimplePriceOracle function getUnderlyingPrice compares against \"cETH\". It is not clear if this SimplePriceOracle will be used in production, probably only for testing, but still would be nice to unify it across all the contracts.  ## Recommended Mitigation Steps Replace \"cETH\" with \"bETH\" in SimplePriceOracle function getUnderlyingPrice.  "}, {"title": "Use 'receive' when expecting eth and empty call data", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact contract CEther fallback function was refactored to be compatible with the Solidity 0.6 version:    /**    * @notice Send Ether to CEther to mint    */   fallback () external payable {       (uint err,) = mintInternal(msg.value);       requireNoError(err, \"mint failed\");   }  From Solidity 0.6 documentation:  \"The unnamed function commonly referred to as \u201cfallback function\u201d was split up into a new fallback function that is defined using the fallback keyword and a receive ether function defined using the receive keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly payable. The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function payable or not. If it is not payable then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern.\"  I think in this case \"receive\" is more suitable as the function is expecting to receive ether and empty call data.  ## Recommended Mitigation Steps Replace \"fallback\" with \"receive\".  "}, {"title": "uint(-1) index for not found", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/24", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact functions getTokenConfigBySymbolHash, getTokenConfigByCToken and getTokenConfigByUnderlying check returned index against max uint:   index != uint(-1) -1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.  ## Recommended Mitigation Steps One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.  "}, {"title": "Missed NatSpec @param for newly introduced parameter distributeAll", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeSupplierComp() function has been modified to take in a third parameter which is a boolean distributeAll. But the corresponding NatSpec comments for the function have not been updated to add this new parameter. This could lead to minor confusion where NatSpec is consulted.  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L1238-L1243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add @param for distributeAll parameter.  "}, {"title": "Floating pragma used in Uniswap*.sol\u2028", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/19", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Contracts should be deployed using the same compiler version/flags with which they have been tested. Locking the floating pragma, i.e. by not using ^ in pragma solidity ^0.6.10, ensures that contracts do not accidentally get deployed using an older compiler version with unfixed bugs.  For reference, see https://swcregistry.io/docs/SWC-103   ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapAnchoredView.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapConfig.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapLib.sol#L3   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove ^ in \u201cpragma solidity ^0.6.10\u201d and change it to \u201cpragma solidity 0.6.12\u201d to be consistent with the rest of the contracts.  "}, {"title": "All except one Comptroller verify functions do not verify anything in Comptroller.sol/CToken.sol\u2028", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Six of the seven Comptroller verify functions do nothing. Not sure why their calls in CToken.sol have been uncommented from the original Compound version.  Except redeemVerify(), six other verify functions transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify() and seizeVerify() have no logic except accessing state variables to not be marked pure. Calls to these functions were commented out in the original Compound code\u2019s CToken.sol but have been uncommented here.  Given that they do not implement any logic, the protocol should not be making any assumptions about any defence provided from their unimplemented verification logic.  ## Proof of Concept  Dummy functions whose comments say \u201c// Shh - currently unused\u201d:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L263-L281  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L402-L418  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L450-L474  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L519-L546  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L584-L609  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L638-L656    Uncommented calls from modified code:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L126  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L560  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L798  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L915  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1019  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1090    Commented calls from original Compound code:  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L123-L124  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L558-L559  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L797-L798  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L915-L916  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1020-L1021  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1092-L1093    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add logic to implement verification if that is indeed assumed to be implemented but is actually not. Otherwise, comment call sites.  "}, {"title": "sweepToken() function removed in CErc20.sol from original Compound code", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/17", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The sweepToken() function in the original Compound code whose specified purpose was to recover accidentally sent ERC20 tokens to contract has been removed.   The original code comment says: \u201cA public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock).\u201d This safety measure is helpful given the number/value of accidentally stuck tokens that are sent to contracts by mistake.  Tokens accidentally sent to this contract will be stuck leading to fund loss for sender.  ## Proof of Concept  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CErc20.sol#L112-L120  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CErc20.sol#L109-L121  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Retain this function unless there is a specific reason to remove it here.  "}, {"title": "No account existence check for low-level call in CEther.sol", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall\u00a0return\u00a0true\u00a0even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  The doTransferOut() function was changed from using a transfer() function (which reverts) to a call() function (which returns a boolean), however there is no account existence check for the destination address to. If it doesn\u2019t exist, for some reason, call will still return true (not throw an exception) and successfully pass the return value check on the next line.  The checked call paths don\u2019t seem vulnerable because they use msg.sender/admin and not a user-controlled address, but this may be a risk if used later in other contexts. Hence rating as low-risk.  For reference, see this related high-risk severity finding from Trail of Bit\u2019s audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CEther.sol#L145-L148  https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls  https://docs.soliditylang.org/en/v0.8.4/control-structures.html#error-handling-assert-require-revert-and-exceptions   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for account-existence before the call() to make this safely extendable to user-controlled address contexts in future.  "}, {"title": "Missing event visbility in _setCompAddress() function", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The _setCompAddress() function in the Comptroller contract does not emit an event when changing the comp address. While this does not impose any security risk, it does hinder a users ability to view any changes made to the comp address through the contract's lifetime.   ## Affected line https://github.com/code-423n4/2021-04-basedloans/blob/main/code/contracts/Comptroller.sol#L1354  ## Recommended Mitigation Steps It is recommended to emit an event indicating the old comp address, and the new comp address to be used when calling the _setCompAddress() function. An example of such an event is `event NewCompAddress(address oldCompAddress, address newCompAddress)`.  "}, {"title": "More readable constants", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Some constant values are difficult to read in one time because they have at lot of 0's. Solidity allows _ to separate series of zero's  ## Proof of Concept .\\Governance\\Blo.sol:    uint public constant totalSupply = 100000000e18; // 100 million BLO .\\Governance\\GovernorAlpha.sol:    function quorumVotes() public pure returns (uint) { return 4000000e18; } // 4,000,000 = 4% of BLO .\\Governance\\GovernorAlpha.sol:    function proposalThreshold() public pure returns (uint) { return 1000000e18; } // 1,000,000 = 1% of BLO  ## Tools Used grep  ## Recommended Mitigation Steps Replace   1000000e18 with    1_000_000e18  Replace   4000000e18 with    4_000_000e18  Replace 100000000e18 with  100_000_000e18   "}, {"title": "Unnecessary `else if` statement in `swapWithSynthsWithLimit`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In `Router.sol`, the second `else if` statement in the function `swapWithSynthsWithLimit` is unnecessary.  ## Proof of Concept  Referenced code: [Router.sol#L162](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L162)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using `else {...}`, which has the identical behavior to save gas.  "}, {"title": "Unused ID field in structs", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/304", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Both structs CollateralDetails and DebtDetails have unused ID field which is never set nor queried:    uint ID;  "}, {"title": "token == arrayAnchors[i]", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact In function updateAnchorPrice here 'arrayAnchors[i]' can be replaced with 'token' to eliminate one expensive storage access:    arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);  "}, {"title": "totalSupply + amount > maxSupply", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/299", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Condition could be '>', not '>=' as there is no point in recalculating amount to the same value (waste of gas):  if((totalSupply + amount) >= maxSupply){   amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply  }  "}, {"title": "Some storage optimizations", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/292", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  a_delamo   # Vulnerability details  Here you have more information: https://gist.github.com/alexon1234/5eb3fff3bded4e4c50d6e13abae6f474  "}, {"title": "variable == false -> !variable", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/288", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact a bit cheapier when you replace:   require(inited == false); with:   require(!inited); same with variable == true.  "}, {"title": "Extra useless steps to calculate pooledVADER and pooledUSDV ", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/287", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Here are some useless calculations:   if(_token == VADER && _pool != VADER){  // Want to know added VADER      addedAmount = _balance - pooledVADER;      pooledVADER = pooledVADER + addedAmount;  } else if(_token == USDV) {             // Want to know added USDV      addedAmount = _balance - pooledUSDV;      pooledUSDV = pooledUSDV + addedAmount; if you do the simple maths, it is always in the first case, pooledVADER = _balance, in the second case pooledUSDV = _balance.   "}, {"title": "Use immutable for constant variables", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/286", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact There are variables that are only assigned once (e.g. in a constructor). You should mark such variables with the keyword \"immutable\", this greatly reduces the gas costs. A concrete example of such a variable is \"VADER\" which is only initialized once and cannot be changed later:    VADER = _vader; There are plenty of such variables across the contracts.   "}, {"title": "ERC20 specification declares decimals as uint8 type", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/283", "labels": ["bug", "0 (Non-critical)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact iERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.  ## Recommended Mitigation Steps You can refactor to uint8 or just be informed about such compatibility guidelines.  "}, {"title": "Not needed check for uint > 0", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact The following functions check that an uint > 0 but it's always true.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L278 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L197 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L127  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Remove the checks.  "}, {"title": "Events not emitted", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/250", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact Events not emitted for important state changes. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L93 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L98 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L196 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L201 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L61 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L163 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L171 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L179 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L184 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L188 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L193 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L198  ## Proof of Concept -  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Emit events with meaningful names for the changes made.  "}, {"title": "Tokens can get locked and funds lost when minting is disabled in Vader.sol and USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/238", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The flipMinting() function can disable/stop conversion/redeeming of VADER<>USDV tokens upon DAO approval (when that functionality is added). When minting is disabled (i.e. false), the convert functions in USDV.sol accept VADER tokens from sender (L170) but do not burn them to mint the sender the equivalent USDV tokens. When minting is disabled (i.e. false), the redeem functions in USDV.sol accept USDV tokens from sender (L188) but do not burn them to mint the sender the equivalent VADER tokens. Both paths silently return 0 without reverting the transaction thus trapping the sent tokens and leaving the users with lost funds. Protocol will break and funds will be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L171-L177  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174-L181  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L165-L172  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L183-L191  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L238-L243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Revert in the paths (instead of silently returning) when minting is disabled so that tokens are not accepted for conversion or redemption.  "}, {"title": "Add anchor map", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  `Router.updateAnchorPrice` iterates over all anchor tokens on each update which is very inefficient and does a lot of expensive storage loads. add a mapping `address => index` to easily retrieve the index of the token in the `arrayAnchors` mapping.  "}, {"title": "`DAO.mapPID_finalised` is never read in the contract, only written", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  `DAO.mapPID_finalised` is never read in the contract, only written. Remove it and show the `finalized` state in the frontend based on whether the `FinalisedProposal` event was emitted  "}, {"title": "Canceled proposals can still be executed", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/228", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Proposals that passed the threshold (\"finalized\") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.  ## Impact  Proposals cannot be cancelled.  ## Recommended Mitigation Steps  Set a cancel flag and check for it in `finaliseProposal` and in execution.   "}, {"title": "Proposals can be cancelled", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/227", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved.  ## Impact  An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.  ## Recommended Mitigation Steps  Check `oldProposalID == newProposalID`   "}, {"title": "Vault Weight accounting is wrong for withdrawals", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/224", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.  The second deposited synth is now essentially weightless.  ## Impact  Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.  ## Recommended Mitigation Steps  The weight should be indexed by the synth as well.   "}, {"title": "Vault rewards last claim time not always initialized", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/223", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.  ## Impact  The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.  ## Recommended Mitigation Steps  Let users only harvest synths that they deposited.   "}, {"title": " Vault rewards can be gamed", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/222", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.  Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.  Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:  1. Create a custom token and issue lots of tokens to the attacker 2. Create synth of this token 3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive. 4. Mint some synths by paying BASE to the pool 5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.  Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.  ## Impact  Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable \"real\" synth. The rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.  ## Recommended Mitigation Steps  The `calcReward` function completely disregards the `synth` parameter which seems odd. Think about making the rewards based on the actual synths deposited instead of a \"global\" weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.   "}, {"title": "Transfer fee is burned on wrong accounts", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/220", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.  ## Impact  Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.  ## Recommended Mitigation Steps  It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.  "}, {"title": "Interest debt is capped after a year", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/219", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Utils.getInterestOwed` function computes the `_interestPayment` as:  ```solidity uint256 _interestPayment =   calcShare(       timeElapsed,       _year,       getInterestPayment(collateralAsset, debtAsset)   ); // Share of the payment over 1 year ```  However, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.  ## Impact  The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.  It's still recommended to fix the logic bug in case more functions will be added that use the broken function.  ## Recommended Mitigation Steps  Use a different function than `calcShare` that does not cap.   "}, {"title": "`flashProof` is not flash-proof", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/218", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.  However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.  But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)  A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.  ## Impact  The `flashProof` modifier does not serve its purpose.  ## Recommended Mitigation Steps  Try to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.  Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.   "}, {"title": "Wrong `calcAsymmetricShare` calculation", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/214", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share which is used to determine the collateral value in base tokens could be wrong. For example, it might be possible to borrow more than the collateral put up.  ## Recommended Mitigation Steps  Clarify if the comment is correct or the code and fix them.   "}, {"title": "getAnchorPrice potentially returns the wrong median", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/213", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`. This only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.  ## Impact  If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.  ## Recommended Mitigation Steps  Check the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.   "}, {"title": "Wrong slippage protection on Token -> Token trades", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/209", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:  1. token to base 2. base to token  The slippage protection of the second trade (base to token) is computed wrong:  ```solidity require(iUTILS(UTILS()).calcSwapSlip(         inputAmount, // should use outToken here from prev trade         iPOOLS(POOLS).getBaseAmount(outputToken)   ) <= slipLimit ); ```  It compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.  ## Impact  Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.  ## Recommended Mitigation Steps  It should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.   "}, {"title": "Missing access restriction on `lockUnits/unlockUnits`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/208", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`.  ## Impact  Anyone can steal pool tokens from any other user.  ## Recommended Mitigation Steps  Add access control and require that `msg.sender` is the router or another authorized party.   "}, {"title": "4 Synths can be minted with fake base token", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/207", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.  The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER` in `mintSynth`.   "}, {"title": "`getAddedAmount` can return wrong results", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/206", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. However, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns wrong results:  1. It gets the `token` balance 2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token  ## Impact  Anyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.  Furthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.  ## Recommended Mitigation Steps  Add a require statement in the `else` branch that checks that `_token == _pool`.   "}, {"title": "Swap token can be traded as fake base token", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/205", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.  Another example scenario is that the token pool amount can be stolen. Send `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER`  "}, {"title": "Wrong liquidity units calculation", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/204", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correclty implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.  ## Recommended Mitigation Steps  Fix the equation.   "}, {"title": "Incorrect burn address in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/202", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The internal _transfer() function is called from external facing transfer(), transferFrom() and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo(). These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.  This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L129  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L122-L134  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L91-L94  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L108-L112  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L116-L119    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change L129 to: _burn(sender, _fee);   "}, {"title": "Gas Optimization: DAO.sol Unnecessary Multiple Return Statements", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact Gas Optimization: DAO.sol Unnecessary Multiple Return Statements  ## Recommended Mitigation Steps  In DAO.sol, replace this:  if(votes > consensus){     return true; } else {     return false; }  With this:  return (votes > consensus)  "}, {"title": "Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value  The value \"(T1 * B1) / T1\" is identical to the value \"B1\", so you can simplify the expression \"B1 + (T1 * B1) / T1\" to \"B1 + B1\".  ## Recommended Mitigation Steps  In Utils.sol, replace this:  uint _redemptionValue = B1 + (T1 * B1) / T1;   With this:  uint _redemptionValue = B1 + B1;  "}, {"title": "Gas Optimization: Vader.sol Unnecessary Conditional", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Vader.sol Unnecessary Conditional  You can remove this conditional entirely.  ## Recommended Mitigation Steps  In Vader.sol, change this:  if(emitting){         emitting = false;     } else {         emitting = true;     }  To this:  emitting = !emitting;  "}, {"title": "Gas Optimization: Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact  Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero  SSTORE calls (writes to storage) are very expensive, especially for cold-storage slots (those that have not yet been accessed this transaction). We know that the SSTORE call to totalFees will be a cold storage call, since this is the only place in the whole contract that totalFees is used. Vether.sol makes two SSTORE calls in _transfer that are unnecessary when _fee is zero. It will be common for _fee to be zero, since Vether.sol implements an \"excluded addresses\" list (mapAddress_Excluded), where _fee is zero when either the sender or the recipient is on the excludedAddresses list. Currently, anyone can add themselves to the excludedAddresses list, but that is probably a mistake.  Nevertheless, since it will probably at least include Uniswap, we should add a check for whether _fee is zero.  ## Proof of Concept When _fee is zero, Vether._transfer() nevertheless makes these two unnecessary SSTORE calls:  _balances[address(this)] += _fee; totalFees += _fee;  ## Recommended Mitigation Steps  Change this:  _balances[address(this)] += _fee; totalFees += _fee;  To this:  if(_fee > 0){   _balances[address(this)] += _fee;   totalFees += _fee; }    "}, {"title": "Unnecessary logic that will never get triggered in DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/186", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional checking if proposal has quorum in finaliseProposal() is unnecessary and will never be triggered because finalising proposals will always have quorum. Proposal without quorum are not finalised in the voteProposal() function.  Removing this code will reduce contract size and save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L114-L116  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L82-L90  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L94-L99   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove code from L114 to L116.  "}, {"title": "Perform early input validation of zero-address for efficiency in DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/182", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Instead of performing a zero-address check in moveRewardAddress on L146 or L152, it is more efficient to do so in newAddressProposal() as soon as the new address is proposed, instead of allowing a proposal for zero-address which goes through the whole voting process. If there is a requirement for zero-address proposals, it should be specified explicitly.  Depending on the participation in the voting process, this will save significant amount of gas for all the participants.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L69-L74  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L144-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Perform input validation of zero-address in newAddressProposal() for proposedAddress parameter.   "}, {"title": "changeDAO should be a two-step process in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/162", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  changeDAO() updates\u00a0DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires\u00a0msg.sender\u00a0to be the incorrectly used\u00a0DAO\u00a0address (for which private keys may not be available to sign transactions).  Reference: See finding #6 from Trail of Bits audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use a two-step process where the old DAO address first proposes new ownership in one transaction and a second transaction from the newly proposed DAO address accepts ownership. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.   "}, {"title": "Missing input validation may set rewardAddress to zero-address in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/160", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function setRewardAddress is used by DAO to change rewardAddress from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L80  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L209  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L183-L186   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check to setRewardAddress.  "}, {"title": "Gas savings by converting storage variable to immutable in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity\u2019s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), \u201cState variables can be declared as\u00a0constant\u00a0or\u00a0immutable. In both cases, the variables cannot be modified after the contract has been constructed. For\u00a0constant variables, the value has to be fixed at compile-time, while for\u00a0immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.\u201d  The burnAddress variable  can be made immutable. This will avoid the use of one storage slot and lead to gas savings.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L36   https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L71  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Make burnAddress immutable.   "}, {"title": "Flash attack mitigation does not work as intended in USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/138", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  One of the stated protocol (review) goals is to detect susceptibility to \u201cAny attack vectors using flash loans on Anchor price, synths or lending.\u201d As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number  However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0 which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: \"// Stops an EOA doing a flash attack in same block\"  Even if the DAO can call setParams() to change blockDelay to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalises and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L35-L44  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize blockDelay to >= 1 at declaration or in constructor.   "}, {"title": "Gas savings by declaring state variables constant in USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity\u2019s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), \u201cState variables can be declared as\u00a0constant\u00a0or\u00a0immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for\u00a0immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.\u201d  State variables name, symbol and decimals can be declared as constants and assigned at declaration (instead of constructor) because they are never modified later. This avoid 3 storage slots and associated expensive SSTOREs/SLOADs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L12-L13   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Declare state variables name, symbol and decimals as constant.   "}, {"title": "Incorrect operator used in deploySynth() of Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/124", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory\u2019s deploySynth() function.   However, the require() incorrectly uses \u2018||\u2019 operator instead of \u2018&&\u2019 which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L138   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change \u2018||\u2019 operator to \u2018&&\u2019 in the require statement: require(token != VADER && token != USDV);   "}, {"title": "Gas savings by removing unused state variable _isMember and related getter function isMember() in Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  _isMember mapping state variable is declared and used only in the getter function isMember(), but is net assigned to anywhere in the contract. This will consume an unnecessary storage slot and along with its getter function will also increase the contract size.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L215-L217   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove _isMember state variable declaration on L22 and related getter function isMember().   "}, {"title": "Gas savings by moving inited bool state variable next to an address state variable declaration in Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  A bool in Solidity is internally represented as a unit8 and so required only 8 bits of the 256-bits storage slot. An address variable is 160-bits. So declaring a bool next to an address variable lets Solidity pack them in the same storage slot thereby using one slot instead of two.  Moving the inited bool state variable next to one of the address state variables VADER, USDV, ROUTER or FACTORY lets the compiler pack them together in one storage slot instead of two, thereby saving one slot. It costs 20k gas to SSTORE each slot of data.  The current order where inited bool is declared before uint does not allow packing because uint itself requires the entire 256-bits of a slot, which forces the compiler to use one full slot for the inited bool variable.  For reference, see https://mudit.blog/solidity-gas-optimization-tips/  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L13-L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move inited bool state variable declaration next to an address state variable declaration.   "}, {"title": "Gas savings by breaking from loop after match+replace in replaceAnchor() of Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  If the requirement is that listed anchors are unique token addresses, then the loop in replaceAnchor() can break upon match+replace to save gas from executing more loop iterations.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L261-L265   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a break statement after L263.   "}, {"title": "Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L234-L241  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L227-L229  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L227  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check if oldToken exists and is curated as part of input validation in replacePool() function.   "}, {"title": "Gas savings by removing unused state variable repayDelay in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  repayDelay uint state variable is declared but never used elsewhere. This will consume an unnecessary storage slot and also increase the contract size.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L35   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove repayDelay state variable declaration on L35.   "}, {"title": "Copy-paste bug leading to incorrect harvest rewards in Vault.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/51", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.  This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L141  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L144  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L125  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L105   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.  L144 should be changed to: uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();   "}, {"title": "Different pragma solidity", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/25", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Vault.sol has a different pragma statement than the rest, it contains an additional \"^\".  For the record the Vether.sol contract (as deployed here https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code),  has a different solidity version.  It's cleaner to use the same versions.  ## Proof of Concept  DAO.sol:pragma solidity 0.8.3; Factory.sol:pragma solidity 0.8.3; Pools.sol:pragma solidity 0.8.3; Router.sol:pragma solidity 0.8.3; Synth.sol:pragma solidity 0.8.3; USDV.sol:pragma solidity 0.8.3; Utils.sol:pragma solidity 0.8.3; Vader.sol:pragma solidity 0.8.3; Vault.sol:pragma solidity ^0.8.3; Vether.sol:pragma solidity 0.6.4;  ## Tools Used Editor  ## Recommended Mitigation Steps Use the same solidity versions   "}, {"title": "Result of ERC20 transfer not checked", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function transferOut of Pools.sol contains a iERC20(_token).transfer where the result of the function isn't checked. This could result in transfers that don't succeed are undetected.  ## Proof of Concept Pools.sol:   function transferOut(address _token, uint _amount, address _recipient) internal {         if(_token == VADER){             pooledVADER = pooledVADER - _amount; // Accounting         } else if(_token == USDV) {             pooledUSDV = pooledUSDV - _amount;  // Accounting         }         if(_recipient != address(this)){             iERC20(_token).transfer(_recipient, _amount);         }     }  ## Tools Used Editor  ## Recommended Mitigation Steps Add a require statement to check the result: require(...transfer(...) )   "}, {"title": "Init function can be called by everyone", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.  ## Proof of Concept  DAO.sol:    function init(address _vader, address _usdv, address _vault) public { Factory.sol:    function init(address _pool) public { Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public { Router.sol:    function init(address _vader, address _usdv, address _pool) public { USDV.sol:    function init(address _vader, address _vault, address _router) external { Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public { Vader.sol:    function init(address _vether, address _USDV, address _utils) external { Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {    ## Tools Used Editor  ## Recommended Mitigation Steps Add a check to the init function, for example that only the deployer can call the function.  "}, {"title": "Some  unused code", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There is some unused / redundant code present.  Router.sol defines repayDelay but it is never used Vault.sol initializes POOLS twice, with the same value.  ## Proof of Concept Router.sol: uint public repayDelay = 3600;  Vault.sol:  function init(address _vader, address _usdv, address _router, ... ..         POOLS = _pool; ..           POOLS = _pool;     ## Tools Used Editor  ## Recommended Mitigation Steps Remove redundant code  "}, {"title": "Public function that could be declared external", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept  1. In Vault.sol  -- > init() and grant()                     https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L45  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L68  2. Vader.sol -- > burn()    https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L146  3. Utils.sol -- > init(),  getProtection()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L30  4. Router.sol -- >  init(address,address,address)  getVADERAmount(uint256)  getUSDVAmount(uint256)  borrow(uint256,address,address)  repay(uint256,address,address)  checkLiquidate() getSystemCollateral(address,address)  getSystemDebt(address,address) getSystemInterestPaid()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L77  5. Pools.sol  init(address,address,address,address)  isMember(address)  isSynth(address)   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol  6. Dao.sol  init(address,address,address)  newGrantProposal(address,uint256)  newAddressProposal(address,string)  voteProposal(uint256)  cancelProposal(uint256,uint256)  finaliseProposal(uint256)  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L46    ## Tools Used  slither  ## Recommended Mitigation Steps  use external instead of public visibility to save gas  "}, {"title": "Unchecking the ownership of `mph` in function `distributeFundingRewards` could cause several critical functions to revert", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.  ## Proof of Concept  Referenced code: [MPHMinter.sol#L121](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/rewards/MPHMinter.sol#L121) [DInterest.sol#L1253](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1253) [DInterest.sol#L1420](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1420)  ## Tools Used  None  ## Recommended Mitigation Steps  Add a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).  "}, {"title": "Use openzeppelin ECDA for erecover", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  In `Sponsorable.sol` is using erecover directly to verify the signature. Being such a critical piece of the protocol, I would recommend using the ECDSA from openzeppelin as it does more validations when verifying the signature.   ```  // Currently   address recoveredAddress =       ecrecover(digest, sponsorship.v, sponsorship.r, sponsorship.s);     require(       recoveredAddress != address(0) && recoveredAddress == sponsorship.sender,       \"Sponsorable: invalid sig\"     );     //ECDSA     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most         // signatures from current libraries generate a unique signature with an s-value in the lower half order.         //         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept         // these malleable signatures as well.         require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");         require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");          // If the signature is valid (and not malleable), return the signer address         address signer = ecrecover(hash, v, r, s);         require(signer != address(0), \"ECDSA: invalid signature\");          return signer;     }    ``` ## Tools Used  None   "}, {"title": "Extra precautions in updateAndQuery", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function updateAndQuery of EMAOracle.sol subtracts the incomeIndex with the previous incomeIndex. These incomeIndex values are retrieved via the moneyMarket contract from an external contract.  If by accident the previous incomeIndex is larger than the current incomeIndex then the subtraction would be negative and the code halts (reverts), without an error message. Also the updateAndQuery function would not be able to execute (until the current incomeIndex is larger than the previous incomeIndex).  This situation could occur when an error occurs in one of the current or future money markets.  ## Proof of Concept EMAOracle.sol:   function updateAndQuery() {         ...         uint256 _lastIncomeIndex = lastIncomeIndex;         ...         uint256 newIncomeIndex = moneyMarket.incomeIndex();         uint256 incomingValue =             (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /                 timeElapsed;  ## Tools Used Editor  ## Recommended Mitigation Steps Give an error message when the previous incomeIndex is larger than the current incomeIndex. And/or create a way to recover from this erroneous situation.  "}, {"title": "function payInterestToFunders does not have a re-entrancy modifier", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact function payInterestToFunders does not have a re-entrancy modifier. I expect to see this modifier because similar functions (including sponsored version) have it.  ## Recommended Mitigation Steps Add 'nonReentrant' to function payInterestToFunders.  "}, {"title": "Missmatch between the comment and the actual code", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Here the comment says that it should transfer from msg.sender but it actually transfers from the sender which is not always the msg.sender (e.g. sponsored txs):   // Transfer `fundAmount` stablecoins from msg.sender   stablecoin.safeTransferFrom(sender, address(this), fundAmount);  ## Recommended Mitigation Steps Update the comment to match the code.  "}, {"title": "contract AaveMarket function setRewards has a misleading revert message", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact contract AaveMarket function setRewards has a misleading revert message:    require(newValue.isContract(), \"HarvestMarket: not contract\");  ## Recommended Mitigation Steps Should be 'AaveMarket', not 'HarvestMarket'.  "}, {"title": "Incorrect type conversion in the contract `ABC` makes users unable to burn FSD tokens", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/77", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `_calculateDeltaOfFSD` of contract `ABC` incorrectly converts an `int256` type parameter, `_reserveDelta`, to `uint256` by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation `sub` at line 43 to revert, and thus the FSD tokens cannot be burned. (`_reserveDelta` is negative when burning FSD tokens)  ## Proof of Concept  Simply calling `fsd.burn` after a successful `fsd.mint` will trigger this bug.  Referenced code: [ABC.sol#L43](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L43) [ABC.sol#L49](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L49) [ABC.sol#L54](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L54)  ## Recommended Mitigation Steps  Use the solidity function `abs` to get the `_reserveDelta` absolute value.  "}, {"title": "The variable `fShareRatio` is vulnerable to manipulation by flash minting and burning", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The variable `fShareRatio` in the function `purchaseMembership` of contract `FSDNetwork` is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).  ## Proof of Concept  The `fShareRatio` is calculated (line 136) by:  ```solidity (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare; ```  where `fsd.getReserveBalance()` can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased `fShareRatio` could affect the function `purchaseMembership` results. For example, the user could purchase the membership even if the `fShareRatio` is < 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of `fShareRatio`.  Referenced code: [FSDNetwork.sol#L134-L142](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L134-L142) [FSDNetwork.sol#L178-L182](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L178-L182)  ## Recommended Mitigation Steps  Force users to wait for (at least) a block to prevent flash minting and burning.  "}, {"title": "Incorrect implementation of arctan in the contract `FairSideFormula`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/73", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The current implementation of the arctan formula in the contract `FairSideFormula` is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function `calculateDeltaOfFSD` and the number of FSD tokens minted or burned.  ## Proof of Concept  The function `_arctan` misses two `abs` on the variable `a`. The correct implementation should be:  ```solidity function _arctan(bytes16 a) private pure returns (bytes16) {     return         a.mul(PI_4).sub(             a.mul(a.abs().sub(ONE)).mul(APPROX_A.add(APPROX_B.mul(a.abs())))         ); } ```  Notice that `_arctan` is called by `arctan`, and `arctan` is called by `arcs` with `ONE.sub(arcInner)` provided as the input parameter. Since `arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)` can be a large number (recall that `x` is the capital pool), it is possible that the parameter `a` is negative.  Referenced code:  [FairSideFormula.sol#L45-L61](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L45-L61) [FairSideFormula.sol#L77-L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L77-L85) [FairSideFormula.sol#L127](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L127) [ABC.sol#L38](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L38)  ## Recommended Mitigation Steps  Modify the `_arctan` function as above.  "}, {"title": "`pendingWithdrawals` not decreased after a `withdraw`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/72", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The variable `pendingWithdrawals` in the contract `Withdrawable` is not decreased after the function `withdraw` is called, which causes the return value of function `getReserveBalance` less than it should be. This bug could cause incorrect results in several critical functions related to FSD token pricing, including `getFSDPrice`, `purchaseMembership`, `getMaximumBenefitPerUser`, `mint`, and `burn` in the `FSDNetwork` and `FSD` contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L14-L19](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L14-L19) [Withdrawable.sol#L26-L28](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L26-L28)  Affected functions: [FSD.sol#L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L85) [FSD.sol#L100](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L100) [FSDNetwork.sol#L136](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L136) [FSDNetwork.sol#L361](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L361) [FSDNetwork.sol#L369](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L369)  ## Recommended Mitigation Steps  Add `pendingWithdrawals = pendingWithdrawals.sub(reserveAmount);` after line 17 in the contract `Withdrawable`.  "}, {"title": "Gas optimization for the `rootPows` function in `FairSideFormula`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/71", "labels": ["bug", "question", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Gas optimization is possible for the current `rootPows` implementation.  ## Proof of Concept  The original implementation of `rootPows` requires 4 `mul` and 2 `sqrt`:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     // fourth root     x = x.sqrt().sqrt();     // to the power of 3     x = _pow3(x);     // we offset the root on the second arg     return (x, x.mul(x)); } ```  However, the calculation process can be simplified to be more gas-efficient than the original with only 1 `mul` and 2 `sqrt` requried:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     bytes16 x1_2 = x.sqrt();     bytes16 x3_2 = x.mul(x1_2);     bytes16 x3_4 = x3_2.sqrt();     return (x3_4, x3_2); } ```  Referenced code: [FairSideFormula.sol#L67-L75](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L67-L75)  ## Recommended Mitigation Steps  To save gas, change the implementation of `rootPows` as mentioned above.  "}, {"title": "Should check return data from Chainlink aggregators", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `getEtherPrice` function in the contract `FSDNetwork` fetches the ETH price from a Chainlink aggregator using the `latestRoundData` function. However, there are no checks on `roundID` nor `timeStamp`, resulting in stale prices.  ## Proof of Concept  Referenced code: [FSDNetwork.sol#L376-L381](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L376-L381)  ## Recommended Mitigation Steps  Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:  ```solidity (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(answeredInRound >= roundID, \"...\"); require(timeStamp != 0, \"...\"); ```  "}, {"title": "Solidity keyword `transfer` is used in the contract `Withdrawable`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `withdraw` in the contract `Withdrawable` uses the Solidity keyword, `transfer`, which is unrecommended since it forwards a fixed amount of 2300 gas to the recipient. The gas cost of opcodes may change during hard forks in the future and thus break the functionalities of existing deployed contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L18](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L18)  Please refer to the following references for more details:  [Solidity issue - Remove .send and .transfer](https://github.com/ethereum/solidity/issues/7455) [Stop Using Solidity's transfer() Now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)   ## Recommended Mitigation Steps  Use `.call{value: 1 ether}(\"\")` instead of `transfer` or `send`. Besides, since the `call` function forwards all gas to the recipient, the contract should add protections (e.g., reentrancy guards) to prevent the recipient from reentering critical functions.  "}, {"title": "Revert messages are wrong", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact The following revert messages refer to a different function instead of the one where they actually are, making harder to understand the flow of the program in case of error. [l. 166](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166) [l. 185](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185) [l. 254](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254)  ## Recommended Mitigation Steps Set the messages with the correct function name.  "}, {"title": "convictionless mapping is not used", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/61", "labels": ["bug", "question", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact convictionless can be set via function setConvictionless, however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like _updateConvictionScore.  ## Recommended Mitigation Steps Either remove this mapping or use it where intended.  "}, {"title": "Gas optimizations - Reduce reads in purchaseMembership method", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The method `purchaseMembership` in `FSDNetwork` contract contains the code below. Inside this method, we are constantly reading from the mapping `membership`, so why not use just one read `Membership userMembership = membership[msg.sender]` and use this instance for everything related to memberships.  Each read we are currently doing has an impact on the gas cost.  ``` function purchaseMembership(uint256 costShareBenefit) external {         require(             costShareBenefit % 10 ether == 0 && costShareBenefit > 0,             \"FSDNetwork::purchaseMembership: Invalid cost share benefit specified\"         );          if (             membership[msg.sender].creation + MEMBERSHIP_DURATION <             block.timestamp         ) {             membership[msg.sender].creation = 0;             membership[msg.sender].availableCostShareBenefits = 0;         }          uint256 totalCostShareBenefit =             membership[msg.sender].availableCostShareBenefits.add(                 costShareBenefit             );         require(             totalCostShareBenefit <= getMaximumBenefitPerUser(),             \"FSDNetwork::purchaseMembership: Exceeds cost share benefit limit per account\"         );          totalCostShareBenefits = totalCostShareBenefits.add(costShareBenefit);          // FSHARE = Total Available Cost Share Benefits / Gearing Factor         uint256 fShare = totalCostShareBenefits / GEARING_FACTOR;         // Floor of 7500 ETH         if (fShare < 7500 ether) fShare = 7500 ether;          // FSHARERatio = Capital Pool / FSHARE (scaled by 1e18)         uint256 fShareRatio =             (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare;          // 1 ether = 100%         require(             fShareRatio >= 1 ether,             \"FSDNetwork::purchaseMembership: Insufficient Capital to Cover Membership\"         );          uint256 membershipFee = costShareBenefit.wmul(MEMBERSHIP_FEE);         uint256 fsdSpotPrice = getFSDPrice();         uint256 fsdFee = membershipFee.wdiv(fsdSpotPrice);          // Automatically locks 65% to the Network by disallowing its retrieval         fsd.safeTransferFrom(msg.sender, address(this), fsdFee);          if (membership[msg.sender].creation == 0) {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;             membership[msg.sender].creation = block.timestamp;             membership[msg.sender].gracePeriod =                 membership[msg.sender].creation +                 MEMBERSHIP_DURATION +                 60 days;         } else {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;              uint256 elapsedDurationPercentage =                 ((block.timestamp - membership[msg.sender].creation) *                     1 ether) / MEMBERSHIP_DURATION;             if (elapsedDurationPercentage < 1 ether) {                 uint256 durationIncrease =                     (costShareBenefit.mul(1 ether) /                         (totalCostShareBenefit - costShareBenefit))                         .mul(MEMBERSHIP_DURATION) / 1 ether;                 membership[msg.sender].creation += durationIncrease;             }         }          uint256 governancePoolRewards =             fsdFee.wmul(GOVERNANCE_FUNDING_POOL_REWARDS);          // Staking Rewards = 20% + [FSHARERatio - 125%] (if FSHARERatio > 125%)         uint256 stakingMultiplier =             fShareRatio >= 1.25 ether                 ? STAKING_REWARDS + fShareRatio - 1.25 ether                 : STAKING_REWARDS;          // Maximum of 75% as we have 15% distributed to governance + funding pool         if (stakingMultiplier > 0.75 ether) stakingMultiplier = 0.75 ether;          uint256 stakingRewards = fsdFee.wmul(stakingMultiplier);          // 20% as staking rewards         fsd.safeTransfer(address(fsd), stakingRewards);         fsd.addRegistrationTribute(stakingRewards);          // 7.5% towards governance         fsd.safeTransfer(address(fsd), governancePoolRewards);         fsd.addRegistrationTributeGovernance(governancePoolRewards);          // 7.5% towards funding pool         fsd.safeTransfer(FUNDING_POOL, governancePoolRewards);     } ```  "}, {"title": "`ERC20ConvictionScore.acquireConviction` implements wrong governance checks", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  There are two issues with the governance checks when acquiring them from an NFT:  #### Missing balance check The governance checks in `_updateConvictionScore` are:  ```solidity !isGovernance[user] && userConvictionScore >= governanceThreshold  && balanceOf(user) >= governanceMinimumBalance; ```  Whereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.  ```solidity else if (     !isGovernance[msg.sender] && userNew >= governanceThreshold ) {     isGovernance[msg.sender] = true; } ```  #### the `wasGovernance` might be outdated  The second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now. The NFT's governance state is blindly appplied to the new user:  ```solidity if (wasGovernance && !isGovernance[msg.sender]) {     isGovernance[msg.sender] = true; } ```  This allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation.  ## Impact It's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and backrunning with a redemption.  ## Recommended Mitigation Steps Add the missing balance check in `acquireConviction`. Remove the `wasGovernance` governance transfer from the NFT and solely recompute it based on the current `governanceThreshold` / `governanceMinimumBalance` settings.   "}, {"title": "`ERC20ConvictionScore` allows transfers to special TOTAL_GOVERNANCE_SCORE address", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors. But any user can directly transfer to this address increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`. It'll first write a snapshot of this address' balance which should be very low:  ```solidity // in _updateConvictionScore _writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta); ```  This address then accumulates a score based on its balance which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.  ## Impact Increasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. (by manipulating `FairSideDAO.totalVotes`). `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Disallow transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.   "}, {"title": "`ERC20ConvictionScore._updateConvictionScore` uses stale credit score for `governanceDelta`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/41", "labels": ["bug", "question", "3 (High Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  The user could increase their conviction / governance score first in the same block and then lose their status in a second transaction, and the total governance conviction score would only be reduced by the previous score.  Example: Block n - 10000: User is a governor and has a credit score of 1000 which was also contributed to the `TOTAL_GOVERNANCE_SCORE` Block n: - User updates their own conviction score using public `updateConvictionScore` function which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total. - User transfers their whole balance away, the balance drops below `governanceMinimumBalance` and user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score) but it's only `1000` because it takes the snapshot of block n - 1.  ## Impact The `TOTAL_GOVERNANCE_SCORE` score can be inflated this way and break the voting mechanism in the worst case as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Use the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`   "}, {"title": "`ERC20ConvictionScore`'s `governanceDelta` should be subtracted when user is not a governor anymore", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.  In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative but it's positive.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  It then gets added to the new total:  ```solidity uint224 totalGCSNew =     add224(         totalGCSOld,         governanceDelta,         \"ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows\"     ); ```  ## Impact The `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data which can then be used for anyone to pass proposals in the worst case. Or `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Return a negative, signed integer for this case and add it to the new total.   "}, {"title": "Wrong error message in `__castOffchainVotes`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The error message states:  ```solidity require(     proposal.offchain,     \"FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain\" ); ```  But it should be \"... meant to be voted onchain\".   "}, {"title": "NFTs can never be redeemed back to their conviction scores leading to lock/loss of funds\u2028", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Besides the conviction scores of users, there appears to be tracking of the FairSide protocol\u2019s tokenized conviction score as a whole (using fscAddress = address(fairSideConviction)). This is evident in the attempted reduction of the protocol\u2019s score when a user acquires conviction back from a NFT. However, the complementary accrual of user's conviction score to fscAddress when user tokenizes their conviction score to mint a NFT is missing in tokenizeConviction().  Because of this missing updation of conviction score to fscAddress on tokenization, there are no checkpoints written for fscAddress and there also doesn\u2019t appear to be any initialization for bootstrapping this address\u2019s conviction score checkpoints. As a result, the sub224() on Line350 of ERC20ConvictionScore.sol will always fail with an underflow because fscOld = 0 (because fscNum = 0) and convictionScore > 0, effectively reverting all calls to acquireConviction().  The impact is that all tokenized NFTs can never be redeemed back to their conviction scores and therefore leads to lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.   ## Proof of Concept  1. Alice tokenizes her conviction score into a NFT. She sells that NFT to Bob who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.   2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on FairSide network. But the call to acquireConviction() fails. Bob is never able to redeem Alice\u2019s NFT and has lost the funds used to buy it.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L343-L355   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add appropriate logic to bootstrap+initialize fscAddress\u2019s tokenized conviction score checkpoints and update it during tokenization.  "}, {"title": "Locked funds from tokenization are credited twice to user leading to protocol fund loss", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/30", "labels": ["bug", "question", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The tokens optionally locked during tokenization are released twice on acquiring conviction back from a NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and also occurs in a different part of the code.)  When a user wants to acquire back the conviction score captured by a NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in _release() (via acquireConviction -> burn) of FairSideConviction.sol and again immediately after the burn on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  This leads to loss of protocol funds.  ## Proof of Concept  Alice tokenizes her conviction score into a NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L123  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L314-L316   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the redundant transfer of FSD tokens from protocol to user on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  "}, {"title": "Conviction totals not updated during tokenization", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  _updateConvictionScore() function returns convictionDelta and governanceDelta which need to be used immediately in a call to _updateConvictionTotals(convictionDelta, governanceDelta) for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.  This updation of totals after a call to _updateConvictionScore() is done on Line70 in _beforeTokenTransfer() and Line367 in updateConvictionScore() of ERC20ConvictionScore.sol.  However, the return values of _updateConvictionScore() are ignored on Line284 in tokenizeConviction() and not used to update the totals using _updateConvictionTotals(convictionDelta, governanceDelta).  The impact is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero which is incorrect and reported separately in a different finding) but the totals are not updated. This leads to incorrect accounting of TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE which are used in the calculation of tributes and therefore will lead to incorrect tribute calculations.  ## Proof of Concept  Alice calls tokenizeConviction() to convert her conviction score into an NFT. Her conviction deltas as returned by _updateConvictionScore() are ignored and TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE values are not updated. As a result, the tributes rewarded are proportionally more than what should have been the case because the conviction score totals are used as the denominator in availableTribute() and availableGovernanceTribute().  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L284  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L108-L110  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L52-L70  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L365-L367  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L73-L106  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L83-L100  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L102-L123   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use the return values of _updateConvictionScore() function (i.e. convictionDelta and governanceDelta) on Line284 of ERC20ConvictionScore.sol and use them in a call to _updateConvictionTotals(convictionDelta, governanceDelta).  "}, {"title": "Conviction scoring fails to initialize and bootstrap", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/26", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Conviction scores for new addresses/users fail to initialize+bootstrap in ERC20ConvictionScore\u2019s _updateConvictionScore() because a new user\u2019s numCheckpoints will be zero and never gets initialized.   This effectively means that FairSide conviction scoring fails to bootstrap at all, leading to failure of the protocol\u2019s pivotal feature.  ## Proof of Concept  When Alice transfers FSD tokens to Bob for the first time, _beforeTokenTransfer(Alice, Bob, 100) is triggered which calls _updateConvictionScore(Bob, 100) on Line55 of ERC20ConvictionScore.sol.   In function _updateConvictionScore(), given that this is the first time Bob is receiving FSD tokens, numCheckpoints[Bob] will be 0 (Line116) which will make ts = 0 (Line120), and Bob\u2019s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes convictionDelta = 0 (Line122) and not let control go past Line129.   This means that a new checkpoint never gets written, i.e. conviction score never gets initialized, for Bob or for any user for that matter.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  FairSide\u2019s adjustment of Compound\u2019s conviction scoring is based on time and so needs an initialization to take place vs. Compound\u2019s implementation. A new checkpoint therefore needs to be created+initialized for a new user during token transfer.  "}, {"title": "Call to swapExactTokensForETH in liquidateDai() will always fail\u2028", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  liquidateDai() calls Uniswap\u2019s swapExactTokensForETH to swap Dai to ETH. This will work if msg.sender, i.e. FSD contract,\u00a0has already given the router an allowance of at least amount on the input token Dai.   Given that there is no prior approval, the call to UniswapV2 router for swapping will fail because msg.sender has not approved UniswapV2 with an allowance for the tokens being attempted to swap.  The impact is that updateCostShareRequest() will fail and revert while working with stablecoin Dai.  ## Proof of Concept  https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L191  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L182-L198  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L323  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L307-L329  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L280  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L297   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add FSD approval to UniswapV2 with an allowance for the tokens being attempted to swap.  "}, {"title": "Incorrect use of _addTribute instead of _addGovernanceTribute", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The addRegistrationTributeGovernance() function is called by the FSD network to update tribute when 7.5% is contributed towards governance as part of purchaseMembership(). However, this function incorrectly calls _addTribute() (as done in addRegistrationTribute) instead of _addGovernanceTribute().  The impact is that governanceTributes never gets updated and the entire tribute accounting logic is rendered incorrect.   ## Proof of Concept  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L140  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L130  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L195  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L30-L48  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L50-L70   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _addGovernanceTribute() instead of _addTribute on L140 of FSD.sol  "}, {"title": "Repetitive storage access", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _addTribute can reuse lastTribute to reduce the numbers of storage access: tributes[totalTributes - 1].amount = add224(...) can be replaced with lastTribute.amount = add224(...) as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function _addGovernanceTribute governanceTributes.  ## Recommended Mitigation Steps lastTribute.amount = add224(...)  "}, {"title": "non existing function returns", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions castVote and  castVoteBySig of FairSideDAO.sol have no \"returns\" parameters, however they do call \"return\" at the end of the function.  This is confusing for the readers of the code.  ## Proof of Concept // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dao/FairSideDAO.sol#L443  function castVote(uint256 proposalId, bool support) public {         return _castVote(msg.sender, proposalId, support);     }   function castVoteBySig( .. ) public {        ...        return _castVote(signatory, proposalId, support);     }  ## Tools Used Editor  ## Recommended Mitigation Steps  Remove the \"return\" statements from castVote and castVoteBySig  "}, {"title": "gracePeriod not increased after membership extension", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function purchaseMembership of FSDNetwork.sol, when the membership is extended then membership[msg.sender].creation is increased, however  membership[msg.sender].gracePeriod is not increased. This might lead to a gracePeriod than is less then expected. It seems logical to also increase the gracePeriod    ## Proof of Concept FSDNetwork.sol // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L171 function purchaseMembership(uint256 costShareBenefit) external {      ...       if (membership[msg.sender].creation == 0) {             ...             membership[msg.sender].creation       = block.timestamp;             membership[msg.sender].gracePeriod =  membership[msg.sender].creation +  MEMBERSHIP_DURATION +  60 days;         } else {           ....           membership[msg.sender].creation += durationIncrease;    }  ## Tools Used Editor  ## Recommended Mitigation Steps Check if gracePeriod has to be increased also.  When that is the case add the logic to do that.  "}, {"title": "Users can avoid paying borrowing interest after the fyToken matures", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  According to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to `Witch` and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.  ## Proof of Concept  1. A user creates a new vault and opens a borrowing position as usual. 2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in `Ladle`), which is his debt multiplied by the rate accrual (line 373). 3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to `Witch` by calling the function `batch` of `Ladle` with the operation `GIVE`. 4. He then calls the function `buy` of `Witch` with the corresponding `vaultId` to buy all his collateral using underlying tokens.  In the last step, the `elapsed` time (line 61) is equal to the current timestamp since the vault is never grabbed by `Witch` before, and thus the auction time of the vault, `cauldron.auctions(vaultId)`, is 0 (the default mapping value). Therefore, the collateral is sold at a price of `balances_.art/balances_.ink` (line 74). The user can buy `balances_.ink` amount of collateral using `balances_.art` but not paying for borrowing fees.  Referenced code: [Ladle.sol#L350](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L350) [Ladle.sol#L368-L377](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L368-L377) [Ladle.sol#L267-L272](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L267-L272) [Cauldron.sol#L234-L252](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L234-L252) [Witch.sol#L61](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L61) [Witch.sol#L74](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L74)  ## Recommended Mitigation Steps  Do not allow users to `give` vaults to `Witch`. To be more careful, require `vaultOwners[vaultId]` and `cauldron.auctions(vaultId)` to be non-zero at the beginning of function `buy`.  "}, {"title": "Possible DoS attack when creating `Joins` in `Wand`", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  It is possible for an attacker to intendedly create a fake `Join` corresponding to a specific token beforehand to make `Wand` unable to deploy the actual `Join`, causing a DoS attack.  ## Proof of Concept  The address of `Join` corresponding to an underlying `asset` is determined as follows and thus unique:  ```solidity Join join = new Join{salt: keccak256(abi.encodePacked(asset))}(); ```  Besides, the function `createJoin` in the contract `JoinFactory` is permissionless: Anyone can create the `Join` corresponding to the `asset`. An attacker could then deploy a large number of `Joins` with different common underlying assets (e.g., DAI, USDC, ETH) before the `Wand` deploying them. The attempt of deploying these `Joins` by `Wand` would fail since the attacker had occupied the desired addresses with fake `Joins`, resulting in a DoS attack.  Moreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function `addAsset` of `Wand` and front-runs them to create the corresponding `Join` to make the benign transaction fail.  Referenced code: [JoinFactory.sol#L64-L75](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75) [Wand.sol#L53](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)  ## Recommended Mitigation Steps  Enable access control in `createJoin` (e.g., adding the `auth` modifier) and allow `Wand` to call it.  "}, {"title": "Unnecessary `unchecked` keyword is used in `FYToken`", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  At line 172 in the contract `FYToken`, the `unchecked` keyword is unnecessary since no arithmetic operation is involved.  ## Proof of Concept  Referenced code: [FYToken.sol#L172](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L172)  ## Recommended Mitigation Steps  Consider removing the `unchecked` keyword.  "}, {"title": "In method _update on Pool.sol - Divide before multiply", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  In the Pool.sol contract there is the following code:  ``` function _update(         uint128 baseBalance,         uint128 fyBalance,         uint112 _baseCached,         uint112 _fyTokenCached     ) private {         ....              cumulativeBalancesRatio +=                 (scaledFYTokenCached / _baseCached) *                 timeElapsed;         ....     } ```  The multiplication should be always placed at the end to avoid miscalculations like the following one:  ```   a = (b/d)*c   0 = (5/10)*2      a = (b * c)/ 2   1 = (5 * 2)/10  ```      "}, {"title": "Gas optimizations - using external over public ", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact The following methods could be external instead of public  ``` level(bytes12) should be declared external:         - Cauldron.level(bytes12) (contracts/Cauldron.sol#513-521) mature(bytes6) should be declared external:         - Cauldron.mature(bytes6) (contracts/Cauldron.sol#524-532) accrual(bytes6) should be declared external:         - Cauldron.accrual(bytes6) (contracts/Cauldron.sol#546-553) setFlashFeeFactor(uint256) should be declared external:         - Join.setFlashFeeFactor(uint256) (contracts/Join.sol#33-36) maxFlashLoan(address) should be declared external:         - Join.maxFlashLoan(address) (contracts/Join.sol#90-97) flashFee(address,uint256) should be declared external:         - Join.flashFee(address,uint256) (contracts/Join.sol#105-113) flashLoan(IERC3156FlashBorrower,address,uint256,bytes) should be declared external:         - Join.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (contracts/Join.sol#132-151) setFee(uint256) should be declared external:         - Ladle.setFee(uint256) (contracts/Ladle.sol#102-105) addAsset(bytes6,address) should be declared external:         - Wand.addAsset(bytes6,address) (contracts/Wand.sol#49-61) makeBase(bytes6,IMultiOracleGov,address,address) should be declared external:         - Wand.makeBase(bytes6,IMultiOracleGov,address,address) (contracts/Wand.sol#65-78) makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) should be declared external:         - Wand.makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) (contracts/Wand.sol#81-94) addSeries(bytes6,bytes6,uint32,bytes6[],string,string) should be declared external:         - Wand.addSeries(bytes6,bytes6,uint32,bytes6[],string,string) (contracts/Wand.sol#98-154) setAuctionTime(uint128) should be declared external:         - Witch.setAuctionTime(uint128) (contracts/Witch.sol#41-44) setInitialProportion(uint128) should be declared external:         - Witch.setInitialProportion(uint128) (contracts/Witch.sol#47-51) grab(bytes12) should be declared external:         - Witch.grab(bytes12) (contracts/Witch.sol#54-59) buy(bytes12,uint128,uint128) should be declared external:         - Witch.buy(bytes12,uint128,uint128) (contracts/Witch.sol#62-99) mint(address,uint256) should be declared external:         - DAIMock.mint(address,uint256) (contracts/mocks/DAIMock.sol#36-38) mint(address,uint256) should be declared external:         - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#11-13) mint(address,uint256) should be declared external:         - RestrictedERC20Mock.mint(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#12-14) burn(address,uint256) should be declared external:         - RestrictedERC20Mock.burn(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#17-19) pull(address,uint256) should be declared external:         - GemJoinMock.pull(address,uint256) (contracts/mocks/TLMMock.sol#14-16) mint(address,uint256) should be declared external:         - USDCMock.mint(address,uint256) (contracts/mocks/USDCMock.sol#13-15) withdraw(uint256) should be declared external:         - WETH9Mock.withdraw(uint256) (contracts/mocks/WETH9Mock.sol#21-26) totalSupply() should be declared external:         - WETH9Mock.totalSupply() (contracts/mocks/WETH9Mock.sol#28-30) latestRoundData() should be declared external:         - ChainlinkAggregatorV3Mock.latestRoundData() (contracts/mocks/oracles/chainlink/ChainlinkAggregatorV3Mock.sol#22-34) exchangeRateCurrent() should be declared external:         - CTokenChiMock.exchangeRateCurrent() (contracts/mocks/oracles/compound/CTokenChiMock.sol#12-14) tickSpacing() should be declared external:         - UniswapV3PoolMock.tickSpacing() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#27-29) maxLiquidityPerTick() should be declared external:         - UniswapV3PoolMock.maxLiquidityPerTick() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#31-33) setSources(bytes6[],bytes6[],address[]) should be declared external:         - ChainlinkMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#56-68) peek(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#105-113)         - CompoundMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#78-86)         - UniswapV3Oracle.peek(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#126-132) get(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#119-127)         - CompoundMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#92-100)         - UniswapV3Oracle.get(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#138-144) setSources(bytes6[],bytes6[],address[]) should be declared external:         - CompoundMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/compound/CompoundMultiOracle.sol#37-48) setSecondsAgo(uint32) should be declared external:         - UniswapV3Oracle.setSecondsAgo(uint32) (contracts/oracles/uniswap/UniswapV3Oracle.sol#44-48) setSources(bytes6[],bytes6[],address[]) should be declared external:         - UniswapV3Oracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/uniswap/UniswapV3Oracle.sol#73-85) transferOwnership(address) should be declared external:         - Ownable.transferOwnership(address) (contracts/utils/access/Ownable.sol#25-28) tokenSymbol(address) should be declared external:         - SafeERC20Namer.tokenSymbol(address) (contracts/utils/token/SafeERC20Namer.sol#87-95) tokenName(address) should be declared external:         - SafeERC20Namer.tokenName(address) (contracts/utils/token/SafeERC20Namer.sol#98-106) setParameter(bytes32,int128) should be declared external:         - Pool.setParameter(bytes32,int128) (contracts/yieldspace/Pool.sol#135-141) getK() should be declared external:         - Pool.getK() (contracts/yieldspace/Pool.sol#144-147) getG1() should be declared external:         - Pool.getG1() (contracts/yieldspace/Pool.sol#150-152) getG2() should be declared external:         - Pool.getG2() (contracts/yieldspace/Pool.sol#155-157) getCache() should be declared external:         - Pool.getCache() (contracts/yieldspace/Pool.sol#175-185) fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#657-694) baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#707-744) fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#757-797) baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#811-848) ```  Here more information about the gas optimizations of external vs public: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tools Used  Slither   "}, {"title": "function build could explicitly check that seriesId is not 0", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It would be helpful if function build explicitly check that seriesId != bytes12(0). In practice, it is not possible to have a series with an id of 0, so this check will not pass:     require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\"); however, the error message is not very informative, thus I am suggesting adding an explicit check.  ## Recommended Mitigation Steps require (seriesId != bytes12(0), \"Series id is zero\");  "}, {"title": "function redeem should return 'redeemed' amount", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function redeem in contract FYToken should return 'redeemed' amount. There return value is not used anywhere, but it's a mistake that it assigns 'redeemed' but returns 'amount'.  ## Recommended Mitigation Steps Remove return sentence or explicitly return 'redeemed'.  "}, {"title": "external function transferToPool is pretty useless", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact external function transferToPool is pretty useless and error-prone. It relies on the user not to leave these tokens in a separate tx, otherwise, it will just be feeding the bots. To use it directly users will have to write their own custom smart contract and chain actions.  ## Recommended Mitigation Steps It would be better to remove this function and leave the only way to invoke it via a batch function.  "}, {"title": "unnecessary store", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function batch of Ladle.sol, at the operation GIVE, the value of vault is stored and is deleted directly afterwards. So storing is unnecessary. Maybe the solidity compiler already optimizes this.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L228   function batch( } else if (operation == Operation.GIVE) {                ...                  vault = _give(vaultId, to);                 delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore              ## Tools Used  ## Recommended Mitigation Steps Remove the \" vault = \"   "}, {"title": "Multiple compiler versions allowing a wide range from 0.5.0 to >=0.8.0", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Project uses multiple compiler versions with most specifying ^0.8.0, some specifying >=0.8.0 which allows breaking versions >= 0.9.0 in future if reused/redeployed, and some even allowing much older >= 0.5.0/0.6.0.   The dangers of allowing multiple compilers across breaking revisions is that the security bug fixes and features might be different across different contracts introducing vulnerabilities or giving a false sense of security.  For example, most contract use ^0.8.0 which means they have default checked arithmetic to prevent overflows/underflows without using OZ SafeMath. This doesn\u2019t apply to the few (inherited) contracts that may be compiled with <0.8.0 and have unchecked overflows/underflows.   ## Proof of Concept  ^0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L2  >= 0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/YieldMath.sol#L2  >= 0.5.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/SafeERC20Namer.sol#L3  >= 0.6.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/TransferHelper.sol#L4  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Update all contracts to use pragma solidity ^0.8.0 or better a fixed version like 0.8.4 2. Deploy with the same compiler version which was used for testing  "}, {"title": "flashFeeFactor is uninitialized at declaration leading to zero-fee flash loans enabled by default\u2028", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  flashFeeFactor is uninitialized at declaration and so zero initially until set by setFlashFeeFactor(). As indicated in one of the the explainer videos, the idea is to set this by default to uint256.max to disable flash loans by default.  Currently, flash loans are enabled by default with a zero flash fee unless changed by setFlashFeeFactor().  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L26  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L32-L39  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L107-L110  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L117-L119  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L132   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize at declaration with a reasonable value which could be uint256.max to disable flash loans by default.  "}, {"title": "Prevent the use of LOCK in setRoleAdmin to instead force the use of lockRole", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The LOCK role is special in AccessControl because it has itself as the admin role (like ROOT) but no members. This means that calling setRoleAdmin(msg.sig, LOCK) means no one can grant/revoke that msg.sig role anymore and it gets locked irreversibly. This means it disables admin-based permissioning management of that role and therefore is very powerful in its impact.  Given this, there is a special function lockRole() which is specifically meant to enforce LOCK as the admin for the specified role parameter. For all other role admin creations, the generic setRoleAdmin() may be used. However, setRoleAdmin() does not itself prevent specifying the use of LOCK as the admin. If this is accidentally used then it leads to disabling that role\u2019s admin management irreversibly similar to the lockRole() function.  It is safer to force admins to use lockRole() as the only way to set admin to LOCK and prevent the use of LOCK as the adminRole parameter in setRoleAdmin(), because doing so will make the intention of the caller clearer as lockRole() clearly has that functionality specified in its name and that\u2019s the only thing it does.   ## Proof of Concept  Alice who is the admin for foo() wants to give the admin rights to Bob (0xFFFFFFF0) but instead of calling setRoleAdmin(foo.sig, 0xFFFFFFF0), she calls setRoleAdmin(foo.sig, 0xFFFFFFFF) where 0xFFFFFFFF is LOCK. This makes LOCK as the admin for foo() and prevents any further admin-based access control management for foo().  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L48  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L129-L131  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L235-L240  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L165-L176  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Prevent the use of LOCK as the adminRole parameter in setRoleAdmin().  "}, {"title": "Missing sender address check in receive() may lead to locked Ether", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Add an address check in receive() of Ladle.sol to ensure the only address sending ETH being received in receive() is the Weth9 contract (similar to the check in PoolRouter.sol) for Ether withdrawal in _exitEther().  This will prevent stray Ether from being sent accidentally to this contract and getting locked.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L521-L522  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/PoolRouter.sol#L145-L148   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an address check in receive() of Ladle.sol to ensure only Weth9 contract can send Ether to this contract.  "}, {"title": "Return values of batch operations are ignored", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Many batched operation functions return values but these are ignored by the caller batch(). While this may be acceptable for the front-end which picks up any state changes from such functions via emitted events, integrating protocols that make a call to batch() may require it to package and send back return values of all operations from the batch to react on-chain to the success/failure or other return values from such calls. Otherwise, they will be in the dark on the success/impact of batched operations they\u2019ve triggered.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L120-L245  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L250  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L258  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L284-L286  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L296-L298  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L326-L328  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L342-L344  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L382-L384  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L396-L398  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L410-L412  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L446-L448  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L462-L464  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L527-L529  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L539-L541  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L559-L561  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L588-L590  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Package and send back return values of all batched operations\u2019 functions to the caller of batch().  "}, {"title": "Uninitialized or Incorrectly set auctionInterval may lead to liquidation engine livelock", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an auctionInterval threshold to give a reasonable window to a liquidation engine that has grabbed the vault.  The grab() function has a comment on Line 354: \u201c// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\u201d indicating a requirement of the auctionInterval being equal to one day. This can happen only if the auctionInterval is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on setAuctionInterval() being called with the appropriate auctionInterval_ value which is also not validated.  Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize auctionInterval at declaration to a safe default value instead of the current 0 which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact entire protocol\u2019s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.   ## Proof of Concept  Configuration recipe forgets to set the auctionInterval state variable by calling setAuctionInterval() and inadvertently leaves it at the default value of 0. Alternatively, it calls it but with a lower than intended/reasonable auction interval value. Both scenarios fail to give sufficient protection to liquidation engines from having their grabbed vaults re-grabbed without sufficient time for liquidation auctions.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L63  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L108-L115  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L354   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Initialize auctionInterval  at declaration with a reasonable default value. 2. Add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  "}, {"title": "Potential griefing with DoS by front-running vault creation with same vaultID", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The vaultID for a new vault being built is required to be specified by the user building a vault via the build() function (instead of being assigned by the Cauldron/protocol). An attacker can observe a build() as part of a batch transaction in the mempool, identify the vaultID being requested and front-run that by constructing a malicious batch transaction with only the build operation with that same vaultID. The protocol would create a vault with that vaultID and assign attacker as its owner. More importantly, the valid batch transaction in the mempool which was front-run will later fail to create its vault because that vaultID already exists, as per the check on Line180 of Cauldron.sol. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed vaultID.  While the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol\u2019s real users by preventing them from opening a vault and interacting with the protocol in any manner.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol\u2019s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.  ## Proof of Concept  Alice uses Yield\u2019s front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the vaultID of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice\u2019s vaultID. She uses a higher gas price to front-run Alice\u2019s transaction and get\u2019s the protocol to assign that vaultID to herself. Alice\u2019s batch transaction later fails because the vaultID she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L180  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L173-L190  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L133-L135  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L249-L255   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Mitigate this DoS vector by having the Cauldron assign the vauldID instead of user specifying it in the build() operation. This would likely require the build() to be a separate non-batch transaction followed by other operations that use the vaultID assigned in build(). Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in Ladle.  Alternatively, consider adding validation logic in Ladle\u2019s batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol\u2019s operations per valid recipes, which could be an attacker\u2019s signature pattern.  "}, {"title": "Missing checks on debt max/min limits could cause pour to revert", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  setDebtLimits() is used to set the maximum and minimum debt for an underlying and ilk pair. The assumption is that max will be greater than min while setting them because otherwise the debt checks in _pour() for line/dust will fail and revert.  While max and min debt limits can be reset, it is safer to perform input validation on them in setDebtLimits().  ## Proof of Concept  A recipe incorrectly interchanges the values of min and max debt which leads to exceptions in pouring into the vaults.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L91-L92  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L319-L322  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Wand.sol#L79   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a check to ensure max > mix.  "}, {"title": "UniswapV3Oracle function _peek is public", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In contract UniswapV3Oracle function _peek has visibility of public while the name and similar functions in other oracles are declared as private.  ## Recommended Mitigation Steps give _peek private visibility.  "}, {"title": "no need for transferToPool to be payable", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function transferToPool is marked as 'payable'. It only transfers ERC20 tokens, no Ether, so there is no need in having 'payable' here.  ## Recommended Mitigation Steps Remove 'payable' modifier from function transferToPool.  "}, {"title": "_burnInternal always returns 0 for fy tokens returned", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function _burnInternal always returns 0 as a third parameter. It should return tokensBurnt, tokenOut, fyTokenOut.  ## Recommended Mitigation Steps return (tokensBurned, tokenOut, fyTokenOut);  "}, {"title": "Unsafe call to `.decimals`", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`. This function was optional in the initial ERC-20 and might fail for old tokens that therefore did not implement it.  ## Impact FyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.  ## Recommended Mitigation Steps Consider using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.  "}, {"title": "Undercollateralized vaults' owner can be overwritten", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/30", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The witch can `Witch.grab` vaults and the `vaultOwners[vaultId]` field is set to the original owner. However, when the auction time is over and the debt has not been fully paid back, the original owner is not restored, and the witch can grab the same vault again, overwriting the original owner `vaultOwners[vaultId]` field permanently with the witch.  ```solidity function grab(bytes12 vaultId) public {     DataTypes.Vault memory vault = cauldron.vaults(vaultId);     vaultOwners[vaultId] = vault.owner;     cauldron.grab(vaultId, address(this)); } ```  Even a full repayment will not restore the original vault owner anymore.  ## Impact No funds will be stuck as the vault can still be correctly liquidated (calling `settle`). However, the vault owner will not be restored which is bad if it is a valuable vaultId (low number) that has a special meaning or would be used as an NFT/for retroactive airdrops for initial liquidity providers down the road.  ## Recommended Mitigation Steps When grabbing check if `vaultOwners[vaultId]` is already the witch and in that case just do an early return of the function - not overwriting the `vaultOwners[vaultId]` field.   "}, {"title": "Implicit unsafe math", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  `Ladle._close` (and many other occurrences) reverts the transaction on certain signed inputs that are negated and cast to unsigned integers.  ```solidity // Ladle._close calling it with art or ink as type(int128).min will crash uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art)); ilkJoin.exit(to, uint128(-ink))  // explanation int128 art = type(int128).min; // -2^127 uint128 amt = uint128(-art); // this fails as -art=--2^127=2^127 cannot be represented in int128 ```  Other places: - `CauldronMath.add` - `Ladle._pour` - everywhere where `-int*` is used  ## Impact One cannot use the actual `type(int128).min` value for function parameters.  ## Recommended Mitigation Steps Revert with a meaningful error message as is done in the `/math/Cast*` functions.   "}, {"title": "enum TokenType is never used", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/21", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact enum TokenType in library PoolDataTypes is not used anywhere.  ## Recommended Mitigation Steps Either remove it or use it where intended.  "}, {"title": "Useless 'auth' modifier in setSources", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setSources in Oracle contracts does not need 'auth' modifier as it will be checked anyway in function setSource. This does not impact the security, it is just a useless check that can be removed.  ## Recommended Mitigation Steps Remove 'auth' modifer from function setSources.  "}, {"title": "'peek' and 'get' are identical (non-transactional)", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In the contract ChainlinkMultiOracle both functions 'peek' and 'get' are identical. They are declared as views while based on IOracle interface 'get' should be transactional.   "}, {"title": "Duplication of Balance", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/16", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xsomeone   # Vulnerability details  ## Impact  It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system minting units out of thin air.  ## Proof of Concept  The `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.  This allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.  Code Referenced: https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L268-L295  ## Tools Used  Manual Review.  ## Recommended Mitigation Steps  A `require` check should be imposed that prohibits the `from` and `to` variables to be equivalent.  "}, {"title": "Avoid assembly in getRevertMsg ", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getRevertMsg of RevertMsgExtractor.sol uses assembly to retrieve revert information. The latest solidity version have new functions that allows you to retrieve information without assembly.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/RevertMsgExtractor.sol function getRevertMsg(bytes memory returnData) internal pure returns (string memory) { ..        assembly {             // Slice the sighash.             returnData := add(returnData, 0x04)         }   ## Tools Used  ## Recommended Mitigation Steps Below is a piece of code showing the new functionality:  pragma solidity ^0.8.1;  contract ContractError {     function Underflow() public pure returns (uint) {          uint x = 0;          x--; // this will generate an underflow          return x;     }     function UncheckedUnderflow() public pure returns (uint) {          uint x = 0;          unchecked { x--; } // this will generate an underflow          return x;     }  }  contract C {     ContractError e = new ContractError();          function TestUnderflow() public view returns (string memory) {          try e.Underflow() returns (uint) {             return \"Ok\";         } catch Error(string memory reason) {             return reason;         } catch Panic(uint _code) {             if (_code == 0x01) { return \"Assertion failed\"; }             else if (_code == 0x11) { return \"Underflow/overflow\"; }             // We ignore the other errors.             return \"Other Panic\";         } catch (bytes memory reason) {              uint x=0;             for (uint i=0;i<4;i++) //get first 4 bytes                 x = (x<<8) + uint(uint8(reason[i]));                      if (x == 0x08c379a0) // abi.encodeWithSignature(\"Error(string)\")                 return \"Error\";             return \"Unknown\";         }     } }   "}, {"title": "PoolFactory and JoinFactory very similar", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact PoolFactory and JoinFactory contain very similar but also relatively complicated code. // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/PoolFactory.sol // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol  The risk is that future changes/improvements in one contract might not be updated in the other.  ## Proof of Concept  ## Tools Used Editor  ## Recommended Mitigation Steps Consider refactoring the code where the core code is put in a library and reused from both of the contracts.   "}, {"title": "Constants \"chi\" and \"rate\"", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several implementations of the value of \"chi\" and \"rate\" are used, sometimes as constant and sometimes the direct value is used, see proof of concept below. The risk is that if it is changed in one place if might not be changed in another place, leading to bugs.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L26 bytes6 public constant CHI = \"chi\"; bytes6 public constant RATE = \"rate\";  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L27 bytes32 constant CHI = \"chi\";  //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L40     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {       ...         if (kind == \"rate\") rawPrice = CTokenInterface(source).borrowIndex();         else if (kind == \"chi\") rawPrice = CTokenInterface(source).exchangeRateStored();  ## Tools Used grep  ## Recommended Mitigation Steps Define the constants for \"chi\" and \"rate\" on one location and include this where required.   "}, {"title": "Several todos left in the code", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The code still has some todos, which should be resolved before production  ## Proof of Concept Ladle.sol:        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo` Ladle.sol:        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo` Wand.sol:        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well Wand.sol:        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs Wand.sol:            name,     // Derive from base and maturity, perhaps Wand.sol:            symbol    // Derive from base and maturity, perhaps  ## Tools Used Grep  ## Recommended Mitigation Steps Check and fix or remove the todos   "}, {"title": "Witch can't give back vault after 2x grab", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The witch.sol contract gets access to a vault via the grab function, in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.  After the second grab, the information of the original owner of the vault is lost and the vault can't be returned to the original owner once the debt has been sold.  The grab function stores the previous owner in vaultOwners[vaultId] and then the contract itself is the new owner (via cauldron.grab and cauldron._give). The vaultOwners[vaultId] is overwritten at the second grab  The function buy of Witch.sol tried to give the vault back to the original owner, which won't succeed after a second grab.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L50     function grab(bytes12 vaultId) public {         DataTypes.Vault memory vault = cauldron.vaults(vaultId);         vaultOwners[vaultId] = vault.owner;         cauldron.grab(vaultId, address(this));     }  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349     function grab(bytes12 vaultId, address receiver)  external  auth   {      ...         _give(vaultId, receiver);       // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349  function _give(bytes12 vaultId, address receiver) internal returns(DataTypes.Vault memory vault)  {     ...         vault.owner = receiver;         vaults[vaultId] = vault;  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L57  function buy(bytes12 vaultId, uint128 art, uint128 min) public {      ....             cauldron.give(vaultId, vaultOwners[vaultId]);  ## Tools Used Editor  ## Recommended Mitigation Steps Assuming it's useful to give back to vault to the original owner: Make a stack/array of previous owners if multiple instances of the witch.sol contract would be used. Or check if the witch is already the owner (in the grab function) and keep the vaultOwners[vaultId] if that is the case  "}, {"title": "auth only works well with external functions", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The auth modifier of AccessControl.sol doesn't work as you would expect.  It checks if you are authorized for \"msg.sig\", however msg.sig is the signature of the first function you have called, not of the current function. So if you call function A, which calls function B, the \"auth\" modifier of function B checks if you are authorized for function A!  There is a difference between external an public functions. For external functions this works as expected because a fresh call (with a new msg.sig) is always made. However with a public functions, which are called from within the same contract, this doesn't happen and the problem described above occurs. See in the proof of concept for a piece of code which shows the problem. In the code there are several functions which have public and auth combined, see also in the proof of concept .  In the current codebase I couldn't find a problem situation, however this could be accidentally introduced with future changes. If could also be introduced via the _moduleCall of Ladle.sol, which allows functions to be defined which might call the public functions.  ## Proof of Concept ### auth // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/access/AccessControl.sol#L90 modifier auth() {         require (_hasRole(msg.sig, msg.sender), \"Access denied\");         _;     }  ### example pragma solidity ^0.8.0; contract TestMsgSig {      event log(bytes4);      function setFeePublic(uint256) public  {          emit log(this.setFeePublic.selector);          emit log(msg.sig);     }     function setFeeExternal(uint256) external  {          emit log(this.setFeeExternal.selector);          emit log(msg.sig);     }      function TestPublic() public {         setFeePublic(2);     }      function TestExternal() public {        this.setFeeExternal(2);     } } ### occurrences of public auth Wand.sol:   function addAsset(bytes6 assetId,address asset) public auth { Wand.sol:    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth { Wand.sol:    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth { Wand.sol:     function addSeries(...  ) public auth { Witch.sol:    function setAuctionTime(uint128 auctionTime_) public auth { Witch.sol:    function setInitialProportion(uint128 initialProportion_) public auth {  Ladle.sol:     function setFee(uint256 fee)         public        auth      Join.sol:    function setFlashFeeFactor(uint256 flashFeeFactor_) public   auth     {  oracles\\chainlink\\ChainlinkMultiOracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\\chainlink\\ChainlinkMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { oracles\\compound\\CompoundMultiOracle.sol:    function setSource(bytes6 base, bytes6 kind, address source) public auth { oracles\\compound\\CompoundMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) public auth { oracles\\uniswap\\UniswapV3Oracle.sol:    function setSecondsAgo(uint32 secondsAgo_) public auth { oracles\\uniswap\\UniswapV3Oracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\\uniswap\\UniswapV3Oracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { fytoken.sol:  function setOracle(IOracle oracle_)  public  auth     {   ## Tools Used grep  ## Recommended Mitigation Steps make sure all auth functions use external  (still error prone) or change the modifier to something like:     modifier auth(bytes4 fs) {         require (msg.sig == fs,\"Wrong selector\");         require (_hasRole(msg.sig, msg.sender), \"Access denied\");         _;     }      function setFee(uint256) public auth(this.setFee.selector) {        .....     }    "}, {"title": "Use constants for numbers", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In several locations in the code numbers like 1e12, 1e18, 1e27 are used. The same goes for values like: type(uint256).max It quite easy to make a mistake somewhere, also when comparing values.  ## Proof of Concept .\\Cauldron.sol:        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18); .\\Cauldron.sol:            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18); .\\Cauldron.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\\Cauldron.sol:        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals .\\FYToken.sol:        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18); .\\FYToken.sol:            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18); .\\FYToken.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\\Witch.sol:        require (initialProportion_ <= 1e18, \"Only at or under 100%\"); .\\Witch.sol:            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2)); .\\Witch.sol:            price = uint256(1e18).wdiv(term1.wmul(term2)); .\\oracles\\chainlink\\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\\oracles\\chainlink\\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\\oracles\\compound\\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\\oracles\\compound\\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\\yieldspace\\Pool.sol:            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27; .\\yieldspace\\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\\yieldspace\\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\\yieldspace\\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max .\\yieldspace\\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max  .\\FYToken.sol:    uint256 public chiAtMaturity = type(uint256).max;           // Spot price (exchange rate) between the base and an interest accruing token at maturity .\\FYToken.sol:        require (chiAtMaturity == type(uint256).max, \"Already matured\"); .\\FYToken.sol:        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.    ## Tools Used grep  ## Recommended Mitigation Steps Define constants for the numbers used throughout the code.   "}, {"title": "YieldMath.sol / Log2: >= or > ?", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The V1 version of YieldMath.sol contains \">=\" (larger or equal), while the V2 version of YieldMath.sol containt \">\" (larger) in the log_2 function. This change doesn't seem logical and might lead to miss calculations. The difference is present in a number of adjacent lines.  ## Proof of Concept // https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol#L217 function log_2 (uint128 x) ... b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}   //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/YieldMath.sol#L58 function log_2(uint128 x) ... b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}  ## Tools Used diff  ## Recommended Mitigation Steps Check which version is the correct version and fix the incorrect version.    "}, {"title": "Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/171", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.  ## Proof of Concept  The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.  Referenced code: [RCTreasury.sol#L642-L653](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L642-L653) [RCTreasury.sol#L669](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L669) [RCTreasury.sol#L672](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L672) [RCTreasury.sol#L678](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L678) [RCOrderbook.sol#L553-L557](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L553-L557)  ## Recommended Mitigation Steps  Change `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.  "}, {"title": "The `domainSeperator` is not recalculated after a hard fork happens", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/166", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-realitycards-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The variable `domainSeperator` in `EIP712Base` is cached in the contract storage and will not change after the contract is initialized. However, if a hard fork happens after the contract deployment, the `domainSeperator` would become invalid on one of the forked chains due to the `block.chainid` has changed.  ## Proof of Concept  Referenced code: [EIP712Base.sol#L25-L44](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/lib/EIP712Base.sol#L25-L44)  ## Recommended Mitigation Steps  Consider using the [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol) from OpenZeppelin, which recalculates the domain separator if the current `block.chainid` is not the cached chain ID.  "}, {"title": "Use Mode instead of uint in RCFactory to make code much more readable", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  On `RCFactory` is using uint to represent the enum Mode while on RCMarket is using the enum directly.  It would make the code much readable if RCFactory would use Mode directly.   "}, {"title": "Gas optimizations - Remove isMarket from RCMarket", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  `RCMarket` contains the constant variable `isMarket` to indicate it is a Market `bool public constant override isMarket = true;`. This is after used in `RCFactory` ``` function changeMarketApproval(address _market) external onlyGovernors {         require(_market != address(0));         // check it's an RC contract         IRCMarket _marketToApprove = IRCMarket(_market);         assert(_marketToApprove.isMarket());         isMarketApproved[_market] = !isMarketApproved[_market];         emit LogMarketApproved(_market, isMarketApproved[_market]);     } ```  Why not use `mappingOfMarkets` to verify the address is a Market? This would reduce the state space used.  "}, {"title": "`RCNftHubL2.safeTransferFrom` not accoring to spec", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:  > When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)  This check is not implemented, it just drops the `_data` argument.  ## Impact  Contracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.  ## Recommended Mitigation Steps  Implement the `IERC721Receiver` check in `safeTransferFrom`.   "}, {"title": "Dangerous toggle functions", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/157", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Usually one tries to avoid toggle functions in blockchains, because it could be that you think that the first transaction you sent was not correctly submitted (but it's just pending for a long time), or you might even be unaware that it was already sent if multiple roles can set it (like with `changeMarketApproval` / `onlyGovernors`) or if it's an msig. This results in potentially double-toggling the state, i.e, it is set to the initial value again.  Some example functions: `changeMarketCreationGovernorsOnly`, `changeMarketApproval`, and the ones that follow.  ## Impact  The outcome of toggle functions is hard to predict on blockchains due to the very async nature and lack of information about pending transactions.  ## Recommended Mitigation Steps  Use functions that accept a specific value as a parameter instead.  "}, {"title": "uberOwner cannot do all the things an owner can", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/156", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `uberOwner` cannot do the same things the owner can. They can \"only\" set the reference contract for the market.  The same ideas apply to `Treasury` and `Factory`'s `uberOwner`.  ## Impact  The name is misleading as it sounds like the uber-owner is more powerful than the owner.  ## Recommended Mitigation Steps  Uberowner should at least be able to set the owner if not be allowed to call all functions that an `owner` can. Alternatively, rename the `uberOwner`.  "}, {"title": "Unbounded iteration on _cardAffiliateAddresses", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/154", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `Factory.createMarket` iterates over all `_cardAffiliateAddresses`.  ## Impact  The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.   ## Recommended Mitigation Steps  Perform a `_cardAffiliateAddresses.length == 0 || _cardAffiliateAddresses.length == tokenUris.length` check in `createMarket` instead of silently skipping card affiliate cuts in `Market.initialize`. This would restrict the `_cardAffiliateAddresses` length to the `nftMintingLimit` as well.  "}, {"title": "Market-specific pause is not checked for sponsor", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The treasury only checks its `globalPause` field but does not check its market-specific `marketPaused` field for `Treasury.sponsor`. A paused market contract can therefore still deposit as a sponsor using `Market.sponsor`  ## Impact  The market-specific pause does not work correctly.  ## Recommended Mitigation Steps  Add checks for `marketPaused` in the Treasury for `sponsor`.   "}, {"title": "Gas optimizations - Duplicated state variable ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact On `RCOrderbook`, there are duplicated the state variable `treasuryAddress` and `treasury`  ```     address public treasuryAddress;     IRCTreasury public treasury; ``` ```     constructor(address _factoryAddress, address _treasuryAddress) {         factoryAddress = _factoryAddress;         treasuryAddress = _treasuryAddress;         treasury = IRCTreasury(treasuryAddress);         uberOwner = msgSender();     }  ```  "}, {"title": "totalNftMintCount can be replaced with ERC721 totalSupply()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I can't find a reason why totalNftMintCount in Factory can't be replaced with ERC721 totalSupply() to make it less error-prone. As nfthub.mint issues a new token it should automatically increment totalSupply and this assignment won't be needed:       totalNftMintCount = totalNftMintCount + _tokenURIs.length; Also in function setNftHubAddress you need to manually set _newNftMintCount if you want to change nfthub so an invalid value may crash the system. totalSupply() will eliminate totalNftMintCount and make the system more robust.  ## Recommended Mitigation Steps Replace totalNftMintCount with nfthub totalSupply() in Factory contract.  "}, {"title": "Shadowing Local Variables found in RCOrderbook.sol", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact 1 - Low Risk    - Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  ## Proof of Concept  According to the Slither-analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing), shadowing local variables is naming conventions found in two or more variables that are similar. Although they do not pose any immediate risk to the contract, incorrect usage of the variables is possible and can cause serious issues if the developer does not pay close attention.   It is recommended that the naming of the following variables should be changed slightly to avoid any confusion:   -------------------------------------------------------------------  RCOrderbook._updateBidInOrderbook(address,address,uint256,uint256,uint256,RCOrderbook.Bid)._owner   (contracts/RCOrderbook.sol line(s)#358) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)    -------------------------------------------------------------------  RCOrderbook.closeMarket()._owner   (contracts/RCOrderbook.sol line(s)#639) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)   -------------------------------------------------------------------  ## Tools Used  Solidity Compiler 0.8.4 Hardhat v2.3.3 Slither v0.8.0  Compiled, Tested, Deployed contracts on a local hardhat network.  Ran Slither-analyzer for further detecting and testing.  ## Recommended Mitigation Steps  (Worked best under python venv) 1. Clone Project Repository 2. Run Project against Hardhat network;    compile and run default test on contracts. 3. Installed slither analyzer:   https://github.com/crytic/slither 4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results  "}, {"title": "Redudant calculations in payRent when marketBalance < _amount", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact   _amount -= (_amount - marketBalance); is basically the same as:    _amount = marketBalance;   "}, {"title": "Wrong calculation on _collectRentAction", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/122", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The method `_collectRentAction` contains the following code: ``` ...            } else if (!_foreclosed && _limitHit && _marketLocked) {                 // CASE 4                 // didn't foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN refund rent between the earliest event and now                 if (_cardTimeLimitTimestamp < marketLockingTime) {                     // time limit hit before market locked                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = block.timestamp - _cardTimeLimitTimestamp;                 } else {                     // market locked before time limit hit                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && !_limitHit && !_marketLocked) {                 // CASE 5                 // did foreclose AND                 // didn't hit time limit AND                 // didn't lock market                 // THEN rent OK, find new owner                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (_foreclosed && !_limitHit && _marketLocked) {                 // CASE 6                 // did foreclose AND                 // didn't hit time limit AND                 // did lock market                 // THEN if foreclosed first rent ok, otherwise refund after locking                 if (_timeUserForeclosed < marketLockingTime) {                     // user foreclosed before market locked                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // market locked before user foreclosed                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && _limitHit && !_marketLocked) {                 // CASE 7                 // did foreclose AND                 // did hit time limit AND                 // didn't lock market                 // THEN if foreclosed first rent ok, otherwise refund after limit                 if (_timeUserForeclosed < _cardTimeLimitTimestamp) {                     // user foreclosed before time limit                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // time limit hit before user foreclosed                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 }             } else {                 // CASE 8                 // did foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b                 if (                     _timeUserForeclosed <= _cardTimeLimitTimestamp &&                     _timeUserForeclosed < marketLockingTime                 ) {                     // user foreclosed first (or at same time as time limit)                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else if (                     _cardTimeLimitTimestamp < _timeUserForeclosed &&                     _cardTimeLimitTimestamp < marketLockingTime                 ) {                     // time limit hit first                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 } else {                     // market locked first                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = _timeUserForeclosed - marketLockingTime;                 } ... ```  On the case 6, instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, is doing `_refundTime = block.timestamp - marketLockingTime;`. This could lead to funds being drained by the miscalculation.   "}, {"title": "Anyone can affect deposits of any user and turn the owner of the token", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/119", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  On `RCTreasury`, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp.  So, calling this method using `user = XXXXX` and `_timeToCollectTo = type(uint256).max)`, would make `isForeclosed[user] = true`.  ```     function collectRentUser(address _user, uint256 _timeToCollectTo)         public         override         returns (             uint256 newTimeLastCollectedOnForeclosure         )     {         require(!globalPause, \"Global pause is enabled\");         assert(_timeToCollectTo != 0);         if (user[_user].lastRentCalc < _timeToCollectTo) {             uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);              if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {                 // The User has run out of deposit already.                 uint256 previousCollectionTime = user[_user].lastRentCalc;                  /*             timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)                                   = (now - previousCollectionTime) * (usersDeposit/rentOwed)             */                 uint256 timeUsersDepositLasts =                     ((_timeToCollectTo - previousCollectionTime) *                         uint256(user[_user].deposit)) / rentOwedByUser;                 /*             Users last collection time = previousCollectionTime + timeTheirDepsitLasted             */                 rentOwedByUser = uint256(user[_user].deposit);                 newTimeLastCollectedOnForeclosure =                     previousCollectionTime +                     timeUsersDepositLasts;                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(                     newTimeLastCollectedOnForeclosure                 );                 assert(user[_user].deposit == 0);                 isForeclosed[_user] = true;                 emit LogUserForeclosed(_user, true);             } else {                 // User has enough deposit to pay rent.                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);             }             emit LogAdjustDeposit(_user, rentOwedByUser, false);         }     } ```  Now, we can do the same for all the users bidding for a specific token.  Finally, I can become the owner of the token by just calling `newRental` and using a small price. `newRental` will iterate over all the previous bid and will remove them because there are foreclosed.   ## Tools Used Editor  ## Recommended Mitigation Steps  `collectRentUser` should be private and create a new public method with `onlyOrderbook` modifier  "}, {"title": "NFT Hub implementation deviates from ERC721 for transfer functions", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  ERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom().   Impact: The system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.   Given that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/nfthubs/RCNftHubL2.sol#L212-L234  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/00128bd26061986d10172573ceec914a4f3b4d3c/contracts/token/ERC721/ERC721.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add support for approval in NFT transfers.  "}, {"title": "questionFinalised is redundant", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/111", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact questionFinalised is redundant, it is only set to true or false but never queried or used in any meaningful way.  ## Recommended Mitigation Steps Remove questionFinalised from the codebase.  "}, {"title": "Missing call to removeOldBids may affect foreclosure", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Orderbook.removeBids() as commented \u201c///remove bids in closed markets for a given user ///this can reduce the users bidRate and chance to foreclose\u201d  removeOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  \u201cdo some cleaning up, it might help cancel their foreclosure\u201d as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.  Impact: If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidrate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L300-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add call to removeOldBids() on L355 of withdrawDeposit() of Treasury.  "}, {"title": "Unused named return values are misleading and could lead to errors", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/96", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The code base uses a mix of named return values and explicit returns. In some places, the named return values are never assigned to and explicit returns are used instead.   Impact: This makes code readability and auditability hard potentially leading to errors and missed vulnerabilities.  ## Proof of Concept  Named return value shouldContinue is never assigned in _collectRentAction(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L856   Named return value didUpdateEverything is never assigned in _collectRent(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1040  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unassigned named return variables and be consistent in named vs explicit return usage.  "}, {"title": "Redundant allowance and balance checks", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In Market sponsor() the call to treasury.checkSponsorship() checks allowance and balance  of user. This is redundant because the call to treasury.sponsor downstream checks allowance again and insufficient balance would cause any transfer to fail anyway.  Impact: Given the gas sensitivity of the code base, removing this redundant check could help conserve gas and prevent any DoS from breaking gas limits.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L810  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L386-L396  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L474-L478   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant checks.  "}, {"title": "exitedTimestamp set prematurely", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/91", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The exitedTimestamp flag is used to prevent front-running of user exiting and re-entering in the same block. The setting of this flag in exit() should really be inside the conditionals and triggered only if current owner or if bidExists. It currently assumes that either of the two will always be true which may not necessarily be the case.  Impact: A user accidentally exiting a card he doesn't own or have a bid for currently will be marked as exited and prevented from a newRental in the same block. User can prevent one's own newRental from succeeding, because it was accidentally triggered, by front-running it himself with an exit. There could be other more realistic scenarios.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L784-L804  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L56-L57  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L678-L681   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Set exitedTimestamp flag only when the conditionals are true within exit()  "}, {"title": "maxSumOfPrices check is broken", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  rentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies \u201climit to the sum of the bids to place\u201d as specified in the Natspec @param comment. This is apparently for front-run protection.  However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total of bids places greater than the _maxSumOfPrices specified.  Impact: The user may not have sufficient deposit, be foreclosed and/or impacted on other bids/markets.  ## Proof of Concept  Scenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L636-L637  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L639-L657   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Modify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.  "}, {"title": "Missing market open check", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing _checkState(States.OPEN) on first line of rentAllCards() as specified on L617. These core market functions are supposed to operate only when market is open but the missing check allows control to proceed further in the control flow. In this case, the function proceeds to call newRental() which has a conditional check state == States.OPEN and silently returns success otherwise, without reverting.  Impact: rentAllCards does not fail if executed when market is closed or locked. newRental returns silently without failure when market is closed or locked.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L617  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L637-L658  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L672   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check market open state in the beginning of all core market functions and revert with an informative error string otherwise.  "}, {"title": "Misplaced zero-address check", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Misplaced zero-address check for nfthub on L595 in createMarket() because nfthub cannot be 0 at this point as nfthub.addMarket() on L570 would have already reverted if that were the case.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L570  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L595  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move nfthub zero-address check to before the call to nfthub.addMarket().  "}, {"title": "Making isMarketApproved False on an operational market will lock NFTs to L2", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Once market is approved and operational, changing approval to false should not be allowed or else it will prevent NFTs from being withdrawn to mainnet. All other Governor controlled variables are used during market creation and not thereafter, except this one. The other onlyGovernors functions only affect state before market creation but this one affects after creation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L382-L391  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L326-L330   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Once market is approved and operational, changing approval to false should not be allowed.  "}, {"title": "Basis points usage deviates from general definition", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/72", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The general definition of basis points is 100 bps = 1%. The usage here, 1000 bps = 100%, deviates from generally accepted definition and could cause confusion among users/creators/affiliates or potential miscalculations.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L228  https://www.investopedia.com/terms/b/basispoint.asp  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Document the used definition of basis points or switch to the generally accepted definition.  "}, {"title": "Redundant require() statement in RCFactory.createMarket()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  jvaqa   # Vulnerability details  Redundant require() statement in RCFactory.createMarket()  ## Impact  RCFactory.createMarket() contains two require() statements side-by-side both checking the value of the relative values of _timestamps[0] and block.timestamp. // [1]  However, there is no case where the first require() statement would be triggered without the second require() statement also being triggered, since advancedWarning cannot have a negative value. // [2]  Thus, the first require() statement is redundant, and unnecessarily uses gas.  ## Proof of Concept  Alice can call RCFactory.createMarket() with an advancedWarning value greater than zero, and a _timestamps[0] value less than block.timestamp.  ## Recommended Mitigation Steps  Remove this require statement:  require(                 _timestamps[0] >= block.timestamp,                 \"Market opening time not set\"             ); // [3]   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L524  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  "}, {"title": "RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  jvaqa   # Vulnerability details  RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.  ## Impact  IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. // [1]  The comments explicitly state that _incrementState() should be called \"thrice\". // [2]  However, it is possible to create a market where these events do not occur sequentially.  You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.  This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0]. // [3]  This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. // [4]  Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.  ## Proof of Concept  When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0]. // [5]  ## Recommended Mitigation Steps  Add the following check to RCFactory.createMarket():  require(     _timestamps[0] < _timestamps[1],     \"market must begin before market can lock\" );  [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521  [5] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468  "}, {"title": "Lack of zero address validation ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact   constructor of RCorderbook.sol lacks zero address validation , since parameter of costructor are used initialize state variable which are used in other function of the contract , error in these state variable can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L106  ## Tools Used manual review  ## Recommended Mitigation Steps add require condition to check for zero address  "}, {"title": "Unused return value from orderbook.findNewOwner() and treasury.payRent()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact checking the return value from function indicates ether function call was success or failure because of that, we should utilise the return value   ## Proof of Concept  In RCmarket.sol  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1025  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1060  ## Tools Used slither  ## Recommended Mitigation Steps  Utilize return value  "}, {"title": "RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "# Handle  jvaqa   # Vulnerability details  RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted  ## Impact  The comments state that calling addToWhitelist() should add a user to the whitelist. [1]  However, since the implementation simply flips the user's whitelist bool, if the user is already on the whitelist, then calling addToWhitelist() will actually remove them from the whitelist. [2]  Since batchAddToWhitelist() will repeatedly call addToWhitelist() with an entire array of users, it is very possible that someone could inadvertently call addToWhitelist twice for a particular user, thereby leaving them off of the whitelist. [3]   ## Proof of Concept  If a governor calls addToWhitelist() with the same user twice, the user will not be added to the whitelist, even though the comments state that they should.  ## Recommended Mitigation Steps  Change addToWhitelist to only ever flip a user's bool to true. To clarify the governor's intention, create a corresponding removeFromWhitelist and batchRemoveFromWhitelist which flip a user's bool to false, so that the governor does not accidently remove a user when intending to add them.   Change this:  isAllowed[_user] = !isAllowed[_user]; // [4]  To this:  isAllowed[_user] = true; // [4]  And add this:      /// @notice Remove a user to the whitelist     function removeFromWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), \"Not authorised\");         isAllowed[_user] = false;     }      /// @notice Remove multiple users from the whitelist     function batchRemoveFromWhitelist(address[] calldata _users) public override {         for (uint256 index = 0; index < _users.length; index++) {             removeFromWhitelist(_users[index]);         }     }   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L209  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L217  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213   "}, {"title": "anyone can call function sponsor", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:     /// @notice ability to add liqudity to the pot without being able to win.     /// @dev called by Factory during market creation     /// @param _sponsorAddress the msgSender of createMarket in the Factory     function sponsor(address _sponsorAddress, uint256 _amount)         external         override     {         _sponsor(_sponsorAddress, _amount);     }  ## Recommended Mitigation Steps Check that the sender is a factory contract.  "}, {"title": "circuitBreaker overrides the state", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function circuitBreaker calls _incrementState but later sets the state itself again:     function _incrementState() internal {         assert(uint256(state) < 4);         state = States(uint256(state) + (1));         emit LogStateChange(uint256(state));     }      function circuitBreaker() external {         require(             block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),             \"Too early\"         );         _incrementState();         orderbook.closeMarket();         state = States.WITHDRAW;     }  ## Recommended Mitigation Steps state = States.WITHDRAW; shouldn't be there, or another solution would be to put it before orderbook.closeMarket(); and remove _incrementState(); instead but then LogStateChange event will also need to be emitted manually.  "}, {"title": "contract RCTreasury does not use nfthub and setNftHubAddress", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract RCTreasury has an unused storage variable nfthub and setNftHubAddress function. This variable was moved to the Factory contract so it is useless here.  ## Recommended Mitigation Steps Remove nfthub variable and function setNftHubAddress.  "}, {"title": "functions safeTransferFrom and transferFrom are too similar", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function safeTransferFrom is almost identical to function transferFrom. It would be better to reduce code duplication by re-using the code.  ## Recommended Mitigation Steps    function safeTransferFrom(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) public override {         transferFrom(from, to, tokenId);         _data;     }  "}, {"title": "event WithdrawnBatch is not used", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact event WithdrawnBatch in contract RCNftHubL2 is not used anywhere.  ## Recommended Mitigation Steps Remove or use it where intended.  "}, {"title": "Add comment to not obvious code in withdrawDeposit ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function withdrawDeposit of RCTreasury.sol, the value of isForeclosed[_msgSender]  is set to true. In the next statement it is overwritten with a new value. So the first statement seem redundant. However this is not the case because it is retrieved from the function removeUserFromOrderbook (see proof of concept below)  As this is not obvious it is probably useful to add a comment so future developers can understand this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322 function withdrawDeposit(uint256 _amount, bool _localWithdrawal)  external  override  balancedBooks  {   ...      isForeclosed[_msgSender] = true;   // this seems to be redundant     isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook( _msgSender );  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L575   function removeUserFromOrderbook(address _user)  external override returns (bool _userForeclosed) {         require(treasury.isForeclosed(_user), \"User must be foreclosed\");   // this checks the isForeclosed value from the treasury contract   ## Tools Used  ## Recommended Mitigation Steps Add a comment to  isForeclosed[_msgSender] = true;  explaining this line is important.   "}, {"title": "payout doesn't fix isForeclosed state", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.  For example the function refundUser does check and update the isForeclosed status.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429  function payout(address _user, uint256 _amount)  external override balancedBooks onlyMarkets returns (bool) {         require(!globalPause, \"Payouts are disabled\");         assert(marketPot[msgSender()] >= _amount);         user[_user].deposit += SafeCast.toUint128(_amount);         marketPot[msgSender()] -= _amount;         totalMarketPots -= _amount;         totalDeposits += _amount;         emit LogAdjustDeposit(_user, _amount, true);         return true;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447  function refundUser(address _user, uint256 _refund)  external override onlyMarkets {      ...         if ( isForeclosed[_user] && user[_user].deposit > user[_user].bidRate / minRentalDayDivisor )  {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }  ## Tools Used  ## Recommended Mitigation Steps Check and update the isForeclosed state in the payout function  "}, {"title": "unnecessary emit of LogUserForeclosed", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function deposit of RCTreasury.sol resets the isForeclosed state and emits LogUserForeclosed, if the use have enough funds. However this also happens if the user is not Foreclosed and so the emit is redundant and confusing.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L279 function deposit(uint256 _amount, address _user) public override balancedBooks returns (bool) {    ....         // this deposit could cancel the users foreclosure         if ( (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor) ) {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }         return true;     }  ## Tools Used  ## Recommended Mitigation Steps Only do the emit when isForeclosed was true  "}, {"title": "addToWhitelist doesn't check factoryAddress", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function addToWhitelist of RCTreasury.sol does a call to the factory contract, however the factoryAddress might not be initialized, because it is set via a different function (setFactoryAddress). The function addToWhitelist will revert when it calls a 0 address, but it might be more difficult to troubleshoot.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L233    function setFactoryAddress(address _newFactory) external override {         ...         factoryAddress = _newFactory;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L210     function addToWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), \"Not authorised\");         isAllowed[_user] = !isAllowed[_user];     }  ## Tools Used  ## Recommended Mitigation Steps Verify that factoryAddress is set in the function addToWhitelist, for example using the following code.  require(factory != address(0), \"Must have an address\");  "}, {"title": "external-function", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#tokenURI(uint256) is declared external in the IRCMarket interface but is declared public in the RCMarket implementation.   This is inconsistent and affect the gas behavior of the function: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L27  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  ## Tools Used  Slither  ## Recommended Mitigation Steps  Mark the implementation method as external.  "}, {"title": "costly-loop", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#initialize(uint256,uint32[],uint256,uint256,address,address,address[],address,string) has a potentially expensive loop that modifies state continually over an indeterminate number of cards.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L252  ## Tools Used  Slither  ## Recommended Mitigation Steps  Potentially a gas-expensive loop because of arbitrary length of _cardAffiliateAddresses possibly assigning to state variable cardAffiliateCut multiple times. * It appears that the loop may be exited on the first cardAffiliateCut = 0 to optimize gas * Alternatively a local variable may be assigned temporarily and then assigned to state: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop   "}, {"title": "Camel case function name", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Minimal code quality issue.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCFactory.sol#L26  The function setminimumPriceIncreasePercent does not follow the code standard of camel casing of function names.    ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Rename the function to have proper camel casing.  "}, {"title": "Can access cards of other markets", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/11", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Within RCMarket.sol the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.  You can still only move cards you own.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338     function ownerOf(uint256 _cardId) public view override returns (address) {         uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards         return nfthub.ownerOf(_tokenId);     }  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313   modifier onlyTokenOwner(uint256 _token) {         require(msgSender() == ownerOf(_token), \"Not owner\"); // _token could be higher than numberOfCards,         _;     }    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,         _checkState(States.WITHDRAW);         require(             !factory.trapIfUnapproved() ||                 factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market             \"Upgrade blocked\"         );         uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market         _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place         nfthub.withdrawWithMetadata(_tokenId);         emit LogNftUpgraded(_card, _tokenId);     }    ## Tools Used  ## Recommended Mitigation Steps Add the following to ownerOf: require(_card < numberOfCards, \"Card does not exist\");   "}, {"title": "1000 as a constant", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A value of 1000 is used to indicate 100%. This value is hardcoded on several places. It's saver to use a constant, to prevent mistakes in future updates.  ## Proof of Concept .\\RCFactory.sol:    /// @dev in basis points (so 1000 = 100%) .\\RCFactory.sol:                1000, .\\RCMarket.sol:                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) - .\\RCMarket.sol:            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) - .\\RCMarket.sol:            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000); .\\RCMarket.sol:                (1000); .\\RCMarket.sol:            _remainingPot = (totalRentCollected * _remainingCut) / (1000); .\\RCMarket.sol:            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut; .\\RCMarket.sol:            (_rentCollected * _remainingCut) / (1000); .\\RCMarket.sol:            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000); .\\RCMarket.sol:            uint256 _payment = (totalRentCollected * _cut) / (1000);  ## Tools Used grep  ## Recommended Mitigation Steps Replace 1000 with a constant.   "}, {"title": "Checks for enum bounds", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact For the enums Mode and State, checks are made that the variables are within bounds. Here specific size are used, e.g. 2 and 4. If the size of the enums would be changed in the future, those numbers don't change automatically. Also solidity provides in-built check to check that variables are within bounds, which could be used instead. This also make the code more readable.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L202 enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} function initialize(      ...         assert(_mode <= 2);        // can be removed       ...          mode = Mode(_mode);  // this makes sure: 0<=mode<=2   // move to top  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/interfaces/IRCMarket.sol#L7     enum States {CLOSED, OPEN, LOCKED, WITHDRAW}  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1094     function _incrementState() internal {         assert(uint256(state) < 4);                 // can be removed         state = States(uint256(state) + (1));  // this makes sure: 0<=state<=3         emit LogStateChange(uint256(state));     }  ## Tools Used  ## Recommended Mitigation Steps For function initialize: Remove the \"assert(_mode <= 2);\" and move the statement \"mode = Mode(_mode);\" to the top of the function and add a comment  For function _incrementState:  Remove \"assert(uint256(state) < 4);\" and add a comment at \"state = States(uint256(state) + (1));\"  "}, {"title": "improve readability of 1000000 ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The number 1000000  is used in the constructor of RCTreasury.sol. This is difficult to read in a glance. Solidity allows the use of an underscore ( _ ) to make numbers more readable.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L114 setMaxContractBalance(1000000 ether); // 1m  ## Tools Used  ## Recommended Mitigation Steps  Replace 1000000 with 1_000_000   "}, {"title": "_realitioAddress not used", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The variable _realitioAddress of RCMarket.sol isn't used. The variable realitio seems to used instead. Two variables with the same purpose is confusing.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L121     IRealitio public realitio;     address public _realitioAddress;  ## Tools Used  ## Recommended Mitigation Steps Remove     address public _realitioAddress;  "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several variables are only set once. So it might be useful to make them immutable to reduced the change of accidental updates See the \"proof of concept\" for examples.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol uint256 public numberOfCards; uint256 public totalNftMintCount; IRCTreasury public treasury; IRCFactory public factory; IRCNftHubL2 public nfthub; IRCOrderbook public orderbook; uint256 public minimumPriceIncreasePercent; uint256 public minRentalDayDivisor; uint256 public maxRentIterations; uint32 public marketOpeningTime; uint32 public override marketLockingTime; uint32 public oracleResolutionTime;    address public artistAddress; address public affiliateAddress; address public marketCreatorAddress; uint256 public creatorCut;     address[] public cardAffiliateAddresses; address public arbitrator; IRealitio public realitio;  //https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCFactory.sol#L113 IRCTreasury public override treasury;      ## Tools Used  ## Recommended Mitigation Steps Use the immutable keyword where possible   "}, {"title": "Unchecked ERC20 transfers can cause lock up", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  axic   # Vulnerability details  ## Impact  Some major tokens went live before ERC20 was finalised, resulting in a discrepancy whether the transfer functions a) should return a boolean or b) revert/fail on error. The current best practice is that they should revert, but return \u201ctrue\u201d on success. However, not every token claiming ERC20-compatibility is doing this \u2014 some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.  Today many tools, including OpenZeppelin, offer a wrapper for \u201csafe ERC20 transfer\u201d: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the `balancedBooks` modifier:  ```     modifier balancedBooks {         _;         // using >= not == in case anyone sends tokens direct to contract         require(             erc20.balanceOf(address(this)) >=                 totalDeposits + marketBalance + totalMarketPots,             \"Books are unbalanced!\"         );     } ```  This modifier is present on most functions, but is missing on `topupMarketBalance`: ```     function topupMarketBalance(uint256 _amount) external override {         erc20.transferFrom(msgSender(), address(this), _amount);         if (_amount > marketBalanceDiscrepancy) {             marketBalanceDiscrepancy = 0;         } else {             marketBalanceDiscrepancy -= _amount;         }         marketBalance += _amount;     } ```  In the case an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with \u201cBooks are unbalanced\u201d.  ## Proof of Concept  Anyone can call `topupMarketBalance` with some unrealistically large number, so that `marketBalance` does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but return \u201cfalse\u201d instead.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Use something like OpenZeppelin\u2019s SafeERC20 2. Set up an allow list for tokens, which are knowingly safe 3. Consider a different approach to the `balancedBooks` modifier   "}, {"title": "Gas inefficiency with NativeMetaTransaction and calldata", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  axic   # Vulnerability details  ## Impact  In `lib/NativeMetaTransactions.sol` there is a frequently used helper `msgSender`: ```     function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             bytes memory array = msg.data;             uint256 index = msg.data.length;             assembly {                 // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.                 sender := and(                     mload(add(array, index)),                     0xffffffffffffffffffffffffffffffffffffffff                 )             }         } else { ... ```  Even though only the last 20-bytes matter, the `bytes memory array = msg.data;` line causes the *entire* calldata to be copied to memory. This is exaggerated by the fact, that if `msgSender()` is called multiple times in a transaction, the calldata will be also copied multiple times as memory is not freed.  ## Proof of Concept  N/A  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  There are multiple ways to avoid this:  1. Make use of calldata slices and conversions  Something along the lines of (untested!): ```             // Copy last 20 bytes             bytes calldata data = msg.data[(msg.data.length - 20):];             sender = payable(address(uint160(bytes20(data)))); ```  2. Implementing purely in assembly  The OpenZeppelin implementation (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol#L21-L30) is an example of an optimised assembly version: ```             assembly {                 sender := shr(96, calldataload(sub(calldatasize(), 20)))             } ```  3. Combining slices and assembly  One must note that the pure assembly version is obviously the most gas efficient, at least today.   "}, {"title": "Gas optimization on `redeemToken` of `ATokenYieldSource`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  At line 213 of `ATokenYieldSource`, `depositToken()` can be replaced by `_tokenAddress()` to save gas since the former is a public function, while the latter is an internal function.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L213](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L213)  ## Recommended Mitigation Steps  Change `depositToken()` to `_tokenAddress()`.  "}, {"title": "Gas optimization on `_depositToAave`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `_depositToAave` of `ATokenYieldSource` calls `_lendingPool` and `_tokenAddress` twice, both of which include function calls to external contracts. Thus, storing the first results into local variables and reuse them for the second time could help save gas.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L175-L182](https://github.com/pooltogether/aave-yield-source/blob/main/contracts/yield-source/ATokenYieldSource.sol#L175-L182)  ## Recommended Mitigation Steps  Store the result of `_tokenAddress()` and `_lendingPool()` to local variables and resue them.  "}, {"title": "User could lose underlying tokens when redeeming from the `IdleYieldSource`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/120", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "IdleYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.  ## Proof of Concept  When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.  Referenced code: [IdleYieldSource.sol#L129-L131](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L129-L131)  ## Recommended Mitigation Steps  Change `redeemedShare` to `redeemAmount` at line 131.  "}, {"title": "Lack of `nonReentrant` modifier in yield source contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource", "IdleYieldSource", "SushiYieldSource", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `YearnV2YieldSource` contract prevents the `supplyTokenTo`, `redeemToken`, and `sponsor` functions from being reentered by applying a `nonReentrant` modifier. Since these contracts share a similar logic, adding a `nonReentrant` modifier to these functions in all of the yield source contracts is reasonable. However, the same protection is not seen in other yield source contracts.  ## Proof of Concept  A `nonReentrant` modifier in the following functions is missing: 1. The `sponsor` function of `ATokenYieldSource` 2. The `supplyTokenTo` and `redeemToken` function of `BadgerYieldSource` 3. The `sponsor` function of `IdleYieldSource` 4. The `supplyTokenTo` and `redeemToken` function of `SushiYieldSource`  Referenced code: [ATokenYieldSource.sol#L233](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L233) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [IdleYieldSource.sol#L150](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L150) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Add a `nonReentrant` modifier to these functions. For `BadgerYieldSource` and `SushiYieldSource` contracts, make them inherit from Openzeppelin's `ReentrancyGuardUpgradeable` to use the `nonReentrant` modifier.  "}, {"title": "`onERC721Received` not implemented in `PrizePool`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/118", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `PrizePool` contract does not implement the `onERC721Received` function, which is considered a best practice to transfer ERC721 tokens from contracts to contracts. The absence of this function could prevent `PrizePool` from receiving ERC721 tokens from other contracts via `safeTransferFrom`.  ## Proof of Concept  Referenced code: [PrizePool.sol](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol)  ## Recommended Mitigation Steps  Consider adding an implementation of the `onERC721Received` function in `PrizePool`.  "}, {"title": "Using `transferFrom` on ERC721 tokens", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.  ## Proof of Concept  Referenced code: [PrizePool.sol#L602](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L602)  ## Recommended Mitigation Steps  Consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.  "}, {"title": "SafeMath not completely used in yield source contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 1. line 78 in `SushiYieldSource` 2. line 67 in `BadgerYieldSource` 3. line 91 and 98 in `IdleYieldSource`  ## Proof of Concept  Referenced code: [SushiYieldSource.sol#L78](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L78) [BadgerYieldSource.sol#L67](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L67) [IdleYieldSource.sol#L91](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L91) [IdleYieldSource.sol#L98](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L98)  ## Recommended Mitigation Steps  Use the SafeMath library functions in the above lines.  "}, {"title": "Return values of ERC20 `transfer` and `transferFrom` are unchecked", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "SushiYieldSource", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.  ## Proof of Concept  If warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.  Referenced code: [BadgerYieldSource.sol#L44](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L44) [BadgerYieldSource.sol#L79](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L79) [SushiYieldSource.sol#L48](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L48) [SushiYieldSource.sol#L89](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L89)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  "}, {"title": "Unlocked pragma used in multiple contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Some contracts (e.g., `PrizePool`) use an unlocked pragma (e.g., `pragma solidity >=0.6.0 <0.7.0;`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.4/#solidity)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  "}, {"title": "Declare functions as `external` to save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "SushiYieldSource", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Functions (e.g., `supplyTokenTo`, `redeemToken`) in the `BadgerYieldSource` and `SushiYieldSource` can be declared `external` instead of `public` to save gas.  ## Proof of Concept  Referenced code: [BadgerYieldSource.sol#L26](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L26) [BadgerYieldSource.sol#L32](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L32) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [SushiYieldSource.sol#L29](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L29) [SushiYieldSource.sol#L35](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L35) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Change the keyword `public` to `external`.  "}, {"title": "IdleYieldSource doesn't use mantissa calculations", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/103", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.  For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalunderlying assets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.    ## Proof of Concept https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95  https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L106  ## Recommended Mitigation Steps Implement mantissa calculations like in the contract for the AAVE  yield.  "}, {"title": "Gas savings on uninitialized variables.", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ##Impact Uninitialized variables initialize to 0 automatically. No need to explicitly initialize it.   ##Proof of concept https://github.com/pooltogether/aave-yield-source/blob/bc65c875f62235b7af55ede92231a495ba091a47/contracts/yield-source/ATokenYieldSource.sol#L141  ##Recommended mitigation steps Replace with: `uint256 shares;`  "}, {"title": "CreditBurned event emitted even on zero tokens burned", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  In `PrizePool._updateCreditBalance` the `CreditBurned` event is emitted even if nothing was burned. Not emitting this event when nothing happened can save gas and also seems better semantically.  "}, {"title": "Credit accrual is done twice in `award`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The credit is accrued twice in `award`. The first accrual happens implicitly when calling `_mint` through the `ControlledToken(controlledToken).controllerMint` call which then performs the `PrizePool.beforeTokenTransfer` hook which accrues credit. Then the explicit accrual is done again. It should be enough to only add the `extraCredit` without doing another accrual (calling `_updateCreditBalance(..., newBalance= _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra)))` instead).  "}, {"title": "SushiYieldSource save gas with pre-approval", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "SushiYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  `SushiYieldSource` should approve the SushiBar once during initialization with the max value. This saves gas on every `supplyTokenTo` call as the approval can be removed from there.  "}, {"title": "ATokenYieldSource save gas with pre-approval", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource", "IdleYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  `ATokenYieldSource` should approve the lending contract once during initialization with the max value. This saves gas on every `supplyTokenTo/_depositToAave` call as the approval can be removed from there.  "}, {"title": "withdraw timelock can be circumvented", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/91", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  One can withdraw the entire `PrizePool` deposit by circumventing the timelock. Assume the user has no credits for ease of computation: - user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This \"mints\" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`. - user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp` - As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.  ## Impact  Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.  ## Recommended Mitigation Steps  The unlock timestamp should be increased by duration each time, instead of being reset to the duration.  "}, {"title": "`YearnV2YieldSource` wrong subtraction in withdraw", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/90", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  `YearnV2YieldSource._withdrawFromVault` uses a wrong subtraction. When withdrawing from the `vault` one redeems `yTokens` for `token`s, thus the `token` balance of the contract should increase after withdrawal. But the contract subtracts the `currentBalance` from the `previousBalance`:  ```solidity uint256 yShares = _tokenToYShares(amount); uint256 previousBalance = token.balanceOf(address(this)); // we accept losses to avoid being locked in the Vault (if losses happened for some reason) if(maxLosses != 0) {     vault.withdraw(yShares, address(this), maxLosses); } else {     vault.withdraw(yShares); } uint256 currentBalance = token.balanceOf(address(this)); // @audit-issue this seems wrong return previousBalance.sub(currentBalance); ```  ## Impact  All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.  ## Recommended Mitigation Steps  It should return `currentBalance > previousBalance ? currentBalance - previousBalance : 0`  "}, {"title": "ATokenYieldSource mixes aTokens and underlying when redeeming", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ATokenYieldSource.redeemToken` function burns `aTokens` and sends out underlying, however, it's used in a reverse way in the code: The `balanceDiff` is used as the `depositToken` that is transferred out but it's computed on the **aTokens** that were burned instead of on the `depositToken` received.  ## Impact  It should not directly lead to issues as aTokens are 1-to-1 with their underlying but we still recommend doing it correctly to make the code more robust against any possible rounding issues.  ## Recommended Mitigation Steps  Compute `balanceDiff` on the underyling balance (depositToken), not on the aToken. Subtract the actual burned aTokens from the user shares.  "}, {"title": "BadgerYieldSource balanceOfToken share calculation seems wrong", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/84", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details   When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.  The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:  ```solidity balances[addr].mul(   badger.balanceOf(address(badgerSett)) ).div(   badgerSett.totalSupply() ) ```  However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault (\"Sett\") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:  > Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)  ## Impact  Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.  ## Recommended Mitigation Steps  It should use [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for \"the balance in the Sett, the Controller, and the Strategy\".  "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/81", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource", "SushiYieldSource", "BadgerYieldSource", "PrizePool", "ControlledToken", "StakePrizePool"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `StakePrizePool.initialize`: `address _stakeToken` not checked for non-zero or contract - `ControlledToken.initialize`: `address controller` not checked for non-zero or contract - `PrizePool.withdrawReserve`: `address to` not checked for non-zero, funds will be lost when sending to zero address - `ATokenYieldSource.initialize`: `address _aToken, _lendingPoolAddressesProviderRegistry` not checked for non-zero or contract - `BadgerYieldSource.initialize`: `address badgerSettAddr, badgerAddr` not checked for non-zero or contract - `SushiYieldSource.constructor`: `address _sushiBar, _sushiAddr` not checked for non-zero or contract  ## Impact  Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps  Validate the parameters.  "}, {"title": "_depositToAave always returns 0", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract ATokenYieldSource function _depositToAave returns 0 if successful. However, this value is not checked nor used anywhere. As this function is internal it would probably be better to remove this unnecessary return to save some gas and eliminate confusion.  ## Recommended Mitigation Steps refactor function _depositToAave to return void.  "}, {"title": "Uneven use of events", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact To track off-chain data it is necessary to use events  ## Proof of Concept  In  ATokenYieldSource.sol, IdleYieldSource.sol, yearnV2yieldsource  : events are emmitted in supplyTokenTo(), redeemToken() sponsor(), but not in  BadgerYieldsource.sol and shushiyieldsource.sol     ## Tools Used  Manual analysis  ## Recommended Mitigation Steps use events   "}, {"title": "Various gas optimizations", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  # General Gas optimization  ## Upgrade to at least 0.8.4 (even better is 0.8.5)  The following should lead to better gas savings:    - The inliner should decrease runtime gas.   - Inbuilt safemath instead of openzeppelin safemath should save some gas.   - Various improvement in the expression simplifier in the compiler throughout (0.7.0 - 0.8.5)     which should decrease both runtime and deploy time costs. (I'm assuming that the project     currently uses 0.6.12, since the compiler version was not explicitly specified.)  Of course, these improvements comes when optimizer is enabled, preferably with a high `--optimize-runs` value.  Note that the `inliner` in particular can be quite useful for the contract, since the contracts sometimes generously chains small functions.  ## Use custom errors instead of large revert strings  Saves both deploy time and runtime gas (runtime gas is only relevant when the revert condition is met.)  Need at least solidity 0.8.4 for this feature.  ### Use shorter revert strings  If you decide to not use custom errors, then try to use revert strings of size at most 32 characters.  For one, shorter strings would save deploy cost (one time saving of 200 gas per byte / character decreased). Also strings more than 32 bytes requires an additional `mstore`, two additional `push`, and an `add`. Roughly, 18 more gas during runtime (when revert condition is met).  Example string (33 bytes), from ControlledToken.sol  ``` solidity uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, \"ControlledToken/exceeds-allowance\"); ```  # Specific Gas optimizations  ## Use `immutable`  For state variables that are only assigned in constructors, change it to `immutable`.  This saves an `sload` each time the variable is accessed. Can save around 2100 gas (or 100 depending on warm / cold.)  Examples:  ### StakePrizePool.sol  ``` diff modified   contracts/StakePrizePool.sol @@ -8,7 +8,7 @@ import \"../PrizePool.sol\";   contract StakePrizePool is PrizePool {  -  IERC20Upgradeable private stakeToken; +  IERC20Upgradeable immutable private stakeToken;     event StakePrizePoolInitialized(address indexed stakeToken); ```  ### ControlledToken.sol  ``` diff contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {     /// @notice Interface to the contract responsible for controlling mint/burn -  TokenControllerInterface public override controller; +  TokenControllerInterface public immutable override controller; ```  ### yield-source/YearnV2YieldSource.sol  ``` diff @@ -24,7 +24,7 @@ contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeabl      /// @notice Yearn Vault which manages `token` to generate yield      IYVaultV2 public vault;      /// @dev Deposit Token contract address -    IERC20Upgradeable internal token; +    IERC20Upgradeable immutable internal token;      /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS      uint256 public maxLosses = 0; // 100% would be 10_000 ```  This change would likely require changing the initialization pattern. See the section below for details.  Similarly, several such variables can be changed. Not listing everything here.  ## Avoiding the `initialize` pattern  If elements can be initialized in the constructor, or via calls to internal functions in constructor, instead of the public `initialize` function, it should be possible to save deployment costs. On top of that, since the `initialize` function won't be part of the function dispatch in the contract, one could save some gas at run time for some calls (saves approximately two `push`, an `eq` and a `jumpi`.)  Another benefit for this is that several state variables can be converted to immutables. Again, saves `sload` costs during runtime.  Also, it might also be possible to change `initialize` from `public` to `internal`.  ## `_msgSender()` (Possible micro optimization)  Use `msg.sender` instead of `_msgSender()`. The latter might not be inlined by the compiler. (This is for cases where `_msgSender()` function simply returns `msg.sender`.) Can save around 30 gas (2 `JUMP`, plus some `PUSH` and some stack operations.)  Also, the contracts seem to mix `_msgSender()` and `msg.sender`, for example in `PrizePool.sol`. This could be avoided.  ## Use `decreaseAllowance` in ControllerToken.sol  ``` diff @@ -58,8 +58,7 @@ contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {    /// @param _amount Amount of tokens to burn    function controllerBurnFrom(address _operator, address _user, uint256 _amount) external virtual override onlyController {      if (_operator != _user) { -      uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, \"ControlledToken/exceeds-allowance\"); -      _approve(_user, _operator, decreasedAllowance); +      decreaseAllowance(_user, _operator, _amount);      }      _burn(_user, _amount);    } ```  Will be slightly more gas efficient than the first once.  # General comments  ## Try to avoid `super` if possible  For example, in Ticket.sol:  ``` solidity   public   virtual   override   initializer {   super.initialize(_name, _symbol, _decimals, _controller); ```  The above usage of `super` is unnecessary. Unless you are dealing with multiple inheritance, where `super` is absolutely required, there is no need to use super, instead of statically specifying the name of the parent contract. There is however no performance penalty in using `super` instead of a static call to the parent.  ## Several `balance` related function can be made `view`?  In PrizePool, the function `function balance() external returns (uint256)` can perhaps be made `view`. This would also mean that a few other internal functions should be made `view`, such as `_balance`.   "}, {"title": "Using memory[] parameter without checking its length", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Using memory array parameters (e.g. uint[] memory) as function parameters can be tricky in Solidity, because an attack is possible with a very large array which will overlap with other parts of the memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L219  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L639   This an example to show the exploit:  // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol  pragma solidity ^0.4.24; // only works with low solidity version  contract test{     struct Overlap {         uint field0;     }     event log(uint);    function mint(uint[] memory amounts) public  returns (uint) {   // this can be in any solidity version        Overlap memory v;        v.field0 = 1234;        emit log(amounts[0]); // would expect to be 0 however is 1234        return 1;      }    function go() public { // this part requires the low solidity version       uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251       bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x);       bool success=address(this).call(payload);   } }     ## Tools Used  manual analysis  ## Recommended Mitigation Steps check the array length before using it  "}, {"title": "safeApprove() for Yearn Vault may revert preventing deposits causing DoS", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The _depositInVault() function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract\u2019s token balance.  However, the\u00a0safeApprove\u00a0function\u00a0prevents changing an allowance between non-zero values\u00a0to mitigate a\u00a0possible front-running attack. It reverts if that is the case. Instead, the\u00a0safeIncreaseAllowance\u00a0and\u00a0safeDecreaseAllowance\u00a0functions should be used. Comment from the OZ library for this function: \u201c// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and \u2018safeDecreaseAllowance'\"  Impact: If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user\u2019s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible.  ## Proof of Concept  Reference: See similar Medium-severity finding M03 here: https://blog.openzeppelin.com/1inch-exchange-audit/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L173  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6842518b1b71fac9a21c7d94ec521992cff266b5/contracts/token/ERC20/utils/SafeERC20.sol#L44-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use safeIncreaseAllowance()\u00a0function instead of safeApprove().  "}, {"title": "Lack of event emission after critical initialize() functions", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, Ticket.sol nor its base class ControlledToken.sol emit such an event in their initialize() functions.  Impact: These contracts are initialized but their critical init parameters (name, symbol, decimals and controller address) are not logged for any off-chain monitoring.  ## Proof of Concept  See similar Medium-severity Finding M01 in OpenZeppelin\u2019s audit of UMA protocol: https://blog.openzeppelin.com/uma-audit-phase-4/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/Ticket.sol#L24-L37  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/ControlledToken.sol#L22-L36  Examples of event emission: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L47   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit an initialised event in Ticket.sol and ControlledToken.sol logging their init parameters.  "}, {"title": "Missing calls to init functions of inherited contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource", "IdleYieldSource", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use the delegateCall proxy pattern and hence their implementations require the use of initialize() functions instead of constructors. This requires derived contracts to call the corresponding init functions of their inherited base contracts. This is done in most places except a few.  Impact: The inherited base classes do not get initialized which may lead to undefined behavior.   ## Proof of Concept  Missing call to __ReentrancyGuard_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/ATokenYieldSource.sol#L99-L102  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  Missing call to__ERC20_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L83-L86   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing calls to init functions of inherited contracts.  "}, {"title": "Actual yield source check on address will succeed for non-existent contract", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "YieldSourcePrizePool", "MitigationStarted"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall\u00a0return\u00a0true\u00a0even if the account called is non-existent (per EVM design). Solidity documentation warns: \"The low-level functions\u00a0call, delegatecall\u00a0and staticcall return\u00a0true\u00a0as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\u201d  The staticcall here will return True even if the _yieldSource contract doesn't exist at any incorrect-but-not-zero address, e.g. EOA address, used during initialization by accident. Impact: The hack, as commented, to check if it\u2019s an actual yield source contract will fail if the address is indeed a contract account which doesn\u2019t implement the depositToken function. However, if the address is that of an EOA account, the check will pass here but will revert in all future calls to the yield source forcing contract redeployment after the pool is active. Users will not be able to interact with the pool and abandon it.  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.6/control-structures.html#error-handling-assert-require-revert-and-exceptions  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L41-L45  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  A contract existence check should be performed on _yieldSource prior to the depositToken function existence hack for determining yield source contract.  "}, {"title": "Missing modifier onlyControlledToken may result in undefined/exceptional behavior", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "PrizePool"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The modifier onlyControlledToken is used for functions that allow the controlledToken address as a parameter to ensure that only whitelisted tokens (ticket and sponsorship) are provided. This is used in all functions except calculateEarlyExitFee().  Impact: The use of a non-whitelisted controlledToken will result in calls to potentially malicious token contract and cause undefined behavior for the `from` user address specified in the call.  ## Proof of Concept  Missing modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L729-L747  Modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1105-L1110  All other functions which accept controlledToken parameter have modifier onlyControlledToken: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L327  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L378  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L498  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L888  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L903  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing modifier onlyControlledToken to calculateEarlyExitFee().   "}, {"title": "Named return values are never used in favor of explicit returns", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Named return values in multiple functions are never used in favor of explicit returns.   Impact: This affects readability/auditability at the least and could potentially result in unexpected values being returned along paths with no explicit returns.  ## Proof of Concept  Unused in favor of explicit return:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L717-L726  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L741-L744  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L770  Used without explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L923-L930  Used with explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L944-L947   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused named returns where unnecessary. Be consistent in using named vs explicit returns.  "}, {"title": "Switch modifier order to consistently place the nonreentrant modifier as the first one", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  If a function has multiple modifiers they are executed in the order specified. If checks or logic of modifiers depend on other modifiers this has to be considered in their ordering. PrizePool has functions with multiple modifiers with one of them being nonreentrant which prevents reentrancy on the functions. This should ideally be the first one to prevent even the execution of other modifiers in case of reentrancies.  While there is no obvious vulnerability currently with nonreentrant being the last modifier in the list, it is safer to place it in the first. This is of slight concern with the deposit functions which have the canAddLiquidity() modifier (before nonreentrant) that makes external calls to get totalSupply of controlled tokens.  ## Proof of Concept  For reference, see similar finding in Consensys\u2019s audit of Balancer : https://consensys.net/diligence/audits/2020/05/balancer-finance/#switch-modifier-order-in-bpool  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275-L277  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Switch modifier order to consistently place the nonreentrant modifier as the first one to run so that all other modifiers are executed only if the call is nonreentrant.  "}, {"title": "Caching sushiAddr and sushiBar in local variables to save 200 gas in supplyTokenTo()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "SushiYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Caching sushiAddr and sushiBar in local variables right at the beginning of supplyTokenTo() (similar to what's done in redeemToken) can save 100 gas from repeat SLOADs for each of them for a total savings of 200.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/SushiYieldSource.sol#L48-L51  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Caching sushiAddr and sushiBar in local variables at the beginning of supplyTokenTo() and use those instead.  "}, {"title": "maxLosses can be cached in a local variable to save 100 gas in _withdrawFromVault()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  maxLosses state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L187-L188  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxLosses in a local variable at the beginning of the function and use that instead.  "}, {"title": "token can be cached in a local variable to save 100 gas in _withdrawFromVault()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L185  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L192   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  "}, {"title": "token can be cached in a local variable to save 200 gas in _depositInVault()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in three places in _depositInVault(). It can be cached in a local variable  at the beginning of the function to save 200 gas from two repeated SLOADs.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L172  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  "}, {"title": "Using function parameter in initialize() instead of state variable saves 100 gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Using parameter _vault instead of SLOAD of state variable vault in the call to safeApprove() leads to gas savings of 100.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L87  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L67  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Using parameter _vault instead of state variable vault in the call to safeApprove()  "}, {"title": "Zero-address check unnecessary due to the initializer modifier", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  YearnV2YieldSource initialize does a zero-address check for value address to detect if it has already been initialized. This is an unnecessary check because vault address default value is zero, it is not initialized/set anywhere else and the initializer modifier will prevent the calling of initialize() a second time. So vault is guaranteed to be zero in initialize().  The impact is gas wastage from an additional SLOAD of vault state variable and the require() check.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L73  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the zero-address check for vault.  "}, {"title": "Caching badger and badgerSett can save 400 gas in supplyTokenTo()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  State variables badger and badgerSett addresses are read two and four times respectively in supplyTokenTo(). Caching them in local variables at the beginning of the function and using those local variables can save 400 gas from avoiding 3 repeated SLOADs for badgerSett and 1 repeated SLOAD for badger.  Impact: Gas savings of 400  ## Proof of Concept  Two badger reads: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L44-L45  Four badgerSett reads:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L45  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L47  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L48  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache badger and badgerSett state variables in local variables at the beginning of the function and use those local variables instead.  "}, {"title": "Gas savings of (100*loop-iteration-count) by caching _tokens.end() in _tokenTotalSupply()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The loop iteration in _tokenTotalSupply() ends when currentToken matches _tokens.end() where _tokens is a state variable.  Impact: Checking against the state variable for every iteration costs 100 gas per iteration. Even with only two controlled tokens (tickets & sponsorship), this costs 100 more than caching this in a local memory variable and using that within the while predicate.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L177   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _tokens.end() in a local memory variable before the loop and using that within the while predicate.  "}, {"title": "Preventing zero-address controlled tokens from being added can avoid checks later", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "PrizePool"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  When _tokenTotalSupply() adds up the supplies of all controlled tokens, it checks and skips zero-address tokens. Instead of checking for zero-address every time for every call to _tokenTotalSupply() from captureAwardBalance() and every deposit via canAddLiquidity modifier, preventing zero-address controlled-token addresses from being added in _addControlledToken() during initialization will avoid these checks.  Impact: All deposit calls which cost 0.5M gas currently will be impacted by these unnecessary checks if we instead perform it one time during the addition of tokens in initialization.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L228-L230  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move zero-address check from time of use to time of adding the tokens into the list in initialize().  "}, {"title": "Gas savings of 100 by caching maxTimelockDuration in _calculateTimelockDuration()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  State variable maxTimelockDuration is read twice on consecutive lines 723 and 724 of function _calculateTimelockDuration(). Caching it in a local variable will save 100 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L723-L724   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxTimelockDuration in a local variable in the beginning of the function.  "}, {"title": "Gas savings of 100 per user by caching _timelockBalances[user] in _sweepTimelockBalances()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Mapping state variable value _timelockBalances[user] is read on consecutive lines 655 and 656 resulting in 2 SLOADS (2100 + 100 gas).   Impact: Caching this in a local variable would save ~= 100 gas savings per user iteration (by converting the use of the second 100-gas costing SLOAD to 1 MSTORE and 1 MLOAD both of which only cost 3 gas). If there are 1000 users in a call to sweepTimelockBalances(), this could be significant savings of 100,000 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L655-L656   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _timelockBalances[user] in a local variable before using on lines 655 and 656.  "}, {"title": "Gas savings of 300 by caching _currentAwardBalance in captureAwardBalance()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Cache _currentAwardBalance state variable in a local variable for computation to save gas. 4 SLOADs + 1 SSTORE can be reduced to 1 SLOAD and 1 STORE.   Impact: Saves 300 gas from avoid 3 SLOADs because each SLOAD to already accessed storage slot costs 100.  ## Proof of Concept  2 SLOADs: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L456  1 SSTORE + 1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L465  1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L470   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _currentAwardBalance in a local variable in the beginning, use that for computation/return and one updation to state variable at the end.  "}, {"title": "Simplifying extensible but expensive modifier may save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The canAddLiquidity modifier, which is used on all deposits (each deposit costs 0.5M gas), appears to be an expensive modifier because it calculates the sum of all the supplies across controlled tokens (by making external CALLs) and adding that up with reserve and timelock supplies. While this is an extensible implementation that supports arbitrary number of controlled tokens via mapped singly linked list, the prize pools typically have only two controlled tokens: tickets and sponsorship.   Impact: deposits currently cost 0.5M gas.  ## Proof of Concept  https://docs.pooltogether.com/protocol/overview#gas-usage  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L276  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L300  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1119-L1122  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1069-L1072  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1054-L1064  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider gas profiling a fast-path calculation by keeping a separate state variable that tracks the sum of timelock+reserve along with all deposits made towards controlled token supplies and comparing new deposits with that state variable instead of reevaluating totals during each deposit. The extra SLOADs, CALLs and other expensive operations (in linked list and other logic) during reevaluation may add up to more than updating this proposed new state variable across different operations.  "}, {"title": "Avoid use of state variables in event emissions to save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase.  ## Proof of Concept  The Initialized event in PrizePool uses state variables maxExitFeeMantissa and maxTimelockDuration instead of using the equivalent function parameters _maxExitFeeMantissa and _maxTimelockDuration which were just used to set these state variables. Using them instead will save 2 extra SLOADs, leading to gas savings of 200.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  The StakePrizePoolInitialized event uses state variable stakeToken instead of the function parameter _stakeToken used to set it. Using that instead will save 100 gas.  \u2028\u2028https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/StakePrizePool.sol#L36-L38\u2028  The IdleYieldSourceInitialized similarly uses idleToken instead of _idleToken.\u2028\u2028  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L62-L66  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use equivalent function parameters or local variables in event emits instead of state variables.  "}, {"title": "Gas Optimization: PrizePool._calculateCreditBalance.creditBalance is incorrectly passed by reference rather than passed by value, causing unnecessary SLOADs instead of MLOADs", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool._calculateCreditBalance.creditBalance is incorrectly declared as storage rather than as memory, causing unnecessary SLOADs instead of MLOADs. [1]  PrizePool._calculateCreditBalance() is declared as a view function, so we know definitively that PrizePool._calculateCreditBalance.creditBalance is not modified within the function. [2]  Since PrizePool._calculateCreditBalance.creditBalance is not modified within the function, then when we fetch it, we want to pass it by value and not by reference by declaring it as 'CreditBalance memory creditBalance' rather than 'CreditBalance storage creditBalance'.   This way, each of the subsequent reads of the creditBalance are read from memory (MLOAD) rather than read from storage (SLOAD), where MLOAD is cheaper than SLOAD.  ## Recommended Mitigation Steps  Change this:  CreditBalance storage creditBalance  To this:  CreditBalance memory creditBalance   [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L825  [2] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L823  "}, {"title": "PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender(). [1]  Nearly all of PrizePool.sol opts to use _msgSender() to provide for more optionality.   It appears that PrizePool.beforeTokenTransfer() may have been copy/pasted into PrizePool.sol without adjusting msg.sender to use _msgSender().  ## Recommended Mitigation Steps  Replace the seven instances of msg.sender in PrizePool.beforeTokenTransfer() with _msgSender()  [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  "}, {"title": "function _getRefferalCode() can be refactored to a constant variable", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _getRefferalCode() in ATokenYieldSource just returns a constant of uint16(188). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary.  ## Recommended Mitigation Steps  uint16 internal constant REFFERAL_CODE = uint16(188);  "}, {"title": "modifier canAddLiquidity and function _canAddLiquidity", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact modifier canAddLiquidity calls internal function _canAddLiquidity. This function is not called anywhere else so I do not see a reason why all the logic can't be moved to the modifier to save some gas by reducing the extra call.  ## Recommended Mitigation Steps Remove function _canAddLiquidity, place its logic directly in the canAddLiquidity modifier.  "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/7", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Most of the contracts set variables in the initialize function that are never changed. See for examples in the \"proof of concept\" section. Here the solidity keyword \"immutable\" could be added to the variables as an extra security measure.  ## Proof of Concept ControlledToken.sol:         TokenControllerInterface public override controller; StakePricePools.sol:           IERC20Upgradeable private stakeToken; YieldSourcePrizePool.sol:   IYieldSource public yieldSource; PrizePool.sol:                     RegistryInterface public reserveRegistry; PrizePool.sol:                     uint256 public maxExitFeeMantissa; PrizePool.sol:                     uint256 public maxTimelockDuration; BadgerYieldSource.sol       IBadgerSett private immutable badgerSett; BadgerYieldSource.sol       IBadger private immutable badger; YearnV2YieldSource.sol      IYVaultV2 public vault; YearnV2YieldSource.sol      IERC20Upgradeable internal token;  IdleYieldSource.sol            address public idleToken; IdleYieldSource.sol            address public underlyingAsset; ATokenYieldSource.sol       ATokenInterface public aToken; ATokenYieldSource.sol       ILendingPoolAddressesProviderRegistry public lendingPoolAddressesProviderRegistry;     SushiYieldSource.sol          ISushiBar public immutable sushiBar; SushiYieldSource.sol          ISushi public immutable sushiAddr;     ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  "}, {"title": "uint256(-1)", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact uint256(-1) is used in the function initialize of PrizePool.sol to indicate the max uint256 value. Solidity also allows type(uint256).max), which is easier to read.  ## Proof of Concept // https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L233 function initialize ( ...     _setLiquidityCap(uint256(-1));  ## Tools Used  ## Recommended Mitigation Steps Replace uint256(-1) with: type(uint256).max)  "}, {"title": "The `currentHour` variable in `Pricing` could be out of sync", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `recordTrade` function in `Pricing` updates the `currentHour` variable by 1 every hour. However, if there is no trade (i.e., the `recordTrade` is not called) during this hour, the `currentHour` is out of sync with the actual hour. As a result, the `averagePriceForPeriod` function uses the prices before 24 hours and causes errors on the average price.  ## Proof of Concept  Referenced code: [Pricing.sol#L90-L94](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L90-L94)  ## Recommended Mitigation Steps  Calculate how much time passed (e.g., `(block.timestamp - startLastHour) / 3600`) to update the `currentHour` variable correctly.  "}, {"title": "The `averagePriceForPeriod` function may revert without proper error message returned", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `averagePriceForPeriod` function of `LibPrices` does not handle the case where `j` equals 0 (i.e., no trades happened in the last 24 hours). The transaction reverts due to dividing by 0 without a proper error message returned.  ## Proof of Concept  Referenced code: [LibPrices.sol#L73](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPrices.sol#L73)  ## Recommended Mitigation Steps  Add `require(j > 0, \"...\")` before line 73 to handle this special case.  "}, {"title": "`Prices.averagePrice` does not show a difference between no trades and a zero price", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `getHourlyAvgTracerPrice` and `getHourlyAvgOraclePrice` functions in `Pricing` return 0 if there is no trade during the given `hour` because of the design of `averagePrice`, which could mislead users that the hourly average price is 0. The same problem happens when emitting the old hourly average in the `recordTrade` function.  ## Proof of Concept  Referenced code: [Pricing.sol#L254-L256](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L254-L256) [Pricing.sol#L262-L264](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L262-L264) [Pricing.sol#L74](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L74)  ## Recommended Mitigation Steps  Return a special value (e.g., `type(uint256).max`) from `averagePrice` if there is no trade during the specified hour to distinguish from an actual zero price. Handle this particular value whenever the `averagePrice` function is called by others.  "}, {"title": "Unlocked pragma used in multiple contracts", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/133", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Most of the contracts use an unlocked pragma (e.g., `pragma solidity ^0.8.0`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.6/)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  "}, {"title": "Gas savings in verifyAndSubmitLiquidation()", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Liquidation.verifyAndSubmitLiquidation(...) we can save the minimumMargin to memory since it's called two times.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L171  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Save the result of Balances.minimumMargin(...) to memory.  "}, {"title": "Change claimEscrow() to external", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The claimEscrow(...) function in Liquidation.sol can be set external instead of public since it's not used in the contract. (code clarity and gas savings)  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L109  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change public to external.  "}, {"title": "Logic error in fee subtraction", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/127", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In LibBalances.applyTrade() we need to collect a fee from the trade. The current code however subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol#L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change +fee to -fee in the highlighted line.  "}, {"title": "Gas savings in getPoolFundingRate()", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact We can save gas by substituting getPoolTarget() with levNotionalValue/100, since tracer.leveragedNotionalValue() is already saved in memory.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L216  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Substitute getPoolTarget() with levNotionalValue/100.  "}, {"title": "State variable not used", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact State variable perpsFactory is not used in the Insurance contract.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L18  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Just delete it.  "}, {"title": "Superfluous verifySignature function", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/121", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the trader contract isValidSignature(...) and verifySignature(...) serve the same purpose. Suggested keep only one for code clarity.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L206 https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L231  ## Tools Used Manual analysys  ## Recommended Mitigation Steps Suggested keep only one function for code clarity.  "}, {"title": "Use EIP-1167 in order to deploy new perpetual swap contracts", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  For every new TracerPerpetualSwaps contract, we need to deploy a new Liquidation, Insurance, and Pricing contract.  All these deployments are really gas-intensive, so it would be recommended to use EIP-1167: Minimal Proxy Contract to reduce the gas cost of the deployments.  ```solidity function _deployTracer(         bytes calldata _data,         address tracerOwner,         address oracle,         address fastGasOracle,         uint256 maxLiquidationSlippage     ) internal returns (address) {         // Create and link tracer to factory         address market = IPerpsDeployer(perpsDeployer).deploy(_data);         ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);          validTracers[market] = true;         tracersByIndex[tracerCounter] = market;         tracerCounter++;          // Instantiate Insurance contract for tracer         address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);         address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);         address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(             pricing,             market,             insurance,             fastGasOracle,             maxLiquidationSlippage         );          // Perform admin operations on the tracer to finalise linking         tracer.setInsuranceContract(insurance);         tracer.setPricingContract(pricing);         tracer.setLiquidationContract(liquidation);          // Ownership either to the deployer or the DAO         tracer.transferOwnership(tracerOwner);         ILiquidation(liquidation).transferOwnership(tracerOwner);         emit TracerDeployed(tracer.marketId(), address(tracer));         return market;     } ```   More info: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/ https://eips.ethereum.org/EIPS/eip-1167   "}, {"title": "Wrong trading pricing calculations", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/119", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the Pricing contract, an agent can manipulate the trading prices by spamming an high amount of trades.  Indeed an agent can create an high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent.  Since the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, letting a malicious agent get the ability to manipulate the market.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L129  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Pass the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade.  "}, {"title": "Unnecessary type conversions", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Superfluous type conversions.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L229-L230 The type conversion here is not necessary.  ## Recommended Mitigation Steps Remove the type conversion.  "}, {"title": "Missing checks for lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/117", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The contract TracerPerpetualSwaps introduces these four state variables (lowestMaxLeverage,  maxLeverage, insurancePoolSwitchStage and deleveragingCliff) and four respective set functions. Logically the following relations are needed: lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff, but the code doesn't check for them.  Non-critical because needs an error by the owner.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L552 Also lines L560, L564, L568  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add appropriate requires to the set functions and the constructor.  "}, {"title": "Underflow problems occurring when a token has >18 decimals", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The contracts assume that all tokens will have <=18 decimals. If the Tracer team are the only people deploying the contracts, and they keep this in mind, this isn't a problem. If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.   ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232 We can see that the scaler computations will underflow and be defined when it should not be.  ## Recommended Mitigation Steps Write a require check that ensures tokenDecimals <= 18 before running the above functions.  "}, {"title": "No check transferFrom() return value", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact The smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false. In the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. Other places: [TracerPerpetualSwaps: withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L203) [TracerPerpetualSwaps:withdrawFees](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L514) [SafetyWithdraw:withdrawERC20Token](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/SafetyWithdraw.sol#L13) [Insurance:withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L97)  ## Recommended Mitigation Steps Wrap the call into a require() or use openzeppelin's [SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library.  "}, {"title": "inclusive check that account is not above minimum margin", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Here the check currentMargin < Balances.minimumMargin should be inclusive <= to indicate the account is not above minimum margin:     require(         currentMargin <= 0 ||             uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),         \"LIQ: Account above margin\"     );  ## Recommended Mitigation Steps uint256(currentMargin) <= Balances.minimumMargin ...  "}, {"title": "amountToReturn > receipt.escrowedAmount could be inclusive", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Could save some gas here when amountToReturn = receipt.escrowedAmount:     if (amountToReturn > receipt.escrowedAmount) {        liquidationReceipts[receiptId].escrowedAmount = 0;     } else {        liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;     }  ## Recommended Mitigation Steps  if (amountToReturn >= receipt.escrowedAmount) { ...  "}, {"title": "Wrong funding index in settle when no base?", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:  > \"// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate\"  The code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.  ```solidity if (accountBalance.position.base == 0) {     // set to the last fully established index     // @audit shouldn't this be global - 1 like below?     accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;     accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer(); } ```   ## Impact It might be possible that first-time depositors skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.  ## Recommended Mitigation Steps Check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.  "}, {"title": "Insurance slippage reimbursement can be used to steal insurance fund", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/105", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Liquidation` contract allows the liquidator to submit \"bad\" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`. The function can be called with an `orders` array which does not check for duplicate orders. An attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.  Example: - Attacker uses two accounts, one as the liquidator and one as the liquidatee. - They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.) - Liquidator liquidates liquidatee - They now do two trades:   - One \"good\" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade   - One \"bad\" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade - The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the \"bad\" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit  This can be repeated until the insurance fund is drained.  ## Impact  The attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.  ## Recommended Mitigation Steps Disallow duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack. A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.  "}, {"title": "Can set values to more than 100%", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/102", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  There are several setter functions that do not check if the amount is less than 100%.  - `TracerPerpetualSwaps`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage` - `Insurance`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage`  ## Impact Setting values to more than 100% might lead to unintended functionality.  ## Recommended Mitigation Steps Ensure that the parameters are less than 100%.  "}, {"title": "Wrong token approval", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The pool holdings of `Insurance` (`publicCollateralAmount` and `bufferCollateralAmount`) is in WAD (18 decimals) but it's used as a raw token value in `drainPool`  ```solidity // amount is a mix of pool holdings, i.e., 18 decimals // this requires amount to be in RAW! if tracerMarginToken has > 18 decimals, it'll break, < 18 decimals will approve too much tracerMarginToken.approve(address(tracer), amount); // this requires amount to be in WAD which is correct tracer.deposit(amount); ```  ## Impact  If `tracerMarginToken` has less than 18 decimals, the approval approves orders of magnitude more tokens than required for the `deposit` call that follows. If `tracerMarginToken` has more than 18 decimals, the `deposit` that follows would fail as fewer tokens were approved, but the protocol seems to disallow tokens in general with more than 18 decimals.  ## Recommended Mitigation Steps Convert the `amount` to a \"raw token value\" and approve this one instead.   "}, {"title": "Wrong price scale for `GasOracle`", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/93", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.  However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it's in 18 decimals.  > \"Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\"  There is a `toWad` function that seems to involve scaling but it is never used.  ## Impact** If the scale is wrong, the gas price can be heavily inflated or under-reported.   ## Recommended Mitigation Steps Check `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.  "}, {"title": "LibMath sumN can iterate over array", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/89", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  When `LibMath.sumN` function does not check if `n <= arr.length` and can therefore fail if called with `n > arr.length`.  ## Impact The caller must always check that it's called with an argument that is less than `n` which is inconvenient.  ## Recommendation Change the condition to iterate up to `min(n, arr.length)`.   "}, {"title": "LibMath fails implicitly", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details   When `LibMath.abs` is called with -2^255 (`type(int256).min`), it tries to multiply it by `-1` but it'll fail as it exceeds the max signed 256-bit integers.  ## Impact The function will fail with an implicit error that might be hard to locate.  ## Recommendation Throw an error similar to `toInt256` like `int256 overflow`.   "}, {"title": "Potential division by zero\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In function minimumMargin(), maximumLeverage being zero is not handled because it will result in div by zero as PRBMathUD60x18.div expects non-zero divisor.   Impact: Various critical market functions will revert if maximumLeverage is zero.  ## Proof of Concept  https://github.com/hifi-finance/prb-math/blob/c4dea7d0e6ae246fbb631f7fb4be4072d1da9a07/contracts/PRBMathUD60x18.sol#L71-L77   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L118  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L135  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L186  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L242  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L248  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add checks to make sure maximumLeverage is never zero or handle appropriately.  "}, {"title": "Malicious owner can drain the market at any time using SafetyWithdraw\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/81", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawERC20Token() in SafetyWithdraw inherited in TracerPerpetualSwaps is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.   Alternatively, if this is meant for the owner to withdraw \u201cexternal\u201d ERC20 tokens mistakenly deposited to the Tracer market then the function should exclude tracerQuoteToken from being the tokenAddress that can be used as a parameter to withdrawERC20Token().  Impact: Malicious owner of a market withdraws/rugs all tracerQuoteTokens deposited at any time after market launch. All users lose deposits. Protocol takes a reputational hit and has to refund the users from treasury.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/SafetyWithdraw.sol#L8-L14  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  For a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused  (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the tracerQuoteToken from being given as the tokenAddress.   "}, {"title": "Missing length check on array could lead to undefined behavior", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The sumN() library function expects to calculate the sum of n elements of the supplied array but there is no check to see if the array indeed has n elements. A smaller array could lead to reading out of bounds memory resulting in undefined values.  Impact: The current usage of the library does not indicate an out of bounds access but any new code using this library could be impacted.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L38-L46  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L68  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibPrices.sol#L73   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(n <= arr.length) at the beginning of sumN() to be safe.  "}, {"title": "setDecimals can be set by anyone and not used", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The setDecimals() in the sample Gas Price Oracle implementation allows anyone to set the decimals value used by the contract but is not used anywhere.  Impact: It is unclear if this should be set by anyone and if that value should be used in determining the precision of the values returned.  ## Proof of Concept   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L64-L66   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if this access and missing logic is correct.  "}, {"title": "Close-ended time ranges may confuse users/interfaces", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Time ranges are typically open-ended which includes the start & end times, and not close-ended. So the releaseTime would be interpreted as the time it would be released i.e. block.timestamp >= releaseTime would be the expected check here instead of \u2018>\u2019. Similarly, on L406, it should be \u2018<=\u2018 instead of \u2018<\u2018.  Impact: Claims of escrow and receipts are expected to succeed in a particular block but they revert and have to wait until the next block.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L112  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L406  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Unless justified, change the strict inequality and make it \u2018>=\u2018 and \u2018<=\u2018 to convert open ranges to closed ranges for block.timestamp comparisons.  "}, {"title": "Use of incorrect index leads to incorrect updation of funding rates", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/74", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The updateFundingRate() function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of [currentFundingIndex] which has been updated since the previous call to this function while it should really be using [currentFundingIndex-1] to reference the previous funding rate.  Impact: The cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and protocol takes a reputation hit.   ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L155-L160  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L168  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L77  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L196-L215  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L221-L230  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L445-L446  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use [currentFundingIndex-1] for non-zero values of currentFundingIndex to get the value updated in the previous call on lines L155 and L159 of Pricing.sol.  "}, {"title": "Potential Out-of-Gas exception due to unbounded loop", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact Trading function executeTrade() batch executes maker/taker orders against a market. The trader/interface provides arrays of makers/takers which is unbounded. As a result, if the number of orders is too many, there is a risk of this transaction exceeding the block gas limit (which is 15 million currently).  Impact: executeTrade() is called with too many orders in the batch. Tx exceeds block gas limit and reverts. None of the orders are executed.  ## Proof of Concept  See similar Medium-severity finding from ConsenSys's Audit of Growth DeFi: https://consensys.net/diligence/audits/2020/12/growth-defi-v1/#potential-resource-exhaustion-by-external-calls-performed-within-an-unbounded-loop  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L67  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L78  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Limit the number or orders executed based on gasleft() after every iteration or estimate the gas cost and enforce an upper bound on the number of orders allowed in maker/taker arrays.  "}, {"title": "Malicious owner can arbitrarily change fee to any % value\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.  Impact: Users trade on a market with 0.1% fees. The owner suddenly changes this to 100%. Users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.  ## Proof of Concept  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L548-L550  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L198-L214  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event, provide time lock for users to react and establish an upper threshold for fees that is decided across markets by governance.  "}, {"title": "Event log poisoning/griefing in withdrawFees()\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  withdrawFees() is an external function which can be called by anyone to transfer the accumulated fees to the feeReceiver account. However, there is no data validation to check if fees are non-zero.  Impact: One can keep calling withdrawFees(), even if the fees is zero, to grief the system with 0 amount transfers and emission of events recording the same. This leads to what is known as event log poisoning where malicious external users spam the Tracer contract to generate arbitrary FeeWithdrawn events.  ## Proof of Concept  See similar Finding from Sigma Prime\u2019s audit of Synthetix Unipool: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L508-L516  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider adding a require or if statement preventing the withdrawFees() function from emitting the event when the amount variable is zero, i.e. check if fees != 0 before transfer+emit.  "}, {"title": "function which can declared as external ", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact public function which are not called within contract should be declared as external to save gas  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L572  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L470  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/InsurancePoolToken.sol#L14  ## Tools Used  manual review  ## Recommended Mitigation Steps  Declare public function as external which are not called in the contract  "}, {"title": "Dangerous use of storage data location specifier", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Reference type local variables require an explicit data location specified indicating if they need to be in storage or memory. Assigning state variables to storage local variables creates a reference  (instead of a copy) to the state variable and modifications to the local variable will be reflected in the state variable. This is required if the intention is to make updates to state variables. Unnecessarily using storage specifiers may lead to unintentional updates of state variables and has led to vulnerabilities.  In L457 of settle(), a local variable insuranceBalance is created in storage to point to balances[address(insuranceContract)] but is never updated. Instead balances[address(insuranceContract)] itself is updated on L474.  Impact: While there is no immediate impact, any modifications to the code with insuranceBalance will be dangerous because it will update the critical state variable balances[address(insuranceContract)]. It is safer to use a memory specifier for insuranceBalance.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L456-L457  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L467  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L474  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace the use of storage specifier on L457 with memory.  "}, {"title": "tvl calculation in withdraw() should use convertedWadAmount instead of amount", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The tvl calculation in deposit() uses convertedWadAmount but the one in withdraw() uses the parameter amount. While amount is still in WAD format, it may contain dust which is what the conversion to rawTokenAmount and then back to convertedWadAmount removes.  Impact: Use of amount in tvl during withdraw() will consider dust while the one in deposit() will not, which is inconsistent.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L200  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L176-L177  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use convertedWadAmount instead of amount to be consistent with the increment during withdraw() tvl calculation.  "}, {"title": "Deposit event should use the converted WAD amount", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The Deposit event uses the function parameter amount instead of the convertedWadAmount which is what is used to update the user\u2019s position and tvl because it prevents any dust deposited in amount. This will also make it consistent with the emit event in withdraw function.  Impact: Deposit event amount reflects the value with dust while the user position does not. This may lead to confusion.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L163  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L204  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use uint256(convertedWadAmount) instead of amount in Deposit event.  "}, {"title": "executionPrice, newMakeAverage and newTakeAverage before calling the market", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Trader function executeTrade calculates executionPrice, newMakeAverage, newTakeAverage, then calls the market, and only if it succeeds it uses these variables.  ## Recommended Mitigation Steps Better first call the market and only then calculate and use these variables to avoid useless calculations and gas costs.  "}, {"title": "recalculation of 10**18", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Insurance function drainPool calculates 10**18 many times. To reduce the number of calculations and save gas, this number can be extracted as a constant variable and used everywhere where necessary.  ## Recommended Mitigation Steps Extract 10**18 as a constant.  "}, {"title": "LIQUIDATION_GAS_COST may not be a constant\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The gas cost for liquidation may change if code is updated/optimized, compiler changed or profiling improved. The developers may forget to update this constant in code.  Impact: The margin validity calculation which uses this value may be affected if this changes and hence is not as declared in the constant. This may adversely impact validation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L26  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L244  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L250  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L494  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L159  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L193  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  It is safer to make this a constructor-set immutable value that will force usage of an updated accurate value at deployment time. Evaluate if the sensitivity to this value is great enough to justify a setter to change it if incorrectly initialized at deployment.  "}, {"title": "orders and orderToSig mappings", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contract Trader has 2 mappings: orders and orderToSig. I see that orderToSig also stores Perpetuals.Order inside it, so I wonder if it really was necessary to separate these mappings as some state (order) is duplicated among them. It may be a bit more efficient to access orders without signatures but it also makes it more error-prone as you need to keep the invariant that orders match in these mappings. Currently I don't see an exact problem as orderToSig are only set in function grabOrder and never used in code anywhere but I am not sure if it is really necessary.   Tracer representetive's answer on Discord: 'Yeah thats a good point on the Trader mapping, one does look redundant now as they both store the order itself. I think originally one was mutated and one wasn't, but then that functionality got moved into the filled mapping anyway. Seems safe to remove orders and simply reference the orderToSig mapping'.  ## Recommended Mitigation Steps Remove orders and simply reference the orderToSig mapping.  "}, {"title": "state variable which can be declared as immutable", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact state variable which have to initialise in constructor can be declared as immutable to save gas  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L23  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L20  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L30  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L31  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L17  ## Tools Used  manual review  "}, {"title": "Unused State variable", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Unused state variable will increase unnecessarily code size and use the memory  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L19  ## Tools Used  manual review  ## Recommended Mitigation Steps  remove the variable which are unused  "}, {"title": "[Gas] Use at least 0.8.0 instead of 0.8.4", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## Use at least 0.8.4 instead of 0.8.0  It has an important optimization improvement: a low level inliner. Especially since you have several small functions.  The current hardhat config indicates that version `0.8.0` is being used.    "}, {"title": "[Gas] Change some function parameters from `memory` to `calldata`", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## For function arguments, change `memory` to `calldata`  There are several places where this is applicable, however, will point out one such occasion:  ``` diff modified   src/contracts/Trader.sol @@ -64,7 +64,7 @@ contract Trader is ITrader {       * @param makers An array of signed make orders       * @param takers An array of signed take orders       */ -    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) +    function executeTrade(Types.SignedLimitOrder[] calldata makers, Types.SignedLimitOrder[] calldata takers)          external          override      { @@ -144,7 +144,7 @@ contract Trader is ITrader {       * @dev Should only be called with a verified signedOrder and with index       *      < signedOrders.length       */ -    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index) +    function grabOrder(Types.SignedLimitOrder[] calldata signedOrders, uint256 index)          internal          returns (Perpetuals.Order memory)      { ```  Reason: when you specify `memory` for a (non value type) function-parameter for an external function, the following happens: the compiler would copy elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Then later on, the internal call (here `grabOrder`) would pass a memory reference. However, this is a great example of where copying to memory is unnecessary. Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  You would only have to use `memory` if the function has to modify the parameter, in which case a copy is really needed as `calldata` cannot be modified.    "}, {"title": "Using array memory parameter without checking its length ", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact These array memory parameter can be  problematic if not used properly , if the array is very large it may overlap over other part of memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L274  This an example to show the exploit: // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol pragma solidity ^0.4.24; // only works with low solidity version  contract test{ struct Overlap { uint field0; } event log(uint);  function mint(uint[] memory amounts) public returns (uint) {  // this can be in any solidity version Overlap memory v; v.field0 = 1234; emit log(amounts[0]); // would expect to be 0 however is 1234 return 1; }  function go() public { // this part requires the low solidity version uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251 bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x); bool success=address(this).call(payload); } } ## Tools Used  manual review  ## Recommended Mitigation Steps  check array length before using it  "}, {"title": "avoid paying insurance", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact It's possible to avoid paying insurance in the following way: - once per hour (at the right moment), do the following: ----using a flash loan, or with a large amount of tokens, call deposit of Insurance.sol to make sure that the pool is sufficiently filled (poolHoldings > poolTarget) ----call the function executeTrade of Trader.sol with a minimal trade (possibly of value 0, see finding \"executeTrade with same trades\") ----executeTrade calls matchOrders, which calls recordTrade ----recordTrade calls updateFundingRate();   (once per hour, so you have to be sure you do it in time before other trades trigger this) ----updateFundingRate calls getPoolFundingRate ----getPoolFundingRate determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0 ----updateFundingRate stores the 0 rate via setInsuranceFundingRate  (which is used later on to calculate the amounts for the insurances) ----withdraw from the Insurance and pay back the flash loan  The insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack This will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.  ## Proof of Concept  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L45 function deposit(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L74 function withdraw(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L69      function recordTrade(uint256 tradePrice) external override onlyTracer {       ..         if (startLastHour <= block.timestamp - 1 hours) {            ..             updateFundingRate();  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L141 function updateFundingRate() internal {       ..         int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();       ..         int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;      ..         setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L204 function getPoolFundingRate() external view override returns (uint256) {      ..         // If the pool is above the target, we don't pay the insurance funding rate         if (poolTarget <= poolHoldings) {             return 0;         }  ## Tools Used  ## Recommended Mitigation Steps Set a timelock on withdrawing insurance   "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Some of the contracts set variables in the initialize function that are never changed. See for examples in the \"proof of concept\" section. Here the solidity keyword \"immutable\" could be added to the variables as an extra security measure.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L17     address public tracer;     IInsurance public insurance;     IOracle public oracle;          https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L24     uint256 public override maxSlippage;     IPricing public pricing;     ITracerPerpetualSwaps public tracer;     address public insuranceContract;     address public fastGasOracle;          //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L20       address public collateralAsset; // Address of collateral asset      address public token; // token representation of a users holding in the pool      ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool   ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  "}, {"title": "Comment in claimEscrow", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function claimEscrow of Liquidation.sol can be called by everyone. The claimed funds go to the trader so there are no funds at risk. However the comment says the traders is doing this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L106 /**      * @notice Allows a trader to claim escrowed funds after the escrow period has expired      * @param receiptId The ID number of the insurance receipt from which funds are being claimed from      */     function claimEscrow(uint256 receiptId) public override {   ## Tools Used  ## Recommended Mitigation Steps Double check and it the code works as intended adapt the comment. Otherwise add check that only the trader can call the function.  "}, {"title": "Variables that can be converted into immutables", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Impact  Several variables can be converted into immutables. Doing so can save 2100 gas for storage reads when the slot is warm and 100 otherwise.  ``` Notice: Variable declaration can be converted into an immutable.   --> @openzeppelin/contracts/token/ERC20/ERC20.sol:38:5:    | 38 |     uint256 private _totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:18:5:    | 18 |     ITracerPerpetualsFactory public perpsFactory;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:20:5:    | 20 |     address public collateralAsset; // Address of collateral asset    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:23:5:    | 23 |     address public token; // token representation of a users holding in the pool    |     ^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:25:5:    | 25 |     ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:28:5:    | 28 |     IPricing public pricing;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:29:5:    | 29 |     ITracerPerpetualSwaps public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:30:5:    | 30 |     address public insuranceContract;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:31:5:    | 31 |     address public fastGasOracle;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:17:5:    | 17 |     address public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:18:5:    | 18 |     IInsurance public insurance;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:19:5:    | 19 |     IOracle public oracle;    |     ^^^^^^^^^^^^^^^^^^^^^ ```  ## Proof of Concept  References to source file and line numbers can be seen above.  ## Tools Used  A custom solidity compiler.  ## Recommended Mitigation Steps  As explained above, these variables can be converted into immutables.  "}, {"title": "make sure withdrawFees allways can withdraw", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact If you call the function withdrawFees and the \"tvl\" would not be enough for the fee then the code would revert. In this case the fees cannot be withdrawn. Although it is unlikely that the tvl would be wrong it is probably better to be able to withdraw the remaining fees.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L508 function withdrawFees() external override {         uint256 tempFees = fees;         fees = 0;         tvl = tvl - tempFees;          // Withdraw from the account         IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);         emit FeeWithdrawn(feeReceiver, tempFees);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like: tempFees = min (fees, tvl); and change fees=0 to: fees -= tempFees;  "}, {"title": "Comment in partialLiquidationIsValid misleading", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The comments for partialLiquidationIsValid indicate that the params are in WAD format (except liquidationGasCost) However the parameter minimumLeftoverGasCostMultiplier originates from Liquidation.sol and has the value 10. So it is not in WAD format and the comment is misleading.  ## Proof of Concept //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L149  @dev Assumes params are WAD except liquidationGasCost  function partialLiquidationIsValid(         Balances.Position memory updatedPosition,         uint256 lastUpdatedGasPrice,         uint256 liquidationGasCost,         uint256 price,         uint256 minimumLeftoverGasCostMultiplier     )   //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L27 uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Update the comment   "}, {"title": "check sign in calculateSlippage", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/17", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In function calculateSlippage of LibLiquidation.sol, the value of amountToReturn is calculated by subtracting to numbers. Later on it is check if this value is negative. However amountToReturn is an unsigned integer so it can never be negative. If a negative number would be attempted to be assigned, the code will revert, because solidity 0.8 checks for this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L106 function calculateSlippage( ...             uint256 amountToReturn = 0;             uint256 percentSlippage = 0;             if (avgPrice < receipt.price && receipt.liquidationSide == Perpetuals.Side.Long) {                 amountToReturn = amountExpectedFor - amountSoldFor;             } else if (avgPrice > receipt.price && receipt.liquidationSide == Perpetuals.Side.Short) {                 amountToReturn = amountSoldFor - amountExpectedFor;             }             if (amountToReturn <= 0) {    // can never be smaller than 0, because amountToReturn is uint256                 return 0;             }  ## Tools Used  ## Recommended Mitigation Steps Double check if amountToReturn could be negative. If this is the case change the type of amountToReturn to int256 and add the appropriate type casts   "}, {"title": "Comment for formula calcEscrowLiquidationAmount different than code", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The comment for the formula in calcEscrowLiquidationAmount is:  currentMargin - (minMargin - currentMargin) * portion  however it is coded as:  {currentMargin - (minMargin - currentMargin)} * portion  According to Ray/Lions mane the comment is wrong  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L32 //       Calculated as currentMargin - (minMargin - currentMargin) * portion of whole position being liquidated function calcEscrowLiquidationAmount( ..         int256 amountToEscrow = currentMargin - (minMargin.toInt256() - currentMargin);         int256 amountToEscrowProportional = PRBMathSD59x18.mul(amountToEscrow, PRBMathSD59x18.div(amount, totalBase));   ## Tools Used  ## Recommended Mitigation Steps Fix the comment  "}, {"title": "alternative solidity coding", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Solidity allows some tricks to make the code easier to read:     LibMath.sol:     uint256 public constant POSITIVE_INT256_MAX = 2**255 - 1;     uint256 public constant POSITIVE_INT256_MAX = uint(type(int256).max);   // alternative coding  Insurance.sol:     uint256 public multiplyFactor = 36523 * (10**11);     uint256 public multiplyFactor = 0.0036523e18;   // alternative coding   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Use the most readable coding   "}, {"title": "Use constants for numbers", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact At several places constants are hardcoded as numbers. It's more readable and more maintainable to turn them into explicit constants. That also lowers to risk to change it on one place and forget is on another place. See examples in proof of concept  ## Proof of Concept .\\Insurance.sol:            if (publicCollateralAmount > 10**18) { .\\Insurance.sol:                amount = poolHoldings - 10**18; .\\Insurance.sol:                publicCollateralAmount = 10**18; .\\Insurance.sol:            if (publicCollateralAmount < 10**18) { .\\Insurance.sol:            } else if (poolHoldings - amount < 10**18) { .\\Insurance.sol:                amount = poolHoldings - 10**18; .\\Insurance.sol:                publicCollateralAmount = 10**18; .\\Insurance.sol:            uint256 multiplyFactor = 36523 * (10**11); .\\Insurance.sol:        return tracer.leveragedNotionalValue() / 100; .\\oracle\\GasOracle.sol:    uint8 public override decimals = 18; .\\lib\\libprices.sol:       for (uint256 i = 0; i < 8; i++) { .\\lib\\libprices.sol:           uint256 currTimeWeight = 8 - i; .\\lib\\LibPrices.sol:        return (averageTracerPrice.toInt256() - averageOraclePrice.toInt256()) / 90; .\\lib\\LibBalances.sol:        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6; .\\lib\\LibPerpetuals.sol:        percentFull = percentFull * 100; // To bring it up to the same percentage units as everything else .\\Liquidation.sol:    uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Replace numeric values with constants   "}, {"title": "todos left in the code", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There are several todos left in the code.  ## Proof of Concept .\\Pricing.sol:                     // todo by using public variables lots of these can be removed .\\Trader.sol:                      // todo this could be succeptible to re-entrancy as .\\lib\\LibLiquidation.sol:    // todo with the below * -1, note ints can overflow as 2^-127 is valid but 2^127 is not. .\\lib\\LibPrices.sol:             // todo double check safety of this.  ## Tools Used  ## Recommended Mitigation Steps Check, fix and remove the todos before it is deployed in production    "}, {"title": "prb-math not audited", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The library prb-math documents that it is not audited by a security researcher.  This means its more risky to rely on this library.  ## Proof of Concept // https://github.com/hifi-finance/prb-math#security The contracts have not been audited by a security researcher.      ## Tools Used  ## Recommended Mitigation Steps Consider (crowdsourcing) an audit for prb-math   "}, {"title": "Only one constructor with an emit", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The constructor of Insurance.so does an emit. However the constructors of the other contracts (InsurancePoolToken.sol, Liquidation.sol, Pricing.sol, TracerPerpetualSwaps.sol, TracerPerpetualsFactory.sol, Trader.sol) don't do an emit in the constructor.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L31 constructor(address _tracer) {      ...         emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());     }  ## Tools Used  ## Recommended Mitigation Steps Perhaps it's useful for other constructor to also include an emit   "}, {"title": "matchOrders could/should check market", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function matchOrders of TracerPerpetualSwaps.sol doesn't check that the contract itself is indeed equal to order1.market and order2.market. The function executeTrade Trader.sol, which calls the matchOrders, can deal with multiple markets. Suppose there would be a mistake in executeTrade,  or in a future version, the matchOrders would be done in the wrong market.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L216 function matchOrders( Perpetuals.Order memory order1, Perpetuals.Order memory order2, uint256 fillAmount )   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67  function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external  override { ...  (bool success, ) = makeOrder.market.call(                 abi.encodePacked(                     ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,                     abi.encode(makeOrder, takeOrder, fillAmount)                 )             );   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPerpetuals.sol#L128 function canMatch( Order memory a, uint256 aFilled,Order memory b, uint256 bFilled ) internal view returns (bool) {     ...         bool marketsMatch = a.market == b.market;  ## Tools Used  ## Recommended Mitigation Steps Add something like: require ( order1.market == address(this), \"Wrong market\");  Note: canMatch already verifies that  order1.market== order2.market   "}, {"title": "Claim liquidation escrow", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A liquidator can always claim the liquidation escrow in the following way: - create a second account - setup a complimentary trade in that second account, which will result in a large slippage when executed - call executeTrade (which everyone can call), to execute a trade between his own two accounts with a large slippage - the slippage doesn't hurt because the liquidator owns both accounts - call claimReceipt with the receiptId of the executed order, within the required period (e.g. 15 minutes)  ## Proof of Concept   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67 function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {  https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394  function claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {  ## Tools Used  ## Recommended Mitigation Steps perhaps limit who can call executeTrade   "}, {"title": "More accurate calculation of return USD of `withdrawSingleByLiquidity`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/121", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `withdrawSingleByLiquidity` function of `LifeGuard3Pool` calls `buoy.singleStableToUsd` to calculate the return USD amount, which internally calls `_stableToUsd` with the `deposit` parameter set to `true`. A more accurate calculation is to set the `deposit` parameter to `false` since this action is a withdrawal. A similar issue exists in the function `calcProtocolWithdraw` of `Allocation`, where the current strategy's USD is calculated by `buoy.singleStableToUsd`.  ## Proof of Concept  Referenced code: [LifeGuard3Pool.sol#L226](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/LifeGuard3Pool.sol#L226) [Buoy3Pool.sol#L122](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L122) [Allocation.sol#L142](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L142)  ## Recommended Mitigation Steps  Consider adding a new boolean parameter, `deposit`, to the `singleStableToUsd` function of `Buoy3Pool` to indicate whether the action is a deposit or not, as that in the `stableToUsd` and `stableToLp` functions.  "}, {"title": "BaseVaultAdaptor assumes `sharePrice` is always in underlying decimals", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The two `BaseVaultAdaptor.calculateShare` functions computes `share = amount.mul(uint256(10)**decimals).div(sharePrice)`  ```solidity uint256 sharePrice = _getVaultSharePrice(); // amount is in \"token\" decimals, share should be in \"vault\" decimals share = amount.mul(uint256(10)**decimals).div(sharePrice); ```  This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.  This both happens to be the case for Yearn vaults, but will not necessarily be the case for other protocols. As this functionality is in the `BaseVaultAdaptor` and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.  ## Impact Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.  ## Recommended Mitigation Steps The conversion seems highly protocol specific, `calculateShare` should be an abstract function like `_getVaultSharePrice`, that is implemented in the specific adaptors.  "}, {"title": "Usage of deprecated ChainLink API in `Buoy3Pool`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The Chainlink API (`latestAnswer`) used in the `Buoy3Pool` oracle wrappers is deprecated:  > This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)  ## Impact It seems like the old API can return stale data. Checks similar to that of the new API using `latestTimestamp` and `latestRoundare` are needed. This could lead to stale prices according to the Chainlink documentation: * [under current notifications: \"if answeredInRound < roundId could indicate stale data.\"](https://docs.chain.link/docs/developer-communications#current-notifications) * [under historical price data: \"A timestamp with zero value means the round is not complete and should not be used.\"](https://docs.chain.link/docs/historical-price-data#solidity)  ## Recommended Mitigation Steps Add the recommended checks: ```solidity (     uint80 roundID,     int256 price,     ,     uint256 timeStamp,     uint80 answeredInRound ) = chainlink.latestRoundData(); require(     timeStamp != 0,     \u201cChainlinkOracle::getLatestAnswer: round is not complete\u201d ); require(     answeredInRound >= roundID,     \u201cChainlinkOracle::getLatestAnswer: stale data\u201d ); require(price != 0, \"Chainlink Malfunction\u201d); ```  "}, {"title": "`Buoy3Pool.safetyCheck` is not precise and has some assumptions", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/104", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `safetyCheck` function has several issues that impact how precise the checks are:  1. only checks if the `a/b` and `a/c` ratios are within `BASIS_POINTS`. By transitivity `b/c` is only within `2 * BASIS_POINTS` if `a/b` and `a/c` are in range. For a more precise check whether both USDC and USDT are within range, `b/c` must be checked as well.  2. If `a/b` is within range, this does not imply that `b/a` is within range. > \"inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions\"  Example: `lastRatio = 1.0` `ratio: a = 1.0, b = 0.8` => `a/b = 1.25`, `b/a = 0.8` If `a/b` was used with a 20% range, it'd be out of range, but `b/a` is in range.  3. The natspec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both `_ratio` and `lastRatio` are only from Curve. Only `_updateRatios` checks the oracle.  ## Recommended Mitigation Steps In addition, check if `b/c` is within `BASIS_POINTS`.  "}, {"title": "`Allocaiton.calcProtocolExposureDelta` gas optimization", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `Allocaiton.calcProtocolExposureDelta` should break out of the loop to save gas after `protocolExposedDeltaUsd` is set.  ```solidity if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {     // ...Calculate the delta between exposure and target     uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);     protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(         PERCENTAGE_DECIMAL_FACTOR     );     protocolExposedIndex = i;     // @audit break here } ```  "}, {"title": "Wrong min amount check in `withdrawByStablecoin`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `WithdrawHandler.withdrawByStablecoin` incorrectly uses the `lpAmount` instead of the `minAmount` in the check.  ```solidity require(lpAmount > 0, \"!minAmount\"); ```  ## Recommended Mitigation Steps Use `minAmount > 0` if trying to check for `!minAmount` or use a different error message for an invalid LP amount.  "}, {"title": "Inconsistent usage of exponentiation for constants", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact Detailed description of the impact of this finding. See Constants.sol, where you use 10**DECIMALS: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Constants.sol#L7  VS  FixedContracts.sol, where you use 1E6: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/FixedContracts.sol#L13  While both expressions result in the same values, I recommend picking one to avoid potential confusion     "}, {"title": "setBigFishThreshold above 100%", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/80", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setBigFishThreshold should require that _percent is not above PERCENTAGE_DECIMAL_FACTOR if it is not intended to have it over 100%.  ## Recommended Mitigation Steps require _percent <= PERCENTAGE_DECIMAL_FACTOR  "}, {"title": "Unused code", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract LifeGuard3Pool has unused events: LogHealhCheckUpdate, LogNewEmergencyWithdrawal. Interfaces IHarvest and IStake are not used. contract Buoy3Pool has unused variable TIME_LIMIT and a variable that is only initialized but never used: lpToken.  Style issue: BASIS_POINTS all caps indicate it should be a constant, however, an owner can change it by calling function setBasisPointsLmit.  ## Recommended Mitigation Steps Make use of this code or remove it.   "}, {"title": "Incorrect use of operator leads to arbitrary minting of GVT tokens", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeStrategyGainLoss() function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on msg.sender by checking that vaultIndexes[msg.sender] is a valid index range 1-4. However the operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.  Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in vaultIndexes[msg.sender] which will fail the > 0 check but pass the <= N_COINS + 1 check (N_COINS = 3) because 0 <= 4 which will allow control to go past this check. Furthermore, on L362, index=0 will underflow the -1 decrement (due to lack of SafeMath.sub and use of < 0.8.0 solc) and index will be set to (uint256_MAX - 1). This will allow execution to proceed to the else part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.   ## Proof of Concept  The attack control flow: -> Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0) -> index = 0 passes check for the index <= N_COINS + 1 part of predicate on L357 in Controller.sol -> index = uint256_MAX after L362 -> gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN); on L371 in Controller.sol -> ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward); on L376 in Controller.sol -> (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward); on L254 in PnL.sol -> performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR); on L186 of PnL.sol ->  gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus); on L256 in PnL.sol  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L355  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L356-L357  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L362  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L370-L371  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L376  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L253-L258  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or consider explicit access control for the authorized vault adaptors.  "}, {"title": "Use of uninitialized value and unclear/unused logic", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  vaultIndexes is uninitialized and it's unclear what 10000 signifies here. investDelta return value is also ignored at call site. If this is an indication of missed/incorrect logic, then it's risky. If not, removing will help readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L166  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate any missing logic or else remove unused code.  "}, {"title": "Vault assets can be migrated to an arbitrary address at anytime by owner", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  BaseVaultAdaptor contains logic that is \u201cbuilt on top of any vault in order for it to function with Gro protocol.\u201d One of such functions is the migrate() function which is onlyOwner and takes an address parameter which allows owner to migrate vault\u2019s entire balance at any time to that address. This is extremely risky because it gives an opportunity for, at least a perception of, rug-pull by a disgruntled/malicious owner/dev to the protocol users/community. This could also be dangerous if triggered accidentally especially by an EOA owner address or maliciously via compromised keys.  Scenario1: Protocol launches and starts accumulating TVL. A savvy user analyzes source and shares the presence of this migrate() function as potential owner rug-pull vector. Users withdraw funds and protocol reputation takes a hit.  Scenario 2: Protocol launches and hits 100MM TVL. A disgruntled dev/owner migrates vault assets to their address and drains the protocol.  Scenario 3: Protocol launches and hits 100MM TVL. Owner EOA keys get compromised and attacker migrates vault assets to their address and drains the protocol.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L294-L302  See similar concern on migrate() functionality in ShibaSwap recently: Yearn dev https://twitter.com/bantg/status/1412370758987354116 https://twitter.com/bantg/status/1412388385663164425 Others https://twitter.com/valentinmihov/status/1412352490918625280 https://twitter.com/shegenerates/status/1412642215537545218   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the need for this function and avoid/mitigate risk appropriately.  "}, {"title": "Incorrect error strings used may cause confusion", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Error strings used in require checks should accurately reflect the failing condition. Use of informative/accurate error messages helps troubleshoot exceptional conditions during transaction failures or unexpected behavior. Otherwise, it can be misleading and waste crucial time during exploits or emergency conditions.   While the codebase has this correct in most places, there are a few places where there appears to be a copy/paste error:  Example 1: require(msg.sender == withdrawHandler || msg.sender == insurance, \"depositStable: !depositHandler\");  The error string should indicate \u201c!withdrawHandler/insurance\u201d instead of \u201c!depositHandler\u201d  Example 2: require(msg.sender == _controller().insurance(), \"withdraw: !withdrawHandler/insurance\");  The error string should only indicate \u201c!insurance\u201d instead of \u201c!withdrawHandler/insurance\u201d  ## Proof of Concept  For reference, see Note 2 in OpenZeppelin's Audit of Compound Governor Bravo: https://blog.openzeppelin.com/compound-governor-bravo-audit/  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L206-L211  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L228  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L162  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L285  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L405   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check/fix error strings.  "}, {"title": "Safe addresses can only be added but not removed", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The addSafeAddress()  takes an address and adds it to a \u201csafe list\". This is used in eoaOnly() to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.  Scenario: A trusted integration/partner address is added to safe list. But that wallet/protocol/DApp is later manipulated (by project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L171-L174  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L176-L178  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L266-L272   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both enabling/disabling of safe addresses.  "}, {"title": "Missing zero-address check and event parameter for _emergencyHandler", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Controller setWithdrawHandler() is missing a zero-address check and event parameter for _emergencyHandler which is the more critical (used rarely but in an emergency incident-response that is always time-critical ) of the two addresses.  Scenario: setWithdrawHandler() is accidentally called with _emergencyHandler = 0 address. Without a check or an event here, this error goes unnoticed (unless caught in the event from WithdrawHandler::setDependencies). There is an emergency triggered after which withdrawals are attempted via the emergencyHandler but they fail because of the zero address. The correct non-zero emergencyHandler has to be set again. Valuable time is lost and funds are lost.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105-L110  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L129  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check and event parameter for _emergencyHandler  "}, {"title": "Missing emits for declared events", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/47", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing emits for declared events indicate potentially missing logic, redundant declarations or reduced off-chain monitoring capabilities.  Scenario: For example, the event LogFlashSwitchUpdated is missing an emit in Controller. Based on the name, this is presumably related to flash loans being enabled/disabled which could have significant security implications. Or the (misspelled) LogHealhCheckUpdate which is presumably related to a health check logic that is missing in LifeGuard.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L83  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L48  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L61  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L62  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if logic is missing and add logic+emit or remove event.  "}, {"title": "Single-step process for critical ownership transfer is risky", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The Controller contract is arguably the most critical contract in the project for access control management (it has 17 onlyOwner functions). Given that it is derived from Ownable, the ownership management of this contract (also Whitelist and Controllable) defaults to Ownable\u2019s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  The same applies to the changing of controller\u2019s address in contracts deriving from Controllable using setController().  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b9e2c7896d899de9960f2b3d17ca04d5beb79e8a/contracts/access/Ownable.sol#L46-L64  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L38  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L101  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L112  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L137  And many other onlyOwner functions such as setController():  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Controllable.sol#L35-L40   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a time-delay for such sensitive actions. And at a minimum, use a multisig owner address and not an EOA.  "}, {"title": "Missing input validation on _feeToken in DepositHandler constructor and setFeeToken()", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation on _feeToken in constructor to check if it's referring to a valid index (only USDT=2 makes sense) in the stablecoins similar to the check in setFeeToken(), which cannot be done here because the controller variable is only set later in setDependencies(). Also, given that it is set to true and that only USDT has this capability, the constructor should really check if this value is 2 and nothing else.  Also, setFeeToken() should only allow an index of 2 for now.  Scenario: Incorrectly using a _feeToken value other than 2 will cause an unnecessary balance check because of the presumed transfer fees for that token which does not exist.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L56  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L68-L75   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for _feeToken == 2 in constructor or set+check it using setFeeToken() later. Given that it is only USDT which may have fees, consider hardcoding this assumption instead of making it flexible and leaving room for error, because this is not something that applies to DAI or USDC. The entire codebase currently assumes the presence of only these three tokens in the protocol anyway.  "}, {"title": "Simpler logic can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The for loop in investSingle() can be removed in favor of simpler logic to calculate k [k = N_COINS - (i + j)], which will save some gas in the deposit flow.   ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L317-L326   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace L317 to L323 with: ``` uint256 inBalance = inAmounts[N_COINS - (i + j)]; if (inBalance > 0) {       _exchange(inBalance, int128(k), int128(i)); } ```  "}, {"title": "Removing unnecessary lpToken.balanceOf can save 4700+ gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In LifeGuard3Pool (LG) deposit(), lp token balance is determined for the crv3pool.add_liquidity() call. Given that LG does not hold any lp tokens between txs, there is no need to determine and subtract lp token balance before and after the curve add liquidity call. Removing the call on L204 will save at least 2600+2100=4700 gas from the external call.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L204-L206  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the call on L204 and just get the balance on L206 without any subtraction.  "}, {"title": "Removing redundant code can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In LG setDependencies(), the code to approve withdrawHandler to pull from lifeguard is repeated twice, once to set it to 0 allowance if the withdrawHandler is != 0 and then unconditionally to set it MAX. Given that this is the only function that sets withdrawHandler, the first set of 0 approvals seem to be redundant given the unconditional approvals that follow. Removing this can save some gas although we don\u2019t expect this to be called often.  The redundant logic could be for the case where the withdrawHandler is updated and the old handler is given an approval of 0 and the new one MAX.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L78-L89   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate code and remove logic if redundant. If this is present to handle withdrawHandler updates then ignore this recommendation.  "}, {"title": "Removing unused return values can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The investDelta return variable from function getVaultDeltaForDeposit() is ignored at the only call-site in DepositHandler. Removing it can save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L144-L152  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L171-L175  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused return value or add logic to use it at caller.  "}, {"title": "Removing unnecessary check can save gas in withdraw flow", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The minAmount <= amount check in _prepareForWithdrawalSingle() is an unnecessary check because the same check has already passed in both lg.withdrawSingleByLiquidity and lg.withdrawSingleByExchange. And there is no logic that changes the checked parameters between the earlier checks and this one.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L361  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L224  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L268   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary check.  "}, {"title": "Changing function visibility from public to external/internal/private can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function\u2019s parameters are not copied into memory and are instead read from calldata directly. If a function is called only from with that contract or derived contracts, making it internal/private can further reduce gas costs because the expensive calls are converted into cheaper jumps.   ## Proof of Concept  The only callers of eoaOnly() are external contracts DepositHandler and WithdrawHandler. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L268 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 The only caller of calcSystemTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L62-L63 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L213 The only caller of calcVaultTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L92-L93 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L432 validGTokenDecrease() can be made private just like validGTokenIncrease because it is only called from within Controller. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L448 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L248   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external/private where possible.  "}, {"title": "Moving logic to where required will save >=6800 gas on deposit/withdraw flows", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In isValidBigFish(), the calculation of gvt and pard assets by making an external call to PnL.calcPnL() is required only if the amount is >= bigFishAbsoluteThreshold.   Impact: Moving this logic for calculation of `assets` to the else part where it is required will save gas due to the external pnl call (2600 call + 2*2100 SLOADs for state variable reads in calcPnL()) for the sardine flow, where this is not required.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L250-L258  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L144-L146   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move logic to else part instead of doing it before the conditional as shown below: ```         if (amount < bigFishAbsoluteThreshold) {             return false;         } else if (amount > assets) {             return true;         } else {             (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();             uint256 assets = pwrdAssets.add(gvtAssets);             return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);         } ```  "}, {"title": "Unnecessary zero-address check", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Unnecessary zero-address check for account in addReferral() because it is always msg.sender (can never be 0) in the only call site from DepositHandler::depositGToken(). Removing this check can save a little gas in the critical deposit flow.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L202  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary zero-address check.  "}, {"title": "Rearranging order of state variable declarations to pack them will save storage slots and gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Moving declarations of state variables that take < 32 Bytes next to each other will allow combining them in the same storage slot and potentially save gas from combined SSTOREs depending on store patterns.  Impact: Moving emergencyState bool right next to preventSmartContracts bool will conserve a storage slot and may save gas.  ## Proof of Concept  See reference: https://mudit.blog/solidity-gas-optimization-tips/ and https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L54  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L44   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Moving declarations of state variables that take < 32 Bytes next to each other. E.g.: booleans next to each other or address types.  "}, {"title": "Simplifying logic will save at least 4200-11,500 gas in deposit flow", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The feeToken logic is to account for tokens that may charge transfer fees and therefore require balance checks before/after transfers. For now, the only token that is programmed to potentially do so (in future, not currently) is USDT (neither DAI/USDC have this capability).  Impact: While this flexible future-proof logic is good design, this costs 3 SLOADs = 3*2100 = 6300 gas for reading the state variable feeToken 3 times (different index each time i.e. costs 2100, not 100) while the only token programmed for transfer fees is USDT (which has never charged fees). 2100 gas + two external token balance calls for USDT (2600*2 = 5200 gas + balance gas costs) >= total of 7300 gas for USDT and 4200 gas for other two tokens is perhaps expensive to support this future-proofing logic. However, from a security-perspective, it might be safer to leave this in here for USDT but remove checking for other two.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L145-L149  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L163-L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate removing it completely or hardcoding logic only for USDT index=2 to save gas.  "}, {"title": "Caching repeatedly read state variables in local variables can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. Successive SLOADs cost 100 gas. Memory stores/loads (MSTOREs/MLOADs) cost only 3 gas. Therefore, by caching repeatedly read state variables in local variables within a function, one can save >=100 gas.  ## Proof of Concept  * Caching ctrl address in a local variable will save 300 gas because it is SLOADed 4 times now in this critical deposit flow. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L119 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L121  * Caching lg address state variable in a local variable outside the loop can save 1100 gas by avoiding 4 unnecessary SLOADs per loop iteration (4*3 = 12 but one SLOAD is hoisted out of the loop = 11 extra SLOADS at 100 gas = 1100 gas). https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L147-L151  * Caching buoy address state variable in the function beginning can save 100 gas from an extra SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L174-L176  * Caching insurance address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L198  * Caching lg address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L197 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L199  * Hoisting buoy state variable out of the loop and caching it in a local variable will save 300 gas from 3 unnecessary SLOADs. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L181  * Caching buoy in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L212 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L219  * Caching ctrl in a local variable at the function beginning and using that in the rest of this function will save 4 unnecessary SLOADs i.e. 400 gas in this function. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L221 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L226 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L236 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L260 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L264  * Hoisting buoy out of the loop and caching in a local variable will save 3 unnecessary SLOADs and so 300 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L329  * Caching lg in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L356 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L357  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache repeatedly read state variables (especially those within a loop) in local variables at an appropriate part of the function (preferably the beginning) and use them instead of state variables. Converting SLOADs to MLOADs reduces gas from 100 to 3.  "}, {"title": "Unnecessary duplication of array", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The methods `_stableToUsd` and `_stableToLp`  in the`Buoy3Pool.sol` contract is duplicating the array unnecessarily and costing gas to the users.  ``` function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, \"deposit: !length\");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);     return _lpToUsd(lpAmount);   }    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, \"deposit: !length\");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     return curvePool.calc_token_amount(_tokenAmounts, deposit);   } ```  "}, {"title": "BASIS_POINTS naming convention", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The variable BASIS_POINTS in Buoy3Pool.sol is written in capitals, which is the naming convention for constants. However BASIS_POINTS isn't a constant, because it is updated in setBasisPointsLmit This is confusing when reading the code.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L30 uint256 public BASIS_POINTS = 20;   function setBasisPointsLmit(uint256 newLimit) external onlyOwner {         uint256 oldLimit = BASIS_POINTS;         BASIS_POINTS = newLimit;         emit LogNewBasisPointLimit(oldLimit, newLimit);     }  ## Tools Used  ## Recommended Mitigation Steps Change BASIS_POINTS  to something like: basisPoints   "}, {"title": "calcProtocolExposureDelta could use a break", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact calcProtocolExposureDelta should probably stop executing once it has found the first occurrence where exposure > threshold. (as is also indicated in the comment).  The current code also works (due to the check protocolExposedDeltaUsd == 0), however inserting a break statement at the end of the \"if\" is more logical and saves a bit of gas.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L286 ///     By defenition, only one protocol can exceed exposure in the current setup. ...  function calcProtocolExposureDelta(uint256[] memory protocolExposure, SystemState memory sysState) private pure        returns (uint256 protocolExposedDeltaUsd, uint256 protocolExposedIndex)     {         for (uint256 i = 0; i < protocolExposure.length; i++) {             // If the exposure is greater than the rebalance threshold...             if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {                 // ...Calculate the delta between exposure and target                 uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);                 protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(                     PERCENTAGE_DECIMAL_FACTOR                 );                 protocolExposedIndex = i;                     // probably put a break here             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add a break statement at the end of the if  "}, {"title": "Unnecessary update of amount ", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In several functions of BaseVaultAdaptor a value is stored in the variable amount at the end of the function. However this variable is never used afterwards so the storage is unnecessary and just uses gas.  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/BaseVaultAdaptor.sol#L165     function withdraw(uint256 amount) external override {      ..         if (!_withdrawFromAdapter(amount, msg.sender)) {             amount = _withdraw(calculateShare(amount), msg.sender);      function withdraw(uint256 amount, address recipient) external override {     ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdraw(calculateShare(amount), recipient);      function withdrawToAdapter(uint256 amount) external onlyOwner {         amount = _withdraw(calculateShare(amount), address(this));     }      function withdrawByStrategyOrder( ..         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyOrder(calculateShare(amount), recipient, reversed);      function withdrawByStrategyIndex(    ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyIndex(calculateShare(amount), recipient, strategyIndex);   ## Tools Used  ## Recommended Mitigation Steps Replace   amount = _withdraw***(...); with    _withdraw***(...);  "}, {"title": "redundant check of array length", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _stableToUsd and _stableToLp check that the size of the input array is right. However because that parameter definition also contains the length (e.g. [N_COINS] ), it is already checked by solidity.  So checking it again is not necessary. Note: if this would be necessary than it should also be done at the other functions that have an input parameter with  [N_COINS], see at Proof of concept.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L174     function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, \"deposit: !length\");     ...      function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, \"deposit: !length\");       ..  Other functions with a [N_COINS] parameter: .\\Controller.sol:    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist { .\\DepositHandler.sol:    function _invest(uint256[N_COINS] memory _inAmounts, uint256 roughUsd) internal returns (uint256 dollarAmount) { .\\DepositHandler.sol:    function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) { .\\WithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[N_COINS] calldata minAmounts) external override { .\\insurance\\Exposure.sol:    function getUnifiedAssets(address[N_COINS] calldata vaults) .\\insurance\\Exposure.sol:    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure) .\\insurance\\Insurance.sol:    function calculateWithdrawalAmountsOnPartVaults(uint256 amount, address[N_COINS] memory vaults) .\\insurance\\Insurance.sol:    function calculateWithdrawalAmountsOnAllVaults(uint256 amount, address[N_COINS] memory vaults) .\\pools\\LifeGuard3Pool.sol:    function distributeCurveVault(uint256 amount, uint256[N_COINS] memory delta) .\\pools\\LifeGuard3Pool.sol:    function invest(uint256 depositAmount, uint256[N_COINS] calldata delta) .\\pools\\LifeGuard3Pool.sol:    function _withdrawUnbalanced(uint256 inAmount, uint256[N_COINS] memory delta) private { .\\pools\\oracle\\Buoy3Pool.sol:    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) { .\\pools\\oracle\\Buoy3Pool.sol:    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {  ## Tools Used  ## Recommended Mitigation Steps Remove : require(tokenAmounts.length == N_COINS, \"deposit: !length\");  "}, {"title": "hardcoded values", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There are several hardcodes values that could very well be replaced with constants. For example: - 10**18 - 5E17 - 10000  - 10**4 - 3 (N_COINS) This will make the code more readable and easier to maintain  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/DepositHandler.sol#L206  function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) {      ..            usdAmount = usdAmount.add(inAmounts[i].mul(10**18).div(getDecimal(i)));  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/tokens/GToken.sol#L24 abstract contract GToken is GERC20, Constants, Whitelist, IToken {     uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;   function applyFactor(   ....      if (diff >= 5E17) {  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/yearnv2/v032/VaultAdaptorYearnV2_032.sol#L107 function updateStrategiesDebtRatio(uint256[] memory ratios) internal override {         ..         require(ratioTotal <= 10**4, \"The total of ratios is more than 10000\");  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L317  function emergency(uint256 coin) external onlyWhitelist { ...        percent = 10000;  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Insurance.sol#L144  function getVaultDeltaForDeposit(uint256 amount) ....   investDelta[vaultIndexes[0]] = 10000;   .\\common\\StructDefinitions.sol:    uint256[3] vaultCurrentAssets; .\\common\\StructDefinitions.sol:    uint256[3] vaultCurrentAssetsUsd; .\\common\\StructDefinitions.sol:    uint256[3] stablePercents; .\\common\\StructDefinitions.sol:    uint256[3] stablecoinExposure; .\\common\\StructDefinitions.sol:    uint256[3] protocolWithdrawalUsd; .\\common\\StructDefinitions.sol:    uint256[3] swapInAmounts; .\\common\\StructDefinitions.sol:    uint256[3] swapInAmountsUsd; .\\common\\StructDefinitions.sol:    uint256[3] swapOutPercents; .\\common\\StructDefinitions.sol:    uint256[3] vaultsTargetUsd; .\\interfaces\\IBuoy.sol:    function stableToUsd(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\\interfaces\\IBuoy.sol:    function stableToLp(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\\interfaces\\IController.sol:    function stablecoins() external view returns (address[3] memory); .\\interfaces\\IController.sol:    function vaults() external view returns (address[3] memory); .\\interfaces\\ICurve.sol:    function calc_token_amount(uint256[3] calldata inAmounts, bool deposit) external view returns (uint256); .\\interfaces\\ICurve.sol:    function add_liquidity(uint256[3] calldata uamounts, uint256 min_mint_amount) external; .\\interfaces\\ICurve.sol:    function remove_liquidity(uint256 amount, uint256[3] calldata min_uamounts) external; .\\interfaces\\ICurve.sol:    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external; .\\interfaces\\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\\interfaces\\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\\interfaces\\IExposure.sol:    function getUnifiedAssets(address[3] calldata vaults) .\\interfaces\\IExposure.sol:        returns (uint256 unifiedTotalAssets, uint256[3] memory unifiedAssets); .\\interfaces\\IExposure.sol:        uint256[3] calldata unifiedAssets, .\\interfaces\\IExposure.sol:        uint256[3] calldata targetPercents .\\interfaces\\IExposure.sol:    ) external pure returns (uint256[3] memory vaultIndexes); .\\interfaces\\IExposure.sol:        uint256[3] calldata targets, .\\interfaces\\IExposure.sol:        address[3] calldata vaults, .\\interfaces\\IExposure.sol:    ) external view returns (uint256[3] memory); .\\interfaces\\IInsurance.sol:    function calculateDepositDeltasOnAllVaults() external view returns (uint256[3] memory); .\\interfaces\\IInsurance.sol:    function getDelta(uint256 withdrawUsd) external view returns (uint256[3] memory delta); .\\interfaces\\IInsurance.sol:            uint256[3] memory, .\\interfaces\\IInsurance.sol:            uint256[3] memory, .\\interfaces\\IInsurance.sol:    function sortVaultsByDelta(bool bigFirst) external view returns (uint256[3] memory vaultIndexes); .\\interfaces\\ILifeGuard.sol:    function getAssets() external view returns (uint256[3] memory); .\\interfaces\\ILifeGuard.sol:    function distributeCurveVault(uint256 amount, uint256[3] memory delta) external returns (uint256[3] memory); .\\interfaces\\ILifeGuard.sol:    function invest(uint256 whaleDepositAmount, uint256[3] calldata delta) external returns (uint256 dollarAmount); .\\interfaces\\ILifeGuard.sol:        uint256[3] calldata inAmounts, .\\interfaces\\IWithdrawHandler.sol:        uint256[3] calldata minAmounts .\\interfaces\\IWithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[3] calldata minAmounts) external; .\\pools\\oracle\\Buoy3Pool.sol:    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) { .\\pools\\oracle\\Buoy3Pool.sol:        uint256[3] memory _prices; .\\pools\\oracle\\Buoy3Pool.sol:        for (uint256 j = 0; j < 3; j++) {   ## Tools Used  ## Recommended Mitigation Steps Do the following replacements - 10**18 ==> DEFAULT_DECIMALS_FACTOR - 5E17 ==> DEFAULT_DECIMALS_FACTOR /2 or BASE/2 - 10000 ==> PERCENTAGE_DECIMAL_FACTOR - 10**4 ==> PERCENTAGE_DECIMAL_FACTOR - 3 ==> N_COINS  "}, {"title": "implicit underflows", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/6", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert. int256(a-b)  where a and b are uint, For example if a=1 and b=2 then the intermediate result would be uint(-1) == 2**256-1 int256(-x) where x is a uint. For example if x=1 then the intermediate result would be uint(-1) == 2**256-1 Its better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(..) ..         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result  //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112  function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)... ..  emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87  function safetyCheck() external view override returns (bool) {       ...             _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result    ## Tools Used  ## Recommended Mitigation Steps replace int256(a-b) with int256(a)-int256(b) replace int256(-x)   with -int256(x)   "}, {"title": "emergencyHandler not checked & not emitted", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setWithdrawHandler allows the setting of withdrawHandler and emergencyHandler. However emergencyHandler isn't checked for 0 (like the withdrawHandler ) The value of the emergencyHandler is also not emitted (like the withdrawHandler )  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L105  function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {         require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");         withdrawHandler = _withdrawHandler;         emergencyHandler = _emergencyHandler;         emit LogNewWithdrawHandler(_withdrawHandler);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like:         require(_emergencyHandler!= address(0), \"setEmergencyHandler: 0x\");         event LogNewEmergencyHandler(address tokens);         emit LogNewEmergencyHandler(_emergencyHandler);  "}, {"title": "sortVaultsByDelta doesn't work as expected", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function sortVaultsByDelta doesn't always work as expected. Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0 Then maxIndex = 0 And (delta < minDelta (==0) ) is never true, so minIndex = 0  Then (assuming bigFirst==true): vaultIndexes[0] = maxIndex = 0 vaultIndexes[2] = minIndex = 0 vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3  This is clearly not what is wanted, all vaultIndexes should be different and should be in the range [0..2] This is due to the fact that maxDelta and minDelta are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because vaultIndexes[1]  is out of range).  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {         uint256 maxIndex;         uint256 minIndex;         int256 maxDelta;         int256 minDelta;         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(                 unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)             );             // Establish order             if (delta > maxDelta) {                 maxDelta = delta;                 maxIndex = i;             } else if (delta < minDelta) {                 minDelta = delta;                 minIndex = i;             }         }         if (bigFirst) {             vaultIndexes[0] = maxIndex;             vaultIndexes[2] = minIndex;         } else {             vaultIndexes[0] = minIndex;             vaultIndexes[2] = maxIndex;         }         vaultIndexes[1] = N_COINS - maxIndex - minIndex;     }  ## Tools Used  ## Recommended Mitigation Steps Initialize maxDelta and minDelta:         int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version         int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version Check maxIndex and minIndex are not the same require (maxIndex != minIndex);  "}, {"title": "Unimplemented methods in several interfaces", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/140", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Some methods declared in the interfaces are not implemented. Specifically, the `withdrawRepay` method of `ILendingPair` and the `liqFeePool` method of `Controller`.  ## Proof of Concept  Referenced code: [IController.sol#L14](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/IController.sol#L14) [ILendingPair.sol#L22](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/ILendingPair.sol#L22)  ## Recommended Mitigation Steps  Remove the unimplemented methods.  "}, {"title": "Math.max can be used", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/133", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The line `return (rate < MIN_RATE) ? MIN_RATE : rate;` can be written as `return Math.max(rate, MIN_RATE);` for an easier reading, since the Math library is already imported.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/InterestRateModel.sol#L37  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Rewrite using the Math.max function  "}, {"title": "typo: totalAccountBorrrow", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact Simple typo: totalAccountBorrrow instead of totalAccountBorrow  ## Proof of Concept In LendingPair.sol: ```     uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);      return totalAccountSupply * 1e18 / totalAccountBorrrow; ```  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Correct the typo  "}, {"title": "Unused imported interface in LendingPair", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The './interfaces/IInterestRateModel.sol' imported in LendingPair.sol isn't actually used and can be removed  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L13  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove the import line.  "}, {"title": "repayAll() and repayAllETH() vulnerable to frontrunning", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/125", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The repayAll() and repayAllETH() functions allow any user to pay off debt of another user. Since all of the debt is going to be paid, no amount is specified, allowing the recipient of the repayment to frontrun the transaction to increase their debt. The risk of this issued was lowered as it depended on the user having enough tokens and allowance in the case of repayAll(), or having a msg.sender higher than the current debt in the case of repayAllEth().  ## Proof of Concept The affected lines are the following:  https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L147 https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156  The scenario for repayAll() is the following:  1. Alice pays off 5 of Bob's Dai debt using repayAll(). 2. Bob monitors the mempool for Alice's transaction, and front-runs it by taking out as much debt as Alice's allowance (and therefore balance) to the contract. 3. `debtOf[_token][_account]` now returns the higher amount and pays off Bob's new debt.   The scenario for repayAllEth() is similar:  1. Alice pays off 0.5 of Bob's Weth debt using repayAllEth(). 2. Bob monitors the mempool for Alice's transaction, and frontruns it by taking out as much debt as Alice's msg.value amount used. 3. `debtOf[address(WETH)][_account]` now returns the higher amount and pays off Bob's new debt.  ## Recommended Mitigation Steps This issue can be mitigated by enforcing a minimum time to hold debt - e.g. not allowed to repay debt for at least 6 blocks. Alternatively, the repay() function could be used to replace the 2 affected functions by passing in the _amount as the total debt (looked up off-chain and used in the dapp, for example) so that only up to a certain amount of debt is paid. This also means the repay() function would need to be made `payable`, and that the `msg.value` is validated to equal the _amount parameter.  "}, {"title": "`LendingPair.pendingSupplyInterest` is not accurate", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LendingPair.pendingSupplyInterest` does not accrue the new interest since the last update.  ## Impact The returned value is not accurate.  ## Recommendation Accrue it first such that `cumulativeInterestRate` updates and `_newInterest` returns the updated value.  "}, {"title": "`LendingPair.liquidateAccount` fails if tokens are lent out", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123", "labels": ["bug", "disagree with severity", "sponsor confirmed", "3 (High Risk)"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.  ## Impact No liquidations can be performed if all tokens are lent out. Example: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.  ## Recommendation Mint LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.  "}, {"title": "`LendingPair.liquidateAccount` does not accrue and update cumulativeInterestRate", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/122", "labels": ["bug", "disagree with severity", "sponsor confirmed", "3 (High Risk)"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.  ## Impact The liquidatee (borrower)'s state will not be up to date. I could skip some interest payments by liquidating myself instead of repaying if I'm under-water. As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.  ## Recommendation It should call `accrueAccount` instead of `_accrueAccountInterest`   "}, {"title": "Interest model is non-continuous", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/112", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `InterestRateModel.borrowRatePerBlock` function has a literal jump at target ratio and does not form a continuous function. Usually (as in Compound) it's a piece-wise continuous function with a linear function `f` on `[0%; TARGET%]` and a second linear function `g` on [`TARGET%; 100%]` where `f(TARGET) = g(TARGET)` and `g`'s slope is much higher than `f` to discourage further borrows.  Example: Assuming a `TARGET_UTILIZATION` of 80%, the `borrowRatePerBlock` for a utilisation ratio slightly less than `TARGET_UTILIZATION` (`if` branch) would be: `LOW_RATE * TARGET_UTILIZATION`. However, when borrowing **at** `TARGET_UTILIZATION` (`else` branch), the `borrowRatePerBlock` suddenly becomes `TARGET_UTILIZATION`, i.e., a `(1-LOW_RATE) * TARGET_UTILIZATION` increase.  This is because `debt - (supply * TARGET_UTILIZATION / 100e18) = 0` (as `debt * 100e18 / supply = TARGET_UTILIZATION`) and thus the inner `utilization = 0`.   ## Impact Borrowing a single wei more that pushes the utilization ratio to the `TARGET_UTILIZATION` (going from `if` to `else` branch)  leads to suddenly having to pay 20% (1 - target) more interest **on the overall debt position**.  ## Recommended Mitigation Steps I think the expected behavior for the `else` case should be something like `TARGET_UTILIZATION * LOW_RATE + (HIGH_RATE - TARGET_UTILIZATION * LOW_RATE) * utilization / 100e18` such that it's a continuous function at utiisation ratio of `TARGET_UTILIZATION`.  "}, {"title": "Variables that can be converted into immutables", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutables  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/external/ERC20.sol:17:3:    | 17 |   uint8 public decimals;    |   ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:17:3:    | 17 |   uint MAX_INT = 2**256 - 1;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:22:3:    | 22 |   address public lendingPairMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:23:3:    | 23 |   address public lpTokenMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:24:3:    | 24 |   IController public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:35:3:    | 35 |   IPairFactory public factory;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:36:3:    | 36 |   IController  public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:37:3:    | 37 |   IERC20  public rewardToken;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ ```  Instead of the expensive `sload`, to read from storage, these would be transformed into a cheap `push value`, when the variables are converted into immutable.  ## Tools Used  A custom compiler.    "}, {"title": "Lack of zero address validation", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/108", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Due to lack of zero address validation funds can be lost in following case  ex - No checking of address(0) in constructor        No checking of address(0) while using low-level call to transfer eth  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L25  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L49  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L57  ## Tools Used manual review  ## Recommended Mitigation Steps  add zero address validation  "}, {"title": "Use of Floating Pragma", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact  https://swcregistry.io/docs/SWC-103  ## Proof of Concept Most of  listed files uses floating pragma, some are  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L6  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L3  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/InterestRateModel.sol#L6  ## Tools Used  manual review  ## Recommended Mitigation Steps use fixed solidity version  "}, {"title": "Single-step process for critical ownership transfers is risky", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Multiple contracts: Controller, LPTokenMaster, RewardDistribution and UniswapV3Oracle use onlyOwner authorized functions. Given that this is derived from Ownable, the ownership management of these contracts defaults to Ownable\u2019s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/external/Ownable.sol#L25-L38  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L11  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L12  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L17  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/UniswapV3Oracle.sol#L12  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a timelock delay for such sensitive actions. And at a minimum, use a multisig (with mutually independent and trustworthy owners) and not an EOA.  "}, {"title": "Chainlink - Use latestRoundData instead latestAnswer to run more validations", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  `UniswapV3Oracle.sol` is calling `latestAnswer` to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh. On the other hand, calling the method `latestRoundData` allow you to run some extra validations  ```        (           roundId,           rawPrice,           ,           updateTime,           answeredInRound         ) = AggregatorV3Interface(XXXXX).latestRoundData();         require(rawPrice > 0, \"Chainlink price <= 0\");         require(updateTime != 0, \"Incomplete round\");         require(answeredInRound >= roundId, \"Stale price\"); ```  More information:  https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  "}, {"title": "_wethWithdrawTo is vulnerable re-entrancy", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function withdrawBorrowETH invokes _wethWithdrawTo and later _checkMinReserve, however, the check of reserve is not necessary here, as function _wethWithdrawTo also does that after transferring the ether. However, this reserve check might be bypassed as TransferHelper._wethWithdrawTo uses a low level call that is vulnerable to re-entrancy attacks. As this MIN_RESERVE sounds like an important value, you should consider preventing re-entrancy attacks here.   // Prevents division by zero and other undesirable behavior   uint public constant MIN_RESERVE = 1000;  ## Recommended Mitigation Steps Consider using re-entrancy guard on all main action functions (e.g. deposit, withdraw, borrow, repay, etc): https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  "}, {"title": "setReward does not check if pid exists", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setReward does not check if pid actually exists. Provided wrong _pair, _token and _isSupply params it will return a default value of 0, thus the first pool will be updated even though the caller may intended to update another pool. The risk is very low as this function can only be called by onlyOwner but I still think the code should prevent such scenarios from accidentally happening.  ## Recommended Mitigation Steps Check that pidByPairToken added value is true.  "}, {"title": "addPool emits PoolUpdate with wrong pid", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function addPool emits event PoolUpdate passing pools.length as pid while the actual pid is pools.length-1.  ## Recommended Mitigation Steps    emit PoolUpdate(pools.length-1, _pair, _token, _isSupply, _points); or even better store it in a temporary variable and re-use multiple times.  "}, {"title": "safeTransferFrom in TransferHelper is not safeTransferFrom", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact A non standard erc20 token would always raise error when calling `_safeTransferFrom`.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit.  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19  TransferHelper does not uses `SafeERC20` library as the function name implies.   A sample POC: script: ``` usdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) lending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) ```  Error Message: ```   Error: Transaction reverted: function returned an unexpected amount of data       at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)       at LendingPair.deposit (contracts/LendingPair.sol:95) ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Uses openzeppelin `SafeERC20` in transfer helper (and any other contract that uses IERC20).  "}, {"title": "LendingPair: Missing validation check for ETH methods [Updated]", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  The `depositRepayETH()`, `withdrawBorrowETH()`, `withdrawAllETH()` and `repayAllETH()` fail to check if ETH is an asset of the lending pair (ie. if ETH is either tokenA or tokenB).  From manually tracing the `depositRepayETH()` function, attempts to call it will revert in `_mintSupply()` when `lpToken[_token].mint(_account, _amount);` is called, since the `lpToken` is only initialized for only tokenA and tokenB.  Nevertheless, it is recommended to perform token validation for the ETH methods as well, since it should be treated like other ERC20 tokens. It also helps to avoid wasting gas.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156)  ## Recommended Mitigation Steps  Include `_validateToken()` in the equivalent ETH functions. An alternative suggestion is to drop the ETH methods (eg. combine `depositRepayETH()` into `depositRepay()` and doing a bit of refactoring to make native ETH deposits / withdrawals possible.  ```jsx // public constant ETH_ADDRESS = ''; // define a special constant address for ether != WETH address function depositRepay(address _account, address _token, uint _amount) external payable {     _validateTokenAndValue(_token, msg.value, _amount);     accrueAccount(_account);      _depositRepay(_account, _token, _amount);   _handleDeposit{value:msg.value}(_token, _amount); }  function _validateTokenAndValue(address _token, uint etherWei, uint amount) internal view {   address token;   if (_token == ETH_ADDRESS) {    token = WETH;    require(etherWei == amount, \"LendingPair: invalid etherWei\");   } else {    token = _token;    require(etherWei == 0, \"LendingPair: invalid etherWei\");   }     require(token == tokenA || token == tokenB, \"LendingPair: invalid token\"); }  function _handleDeposit(address _token, uint _amount) internal payable {  (_token == ETH_ADDRESS) ?    WETH.deposit{ value: msg.value }() :    _safeTransferFrom(_token, msg.sender, _amount); } ```  "}, {"title": "LendingPair: Unnecessary Casting", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  The address casting of `_token` in `lpToken[address(_token)]` can be removed in the `withdrawAll()`, `_withdraw()` and `_borrow()` functions, since `_token` is already an address in these functions.   In other words, `lpToken[address(_token)]` *\u2192* `lpToken[token]`  "}, {"title": "External call does not have amount check in TransferHelper", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  There is occurrence in the code of the TransferHelper contract where amount is checked after the external call.  ## Proof of Concept  - Navigate to [TransferHelper.sol](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol) -  Amount is checked after an external call. [TransferHelper.sol amount check](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol#L22)  -  To favor readability and avoid confusions, consider applying check at the beginning of function.  ## Tools Used  None  ## Recommended Mitigation Steps  To favor readability and avoid confusions, consider applying check at the beginning of function.  ```sh   function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     require(_amount > 0, \"TransferHelper: amount must be > 0\");     ...   } ```  "}, {"title": "UniswapV3Oracle: Reduce minObservations to uint16", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  Will help prevent erraneous `minObservations` values from being set (ie. `> 65535`) by the owner without needing checks. Otherwise, the `isPoolValid` will always return false, causing reverts in calling `tokenPrice` and `addPool` functions (and other functions calling these).  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101)  ## Proof Of Concept  The maximum number of observations available is `65535` (see [https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39)), which is equivalent to `type(uint16).max`.  Hence,   - `uint public minObservations` can be reduced to `uint16 public minObservations`. - `(, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();` becomes `(, , , , uint16 observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();`  "}, {"title": "UniswapV3Oracle: No events emitted for setUniPriceConverter, setTwapPeriod, setMinObservations", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  No impact but personally, I think it's good practice to emit an event whenever you update the state of the contract via a setter function.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75)  "}, {"title": "RewardDistribution: Optimise _getPid", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  A repeated call to `pidByPairToken[_pair][_token][_isSupply]` can be avoided since it is stored in `poolPosition`. Simply return [poolPosition.pid](http://poolposition.pid).   ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250)  ## Proof of Concept  ```jsx function _getPid(address _pair, address _token, bool _isSupply) internal view returns(uint) {     PoolPosition memory poolPosition = pidByPairToken[_pair][_token][_isSupply];     require(poolPosition.added, \"RewardDistribution: invalid pool\");      return poolPosition.pid; } ```  "}, {"title": "LPTokenMaster: CEI Pattern", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  It would be better to perform the allowance check before handling the token transfer. This is in line with the best practice of the CEI (checks-effects-interactions) pattern to avoid possible re-entrancy attacks.  [https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk](https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk)  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46)  ## Recommended Mitigation Steps  ```jsx function transferFrom(address _sender, address _recipient, uint _amount) external returns (bool) {     _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);     _transfer(_sender, _recipient, _amount);     return true; } ```  "}, {"title": "difference between _safeTransferFrom and _safeTransfer", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact   The functions _safeTransferFrom and _safeTransfer are similar but there is one difference: _safeTransferFrom reverts when _amount == 0 _safeTransfer  doesn't do any action when _amount == 0  I don't see any reason for the different behavior.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     bool success = IERC20(_token).transferFrom(_sender, address(this), _amount);     require(success, \"TransferHelper: transfer failed\");     require(_amount > 0, \"TransferHelper: amount must be > 0\");   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L468   function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {     if (_amount > 0) {       bool success = _token.transfer(_recipient, _amount);       require(success, \"LendingPair: transfer failed\");       _checkMinReserve(address(_token));     }   }  ## Tools Used  ## Recommended Mitigation Steps Double check the difference and perhaps apply the same logic for amount==0 to both functions.  "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/28", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Some of the constructors set values that are never changed. See proof of concept. Its best to use the immutable keyword to make sure they aren't changed by accident.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L38 address public tokenA; address public tokenB;  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L37 IPairFactory public factory; IController  public controller; IERC20  public rewardToken;  ## Tools Used  ## Recommended Mitigation Steps Add the immutable keyword where possible   "}, {"title": "redundant call to _checkMinReserve in withdrawBorrowETH ", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function withdrawBorrowETH of the contract LendingPair calls _wethWithdrawTo and then calls _checkMinReserve. However _wethWithdrawTo also calls _checkMinReserve  (except when _amount but then not much happens anyway.  So the call to _checkMinReserve in withdrawBorrowETH is redundant and uses some extra gas.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106  function withdrawBorrowETH(uint _amount) external {    ..     _wethWithdrawTo(msg.sender, _amount);     _checkMinReserve(address(WETH)); // is also called in _wethWithdrawTo   }   function _wethWithdrawTo(address _to, uint _amount) internal override {     if (_amount > 0) {       TransferHelper._wethWithdrawTo(_to, _amount);       _checkMinReserve(address(WETH));     }   }  ## Tools Used  ## Recommended Mitigation Steps Consider removing the _checkMinReserve in withdrawBorrowETH Or consider moving the _checkMinReserve to all functions where _wethWithdrawTo is called  "}, {"title": "minBorrowUSD not initialized in the contract", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The parameter minBorrowUSD of the contract Controller isn't initialized. If someone is able to Borrow before the function setMinBorrowUSD is called, he might be able to borrow a very small amount. This might be unwanted.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L27   uint public minBorrowUSD;    function setMinBorrowUSD(uint _value) external onlyOwner {     minBorrowUSD = _value;   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L553 function _checkBorrowLimits(address _token, address _account) internal view {    ...     require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");   ## Tools Used  ## Recommended Mitigation Steps Initialize minBorrowUSD via the constructor or set a reasonable default in the contract.  "}, {"title": "No check of MAX_LIQ_FEES in contructor of Controller", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Both the functions setLiqParamsToken and setLiqParamsDefault have a check to make sure that _liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES  However the constructor of Controller sets the same parameters and doesn't have this check. It seems logical to also do the check in the controller otherwise the parameters could be set outside of the wanted range.  ## Proof of Concept // https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L49 constructor( address _interestRateModel, uint _liqFeeSystemDefault, uint _liqFeeCallerDefault) {     ...     liqFeeSystemDefault = _liqFeeSystemDefault;     liqFeeCallerDefault = _liqFeeCallerDefault;  function setLiqParamsToken( address _token, uint    _liqFeeSystem, uint    _liqFeeCaller ) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, \"Controller: fees too high\"); ...     liqFeeSystemToken[_token] = _liqFeeSystem;     liqFeeCallerToken[_token] = _liqFeeCaller;  function setLiqParamsDefault( uint    _liqFeeSystem, uint    _liqFeeCaller) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, \"Controller: fees too high\");     liqFeeSystemDefault = _liqFeeSystem;     liqFeeCallerDefault = _liqFeeCaller;  ## Tools Used  ## Recommended Mitigation Steps Add something like the following in the constructor of Controller  require(liqFeeCallerDefault + liqFeeSystemDefault <= MAX_LIQ_FEES, \"Controller: fees too high\");  "}, {"title": "Undefined Event", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Without Event, it is difficult to identify in real-time whether correct values are recorded on the blockchain. In this case, it becomes problematic to determine whether the corresponding value has been changed in the application and whether the corresponding function has been called. setMinBorrowUSD function is missing event.  ## Proof of Concept  1. Go to following the function [setMinBorrowUSD Function](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L137) 2. There is missing event definition on the function.   ## Tools Used  None  ## Recommended Mitigation Steps  Add Event corresponding to the change occurring in the function.  <code>Add `emit NewMinBorrowUSD(_value);`</code>  "}, {"title": "Flash loan manipulation on `getPoolShareWeight` of `Utils`", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/238", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.  ## Proof of Concept  According to the implementation of `getPoolShareWeight,` a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:  1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool. 2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's `baseAmount`. He could split his trade into small amounts to reduce slip-based fees. 3. The attacker now wants to increase his weight in the `DaoVault`. He adds his LP tokens to the pool by calling the `deposit` function of `Dao.` 4. `Dao` then calls `depositLP` of `DaoVault`, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased. 5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling `harvest` of the `Dao` contract. 6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.  Referenced code: [Utils.sol#L46-L50](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50) [Utils.sol#L70-L77](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77) [DaoVault.sol#L44-L56](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56) [Dao.sol#L201](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201) [Dao.sol#L570](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570)  ## Recommended Mitigation Steps  A possible mitigation is to record the current timestamp when a user's weight in the `DaoVault` or `BondVault` is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.  "}, {"title": "Improper access control of `claimAllForMember` allows anyone to reduce the weight of a member", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/235", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.   ## Proof of Concept  For example, an attacker can intentionally front-run a victim's `voteProposal` call to decrease the victim's vote weight to prevent the proposal from being finalized:  1. Supposing the victim's member weight in the `BondVault` is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim's weight will be decreased to 101. To simplify the situation, assuming that the victim's weight in the `DaoVault` and the total weight of the `DaoVault` are both 0. 2. The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls `voteProposal`, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%). 3. An attacker does not want the proposal to be finalized, so he calls `claimAllForMember` with the victim as the parameter to intentionally decrease the victim's weight. 4. As a result, the victim's weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 < 66.6%).  Similarly, an attacker can front-run a victim's `harvest` call to intentionally decrease the victim's reward since the amount of reward is calculated based on the victim's current weight.  Referenced code: [Dao.sol#L179-L206](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L179-L206) [Dao.sol#L276-L285](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L276-L285) [Dao.sol#L369-L383](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L369-L383) [Dao.sol#L568-L574](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L568-L574) [Dao.sol#L577-L586](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L577-L586) [BondVault.sol#L104-L117](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L104-L117) [BondVault.sol#L120-L129](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L120-L129) [BondVault.sol#L155-L162](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L155-L162)  ## Recommended Mitigation Steps  Consider removing the `member` parameter in the `claimAllForMember` function and replace all `member` to `msg.sender` to allow only the user himself to claim unlocked bonded LP tokens.  "}, {"title": "Possible divide by zero errors in `Utils`", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/232", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Several functions in `Utils` do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.  ## Proof of Concept  Referenced code: [Utils.sol#L75](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L75) [Utils.sol#L90](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L90) [Utils.sol#L109-L110](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L109-L110) [Utils.sol#L123-L124](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L123-L124) [Utils.sol#L131](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L131) [Utils.sol#L138](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L138) [Utils.sol#L155](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L155) [Utils.sol#L189](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L189) [Utils.sol#L195](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L195) [Utils.sol#L215](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L215)  ## Recommended Mitigation Steps  Check if the divisors are 0 in the above functions to handle edge cases.  "}, {"title": "Missing input validation in addLiquidityForMember()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/225", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, the function addLiquidityForMember() doesn't check inputBase and inputToken. Since we know they can't both be zero (it wouldn't change anything and user pays the gas for nothing).  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a require `inputBase>0 || inputToken>0`.  "}, {"title": "Loss of precision", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/224", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, there's a loss of precision that can be corrected by shifting the operations.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274  ## Tools Used editor  ## Recommended Mitigation Steps Consider rewriting L274-275 with `uint numerator = (_fees * reserve) / eraLength / maxTrades;`.  "}, {"title": "Missing input validation zapLiquidity()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact zapLiquidity() in Router.sol misses an input validation unitsInput > 0.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59  ## Tools Used editor  ## Recommended Mitigation Steps Add an input validation for unitsInput.  "}, {"title": "state variable that can be declared as constant", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/219", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L11  ## Tools Used  manual review  ## Recommended Mitigation Steps   "}, {"title": "state variables that can be declared as immutable", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact  https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L15  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L14  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L18  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L7 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L12  ## Tools Used  manual review  ## Recommended Mitigation Steps  "}, {"title": "Missing revert if denominator = 0", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/214", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Synth.sol, the function burnSynth() calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176  ## Tools Used editor  ## Recommended Mitigation Steps Add a require(denom != 0, \"LPDebt = 0\").  "}, {"title": "Mismatch in event definition", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/210", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with \"synth\" as second output.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L13 https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L46  ## Tools Used editor  ## Recommended Mitigation Steps Think about what's the better variable to be emitted, and correct one of the lines.  "}, {"title": "Pool.burnSynth(address,address) is potentially reentrant", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/203", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  Pool.burnSynth(address,address) is potentially a reentrant method because it executes transfers and burning before updating balances/metrics.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  ## Tools Used  Slither  ## Recommended Mitigation Steps  The function should update state before external calls.  Consider using a nonReentrant guard as provided by OpenZeppelin:  https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard  "}, {"title": "Dividend reward can be gamed", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/182", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees.  - The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent. - The `normalAverageFee` variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool `arrayFeeSize` (20) times (use `buyTo`). The fees of the single wei trades will be zero and thus the `normalAverageFee` will also be zero as, see `addTradeFee`. - The attacker then does a trade that generates some non-zero fees, setting the `normalAverageFee` to this trade's fee. The `feeDividend` is then computed as `_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2`. Half of the `dailyAllocation` is sent to the pool. - The attacker repeats the above steps until the reserve is almost empty. Each time the `dailyAllocation` gets smaller but it's still possible to withdraw almost all of it. - They redeem their LP tokens and gain a share of the profits  ## Impact The reserve can be emptied by the attacker.  ## Recommended Mitigation Steps Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short. I think a better idea is to compute the dividends based on **volume** traded over a timespan instead of looking at individual trades.   "}, {"title": "SynthVault withdraw forfeits rewards", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/168", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.  ## Impact Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.  ## Recommended Mitigation Steps Claim the rewards with the user's deposited balance first in `withdraw`.   "}, {"title": "SynthVault deposit lockup bypass", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/167", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.harvestSingle` function can be used to mint & deposit synths without using a lockup. An attacker sends `BASE` tokens to the pool and then calls `harvestSingle`. The inner `iPOOL(_poolOUT).mintSynth(synth, address(this));` call will mint synth tokens to the vault based on the total `BASE` balance sent to the pool, including the attacker's previous transfer. They are then credited the entire amount to their `weight`.  This essentially acts as a (mint +) deposit without a lock-up period.  ## Recommended Mitigation Steps Sync the pool before sending `BASE` to it through `iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);` such that any previous `BASE` transfer is wasted. This way only the actual reward's weight is increased.  "}, {"title": "SynthVault rewards can be gamed", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/166", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:  1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price. 2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price. 3. Optionally drip more `BASE` into the pool and repeat the deposits 4. Drip back `token` to the pool to rebalance it  The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards.  ## Impact The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.  ## Recommended Mitigation Steps Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.  "}, {"title": "Synth: Can accidentally burn tokens by sending them to zero", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/159", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Synth._transfer` function does not check if `recipient != 0`. Unlike standard ERC20, tokens can be accidentally burned this way.  ## Recommended Mitigation Steps Prevent user errors by denying transfers to the zero address and forcing them to call `burn` instead.  "}, {"title": "Pools can be created without initial liquidity", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/151", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call `PoolFactory.createPoolADD`, receive the LP tokens in `addForMember` and withdraw liquidity again.  ## Recommended Mitigation Steps Consider burning some initial LP tokens or taking a pool creation fee instead.   "}, {"title": "Variable one in Utils.sol can be set to constant  ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact Gas optimizations Does not affect the contract in any harmful way. Suggestions allow for smart contract gas optimizations.  ## Proof of Concept According to Slither analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant), the variable in contract Utils.sol called \"one\" or Utils.one can be set to a constant as it is considered a variable that does not change throughout the contract.   Slither Detectors:  constable-states:  Utils.one (contracts/Utils.sol, lines#11) should be constant  ------------  Code in contract:  uint public one = 10**18; <---- can be constant as it does not change  --------------  Console output (via Slither in JSON format):    \"constable-states\": [     \"Utils.one (contracts/Utils.sol#11) should be constant\\n\"   ],  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  "}, {"title": "Function purgeDeployer() should be declared external in BondVault.sol", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact  Gas Optimization This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.   Slither Detector:  external-function:  purgeDeployer() should be declared external:  BondVault.purgeDeployer() (contracts/BondVault.sol, lines#50-52)  -----------------------  Console output (via Slither in JSON format):  \"external-function\": [     \"purgeDeployer() should be declared external:\\n\\t- BondVault.purgeDeployer() (contracts/BondVault.sol#50-52)\\n\",     \"hasMinority(uint256) should be declared external:\\n\\t- Dao.hasMinority(uint256) (contracts/Dao.sol#601-610)\\n\",     \"ROUTER() should be declared external:\\n\\t- Dao.ROUTER() (contracts/Dao.sol#615-621)\\n\",     \"UTILS() should be declared external:\\n\\t- Dao.UTILS() (contracts/Dao.sol#624-630)\\n\",     \"BONDVAULT() should be declared external:\\n\\t- Dao.BONDVAULT() (contracts/Dao.sol#633-639)\\n\",     \"DAOVAULT() should be declared external:\\n\\t- Dao.DAOVAULT() (contracts/Dao.sol#642-648)\\n\",     \"POOLFACTORY() should be declared external:\\n\\t- Dao.POOLFACTORY() (contracts/Dao.sol#651-657)\\n\",     \"SYNTHFACTORY() should be declared external:\\n\\t- Dao.SYNTHFACTORY() (contracts/Dao.sol#660-666)\\n\",     \"RESERVE() should be declared external:\\n\\t- Dao.RESERVE() (contracts/Dao.sol#669-675)\\n\",     \"SYNTHVAULT() should be declared external:\\n\\t- Dao.SYNTHVAULT() (contracts/Dao.sol#678-684)\\n\",     \"greet() should be declared external:\\n\\t- Greeter.greet() (contracts/Greeter.sol#15-17)\\n\",     \"setGreeting(string) should be declared external:\\n\\t- Greeter.setGreeting(string) (contracts/Greeter.sol#19-22)\\n\"   ]  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  "}, {"title": "Missing check for already curated pool being re-curated", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  addCuratedPool() is missing a require(isCuratedPool[_pool] == false) check, similar to the one in removeCuratedPool to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L79-L87  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L93   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(isCuratedPool[_pool] == false) before setting isCuratedPool[_pool] = true.  "}, {"title": "Incorrect event parameter logs zero address instead of WBNB", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The token argument used in CreatePool event emit of createPoolADD() should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L60  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _token instead of token in event emit.  "}, {"title": "Members lose SPARTA tokens in removeLiquiditySingle()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/133", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member\u2019s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.   In other words, the _member's BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().   This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.  ## Proof of Concept  LPs sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121  SPARTA and TOKENs withdrawn from Pool to Router: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122  TOKENs from Router sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126  TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. BASE SPARTA should also be transferred to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo() 2. Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.  "}, {"title": "Lack of require() allows control flow to proceed leading to undefined behavior", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The _handleTransferIn() functions use a conditional check (_amount > 0) to execute the transfer-in logic of tokens. This should really be a require() to prevent zero amount transfers into the protocol which will allow subsequent logic to execute and potentially utilize any dust/stuck funds from earlier to be accounted to the sender.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L198-L210  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L202-L206  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L110-L114  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change condition check to a require() which will revert any transfers of zero tokens/funds.  "}, {"title": "Missing isListedPool checks may lead to lock/loss of user funds", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/130", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  This isListedPool check implemented by isPool() is missing in many functions of the contract that accept pool/token addresses from users. getPool() returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L119-L133  Use of getPool() without isPool() check: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L108  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L52  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L81  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L139  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L155  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L232  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L247-L248  Several usages of getPool() in Utils.sol and other places.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Combine isPool() isListedPool check to getPool() so that it always returns a valid/listed pool in the protocol.  "}, {"title": "Unnecessary redundant check for basisPoints", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/129", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The threshold check for basisPoints while a required part of input validation is an unnecessary redundant check because calcPart() does a similar upper bound check and the lower bound check on 0 is only an optimization.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L95  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L65   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant check to save gas and improve readability/maintainability.  "}, {"title": "Unused _token potentially indicates missing logic or is dead code", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  _token is conditionally set (to WBNB) but never used in addLiquiditySingleForMember() function unlike its usage in other functions. Such usage typically indicates missing/incorrect functionality. It looks like _handleTransferIn checks token == 0 again to consider BNB.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Recommend re-evaluating _token usage in this function, adding any missing logic or removing it for readability/maintainability.  "}, {"title": "Missing check for toPool != fromPool", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/127", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  zapLiquidity() used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L58-L71   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toPool != fromPool as part of input validation.  "}, {"title": "Attacker can trigger pool sync leading to user fund loss", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  An attacker can front-run any operation that depends on the pool contract's internal balance amounts being unsynced to pool's balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make _getAddedBaseAmount() and _getAddedTokenAmount() return 0 (because the balances are synced) from such operations.   Impact: The affected operations are: addForMember(), swapTo() and mintSynth() which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L308-L312  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L261-L270  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L272-L281  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L216-L220  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L231  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L174-L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L279  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add access control to sync() function so that only Router can call it via addDividend().  "}, {"title": "Incorrect event parameter used in emit", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Incorrect event parameter outputAmount is used (instead of output) in the MintSynth event emit. outputAmount is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L240  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L232  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace outputAmount with output in the emit.  "}, {"title": "Old DAO continues to exist/function even after moving to a new DAO", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/107", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  If moveDAO() is executed after voting, the existing DAO contract continues to function as before whereas it should ideally cease to function/exist from the users\u2019 perspective or at least function as a clone of the new DAO by using the same addresses as it does.  Scenario: moveDAO is executed to make DAO and BASE.DAO point to the new address. Existing DAO contract continues to function but all the other interfacing contracts (ROUTER, UTILS, DAOVAULT, BONDVAULT, SYNTHVAULT, POOLFACTORY, SYNTHFACTORY and RESERVE) use the updated DAO address as updated in BASE. At a minimum, this leads to undefined behavior and at worst an attack where the old DAOs (there could be many) are exploited because it still points to valid router, pool and vault contracts.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L451-L459   changeDAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/outside-scope/Sparta.sol#L189-L193   Use of BASE.DAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L54-L57  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/DaoVault.sol#L32-L34  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L39-L41  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L41-L43  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L29-L31  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L35-L37  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L27-L29  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L45-L47  Updated Getters: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L614-L684  Example uses of stale interface contract addresses _* instead of using Dao(DAO).* versions: _ROUTER: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L259  _BONDVAULT: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L281  _UTILS: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L205  _RESERVE: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L188  etc.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  At a minimum, all DAO public/external functions should check and revert if daoHasMoved or the design can even consider a selfdestruct to destroy the DAO contract once it has successfully handed over to the new DAO contract and all pending actions have been cleared. In the unlikely requirement of older DAO contracts continuing to exist, they should at least use addresses of interfacing contracts as reported by the new DAO which could have updated them.  "}, {"title": "Event log poisoning by griefing attackers", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Event log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L382  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event only if non-zero weight as relevant to proposal voting/cancelling.  "}, {"title": "Deflationary assets are not handled uniformly across the protocol", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/101", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO codebase not handle deflationary asset tokens. However, this is handled in similar _handleTransferIn functions of Router and poolFactory which indicates that protocol allows/anticipates listing of deflationary tokens which require a start balance check/subtraction before and after transfers to account for the actual amount transferred instead of taking the face-value amount from the parameter without considering any transfer fees imposed by the token contract.  Rationale for Medium severity: This is typically a low-severity finding in protocols that uniformly do not handle deflationary/inflationary/rebasing tokens because they either whitelist-away such tokens or do not anticipate handling them (by documenting and warning users) in their protocols. Spartan however has code indicative of expecting/handling deflationary tokens in Router and poolFactory but is missing similar special handling in DAO which is a case of missed handling and so is more serious because it leads to mis-accounting and potential fund loss in different parts of the protocol code.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L266  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L206-L208  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L111-L113  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add code similar to Router and poolFactory to handle deflationary tokens in DAO.  "}, {"title": "Type mismatch between parameters of setGenesisFactors() and state variables", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The state variables corresponding to setGenesisFactors() parameters _coolOff, _daysToEarn, _majorityFactor, _daoClaim and_daoFee are declared to be uint256 but are set using these parameters that are uint32. While it\u2019s unlikely that these will need values > uint32, this leads to wastage of storage slots and gas.   ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L128  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L21-L24  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L19   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The state variables can be declared uint32 to fit all five of them in a single slot and this will lead to efficient SSTOREs because they are set together. If values > uint32 are relevant, then the parameter types of setter setGenesisFactors() have to be changed.  "}, {"title": "Missing event emit for MemberWithdraws", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO member withdrawal is missing an emit for MemberWithdraws event. This results in lack of transparency and off-chain monitoring capability.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L78  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L170-L174   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an emit for the event or otherwise rationalize/document why it isn\u2019t necessary and remove the event declaration.  "}, {"title": "ROUTER._handleTransferIn()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact Here we return a value that isnt used anywhere which can safely be removed. This will save the return and also memory store gas costs  If the asset is not BNB/WBNB; we also get the startBal which is another memory store that isnt required, but more importantly we do a more expensive call to check the balance of the token in the pool contract which isnt required. This goes a step further at the 'actual' step at the end where we call the balance again and then do a MINUS math operation calling the memory value  Removing those lines will make all transactions cheaper that involve moving assets through the ROUTER, which appears to be quite a lot and sometimes even multiple times per function   ## Proof of Concept     ROUTER lines #197 to #211  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L197        ## Recommended Mitigation Steps     Remove these lines: #204 #206 #208  Also remove the return: returns(uint256 actual)  "}, {"title": "ROUTER.addTradeFee()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact     This is called with every dividend-generating txn (which is 100 or so txns per day/era by default and can be cranked up with an increase in txn volume, so higher importance than some of the other gas opts)       This is a little harder to optimize as it uses the changed state within the same function; however there is still room for optimization despite that; see below.   arrayFeeSize is called from storage twice every time; and if the array is fully built it's also called another 20 times (by default; can be increased by dao) per call to this function. As this variable doesn't change within this function; it can simply be called once at the started and stored in memory, should be a decent gas opt in a very commonly occuring txn  feeArray is also called from storage only once whilst the array is still building and not complete (this is okay) but once it's built it's called 20 times (again; by default; this might be raised) If we instead call this from storage once *just before* it's required in the loop (has to be after addFee() as this changes that feeArray's state) we can save even more gas  also; arrayFeeLength does not need to be stored in memory; just use feeArray.length from torage instead (only used once, so will only save the memory storage gas which is small)      ## Proof of Concept    ROUTER lines #285 to #297 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L285      ## Recommended Mitigation Steps    Step1: add at the start of the function: uint _arrayFeeSize = arrayFeeSize (Get storage arrayFeeSize & store in memory)  Step2: Replace all 3 instances of arrayFeeSize with _arrayFeeSize  Step3: add below addFee(_fee): uint [] memory _feeArray = feeArray (Get storage feeArray & store in memory)  Step4: replace feeArray[i] (inside the loop) to _feeArray[i]  Step5: remove line: uint arrayFeeLength = feeArray.length and replace arrayFeeLength with feeArray.length; no need to store in memory if its only used once  "}, {"title": "Frontrunning is infinitely profitable, slippage is implied 100%", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/85", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%.   ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L284  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L296  ## Recommended Mitigation Steps Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.  "}, {"title": "SYNTHVAULT.addFee() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact    This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.       If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas       ## Proof of Concept   SYNTHVAULT lines #249 to #255     https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L249       ## Recommended Mitigation Steps   Step1: Above line #249; add in:   uint [] memory _revArray = revenueArray  (Get the storage revenueArray and store it in memory)      Step2: change revenueArray.length to _revArray.length  (maybe even remove this memory variable and just call the length directly in the loop conditions in place of 'n'?)     Step3: change:   revenueArray[i] = revenueArray[i - 1]   to:   _revArray[i] = _revArray[i - 1]      Step4: change:   revenueArray[0] = _fee   To:   _revArray[0] = _fee      Step5: add:   revenueArray = _revArray  as the final line inside the function  "}, {"title": "SYNTHVAULT.harvestAll() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact    Here we call the storage stakedSynthAssets 3 times in the loop or 4 times per loop if the reward is > 0.   It could instead be called once before the loop and stored in memory. Will save more gas as time goes on and the stakedSynthAssets array potentially gets larger as more assets get listed      ## Proof of Concept   SYNTHVAULT lines #121 to #132   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L121      ## Recommended Mitigation Steps   Step1: Above line #122; add in:   address [] memory _stakedSynthAssets = stakedSynthAssets  (Get the storage stakedSynthAssets and store it in memory)     Then: replace all 4 instances of:  stakedSynthAssets with _stakedSynthAssets  "}, {"title": "POOL.addFee() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact   This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.     If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas     ## Proof of Concept  POOL lines #357 to #363   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L357     ## Recommended Mitigation Steps  Step1: Above line #358; add in:  uint [] memory _revArray = revenueArray (Get the storage revenueArray and store it in memory)    Step2: change revenueArray.length to _revArray.length    Step3: change:  revenueArray[i] = revenueArray[i - 1]  to:  _revArray[i] = _revArray[i - 1]    Step4: change:  revenueArray[0] = _fee  To:  _revArray[0] = _fee    Step5: add:  revenueArray = _revArray as the final line inside the function  "}, {"title": "ROUTER.addFee() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact  This function calls feeArray from storage when setting 'n' and then twice every loop (feeArray[i] && feeArray[i - 1]) and then again after the loop once.   If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas   ## Proof of Concept UTILS lines #300 to #306  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L301    ## Recommended Mitigation Steps Step1: Above line #301; add in: uint [] memory _feeArray = feeArray (Get the storage feeArray and store it in memory)  Step2: change feeArray.length to _feeArray.length  Step3: change: feeArray[i] = feeArray[i - 1] to: _feeArray[i] = _feeArray[i - 1]  Step4: change: feeArray[0] = _fee To: _feeArray[0] = _fee  Step5: add: feeArray = _feeArray  as the final line inside the function  "}, {"title": "Use unchecked blocks in some cases to save gas.", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use unchecked blocks when safemath is not required  In some cases, it's unnecessary to use the default checked arithmetic. In such cases, wrapping the block in unchecked would save gas.  One example is:  ``` diff @@ -271,11 +272,13 @@ contract Pool is iBEP20 {       // Check the TOKEN amount received by this Pool      function _getAddedTokenAmount() internal view returns(uint256 _actual){ -        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); -        if(_tokenBalance > tokenAmount){ -            _actual = _tokenBalance-(tokenAmount); -        } else { -            _actual = 0; +        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); +       unchecked { +            if(_tokenBalance > tokenAmount){ +                _actual = _tokenBalance-(tokenAmount); +            } else { +                _actual = 0; +            }  ```  For loops, such optimizations would save a lot of gas.  ``` diff @@ -356,9 +359,11 @@ contract Pool is iBEP20 {       function addFee(uint _rev) internal {          uint _n = revenueArray.length; // 2 +       require(_n > 0); +       unchecked {          for (uint i = _n - 1; i > 0; i--) {              revenueArray[i] = revenueArray[i - 1];          } +       }          revenueArray[0] = _rev;      }  } ```   "}, {"title": "Variables that can be  converted into immutable", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutable  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/BondVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:16:5:    | 16 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:18:5:    | 18 |     uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:13:5:    | 13 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:15:5:    | 15 |     address public TOKEN;    |     ^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:16:5:    | 16 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:19:5:    | 19 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:27:5:    | 27 |     uint public genesis; // Timestamp from when the pool was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Router.sol:9:5:   | 9 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:10:5:    | 10 |     address public WBNB;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:8:5:   | 8 |     address public LayerONE; // Underlying relevant layer1 token   |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:9:5:   | 9 |     uint public genesis;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:10:5:    | 10 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:13:5:    | 13 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:10:5:    | 10 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:11:5:    | 11 |     uint public one = 10**18;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:10:5:    | 10 |     address public SPARTA;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:12:5:    | 12 |     uint256 public genesis;    |     ^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/outside-scope/Reserve.sol:8:5:   | 8 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:30:5:    | 30 |     uint256 private _100m;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:31:5:    | 31 |     uint256 public maxSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:38:5:    | 38 |     address public BASEv1;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:8:5:   | 8 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/poolFactory.sol:10:5:    | 10 |     uint public curatedPoolSize;    // Max amount of pools that can be curated status    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:6:5:   | 6 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:7:5:   | 7 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:15:5:    | 15 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:23:5:    | 23 |     uint public genesis;                // Timestamp from when the synth was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^  ```   Instead of using an expensive `sload` operation, converting to immutable would make reading to cost just 3 gas.   ## Tools Used  A custom compiler.  "}, {"title": "Inconsistent value of burnSynth between Pool and Synth", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact When users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.  Users can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth. While users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L174  ## Tools Used None  ## Recommended Mitigation Steps  Pool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.  IMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol. Consider to let `Pool` contract pass the parameters to the `Synth` contract and add a require check in the `Synth` contract.    "}, {"title": "Dao.sol: Unused hasMinority()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `hasMinority()` is defined as a public function, but is unused in the contract. It can either be entirely removed or have its visibility changed to `external`.  "}, {"title": "_deposit resetting user rewards can be used to grief them and make them loose rewards via `depositForMember `", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107   `mapMemberSynth_lastTime` is also used to calculate rewards earned  `depositForMember` allows anyone, to \"make a donation\" for the member and cause that member to loose all their accrued rewards  This can't be used for personal gain, but can be used to bring misery to others.   ## Proof of Concept `depositForMember` https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95 and can be called by anyone  This will set the member  ```  mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth) ```  this can be continuously exploited to make members never earn any reward   ## Recommended Mitigation Steps  This is the second submission under the same exploit This can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107  "}, {"title": "Remove _token from addLiquiditySingleForMember", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact  Gas optimization / non-critical issue. Wasted lines of code creating and setting a local variable that does not appear to be required. I can't think of a reason to leave it in.    ## Proof of Concept _token local variable is not used anywhere in the codebase. Can be removed to save gas and compile size. Looks like it's to handle WBNB (if it was required) but forgot to check/remove after it was catered for elsewhere. - https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83    ## Tools Used N/A    ## Recommended Mitigation Steps ROUTER.addLiquiditySingleForMember() - Remove line #82 - Remove line #83  "}, {"title": "Utils.sol: Redundant two assignment in calcLiquidityUnitsAsym()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `calcLiquidityUnitsAsym()` function's last 2 lines are:  ```jsx uint two = 2; return (totalSupply * amount) / (two * (amount + baseAmount)); ```  The `two` assignment seems unnecessary.  ### Recommended Mitigation Steps  `return (totalSupply * amount) / (two * (amount + baseAmount));`  "}, {"title": "Dao.sol: newParamProposal takes in uint32 param", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `newParamProposal()` takes in a `uint32 param` as an input argument. The valid scenarios for this proposal are for changing the cooloff period and erasToEarn via the `changeCooloff()` and `changeEras()`. These functions however cast the `param` to `uint256` before assigning it to the relevant variable.   We therefore have either of the following cases:  1.  `uint32 param` should be increased to `uint256 param` 2. `coolOffPeriod` and `erasToEarn` can be decreased in size to `uint32` instead of `uint256`. For further optimizations, these 2 variables should be grouped together so that they take up 1 storage slot instead of 2 separate ones.  "}, {"title": "Dao.sol: Define BASE as iBEP20 instead of address", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `BASE` is defined as an `address` type, but is casted as `iBEP20` in almost every instance within the Dao contract, and in numerous instances in many other contracts as well. It would therefore be better to define it as `iBEP20` instead, to avoid casting.  ### Recommended Mitigation Steps  Change `address public BASE;` to `iBEP public BASE`. Castings of `BASE` to `iBEP20` can be removed subsequently.  "}, {"title": "Misuse of AMM model on minting Synth (resubmit to add more detail)", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/59", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.  The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.  ## Proof of Concept Pool's mint synth https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242  The synth amount is calculated at L:232 ``` uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); ``` which is the same as swapping base to token at L:287 ``` uint256 _X = baseAmount; uint256 _Y = tokenAmount; _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output ```  However, while swapping tokens decrease pool's token, mint just mint it out of the air.  Here's a POC: Swap sparta to token for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.swapTo(token.address, user).transact() ```  Mint Synth for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.mintSynth(token_synth.address, user).transact() ``` The Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets `4744.4059` and the second case gets `6223.758`.  ## Tools Used None ## Recommended Mitigation Steps The debt should be considered in the AMM pool.  I recommend to maintain a debt variable in the Pool and use `tokenAmount - debt` when the Pool calculates the token price. Here's some idea of it. ```     uint256 public debt;     function _tokenAmount() returns (uint256) {         return tokenAmount - debt;     }      // Swap SPARTA for Synths     function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {         require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth         uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount          // Use tokenAmount - debt to calculate the value         uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN          // increment the debt         debt += output          uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted         _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount         uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN         fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA         _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold         iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user         _addPoolMetrics(fee); // Add slip fee to the revenue metrics         emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);       return (output, fee);     }  ```   "}, {"title": "Router.sol: Redundant _token initialization in addLiquiditySingleForMember()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The lines below of the `addLiquiditySingleForMember()` function  ```jsx address _token = token; if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB ```  are redundant since `_token` is not used subsequently. Note that `_handleTransferIn()` will perform the handling of native BNB transfers.  ### Recommended Mitigation Steps  The mentioned lines above can be removed.  "}, {"title": "Pool.sol + Router.sol: Set revenue directly as _fee", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx // Pool.sol: L344-345 map30DPoolRevenue = 0; map30DPoolRevenue = map30DPoolRevenue+(_fee);  // Router.sol: L317-318 mapAddress_30DayDividends[_pool] = 0; mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees; ```  can simply be written as  ```jsx map30DPoolRevenue = _fee;  mapAddress_30DayDividends[_pool] = _fees; ```  respectively.  "}, {"title": "Pool.sol + Synth.sol: Inconsistent Allowance Checking Implementation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The contract performs allowance checks for transfers in 2 ways:  1. Check allowance is greater than requested amount, revert otherwise. Then do allowance decrement. (Eg. in `transferFrom`) 2. Directly do the allowance decrement, will revert for underflow since sol 0.8.3 is used. (Eg. in `burnFrom`  It is best to stick to 1 method for consistency. For gas optimizations, the 2nd method is better, but the first provides more meaningful revert messages to aid debugging.  ### Recommended Mitigation Steps  Commit to either method, not both.  "}, {"title": "isEqual(): Inconsistent Implementation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){   if(sha256(part1) == sha256(part2)){       return true;   } } ```  Both implementations can be simplified and made consistent to be  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool){   return(sha256(part1) == sha256(part2)); } ```  "}, {"title": "DaoVault.sol & BondVault.sol: Discrepancies in mapping visibility", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In DaoVault and BondVault, the following mappings are declared private:  - `mapMember_weight` - `mapMemberPool_weight`  The DaoVault has an additional private mapping `mapMemberPool_balance`.  Despite this, the DaoVault has getter methods for all 3 mappings, whilst the BondVault only has a getter method for `mapMember_weight`.  The getter methods (which aren't included in the interface) would be unnecessary if the mappings are declared as public. Also, the BondVault might perhaps be lacking a view method for `mapMemberPool_weight`.   Should the separate getter methods remain unchanged, note that the getter method for `getMemberWeight()` has a convoluted implementation:  ```jsx function getMemberWeight(address member) external view returns (uint256) {  if (mapMember_weight[member] > 0) {   return mapMember_weight[member];   } else {     return 0;     } } ```  which can be simplified to simply returning the `mapMember_weight[member]`.  ### Recommended Mitigation Steps  - Declare the relevant private mappings as public. - Kindly check if `mapMemberPool_weight` should be public for the BondVault as well, since it is the case for the DaoVault.  "}, {"title": "Dao.sol: Return votes > consensus", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `hasMajority()`, `hasQuorum()` and `hasMinority()` functions contains the following implementation:  ```jsx if(votes > consensus){  return true; } else {  return false; } ```  This can be reduced to `return (votes > consensus);`  "}, {"title": "BondVault.sol: Optimizations", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - `_pool` is fetched once in `claimForMember()`, but is fetched again in its sub function `decreaseWeight()`. Since `decreaseWeight()` is solely called by `claimForMember()`, the `_pool` variable can be passed as an input to `decreaseWeight()` to avoid having to retrieve its value again. - In `increaseWeight()` and `decreaseWeight()`, zeroing out `mapMemberPool_weight` is redundant as it is set to another value 2 lines later.  "}, {"title": "Router.sol: lastMonth variable is private", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `uint private lastMonth; // Timestamp of the start of current metric period (For UI)`   There is no getter method for `lastMonth`, which makes the (For UI) comment is erroneous.  ### Recommended Mitigation Steps  Make it `public` or edit the comment  "}, {"title": "Pool.sol: Optimizations", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  1. `DEPLOYER` is set in the constructor but is not used anywhere in the contract 2. Redundant initialization `lastMonth = 0;` 3. `genesis` and `decimals` can have the `immutable` keywords since they are only set in the constructor and can't be changed 4. `iUTILS(_DAO().UTILS())` is called many times in `mintSynth()`, `removeForMember()` and `_swap*()` functions. Recommend storing as a local variable in these functions. 5. Since `revenueArray` cannot exceed length 2, the `addFee` function can be directly incorporated into the `addRevenue` function. Its for loop can be replaced with direct replacement of values. Also, `revenueArray.length != 2` is cleaner and easier to read compared to `!(revenueArray.length == 2)`. Given its purpose and usage, `archiveRevenue` / `cachePastRevenue` seems to be a better function name. If it is clear that revenueArray will be kept constant at 2, an alternative is to simply store the values as 2 separate variables.  ### Recommended Mitigation Steps  1. Remove `DEPLOYER` 2. Remove the initialization `lastMonth = 0;` 3. `uint public immutable genesis;` and `uint8 public immutable override decimals;` 4. `iUTILS utils = _DAO().UTILS();` should utils be called more than once in a function 5. Possible implementation below  ```jsx function archiveRevenue(uint _totalRev) {  if (revenueArray.length == 2) {   // shift value to the right   revenueArray[1] = revenueArray[0];   revenueArray[0] = _totalRev;   } else {     // populate revenueArray to be of length 2     revenueArray.push(_totalRev);   } } ```  "}, {"title": "Dao.sol: Restrict Function Visibilities", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - `calcClaimBondedLP()` returns `_BONDVAULT.calcBondedLP(()` which is a view function. Hence, `calcClaimBondedLP()` can be a view function as well. - `hasMinority()` is not called within the contract. Hence, the `public` keyword can be reduced to `external` to save gas.  ### Recommended Mitigation Steps  - Restrict `calcClaimBondedLP()` visibility to `view` (ie. add `view` keyword). - Reduce `hasMinority()` from `public` to `external`  "}, {"title": "Synth.sol: Redundant _handleTransferIn, onlyDAO, DEPLOYER", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `_handleTransferIn()`, `DEPLOYER` and `onlyDAO()` are defined but unused. Hence, they can be removed from the contract.  "}, {"title": "Pool.sol: swapTo() should not be payable", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `swapTo()` function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.  Furthermore, the `swapTo()` will not detect any deposited BNB, so any swapTo() calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.   ### Recommended Mitigation Steps  Remove `payable` keyword in `swapTo()`.  "}, {"title": "Dao.sol: Reserve emissions must be turned on for depositLPs and bonds", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `depositLPForMember()` and `bond()` invokes `harvest()` if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling `harvest()` to earn more DAOVault incentives. However, `harvest()` reverts if reserve emissions are turned off.   Hence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.  ### Recommended Mitigation Steps  Cache claimable rewards into a separate mapping when `depositLPForMember()` and `bond()` are called. `harvest()` will then attempt to claim these cached + pending rewards. Perhaps Synthetix's Staking Rewards contract or Sushiswap's FairLaunch contract can provide some inspiration.  "}, {"title": "Dao.sol: Insufficient validation for proposal creation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.  - The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check `typeStr`, and so `completeProposal()` isn't executed at all. - Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.  All of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).  ### Recommended Mitigation Steps  1. Since the number of proposal types is finite, it is best to restrict and validate the `typeStr` submitted. Specifically,     - `newActionProposal()` should only allow `FLIP_EMISSIONS` and `GET_SPARTA` proposal types     - `newAddressProposal()` should only allow `DAO`, `ROUTER`, `UTILS`, `RESERVE`, `LIST_BOND`, `DELIST_BOND`, `ADD_CURATED_POOL` and  `REMOVE_CURATED_POOL` proposal types     - `newParamProposal()` should only allow `COOL_OFF` and `ERAS_TO_EARN` proposal types 2. Perhaps have a \"catch-all-else\" proposal that will only call `_completeProposal()` in `finaliseProposal()`  ```jsx function finaliseProposal() external {  ...  } else if (isEqual(_type, 'ADD_CURATED_POOL')){   _addCuratedPool(currentProposal);   } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){     _removeCuratedPool(currentProposal);   } else {   completeProposal(_proposalID);  } } ```  3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`  ```jsx function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {     require(proposedAddress != address(0), \"!address\");   // TODO: validate typeStr   ... }  function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {     require(param != 0, \"!param\");   // TODO: validate typeStr   ... } ```  "}, {"title": "BondVault.sol: Possibly unwithdrawable bondedLP funds in claimForMember() + claimRate never zeros after full withdrawals", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  A host of problems arise from the L110-113 of the `claimForMember()` function, where `_claimable` is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).  ```jsx // L110 - L113 mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){  mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate } ```  **1. Permanently Locked Funds**  If a user claims his bonded LP asset by calling `dao.claimForMember()`, or a malicious attacker helps a user to claim by calling `dao.claimAllForMember()`, either which is done such that `_claimable` is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.  - Assume `mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable` - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable` - L111: The if condition is satisfied - L112: User's claimRate is erroneously set to 0 \u21d2 `calcBondedLP()` will return 0, ie. funds are locked permanently  **2. Claim Rate Never Zeroes For Final Claim**   On the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. `_claimable` = `mapBondAsset_memberDetails[asset].bondedLP[member]`, we see the following effects:  - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = 0` - L111: The if condition is not satisfied, L112 does not execute, so the member's claimRate for the asset remains non-zero (it is expected to have been set to zero).  Thankfully, subsequent behaviour remains as expected since `calcBondedLP` returns zero as `claimAmount` is set to the member's bondedLP balance (which is zero after a full withdrawal).  ### Recommended Mitigation Steps  The `_claimable` deduction should occur after the condition check. Alternatively, change the condition check to `if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)`.  "}, {"title": "Synth `realise` is vulnerable to flash loan attacks", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. Synth's lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.   The attack is not necessarily required flash loan. Big whale of the lp token holders could keep calling realse by shifting token ratio of AMM pool back and forth.   ## Proof of Concept The vulnerability locates at: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199  Where the formula here is dangerous: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L210-L217 Here's a script for conducting flashloan attack ```python flashloan_amount = init_amount user = w3.eth.accounts[0] marked_token.functions.transfer(user, flashloan_amount).transact() marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user}) token_pool.functions.addForMember(user).transact({'from': user}) received_lp = token_pool.functions.balanceOf(user).call()  synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() token_synth.functions.realise(token_pool.address).transact() token_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user}) token_pool.functions.removeForMember(user).transact({'from': user}) token_synth.functions.realise(token_pool.address).transact() synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() print('synth_lp_balance_after_realise', synth_balance_after_realise) print('synth_lp_balance_before_realise', synth_balance_before_realise)  ``` Output: ``` synth_balance_after_realise 1317859964829313908162 synth_balance_before_realise 2063953488372093023256 ``` ## Tools Used None  ## Recommended Mitigation Steps Calculating Lp token's value base on AMM protocol is known to be dangerous. There are a few steps that might solve the issue: 1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle. 2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing   "}, {"title": "Hijack token pool by burning liquidity token", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact  `Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).  The liquidity tokens are calculated at `Utils:calcLiquidityUnits` ```             // units = ((P (t B + T b))/(2 T B)) * slipAdjustment             // P * (part1 + part2) / (part3) * slipAdjustment             uint slipAdjustment = getSlipAdustment(b, B, t, T);             uint part1 = t*(B);             uint part2 = T*(b);             uint part3 = T*(B)*(2);             uint _units = (P * (part1 + (part2))) / (part3);             return _units * slipAdjustment / one;  // Divide by 10**18 ``` where `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.  Since any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on.  ## Proof of Concept Pool's burn logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146  Utils' lp token formula: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80  Here's a script of a user depositing 1M token to a pool where `totalSupply` equals 1  ``` dai_pool.functions.burn(init_amount-1).transact() print('total supply', dai_pool.functions.totalSupply().call()) dai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact() dai_pool.functions.addForMember(user).transact() print('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call()) ```  Output: ``` total supply 1 lp received from depositing 1M dai:  0 ``` ## Tools Used None ## Recommended Mitigation Steps Remove `burn` or restrict it to privileged users only.   "}, {"title": "Dao.sol: Unbounded Iterations in claimAllForMember()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `claimAllForMember()` function iterates through the full list of `listedAssets`. Should `listedAssets` become too large, as more assets are listed, calling this function will run out of gas and fail.  ### Recommended Mitigation Steps  A good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.  ```jsx function claimAllForMember(address member, uint256[] calldata assetIndexes)  external returns (bool){         address [] memory listedAssets = listedBondAssets; // Get array of bond assets         for(uint i = 0; i < assetIndexes.length; i++){             uint claimA = calcClaimBondedLP(member, listedAssets[assetIndexes[i]]); // Check user's unlocked Bonded LPs for each asset             if(claimA > 0){                _BONDVAULT.claimForMember(listedAssets[assetIndexes[i]], member); // Claim LPs if any unlocked             }         }         return true;     } ```  "}, {"title": "Router.sol: Optimise calculation of totalTradeFees in addTradeFee()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In the case where `arrayFeeLength < arrayFeeSize`, totalTradeFees is not calculated, so normalAverageFee will be 0. Hence, a return statement can be added to exit the function. Otherwise, when `arrayFeeSize >= arrayFeeLength`, the feeArray elements are iterated through twice:  - First, in `addFee`, to shift the elements by 1 to make way for the new fee. Note that `addFee()` is also solely called by `addTradeFee()` - Second, for the calculation of totalTradeFees  With all these in mind, we can make the second iteration redundant by combining the total trade fee calculation in `addFee()`.  ### Recommended Mitigation Steps  ```jsx function addTradeFee(uint _fee) internal {  uint arrayFeeLength = feeArray.length;   if(arrayFeeLength < arrayFeeSize){   feeArray.push(_fee); // Build array until it is == arrayFeeSize     return;    }   // If array is required length; shift in place of oldest item   // Calculate totalTradeFee at the same time   uint totalTradeFees = addCurrentFeeAndCalcTotalTradeFees(arrayFeeLength, _fee);    normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee }  function addCurrentFeeAndCalcTotalTradeFees(   uint arrayFeeLength,  uint _fee ) internal returns (uint totalTradeFees) {  totalTradeFees = _fee; // add newest fee   // store and update in memory first, for gas optimization   uint[] memory _feeArray = feeArray;   for (uint i = arrayFeeLength - 1; i > 0; i--) {   _feeArray[i] = _feeArray[i - 1];     totalTradeFees += _feeArray[i];   }   _feeArray[0] = _fee;   feeArray = _feeArray; } ```  "}, {"title": "Router.sol: Better changeArrayFeeSize implementation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The current `changeArrayFeeSize` implementation deletes the entire feeArray (which is used to calculate normalAverageFee for dividends), resulting in having to rebuild the feeArray again.  It would be better to keep the feeArray as is if the `_size` is greater than the current feeArrayLength, or trim it otherwise, so that the calculation `normalAverageFee` has past trade fees to use and is therefore more accurate.  ### Recommended Mitigation Steps  ```jsx function changeArrayFeeSize(uint _size) external onlyDAO {  arrayFeeSize = _size;   // trim feeArray to match _size   if (_size < feeArray.length) {      uint[] memory tempFeeArray = new uint[](_size);      // copy feeArray for gas optimization      uint[] memory _feeArray = feeArray;    for (uint i = 0; i < _size; i++) {         tempFeeArray[i] = _feeArray[i];    }      feeArray = tempFeeArray;  }   // otherwise, keep feeArray unchanged } ```  "}, {"title": "Utils.sol: Combine Swap Output + Fee Calculation to avoid Rounding Errors + Integer Overflow [Updated]", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/34", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  For minting, burning of synths and swaps, the fee and output amounts are calculated separately via `calcSwapOutput` and `calcSwapFee`. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.  For example, if we take `x = 60000, X = 73500, Y = 50321`, the actual swap fee should be `10164.57` and output `12451.6`. However, `calcSwapOutput` and `calcSwapFee` returns `10164` and `12451`, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be `10164` and `12452` instead.  Functions that have to call `calcSwapOutput` within the contract (eg. `calcSwapValueInBaseWithPool`) should call this function as well, for calculation consistency.  In addition, calculations for both `calcSwapOutput` and `calcSwapFee` will phantom overflow if the input values become too large. (Eg. `x = 2^128, Y=2^128`). This can be avoided by the suggested implementation below using the FullMath library.  ### Recommended Mitigation Steps  ```jsx function calcSwapFeeAndOutput(uint x, uint X, uint Y) public pure returns (uint output, uint swapFee) {      uint xAddX = x + X;      uint rawOutput = FullMath.mulDiv(x, Y, xAddX);      swapFee = FullMath.mulDiv(rawOutput, x, xAddX);      output = rawOutput - swapFee; }  function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){        uint _baseAmount = iPOOL(pool).baseAmount();        uint _tokenAmount = iPOOL(pool).tokenAmount();        (_output, ) = calcSwapFeeAndOutput(amount, _tokenAmount, _baseAmount); } ```  The FullMath library is included (and made compatible with sol 0.8+) below for convenience.  ```jsx // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0;  /// @title Contains 512-bit math functions /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision /// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits library FullMath {     /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0     /// @param a The multiplicand     /// @param b The multiplier     /// @param denominator The divisor     /// @return result The 256-bit result     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv     function mulDiv(         uint256 a,         uint256 b,         uint256 denominator     ) internal pure returns (uint256 result) {         // 512-bit multiply [prod1 prod0] = a * b         // Compute the product mod 2**256 and mod 2**256 - 1         // then use the Chinese Remainder Theorem to reconstruct         // the 512 bit result. The result is stored in two 256         // variables such that product = prod1 * 2**256 + prod0         uint256 prod0; // Least significant 256 bits of the product         uint256 prod1; // Most significant 256 bits of the product         assembly {             let mm := mulmod(a, b, not(0))             prod0 := mul(a, b)             prod1 := sub(sub(mm, prod0), lt(mm, prod0))         }          // Handle non-overflow cases, 256 by 256 division         if (prod1 == 0) {             require(denominator > 0, \"0 denom\");             assembly {                 result := div(prod0, denominator)             }             return result;         }          // Make sure the result is less than 2**256.         // Also prevents denominator == 0         require(denominator > prod1, \"denom <= prod1\");          ///////////////////////////////////////////////         // 512 by 256 division.         ///////////////////////////////////////////////          // Make division exact by subtracting the remainder from [prod1 prod0]         // Compute remainder using mulmod         uint256 remainder;         assembly {             remainder := mulmod(a, b, denominator)         }         // Subtract 256 bit number from 512 bit number         assembly {             prod1 := sub(prod1, gt(remainder, prod0))             prod0 := sub(prod0, remainder)         }          // Factor powers of two out of denominator         // Compute largest power of two divisor of denominator.         // Always >= 1.         uint256 twos = denominator & (~denominator + 1);         // Divide denominator by power of two         assembly {             denominator := div(denominator, twos)         }          // Divide [prod1 prod0] by the factors of two         assembly {             prod0 := div(prod0, twos)         }         // Shift in bits from prod1 into prod0. For this we need         // to flip `twos` such that it is 2**256 / twos.         // If twos is zero, then it becomes one         assembly {             twos := add(div(sub(0, twos), twos), 1)         }         unchecked {             prod0 |= prod1 * twos;                          // Invert denominator mod 2**256             // Now that denominator is an odd number, it has an inverse             // modulo 2**256 such that denominator * inv = 1 mod 2**256.             // Compute the inverse by starting with a seed that is correct             // correct for four bits. That is, denominator * inv = 1 mod 2**4             uint256 inv = (3 * denominator) ^ 2;                          // Now use Newton-Raphson iteration to improve the precision.             // Thanks to Hensel's lifting lemma, this also works in modular             // arithmetic, doubling the correct bits in each step.             inv *= 2 - denominator * inv; // inverse mod 2**8             inv *= 2 - denominator * inv; // inverse mod 2**16             inv *= 2 - denominator * inv; // inverse mod 2**32             inv *= 2 - denominator * inv; // inverse mod 2**64             inv *= 2 - denominator * inv; // inverse mod 2**128             inv *= 2 - denominator * inv; // inverse mod 2**256                          // Because the division is now exact we can divide by multiplying             // with the modular inverse of denominator. This will give us the             // correct result modulo 2**256. Since the precoditions guarantee             // that the outcome is less than 2**256, this is the final result.             // We don't need to compute the high bits of the result and prod1             // is no longer required.             result = prod0 * inv;         }         return result;     } } ```  "}, {"title": "`approveAndCall` approve `max` amount of token", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/33", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `approveAndCall` approve max allowance to the receiver regardless of the given parameter.  This is far away from what the function name implies. Users would lose all the tokens by using this function.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L118 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L113 ## Tools Used None ## Recommended Mitigation Steps Change to `_approve(msg.sender, recipient, amount); `  "}, {"title": "Misleading comment and missing revert message", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46  The comment at `poolFactory` L46  is a bit misleading. ``` require(getPool(token) == address(0)); // Must be a valid token ```  A similar checks in `synthFactory` seems to be more clear. https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L38  ```         require(getSynth(token) == address(0), \"exists\"); // Synth must not already exist ```  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46 ## Tools Used None ## Recommended Mitigation Steps  It seems that `PoolFactory` is the only contract that does not provide detailed revert messages. I wonder whether the devs do this because of the concern about the code size limit. If that's the case, I recommend refactoring it to libraries or even uses a proxy factory to create new pools.   Ref to proxy factory:  https://eips.ethereum.org/EIPS/eip-1167  "}, {"title": "Pool.sol & Synth.sol: Failing Max Value Allowance", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/29", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.  This also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.  This affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.  ### Recommended Mitigation Steps  Keep it simple, remove the condition.  ```jsx function _approve(address owner, address spender, uint256 amount) internal virtual {         require(owner != address(0), \"!owner\");         require(spender != address(0), \"!spender\");         _allowances[owner][spender] = amount;         emit Approval(owner, spender, amount);     } ```  "}, {"title": "DEPLOYER can drain DAOVault funds + manipulate proposal results", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  2 conditions enable the `DEPLOYER` to drain the funds in the DAOVault.  - `DAOVault` is missing `purgeDeployer()` function - `onlyDAO()` is callable by both the `DAO` and the `DEPLOYER`  The `DEPLOYER` can, at any time, call `depositLP()` to increase the LP funds of any account, then call `withdraw()` to withdraw the entire balance.  The only good use case for the `DEPLOYER` here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like `onlyDeployer()`.  ### Proof of Concept  1. `DEPLOYER` calls `depositLP()` with any arbitrary amount (maybe DAOVault's pool LP balance - Alice's deposited LP balance) for Alice and pool to increase their weight and balance. 2. At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it) 3. `DEPLOYER` calls `withdraw()` for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault's pool balance)  ### Recommended Mitigation Steps  - Create a separate role and modifier for the `DEPLOYER`, so that he is only able to call `withdraw()` but not `depositLP()` - Include the missing `purgeDeployer()` function.  "}, {"title": "memberCount not accurate", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function depositForMember of BondVault.sol adds user to the array arrayMembers. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array arrayMembers.  This will mean the memberCount() doesn't show accurate results. Also allMembers() will contain duplicate members  ## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L60 function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){         if(!mapBondAsset_memberDetails[asset].isMember[member]){             mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)             arrayMembers.push(member); // Add user to member array (scope: vault)             mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)         }        ...      // Get the total count of all existing & past BondVault members     function memberCount() external view returns (uint256 count){         return arrayMembers.length;     }     function allMembers() external view returns (address[] memory _allMembers){         return arrayMembers;     }  ## Tools Used  ## Recommended Mitigation Steps Use a construction like this: mapping(address => bool) isMember;    if(!isMember[member]){             isMember[member] = true;             arrayMembers.push(member);     }               "}, {"title": "arbitrary synth mint/burn from pool", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/20", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` can mint arbitrary `Sythn` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.  ## Proof of Concept Pool's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242  Synth's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171  Synth's authorization logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242   The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool   Here's a web3.py script of minting arbitrary Synth in a pool. For simplicity, two pools are set with the assumption that link is 10x expensive than dai.  ```python sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(link_pool.address, sparta_amount).transact({'from': user}) link_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from link pool:', after_link_synth - initail_link_synth)  sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user}) dai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from dai pool:', after_link_synth - initail_link_synth)  ```  The log of the above script ``` get link synth amount from link pool: 97078046905036524413 get link synth amount from dai pool: 970780469050365244136 ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Checks the provided synth's underlying token in `mintSynth`  `require(iSYNTH(synthOut).LayerONE() == TOKEN, \"invalid synth\");`    "}, {"title": "grantFunds will revert after a DAO upgrade.", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)  Now the next time grantFunds of DAO.sol is called, its tries to call:  _RESERVE.grantFunds(...)  The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the msg.sender == DAO. However in the mean time the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452  function moveDao(uint _proposalID) internal {         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address         require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid         DAO = _proposedAddress; // Change the DAO to point to the new DAO address         iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address         daoHasMoved = true; // Set status of this old DAO         completeProposal(_proposalID); // Finalise the proposal     }      function grantFunds(uint _proposalID) internal {         uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient         require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid         require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid         _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient         completeProposal(_proposalID); // Finalise the proposal     }  // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17   modifier onlyGrantor() {         require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, \"!DAO\");         _;      }    function grantFunds(uint amount, address to) external onlyGrantor {       ....     }     function setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {         ROUTER = _router;         LEND = _lend;         SYNTHVAULT = _synthVault;         DAO = _Dao;     }   ## Tools Used  ## Recommended Mitigation Steps Call setIncentiveAddresses(..) when a DAO upgrade is done.   "}, {"title": "Result of transfer / transferFrom not checked", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/8", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \"false\" is returned. So its important to check this. If you don't you could mint tokens without have received sufficient tokens to do so. So you could loose funds.  Its also a best practice to check this. See below for example where the result isn't checked.  Note, in some occasions the result is checked (see below for examples).  ## Proof of Concept Highest risk: .\\Dao.sol:                iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract .\\Pool.sol:               iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user .\\Pool.sol:               iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user .\\poolFactory.sol:   iBEP20(_token).transferFrom(msg.sender, _pool, _amount); .\\Router.sol:           iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool .\\Router.sol:           iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool .\\Router.sol:           iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool .\\Router.sol:           iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient .\\Synth.sol:             iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in  less risky .\\Router.sol:           iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool .\\BondVault.sol:     iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user .\\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool .\\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool .\\Router.sol:           iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool .\\Pool.sol:               iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract .\\Router.sol:           iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool .\\Dao.sol:               iBEP20(BASE).transfer(newDAO, baseBal); .\\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user .\\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user .\\Router.sol:           iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool .\\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool .\\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool .\\Router.sol:           iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool  Sometimes the result is checked: .\\Dao.sol:              require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault .\\Dao.sol:              require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee .\\DaoVault.sol:      require(iBEP20(pool).transfer(member, _balance), \"!transfer\"); // Transfer user's balance to their wallet .\\synthVault.sol:    require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in .\\synthVault.sol:    require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user  ## Tools Used grep  ## Recommended Mitigation Steps Always check the result of transferFrom and transfer   "}, {"title": "Block usage of addCuratedPool ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() )  The array arrayPools can be increased in size arbitrarily by repeatedly doing the following: - create a pool with createPoolADD()  (which requires 10,000 SPARTA) - empty the pool with remove() of Pool.sol, which gives back the SPARTA tokens These actions will use gas to perform.  ## Proof of Concept //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token         require((inputToken > 0 && inputBase >= (10000*10**18)), \"!min\"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite         Pool newPool; address _token = token;         if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB         require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18         newPool = new Pool(BASE, _token); // Deploy new pool         pool = address(newPool); // Get address of new pool         mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory         _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool         _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool         arrayPools.push(pool); // Add pool address to the pool array        ..  function curatedPoolCount() internal view returns (uint){         uint cPoolCount;          for(uint i = 0; i< arrayPools.length; i++){             if(isCuratedPool[arrayPools[i]] == true){                 cPoolCount += 1;             }         }         return cPoolCount;     }   function addCuratedPool(address token) external onlyDAO {         ...         require(curatedPoolCount() < curatedPoolSize, \"maxCurated\"); // Must be room in the Curated list  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L187   function remove() external returns (uint outputBase, uint outputToken) {         return removeForMember(msg.sender);     }       // Contract removes liquidity for the user     function removeForMember(address member) public returns (uint outputBase, uint outputToken) {         uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount         outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units         outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units         _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts         _burn(address(this), _actualInputUnits); // Burn the LP tokens         iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user         iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user         emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);         return (outputBase, outputToken);     } ## Tools Used  ## Recommended Mitigation Steps Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool   "}, {"title": "check if pool exists in getPool ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getPool doesn't check if the pool exits (e.g. it doesn't check if the resulting pool !=0) Other functions use the results of getPool and do followup actions.  For example createSynth checks isCuratedPool(_pool) == true; if somehow isCuratedPool(0) would set to be true, then further actions could be done. As far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities. Additionally the reverts that will occur if the result of getPool==0 are perhaps difficult to troubleshoot.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L119     function getPool(address token) public view returns(address pool){         if(token == address(0)){             pool = mapToken_Pool[WBNB];   // Handle BNB         } else {             pool = mapToken_Pool[token];  // Handle normal token         }          return pool;     }  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       function createPool(address token) external onlyDAO returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L37  function createSynth(address token) external returns(address synth){         require(getSynth(token) == address(0), \"exists\"); // Synth must not already exist         address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address         require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, \"!curated\"); // Pool must be Curated   ## Tools Used  ## Recommended Mitigation Steps In function getPool add something like: require  (pool !=0, \"Pool doesn't exist\");  Note: the functions createPoolADD and createPool also have to be changed, to use a different way to verify the pool doesn't exist.   "}, {"title": "more efficient calls to DAO functions", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Sometimes the reference to function calls, that are done via the DAO, are looked up multiple times in one function call. For example mintSynth calls:  \u200b -   _DAO() 4x -   _DAO().UTILS() 3x  This can be done more efficient by caching the result of _DAO() and _DAO().UTILS()  f## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229 \u200bfunction mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {        \u200brequire(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth      \u200b..        \u200buint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN        \u200buint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted       \u200b..        \u200buint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN        \u200bfee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA        \u200b  function _DAO() internal view returns(iDAO) {        \u200breturn iBASE(BASE).DAO();    \u200b}  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L624 \u200bfunction UTILS() public view returns(iUTILS){        \u200bif(daoHasMoved){            \u200breturn Dao(DAO).UTILS();        \u200b} else {            \u200breturn _UTILS;        \u200b}    \u200b}  ## Tools Used  ## Recommended Mitigation Step Cache _DAO() and cache the sub functions like: _DAO().UTILS()) If called multiple times from function  "}, {"title": "Saving gas by checking the last-recorded block number", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `_accrueSherX` function of `LibSherX` and the `payOffDebtAll` function of `LibPool` can be called multiple times in the same block (from different users and transactions). If the current block number is the same as the last-recorded one, it is possible to save gas by early returning at the beginning of the functions.  ## Proof of Concept  Referenced code: [LibSherX.sol#L123-L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L123-L141) [LibPool.sol#L84-L95](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L84-L95)  ## Recommended Mitigation Steps  For example, consider re-writing `_accrueSherX` as follows:  ```solidity function _accrueSherX(IERC20 _token, uint256 sherXPerBlock) private returns (uint256 sherX) {   PoolStorage.Base storage ps = PoolStorage.ps(_token);   if (block.number == ps.sherXLastAccrued) {     return 0;   }   sherX = block.number.sub(ps.sherXLastAccrued).mul(sherXPerBlock).mul(ps.sherXWeight).div(     uint16(-1)   );   // need to settle before return, as updating the sherxperlblock/weight   // after it was 0 will result in a too big amount (accured will be < block.number)   ps.sherXLastAccrued = uint40(block.number);   if (address(_token) == address(this)) {     ps.stakeBalance = ps.stakeBalance.add(sherX);   } else {     ps.unallocatedSherX = ps.unallocatedSherX.add(sherX);     ps.sWeight = ps.sWeight.add(sherX);   } } ```  "}, {"title": "Avoid repeating storage reads in a loop to save gas", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  A storage read cost more gas than a memory read. State variables that do not change during a loop can be stored in local variables and be read from memory multiple times to save gas.  ## Proof of Concept  Referenced code: [LibPool.sol#L89](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L89) [LibSherX.sol#L60](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L60) [LibSherX.sol#L94](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L94) [PoolBase.sol#L131](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L131) [SherX.sol#L76](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L76) [SherX.sol#L98](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L98) [SherX.sol#L152](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L152) [SherX.sol#L184](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L184) [SherX.sol#L243](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L243) [Gov.sol#L190](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L190)  ## Recommended Mitigation Steps  For example, consider re-writing the `harvestFor(address)` function of `SherX` as follows:  ```solidity function harvestFor(address _user) public override {   GovStorage.Base storage gs = GovStorage.gs();   uint256 len = gs.tokensStaker.length;   for (uint256 i; i < len; i++) {     PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);     harvestFor(_user, ps.lockToken);   } } ```  "}, {"title": "Gas optimization on calculating the storage slot of a token", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In the `PoolStorage` library, declaring the `POOL_STORAGE_PREFIX` constant with type `bytes32`, and change `abi.encode` ti `abi.encodePacked` at line 87 can save gas.  ## Proof of Concept  Referenced code: [PoolStorage.sol#L14](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L14) [PoolStorage.sol#L87](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L87)  Related links: [Change `string` to `byteX` if possible](https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78) [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  See above  "}, {"title": "User's `calcUnderlyingInStoredUSD` value is underestimated", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/144", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `calcUnderlyingInStoredUSD()` function of `SherX` should return `calcUnderlyingInStoredUSD(getSherXBalance())` instead of `calcUnderlyingInStoredUSD(sx20.balances[msg.sender])` since there could be SherX unallocated to the user at the time of the function call. A similar function, `calcUnderlying()`, calculates the user's underlying tokens based on the user's current balance plus the unallocated ones.  ## Proof of Concept  Referenced code: [SherX.sol#L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L141)  ## Recommended Mitigation Steps  Change `sx20.balances[msg.sender]` to `getSherXBalance()` at line 141.  "}, {"title": "Inconsistent block number comparison when deciding an unstaking entry is active", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  The `getInitialUnstakeEntry` function of `PoolBase` returns the first active unstaking entry of a staker, which requires the current block to be strictly before the last block in the unstaking window. However, the `unstake` function allows the current block to be exactly the same as the last block (same logic in `unstakeWindowExpiry`).  ## Proof of Concept  Referenced code: [PoolBase.sol#L136](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L136) [PoolBase.sol#L344](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L344) [PoolBase.sol#L364](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L364)  ## Recommended Mitigation Steps  Change the `<=` comparison at line 136 to `<` for consistency.  "}, {"title": "Possible divide-by-zero error in `PoolBase`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/136", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  A possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.  ## Proof of Concept  Referenced code: [PoolBase.sol#L215](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L215)  ## Recommended Mitigation Steps  Check if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.  "}, {"title": "Confusing exponentiation (10e17)", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/129", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The value `10e17` can be confusing, since it doesn't clearly appear from where the exponent 17 comes from (people may ctrl+f or grep the code for other instances of it without results). Indeed throughout the code the expression `10**18` is used.  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L185  ## Tools Used editor  ## Recommended Mitigation Steps Better ways of writing it are `1e18` or `10**18`.  "}, {"title": "NatSpec typo in `_doSherX` @return", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the function `_doSherX` in Payout.sol, the natSpec comment @return states that `sherUsd` is the 'Total amount of USD of the underlying tokens that are being transferred'. I think that's a typo, and it's supposed to be the amount *excluded* from being transferred.  ## Proof of Concept Payout.sol L71  ## Tools Used editor  ## Recommended Mitigation Steps Correct the statement.  "}, {"title": "gas reduction in `calcUnderlying`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the `calcUnderlying` function of LibSherX.sol, the value `gs.tokensSherX.length` can be written down once to save gas (around 300-500 when called in the present tests).  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L55-L60  ## Tools Used hardhat gas calculator  ## Recommended Mitigation Steps Suggested adding `uint256 SherXLength = gs.tokensSherX.length;` and replacing this value throughout the function (three instances).  "}, {"title": "Poorly Named variables", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Poorly named variables in Gov.sol  ## Proof of Concept _protocolPremium is a bool while protcolPremium is a mapping to uint. This is confusing a could potentially cause some input errors.  ## Recommended Mitigation Steps Rename variables.  "}]