[{"title": "3. Migration of the pair contract is disabled", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "In the Instantiate message for the pair contract, the admin eld is set to None in contracts/terraswap_factory/src/contract.rs:149. This that pair contracts cannot be migrated. implies", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. A pairs asset infos are no longer stored sorted which might break other contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "of the In the last version of TerraSwap LBP, the asset_infos stored in the FactoryPairInfo struct in is no contracts/terraswap_factory/src/contract.rs:139 were sorted. That longer the case. That change is not a problem for the audited contracts, since they use a pair_key helper function that generates a key based on the sorted asset_infos. This change, however, might break other contracts that depend on the previous design of stored sorted asset_infos. contract factory", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Unnecessary sub-messages introduce complexity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "Most contract interactions in the codebase are utilizing sub-messages, which have been introduced to Terra with the Columbus-5 upgrade. Sub-messages have been added to allow processing of the result of a call, for example, to handle errors. If the result of a call is not processed, regular messages should be used. There is no security concern in the usage of sub-messages, since they currently use the ReplyOn::Never value which causes a failure to propagate to the caller. Unnecessary usage of sub-messages can be found in:  contracts/terraswap_factory/src/contract.rs:33, 145 and 172  contracts/terraswap_pair/src/contract.rs:73, 101, 259, 307, 360, 370, 381 and 492  contracts/terraswap_router/src/contract.rs:117 and 141  contracts/terraswap_router/src/operations.rs:45, 59 and 97", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Contract name is not unique", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "In contracts/terraswap_token/src/contract.rs:16, the contract name from the CW20 base contract is used in the following string declaration: const CONTRACT_NAME: &str = \"crates.io:cw20-base\";", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Pair contract registration message in factory can be replaced with sub-message reply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "In contracts/terraswap_factory/src/contract.rs:156, a hook pattern is used to register the newly created pairs contract address in the factory. That pattern requires an exposed Register message type in the factory contract. Sub-messages have been introduced with the Columbus 5 upgrade of Terra to allow the processing of a reply without the need to expose a public message handler.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Post initialize message in pair contract can be replaced with sub-message reply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "In contracts/terraswap_pair/src/contract.rs:86, a hook pattern is used to set the newly created liquidity token contract address in the pair contracts cong. That pattern requires an exposed PostInitialize message type in the pair contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unlimited iterator stack might allow an attacker to crash the node, halting block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "The global map iteratorStack in api/iterator.go has no upper limit, which might allow an attacker to exhaust the memory of the node by creating recursive CosmWasm messages/queries that create many entries on the stack. While gas limits might prevent this issue if they are set properly, there is no guarantee that the memory is big enough to hold all the iterator stack entries the gas limit permits. This issue might cause the node to crash, potentially leading to a halt of block production if block producers are aected.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. FFI result handling may lead to memory leaks in certain cases", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "During calls from Rust to Go code through the FFI, UnmanagedVectors are created for error messages. This happens in:  The canonical_address function in libwasmvm/src/api.rs:51.  The human_address function in libwasmvm/src/api.rs:79.  The next function in libwasmvm/src/iterator.rs:60.  The query_raw function in libwasmvm/src/querier.rs:45.  The get function in libwasmvm/src/storage.rs:29.  The scan function in libwasmvm/src/storage.rs:65.  The set function in libwasmvm/src/storage.rs:118.  The remove function in libwasmvm/src/storage.rs:146. These UnmanagedVectors are destroyed within the into_ffi_result function, but only if the closure dened in libwasmvm/src/error/go.rs:75-80 is executed. That only the GoResult::Other or happens in the cases where the GoResult is of either GoResult::User variant. In all other cases, a memory leak can occur if the called code is writing to the UnmanagedVectors. In some cases, a similar issue exists with the result coming from through the FFI, for instance:  The canonical_address function in libwasmvm/src/api.rs:50.  The human_address function in libwasmvm/src/api.rs:78.  The next function in libwasmvm/src/iterator.rs:58 and 59.  The query_raw function in libwasmvm/src/querier.rs:44.  The get function in libwasmvm/src/storage.rs:28. Those UnmanagedVectors are only consumed if no error is returned, but the Go code could in theory write to those unmanaged vectors, even if an error is set. This would also cause a memory leak. Finally, the iterators next function only consumes the UnmanagedVector of the value if the key is not None in libwasmvm/src/iterator.rs:83.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Gas overow errors are treated as normal panics and do not consume Cosmos SDK gas, which can be exploited to halt block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "Within callbacks into Cosmos SDK, there is a special ErrorGasOverflow which occurs if the uint64 that is used to store gas consumption overows (see store/types/gas.go in Cosmos SDK). In such a case of an ErrorGasOverflow, Cosmos SDK sets the consumed gas to 0 in store/types/gas.go:77. The wasmvm callbacks treat such gas overow errors as normal panics, as opposed to treating them as ErrorOutOfGas, see api/callbacks.go:73-78. This leads to a gas consumption of 0 units for the Cosmos SDK related functionality. An attacker may exploit this by sending multiple messages that deliberately cause the Cosmos SDK gas counting to overow. While such messages would revert, they would consume less gas than expected such that block production might surpass Tendermints propose timeout. That could cause block production to halt.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. IBC packet receive functions result is not unwrapped, which is inconsistent and error-prone", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "The IBCPacketReceive function in lib.go:510 returns a result, and does not unwrap the errors as all other functions in lib.go do. That is inconsistent and may lead to errors if not properly handled by the calling context.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Assumption that caller of VMs create function limits contract size is inconsistent and error-prone", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "As mentioned in the TODO in lib.go:67, the VMs Create function does currently not enforce any gas limits during contract creation. Since the singlepass compiler is used, gas counting during compilation is not necessary  but the caller of the function should ensure that the size of the wasm code is limited such that block production of the underlying blockchain cannot come to a halt. Moving that responsibility to the caller is inconsistent since other functions of the VM do accept gas limits. It also requires clear documentation and introduces the likelihood of mistakes by the wasmvm integrator.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Caught Rust panics do not log errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "In several places in the codebase, panics are caught using catch_unwind. catch_unwind returns an Err(cause), where cause is the object that invoked the panic. Currently, the cause is neither logged nor returned. This negatively impacts maintainability. Instances are: libwasmvm/src/cache.rs:43, 92, 116, 143, 169, 230, 305, as well as libwasmvm/src/calls.rs:433 and 517.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Outdated specication/documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "The documentation in various Markdown les is outdated, for example: - - - - - - - - implementation of the Instantiate, Execute and Query interfaces in implementation in spec/Specification.md:43 describes that the balance of a contract instances account is passed in, which is not implemented at the moment. Accordingly, the current the ContractInfo in types/env.go:24 does not contain the Balance eld as is documented in lines 99-100. The documentation of spec/Specification.md:54-59 do not match their lib.go:118, 166, and 211. The documentation of the Result struct in spec/Specification.md:116 does not match the implementation of ContractResult in types/msg.go:12. The documentation of the CosmosMsg struct in spec/Specification.md:141 does not match its implementation in types/msg.go:68. in The spec/Specification.md:161 and 180 are not implemented. Also in lines spec/Specification.md:159 and types/msg.go:238-239 it is stated that a contract is immutable once deployed, but there is no enforcement of immutable interfaces between contract upgrades. The Params struct in spec/Specification.md:75 is now called Env and does contain TransactionInfo instead of MessageInfo, see types/env.go. The comment providing storage iteration/scans in the future, which is already implemented. Additionally, the codebase contains several TODOs in comments that are already resolved, e. g. in types/ibc.go:148 or in lib.go:67 (gas counting is addressed by caller and singlepass backend prevents JIT bombs in the contract code). in spec/Specification.md:202 describes the possibility of ContractMsg documented OpaqueMsg structs and", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Inconsistent type usage for usedGas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf", "body": "The type of usedGas is used inconsistently  in some instances C.uint64 is used, in others the type alias cu64: The functions cSet, cDelete, and cQueryExternal utilize C.uint64 instead of cu64 in api/callbacks.go.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Harvest message can be sandwiched to skim rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "The Harvest operation in contracts/martian-field/src/contract.rs:23-26 claims rewards from the Astroport generator and then, after treasury fees have been applied, sells ASTRO to rebalance between the primary and secondary assets (in two steps). Since the Harvest message is permissionless and can be called by anyone, there is an opportunity in contracts/martian-field/src/execute.rs:210. skim the operation, reducing bonded amount total the to An example of the arbitrage attack to skim rewards would be the following, executed as a single transaction: 1. User swaps ASTRO for the primary asset", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Go to step 1 when ASTRO rewards have accrued. Bots could perpetually exploit this arbitrage if it were economically viable, hindering the overall nancial performance of the Field of Mars protocol. Recommendation We recommend making the Harvest operation permissioned, to reduce the opportunity for arbitrage. Alternatively, the team/community could aim to call the Harvest function with enough frequency so the arbitrage attack is not economically feasible due to transaction fees, but this is also dependent on the ASTRO rewards claimed. Status: Resolved 2. High spread might cause swapped primary asset not enough to cover users debt", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "4. Go to step 1 when ASTRO rewards have accrued. Bots could perpetually exploit this arbitrage if it were economically viable, hindering the overall nancial performance of the Field of Mars protocol. Recommendation We recommend making the Harvest operation permissioned, to reduce the opportunity for arbitrage. Alternatively, the team/community could aim to call the Harvest function with enough frequency so the arbitrage attack is not economically feasible due to transaction fees, but this is also dependent on the ASTRO rewards claimed. Status: Resolved 2. High spread might cause swapped primary asset not enough to cover users debt", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Tax deduction logic is not implemented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "The Field of Mars contract uses the cw-asset library as a dependency, to facilitate the handling of both CW20 and native assets. The cw-asset library does not account for Terra taxes logic, which may cause forward-compatibility issues in the future. Even though the tax rate is currently set to zero, the tax mechanism itself has not been removed. Whilst unlikely, a future governance vote might decide to make use of the mechanism again and augment the tax as provide_liquidity() in martian-field/src/execute_callbacks.rs:18, potentially causing the loss of native contract funds due to accounting errors, and/or panics. rate, which would functions aect such", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Typos in response attributes may degrade the user experience", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "In the UpdatePosition msg, in contracts/martian-field/src/execute.rs:109, the response \"martian_field :: excute :: there is a typo in the attribute of update_position\". This may degrade the user or development experience when using this contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Remove unused code in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "The Snapshot feature in the codebase is not used anywhere in the codebase. Theres no entry point for users or contract admin to execute that function. Additionally, theres a TODO the code in contracts/martian-field/src/state.rs:12 hinting that comment should be deleted.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Outstanding TODOS are present in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "During the audit engagement, several TODO comments were found in the following code lines:  contracts/martian-field/src/execute.rs:186-187  contracts/martian-field/src/execute.rs:266  contracts/martian-field/src/execute_callbacks.rs:517  contracts/martian-field/src/state.rs:12 This implies that the contract might still be under development and not yet ready for mainnet deployment.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Withdrawal of IDO pre-fund contributions will fail in most cases due to funds being deposited in Anchor", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The function withdraw_prefund in contracts/ido-prefund/src/execute.rs will revert in most cases since most of the funds are not actually stored in the contract itself but are deposited into Anchor as soon as a certain threshold is reached. This means that withdrawal requests by end-users will fail until the funds are redeemed from Anchor into the contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Missing input validation on staking cong update might lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The function update_config in contracts/staking/src/contract.rs fails to validate the unbonding conguration provided as an argument by not calling the available assert_unbond_config function, which ensures that unbonding periods are specied in the right order to be processable by the unbonding logic. This could lead to inconsistent contract state and errors during unbonding attempts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. The staking contract owner can withdraw all reward tokens from the contract but users can not unbond without penalty", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The staking contract owner can use the function emergency_withdraw to remove all funds from the smart contract. This seems to be intended for emergency use in case of a vulnerability being detected. However, this does leave the user in a position in which they cannot use unbond to get their own funds back without a penalty.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Staking contract can run out of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The staking contract relies on being funded since rewards are transferred from the contracts balance to the user. In the case of the contract running out of funds, users are left without rewards.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Multisig implementation does not follow CW3 specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The implementation of (https://github.com/CosmWasm/cw-plus/blob/main/packages/cw3/README.md). However, does not follow the naming convention for the interface, which might lead to confusion. the multisig contract is relatively close to the CW3 specication it In addition, the code implements basic functionality that is already implemented by the CW3 reference implementation (https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw3-ex-multisig).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Multisig proposals do not expire and cannot be closed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "Proposals submitted to the multisig remain in an executable state forever. This could lead to old proposals being executed by a signer after circumstances have changed, for example, when a transaction is not relevant anymore. Additionally, the lack of support for cancelling proposals means that a proposer cannot withdraw a past proposal even if the set of signers changes through a cong change. An example of this being a problem could be a proposal having been replaced by a newer version and then accidentally being executed when the signing threshold is lowered.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Staking contract sends UST fees to arbitrary burn address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The staking contract charges a UST fee on all operations. Collected fees can be withdrawn from the contract by sending them to a burn address that can be set by the owner to any address. This is inconsistent with the burn terminology.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Reward withdrawals in staking contract charge fees even if no rewards are distributable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The withdraw function in contracts/staking/src/contract.rs does not fail when no rewards are distributable. This means that the user spends gas and fees without receiving any reward in return. Whilst this may be intentional, it is not what a user would expect as normal behaviour.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Missing tax deductions on UST transfers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "In contracts/ido-prefund/src/execute.rs UST is sent out from the contract in the functions withdraw_prefund and withdraw_ido_funds. In both cases the code fails to account for Terra taxes on native tokens, meaning that these taxes are taken from the contracts balance. In addition, functions deposit_prefund and deposit_anchor_by_admin send UST to Anchor. However, the bookkeeping of user funds takes into account taxes on UST transfers. This is unlikely to lead to the contract ever running out of funds due to fees. However, operator benets may be slightly lower than expected in certain cases.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. app.dart: Logging of sensitive information possible", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "In initCrashlytics, the following error handler is congured to record utter errors in Firebase: FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError; This conguration applies to the whole app and therefore also the wallet part. There, it is possible that sensitive information (mnemonic, private key) are included in a stack trace and sent to rebase. When an account that has access to these information is breached, an attacker can steal all coins that belong to these wallets, which happened in the past.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. No limit for unsuccessful PIN entries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "The wallet is protected by a 6-digit PIN, meaning there are 1,000,000 possible combinations (and roughly 3,000 of them are invalid because of the complexity requirements). Therefore, it will take on average 498,500 tries to nd the correct PIN, meaning a brute force attack is feasible. The wallet currently does not enforce an upper limit on the number of tries and also does not implement a measure like an exponential backo to protect users against such attacks.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Disconnecting the wallet does not require the PIN", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "When a user wants to disconnect his current wallet, he is not asked for the PIN. While this may be desirable from a UX perspective, disconnecting a wallet is a sensitive operation with potential nancial eects. For instance, when the user did not backup the wallet previously, he will lose access to the coins in the wallet.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. security_manager.dart: Initialization vector reuse in AES CBC mode", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "In onPinCodeChanged, the old key is decrypted with the old PIN and the resulting plain text then encrypted again with the new PIN. Because SecretKeyEncryptor._getInitVector returns the current initialization vector (if one exists), the same IV is used for both operations, which should not be done in AES CBC mode.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. wallet_address.dart: Insecure mnemonic generation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "To generate a mnemonic, the function generateMnemonic of the package bip39 is used. This library does not generate the mnemonic in a cryptographically secure way because of an o-by-one error: It calls _randomBytes within generateMnemonic. The _randomBytes function calls nextInt(_SIZE_BYTE) on the Random.secure() PRNG to get a random byte. This function generates random integers from 0, inclusive, to the provided maximum, exclusive. Because _SIZE_BYTE is set to 255, there is therefore no way that _randomBytes returns the value 255, meaning non-uniform randomness is used to generate the mnemonic.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. wallet_transaction_bloc.dart: Unnecessary gas estimation for FCD transfers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "In _transferFromConnectedToExternal, the gas limit for FCD transfers is estimated. This value is then passed to fcdWallet.transfer, which further passes it to _contractService.send. However, because ContractService.send has a hard-coded limit of 62,000 for FCD transfers, the whole estimation is unnecessary and never used.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. payout function may panic due to lack of fee and royalty validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "The payout function in contracts/marketplace/src/execute.rs:890-946 handles the distribution of funds when a sale is being nalized. There are a number of parties that may be paid during the sale of an NFT, such as the seller, nder, artist, and the network. Each of these parties has a dened percentage they receive which is dened in various conguration parameters. The payout function does properly validate that the sum of each of these payment parameters is not greater than 100%. finders_fee, network_fee, and royalty.share should be validated to ensure that their sum is not greater than the payment. The amounts of seller_share_msg, royalty, finders_fee, and network_fee are all independently calculated o of the original payment value with no respect to their sum. An example of a situation that would cause a panic is if a certain collection had an abnormally high royalty.share. For example, let's say the royalty.share is 95%. The subtraction of   royalty.share, network_fee, and finders_fee in line 931 would be greater than the original payment and cause a panic due to an underow (the workspace has overflow-checks enabled, which causes underows to panic).", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Misconguring stale bid duration causes operators to be unable to remove stale bids", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "the contract instantiation During in contracts/marketplace/src/execute.rs:49, msg.stale_bid_duration is not validated to have the input cast as Duration::Time, which is inconsistent with updating of parameters in contracts/marketplace/src/sudo.rs:96-98. As a result, a misconguration of initializing the stale bid duration as Duration::Height would cause the execution to fail in lines 745 and 796 because the Duration enum does not allow addition of time and height. execution message process during sudo", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Bidder can specify unchecked nders fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "and execute_accept_collection_bid lines execute_accept_bid the contracts/marketplace/src/execute.rs:513 bid.finders_fee_bps if there is no existing ask when a seller accepts a bid. This is problematic because nothing stops a bidder from specifying a very high value. While the nder's fee would still go to the sellers specied nder, it may be a proportion that is higher than the seller expected. in use and When creating an ask, params.max_finders_fee_percent, but mentioned above. the nders fee is validated to ensure that this check doesnt occur it is less than in the cases Example: 1. A user creates a bid with a very high nders fee of 90% (high but not enough to error). They would need to create a bid on an NFT that doesnt currently have an ask. 2. Owner would accept the bid 3. 4. The sellers specied nder would get nearly all of the value from the NFT sale, and If there is no ask, then bid.finders_fee_bps is used the seller would not. It is important to note that the caller still species the nder's address when accepting a bid. If this nder value was also pulled from the bid, this would be a critical issue allowing bidders to pay virtually nothing for NFTs.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Percentage and basis point values lack maximum value validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "contracts/marketplace/src/execute.rs:47 of In max_finders_fee_percent and bid_removal_reward_percent are converted to Decimal::percent values but are not checked to ensure that they do not exceed 100%. If it would be harmful to the either of these values were to be set to greater than 100%, protocol. It is best practice to enforce a hard limit on percent values. values and 50, the During the payout calculation, the nders fee could be greater than 100% which will cause the calculations to underow, but this would panic because of enable overflow-checks. Additionally, in execute_remove_stale_bid, a bid_removal_reward_percent greater than 100% would result in a reward greater than the value of the original bid. is situation in This also contracts/marketplace/src/sudo.rs:58. trading_fee_percent, max_finders_fee_percent, and bid_removal_reward_bps should all be validated to ensure that they are not greater than 100%. sudo_update_params function present the in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Sellers can update the price for inactive ask requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "execute_update_ask_price in The contracts/marketplace/src/execute.rs:306 allows the seller to update their NFT asking price without validating whether the associated ask request is expired or inactive. This might cause a misconception to the seller that their ask request is still valid and available for bidders to bid, which may not be true. functionality", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Bidders may set themselves as nder and receive nders fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "the execute_set_bid in In contracts/marketplace/src/execute.rs:334, when a bid is placed on an NFT with a FixedPrice auction, the nder is specied by the set_bid caller. That nder is then passed to the finalize_sale function and in the payout function, the address is then paid the nders fee. This function does contain any logic to verify that the nder address specied is not info.sender. This means that the function does not prevent bidders from specifying themselves as the nder and receiving the illegitimate nder fee. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Existing operators will be overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "sudo_update_params The in contracts/marketplace/src/sudo.rs:86-88 does not incrementally add operators, instead, it will overwrite the existing vector with the new operators. This may become problematic as the number of operators grows. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. A large number of hooks may cause out of gas errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "The sudo_add_sale_hook, sudo_add_ask_hook, and sudo_add_bid_hook functions in contracts/marketplace/src/sudo.rs do not impose a maximum number of hooks that may be added. As the marketplace scales, the number of hooks may begin to grow and cause out-of-gas errors. Note that this is recoverable because the contract contains hook removal functionality. It is best practice to impose a maximum number of hooks as they increase the gas cost of the call.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Release candidate dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "contract/marketplace/Cargo.toml:36-37, In cosmwasm-storage crates are specied at a release candidate version. the cosmwasm-std and As rc software is by convention still in development we suggest not using it in production.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. reserved_for should only be used when the sale type is not an auction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "When bidders attempt to bid on an existing ask request via   execute_set_bid functionality, the reserved_for value would be validated to ensure only the seller specied bidder can seen bid in asked contracts/marketplace/src/execute.rs:378-382. While this functionality is intended for sellers to reserve the sales for a specic bidder, it would defeat the purpose of the auction if the sales type is not xed price. request the on as", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. map_validate does not ensure the address vector is deduplicated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "The map_validate function in contracts/marketplace/src/helpers.rs:28-33 does not ensure that the provided vector of addresses is deduplicated, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "there While level, checks contracts/marketplace/Cargo.toml does not explicitly enable overflow-checks for the release prole. workspace overow are the at While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Potentially unexpected hook behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "There are several scenarios throughout the marketplace contract where actions may be performed without triggering the expected hooks. While this is not inherently a vulnerability, it may lead to unintended consequences if these scenarios are not explicitly considered when implementing hooks. For example, a seller can call SetAsk multiple times to eectively update/overwrite their current ask. This will trigger the HookAction::Create hook multiple times, but not the HookAction::Delete hook, which may be unexpected. The same issue is also found when setting bids.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Bridge operator has full control over funds and relies on backend service controlling a hot wallet", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The centralized design of the bridge allows the bridge operator full access to the users funds. This means the operating entity has to be fully trusted since it can withdraw users funds and censor transactions. The design comes with additional security risks in the form of a backend process (MONITOR) that manages the bridge through a single private key, which is used as a hot wallet. In case of the server being compromised and an attacker gaining access to the key, all funds are at risk, and transactions can be censored or executed at will. Furthermore, a potential DoS attack on the MONITOR could block the entire bridge functionality.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Addresses are encoded as string and not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The function receiveTokens takes a string parameter as the destination address. The reasoning behind this seems to be that some receiver blockchains use dierent address encoding. However, this means that addresses are not validated and tokens might be sent to an invalid address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Adding of new blockchains can be front-run to avoid paying the minimal fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "Adding and conguring the support for a new blockchain requires multiple transactions: - addBlockchain - setMinorTokenAmount - setMinGasPrice The function receiveTokens can be called immediately after the rst addBlockchain transaction. Such a call would allow the usage of the bridge with a zero minBRZFee. This attack might be worthwhile for an attacker if a user wants to use the bridge with a high fee.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Unused sender parameter in accept transfer function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "In the acceptTransfer function, the sender parameter is passed but not included in the transaction id calculation. Whilst the sender information does not add security, it might add value to the calculation of the transaction id for o-chain purposes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Outdated dependencies in build- and deployment system", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The build- and deployment system has several outdated dependencies with known security vulnerabilities. Some of these relate to cryptographic primitives used for deployment.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Inecient array data structure for tracking supported blockchains", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The dierent blockchains supported are stored in an array of strings. This requires an iteration of the entire list in functions like existsBlockchain.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Potential data structure optimization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "mapping(string => uint256) private minBRZFee; mapping(string => uint256) private minGasPrice; mapping(string => uint256) private minTokenAmount;", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Oracle functionality mixed with bridge logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The minBRZFee variable is required to calculate fees in the receiveTokens function. The calculation happens on-chain based on quoteETH_BRZ, gasAcceptTransfer and minGasPrice in the _updateMinBRZFee function. Currently, these variables are set by admin calls. In future versions, the quoteETH_BRZ will be provided by oracles, according to the code comments. The contract is already laid out to include oracle support in a future version. However, is not considered best practice due to poor separation of concerns. integrating oracle functionality into the bridge module itself", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Admin role also controls oracle", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The information required to calculate minBRZFee is currently provided by the admin role. This concentrates a lot of functionality in a single private key managed by the admin server (MONITOR).", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Slightly outdated OpenZeppelin release used", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x vulnerabilities. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unnecessary use of modier for authorization on private method", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The private _processTransaction method is covered by access control modiers. Authorization modiers like onlyMonitor or whenNotPaused are only required for external or public methods but not for private ones. In this particular case, they are already covered in the caller function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Unnecessary long digit constant", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "A constant is dened to represent 10^18 for token decimal conversion: uint256 public constant ETH_IN_WEI = 1000000000000000000;", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Gas Optimizations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The contracts can be optimized for more ecient gas usage in multiple places.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Querying all strategies or user strategies of the factory might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2021-08-18 Audit Report - Apollo.pdf", "body": "The factorys GetStrategies and GetUserStrategies queries are using unbounded storage iterators in contracts/apollo-factory/src/state.rs:91 and 132. As more strategies are added to the factory, the gas cost of running those queries does increase. This is not a security concern for Apollo, since those queries are not used anywhere within the current codebase. Other projects could rely on the queries though. If they do, a high amount of strategies could lead to the queries running out of gas.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Revoked collateral assets re-activated during contract migration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "When performing the migration of the collateral oracle contract, legacy collateral information is migrated to the new storage layout. During this process, every collateral is marked with in is_revoked: false The contracts/mirror_collateral_oracle/src/migration.rs:112. consequence of this is that collateral that had previously been revoked is now re-activated.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Incorrect specication of migration poll voting period", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "During the creation of a new migration poll, the voting period is dened incorrectly as that of the default poll cong in line contracts/mirror_gov/src/contract.rs:329. The impact of this would be the reduction in the voting period of migration polls, allowing less time for them to pass with a potential danger of a distributed poll deposit by the protocol.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Collateral oracles cong migration is not performed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "in The contracts/mirror_collateral_oracle/src/migration.rs:49 is unused. This implies that after the migration, the cong will not be decoded properly. migrate_config function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Admin rights cannot be revoked when claimed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "of current implementation in contract The contracts/admin_manager/src/contract.rs allows an account to claim the contracts admin rights. Upon claiming the admin rights the account becomes the target contracts admin and has the right to perform contract migrations. There is no mechanism to revoke any claimed admin rights. If the third partys account is lost or compromised, there is no way for the protocol to recover, and all locked funds might be lost forever. manager admin the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Users can grief creation of admin polls", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "Creation of a new admin poll is not possible if the number of existing polls is greater or equal to MAX_POLLS_IN_PROGRESS in contracts/mirror_gov/src/contract.rs:335. The impact of which is prevention of new admin polls being created through continuous adding of new polls. We consider this issue to be minor since it is mitigated by the fact that deposits for failed polls are distributed to stakers. Despite this cost, there is still a possibility of attackers trying to grief admin actions.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Admin and migration poll conguration can be updated in a default poll", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "If the governance cong is updated through a poll, the default_poll_config will be used in contracts/mirror_gov/src/contract.rs:435. This could enable a whale or colluding token holders to alter the conguration of the admin and migration poll types through a default poll. Subsequently, such malicious actors could execute migration and admin actions with signicantly lower poll requirements to extract value from Mirror. We consider this issue minor since the community could observe such polls and intervene by rejecting them.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Admin manager can be updated in governance contract with default poll cong", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "all admin While contracts/mirror_gov/src/contract.rs:373, an update of the admin_manager dened in the contract with the default poll cong. through the current implementation allows or migration congs actions admin imply poll After updating the admin_manager to any other address, normal messages can be used for admin actions, including contract migrations. As in the last issue, we only consider this issue minor since the community could observe such polls and intervene by rejecting them.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Migrations that run out of gas remain executable and may be triggered in the far future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "The governance contract supports migrations to be run when a poll is executed through the ExecutePoll message. Such execution, which is triggered as a sub-message in contracts/mirror_gov/src/contract.rs:615, does not have a gas limit set. If the migration (or any other message) runs out of gas, the whole ExecutePoll message will revert. As a consequence, the poll will not be changed from PollStatus::Passed to PollStatus::Failed. This implies that polls will stay open for an unlimited time. the status of This can become problematic if Terra decides to increase the gas limit for messages in the future. In such a case outdated migration messages might be triggered, which could lead to an inconsistent state of the contracts. This issue also replies to any other poll running out gas, but is especially devastating with migrations that might change the storage layout.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Addresses for migration in migration polls are not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf", "body": "When creating migration polls, addresses for the contracts to be migrated are currently not validated in contracts/mirror_gov/src/contract.rs:409. This could lead to failure of migration executions. message creation prior to", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Royalty contract owners can steal royalty funds by changing the funds recipient address.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/royalty/src/contract.rs:126 i.e recipient The update_royalty() function allows updating address and royalty rate a NFT minter wishes to charge, However, this function can also called by the royalty contract owner who can provide recipient address of its convenience in the used calculating the recipient value at contracts/royalty/src/contract.rs:126. This would allow the contract owner to rug pull all the royalty funds of the NFT minters. royalty parameters, arguments function that can", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Bidding contract owners can abuse their authority to front-run threshold values leading to unfair auctions.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/bidding/src/contract.rs:82, 151 In English auctions, bid acceptance is directly proportional to the bid amount. By changing the threshold value during the auction phase using the update_config() function, the owner can decrease the threshold value such that his bid becomes the highest and overwrites the current highest bid using the place_bid() function. Even if the owner changes the threshold value during the auction without having any intention to gain an advantage, this still leads to unfair auctions as other participants may try to outbid the current highest bid compared to the previous threshold value.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Contract owner could steal funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-contract-queuing At - src/execute.rs:249 The refund() function can only be called by the queuing contract owner and that will allow them to remove all the CW20 tokens it holds without sending the NFT to the appropriate owner who puts their order in the queue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Whitelisting in queuing contract can be bypassed by directly queuering the storage contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-contract-queuing At - src/execute.rs:114 The queue() function checks for the whitelisted address at each stage, and allows only the whitelisted addresses to claim tokens in claim(). The logic that checks the whitelisting queries the info.sender contract directly. The contract can respond to the query with any whitelisted address.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Change of storage contract address may lead to loss of funds.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/storage.rs:80 execute_change_storage()changes the storage address. This may lead to loss of funds if the storage address for the given maker address already exists and the new code_id doesnt have the appropriate functions to claim assets out of it.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Cyclic dependencies are present in auction_house and royalty contracts that would break the initialization of the respective contracts.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:37, contracts/royalty/src/contract.rs:28 Instationation of the auction_house contract requires the address of the royalty contract whilst instantiation of the royalty contract requires the address of the auction_house contract. Because of this cyclic interdependency, it would not be possible to deploy both of the contracts with valid params.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. The non-atomic nature of the place_bid function may lead to locked funds.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/storage/src/order.rs:208,209 contracts/bidding/src/contract.rs:99 To place a bid, a user needs to send funds to the storage contract rst and then call the place_bid() function of the bidding contract , which triggers the bidding_lock() function in the storage contract to lock funds. This is a 2-step process which may lead to locking of funds if the second transaction fails. To retrieve those funds users have to explicitly call the claim_assets()funciton. This process may introduce some inconsistencies and non-atomic behaviour may cause more gas consumption.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Incorrect nonce management", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:194 Nonces can be passed as a parameter when calling the approve_order()function that makes no usage no nonce as it is controlled by the user itself. This will allow the replication of order and restrict adding as new order if the same nonce gets used.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Missing tax deduction in collectors swap, LLI farmings mint and the treasurys spend function will drain contracts funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-01-13 Audit Report - Levana Stage 1 - v1.0.pdf", "body": "The collector contracts swap function can deal with native and cw20 tokens. However, in the case of in take contracts/levana-collector/src/contract.rs:285. into account code does token, native taxes not the a Similarly, contracts/levana-lli-farming/src/contract.rs:353. farming contracts mint_lli function does not deduct the LLI taxes in Likewise, contracts/levana-treasury/src/contract.rs:62. taxes are not accounted for in the treasury contracts spend function in Failure to deduct taxes will mean that the contracts funds are slowly drained.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Proxy rewards not included in active pools will be lost upon claiming", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-10 Audit Report - Astroport Core Updates v1.0.pdf", "body": "In the contracts/tokenomics/generator/src/contract.rs:231, ClaimRewards message fetches accrued proxy rewards from all active pools instead of the specied liquidity pools (see lines 748-754). When the claim_rewards function in line 982 is executed during the callback, only the specied liquidity pools will have their proxy reward index updated. This is problematic because if the provided liquidity pools do not contain all the active pools, the proxy reward index for left-out pools will not be updated, causing a loss of rewards for depositors. This issue was discovered by the client independently during the audit, but it is still present in the commit hash used for the audit.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Separation of ash loan payback verication into separate contract could allow administrator to steal funds and introduces misconguration risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "The stablecoin-vault relies on the amount being lent in a ash loan to be tracked in the separate profit-check contract, which then checks that the amount has been repaid in full. This means that the actual ashloan functionality and the repay check are implemented in two dierent admin-congured contracts. As a result, a compromised admin could congure the profit-check address in the stablecoin-vault contract to point to a custom version that does not require full ash loan repayment for its own loans and use the ashloan function to extract user funds from the vault. In addition, having two independent contracts in a 1-to-1 that have to be congured separately with the corresponding address pointers to each other is error-prone and could lead to accidental misconguration.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Systemic dependence on Anchor may impede the ability to stabilize the UST peg via arbitrage during bank run cycle", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "The litepaper explains how bank run cycles can be a threat to the UST peg. If systemic risks materialize in the form of an event that has an impact on the whole Terra ecosystem, this will likely impact Anchor as well. In addition, a malfunction of Anchor or a bank run on Anchor might trigger substantial corrections in the Terra ecosystem. The fact that only a xed amount of UST  i.e. the stable_cap  is meant to remain in the vault will decrease the ratio of UST/aUST in the vault with increasing liquidity in the vault. With a growing amount of liquidity in the vault, the ability to stabilize the UST peg via arbitrage will depend more and more on Anchor being seamlessly working, which is not guaranteed during a bank run cycle. there Moreover, setting contracts/stablecoin-vault/src/contract.rs:770 meaning that the value could be set unrealistic values accidentally. validation when no is the via stable in set_stable_cap, cap", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Fixed fee buer might lead to failure of large ash loans", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "In contracts/stablecoin-vault/src/contract.rs:37, FEE_BUFFER is set to a constant value. The buer is used in line 268 to assure that the contract has enough liquidity to pay taxes and fees. The messages for the fees and taxes are then created in lines 295 and 299 as functions of the amount and fees/taxes. If fees and taxes exceed the buer, large ash loans might fail because they will not be protable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Flash loan and treasury related messages could run out of gas due to too many whitelisted contracts, assets or dapps", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "In contracts/stablecoin-vault/src/contract.rs:244 the handle_flashloan function might run out of gas if the number of whitelisted_contracts gets very large. As this is unlikely and can only happen through governance motions this is only a minor issue. Similarly, in contracts/treasury/treasury/src/contract.rs an unlimited number if the of assets might cause executions of dapp-messages to fail by running out of gas, transactins uses the query compute_total_value. Lastly, in contracts/treasury/treasury/src/contract.rs:160, the removal of a dapp might fail if there are too many dapps and the message runs out of gas. This might not be a big issue, since the hite Whale architecture gure indicates that dapps will be limited.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Unvalidated and too high fee parameters might cause errors in production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "In contracts/stablecoin-vault/src/contract.rs:838-856 all fees in set_fee can be set to values equal to or larger than 1. These can cause errors, e.g. in line 428, where Decimal::from_ratio(amount - treasury_fee, total_share) causing the withdrawal functionality to fail. Similarly, we highlight for informational purposes, that the validation of new_fee.share > Decimal::one() in contracts/treasury/dapps/vault/src/commands.rs:293 allows for a fee equal to 1, which would trigger inecient messages.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Anchor exchange rate might be out of date and as a consequence transactions might fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "In the contracts/stablecoin-vault/src/contract.rs:271 query_aust_exchange_rate functionality is used in the simplied form without the current block height as an input parameter. Anchor in this case uses stored values to calculate the exchange rate, which might be out of date. This implies that there may be imprecisions in the Anchor withdrawal message below in lines 451-454 and 655, which could lead to a failure in execution.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Denomination check is incomplete", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "In packages/white_whale/src/denom.rs the length (size of the String) of a denomination is checked to be smaller than or equal to ve in order to determine whether a given token is a native token. This might fail because a coins Denom can have between 2 and 127 characters.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Zero amounts being sent in messages will fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "In contracts/treasury/dapps/terraswap/src/commands.rs:133, 120 and 172, zero amounts might be sent. These messages will always fail since zero transfers revert.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Canonical address transformations are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf", "body": "While previously recommended as a best practice, usage of canonical addresses is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Lack of accounting for slashing could lead to a bank run, resulting in loss of funds for slow depositors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "to for The due logic example slashing. The codebase does not handle any reduction in a pools total value locked, which could happen the TransferWithdrawalToLocalChain function is implemented with the assumption that the amount returned by the unbonding callback will be equal to the amount specied at the beginning of the unbonding request. In the event that slashing occurs, the module will have a lower than expected balance which will cause later withdrawal requests to fail. This will create a situation where early withdrawals can be fully lled while later withdrawals will fail once the module's balance drops below the requested withdrawal amount. These withdrawals will fail until the module's balance is re-capitalized. The missing amount would need to be fully refunded to the modules balance for all users to be able to successfully withdraw their initial amounts. in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Updating the validator set of a pool does not trigger a redelegation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "If the proposal passes, The parameters of a pool can be updated through an update-pool proposal, including any changes to the validator set. the pool will be updated in x/millions/keeper/keeper_pool.go through the UpdatePool function. However, a change in the validator set does not trigger a redelegation to the new set of validators, instead only the ag isEnabled is updated. Any new deposits will be delegated to the new set of validators but for existing delegations to be updated, depositors need to withdraw, wait for the three-week unbonding period and redeposit.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Delegated funds cannot be redelegated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The codebase does not send redelegate packets, thus the function RedelegateCallback In the situation in x/millions/keeper/callbacks_redelegate.go is never used. where delegations need to ow from one validator to another (e.g. if a validator stops validating blocks) after the validator set got updated through the update-pool proposal, every depositor would need to manually withdraw, wait for the three-week unbonding period, and redeposit. This will require coordination, manual actions by users and impact the overall staking returns, as some depositors may not follow those steps and others have to wait for the unbonding period.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. DrawRetry will always fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The function DrawRetry in x/millions/keeper/msg_server_draw.go:13 does not behave correctly, and as a result, the draw will never be able to be re-executed. The and ClaimRewardsOnNativeChain, ExecuteDraw functions are all incorrectly called with the parameter draw.PoolId instead of the DrawID. This will cause the TransferRewardsToLocalChain and ExecuteDraw functions to fail due to an erroneous draw state. The ClaimRewardsOnNativeChain function will be executed successfully, claiming pool rewards but returning a wrong draw, unless draw.DrawId is equal to draw.PoolId. This means that any draw that fails its initial execution, will be stuck in an erroneous state. TransferRewardsToLocalChain,", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. MinDepositAmount is not strictly enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The function SetParams in x/millions/types/params.go:21 does not explicitly validate that the value of MinDepositAmount is not zero. Although a proposal to update the parameters would prevent a minimum deposit amount of zero, as it is caught in the update_params messages ValidateBasic function, MinDepositAmount could be set to 0 during genesis without causing an error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The chain could be spammed with deposits of negligible amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The function SetParams in x/millions/types/params.go:36 does not enforce a reasonable minimum acceptable amount for MinDepositAmount. Thus, the parameter can theoretically be set close to zero, allowing for spam deposits with negligible amounts. The LaunchNewDraw function is triggered by the BeginBlocker function and iterates over an unbounded loop of deposits. The ability to add a high amount of negligible deposits can allow an attacker to slow down or even halt block production. The minimum deposit needs to be reasonably high to provide enough nancial disincentive against such an attack. We classify this issue as minor since governance controls this value.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. An updated InitialDrawAt cannot be enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The ShouldDraw function in x/millions/types/draw_schedule.go returns true if a draw should be executed. For the rst draw, it will only return true if it is passed the InitialDrawAt parameter of DrawSchedule. However, if the draw schedule is updated through a proposal and a new InitialDrawAt is set to a time in the future, this will not be enforced since the condition in line 46 will not be met. Thus, draws will continue to be drawn every DrawDelta, even if InitialDrawAt has not been met.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Missing validation checks in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "There are missing or insucient validation checks in the codebase:  The PrizeBatch validation in x/millions/types/prize_batch.go:19 allows for a DrawProbability of 0. A prize strategy that has 0 draw probability for all batches would make it impossible for the pool to have a winner.  The FeesStakers parameter is not validated in x/millions/types/proposal_update_params.go.  The DrawSchedule validation in x/millions/types/draw_schedule.go:10 does not check if DrawDelta is less than the MaxDrawScheduleDelta. Use the ValidateNew function for validation of DrawSchedule instead.  The PoolId, DepositId, and ToAddress are not properly validated in in MsgWithdrawDeposit x/millions/types/message_withdraw_deposit.go:36.  In the in MsgDeposit's x/millions/types/message_deposit.go:49, the msg.Amount is being checked to ensure the amount deposited is not negative, but it does not check if the amount is 0. ValidateBasic function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Inactive validators may receive delegations, reducing protocol yield", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "DelegateDepositOnNativeChain The in x/millions/keeper/keeper_deposit.go:111 delegates deposits to the native chain of the pool. However, it is possible for a validator to have already stopped validating and unbonded at the time the latest pool validator set has been proposed and approved. This would allow delegations of pool deposits to inactive validators that will not produce any yield. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. PrizeExpirationDelta parameter can be set to a value that prevents prize claims", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The function ValidateBasics in x/millions/types/params.go:36 would allow for a PrizeExperiationDelta as short as a second. Very short periods would prevent winners from claiming their prizes. We classify this issue as minor since it can only be caused by governance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. FeesStakers parameter can be set unreasonably high", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The function ValidateBasics in x/millions/types/params.go:36 does not prevent an unreasonably high value for the FeesStakers parameter. Although this parameter is controlled by governance, it is possible to be set close to 1, which would mean that all draw proceedings will be taken as fees, causing depositors to receive only a minimal amount of rewards.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Redundant checks are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "The codebase contains redundant checks that lead to ineciencies:  The last draw state check in x/millions/keeper/keeper_draw.go:51 is a through duplicate it x/millions/keeper/keeper_blockers.go:375, ListPoolsToDraw. validation invoked already as is  The ValidateDenom function in x/millions/types/pool.go checks the length of the denomination inside the function. The validation checks in lines 20 and 26 can be removed.  The validation to check if the sender has sucient balance in is  The x/millions/keeper/msg_server_deposit.go:60-62 is duplicate as it already checked in the SendCoins function called in line 79. sanitizedDenom in x/millions/keeper/msg_server_deposit.go:34 can be removed if a stateless check is performed in the message ValidateBasic function in x/millions/types/message_deposit.go:37. function  A length of validators check in x/millions/keeper/keeper_pool.go:251 is in duplicate x/millions/types/proposal_update_pool.go:49. checked already being as is it  The in x/millions/types/message_deposit.go:53 can be removed as it is being checked already through the AccAddressFromBech32 function in line 55. strings.TrimSpace call  All the transaction commands in x/million/client/cli/tx.go:25-30 call msg.ValidateBasic. This is unnecessary, since the function is already invoked in the GenerateOrBroadcastTxWithFactory function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Outstanding TODO comments in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "There are multiple TODOs in the codebase that may refer to important logic. Instances are:  x/millions/keeper/keeper_draw.go:199  x/millions/keeper/keeper_pool.go:85", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Inaccurate messages may confuse or mislead users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "Across the codebase, instances of inaccurate messages have been found, that could confuse or mislead users.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Missing usage description for all transaction and query CLI commands", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "the and transaction in All and x/million/client/cli/tx.go:25-30 x/million/client/cli/query.go:37-59 are missing a long message that describes their usage, which would be helpful for users and external developers. the Millions module query CLI commands for", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Code ineciencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "There are several parts of the codebase that can be optimized to perform stateful and stateless checks, reduce computational resources and gas consumption:  Trim whitespace to catch more cases of invalid values instead of just empty strings for the parameters ChainId, Bech32PrefixAccAddr, and Bech32PrefixValAddr in x/millions/types/pool.go:13, ValidateBasic.  In x/millions/types/message_deposit.go:44-51, using msg.Amount.Validate can replace the implemented functions.  In x/millions/types/proposal_register_pool.go:59-64, validation checks with strings.TrimSpace can be replaced with the ValidateDenom function from Cosmos SDKs types package.  The ComputeSplitDelegations in x/millions/keeper/keeper_deposit.go:130-133 and 158-161 can be combined. function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Code quality could be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "Across the codebase instances of unused or commented code have been found.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Unused pool states", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "the pool states PoolState_Paused and PoolState_Killed are unused. Currently, Additionally, in x/millions/keeper/msg_server_deposit.go:15 allows for deposits to be made to a paused pool. If a paused pool state was implemented in the future without updating this function it could be problematic. Deposit function the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Additional rewards are ignored", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf", "body": "the OnClaimRewardsOnNativeChainCompleted ignores additional coins Currently, returned in the ICA claim rewards callback if they do not match the module account. With interchain security, it is becoming more common to expect chains to return more than one type of reward coin. Overall this would also increase the rewards users receive. there in Additionally, x/millions/keeper/keeper_draw.go:193 that iterates over every coin received. While the likelihood of receiving a large amount of additional coins from a trusted chain is low this edge case should still be handled. unbounded iteration an is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Users will not get native assets back when borrowing them from borrowed farm", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "In the callback_unbond_hook function, stakers that borrow native assets should receive the swapped amount since the pairs swap_msg functionss to parameter to see Some(staker_addr.to_string()), contracts/borrowed-farm/src/bond.rs:407. For native assets though, there is a bug in packages/alpha-homora-v2/src/adapters/pair.rs:206. Consequently, a swap of native assets would be called with None set as the to parameter, which would lead to the swapped funds being stuck in the borrowed farm contract. swap_msg functions is set apply value does that not the the to in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Attackers may delay price update transactions by feeders to manipulate oracle prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the When feeders feed prices to the oracle contract, PriceInfo is set to the current block timestamp. When querying prices from the oracle, that last_update_time value is used in contracts/oracle/src/contract.rs:265 to check whether the last updated price is too old. An attacker (or colluding validators) may exploit this by delaying transactions to shift price updates. the last_update_time of Suppose that a feeder sends a price update transaction in block 12345. An attacker may execute a DOS attack on the target node or the feeders infrastructure to prevent the inclusion of the transaction until some point in the future (e.g. block 13000). In that later block 13000, the price will be accepted and will be considered up to date. That allows an attacker to shift prices around to their benet.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. New borrowers using Homora Bank will pay fees for older borrowers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "During borrows and repays in the Homora Bank contract, the current debt state is updated in In that function, the interest accrued within the Red the update_debt_state function. Bank is calculated, and a proportional Homera fee is stored in state.homora_fee. When a user now repays their loan, they will have to pay that homora_fee proportionally to the in amount contracts/homora-bank/src/contract.rs:462-464 does not account the duration a user has been borrowing though, which implies that new users pay the fees for previous users. current mechanism implemented for repay. debt they The of As an example, suppose there is a current debt of 100 in the Homora Bank and a homora_fee of 10. Now a user is borrowing 100 tokens and immediately repays these 100 tokens in the same block. The current logic will charge that user a proportional fee of 10 * 100 / 200 = 5 tokens.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Tokens with low price may have wrong price quoted by oracle due to loss of precision and price impact of probe amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "calculating in When contracts/oracle/src/contract.rs:297, the price_multiplier, which eectively truncates any decimals beyond 6 decimal places. This is a major issue for tokens that have very low prices and many decimal places. For is multiplied price the in price median oracle the the by example, a token with 18 decimal places and a current price of 0.0000018 would be wrongly represented within the Alpha protocol with a price of 0.000001. Additionally, the probe amount may lead to too much of a price impact for tokens with a low token price.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Wrong interest rate is used when withdrawing from lending bank, leading to small losses for other users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "to interest rates are During the execute_withdraw function of the lending bank contract, updated in withdrawal contracts/lending-bank/src/contract.rs:701. With the linear interest model, a withdrawal implies that utilization goes up, which means that both the borrow rate and the liquidity increase. balance reect after new the in line 707, the balance after withdrawal is calculated. Within that calculation in the Then, get_updated_liquidity_index function, the new liquidity rate is used to update the liquidity index. Since the liquidity rate went up, the liquidity index is higher than it should be. This implies that the user will have fewer IB tokens burned than they should have. The protocol and hence other users will take the dierence. The impact of this issue depends on the activity of the protocol with high amounts locked, small burned amounts and frequent interactions that update interest rates, the impact of a wrong index is rather minor. If there are big withdrawals and less frequent interactions though, there can be material losses for other users.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Adjusting positions up will fail if borrow asset is native but provide asset is CW20 or vice versa", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the In method contracts/borrowed-farm/src/adapters/leveraged_farm.rs:73, wrong borrow_asset_info is sent in line 75. increase_position_msgs provide_asset_info whether native check is a in there is a while asset, This is no issue if both tokens are either native or both are CW20 tokens. If they are of dierent asset types though, no funds of borrow_asset_info will be sent or no allowance will be increased, which will lead to a failure of the execute_adjust_position function when positions are increased in contracts/borrowed-farm/src/bond.rs:557.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Oracle uses median of recent (spot) prices, may be subject to spot price manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "Dierent functions in the protocol query the oracle contract for asset prices. Each asset has those prices in the dierent price sources, and the oracle returns the median of query_asset_price function in contracts/oracle/src/contract.rs:297. All of the price sources use a single stored or queried price. Some of those price sources use spot prices. Spot prices can be manipulated, for example by swapping large amounts of tokens before using the Alpha contracts. Depending on the conguration of an asset, this may allow manipulation of the median price, and hence may be exploited by an attacker. We classify this issue as minor since spot prices are only supposed to be used for testing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Swap amount calculation does not account for taxes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "function get_swap_amount in The contracts/leveraged-farm/src/deposit.rs:81 and 102 on the amounts prior to deducting tax, which happens in lines 84 and 104, respectively. That implies that the swap calculation will be slightly o, and the small dierence will be arbitrated away by external actors. While the impact of this dierence is small, it will take away from a users yield and is easily prevented. called is We consider this issue to be minor since the impact is relatively small.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Repayment may fail if amounts are small", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "During repayment, in the callback_repay function, a swap happens between asset A and asset B to settle outstanding debt from bank A and bank B. Those swaps have a condition to tokens swap in contracts/leveraged-farm/src/withdraw.rs:181 and 197. If that minimum is swapped, the remaining amount of the bid asset might not suce though to repay the other loan. minimum of a", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Swap calculation in leveraged farm uses hardcoded fee and will be wrong if the underlying fee is changed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "get_swap_amount The in contracts/leveraged-farm/src/deposit.rs:43 assumes that the underlying pool swap fee is 0.3%. That value is hardcoded in the formula and hence calculated swap amounts will be wrong if the underlying swapping protocol changes their fee. function same exists The contracts/borrowed-farm/src/bond.rs:527. issue the in execute_adjust_position function in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Lack of price validation in oracle might cause issues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "Prices from feeders are currently not validated. Feeders could (accidentally) set a price to zero in contracts/oracle/src/contract.rs:133. That causes inconsistencies in the protocol, for example in health checks of a position.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Cong parameter validation missing in Homora Banks init asset cong", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the Homora Bank, conguration In the execute_init_asset_config function of parameters in are contracts/homora-bank/src/contract.rs:175-180. If those parameters are set to invalid values, the collateral_factor is set to zero. the protocol might not work as expected  for example if validated not neither Additionally, execute_update_asset_config function currently validate the fee_rate or liquidation_bonus. execute_init_asset_config nor the the the We consider this to be a minor issue since it can only be caused by the owner and is recoverable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "In packages/alpha-homora-v2/src/adapters/asset.rs:318, Luna is treated as a special case for tax calculations, with a hard-coded zero tax value. However, this might lead to inconsistencies if Terra changes the Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, misusing funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Reliance on assumed received amounts might cause issues in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "In several places in the codebase, the implicit assumption is made that another contract is sending a requested amount. Even if correct today, that assumption might be wrong in a future update of a dependent contract, for example, if fees are introduced that reduce the sent amount. An example of this can be found in the Homora Bank contract, where an asset is borrowed from the bank in contracts/homora-bank/src/contract.rs:387. Then the asset is sent to the borrower in line 389, without verifying that the requested amount has actually been received.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Failing swap simulation in leveraged farm may lead to high arbitrage losses when providing liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "If the swap simulation in contracts/leveraged-farm/src/deposit.rs:89 or 109 fails, a zero value is used. Swapping is then skipped in lines 91 or 111, but the liquidity is still provided and the position increased. This may cause liquidity provision with a ratio that is far away from actual pools of the AMM, and the dierence will likely be arbitraged away by external parties, leading to a loss of value.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Spot price queries from oracle may return wrong prices if neither asset is UST", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the function, query_spot_price In in contracts/oracle/src/contract.rs:331-335 that one of the two assets of the pair the price will always be quoted in assets[1]. This is is UST. problematic, since a misconguration of the pair would lead to the protocol executing with wrong prices, rather than returning errors. assumption is made thats not the case, implicit the If", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Interest rate calculation does not account for leap years/seconds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "SECONDS_PER_YEAR in The contracts/lending-bank/src/interest_rates.rs:20 has a value of 31536000 seconds, which corresponds to 365 days (a non-leap year). This implies that in leap years and when leap seconds are used, the interest rate will be slightly higher than expected. constant", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Querying the lending banks market list, user debt and user positiont may run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "The query_markets_list, query_user_debt, and get_user_asset_positions in functions unbounded and contracts/lending-bank/src/contract.rs:1079, contracts/lending-bank/src/accounts.rs:73. That may run out of gas. iterations markets contain stored 1104, over all", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Max di value validation in borrowed farm is executed on previous value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the execute_update_position_parameters In in contracts/borrowed-farm/src/contract.rs:297, validate_percentage is called with the previous max_diff value, not the newly set one. That allows a max_diff value that is bigger than 1. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Balance updates performed from precompiles are overwritten if the precompile is executed in a transaction with other state change logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "Delegate in The precompiles/staking/tx.go:59 and precompiles/distribution/tx.go:67 are not correctly committing balance changes if the caller function performs state changes. WithdrawDelegatorRewards precompiles dened and Consequently, attackers could craft a contract where it is possible to delegate to a validator without having the delegated amount deducted from their balance. users the Additionally, WithdrawDelegatorRewards precompile could lose their rewards, depending on the contract implementation. leveraging contract interact with that a A test case reproducing the issue is provided in Appendix 1. This issue as well as the test case in Appendix 1 has been disclosed by the Evmos team to Oak Security during the audit.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. User distribution authorizations can be misused by malicious contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The state transition functions of the distribution module require the user to authorize the to execute the SetWithdrawAddress, WithdrawDelegatorRewards, and caller WithdrawValidatorCommision functions. Failure to do so would result in the transaction's inability to interact with the distribution precompile. However, the distribution precompile lacks the functionality to revoke authorization once granted, resulting in smart contracts having access granted until the authorizations expiry. Although a user can revoke the authorization directly through the Cosmos SDKs authz module, this defeats the purpose of having the precompile in the rst place.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. The bech32 precompiler is not loaded in the EVM", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The x/evm/keeper/precompiles.go:20-41, initializes the list of available precompiles. AvailablePrecompiles function, dened in However, the bech32 precompile is not added to the list, which renders the precompile inaccessible in the EVM. Additionally, return a valid precompile address. in precompiles/bech32/bech32.go:63, the Address function does not Consequently, the bech32 precompile cannot be executed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Validators and Redelegations queries are not callable from EVM precompiles", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The validators and redelegations functions are available in the staking precompile at precompiles/staking/Staking.sol:201 and 227. However, the implementation of both functions in precompiles/staking/tx.go is missing, rendering the functions uncallable from EVM-based smart contracts.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Queries do not support pagination, enabling attackers to DOS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The query implementations do not support result pagination. This could be problematic since some of the implemented Cosmos SDK queries could return a large number of items. Some examples are the ValidatorSlashes and DelegationRewards queries dened in precompiles/distribution/distribution.go:160. Additionally, gas is not charged depending on the size of the query result size, but rather on the query input size. This could allow malicious actors to execute computationally and memory-heavy queries with a disproportionate gas cost, which could slow down block production up to the point where the chain halts.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The Approve function does not allow ne-grained Coin allowances, allowing more Coins than intended in case of multiple messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The Approve function dened in precompiles/staking/approve.go:32 iterates through a list of user-provided Cosmos SDK message types to allow a grantee to execute them on behalf of the user with the amount of user-specied Coins. However, because of the chosen input data structure, an encoded (Address, Coin, []string) tuple, it is not possible to specify how many Coins are to be used for each individual message. This results in allowing each message type with the Coin dened in the input parameter. Consequently, the total allowance will be dierent from the specied input since it will be equal to the cardinality of messages multiplied by the provided Coin. For example, a message with an allowance of 1ucoin and four message types will result in a total allowance of 4ucoin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Wrong reservation assignment could lead to incorrect receiver for NFT", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "In contracts/contracts/stardust-nft-distribution/src/contract.rs:222, the senders address is assigned to the reservation. Since the contract owner and operator are able to create reservations on behalf of users, this might lead to the contract owner or operator receiving the NFT, rather than the reservation owner, even though the reservation owner paid for the NFT. This could lead to lost NFTs, for example, if the owner or operator is a smart contract such as a governance contract that cannot transfer NFTs.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Missing check for makers ability to cover the maker fee leads to incorrect validation query result", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "query_validate in The not contracts/contracts/stardust-settlement/src/queries.rs:9 validate whether the maker has enough stardust balance to cover the maker fee charged in when contracts/contracts/stardust-settlement/src/order.rs:117 checking if an order is suciently capitalized. This will lead to undercapitalized orders being returned as valid, which is incorrect. function does", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. NFT ownership is not cleared when NFTs are withdrawn, which leads to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "The settlement contract does not clear the stored NFT_OWNER for an NFT when a user sends the Withdraw message. NFT ownership is only updated on deposit in the in deposit_balance contracts/contracts/stardust-settlement/src/state.rs:70, but not cleared in in leads to contracts/contracts/stardust-settlement/src/state.rs:80. That an inconsistent state. withdraw_balance function function the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Setting royalties in settlement contract fails for CW1155 tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "of the part settlement in As contracts/contracts/stardust-settlement/src/royalties.rs:22, the minter of the token is queried. That query uses the CW721 contracts Minter query, which does not exist for CW1155 tokens. Consequently, royalty fees can only be set for CW721 tokens, not for CW1155 tokens. set_royalty contracts function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Submit execution plan will fail due to message sent to wrong contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "the In contracts/contracts/stardust-settlement/src/execution.rs:131, ValidateAndTransferExecutorBalance message is sent to the executor contract, but the executor contract does not accept that message.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Missing check for ability to execute an order leads to misleading validation query result", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "query_validate in The the contracts/contracts/stardust-settlement/src/queries.rs:10 validate_into_info function with None as the last argument. That leads to a skip of validation whether a particular account can actually execute the order. This implies a misleading query result since a successfully validated order might fail validation during execution. function calls", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Querier contracts order update returns a misleading taker asset lled value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "the querier In contracts/contracts/stardust-querier/src/contract.rs:132, taker_asset_filled is set to a value of 0 for orders   that are undercapitalized, lled or cancelled. A 0 ll value is inconsistent. OrderUpdate contracts logic in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Closing an English auction leaves the maker order open", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "the in In function contracts/contracts/stardust-auction/src/contract.rs:132, the maker order is not closed when closing the English auction. That leaves dangling maker orders, leading to an inconsistent state. close_english_auction", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "In contracts/packages/stardust_protocol/src/asset.rs:35 Luna is treated as a special case for tax calculations, with a hard-coded zero value. However, this might lead to inconsistencies if Terra changes Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, leading to any user funds being spent.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Approve and transfer pattern implies a bad user experience and might introduce security issues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "In several places in the codebase, the protocol relies on the approve and transfer pattern. It is generally better to use CW20 receive hooks, as they provide a better user experience (they do not require a separate approval and do not require revocation), are more gas ecient, and are usually more secure since approvals have often a disproportionate size and no expiry.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Relayer fees are skipped if either taker or maker fee is zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "in The contracts/contracts/stardust-settlement/src/order.rs:94 contains the logical or || operator instead of the logical and && operator. This leads to no fees are being charged if either the maker or the taker fee is zero statement if", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Missing input validation of order infos and ll amounts in order execution might confuse users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "execute_orders in The not contracts/contracts/stardust-settlement/src/order.rs:149 validate whether two arrays order_infos and fill_amounts are of equal length. If they are not, any excess elements will be ignored. That might be unexpected for users. function does", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Overow checks not enabled for release prole in all packages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf", "body": "in the workspace level contracts/Cargo.toml, some packages do not While set explicitly enable overow checks. This is not a security concern in the current version of the contracts since the checks are enabled from the workspace to all packages, but future refactoring might leave some packages vulnerable to over- or underows. Packages that currently dont have overow checks enabled are:  contracts/contracts/stardust-settlement/Cargo.toml  contracts/contracts/stardust-auction/Cargo.toml  contracts/contracts/stardust-executor/Cargo.toml  contracts/contracts/stardust-nft-distribution/Cargo.toml  contracts/contracts/stardust-querier/Cargo.toml  contracts/contracts/stardust-registry/Cargo.toml", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Borrowers can prevent liquidation leading to bad debt accumulating", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "liquidating When in contracts/credit-manager/src/vault/liquidate_vault.rs:154-166, all the borrowers unlocking positions are processed in a loop. A borrower can create many tiny unlocking positions using the RequestVaultUnlock message, causing the total unlocking positions cardinality to grow to the point where the liquidate_unlocking function runs out of gas. collateral This is highly problematic, since borrowers can prevent being liquidated, which can result in bad debt accumulating.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Liquidators can extract a higher value by looping small amounts of liquidations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In the contracts/credit-manager/src/liquidate_coin.rs:119-127, request_amount is rounded up using the ceil function. This allows a liquidator to extract a higher value by liquidating small amounts of collateral within a loop. Additionally, the maximum close factor can be bypassed as long as a single liquidation message does not exceed the limit, allowing the total liquidated amount to be higher than the congured limit. We consider liquidations consumes a lot of gas, which decreases the protability of the attack. instead of critical this a major issue because performing multiple small Please see the test_repeated_single_liquidation test case to reproduce the issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Contract version and name are overwritten during instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "the In contracts/account-nft/src/contract.rs:23-36, during instantiation of account-nft contract, in contract/account-nft/src/contract.rs:29-33 and then again during the call of the parent contract instantiation in contract/account-nft/src/contract.rs:35. the version and name of the contract are set twice. First This implies that the stored CW2 metadata would be the one from the cw721-base contract and not the intended one, potentially causing problems in future migrations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Duplicate keys should be removed to prevent miscongurations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "contracts/credit-manager/src/instantiate.rs:19-25 and In contracts/oracle-adapter/src/contract.rs:47-49, the msg.allowed_vaults, msg.vault_pricing and msg.allowed_coins are not deduplicated before storing them. If any allowed vault addresses or coin denominations are duplicates, earlier congurations would be overwritten, and only the last key would be saved successfully. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Update of the account-nft address can lead to state inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the account-nft contract. This can cause state inconsistencies as account ids associated with the previous NFT contract are removed. Also, owners of NFTs from the old contract will lose access to their funds managed in the credit-manager that will be virtually transferred to the owners of the NFTs from the new contract. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Funds held by swapper contract may be unintendedly withdrawn", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "When performing a swap in the swapper contract, the output is transferred to the recipient using in message contract/swapper/base/src/contract.rs:187-194. TransferResult created a Then any amount of contract/swapper/base/src/contract.rs:234. the denom_in and denom_out is transferred to the recipient in However, in the case that the swapper contract holds additional funds of either denomination those would be automatically sent to the recipient in addition to the input and output amounts. We classify this issue as minor despite the fact that no funds should be present in the swapper contract there may be situations where funds are sent to the contract, e.g. an airdrop or inadvertent usage.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Update of the red bank address in the credit-manager could lead to state inconsistency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the red bank in the credit-manager. This would cause state inconsistencies since all the data stored in TOTAL_DEBT_SHARES and DEBT_SHARES will not be updated accordingly.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. The execution of the AssertBelowMaxLTV callback at the end of the UpdateCreditAccount transaction could run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In the contracts/credit-manager/src/execute.rs:285-288, AssertBelowMaxLTV is always added to the list of callbacks to execute after the other Actions provided as an input in the UpdateCreditAccount message. This callback is executing two times an unbounded loop through the COIN_BALANCES, DEBT_SHARES and VAULT_POSITIONS vectors that have not a capped length. Also, it is executed after all the other Actions and Callbacks so it has only a fraction of the initially provided gas. This implies that if the cardinality of the vectors is signicant, the remaining gas could not be enough to pay the computation leading to out of gas errors. While this scenario is not likely to happen at the launch of the protocol, the risk of running out of gas will increase with more assets supported and wider adoption.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. MAX_CLOSE_FACTOR is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "the contract owner In contracts/credit-manager/src/instantiate.rs:15, denes the MAX_CLOSE_FACTOR of liquidations which determines the maximum amount of a position that can be liquidated. However, ineectual and not providing a limit to the value that can be liquidated in a single transaction. the value provided has no validation which could lead to the variable being", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Query silently returns input when no pricing method is found.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "function The in contracts/oracle-adapter/src/contract.rs nds the pricing methodology of the coin denom and queries the relevant vault to calculate the value of redemption. query_priceable_underlying If the submitted coin denom does not have a vault price then the input is simply returned to the user. This could lead to wrong assumptions and may negatively impact the usability of the query.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Redundant checks on received funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "the try_from function attempts to In packages/rover/src/coins.rs:136-158, verify that no zero amount denom and no duplicate denoms are provided. This check is unnecessary because Cosmos SDK will prevent zero amounts from being sent (an error will occur) and will automatically combine duplicate denoms into one single denom (eg. [200 ATOM, 100 ATOM] will become [300 ATOM] ).", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Contracts should implement a two step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Custom access controls implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "The contracts within the scope of this audit implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/account-nft/Cargo.toml  contracts/credit-manager/Cargo.toml  contracts/oracle-adapter/Cargo.toml  contracts/swapper/Cargo.toml  packages/rover/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Unbounded number of steps during route registration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In contracts/swapper/base/src/contract.rs:246-274, is able to dene custom swap routes between token pairs in order to facilitate the exchange of tokens that do not have a shared pool. However, the number of steps a route is able to host is unbounded which could lead to inecient routes being dened. the owner", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unused callback should be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "ForceExitVault The packages/rover/src/msg/execute.rs:147-151, protocol and should be removed from the codebase to increase its maintainability. in dened is not used anywhere in the callback", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Users' inactivity could permanently freeze the protocol", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "calculate_streaming_fee The in contracts/core/src/state/mod.rs:44-75 calculates the time-weighted streaming fee with the following formula: function dened  = (1 +   )   1 where  is the elapsed time since the latest stream fee application. If this time delta gets too big, the exponential operation could perform an overow, reverting the message handling. This could happen, for example, after a chain upgrade or during a bear market where users are less interested in interacting with the contract. Since the calculate_streaming_fee function is executed for each Execute message, its overow and revert of the message would permanently freeze the protocol. A test case is provided in Appendix 1.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Rebalance nalization may become unachievable due to streaming fee collection", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "Streaming fees are collected via the collect_streaming_fee function implemented in in contracts/core/src/execute/fee.rs contracts/core/src/contract.rs:67, including rebalance messages. execution message every on If the deation target units are attained during rebalancing (i.e., target_unit == current_unit  notice the strict equality check), decrementing the collected fee from the current asset units in line 139 of the collect_streaming_fee function will result in an inability to pass the strict equality check in the finalize function. As a result, rebalancing becomes stuck and cannot be nalized.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Inability to inate an asset caused by using the wrong coin denomination for swapping the reserve to asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "The inflate function incorrectly uses the RESERVE_DENOM constant as the token_in argument in contracts/core/src/execute/rebalance.rs:436. msg_swap_exact_in call the for Since RESERVE_DENOM has a constant \"reserve\" value, which is not a valid coin denomination, the intended swap fails, causing the transaction to revert.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Asset deation uses wrong swap direction by swapping the reserve to the asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "The process of deating an asset during rebalancing involves swapping an exact amount of the asset (denom) to the reserve (token.reserve_denom). in the current However, in implementation, contracts/core/src/execute/rebalance.rs uses the asset coin denomination denom as the token_out argument for the msg_swap_exact_out function, resulting in the reserve being swapped to the asset rather than the intended swap of the asset to the reserve. deflate function the", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Deating an asset distributes the asset amount rather than the reserve amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "The deflate function within contracts/core/src/execute/rebalance.rs is designed to distribute the reserve amount received to the RESERVE_BUFFER via the distribute_after_deflate function for subsequent asset ination. However, the current implementation mistakenly distributes the asset amount instead of the reserve amount. This can lead to incorrect accounting of reserves and prevent subsequent ination of assets.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Total supply is not correctly computed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "In contracts/core/src/execute/mod.rs:100, during the execution of Burn messages, the total supply is decreased by the amount of the received tokens. However, since part of the users provided tokens is sent to the fee_collector because of the burn fee, the computed total supply is not correct because it is not accounting for the fees. This implies that the total supply recorded in the contract is smaller than the actual one and a Burn message from the fee_collector would redeem more collateral than expected.", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. ClaimProof does not include beneciary address, which allows front-running of airdrops", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "of types proofs in  Two contracts/airdrop/src/execute.rs:108-116, extracting the claim_proof distinguishes between the Account and ClaimProof types. While the Account type always includes the address of the beneciary, ClaimProof allows claiming with an arbitrary string. airdrops for supported logic are the for This is problematic because it enables front-running of these claims. When an attacker sees the proof string, he can submit it himself and claim the amount before the user.", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. The same claim proof can be used multiple times", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "In contracts/airdrop/src/lib.rs:18, the user input that is proven is dened as {claim_proof}{amount}, i.e., concatenation of the claim proof and the amount. This input is veried with the provided claim proof. Because this encoding is ambiguous, an attacker can craft multiple combinations that result in the same user input and which are not rejected as invalid or duplicates. For instance, let us assume that claim_proof = abcd1234. An amount of 5 results in a user input of abcd12345, which is the value of the leaf. However, setting claim_proof = abcd123 and amount = 45 also results in user input of abcd12345. Because it is only veried (in contracts/airdrop/src/execute.rs:142), both calls will succeed and the user can claim 45 + 5 = 50 tokens instead of the intended 5. claim_proof before used was that not the", "labels": ["Oak Security", "Severity: High"]}, {"title": "9. Inability to mint, burn and rebalance index tokens following the initial deate rebalance trade", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "Deating of an asset persists and updates the temporary accounting asset RESERVE_DENOM as part of the UNITS map alongside the other assets of the index. This RESERVE_DENOM is a constant string that resolves to \"reserve\" and is not a valid coin denomination. Any attempt to transfer this asset will result in an error. Due to the assumption that all assets within the UNITS map are tokens with valid coin denominations, the core functionalities of the protocol - minting, burning, and rebalancing - stop working after the initial deate rebalance trade, as RESERVE_DENOM is also added to the UNITS map. Minting  Since minting index tokens requires sending all asset tokens of UNITS along with the minting message, it is not possible to mint index tokens as RESERVE_DENOM cannot be transferred.  The Burning in contracts/core/src/state/units.rs determines the amount of underlying assets to redeem to the user when burning index tokens. Those assets are then transferred to the user. However, as RESERVE_DENOM is kept within the UNITS map and not removed from the redeemable assets, the transfer and hence the transaction reverts. get_redeem_amounts function fees are automatically Rebalancing  In the case of streaming fees being congured, collected and realized on every rebalance message. However, fees are also incorrectly collected from RESERVE_DENOM. As it is not possible to transfer the collected fees of the RESERVE_DENOM coin denomination, rebalancing reverts.", "labels": ["Oak Security", "Severity: High"]}, {"title": "10. Rebalance may not be nalizable because of rounding error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "The function distribute_after_deflate distributes the amount provided after an ination operation to the RESERVE_BUFFER entries for the dierent tokens. It does so by rst calculating the individual share for each token by dividing the weight by the total weight and then multiplying this ratio by the amount. However, because xed point arithmetic is used, there can be a very small loss of precision (in the 18th decimal place) when performing the division. While this loss of precision generally would be negligible, it breaks an important invariant of the rebalance operation: The sum of all RESERVE_BUFFER entries will no longer be equal to the RESERVE_DENOM balance. is for This the problematic In the contracts/core/src/execute/rebalance.rs:470, RESERVE_DENOM balance is exactly zero. But since this balance can only be decreased by consuming RESERVE_BUFFER entries, the condition may fail when there is a small amount left due to the imprecision of the calculation. Therefore, nalizing the rebalance operation will not be possible. nalization. required that is it", "labels": ["Oak Security", "Severity: High"]}, {"title": "11. Burning index tokens via the periphery contract yields substantially fewer asset tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "Burning index tokens via the periphery BurnExactAmountIn message invokes the burn_exact_amount_in function in contracts/periphery/src/execute.rs. This function in contracts/core/src/query.rs to determine the redeemable amounts of asset tokens, which are then swapped to a desired token (output_asset). simulate_burn function located core calls the the simulate_burn However, to amount_with_fee. Instead of calculating the burn fee amount and deducting it from the provided amount of index tokens, it multiplies the amount with the fee.burn ratio in line 119. This results in the amount_with_fee being just the fee, not the amount minus the fee. incorrectly the burn function applies fee Consequently, the amount_with_fee is substantially smaller than the provided amount of index tokens. As a result, the periphery contract will swap only a fraction of the redeemed assets to the desired token. As users can provide a minimum amount (min_output) of the desired token to receive, the transaction fails if this condition is not met. This renders the BurnExactAmountIn periphery message unusable.", "labels": ["Oak Security", "Severity: High"]}, {"title": "12. The streaming fee calculation formula returns wrong results for some input values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "calculate_streaming_fee The in contracts/core/src/state/mod.rs:44-75 calculates the time-weighted streaming fee with the following formula: function dened  = (1 +   )   1 where  is the elapsed time from the latest stream fee application. Since this function returns a rate that has to be deducted from token units, the result must input be in the [0,1] range. Since the result depends on the and the    variables, it may fall outside of this range for some of those values. Results outside of the mentioned range would cause wrong calculations resulting in token units being incorrectly reduced and accrued to the fee collector. A graphical simulation is provided in the Appendix.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "13. Minting and burning index tokens interferes with rebalancing and can render rebalance nalization unachievable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "As minting and burning index tokens continue to work while rebalancing is ongoing, the total supply of index tokens can uctuate during rebalancing. During rebalancing, the deflate_reserve and deflate functions deate assets, while in the inflate inflate_reserve functions assets inate and contracts/core/src/execute/rebalance.rs. These functions use the current supply of index tokens (token.total_supply) to perform calculations. For example, amount of reserve tokens to the total supply of index tokens (token.total_supply). the inflate_reserve function calculates the swap_unit ratio of the reserve The in is contracts/core/src/execute/rebalance.rs:355 and persisted in the UNITS map. RESERVE_DENOM swap_unit reduced then unit by As the token.total_supply changes during the rebalancing process, the swap_unit increases or decreases accordingly. This can result in RESERVE_DENOM never reaching 0, which is required to nalize the ongoing rebase.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "14. Asset ination simulates the swap incorrectly and expands by the wrong amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "Inating an asset by a certain amount is achieved by swapping the reserve to the asset. To determine the resulting amount (amount_out) of the asset (denom), the token swap is in simulated contracts/core/src/execute/rebalance.rs:402. sim_swap_exact_in function using the instead of using the reserve coin denomination (token.reserve_denom), the However, asset denom is used as the token_in argument for the sim_swap_exact_in function. As a result, the swap is simulated from the asset to the reserve instead of the reserve to the asset. This results in either a failed transaction due to the unsatised min_amount_out slippage protection or, in using the wrong amount the slippage protection is bypassed, (amount_out) to calculate the expansion amount (expand_unit) of the asset. if Additionally, this incorrect amount_out value is supplied as the token_out_min argument for the msg_swap_exact_in function in line 438, potentially causing the swap to fail due to the unsatised slippage protection condition.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "15. An invalid rebalance conguration could prevent its nalization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "Rebalance::validate in The validating the contracts/core/src/state/rebalance.rs is rebalance cong before the protocol's governance can initiate a new rebalance. Once a rebalance has started, the cong can not be altered until the rebalance is nalized. responsible function for However, the current implementation of the Rebalance::validate function is missing some important checks, which can lead to failed rebalances. Specically, if the ination ratios in the conguration are incomplete or empty, it will not be possible to utilize the reserve fully. When attempting to nalize the rebalance, the non-zero check in contracts/core/src/execute/rebalance.rs:468 will fail, causing the nalization of the rebalance to fail. UNITS[RESERVE_DENOM] of Similarly, if the conguration includes duplicate coin denominations within the inflation and deflation vectors, the nalization of the rebalance will fail because of the guard in contracts/core/src/state/rebalance.rs:456-463. the impossibility of a Rebalance being nalized as strict equality cannot be true for two instances of the same denom with dierent amounts. results This in We classify this issue as major because only governance can initiate a rebalance and dene its conguration.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "16. Streaming fee realization mechanism can be manipulated by the fee collector to maximize prot", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "The function realize_streaming_fee can be executed by the designated fee collector address at any time in order to collect fees. collected fees The calculated by multiplying the unit value with the token.total_supply in contracts/core/src/execute/fee.rs:156 for each Coin. are This is problematic because while unit is a time-weighted value, token.total_supply is a value that uctuates over time, leading to too high or low streaming fees. Moreover, it may be economically feasible for the fee collector to temporarily inate the total supply (by minting), execute realize_streaming_fee, and burn the tokens again.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "17. Tokens that are sent by mistake are not refunded when minting", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "The function mint calls assert_units to calculate how many tokens to refund for all backing assets in contracts/core/src/execute/mod.rs:43. The assert_units function checks that info.funds contains an entry for every element in assets, in order to calculate refunds for these elements. However, it is not validated that info.funds does not contain any additional entries. Therefore, info.funds is checked to be a superset of assets. This means that if a user sends other tokens along the call, those will be lost and not refunded.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "18. Fees rates are not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "In contracts/core/src/contract.rs:30-40, during the contracts instantiation, input provided fee rates dened in msg.fee_strategy are not validated to be in the [0,1] range. that range will cause errors in calculations since fees could exceed Values outside of amounts.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Inconsistent query results and failed index token burns due to lack of considering a minimum fee for small index token amounts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf", "body": "simulate_mint The contracts/core/src/query.rs lack Uint128::one(), make_burn_msgs_with_fee_collection contracts/core/src/execute/fee.rs. unlike and the simulate_burn application of the functions in a minimum fee of and in functions make_mint_msgs_with_fee_collection This absence of a minimum fee in the simulate_mint function results in incorrect query results. Additionally, the lack of applying a minimum fee in the simulate_burn function results in a failed burn transaction for small index token amounts (if amount * fee < 1) when used via the periphery contract. This occurs because the make_burn_swap_msgs function in contracts/periphery/src/msgs.rs expects a larger amount of redeemed asset tokens than actually received and fails to swap due to insucient funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Lack of pool status validation in claim function leads to a race between underwriters to withdraw and insurees to claim funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The claim function in src/contract.rs:251 does not perform a check to ensure that the pool is not in a closed state. If the pool status is closed and a hack/default event occurs, swaps can still be performed. Insurees will only claim if the payout amount is bigger than the value of the covered token. Rational underwriters will anticipate that, and rush to withdraw liquidity to maximize their return. Rational insurees will anticipate that rush, and try to claim as fast as possible. This race can lower trust in the protocol, but will eventually put users to a disadvantage that act slower than others.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Wrong payout calculation may lead to last claiming insurees not being able to claim", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The calculation of payout in the claim function in src/contract.rs:302 uses the default_ratio rather than the payout_ratio. This is dierent from the calculation of the capacity in line 476 and may result in the last insuree trying to swap running into out-of-funds errors.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Owner may update default ratio to prevent claims from being made", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "default_ratio, payout_ratio, and expiration are updatable variables that are used to determine whether or not the default event occurred in src/contract.rs:288, how much to pay out in 288, and whether the pool is closed in line 512-514. If the owner account was compromised or the owner simply wanted to control whether claims should be possible and what height they should have, they could update these values, aecting any users that have not claimed yet.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Lack of validation of state parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The instantiate and update_config functions in src/contract.rs:28 and 408 lack validation of the following parameters:  expiration: If set to a time in the past, this will cause the next invocation of check_if_at_status to transition the pool status to closed.  payout_ratio: If set to zero, the next invocation of the purchase would attempt to divide by zero in line 476 while attempting to calculate the total_capicity, which would cause a panic.  price (validated in the instantiate, but not in the update_config function): If set to zero, the purchase function would panic in line 220. A price of more than one would economically not make much sense.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Pool may be congured with an incorrect credit token", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The InstantiateMsg struct in src/msg.rs:11 denes credit_token with a type of Addr, which is then stored without validation in src/contract.rs:70. This allows instantiation of a pool with an invalid credit token address, which may only be detected when claims happen after a hack/default.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Owner may update parameters that can negatively impact users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The update_config function in src/contract.rs:408-439 allows the owner to update the following values:  price  expiration  default_ratio  payout_ratio Any underwriters that provide liquidity to the pool at the time of such a change would be subject to these changes, but they have no way to withdraw the pool if the values change to their disadvantage. This disincentivizes underwriters from entering the pool in the rst place, and also adds to centralization of the protocol. We classify this nding as minor because only the owner can make these changes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Claim payout attribute value is missing tax deduction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The payout attribute in the claim function in src/msg.rs:324 contains the pre-tax payout value. This value will be dierent from the amount that is actually sent after deducting the tax.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of validation of Cw20ReceiveMsg msg can surprise users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The claim function in src/contract.rs:255 receives a Cw20ReceiveMsg but does not match/use the contained msg. This means that the contract will execute a claim regardless of the received message. This goes against user expectations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Default state assessment of protocols added in the future may be subject to manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The audited smart contract only supports protection against drops in the Anchor exchange rate. That exchange rate can only be manipulated by an attacker that is a validator and deliberately gets slashed. Future extensions of the protocol might support insurance of tokens from other protocols though, with default conditions that may be subject to manipulation. In the past, many exploits of protocols were based on manipulation of spot prices, which is a concern for the Risk Harbor protocol. Even though this issue does not aect the current iteration of Risk Harbor, we still classify it as minor since it poses a potential risk of a future iteration.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Hard-coded Anchor market address decreases exibility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The calculation of the redemption_ratio in src/contract.rs:285 uses a hard-coded (currently placeholder) address for the Anchor market contract. This decreases the exibility of the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Selective usage of CW20 features may lead to wrong user expectations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The contract selectively imports and uses code from the CW20 reference implementation. At the same time, the contract does not expose all of the CW20 execution and query message entry points. Depending on the frontend users are using, bought coverage might show up as a CW20 token to the user, but functionality such as transferring, sending, or burning those this selective usage of CW20 code increases the tokens is not available. Moreover, complexity of the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Lack of validation of pool name length may have adverse consequences", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "the stores contract The in src/contract.rs:38-49. The CW20_base crate performs a validation check to ensure that the token name adheres to the expected format and returns an error if this condition is not met. the CW20 format token using base info Using too long names might have adverse consequences, for example for user interfaces that expect limited token names.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Resolved 35. Misleading error message while trying to send and repay at the same time", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Membrane/2023-06-15 Audit Report - Membrane v1.0.pdf", "body": "The mint_revenue function in contracts/cdp/src/position.rs:1639 performs a check to prevent the two optional variables send_to and repay_for being specied simultaneously or not specied at all. if True, However, \"Destination address is required\". specied, the error message is wrong. the error message informs about the second scenario only, that is, If both send_to and repay_for are", "labels": ["Oak Security", "Severity: Informational"]}]