[{"title": "9. MAX_CLOSE_FACTOR is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "the contract owner In contracts/credit-manager/src/instantiate.rs:15, denes the MAX_CLOSE_FACTOR of liquidations which determines the maximum amount of a position that can be liquidated. However, ineectual and not providing a limit to the value that can be liquidated in a single transaction. the value provided has no validation which could lead to the variable being", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Query silently returns input when no pricing method is found.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "function The in contracts/oracle-adapter/src/contract.rs nds the pricing methodology of the coin denom and queries the relevant vault to calculate the value of redemption. query_priceable_underlying If the submitted coin denom does not have a vault price then the input is simply returned to the user. This could lead to wrong assumptions and may negatively impact the usability of the query.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Redundant checks on received funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "the try_from function attempts to In packages/rover/src/coins.rs:136-158, verify that no zero amount denom and no duplicate denoms are provided. This check is unnecessary because Cosmos SDK will prevent zero amounts from being sent (an error will occur) and will automatically combine duplicate denoms into one single denom (eg. [200 ATOM, 100 ATOM] will become [300 ATOM] ).", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Contracts should implement a two step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Custom access controls implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "The contracts within the scope of this audit implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/account-nft/Cargo.toml  contracts/credit-manager/Cargo.toml  contracts/oracle-adapter/Cargo.toml  contracts/swapper/Cargo.toml  packages/rover/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Unbounded number of steps during route registration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In contracts/swapper/base/src/contract.rs:246-274, is able to dene custom swap routes between token pairs in order to facilitate the exchange of tokens that do not have a shared pool. However, the number of steps a route is able to host is unbounded which could lead to inecient routes being dened. the owner", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unused callback should be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "ForceExitVault The packages/rover/src/msg/execute.rs:147-151, protocol and should be removed from the codebase to increase its maintainability. in dened is not used anywhere in the callback", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "3. The function validate in packages/covenant-utils/src/split.rs:46-63 is used only once in the specic context of two-party-pol-holder contract. In this context, its eect is equivalent the function validate_shares dened in packages/covenant-utils/src/split.rs:66-80. It is preferable to just call the latter function with prior verication that self.receivers value contains only the two parties. to the eect of dened Code duplication decreases readability and maintainability, thereby expanding the potential for security vulnerabilities. Recommendation We recommend refactoring the codebase to avoid code duplications. Shared modules with common code as well as generic type parameters and function-type parameters could be used to streamline the data ow. Status: Resolved 43. Remove commented code blocks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-05-02 Audit Report - Timewave Covenants v1.0.pdf", "body": "3. The function validate in packages/covenant-utils/src/split.rs:46-63 is used only once in the specic context of two-party-pol-holder contract. In this context, its eect is equivalent the function validate_shares dened in packages/covenant-utils/src/split.rs:66-80. It is preferable to just call the latter function with prior verication that self.receivers value contains only the two parties. to the eect of dened Code duplication decreases readability and maintainability, thereby expanding the potential for security vulnerabilities. Recommendation We recommend refactoring the codebase to avoid code duplications. Shared modules with common code as well as generic type parameters and function-type parameters could be used to streamline the data ow. Status: Resolved 43. Remove commented code blocks", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Users that unbond from yAsset contract in XPrism mode receive twice their bonded amount minus the fees, and fees are not collected", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "StakingMode::XPrism, In contracts/prism-yasset-staking/src/staking.rs:96-108 and 116 if mode user == - withdrawal_fee. At the same time, the fees are not sent to any other contract. This leads to draining funds from other users and fees not being distributed to stakers, compromising incentives to stake. 2*unbonded_amount receives the", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Lack of tax deduction in limit order contract leads to other users funds being spent", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "In contracts/prism-limit-order/src/order.rs:319 and 322 no taxes are deducted during the execution of the swap. Without deducting taxes, the contract will pay taxes for the swap from its own balance, which will consume the oered amounts of other limit orders, leading to a failure to execute those other limit orders in the future. This would aect a wide range of users of the protocol, who would permanently lose their funds.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Missing total bond amount decrease during unbonding from launch pool contract leaves rewards stuck in contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "the in In contracts/prism-launch-pool/src/contract.rs:206-215, the total_bond_amount is not decreased by the unbonded amount. This implies that for any further rewards, the denominator in line 277 will be too big, leading to any bonded users proportionally losing out on further rewards. unbond function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Users might lose their bonds if unbonding periods of vault contract and Terra protocol are not the same duration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "If no batch is released in contracts/prism-vault/src/unbond.rs:255, the actual unbonded amount is still set to zero in line 317. Moreover, the prev_vault_balance is updated in the calling function execute_withdraw_unbonded in line 191. This might cause lost funds because the vault unbonding period can be freely set, while the Terra unbonding period is xed to 21 days. Two cases are possible. On the one hand, if the unbonding period used in the contract is longer than the actual unbonding period of the Terra protocol, this might lead to lost funds. On the other hand, if the unbonding period is set to less than the actual unbonding period, slashing of validators might lead to a situation where users can avoid being aected by slashing at the cost of other users because the slashing is not executed. Despite the severe implications of a mismatch of the unbonding periods, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Exchange rate peg mechanism allows users to prot from slashes and inhibits liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "peg rate exchange in The and contracts/prism-vault/src/bond.rs:119-129 contracts/prism-vault/src/unbond.rs:41-51 might compromise the incentives of users and validators, depending on the parameter values of the threshold and the recovery_fee. There might be a free lunch for any user that bonds directly after a possible slashing event. implemented mechanism this First, compromises contracts/prism-yasset-staking/src/rewards.rs:28-35 stakers_portion could become larger than one. computations made where in the Second, in the worst case, if a potential prot from a free lunch is large enough, validators might be incentivised to trigger slashing in order to realize these prot opportunities. This might compromise the protocol. Third, users that wish to unbond after slashing have to pay up to the maximal peg recovery fee peg_fee in order to restore the peg. This leads to a rst-mover disadvantage in the sense that one single user might need to pay for the whole slashing. This in turn disincentivizes unbonding and reduces the liquidity of all derivative tokens. These issues are caused by the peg recovery mechanism. In contrast to the Anchor protocol, which uses a similar mechanism, Prism does not have a natural peg recovery by accruing rewards on cLUNA.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Withdrawal of funds may fail if a user unbonds many times without withdrawing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "In contracts/prism-vault/src/state.rs:60, 76, 89 and 114, iterations over the UNBOND_WAITLIST may run out of gas, if the list has many entries. Many entries might occur if a user unbonds regularly, but does not withdraw. That could happen for example if the user is a bot that automatically bonds daily. As a consequence, withdrawing funds may fail. There is currently no way to recover from this issue. Similarly the query in line 139 can run out of gas and fail.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Protection against mass withdrawals is weak and can be bypassed with multiple accounts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "In contracts/prism-fair-launch/src/contract.rs:185-187 in order to prevent massive withdraw on phase 2 (as stated in the comment), a fee is charged if withdraw_amount is greater than cfg.withdraw_threshold. This mechanism can easily be avoided by withdrawing multiple times with amounts less than or equal to cfg.withdraw_threshold. Elaborate exploiters can also bypass it easily by using multiple accounts to execute greater withdrawals.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of conguration validation in vault and yAsset staking contracts can cause errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "The conguration of peg_recovery_fee and er_threshold can be set to values larger than one in contracts/prism-vault/src/contract.rs:78-79 as well as in in contracts/prism-vault/src/config.rs:38-39. This might and contracts/prism-vault/src/bond.rs:124-126 contracts/prism-vault/src/unbond.rs:45-47. cause errors An equivalent problem occurs in prism-yasset-staking/src/contract.rs:37 and 42 where protocol_fee and withdraw_fee can be set to values larger than one, which might cause errors in contracts/prism-yasset-staking/src/rewards.rs:70 and prism-yasset-staking/src/contract.rs:116, respectively. We consider this a minor issue, since it can only be caused by oversight of the contract owner. However, errors in production can lead to downtime of the protocol.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Conguration updates in gov contract might aect votes in progress", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "be In contracts/prism-gov/src/contract.rs:205-210, quorum and threshold in aects can contracts/prism-gov/src/polls.rs:141-146, which could aect the outcome of a vote. In addition, proposers might lose their deposit on existing polls after a change of the quorum. updated. progress votes This in As the values can only be updated by the contract owner or through governance, we consider this a minor issue. An update coming through governance would be visible by any proposer at the time of poll creation. Since the outcome of a poll that updates quorum or threshold values might not be certain, proposers could be disincentivized to create new polls during such a period.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Lendings in the red bank cannot be liquidated when ActionKind::Default circuit breakers trigger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In the rover:contracts/credit-manager/src/liquidate_lend.rs:43-45, liquidate_lend function withdraws the liquidatees asset lent in the red bank as part of the liquidation process. When a liquidation occurs, price queries are dispatched as ActionKind::Liquidation to ensure liquidations can still be executed during extreme the market design the max_confidence and max_deviation circuit breakers will transaction, possibly hindering the liquidation process. as trigger and revert from ActionKind::Default, conditions. diers This In red-bank:contracts/red-bank/src/withdraw.rs:77-86, However, the red bank contract performs an ActionKind::Default price query during the withdrawals. calls assert_below_liq_threshold_after_withdraw get_user_positions_map with is_liquidation parameter as false, resulting in the of as asset ActionKind::Liquidation. ActionKind::Default executed internally function instead query being price liquidating lent positions in the red bank contract will fail when one of the Consequently, max_confidence or max_deviation circuit breakers is triggered, potentially causing bad debt to accrue and risking the protocols solvency.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Incorrect protocol fee calculation during liquidation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In the red-bank:packages/liquidation/src/liquidation.rs:100, calculate_liquidation_amounts function computes the liquidation bonus amount by multiplying the collateral_amount_to_liquidate value with the liquidation bonus percentage. This is incorrect because the collateral_amount_to_liquidate value had already the liquidation bonus applied in line 84. Consequently, the protocol fee amount computed in line 103 will be inaccurate because it uses an incorrect liquidation bonus value, causing the protocol to receive erroneous fee amounts. The client has independently detected this issue during this audit.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Incorrect contract name assertion prevents successful migration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In rover:contracts/account-nft/src/contract.rs:94, the migrate function does not prepend the crates.io: identier to the CONTRACT_NAME when performing a contract migration. This is problematic because the previously deployed version and the contract instantiation process prepends that identier to the contract name. Consequently, migrations will fail because they expects the contract name to not include that identier. This issue is also present in the following contracts:  rover:contracts/credit-manager/src/migrations/helpers.rs:13  red-bank:contracts/oracle/osmosis/src/migrations.rs:13", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Incomplete state migration in account-nft contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "the CONFIG state uses In rover:contracts/account-nft/src/state.rs:5, Item<NftConfig> for version 2.0.0. As version 1.0.0 uses Item<Config>, a state migration is required in order to support the new health_contract_addr eld in the in NftConfig rover:contracts/account-nft/src/contract.rs:88. struct. However, handler does the migrate handle this not Consequently, the burn and update_config functions will fail to load the CONFIG state successfully, preventing the contract from working as intended.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Circuit breakers may block liquidations, risking the protocols solvency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In rover:contracts/credit-manager/src/execute.rs:77, the accounts health state is queried with ActionKind::Default before dispatching any actions. The and ActionKind::Default in max_deviation red-bank:contracts/oracle/base/src/pyth.rs:80-81. If one of the validations fails, the circuit breakers will be triggered, preventing the account from dispatching actions during cases of extreme volatility. subjected validations, max_confidence query price seen the as to is However, the circuit breakers might unintentionally block liquidation attempts. This behavior is inconsistent with the documentation, as one of the objectives is to let the protocol always be open for liquidation. To illustrate the scenario, assume a liquidator deposits ATOM as the debt asset to their account in preparation for liquidation attempts while also borrowing other assets. When the ATOMs price experiences high volatility, the max_confidence or max_deviation circuit breakers can trigger, causing the ActionKind::Default health state query to fail. If the liquidator wants to liquidate an undercollateralized positions debt with ATOM, the Liquidate action cannot be dispatched due to the previous health state query. Consequently, the liquidator cannot liquidate unhealthy positions using their accounts debt assets, ultimately risking the protocols solvency. Additionally, borrowers cannot improve the health of their positions during extreme market circumstances, exposing them to liquidation risks.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Inaccurate health computation due to default collateral limit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "When computing an account's health, the user's lending positions are queried using None as the limit parameter in rover:contracts/credit-manager/src/query.rs:69. In contract red-bank:contracts/red-bank/src/query.rs:185, interprets requesting a maximum of ve collaterals by default (DEFAULT_LIMIT) when the limit parameter is unwrapped. request as bank this red the Consequently, the health computation will be unable to include the excess assets if the account lent more than ve assets in the red bank contract, causing incorrect health LTV computation.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Credit manager migration requires the reward collector account-id", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "the rover:contracts/credit-manager/src/migrations/v2_0_0.rs:42, In migrate handler requires the caller to provide the reward collectors address and account id and store it in the REWARDS_COLLECTOR storage. This requirement is invalid because there is no entry point for the rewards collector contract to mint an account id for themselves before If the owner miscongures the account id to another users the version 2.0.0 update. account, the protocol fee will be distributed to them incorrectly.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Contract version is not updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "The incentive contract inherits the version of the workspace in red-bank:Cargo.toml. During initialization, this version is set correctly. However, during migration, the contract version in updated not red-bank:contracts/incentives/src/contract.rs:767-769. is This could lead to confusion during future migrations as it is not clear which version of the contract is deployed in production.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Users cannot exit vaults for assets that are no longer whitelisted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In the rover credit manager contract, assets sent are veried to ensure that they are whitelisted. in rover:contracts/credit-manager/src/vault/enter.rs:41. subscription performed during vault This also to is a Should an asset be removed from the whitelist, then users would be unable to exit from both locked and unlocked vaults, causing their funds to be locked.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Credit manager contract is not dened when instantiating the health contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "The credit manager contract address is not stored upon instantiation of the health contract. As soon as the health contract is deployed, the health state and values of a users position can be queried by the credit manager. the new However, should this occur, each query would fail during the creation of rover:contracts/health/src/querier.rs:20. HealthQuerier Consequently, this would cause the failure of any calculation of position health in the credit manager. object in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Insucient validation of the interest rate module", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In the red-bank:packages/types/src/red_bank/interest_rate_model.rs, interest rate model of the red bank is dened, which uses two constant slope variables to dene the interest rate on either side of the optimal utilization rate. However, during the creation of a new market, it is not validated that slope_1 is less than slope_2, prior to the optimal utilization rate. Were this to be the case, then the economic model of the red bank would be undermined, which could cause signicant losses. We classify this issue as minor since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Insucient price source validation for liquidity token pricing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In red-bank:contracts/oracle/osmosis/src/price_source.rs:617-623, the current liquidity pool pricing implementation queries an underlying asset's price without proper validation against price_sources. This is problematic because it is crucial to ensure that the price source for denom is not set to an AMM spot price. the example, in For price red-bank:integration-tests/tests/test_oracles.rs:163 source as the Osmosis pools spot price. If the price sources are not validated explicitly, an oversight by admins can potentially open up a price manipulation attack. querying_xyk_lp_price_success case the sets test We classify this issue as minor because it can only happen due to a misconguration by the contract owner. From a secure coding point-of-view, it is recommended that proper validation checks are performed in the code rather to prevent miscongurations. than relying on the owner", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Potential failure of incentives contract migration due to unbounded iteration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In incentive-migration:contracts/incentives/src/migrations/v2_0_0.rs: the migrate_indices_and_unclaimed_rewards function performs an 198-283, unbounded iteration over all keys in ASSET_INCENTIVES, USER_ASSET_INDICES, and USER_UNCLAIMED_REWARDS storages. This is required because the latest version of the incentives contract implements a new storage design that diers from the old one. If there are too many asset incentives, users, or unclaimed rewards to iterate over though, the transaction will fail due to an out-of-gas error, preventing the migration from working correctly. We classify this issue as informational because a failed migration attempt does not inherently compromise the protocols security. If the migration fails, the contract admin can upload a xed contract with an updated migration function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Conict between documentation and implementation of the borrow rate calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In red-bank:packages/types/src/red_bank/interest_rate_model.rs:27, the get_borrow_rate function uses slope_1 when the current utilization rate is less than or equal to the optimal utilization rate. However, in line 14, the documentation states that the utilization rate should use slope_1 when the current utilization rate is less than the optimal utilization rate, not mentioning the case of equality. We classify this issue as informational as the dierence between documentation and implementation does not impact the functionality, but might mislead developers or cause problems in the future.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Use of hardcoded versions during migration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "migrating in credit When rover:contracts/credit-manager/src/contract.rs:132, the values of the old and new versions are hardcoded. manager contract the However, the previous and new contract versions are available as constants and from the lines environment and rover:contracts/credit-manager/src/migrations/v2_0_0.rs:11 rover:contracts/credit-manager/Cargo.toml respectively. in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Inecient execution of messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "For each dispatch action for a particular account, the contract always performs a number of callback messages to ensure that certain conditions are met. the callback message AssertAccountReqs in However, during the execution of rover:contracts/credit-manager/src/execute.rs:255, conditions are only checked if the account is of type high-leverage strategy. This causes the creation of a redundant message, increasing the code's complexity and computational resources required.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Use of custom logic instead of standard libraries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "Throughout the codebase, there are a number of custom conditions that could be simplied by using the cosmwasm_std library functions ensure!, ensure_eq!, and ensure_ne!. example, For rover:contracts/credit-manager/src/utils.rs:36, condition if user != owner {  } is used to return an error if the condition is met. in the The following provides a list of non-exhaustive examples:  rover:contracts/account-nft/src/contract.rs:94, 100  rover:contracts/account-nft/src/execute.rs:80  rover:contracts/credit-manager/src/execute.rs:36  rover:contracts/credit-manager/src/utils.rs:36  rover:contracts/swapper/src/contract.rs:81", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. update_nft_config emits the same attribute value as update_config", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In the rover:contracts/credit-manager/src/update_config.rs:141, update_nft_config function emits the action key attribute as update_config. This is misleading because the update_config function in line 27 emits the same value, potentially confusing event indexers and o-chain listeners.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. get_route function can be used to reduce code complexity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf", "body": "In the rover:contracts/swapper/base/src/contract.rs:164-170, swap_exact_in function attempts to load a swap route and errors if there is no route for the coin_in.denom and denom_out combination. As the get_route function in lines 248-255 performs the same functionality, the code complexity can be reduced by using that function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. A validator updating its ConsumerKey to the same key causes a panic in the related consumer chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/provider/keeper/key_assignment.go:505-523, during the processing the execution appends two abci.ValidatorUpdate of ConsumerKey assignments, elements to the newUpdates slice for each consumer key to replace. The rst abci.ValidatorUpdate is constructed with the old key and Power equal to zero and the second one contains the new key with the validators current Power. If a validator updates its key to the same one, the newUpdates slice will contain two elements with the same key and dierent Power, respectively zero and the current one. This would cause the related consumer chain to panic when trying to update the validator set due to the duplicated ConsumerKey in the validator set.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can DOS attack consumer chains by sending multiple coins to the provider chains reward address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "the the During execution in SendRewardsToProvider x/ccv/consumer/keeper/distribution.go:103, gets the balance of all the coins in the tstProviderAddr and sends them to the provider chain. EndBlocker, consumer function, dened chains the of In order to do so, it has to iterate through all the coins found in the reward address and send them one by one through IBC to the provider chain. Since anyone is allowed to send coins to the reward address, an attacker could create and send a large number of coins with dierent denoms to it, for example using a chain with the token factory module, in order to attack the mentioned unbounded iteration and DOS attack the chain. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the consumer chain to slow down or in the worst case even halt.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Validators can slow down the provider chain by submitting multiple AssignConsumerKey messages in the same block", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "AssignConsumerKey The in x/ccv/provider/keeper/key_assignment.go:378, enables validators to assign themselves a dierent consumerKey for approved consumer chains. function, dened In order to perform this action the consumerAddrsToPrune AddressList grows by one element in line 428. this AddressList Since in x/ccv/provider/keeper/relay.go:95, it could be utilized by attackers to slow down the provider chain. EndBlocker iterated over the in is To execute such an attack, malicious actors could craft transactions with multiple AssignConsumerKey messages and spam the provider chain with those transactions. The consumerAddrsToPrune AddressList will grow of the same cardinality as the AssignConsumerKey sent messages. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the provider chain to slow down or in the worst case even halt. We classify this issue as major instead of critical since the number of iterations is bounded by the maximum number of messages in a block.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. The provider chain halts on failure to send packets to a single consumer chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "the execution During SendVSCPacketsToChain x/ccv/provider/keeper/relay.go:182, panics if consumer chain. function, provider the of chains EndBlock function, dened it fails to send a packet the in to a This implies that an issue relevant only to a consumer chain will make the provider chain panic. Likewise, consumers will also panic in x/ccv/consumer/keeper/relay.go:180 because they will not be able to send packets to the provider. This evidences a single point of failure  an error occurring on a single packet for a single consumer can halt the entire ICS network. We classify this issue as major instead of critical because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Potential loss of rewards during consumer chain removal", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/consumer/keeper/distribution.go, the reward distribution process takes place at the end of each block on the consumer chain. When the number of blocks for transmission is exceeded, the accumulated rewards are sent to the provider. If a proposal to remove or stop a consumer chain is successfully executed, the code at x/ccv/provider/keeper/proposal.go:155-232 automatically handles the removal process. This includes tasks such as cleaning up the state, closing the channel, releasing unbonding operations, and deleting all related data. However, it does not explicitly check whether the rewards associated with the consumer chain have been distributed before removing the chain. This may lead to a loss of rewards that have not been sent to the provider.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Consumer chains can DOS the provider chain by sending slash packets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/provider/keeper/throttle.go:274-276, a panic occurs if the cardinality of the queue of throttled packets is bigger than the dened MaxThrottledPackets hard cap. This behavior can be exploited by a malicious consumer chain, making the provider unable to process any further packets from other consumers. To execute such an attack, the malicious consumer chain can spam the provider chain with slash packets in order to ll the queue and cause a panic. Since the validation of slash packets in x/ccv/provider/keeper/relay.go does not disregard duplicate or other invalid slash packets, the attack can be performed for example by simply sending a valid slash packet multiple times. This could cause other consumer chains to be removed from the ICS because the provider will not receive relevant maturity notications before the timeout. We classify this issue as minor instead of major because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Validators can evade slashing if an equivocation proposal is submitted seven days or later after the infraction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "When a validator performs a double-signing infraction on a consumer chain, equivocation slashing should be proposed and voted upon. Since the voting period lasts two weeks and the unbonding period is currently set to three weeks, an equivocation slashing proposal submitted seven days or later after the infraction takes place allows the validator to unbond and evade slashing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Consumer chains can expand provider chain unbonding period", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "The default unbonding period for consumer chains DefaultConsumerUnbondingPeriod is set in x/ccv/consumer/types/params.go:37 to one day less than the default unbonding period, which is currently three weeks. Since a validators unbonding matures only after all consumer chains unbondings mature, the DefaultConsumerUnbondingPeriod is chosen to ensure that the validators can unbond without any delays. However, since the consumer unbonding period is not enforced in the code to be less than the providers, consumer chains congured with a bigger unbonding period will delay the providers unbonding period.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Unbounded loop over proposals in BeginBlock could slow down block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/provider/keeper/proposal.go:370 and 504, an unbounded loop is used to iterate over the ConsumerAdditionProposals and ConsumerRemovalProcess list. This loop has no set limit for the number of times it can run. Since there are no restrictions on the number of consumer chains that can be supported by the provider chain, a large number of proposals could slow down or halt the chain. We are reporting this with Minor severity since proposals go through governance voting and the likelihood of having multiple proposals with the same SpawnTime or StopTime is low.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Unbounded loops over consumer chains in EndBlock could slow down block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "When the EndBlock function is executed on the provider chain, there are several instances where the GetAllConsumerChains function is called to retrieve a list of all consumer chains. As there are no restrictions on the number of consumer chains that a provider can support, this slice can potentially be very large. The GetAllConsumerChains function is called in:  x/ccv/provider/keeper/proposal.go:60,  x/ccv/provider/keeper/proposal.go:173, and  x/ccv/provider/keeper/proposal.go:224. These unbounded lists are then iterated over to perform various operations for all active there are iterations over leadingVSCMaturedData, consumer chains. Specically, pendingPackets, and MustApplyKeyAssignmentToValUpdates. If the cardinality of these lists increases, block production may slow down, possibly even halting the chain. Operations on time-critical applications running on the network such as auctions or governance proposal execution may be delayed when a consumer chain oods the EndBlocker with fraudulent VSC matured packets, leading to a delay in block production. We are reporting this issue as Minor since consumer chains can only be added through governance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. LastTransmissionBlockHeight is wrongly updated if the IBC token transfer fails", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "the execution During in the x/ccv/consumer/keeper/distribution.go:21, LastTransmissionBlockHeight is updated with the current timestamp even if the IBC token transfer fails. EndBlockRD function, dened the of This implies that rewards are not re-sent in the next block but in the next epoch, leading to lower rewards for unstaking validators. Also, a misleading value is stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Inecient removal of executed proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "The BeginBlock function, which is called at the beginning of every block, calls BeginBlockInit in x/ccv/provider/keeper/proposal.go:367 to get the pending consumer addition proposals and then deletes executed proposals in line 391. even the However, DeletePendingAdditionProps function is called to fetch a KVStore from the MultiStore every block, which is inecient. proposal execute, pending there no to is if This ineciency can be removed by changing the function to delete a single executed proposal and moving it inside the for loop. The same issue applies to the DeletePendingRemovalProps function called from BeginBlockCCR in x/ccv/provider/keeper/proposal.go:501.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Emitting incorrect events is misleading", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In case of unmarshalling packet data failure in the OnRecvPacket function, the ack value will contain an error acknowledgment which is used to emit an event with AttributeKeyAckSuccess in both x/ccv/consumer/ibc_module.go:237 and x/ccv/provider/ibc_module.go:205. This is misleading for client applications and users, since a success ag can be returned along with an error. the DistributeRewardsInternally rewards distributes ConsumerRedistributeName to Similarly, in the x/ccv/consumer/keeper/distribution.go and feeCollector the ConsumerToSendToProviderName DefaultConsumerRedistributeFrac. By the time the sendRewardsToProvider function is called, feeCollector has a zero balance. Thus, in x/ccv/consumer/keeper/distribution.go:138 will always contain 0 emitted fpTokens, which again is misleading for client applications and users the emitted event according function from to", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Redundant checks are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "The codebase contains redundant checks:  The version check in x/ccv/consumer/ibc_module.go:95 is unnecessary as it is already invoked in line 42.  The ValidateBasic function in x/ccv/provider/client/cli/tx.go:56 is the unnecessary GenerateOrBroadcastTxWithFactory function in line 60. invoked already as in is it", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Outstanding TODOs", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "There are multiple TODOs in the codebase that development: imply that the codebase is still in  x/ccv/types/expected_keepers.go:82,  x/ccv/provider/ibc_module.go:185, and  x/ccv/consumer/keeper/genesis.go:21.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Miscellaneous comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "Across the codebase, instances of unused/commented code and inaccurate comments have been found. This can negatively impact the maintainability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Excessive transaction fees are incurred", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf", "body": "In x/smart-account/ante/ante.go:175-181, transaction fees are deducted if the message signer matches the fee payer address. This logic becomes problematic when the transaction contains multiple messages, and the messages signer is the fee payer. The fee would be incorrectly deducted multiple times, causing the fee payer to incur excessive transaction fees. comparison, in For classicSignatureVerificationDecorator only charges a one-time fee for all the messages in a transaction. deductFeeDecorator the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Inconsistencies in the AnyOf authenticator may lead to errors and incorrect authenticated requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf", "body": "in x/smart-account/authenticator/any_of.go:85 The AnyOf authenticator iterates over all congured authenticators in the Authenticate function until any sub-authenticator succeeds when its Authenticate function is called. It does the same in the ConfirmExecution function, which calls ConfirmExecution on all congured authenticators until there is one without an error. This means there can be the following situations: authenticatorA returns success when Authenticate is called but returns an error on the ConfirmExecution function. Another authenticator, authenticatorB, returns an error on Authenticate but succeeds for the ConfirmExecution function. Although no authenticator returned success for both Authenticate and ConfirmExecution functions (which is the requirement for requests to authenticate normally), the AnyOf authenticator will authenticate such a request successfully. inconsistencies can also arise because of this logic, especially for stateful Other authenticators. Consider an example conguration [A, B]. If Authenticate fails on A and succeeds on B, whereas ConfirmExecution succeeds on A, there will never be a call to ConfirmExecution on B. This can be problematic because authenticators may be written under the assumption that there will always be a ConfirmExecution call for every successful Authenticate call, leading to unintended states if this is not the case. Similarly, the logic for AnyOf authenticators Track function can also lead to undesired states. This function requires that all congured authenticators do not return an error, even if they were not involved in the authentication at all. This violates the following excerpt from the documentation: The Call Track() on all messages step is executed, notifying the authenticators involved.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Unimplemented GetAuthenticator query", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf", "body": "GetAuthenticator The in x/smart-account/keeper/query.go:37-57, that returns the selected authenticator data is not exposed in queries, as seen in x/smart-account/client/cli/query.go. function, dened", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Composite authenticators can be initialized with a single sub-authenticator", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf", "body": "Composite authenticators, such as AnyOf and AllOf can be initialized with a single sub-authenticator and x/smart-account/authenticator/any_of.go:60. Although this does not pose any security threats, it is unnecessary if composite authenticators are initialized with a single sub-authenticator. x/smart-account/authenticator/all_of.go:50 in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Open TODOs", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf", "body": "The codebase contains several open TODOs and further comments which may indicate that the codebase is not ready for release in the following locations:  app/ante.go:86  x/smart-account/ante/pubkey.go:49  x/smart-account/ante/pubkey.go:59  x/smart-account/authenticator/authentication_request.go:227  x/smart-account/authenticator/message_filter.go:183  x/smart-account/post/post.go:92  x/smart-account/types/msgs.go:40", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Misleading documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf", "body": "There are instances across the codebase of misleading documentation:  In x/smart-account/authenticator/signature_authenticator.go:90-9 7, in contrast to the documentation, the onAuthenticatorAdded function does not allow for an empty config.  In x/smart-account/keeper/keeper.go:111-154, GetInitializedAuthenticatorForAccount inaccurate. functions documentation the is Inaccurate documentation may mislead developers and decrease the maintainability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Vesting contract allows unlimited allocation by malicious CW20 contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-02 Audit Report - Levana Stage 2 v1.0.pdf", "body": "The CW20 receive hook of the vesting contract currently accepts any CW20 token. Therefore, through contracts/levana-vesting/src/contract.rs:74-95, it is possible for an attacker to create unlimited allocations using a malicious CW20 token contract that sets cw20_msg.sender to the protocols admin address. The attacker could subsequently withdraw Levana tokens once the vesting period has expired.", "labels": ["Oak Security", "Severity: High"]}, {"title": "1. Missing access control of strategy contract conguration updates allows attackers to DoS attack the protocol and redirect queries to malicious contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf", "body": "the exec_config_update In contracts/strategy/src/contract.rs:187-226, function of the strategy contract allows updating the contract congurations such as the core, puppeteer, validator-set and distribution contract addresses, as well as the reference denom. However, since there is no access control for the function, anyone can update the contracts cong to arbitrary values. Consequently, attackers can consistently spam UpdateConfig messages to store invalid addresses for contract dependencies causing the strategy contracts queries to fail and disrupting protocol operations. Additionally, attackers could update contract dependencies to malicious contracts that return malicious data.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Incorrect fee accounting leads to loss of funds and DoS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf", "body": "get_stake_msg The in contracts/core/src/contract.rs:1063-1127, processes delegation messages, updating the COLLECTED_FEES with the amount to the respective fee_address. to be sent function, dened Those fees are then transferred from the ICA account to the fee collectors during the the get_non_native_rewards_and_fee_transfer_msg function execution of dened in lines 1301-1314. However, after the fees are transferred by the puppeteer contract to fee collectors, the COLLECTED_FEES map is not reset. Consequently, as the FSM continues normal operation, more fees are added and all the fees, including the ones that have been already sent, are transferred again. This leads to a loss of funds for the users and eventually causes a denial of service, due to the impossibility of transferring an amount larger than the balance of the ICA account.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. The protocol can get permanently stuck in the Staking state due to unhandled errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf", "body": "the execute_tick_staking In contracts/core/src/contract.rs:693-696, function within the core contract acts as the designated handler when the ContractState transitions to Staking during routine procedures. However, if during this process the puppeteer contract callback to the PuppeteerHook stores a ResponseHookMsg::Error because of a timeout or an error in the ICA transaction, the execute_tick_staking function consistently returns an error in line 695. Consequently, lacking an alternative handler to progress the ContractState, the routine becomes unable to proceed, resulting in the protocol becoming permanently stuck.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. First bonding results in a division by zero error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf", "body": "contracts/core/src/contract.rs:173-179, In function calculates the actual exchange_rate with the following formula: the query_exchange_rate _ = _ + _ + __  _  __ __ in a zero exchange_rate since However, during the rst bonding, delegations_amount, total_lsm_shares and unprocessed_unbonded_amount are zero while core_balance and current_stake would be the same amount. results it this Consequently, contracts/core/src/contract.rs:788, causing the protocol process bonding. division would result by in a in zero to not be able to error", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Attackers can spam Unbond messages to cause DoS of the protocol", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf", "body": "In contracts/core/src/contract.rs:952-959, the execute_unbond function of the core contract allows users to unbond their tokens. By doing so, the execution appends an UnbondItem to the unbond_items vector of the current unbond_batch and then stores it in the contract. However, since there is no maximum cardinality of items that can be appended in the unbond_items vector and no minimum unbounding amount requirement, attackers could spam a large amount of Unbond messages with a small unbounding amount to grow the vector size. This would result in increasing the costs for encoding and storing the unbond_items vector to the point of the execution running out of gas and hindering users to unbond.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Incorrect mint calculation during DenomType::LsmShare bonding", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf", "body": "In contracts/core/src/contract.rs:1005-1064, enables users to bond their tokens and mint derivatives. the execute_bond function However, if the denom_type is equal to DenomType::LsmShare, the amount is directly used without calculating the underlying amount. Consequently, an incorrect number of tokens is computed and minted, resulting in inaccurate accounting and potential nancial losses for users. This issue has been independently reported by a third party. Status: Externally Reported 7. Invalid nite state machine transitions prevent expected ow execution Severity: Major There are multiple instances of state transitions that are not considered valid in the context of the nite state machine (FSM). in the example, For in contracts/core/src/contract.rs:562, the FSM state is set to Claiming, even if there are no validators_to_claim. Since the state transition from Claiming to Unbonding is not valid this would prevent the branch from being executed in lines 574-579. execute_tick_idle, function However, even if the state of the FSM remained in the Idle state, the only valid transition to Unbonding is from Staking. This would prevent any unbondings in any other tick except execute_tick_staking. In particular, in execute_tick_claiming the branch cannot be executed in lines 651-654. Similarly, in execute_tick_transferring the branch in lines 676-679 would be an invalid state transition from Transferring to Unbonding.", "labels": ["Oak Security", "Severity: High"]}, {"title": "1. Users will not get native assets back when borrowing them from borrowed farm", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "In the callback_unbond_hook function, stakers that borrow native assets should receive the swapped amount since the pairs swap_msg functionss to parameter to see Some(staker_addr.to_string()), contracts/borrowed-farm/src/bond.rs:407. For native assets though, there is a bug in packages/alpha-homora-v2/src/adapters/pair.rs:206. Consequently, a swap of native assets would be called with None set as the to parameter, which would lead to the swapped funds being stuck in the borrowed farm contract. swap_msg functions is set apply value does that not the the to in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Attackers may delay price update transactions by feeders to manipulate oracle prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the When feeders feed prices to the oracle contract, PriceInfo is set to the current block timestamp. When querying prices from the oracle, that last_update_time value is used in contracts/oracle/src/contract.rs:265 to check whether the last updated price is too old. An attacker (or colluding validators) may exploit this by delaying transactions to shift price updates. the last_update_time of Suppose that a feeder sends a price update transaction in block 12345. An attacker may execute a DOS attack on the target node or the feeders infrastructure to prevent the inclusion of the transaction until some point in the future (e.g. block 13000). In that later block 13000, the price will be accepted and will be considered up to date. That allows an attacker to shift prices around to their benet.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. New borrowers using Homora Bank will pay fees for older borrowers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "During borrows and repays in the Homora Bank contract, the current debt state is updated in In that function, the interest accrued within the Red the update_debt_state function. Bank is calculated, and a proportional Homera fee is stored in state.homora_fee. When a user now repays their loan, they will have to pay that homora_fee proportionally to the in amount contracts/homora-bank/src/contract.rs:462-464 does not account the duration a user has been borrowing though, which implies that new users pay the fees for previous users. current mechanism implemented for repay. debt they The of As an example, suppose there is a current debt of 100 in the Homora Bank and a homora_fee of 10. Now a user is borrowing 100 tokens and immediately repays these 100 tokens in the same block. The current logic will charge that user a proportional fee of 10 * 100 / 200 = 5 tokens.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Tokens with low price may have wrong price quoted by oracle due to loss of precision and price impact of probe amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "calculating in When contracts/oracle/src/contract.rs:297, the price_multiplier, which eectively truncates any decimals beyond 6 decimal places. This is a major issue for tokens that have very low prices and many decimal places. For is multiplied price the in price median oracle the the by example, a token with 18 decimal places and a current price of 0.0000018 would be wrongly represented within the Alpha protocol with a price of 0.000001. Additionally, the probe amount may lead to too much of a price impact for tokens with a low token price.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Wrong interest rate is used when withdrawing from lending bank, leading to small losses for other users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "to interest rates are During the execute_withdraw function of the lending bank contract, updated in withdrawal contracts/lending-bank/src/contract.rs:701. With the linear interest model, a withdrawal implies that utilization goes up, which means that both the borrow rate and the liquidity increase. balance reect after new the in line 707, the balance after withdrawal is calculated. Within that calculation in the Then, get_updated_liquidity_index function, the new liquidity rate is used to update the liquidity index. Since the liquidity rate went up, the liquidity index is higher than it should be. This implies that the user will have fewer IB tokens burned than they should have. The protocol and hence other users will take the dierence. The impact of this issue depends on the activity of the protocol with high amounts locked, small burned amounts and frequent interactions that update interest rates, the impact of a wrong index is rather minor. If there are big withdrawals and less frequent interactions though, there can be material losses for other users.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Adjusting positions up will fail if borrow asset is native but provide asset is CW20 or vice versa", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the In method contracts/borrowed-farm/src/adapters/leveraged_farm.rs:73, wrong borrow_asset_info is sent in line 75. increase_position_msgs provide_asset_info whether native check is a in there is a while asset, This is no issue if both tokens are either native or both are CW20 tokens. If they are of dierent asset types though, no funds of borrow_asset_info will be sent or no allowance will be increased, which will lead to a failure of the execute_adjust_position function when positions are increased in contracts/borrowed-farm/src/bond.rs:557.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Oracle uses median of recent (spot) prices, may be subject to spot price manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "Dierent functions in the protocol query the oracle contract for asset prices. Each asset has those prices in the dierent price sources, and the oracle returns the median of query_asset_price function in contracts/oracle/src/contract.rs:297. All of the price sources use a single stored or queried price. Some of those price sources use spot prices. Spot prices can be manipulated, for example by swapping large amounts of tokens before using the Alpha contracts. Depending on the conguration of an asset, this may allow manipulation of the median price, and hence may be exploited by an attacker. We classify this issue as minor since spot prices are only supposed to be used for testing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Swap amount calculation does not account for taxes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "function get_swap_amount in The contracts/leveraged-farm/src/deposit.rs:81 and 102 on the amounts prior to deducting tax, which happens in lines 84 and 104, respectively. That implies that the swap calculation will be slightly o, and the small dierence will be arbitrated away by external actors. While the impact of this dierence is small, it will take away from a users yield and is easily prevented. called is We consider this issue to be minor since the impact is relatively small.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Repayment may fail if amounts are small", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "During repayment, in the callback_repay function, a swap happens between asset A and asset B to settle outstanding debt from bank A and bank B. Those swaps have a condition to tokens swap in contracts/leveraged-farm/src/withdraw.rs:181 and 197. If that minimum is swapped, the remaining amount of the bid asset might not suce though to repay the other loan. minimum of a", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Swap calculation in leveraged farm uses hardcoded fee and will be wrong if the underlying fee is changed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "get_swap_amount The in contracts/leveraged-farm/src/deposit.rs:43 assumes that the underlying pool swap fee is 0.3%. That value is hardcoded in the formula and hence calculated swap amounts will be wrong if the underlying swapping protocol changes their fee. function same exists The contracts/borrowed-farm/src/bond.rs:527. issue the in execute_adjust_position function in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Lack of price validation in oracle might cause issues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "Prices from feeders are currently not validated. Feeders could (accidentally) set a price to zero in contracts/oracle/src/contract.rs:133. That causes inconsistencies in the protocol, for example in health checks of a position.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Cong parameter validation missing in Homora Banks init asset cong", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the Homora Bank, conguration In the execute_init_asset_config function of parameters in are contracts/homora-bank/src/contract.rs:175-180. If those parameters are set to invalid values, the collateral_factor is set to zero. the protocol might not work as expected  for example if validated not neither Additionally, execute_update_asset_config function currently validate the fee_rate or liquidation_bonus. execute_init_asset_config nor the the the We consider this to be a minor issue since it can only be caused by the owner and is recoverable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "In packages/alpha-homora-v2/src/adapters/asset.rs:318, Luna is treated as a special case for tax calculations, with a hard-coded zero tax value. However, this might lead to inconsistencies if Terra changes the Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, misusing funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Reliance on assumed received amounts might cause issues in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "In several places in the codebase, the implicit assumption is made that another contract is sending a requested amount. Even if correct today, that assumption might be wrong in a future update of a dependent contract, for example, if fees are introduced that reduce the sent amount. An example of this can be found in the Homora Bank contract, where an asset is borrowed from the bank in contracts/homora-bank/src/contract.rs:387. Then the asset is sent to the borrower in line 389, without verifying that the requested amount has actually been received.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Failing swap simulation in leveraged farm may lead to high arbitrage losses when providing liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "If the swap simulation in contracts/leveraged-farm/src/deposit.rs:89 or 109 fails, a zero value is used. Swapping is then skipped in lines 91 or 111, but the liquidity is still provided and the position increased. This may cause liquidity provision with a ratio that is far away from actual pools of the AMM, and the dierence will likely be arbitraged away by external parties, leading to a loss of value.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Spot price queries from oracle may return wrong prices if neither asset is UST", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the function, query_spot_price In in contracts/oracle/src/contract.rs:331-335 that one of the two assets of the pair the price will always be quoted in assets[1]. This is is UST. problematic, since a misconguration of the pair would lead to the protocol executing with wrong prices, rather than returning errors. assumption is made thats not the case, implicit the If", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Interest rate calculation does not account for leap years/seconds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "SECONDS_PER_YEAR in The contracts/lending-bank/src/interest_rates.rs:20 has a value of 31536000 seconds, which corresponds to 365 days (a non-leap year). This implies that in leap years and when leap seconds are used, the interest rate will be slightly higher than expected. constant", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Querying the lending banks market list, user debt and user positiont may run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "The query_markets_list, query_user_debt, and get_user_asset_positions in functions unbounded and contracts/lending-bank/src/contract.rs:1079, contracts/lending-bank/src/accounts.rs:73. That may run out of gas. iterations markets contain stored 1104, over all", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Max di value validation in borrowed farm is executed on previous value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf", "body": "the execute_update_position_parameters In in contracts/borrowed-farm/src/contract.rs:297, validate_percentage is called with the previous max_diff value, not the newly set one. That allows a max_diff value that is bigger than 1. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. NOIZDStaking.sol: Instant withdrawal signatures can be replayed to bypass freeze time in some cases", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "Nonces are used as a type of withdrawal id to make instant withdrawal permissions unique, which is veried in function _withdrawInstant. However, nonces are kept on a per-user basis, meaning that a user could re-use an admin generated signature intended for another user currently on the same nonce.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. NOIZDStaking.sol: Refund could be blocked by a malicious or faulty receiver", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "The transaction reverts if a single Ether transfer fails (line 388), allowing a malicious or faulty receiver to block the refund operation. This is mitigated by the fact that the built-in pagination allows the admin caller to avoid such malicious or faulty receivers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. NOIZDNFT.sol: Unreachable conditional statement", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "The following code in function tokenURI in line 63 will always result in the execution of the rst branch: return string(abi.encodePacked(baseURI, _tokenURIs[tokenId])) : \"\"; bytes(baseURI).length > ? The reason for this is that baseURI is read from the hardcoded value \"ipfs://\".", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Outdated OpenZeppelin release used", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x issues, some of which are related to ECSDA signing. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release, particularly, since the draft EIP-712 implementation used is updated frequently.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Randomness precompile does not charge gas for external call processing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "get_randomness The in builtin_actors/actors/evm/src/interpreter/precompiles.rs:346, which is callable from the FEVM, does not account for gas for the entire process. precompile dened In ref_fvm/fvm/src/gas/price_list.rs:684, gas is only charged for hashing and the precompile call but not for the random value generation process. Since this function can be invoked by any contract in FEVM, an attacker is able to create a contract that intensively calls this precompile in order to use computational resources without being charged appropriate gas. This could lead to overloading nodes in the network, up to the point where block production slows down or even stops due to timeouts being reached.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Actor installation is not charging gas on wasm preload error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In ref-fvm/fvm/src/kernel/default.rs:906, charging gas after the engine preload operations. the install_actor function is This implies that if the engine fails to set up the wasm engine and bytecode, it will return an error interrupting the execution without calling the on_install_actor function, which is responsible for charging gas. An attacker could take advantage of this by loading an invalid serialized wasm le that consumes computational resources and then returns an error in the preload operations paying no additional gas.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. No gas is charged for event emission and storage", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In fvm/src/gas/price_list.rs:274-281, the gas cost for event-related operations is zero. This implies that no additional gas cost is charged to actors that emit events, including FEVM. Additionally, during the execute_message function, the commit_events function, dened in fvm/src/machine/default.rs, performs an unbounded loop through all the provided StampedEvents in order to store them one by one in an Array Mapped Trie without accounting for gas. Since no gas is charged for event emission and storage, an attacker could leverage this behavior in order to consume computational resources without paying additional gas. This can be exploited to slow down block production or even halt the chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. difficulty opcode is not following the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "As per the legacy EVM specication, the DIFFICULTY opcode returns the current block diculty. After the introduction of EIP-4399, this opcode behavior changed slightly in order to return an RNG beacon following the RANDAO specication. The current FEVM implementation of the DIFFICULTY opcode always returns zero. This implies that smart contracts using this functionality could suer unexpected behaviors.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Storage opcodes do not follow EIP-2929", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In the EVM Berlin fork, EIP-2929 got introduced, which is not implemented in current storage opcodes in the FEVM. Because of that, the FEVM implementation diverts from the gas handling of the EVM.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Maximum stack size can be exceeded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "Prior to executing an opcode, the stack size is checked by calling the Stack::ensure function in builtin-actors/actors/evm/src/interpreter/stack.rs. the current stack size is insucient, the stack size is doubled, possibly increasing the stack size beyond STACK_SIZE. If If the Stack::ensure function is called again as part of executing the next opcode, and the required size is less or equal to the current stack size, it will consider the stack size sucient without checking the size limit. This leads to the stack size being increased beyond the intended limit of 1024 to a maximum stack size of 2048.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Deviating from the EVM, retrieving the code for non-existing accounts reverts the transaction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "the The opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH retrieve the bytecode by calling in get_evm_bytecode_cid builtin-actors/actors/evm/src/interpreter/instructions/ext.rs. However, non-existent account, leading to the transaction being reverted. this function returns an unhandled error in case the address belongs to a function On the contrary, the EVM returns 0 for EXTCODESIZE, and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a non-existent account.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Opcode gas accounting deviating from the Ethereum EVM specication could lead to unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "Due to the dierent gas accounting, contracts developed for the EVM might experience compatibility and portability issues when deployed to the FEVM. Commonly, code is optimized regarding gas cost, but since the FEVMs gas accounting is dierent, the same contract executing on the EVM might run out of gas on FEVM or vice versa. Please nd below a few concrete examples of issues caused by the diverging gas accounting: 1. In the following example, the store function is executable on Ethereum and Binance Smart Chain with num = 50_000, while not executable on the FEVM. It runs out of gas if num >= 45_000. uint256 number; function store(uint256 num) public { for(uint256 i = 0; i<num; i++){ number = i; } } 2. If a contract contains a call instruction with an explicitly provided gas limit via {gas:value}, it may not be portable from the EVM to the FEVM. The optionally dened gas limit for the call instruction has to account for all the internal FVM operations (e.g., system.send handling), making it complex for developers to guess the correct amount of gas limit to provide. An example is provided in Appendix 1. 3. Ethereum smart contract developers usually optimize the code and the build process to minimize gas costs for the user. enables that solc https://docs.soliditylang.org/en/v0.8.17/internals/optimizer.html. optimizations dierent types of rely on opcodes Using the --optimize-runs compiler ag optimizes the gas cost of contracts designed to be deployed once and executed multiple times or if they are children of a factory contract. Also, some common patterns exist to optimize the code to use cheaper opcodes. For example, using SSTORE to store zeros in the EVM is cheaper than other numbers. All of these types of optimizations are not eective in the FEVM and could lead to portability issues. An example of how optimizations aect gas usage in FEVM is provided in Appendix 2.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. assert instruction does not consume all the remaining gas as dened in the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "As per the EVM specication, the assert instruction should consume all the remaining available gas by executing the 0xFE INVALID opcode. However, the FEVM implementation returns error code 33 without charging the remaining gas.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. The bitwise SAR opcode returns 1 instead of 0 if shift is greater than or equal to 256", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "to 256 for The EVM specication states that the SAR opcode should return 0 if shift is greater than or the FEVM implementation in equal builtin-actors/actors/evm/src/interpreter/instructions/bitwise.rs: 43 for the SAR opcode returns U256::ONE (i.e. 1) instead of 0 in this case. This can lead to incorrect results for the SAR opcode. 0. However, a value >=", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. LOG opcodes do not revert in case of a STATICCALL", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "According to the EVM specication, executing LOG opcodes is not allowed in a read-only STATICCALL and should revert in this case. However, the FEVM log function implementing the in does builtin-actors/actors/evm/src/interpreter/instructions/log.rs not check if the current call is a staticcall. opcodes LOG", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "12. block.coinbase is not following the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "According to the EVM specication, the block.coinbase instruction should return the miner of the current block. In contrast, in the FEVM, a zero value is returned. This implies that all the smart contracts that use this information, for example, as a source of entropy, will not work as intended. Examples of usages of this instruction on open source projects can be found with this GitHub query, resulting in around 24K results.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "13. FEVM gas consumption could saturate the available gas in a block and slow down the processing of core Filecoin operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "The FEVM gas consumption is generally higher than that of other core Filecoin network transactions. For example, a FIL transfer performed through FEVM costs 1.651.058 gas, while the same operation costs 489.268 with a base Send transaction. Since FEVM-related gas fees are on a dierent numeric magnitude than base operations, this could lead to a situation where FEVM transactions could saturate the block, leaving little room for core Filecoin operations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "14. The CREATE2 opcode smart contract generation is not supported by FEVM", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "The FEVM does not support smart contract creation using the CREATE2 opcode, while the EVM does. This behavior breaks the compatibility of smart contracts expected to work in the FEVM. A sample smart contract used for testing is available in Appendix 3. The functions create2NewToken and deploy in the provided smart contract revert when executed with the following error: { \"code\": 1, \"message\": \"message execution failed: exit 33, reason: message failed   with backtrace:\\n00: f01306 (method 2) -- contract reverted (33)\\n01: f010 (method 3) -- Serialization error for Cbor protocol: Mismatch { expect_major: 2, byte: 152 } (21)\\n (RetCode=33)\" } As a reference, the same smart contract can be successfully deployed with the CREATE2 opcode on the Goerli network: https://goerli.etherscan.io/tx/0x60150e92677fc2738571222de5a0c107780c131a38f87a493f2 58a56444f93", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "15. FEVM allows funds to be sent to a contract without the need for a receive or fallback method", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "Using the send and transfer functions on the FEVM, a contract can receive funds even without having a fallback or receive function. In contrast, the EVM specication requires that a smart contract cannot receive payments if it lacks a receive or fallback function. Breaking this assumption may result in unexpected behavior, including potentially lost funds. A sample smart contract used for testing is available in Appendix 4.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "16. After SELFDESTRUCT, FEVM does not follow the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In the EVM, when a smart contract executes the SELFDESTRUCT opcode, it thereafter operates as an EOA, which means that its code is erased while it continues to receive payments. However, the funds are no longer available since smart contracts do not have explicit private keys. the FEVM, after executing SELFDESTRUCT on a smart contract, payments can no longer be received, and the error actor doesn't exist is returned. implementation of In the present This behavior of FEVM deviates from the EVM, which may cause problems when migrating EVM-based smart contracts directly to FEVM. A sample smart contract used for testing is available in Appendix 5.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "17. DELEGATECALL does not propagate msg.value to the implementation contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "As per the specication of the DELEGATECALL opcode, the execution context should be the same as the caller contract, which implies that the msg.value and msg.sender values should be the same in the implementation contract, and the implementation contract can utilize those values during execution. However, the FEVM implementation of DELEGATECALL does not propagate the msg.value of the caller context during the delegatecall, since in msg.value builtin-actors/actors/evm/src/interpreter/instructions/call.rs:148. This reduces the portability of EVM contracts to the FEVM and may even lead to unexpected these behavior with potentially catastrophic consequences if divergences in behavior. teams are unaware of U256::zero() passed as is A sample smart contract used for testing is available in Appendix 6.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "18. Diverging behavior of gas refunds during SELFDESTRUCT between EVM and FEVM", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "According to the EVM specication, the SELFDESTRUCT opcode refunds 24000 gas units. The accumulated refund can not exceed half of the gas used for the current context, while a gas refund is provided only once at the end of the transaction's execution. In contrast, the FEVM refunds gas upon SELFDESTRUCT during the the transaction in ref-fvm/fvm/src/kernel/default.rs:180. That implies that the execution can use refunded gas, which may lead to unexpected behavior when porting smart contracts from the EVM to the FEVM. execution of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "19. Retrieving the code of precompile addresses reverts, which diverges from the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In the FEVM, the opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH revert if the target address is a precompile. Given that the FEVM considers all addresses in the range between 0x0 and 0xffff as precompiles, the aforementioned opcodes revert for those addresses See builtin-actors/actors/evm/src/interpreter/instructions/ext.rs:59. precompiles. even they are not if On the contrary, the EVM returns 0 for EXTCODESIZE and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a precompile.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Users can incentivize pools without supplying native funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "The in incentivize the contracts/tokenomics/incentives/src/utils.rs:285 assert_coins_properly_sent function to determine that the funds sent with the the message However, assert_coins_properly_sent function does not perform the fund assertion if the supplied funds are empty, as seen in packages/astroport/src/asset.rs:254. specied function tokens. reward match calls the Consequently, users can incentivize native reward tokens without supplying them inside info.funds. Please refer to the test_incentive_without_funds test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Users can claim excess rewards by specifying duplicate liquidity tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "In contracts/tokenomics/incentives/src/execute.rs:37, the lp_tokens vector specied by the user will be used to claim rewards from the pool. However, specifying duplicate liquidity tokens allows the user to claim more rewards as the existing pool and user positions are collected in a batch, causing the claim_rewards function to compute eligible rewards from an outdated state. Consequently, users can claim excess rewards from the pool, causing a loss of funds for the protocol. Please refer to the test_claim_excess_rewards test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Possibly incorrect reward calculations for new reward schedules", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "In the contracts/tokenomics/incentives/src/state.rs:59-61, calculate_reward function computes the user rewards by multiplying the global index and the user-bonded liquidity token amount if the user index is larger than the global index. This happens because if a new reward schedule is added after the old reward schedule is completed, full rewards are accrued to the user as their liquidity token staking spans across both reward periods. However, suppose the new reward schedules global index is larger than the user index (e.g., due to a large reward amount or a smaller number of stakers). In that case, the rewards will be computed incorrectly in line 63. Specically, the reward is calculated by deducting the global and user indexes and multiplying them with the user-bonded liquidity token amount. Consequently, users will not receive the total rewards they have staked across both periods, causing a loss of rewards for them. Please refer to the test_user_claim_less test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Malicious CW20 tokens can prevent legitimate rewards from being incentivized", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "the contracts/tokenomics/incentives/src/utils.rs:325-329, In remove_reward_from_pool function calls into_msg to transfer the remaining CW20 token the Internally, Cw20ExecuteMsg::Transfer message on the CW20 token contract to complete the fund transfer. the into_msg function calls recipient. rewards to the The issue is that malicious CW20 tokens can revert on purpose when the Transfer message is called, causing the transaction to fail and preventing the owner from removing them. As (see contracts/tokenomics/incentives/src/state.rs:267), legitimate reward tokens might not be possible to be added. Stakers would receive worthless tokens as rewards and would be disincentivized from providing liquidity to the pair contract. the maximum number allowed is external rewards ve of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. External reward incentivization can be maliciously blocked", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "in Reward incentivization is controlled through multiple factors, such as ensuring the reward is the not BLOCKED_TOKENS in incentivization_fee_info contracts/tokenomics/incentives/src/utils.rs:248. requiring caller and pay the fee to In contracts/tokenomics/incentives/src/state.rs:267, MAX_REWARD_TOKENS denes a maximum number of external reward token denoms that can be incentivized for a pair, which is a constant dened as ve. Once this limit is reached, a pool can no longer be further incentivized through external tokens. This presents an opportunity for an attacker to incentivize a pool with multiple worthless non-blacklisted denoms in order to reach the limit and block legitimate external rewards incentivization. Although the incentivization_fee_info fee is implemented, a motivated attacker could block external rewards to a pool relatively inexpensively. Additionally, the BLOCKED_TOKENS is congured as a vector that will increase in size for every blocked token. If the owner keeps adding the attackers tokens to the list with the UpdateBlockedTokenslist message, an out-of-gas error might occur when blocked_tokens.contains is called, as the contains function operates with O(n) complexity. We classify this issue as minor due to the mitigating eect of the incentivization fee.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Native token factory liquidity tokens cannot be supported", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "In the contracts/tokenomics/incentives/src/utils.rs:346-349, query_pair_info function calls the pair_info_by_pool function after parsing the lp_minter address from the native token factory denom. The parsed address will be the pair contract address because the second substring in token factory denoms represents the creators address, which is authorized to mint and burn tokens. occurs problem in The packages/astroport/src/asset.rs:656 attempts to retrieve the pair contract address by sending a Cw20QueryMsg::Minter query message on the lp_minter address. pair_info_by_pool function when the This implies that calling the pair_info_by_pool function for token factory denoms will fail because the Minter query is unavailable in a pair contract. We classify this issue as minor because the support for pair contracts to use token factory denoms is not implemented yet at the audited commit.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Updating blocked tokens does not aect existing reward tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "The contracts/tokenomics/incentives/src/execute.rs:428-503 update_blocked_pool_tokens function in automatically removes active pools BLOCKED_TOKENS. However, this is not enforced for existing reward tokens. that are part of contain assets that the newly added Specically, the incentivize function does not allow blocked tokens to be added as an external reward in contracts/tokenomics/incentives/src/utils.rs:221. As this is only validated when incentivizing new reward tokens, existing reward schedules that contain blocked tokens are not removed. Therefore, although a blocked token will no longer be eligible for new rewards, any pool that already includes it will keep distributing the token.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. The factory contract cannot deregister pairs not stored in the incentives contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "the contracts/tokenomics/incentives/src/utils.rs:110, In deactivate_pool function calls PoolInfo::load when the factory contract deregisters a pair contract address. Such transactions will fail and revert if the liquidity token is not stored in the incentives contract though. This could happen if no users stake the liquidity token in the incentives contract or the liquidity token is not incentivized internally or externally. Please refer to the test_cannot_deactivate_pool test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. The remaining reward funds could be stuck after the owner deregisters them", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "and optionally The RemoveRewardFromPool message allows the owner to remove an external reward token in rewards the owner does not contracts/tokenomics/incentives/src/state.rs:380. choose to remove upcoming rewards from the EXTERNAL_REWARD_SCHEDULES storage, the funds will remain in the contract and will only be distributed if someone incentivizes it for the liquidity pool. scheduled upcoming remove If However, if the reward schedule period has ended and the reward is not incentivized, the funds will be stuck in the contract because there is no entry point for the owner to withdraw them. We classify this issue as minor because it can only be caused by the owner passing a true value for the bypass_upcoming_schedules argument.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Orphaned rewards will be stuck in the contract after the schedule nishes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "In contracts/tokenomics/incentives/src/state.rs:158, the rewards are added to the orphaned rewards if there are no liquidity token stakers. An edge case scenario is that if there are no liquidity tokens staked after the reward ends, the global index will remain zero when added into FINISHED_REWARD_INDEXES, and the orphaned rewards will be stuck in the contract. We classify this issue as minor because users are expected to be incentivized to stake their liquidity tokens for rewards.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Malicious liquidity tokens can bypass factory contract registration validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "In the contracts/tokenomics/incentives/src/utils.rs:379, is_pool_registered function compares the pair contract address queried from the factory contract (factory::QueryMsg::Pair) to match the pair contract address queried from the liquidity token (PairQueryMsg::Pair). This is used to ensure the liquidity token is not forged and originates from a pair contract instantiated by Astroports factory contract. However, this validation can be bypassed by creating a malicious CW20 token that returns PairInfo.contract_addr as a legitimate pair contract address registered in the factory contract. This is because the validation relies on a response returned by the untrusted contract, which can be manipulated. Consequently, the liquidity token validation in deposit, setup_pools, and incentivize functions can be bypassed, allowing untrusted liquidity tokens to receive reward distributions.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Typographic error in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "spelling error. In packages/astroport/src/incentives.rs:27, insentivization_fee_info should be spelled as incentivization_fee_info. It is there is a best practice to resolve variable name spelling errors to improve the readability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Lack of duplicate validation when updating blocked pool tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "update_blocked_pool_tokens in The packages/astroport/src/execute.rs:398 does not validate if there are duplicates between the add and the remove input vectors. Given that the remove operation is done rst in lines 414-425 followed by the add operation, in case an asset is present in both, it will end up being added to BLOCKED_TOKENS without further warning. function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Error message diers from implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "In packages/astroport/src/incentives.rs:52-55, the number of periods of a schedule is validated. The if statement allows that input.duration_periods == MAX_PERIODS; however, the error message states, Duration must be more 0 and less than {MAX_PERIODS}, which diers from the implementation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. New pools can have zero allocation points", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf", "body": "The in contracts/tokenomics/incentives/src/execute.rs:241 allows allocating zero setup_pools function alloc_points to any given pool. This will result in the pool not receiving any ASTRO rewards.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Anyone can whitelist a new vAMM or overwrite an existing one", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "contracts/factory/src/contract.rs:45, In executing ExecuteMsg::Whitelist message, there is no check on the senders address of the transaction to ensure that it is contained in the admins list. when This may lead to three malicious behaviors:  Anyone can instantiate and whitelist a new vAMM on behalf of admins passing arbitrary parameters.  As vAMMs are indexed in the VAMM_ADDRS Map with the stringication of currency_pair as the key, anyone can overwrite an existing vAMM address mapping with a new one with arbitrary parameters.  Using the DelTranche in contracts/risk-fund/src/contract.rs:86, maliciously registered vAMMs can drain the risk fund completely.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Risk fund is not able to partially disburse creditors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/state/tranche.rs:366, when disbursing from the risk fund, the execution tries to take all possible funds from tranches in order to pay the creditor. If there aren't enough funds, it will return an error causing creditors to not get funds, not even partially based on the availability.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. saveSwapInstruction can be executed by anyone with arbitrary values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/contract.rs:73, there isnt any check on the message sender role when executing a saveSwapInstruction message. As this message is used to save and update the Astroport swap pair contract address for a specic pair, the execution of it should be restricted to admins only. In fact, a malicious actor could overwrite a legit Astroport swap pair address to a malicious one. Such a malicious pair could receive UST, emit appropriate events, but not actually return another asset. This is also possible because ReplyKind::AstroportSwapUst parses the asset information from the returned event.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. assert_admin might run out of gas and contract-specic admins might lead to inconsistency and misconguration risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/factory/src/state/admin.rs:13, iterations over ADMIN_ADDRS may run out of gas if the vector has too many entries. Because admins cannot be removed there is currently no way to recover from this issue (see issue 11). Additionally, dierent contracts, e.g. the vAMMs, and the vault, might all contain distinct lists of admins, which the factory, introduces the risk of misconguration.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Risk fund is not aware of the fees sent from the vault", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/vamm/src/contract.rs:98, contracts/vamm/src/state/liquidation.rs:309 and 314, the vAMM is sending a message to the vault VammMsg::SendFunds. in order to send collected fees to the risk fund using The execution of this message is sending funds to the risk fund through a BankMsg::Send but its not directly triggering a mechanism to collect fees. This may lead to the contract not being aware of the collected fees and to capital ineciency of fees that are already in the risk fund but are not in tranches.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. is_vamm_addr might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/factory/src/state/address.rs, the is_vamm_addr function has an asymptotic cost of O(n) and can make the message run out of gas depending on the length of VAMM_ADDRS and the to_check parameter position in the array. This can happen when calling QueryMsg::IsVamm from the risk funds can_disburse function. Since any user can add vAMMs (see issue 1), an attacker can exploit this vulnerability to deny the expected functionality.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Prices collected from oracle are inverted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "During liquidation, the current price is calculated as UST/asset, in the same way as it is calculated in or contracts/vamm/src/state/market.rs:112-119. spot_price mark_price for As prices returned from Chainlink are represented as asset/UST and they use a dierent method respecting mark_price,  calculations between those two values are inconsistent.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. CollectFee message execution might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/contract.rs:62, under certain circumstances, the execution of the CollectFee message can consume a big amount of gas and in the worst case can run out of gas. Consider as an example the scenario that the UST tranche is almost full. 1. Alice sends a CollectFee message. 2. The execution will call the collect_fee function and will ll the UST vault with UST in the msg funds. 3. Now, assume that this will not consume all the funds in the msg. The execution will call recursively collect_fee in order to ll the second tranche. 4. This will cause an interaction with Astroport, we need 2 queries to correctly create the message and then send it. 5. Astroport contract execution returns a reply. 6. Contract uses the reply to update the tranche state. 7. If there still are some funds in the msg, the execution will call another time the collect_fee function. 8. Here we can potentially loop several times until the execution will ll all the tranches or user funds sent in the message will be depleted. This issue is not unlikely to happen if the UST tranche is almost full.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Risk fund can be drained completely due to unpriced vega risk, if highly volatile assets are listed or volatility conditions change", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "Suppose that an asset faces above normal volatility conditions and suppose that an attacker creates two large and maximum leveraged positions with two distinct wallets one short (A) one long (B) such that the expected sum of the payout of the two positions is A+B-fees, and the expected value of A+B is E(A+B) = 0. If the market volatility is large enough to assure that the collateral of one position will not be enough to cover its losses, an exploiter can create a series of payments to drain all funds from the risk fund. In layman's terms this is because the losses of the losing position are limited (since bad debt doesnt exist) and the earnings of the winning position are not capped but are paid out entirely until the risk fund is empty. Because such an attack requires sound nancial engineering and is only possible during adverse market conditions of a given asset, we do not consider this to be a major issue. However, this attack vector also highlights another important vulnerability of the protocol. Because very risky/volatile assets are covered by the same tranches of the risk fund as less risky assets, less risky positions might lose their risk fund coverage from adverse events in the more risky segment. Especially for risk averse users that use the protocol for hedging purposes, this might be an undesired property.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Extensive admin permissions go against best practice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. Under the current architecture, admins have several such permissions: 1. 2. contracts/vamm/src/contract.rs:224, using In ExecuteAdminMsg::ForceMarketPrice, the market price can be set to arbitrary values putting users' funds at risk of liquidation. In contracts/vault/src/contract.rs:67, any address can be added as a new vAMMs address using ExecuteMsg::InsertVamm, which then can drain funds from the vault completely via VammMsg::SendFunds. 3. In contracts/vamm/src/state/config.rs:69-111, updated such that: the config can be a. Only full liquidations take place, via updates of config.liquidation_total_ratio. b. The likelihood of liquidations increases drastically, via updates of config.mark_price_divergence. c. Liquidation rewards are sent fully to the liquidating address, via updates of config.liquidation_reward_split. 4. 5. In contracts/risk-fund/src/contract.rs:86, DelTranche can be called by admins and vAMMs. It sends the funds to the sender. In contracts/risk-fund/src/contract.rs:35, it is possible to add a new admin but not possibility to remove an admin. This makes it impossible to stop malicious admins. This issue is especially problematic due to the smart contracts support of multiple admin accounts  administering these requires o-chain maintenance, which is prone to human error.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. bigint crate is aected by CVE-2020-35880", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "a In rust/utils/Cargo.toml:17 of the levana-common repository, bigint is specied in as https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35880 and https://rustsec.org/advisories/RUSTSEC-2020-0025.html that crate is aected by a Critical CVE with a score of 9.8. dependency. reported As The crate is not maintained anymore and contains several known bugs (including a soundness bug).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Address provider does not validate addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/address-provider/src/contract.rs:44, ExecuteMsg::Change function handler execute_change takes a to parameter of type Addr. This may cause an unvalidated address to be stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. vAMMs conguration parameters are not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/vamm/src/state/config.rs:69, the update_config function which is called when initializing and updating config lacks validation on conguration parameters before saving them. As some of them are intended to be in a specic range and used in math operations, this may lead to inconsistency and execution errors caused by division by zero or assigning negative values to unsigned integers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Admins can insert unvalidated vAMM addresses in the vault", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/vault/src/contract.rs:70, insert_vamms allows adding a new vAMM address in the VAMM_ADDRS array without validation. This may cause inconsistencies in VAMM_ADDRS.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Some possible values of vbase_liquidity can make vAMM unusable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "contracts/vamm/src/state/markets.rs:158, In using vbase_liquidity taken from the InstantiateMsg to initialize quote, base and k of the curve. init_curve is As there is no validation for vbase_liquidity, a value of this parameter equals to or less than 0 can make the vAMM unusable as this will cause:  Case vbase_liquidity == 0: quote, base and k all with zero value  Case vbase_liquidity < 0: quote and base with a negative value", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Its not possible to change the admin of the address provider contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/address-provider/src/contract.rs, the admin cw_controller is registering the contract admin address in the instantiate message. After that, its not possible for the admin to change its address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Its not possible to add or remove admins in Factory, Spot Price, vAMM and Risk Fund contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In Factory, Spot Price, vAMM and Risk Fund contracts instantiate function, the list of admins is taken from the InstantiateMsg message. the instantiation, After its not possible for admins to be added or removed. This is problematic since a compromised admin address cannot be removed or replaced with a new one.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Lack of validation of AddTranche cong values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/contract.rs:80 when executing the AddTranche message, values in the cong object are not validated. This can lead to a not working tranche registered in the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Iterations over tranches might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "the In contracts/risk-fund/src/state/tranche.rs:59-73, tranches might run out of gas, if too many tranches exist. As this can happen only through admin error and is recoverable, we classify this as a minor issue. iterations over", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Proposals tally returns wrong vote results", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:x/gov/keeper/tally.go:79-81, when calculating the result of a governance proposal, the execution is not accounting for NoWithVeto votes. The current implementation returns a failed proposal result if the following inequation is true:     .   It is evident that NoWithVeto votes are not counted and treated as Yes votes in the example in Appendix 1. This implies that proposals that should fail will be unintendedly successful.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. An error triggered during the handling of an Ack IBC message will make the channel unusable and spam the network", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "Neutron uses ORDERED channels, which means that there is a sequencer that keeps track of the currently waiting Ack message. is in handled in This message https://github.com/cosmos/ibc-go/blob/77c10be63204a52ec53b1e8ef91a76bae140d5ed/mod ules/core/keeper/msg_server.go#L588-L647 that incrementing the responsible for the IBCModules HandleAcknowledgement method NextSequenceAck and call dened in neutron:x/interchaintxs/keeper/ibc_handlers.go:16-47. Acknowledgement function dened the is it returns an error, If incremented. This could happen for various reasons: the execution will revert and NextSequenceAck will not be  Sudo handlers in the smart contract return an error because of a bug or an invalid input data  Sudo handlers are not dened in the smart contract This implies that the channel will be unusable and that the relayer will continue sending the same failing Ack message. Also, an attacker could use a signicant amount of deployed smart contracts and transactions with failing Sudo handlers in order to let relayers spam the network with Ack messages and trigger the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. IBC events loop in Sudo handler could drain relayers funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "A malicious hacker could develop a CosmWasm smart contract that implements an IBC events loop in the Sudo handler. For example a contract that in the Response Sudo handler, executes another transaction that will trigger the same Response handler and so on. Since there is not an aggregate gas counter for all the dierent transactions of the IBC events ow that could break the loop with an out of gas error, the execution can run until all the relayers funds are drained. Also, this behavior could be used to congest and slow down the chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Attackers are able to spam the network with IBC messages using the ibc-transfer module", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In  neutron:internal/sudo/sudo.go:100-103,  neutron:internal/sudo/sudo.go:132-135, and  neutron:internal/sudo/sudo.go:166-169, the execution is checking that the received Acknowledgement or Timeout Packet is related to an IBC transaction originated from an existing CosmWasm smart contract address and returning an error otherwise. Since it is possible to send an ibc-transfer modules transfer transaction also from a non contract address, for example using the neutrond CLI, with the following command: neutrond tx ibc-transfer transfer an attacker could send a big number of small value transfer messages in order to spam the network with Acknowledgement packets and let them fail in the guard implemented in the mentioned lines. A huge number of such messages could congest nodes and make them unable to process blocks before the BroadcastTxCommit timeout. Also, the NewTxTimeoutHeightDecorator will discard all messages with an elapsed heightTimeout, which could be used in a particular event in order to manipulate it. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Unbounded iteration in ValidateBasic may cause node timeout", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "ValidateBasic The in x/interchainqueries/types/tx.go:73-100 includes an unbounded iteration that may be exploited to cause a node timeout. MsgRegisterInterchainQuery function for The function loops over TransactionsFilter, a caller-supplied slice that is not checked for duplicate entries and does not have a dened size upper-bound. It is best practice to keep ValidateBasic logic simple as gas is not charged when it is executed. It should only perform all necessary stateless checks to enable middleware operations (for example, parsing the required signer accounts to validate a signature by a middleware) without impacting performance in the CheckTx phase. Other validation operations must be performed when handling a message in a modules MsgServer.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Unbounded iteration in PerformSubmitTx could be used by an attacker to slow down or halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:wasmbinding/message_plugin.go:204, SubmitTx is performing an unbounded iteration over submitTx.Msgs. An attacker could craft a message with a signicant number of Msgs with the intention of spamming the the block production time triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. and impact network This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Unbounded iteration in EndBlocker when calculating vote power could be used by an attacker to slow down or halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:x/gov/keeper/voting.go:40-51, in order to calculate voting powers, the EndBlocker is running an unbounded iteration over a slice containing all voting user votes. An attacker could use a signicant number of addresses with a small amount of tokens in order to grow the slice length and impact the block production time, eventually triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Attackers could steal funds from the ibc-transfer contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "neutron-contracts:contracts/ibc_transfer/src/contract.rs:43, In execute_send is called in order to complete an IBC-20 transaction from source chain to sink chain, but this function does not verify that there are sucient funds in the contract to support an IBC transfer. Because the execute_send function lacks an authorization check, an attacker can frontrun the legit user and steal funds by sending them from the contract to its own address on the sink chain. We classify this issue as major instead of critical since the ibc-transfer contract is meant to be an example.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Fee struct could be simplied to avoid manipulations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:proto/feerefunder/fee.proto:17, Fees denition includes Coins as an attribute in order to track users and relayers payments. The checkFees function dened in neutron:x/feerefunder/keeper/keeper.go:169 ensures that the user pays the right amount, checking that coins are over a threshold. However, theres no validation for the denom. This can be abused, and only one coin with almost no value could be used to pass the validation checks.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Unbounded messages loop could run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron-contracts:contracts/neutron_interchain_queries/src/contrac t.rs:312, tx_body.messages to lter out the required transaction. the recipient_deposits_from_tx_body function iterates over the However, because the number of messages is unknown, this could lead to an unbounded loop execution, which could cause an out-of-gas error. This implies that the smart contract may never be able to consume the supplied dataset corresponding to the query. Even though this is a major issue, we classify it as minor since the aected contract is only an example contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Contracts are not compliant with CW2 migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "The following contracts do not adhere to the CW2 migration specication:  neutron-contracts:contracts/reflect,  neutron-contracts:contracts/neutron_interchain_txs,  neutron-contracts:contracts/neutron_interchain_queries, and  neutron-contracts:contracts/ibc-transfer. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Resolved 35. Misleading error message while trying to send and repay at the same time", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Membrane/2023-06-15 Audit Report - Membrane v1.0.pdf", "body": "The mint_revenue function in contracts/cdp/src/position.rs:1639 performs a check to prevent the two optional variables send_to and repay_for being specied simultaneously or not specied at all. if True, However, \"Destination address is required\". specied, the error message is wrong. the error message informs about the second scenario only, that is, If both send_to and repay_for are", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Duplicate member addresses inate the total weight value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "the contract instantiation in phase During contracts/cw4-voting/src/contract.rs:32-37, the msg.initial_members vector that contains the Member struct address and weight is not validated to make sure the If a duplicate member address is member address is unique across the whole contract. provided, the associated address and weight would be overwritten by the USER_WEIGHTS storage state, as seen in line 35. However, the total weight value in line 36 would still include the nonexisting member weight. This would impact voting outcomes. A test case demonstrating the above scenario can be found in appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Duplicate item name causes ghost contracts to be instantiated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw-core/src/contract.rs:83, the msg.initial_items parameter that contains the InitialItem vector is not validated to have unique item names. Having two or more items with the same name would cause them to be instantiated as ghost contracts because eventually, the item name with the highest reply id would be used, as seen in line 746. As a result, this causes ineciencies in the contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Lack of delay when executing proposals makes contracts prone to governance attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw-proposal-single/src/contract.rs:217, there are no time delays when executing passed proposals. An attacker with enough capital can potentially stake many tokens to gain high voting power, create a malicious proposal and then vote for it. Since proposals can pass early as long as the voting threshold is reached (see contracts/cw-proposal-single/src/proposal.rs:112-114) a passed malicious proposal without giving the community enough time to discuss and block the governance attack. As a result, the attacker's governance attack would succeed, causing potentially catastrophic damage to the protocol. This is especially problematic if the contracts hold non-native tokens, which may have a higher value than the cost of the attack. execute to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Consider checking whether the item key exists before removing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw-core/src/contract.rs:420-434, any provided key as an argument will be removed from the ITEMS storage state as seen in line 430. Since the remove storage function will not dierentiate whether the key exists or not, it is possible to remove a key that never existed in the storage.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Admin withdrawals will aect the reward distribution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "execute_withdraw The in contracts/stake-cw20-reward-distributor/src/contract.rs:185 allows the the contract without an option for a partial admin to withdraw the entire balance of withdrawal. function After the admin withdraws funds using a Withdraw message, the contract will have empty funds, which causes the minimum comparison in line 156 to result in a zero amount. This implies that the Distribute message would pay zero rewards to the staking address for the whole staked duration. The staking address would need to wait some time for the pending rewards to recover to the intended value to receive another set of staking rewards. We consider this to be a minor issue since only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Reward duration should be validated as non-zero value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "contracts/stake-cw20-external-rewards/src/contract.rs:65, In msg.reward_duration represents the reward duration value which is used to calculate the reward rate. If the reward duration value provided is 0, it would cause a division by zero error in line 174 during the execute_fund functionality, causing the contract to be unable to be funded. We consider this to be a minor issue since only the contract owner can cause it. Even if it happens, the problem can be resolved by updating the reward duration to a non-zero value via the UpdateRewardDuration message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Maximum number of items is not sucient to prevent out of gas error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "MAX_ITEM_INSTANTIATIONS_ON_INSTANTIATE The in contracts/cw-core/src/contract.rs:84 is not sucient as it will allow for such a large number of items that the proceeding instantiation loop will run out of gas well before the limit is met. The maximum should be set to a more conservative value rather than u64::MAX - 100. validation", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. execute_pause does not enforce maximum pause duration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "The execute_pause function in contracts/cw-core/src/contract.rs:173 does not enforce a maximum pause duration. The value of pause_duration is added to the current block time and then saved to PAUSED with no checks or validation. This is problematic because if the value is accidentally set to a very high value, it will eectively render the contract useless, without a way to recover. Another potential scenario is that the duration is sent as a Height rather than a Time, which may result in the contract being paused for longer than anticipated.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Incomplete threshold validation in staked balance voting contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw20-staked-balance-voting/src/contract.rs:84, ActiveThreshold::Percentage is only validated to be smaller than 100%, but not validated to be larger than 0%. Zero values may cause undesired voting outcomes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Admin rights go against best practices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. In contracts/cw-core/src/contract.rs:194, the contract admin can run any message, introducing a centralization risk and a single point of failure if the admin keys are lost or compromised. In other reports, centralization risks have been agged with higher severity. In this case, we interpret the admin as a parent DAO which mitigates the centralization risk.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Voting module design is prone to conguration risk", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "The core contract and the voting module are closely interlinked. Because the voting module has only one interface (i.e. to the core contract), updating the voting module introduces an additional point of failure and a conguration risk (e.g. that a proposal module is congured as the voting module) without many benets that come from the modular design. Because this issue is based on a design choice the severity is informational.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/stake-cw20-external-rewards/src/contract.rs:143-153, a check is performed that ensures that in the transaction there is a Coin with the expected denom eld. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Voting thresholds can be set to unusual values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "packages/voting/src/threshold.rs:73-80, In set PercentageThreshold such that a majority can be achieved under very unusual conditions (e.g. if 1% are in favor and 99% percent are against a proposal). While this allows possible to is it for innovative forms of governance, it is prone to user error which may lead to devastating consequences.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. check_ownable is incorrectly implemented which allows attackers to list any tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf", "body": "In cw-std:sellable/src/execute.rs:40 and 263, the check_ownable validation function returns Ok in all conditions, even if the caller is not the owner of the NFT token. This means that a malicious actor is able to bypass validation measures, allowing them to list any NFT tokens at an extremely low price and subsequently purchase them.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Anyone can lock any token_id", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf", "body": "The redeem_item function in cw-std:redeemable/src/execute.rs:11 lacks an authorization check to validate whether the sender is the token_id owner or the contract owner. This allows anyone to lock any token_id in self.locked_items.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Anyone can halt any ongoing sale", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf", "body": "The halt_sale function in cw-std:sales/src/execute.rs:59 is permissionless. This means that any user can halt any ongoing sale. Attackers can take advantage of this to strategically halt sales or to grief users.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. buy_item will error when users supply the correct amount and denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf", "body": "The buy_item function in cw-std:sales/src/execute.rs:91 contains a condition that will cause the function to error when the correct denom and amount are sent. There are a number of issues with the funds validation in this function. First, the condition in line 91 is actually inverted, it will currently return a WrongFundError when the correct funds are sent. This will eectively prevent any user who is correctly supplying funds from buying the item. Next, the sale.price.contains validation is incorrectly used. The contains method on a vector of coins will actually only return true for a complete match of funds. This means that it will only return true if both the denom and amount are equal. these issues will The combination of in a situation where users will receive a WrongFundError when they are correctly passing a valid BuyItem message. Additionally, in the current implementation, transactions that supply the wrong denom will actually pass the validation and cause a panic in line 98. result", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Owner can be set to an invalid address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf", "body": "The ownable contracts SetOwner message in cw-std:ownable/src/lib.rs:106 does not validate that msg.owner is a valid address. This is problematic because the Addr type always must contain valid addresses. Addr is intended to only be used in code after it has undergone validation. In this instance, if the address is ever set to an invalid address, the owner value of the contract will no longer be updatable as there is an authorization check where the caller is checked and info.sender will never match the invalid address.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Primary sales can be incorrectly congured", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf", "body": "msg.start_time, The add_primary_sales function in cw-std:sales/src/execute.rs:47 will allow for overlapping primary sales to be introduced during the instantiation. While the function validates The add_primary_sales function operates with the assumption that sales are non-overlapping and have valid durations with regard to their start and end times. If the contract is improperly instantiated, then the function would also fail to prevent additional overlapping sales from being introduced when the PrimarySale message is received. msg.end_time. validate does not it", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Users will receive incorrect amount of LP tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "execute_balancing_provide_liquidity The in osmosis-liquidity-helper/src/contract.rs:78 allows users to provide either a single asset or a pair of assets to a pool. In the case that a user provides multiple assets, the contract rst performs a double-sided liquidity provision followed by a single-sided provision for any left over assets. function the LP tokens minted during the double sided liquidity provision are never However, transferred to the recipient. The LP tokens received from the initial liquidity provision that will be returned in response to the message in line 122 will never get recorded because the ReturnLpTokens callback was not called with the contracts initial lp_token_balance. The result will be that the caller will only receive LP tokens for the second liquidity provision.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Balanced liquidity provision into constant product pool will fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "When a user performs a balanced liquidity provision into a constant product pool in astroport-liquidity-helper/src/contract.rs:90, the contract rst swaps any tokens to ensure the ratio remains constant and then supplies the tokens into the pool. Subsequently, the contract returns the received LP tokens to the recipient using the callback function ReturnLpTokens. During execution of each message the contract will transfer the recently minted LP tokens from itself in astroport-liquidity-helper/src/contract.rs:185-190 and then again in 250-255. the callback function is called twice, rst to the recipient. However, The ReturnLpTokens callback that is dened in lines 185-190 will be executed before the liquidity is provisioned and the contract's balance changes. This will cause return_amount in line 274 to be 0. When the function attempts to transfer a zero amount the CW20 transfer return an error and revert function will execute_balancing_provide_liquidity function. the transaction. This will eectively block the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. No validation of min_out for double sided liquidity provision", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "When providing liquidity in the execute_balancing_provide_liquidity function in osmosis-liquidity-helper/src/contract.rs:78, users are able to specify the min_out value which denes the minimum amount of LP tokens they want to receive when providing liquidity. In the case that a user provides multiple assets to a pool, the amount of LP tokens minted is never checked to ensure it is greater than the value min_out. This means users may in fact receive fewer LP tokens than expected.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Insucient validation of swap paths", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "In function update_path in cw-dex-router/src/contract.rs:231-249, the contract admin is able to add swap paths to enable the liquidation of tokens that both do and do not share a direct pool. Currently, the contract validates that the rst and last assets match the oer and ask assets. In the case that there are swap operations performed there may be a situation where intermediary assets do not match. This would cause the failure of any execution of the function basket_liquidate. We consider this a minor issue as the admin controls the addition of swap paths.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Insucient validation of vault conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "When instantiating and updating the cong of a vault, the function check is called in which apollo-vaults/packages/apollo-vault/src/state.rs87-110 than it insuciently Decimal::one(). the performance_fee to ensure that validates less is Specifying a performance fee of greater than Decimal::one() would cause an overow in apollo-vaults/packages/apollo-vault/src/state.rs:94. Additionally, reward_liquidation_target is not enforced to be one of the assets in the pool as specied in lines 32-34, which could potentially cause inconsistencies in the overall behavior of the vault.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Basket liquidation fails if no path is found for oer asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "the basket_liquidate function In cw-dex-router/src/contract.rs:251-305, swaps all oer assets into a single receive asset. The swap paths that are used to exchange the oer for the receive asset are dened by the contract admin. In the case that one of the oer assets does not have a path set to the receive asset the throw an error in cw-dex-router/src/contract.rs:276. This would contract will prevent liquidation and the original calling function, execute_compound found in apollo-vault/src/execute_compound.rs, but also the primary function of the relevant vault. the execution of both the basket We consider this only a minor issue as the swap paths are dened by the contract admin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Lack of Osmosis Vault parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "The osmosis-vault contract from Apollo vaults instantiate function does not validate the submitted msg.pool_id before storing it. This might cause two dierent vaults to coexist with the same ID but dierent base and vault tokens, potentially confusing users. it In addition, is recommended to validate msg.lockup_duration to be within the expected range to avoid creating either a zero or an arbitrarily large lockup duration by mistake.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Use of magic numbers throughout the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  astroport-liquidity-helper/src/contract.rs:62  astroport-liquidity-helper/src/contract.rs:95  cw-dex/src/implementations/astroport/helpers:185-186", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "In apollo-vaults/packages/apollo-vault/src/execute_staking.rs:46, a check is performed that ensures that in the transaction the desired native assets have been received. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. The on-chain entropy is generated by querying Terra for the swap result between LUNA and TerraUSD for the amount of block height plus the block time in seconds. Since the swap amount will increase monotonically by a relatively xed amount, and the exchange rate between LUNA and TerraUSD is expected to uctuate by a few percentage points only per block, the resulting value will have little entropy. Recommendation We recommend relying on a more robust source of randomness. Status: Acknowledged The Ink team states in their documentation that it plans to move to an Oracles VRF as the source of randomness in a future version. 10. Updating Anchor aUST and market contract addresses in Anchor strategy could lead to incorrect states", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Ink Protocol/2021-09-15 Ink - Audit Report.pdf", "body": "2. The on-chain entropy is generated by querying Terra for the swap result between LUNA and TerraUSD for the amount of block height plus the block time in seconds. Since the swap amount will increase monotonically by a relatively xed amount, and the exchange rate between LUNA and TerraUSD is expected to uctuate by a few percentage points only per block, the resulting value will have little entropy. Recommendation We recommend relying on a more robust source of randomness. Status: Acknowledged The Ink team states in their documentation that it plans to move to an Oracles VRF as the source of randomness in a future version. 10. Updating Anchor aUST and market contract addresses in Anchor strategy could lead to incorrect states", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Lack of denom validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "Upon instantiation, the transmuter contract creates a pool with multiple denoms through the TransmuterPool::new function. However, the supplied denoms are not eectively validated in contracts/transmuter/src/transmuter_pool/mod.rs:16-24. Incorrect denominations or an input typo would render some of the contracts features unusable, requiring a new instantiation and for the users to withdraw current deposits.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Missing validation steps when registering limiters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "The transmuter contract lacks validation on some of the functions related to limiters. Neither upper_limit nor boundary_offset undergo any validation when newly created in contracts/transmuter/src/limiter/limiters.rs:63-64 and 207-209 or when updated in lines 314 and 348. If a value of zero is provided, most trades will fail to satisfy the limiters restrictions, making some features unusable. On the other hand, if a large number is set, the contract could become rapidly imbalanced as described in the issue Lack of limiters could result in uncontrolled pool imbalance in The label eld is allowed to be empty upon registration of a new limiter contracts/transmuter/src/limiter/limiters.rs:287. Although not a security risk, it can be misleading and aect the user experience. Finally, when registering a new limiter the target denomination is not checked to be part of the current pool in contracts/transmuter/src/limiter/limiters.rs:286-288. This will render the limiter ineective in case of a mistake or a typo, leaving the intended denomination without any control against imbalance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Unbounded loops could render main features unusable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "contract includes transmuter in The loop contracts/transmuter/src/limiter/limiters.rs:391-394. The outer initialization while the inner loop iterates through all denominations specied during pool iterates through all limiters registered by the admin. The size of both vectors can be arbitrarily decided by the admin. structure nested loop for a If any of these vectors is excessively large, it can signicantly inate the gas cost for swap operations, pool joins, or exits, potentially causing operations to revert. The risk escalates when both arrays are overly extended, due to the quadratic computational complexity. Although the comments in lines 365 and 378 state that the number of limiters is expected to be small, no actual mechanism is found to prevent the described scenario.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Zero-value swaps are allowed and introduce ineciencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "the SwapExactAmountIn and contracts/transmuter/src/sudo.rs SwapExactAmountOut messages which are used by the Pool Manager module of Osmosis to automatically execute swaps, including multi-hop swaps. denes These messages contain the token_in and token_out Coin elds. If any of the Coin elds have an amount eld set to zero, unnecessary swaps are performed. Unnecessary steps in a multi-hop swap could cause excessive gas costs for a user who might not be aware of the transmuter pool being used. For example, the SudoMsg::SwapExactAmountIn message triggers such a redundant swap when token_in is \"ABC\".to_string()) and to Coin::new(0, token_out_min_amount is set to Uint128::from(0). set Similarly, the SudoMsg::SwapExactAmountOut message will cause redundant swaps for any valid token_in_max_amount if token_out is set to a value such as Coin::new(0, \"XYZ\".to_string()). These messages can be sent from the Pool Manager module automatically as part of a bigger swap route. For example, redundant parameter combinations from the out-of-scope cosmwasmpool implementation could cause this issue.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Unoptimized zero amount burning or minting", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "swap_tokens_for_alloyed_asset and functions The swap_alloyed_asset_for_tokens, in contracts/transmuter/src/contract.rs:299 and 370, allow minting or burning of zero alloyed tokens. These scenarios arise from join_pool and exit_pool entry points when a user passes a Coin structure with an amount set to zero. dened Although the resulting submessage to x/bank module will fail, unnecessary computation and hence gas will be spent as both functions call check_limits_and_update which can be computationally intensive due to nested iterations inside.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Deregistering of non-existing limiters silently fails", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "In contracts/transmuter/src/contract.rs:187, during limiter deregistration, the in deregister contracts/transmuter/src/limiter/limiters.rs:290 is called. It performs removal operations over the vector without any prior validation, taking denom and label as parameters. The returned value of this operation is the same when an element is removed from the vector and when there is no match. declared function As a consequence, users will receive identical output for existing and non-existing (denom, label) pairs. This could lead to situations where limiters intended to be removed but containing a typo may still be in place after the admin tries to remove them.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Missing Division invariant check", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "In contracts/transmuter/src/division.rs, the Division structure is declared to carry two timestamps: started_at denoting the beginning of the span, and updated_at denoting the last modication time of the division's value. Line 49 enforces that updated_at is not before started_at. However, it does not enforce that updated_at is not after the division's end which is dened as started_at + division_size. This missing invariant check makes reasoning about divisions more dicult.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Admin transfer procedure can be enhanced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "contracts/transmuter/src/admin.rs implements a two-step admin transfer pattern following best practices, requiring the receiving side to accept ownership via the claim function. However, there is no dedicated API to cancel a proposed transfer. At present, the current contract admin can only cancel an unclaimed admin transfer by directing the privileges back to their own address, followed by claiming this mock transfer, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Redundant query function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "The transmuter contract in get_share_denom get_alloyed_denom in line 510. includes two queriable functions that are eectively identical: and contracts/transmuter/src/contract.rs:499 Although not a security issue, having redundant code is unnecessary and can decrease maintainability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Lack of limiters could result in uncontrolled pool imbalance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "The transmuter contract enforces a 1-1 relation between its pool assets. The limiter feature is in place to avoid swift liquidity imbalances happening when specic market conditions open arbitrage opportunities. However, there is no minimum amount of limiters required. Upon instantiation, no limiter is created, which could be intended to facilitate a fast initial liquidity provision. From that on, the lack of a limiter, or a malicious admin removing all the in limiters deregister_limiter function through the contracts/transmuter/src/contract.rs:120-190, open up unlimited arbitrage opportunities that may imbalance the pools to an undesirable level.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Lack of role-based access controls for the pausing mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Default value conceals unexpected state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "In the contracts/transmuter/src/limiter/division.rs:310-316, compressed_moving_average function manages cases where result computation is infeasible. This arises when the time span in focus has a length of zero, occurring when block time matches the start time of the earliest division remaining post-pruning. However, such a division must not exist since the average is computed prior to the division set update. The function currently defaults to returning zero, masking a potential issue with division updates. While this is not a security concern, maintaining an accurate state aids in the early identication and resolution of any unexpected states.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Incorrect error message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "The transmuter contracts exit_pool function checks if the provided token_out coins are part of the pool. it raises an incorrect If one of the assets is not part of the pool, InsufficientPoolAsset error instead of InvalidPoolAssetDenom. Although not a security risk, incorrect or non-descriptive errors may mislead users.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Typographical error in attribute naming", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "The response for the transfer_admin entry point response carries attributes \"method\" and \"andidate\", dened in contracts/transmuter/src/contract.rs:777-779. Presumably, \"candidate\" was the intended name. logging, auditability, and Within CosmWasm, attributes play important interoperability. A typographical mistake might lead o-chain components or other modules to miss events. roles in event", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Unused error messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "In contracts/transmuter/src/error.rs, several error messages are dened but remain unused, specically:  InvalidPoolAssetDenom (see Incorrect error message)  FundsMismatchTokenIn", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Usage of panics for error handling", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "has been macro It contracts/transmuted/src/limiter/limiters.rs:154 for mechanism. expect noticed that the is used in the error handling The usage of expect is generally discouraged because it leads to panics without a developer-friendly error message. expect also causes the wasm execution to abort, which does not allow handling of the error from calling functions.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Usage of vulnerable dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf", "body": "It was found that vulnerabilities. As https://rustsec.org/advisories/RUSTSEC-2023-0052, crates are aected by issues of high impact. the codebase uses dependencies utilizing packages with known reported in https://rustsec.org/advisories/RUSTSEC-2022-0093 and the ed25519-dalek and webpki These vulnerabilities are not directly exploitable in a CosmWasm smart contract and do not aect any of the current code fragments. Therefore this issue has been raised with informational severity for completeness.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Corrupted assets may not be removed when liquidity reaches zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "The transmuter contracts specication states that corrupted assets should be removed from the contract when liquidity is zero. This is done when all the corrupted assets are redeemed at the same time in contracts/transmuter/src/swap.rs:267-276, but not in any other cases such as pool exits and transmutes during unchecked_exit_pool in and contracts/transmuter/src/transmuter_pool/exit_pool.rs:12-43 in update_pool_assets contracts/transmuter/src/transmuter_pool/transmute.rs:38-75. Note that the current implementation does not have any other way of removing corrupted assets from the pool.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Resetting change limiters creates an opportunity window for economic attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "In contracts/transmuter/src/contract.rs:225-228, the states of all change limiters are reset. This is done when new assets are added because weights are no longer correct and should be recalculated. However, change limiters implement protection from rapid market changes and pool imbalances. Removing them, even temporarily, creates an opportunity window for economic attacks. A malicious party capable of joining the pool with a large position can simply listen to the contracts on-chain events and deploy the attack as soon as new assets are added.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Incorrect spot price calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "spot_price in a The contracts/transmuter/src/contract.rs:673. This is incorrect as the assets in the pool can have dierent normalization factors, resulting in prices other than 1. Decimal:one() function returns value xed of We classify this issue as minor because the aected function does not impact the logic of the contract, as it is exclusively used in a query. However, note that it could have a severe impact on external contracts relying on this information. This issue was independently reported by the Osmosis team during the audit.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Outdated libraries with known vulnerabilities in use", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "The transmuter contract makes use of outdated libraries that contain known vulnerabilities. Although we did not nd these vulnerabilities to be exploitable in the current codebase, updates to the codebase may lead to security risks in the future. The following libraries are aected:  sylvia 0.7.0  Aected by RUSTSEC-2024-0012  cosmwasm-std 1.3.1  Aected by CWA-2024-002", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Alloyed asset normalization factor lacks validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "in The contracts/transmuter/src/alloyed_asset.rs:67-73 saves the normalization set_normalizaton_factor function factor for the alloyed asset. However, this value does not undergo any validation as opposed to the normalization factor of the pool assets. If, by mistake, a value of zero is assigned to the normalization factor of the alloyed asset the features that operate with the alloyed asset will error, making them unusable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. ChangeLimiter missing validation upon update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "set_change_limiter_boundary_offset The in contracts/transmuter/src/limiter/limiters.rs:416-447 does not validate the boundary_offset value through ensure_boundary_offset_constrain before saving it. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Migration lacks validation steps", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "add_normalization_factor_to_pool_assets in The the contracts/transmuter/src/migrations/v3_0_0.rs:67-73 set_alloyed_asset_normalization_factor function in lines 113-121 save the normalization factor for the alloyed asset and the pool assets upon migration. However, these values do not undergo any validation. function and If a value of zero is mistakenly assigned to the assets' normalization factor, most of the main features would become unusable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Adminship can be renounced, leading to inability to maintain the protocol", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "The transmuter contract in contracts/transmuter/src/contract.rs:776-785, which leaves the contract without any address holding admin privileges. implements a renounce_adminship entry point Given that several functions needed for the correct long-term operation of the contract are restricted to the admin address only, it will not be possible to maintain the protocol if the adminship is dropped at any point. We classify this issue as minor since it can only be caused by the admin, who is a trusted entity.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Outdated documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "The transmuter contract restricts access to its set_active_status function to moderator users only, following security best practices. However, the access control table in the repositorys README.md le incorrectly states that this function should be restricted to admin users only.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Instantiation without a moderator is allowed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "contracts/transmuter/src/contract.rs:81, In instantiation is parameterized by an optional address for the moderator. the transmuter contract The moderator role is responsible for pausing the contract if any security issue arises and marking assets as corrupt. There are other ways to pause the contract, either by governance or by the admin, but they are less straightforward and potentially slower to react. Specically, governance would need to pass the proposal, which takes time. On the other hand, the admin would need to grant itself moderator privileges rst, and this is one more step that can count in critical scenarios. As a consequence, the contract would ideally not allow a conguration with the moderator set to None.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Miscellaneous performance optimizations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "The codebase contains minor ineciencies that aect performance and hence gas costs:  In contracts/transmuter/src/transmuter_pool/add_new_assets.rs:9- 10, the assets vector is checked for duplicates rst, and then its length is checked for being below the limit. However, duplicate search is a more computationally intensive operation and should be performed after the more ecient length check.  In contracts/transmuter/src/transmuter_pool/corrupted_assets.rs: 91, the pool_assets vector is iterated to discover any corrupted assets. If such has not been found, the control ow prematurely returns. Then, in lines 97-101, the same vector is iterated again to lter corrupted assets and construct a HashMap. Redundant iteration could be avoided by performing the check between the ltering and creating the HashMap.  In contracts/transmuter/src/swap.rs:431, the code responsible for checking if token_out.denom diers from token_in.denom is not necessary as two lines later, during the execution of the swap_variant function, the same check is performed as well.  In contracts/transmuter/src/swap.rs:498, the code responsible for checking if token_out.denom diers from token_in.denom is not necessary, as two lines later, during the execution of the swap_variant function, the same check is performed as well.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Missing current status validation during updates may mislead users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "contracts/transmuter/src/contract.rs:456, the set_active_status In function, in sudo contracts/transmuter/src/sudo.rs:48, no validation ensures that the current and updated statuses are not equal. SetActive message well as as information will be emitted stating that the Consequently, even if these values are equal, status has been changed. This might be misleading and may even have a security impact on contract management during an incident.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Unused code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf", "body": "The codebase contains unused code, which may indicate that the logic has changed or that assumptions do not match the current implementation. Instances of unused code have been found as follows:  SingleTokenExpected error in contracts/transmuter/src/error.rs:24  InvalidTokenInAmount in error contracts/transmuter/src/error.rs:80  UnexpectedDenom error in contracts/transmuter/src/error.rs:100", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Using non-prexed addresses in storage keys can lead to key collisions, allowing exploits to overwrite data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The key returned by the GetTokenizeShareRecordIdByOwnerAndIdKey function in x/staking/types/keys.go contains an address that length prexed. Since addresses could have variable lengths, key collisions are possible if the storage key contains a non-prexed address followed by another component. This could lead to accidental collisions and could be exploited by an attacker to deliberately overwrite existing data at a target storage location. is not", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Tokenization of a delegation and selling the shares allows evasion of slashes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "a is the in no delegation in When tokenized x/staking/keeper/msg_server.go, or Redelegation entry is created, but the current delegation is immediately unbonded and a new delegation the from the module TokenizeShareRecord. This implies that the previous delegator will not be subject to slashing for infractions that happened before the tokenization. Instead, slashes are now applied to the module address associated with the TokenizeShareRecord. UnbondingDelegationEntry TokenizeShares associated with function address created is Since Cosmos SDK applies slashes for past infractions to all currently bonded tokens, this is not an issue, as long as the previous delegator owns the created share tokens. The previous delegator might have an incentive though to sell share tokens quickly if they are aware of a pending slashing event. If there is information asymmetry between the share token holder and a potential buyer, a delegator can use this mechanism to evade slashing. An example of this could be a validator that equivocated but has not published the double-signed block. Rational buyers would therefore not buy any token shares before the UnbondingTime passed but not all buyers can be assumed to be rational. We consider this issue to be major, because it can be used to circumvent one of the fundamental features of proof of stake blockchains.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Withdrawal of tokenized share record rewards is unbounded, owner can be grieved by an attacker", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "WithdrawTokenizeShareRecordReward The in x/distribution/keeper/keeper.go contains an unbounded iteration over all TokenizeShareRecord of an owner, which may run out of gas if too many entries exist. This may happen unintentionally. function Even worse, since it is possible to transfer ownership of a record to any other address, an attacker can create many low-value TokenizeShareRecords and transfer ownership of them to relevant the TokenizeShareRecords to another account to resolve this issue, it allows the attacker to grieve the owner. owner. While transfer owner target target can a The same issue exists in the TokenizeShareRecordReward query function in x/distribution/keeper/grpc_query.go.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Several errors are not checked", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "In several places in the codebase, errors are not checked, and execution continues even if operations failed. This may cause an inconsistent state  a message handler may succeed and write changes to storage even though some operations failed. Instances of not checked errors are in: a) x/distribution/module.go:73: Error return value types.RegisterQueryHandlerClient is not checked b) x/distribution/module.go:146: Error return value cfg.RegisterMigration is not checked c) x/distribution/types/msg.go:183: sdk.AccAddressFromBech32 is not checked Error return value d) x/staking/genesis.go:43: Error return value keeper.SetValidatorByConsAddr is not checked e) x/staking/module.go:79: return types.RegisterQueryHandlerClient is not checked Error value of of of of of f) x/staking/module.go:143: Error return value of cfg.RegisterMigration is not checked g) x/distribution/types/msg.go:183: Error return value sdk.AccAddressFromBech32 is not checked h) x/staking/keeper/msg_server.go:100: k.SetValidatorByConsAddr is not checked i) x/staking/keeper/msg_server.go:457: k.ValidateUnbondAmount is not checked j) x/staking/keeper/msg_server.go:477: k.AddTokenizeShareRecord is not checked k) x/staking/keeper/msg_server.go:550: k.DeleteTokenizeShareRecord is not checked m) x/staking/types/msg.go:380: l) x/staking/keeper/msg_server.go:598: sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked n) x/staking/types/msg.go:414: Error return value Error return value Error return value Error return value Error return value return value return value of of of of of of of of o) x/staking/types/msg.go:442: Error sdk.AccAddressFromBech32 is not checked return value of p) x/slashing/genesis.go:19: Error return value of keeper.AddPubkey is not checked q) x/slashing/module.go:81: Error return value of types.RegisterQueryHandlerClient is not checked r) x/slashing/module.go:144: Error return value of cfg.RegisterMigration is not checked s) x/slashing/keeper/hooks.go:35: Error return value of k.AddPubkey is not checked t) x/slashing/keeper/hooks.go:69: Error return value of h.k.AfterValidatorCreated is not checked", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Tokenize share record reward query does not include automatically withdrawn rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "TokenizeShareRecordReward The x/distribution/keeper/grpc_query.go does withdrawn rewards that have been sent to the TokenizeShareRecords module account. in automatically query not function account for", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Share token denoms may be all lower- or all upper-cased, depending on user input", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The getShareTokenDenom function in x/staking/keeper/msg_server.go creates the denom for new share tokens through concatenation of the user-supplied validator address and a unique ID. The validator address is taken without transformations from the users input. Since Bech32 addresses are valid in either all upper or all lower case, there can be two valid denoms for the same share tokens. While this has not been found to cause any security issues in the current implementation, it may create problems for applications integrating with this module or lead to issues when further logic is added in the future.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Usage of panics for control ow is bad practice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "In several places in the codebase, panics are used for control ow. While this is no security issue since transactions recover from panics in Cosmos SDK, this may lead to problems in the future. For example, a caller of keeper functions may try to handle errors, while the function panics instead. Instances of panic usage for control ow can be found in: a) x/distribution/keeper/allocation.go:33 b) x/distribution/keeper/delegation.go:35, 40, 48 and 127 c) x/distribution/keeper/hooks.go:50 and 97 d) x/distribution/keeper/invariants.go:87 e) x/distribution/keeper/keeper.go:38 f) x/distribution/keeper/store.go:51 and 70 g) x/distribution/keeper/validator.go:70, 80 and 92 h) x/distribution/types/keys.go:65, 79, 94, 108, 122 and 136 i) x/distribution/types/msg.go:35, 72, 107 and 146 j) x/slashing/keeper/infractions.go:19 and 25 k) x/slashing/keeper/signing_info.go:109, 121 and 125 l) x/slashing/types/msg.go:28 m) x/staking/keeper/alias_functions.go:68 n) x/staking/keeper/delegation.go:96, 108, 202, 208, 219, 225, 400, 407, 411, 459, 464, 468, 574, 582, 593, 614 and 717 o) x/staking/keeper/invariants.go:63 and 106 p) x/staking/keeper/keeper.go:42, 46 and 67 q) x/staking/keeper/pool.go:23 and 31 r) x/staking/keeper/querier.go:493, 497 and 502 s) x/staking/keeper/query_utils.go:26, 47, 112 and 116 t) x/staking/keeper/slash.go:29, 54, 70, 128, 132, 135, 208, 251, 256, 259, 271, 276, 287, 292 and 296 u) x/staking/keeper/val_state_change.go:30, 41, 45, 67, 71, 75, 139, 165, 233, 241, 249, 258, 267, 278 and 319 v) x/staking/keeper/validator.go:29, 50, 158, 162, 167, 316, 414, 427, 431 and 435 w) x/staking/types/authz.go:44 x) x/staking/types/delegation.go:51, 66, 73, 151 and 246 y) x/staking/types/historical_info.go:33 z) x/staking/types/keys.go:96 aa) x/staking/types/msg.go:75, 80, 179, 236, 290 and 345 bb) cc) x/staking/types/validator.go:154, 262, 276, 381, 396, 400, 426 and 466 x/staking/types/params.go:94", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Addresses are not properly validated, which may cause panics and unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "This validation. The ValidateBasic method, in x/distribution/types/msg.go:47, includes basic address the DelegatorAddress or the WithdrawAddress provided is empty, but does not validate whether if msg.DelegatorAddress=' ', this check would not return an error, producing further panics and expected behavior. is a correctly formatted Bech32 string. As an example, validation only and raises the input checks error an if", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Dierent tokens for share records of the same validator can have dierent exchange rates after slashing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The staking module creates distinct TokenizeShareRecords whenever a user tokenizes a delegation. These share records have all unique denoms, and their tokens are not fungible with each other, even if the validator is the same. While this simplies the architecture of the module, it implies that the exchange rate between such records starts to diverge over time, specically when tokens are minted after slashing occured. The reason for this is that during the TokenizeShares function in x/staking/keeper/msg_server.go:454, shares are minted without considering the current exchange rate of previous share records. As an example, suppose 1000 ATOM are delegated, of which 500 ATOM are tokenized in record 1. There exist now 500 val...1 tokens. Now suppose a 10% slash happens, such that there are only 900 ATOM in the delegation, and the 500 val...1 tokens are only worth 450 ATOM. If now another 200 ATOM of the same delegation are tokenized in record 2, there will be 200 val...2 tokens. As a result: - - val...1 tokens have an exchange rate of 0.9 ATOM/val...1, while val...2 tokens have an exchange rate of 1 ATOM/val...2. This is not a direct security concern, but may confuse users and lead to problems if protocols built on top of the Liquidity Staking Cosmos SDK module do not consider these dierences properly.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Staking rewards are decoupled from share token holders", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The current architecture separates holders of a tokenized delegation and the recipient of rewards for that delegation. A holder of share record tokens is not eligible for any rewards, instead these rewards accumulate in one single account per tokenized share record. The reward recipient is specied as the TokenizedShareOwner in the TokenizeShares function. It can be transferred using the TransferTokenizeShareRecord function. While this is not a security concern, it may be unexpected that share record tokens do not contain eligibility for rewards.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Lack of event emission is bad practice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "TokenizeShares, The TransferTokenizeShareRecord message handlers in x/staking/keeper/msg_server.go do currently not emit any events. The Unjail message handler in x/slashing/keeper/msg_server.go does emit an event, but does not include information about the action (unjailing). RedeemTokens and Emitting events is a best practice, since it allows o-chain subscribers/indexers to track events.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Tokenized share record related transactions and queries are only available via CLI, not REST", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "Transaction and query functionality for tokenized share records have been added to the CLI in x/distribution/client/cli/tx.go, x/distribution/client/cli/query.go, x/staking/client/cli/tx.go and x/staking/client/cli/query.go, but not to the x/distribution/client/rest/tx.go, x/distribution/client/rest/query.go, x/staking/client/rest/tx.go and x/staking/client/rest/query.go. interfaces REST in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Storing the Id in TokenizeShareRecord is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The TokenizeShareRecord contains the Id of the record. That is unnecessary since every lookup of the record implies that the ID is known, since its part of the key.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Storing the ShareTokenDenom in TokenizeShareRecord is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The TokenizeShareRecord contains the ShareTokenDenom of is unnecessary, since the ShareTokenDenom can be derived from the stored Validator and Id. the record. That", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Specication is outdated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The specication is outdated in several ways: a) x/staking/spec/01_state.md is missing an entry for 0x64 for LastTokenizeShareRecordIdKey. b) x/staking/spec/* still describes queues, which have been removeg from the module.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unused code negatively impacts maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The code base contains unused code. Unused code increases the code size and hence inhibits maintainability. Instances of unused code are: a) The NewStakeAuthorization function in x/staking/types/authz.go. b) The AllInvariants function in x/distribution/keeper/invariants.go. c) The AllInvariants function in x/staking/keeper/invariants.go. d) The ValidatePowerReduction function in x/staking/types/params.go.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Users are unable to withdraw funds once admin deposited all funds in the Red Bank", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "on In the Lockdrop contract, users are able to withdraw funds as long as it's under the congured withdrawal timeline. The withdrawal function will decrease the contracts total locked UST amount based (contracts/lockdrop/src/contract.rs:395). Once the admin deposits all funds to the Red Bank via DepositUstInRedBank, the contracts total locked UST will be set to 0 (L791). Since it only accounts for the deposit timeline instead of the withdrawal timeline (L465-472), users will be unable to withdraw their locked funds even if the withdrawal window is still open. withdrawal user's the We set the severity to Major since the users funds are still recoverable after a certain timeline.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Malicious users can cheat lockup rewards without locking their funds if claim is enabled before withdrawal timeline", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "condition In the Lockdrop contract, users can execute ClaimRewardsAndUnlock to claim rewards in the enabled (contracts/lockdrop/src/contract.rs:686-688). Claims can only be enabled from the Auction contract via AddLiquidityToAstroportPool which accounts in deposit and itself the windows (contracts/auction/src/contract.rs:440-445). withdrawal contract Auction claims only that are for Since both Auction and Lockdrop contracts are independently initialized, theres a possibility that admin might enable claims during the deposit or withdrawal phase of Lockdrop contract. If this happens, a malicious user can potentially cheat the lockup rewards via an attack scenario below: 1. Execute DepositUst to deposit a large amount of funds into any lockup position 2. Claim ClaimRewardsAndUnlock executing rewards via with lockup_to_unlock_duration_option as None 3. contracts/lockdrop/src/contract.rs:703-715, enter In calculate_mars_incentives_for_lockup internal function. Notice that lockup_info.ust_locked variable will be used to calculate users position rewards via calculate_weight. code will 4. Due to the code logic that only updates users MARS rewards when its 0, user_info.total_mars_incentives will not be updated in the future (contracts/lockdrop/src/contract.rs:704). The malicious user will have a denite reward. 5. Execute WithdrawUst to remove all funds locked under that lockup position (funds that can be removed highly depends on window timeline). In L382, the corresponding locked UST amount will decrease, however, the users MARS rewards will still remain the same. We set the severity to minor since this will only be exploitable if the timeline is congured incorrectly/far between Lockdrop and Auction contract which will inuence the execution of EnableClaims.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Users that claimed airdrops will miss out on additional airdrops", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "The current implementation of airdrop claims allows only one claim per user due to the the condition in contracts/airdrop/src/contract.rs:326. At contract owner has the ability to update Merkle roots in L198-200. Taken together, if a user was assigned additional airdrops, they would not be able to claim those additional airdrops. Even without an update, the current design does not allow a user to claim multiple airdrop leaves from the same Merkle tree. the same time,", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing validation on Cong parameters can lead to human errors and unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "The Auction, Lockdrop, and LP Staking contracts are missing validation checks in some of its Cong numerical values. For example, in contracts/auction/src/contract.rs:61, there is no check that msg.init_timestamp corresponds to a future value (i.e. msg.init_timestamp>= env.block.time). in lockdrop/src/contract.rs:45. validation Lockdrop contract present This the in is example An contracts/lp_staking/src/contract.rs:37-39, init_timestamp + cycle_duration <= till_timestamp. Staking the LP in contract in there is no validation that that is Examples of missing validation checks in the Lockdrop contract are:  No validation that there are repeated values in msg.lockup_durations in line 67  No check that msg.seconds_per_duration_unit is non-zero. Examples of missing validation checks in the Auction contract are:  No check that config.mars_vesting_duration is non-zero, which would cause division by zero error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing MARS rewards validation may cause auction participants to lose their deserved rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "In the Auction contract, anyone can deposit MARS to increase the overall reward for users via If no one deposited any MARS token rewards before the IncreaseMarsIncentives. is not possible to continue admin executed AddLiquidityToAstroportPool, depositing minted tokens (contracts/auction/src/contract.rs:199-L203). This would cause auction participants to receive zero Mars token rewards in return for their MARS token delegation. it token already shares MARS due LP to", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Querying the state of the contract may return false information", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "In the LP staking contract, in lines lp_staking/src/contracts.rs:315-352, there is a max function that takes the timestamp provided by the user and the current timestamp. Therefore, if the user-provided timestamp is in the past, the returned information will be false, as it will correspond to the current timestamp. If the user, which can be a 3rd party protocol, relies on this query to do further calculations, this might cause unintended consequences.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Typo in variable names might cause errors in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "In the Lockdrop contract, contracts/lockdrop/src/contract.rs:832, there is a typo in the variable xmars_accured, which may cause development errors in the future.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Overow checks not set for most packages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "The following Cargo.toml les do not enable overow-checks for the release prole:  packages/mars-periphery/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/auction/Cargo.toml  contracts/lockdrop/Cargo.toml  contracts/lockdrop/Cargo.toml", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. getAllPrivate function incorrectly returns public capabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/CapabilityProxy.cdc:62-64, the getAllPrivate function returns all capabilities stored in the self.publicCapabilities dictionary. This is incorrect because the function should return all private capabilities instead of public ones. Consequently, the function will always return incorrect types of capabilities. We classify this issue as major because it aects the correct functioning of the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Deny list lter allows retrieving invalid capabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/CapabilityFilter.cdc:44, the allowed function returns true when the capability cannot be borrowed. This is problematic because a malicious parent account can store invalid capabilities and use them once the underlying resource becomes borrowable. Consequently, this allows the parent account to bypass the lter restrictions created by the child account. to the appendix to reproduce the issue. While the provided test case Please refer demonstrates a situation in which the parent account can bypass the manager capability lter, this issue can similarly lead to bypassing the capability lter in the proxy account.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Capabilities are not checked to be valid", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In several instances of the codebase, capabilities are not validated to be borrowable before storing them. The following code locations should have the capability validated:  addCapability function in contracts/CapabilityProxy.cdc:87-94.  Initialization phase in contracts/HybridCustody.cdc:354 where the filter is not nil.  setManagerCapabilityFilter contracts/HybridCustody.cdc:418 managerCapabilityFilter is not nil. function where in the Consequently, the capabilities might fail to borrow the underlying resource reference when used, which is inecient.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Replaying publishToParent causes the ProxyAccount resource to be overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:593, no validation ensures the publishToParent function is not called towards the same parent address more than once. If the function was called twice for the same parent address, the old ProxyAccount resource will be removed, the as seen in line 621. This is inecient because the child account should call removeParent function to overwrite an existing parent.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Potential incorrect owner query before ownership acceptance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "the giveOwnership function sets the In contracts/HybridCustody.cdc:707, acctOwner to the recipient to indicate they own this child account. However, there is a possibility that the recipient does not claim the published capability from the child's account. Consequently, the getOwner function in line 690 would still show the account owner is the recipient, which is incorrect.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Removing nonexistent capabilities emits events", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "the removeType In contracts/CapabilityFilter.cdc:34-37 and lines 72-75, function removes the capability from the dictionary without checking its existence. This is problematic because the FilterUpdated event would be emitted accordingly to indicate the capability is inactive, which is incorrect. After all, the capability was never added before.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Transferring ownership does not emit an AccountUpdated event", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:327-333, the giveOwnerShip function calls the child account to transfer ownership to another user. However, the AccountUpdated event is not emitted to notify event listeners that there is a change in the owned account.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Unlinking the public proxy account resource path is unnecessary", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:672, the removeParent function unlinks the public path for the proxy account identier. This is unnecessary because public paths are not linked during the creation of the proxy account resource.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Named parameters are not used for known functionalities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:801, the display metadata view is stored in a dictionary with a hardcoded key display. Since the eld and the functionality is already known, hardcoding the parameter can be avoided.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Duplicate function can be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "the getAddresses function performs the In contracts/HybridCustody.cdc:279, same action as getChildAddresses. This is inecient because calling both functions returns the same functionality and result.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Default manager capability lter cannot be updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:223, the filter variable acts as a default lter value passed to any newly added child account. Since the manager resource owner cannot modify calling the setManagerCapabilityFilter again. This can easily get complicated when the number of child accounts increases. this, any new lter to add requires the manager intends", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Codebase readability can be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "The readability of contracts/HybridCustody.cdc: the project can be further improved in the following contexts in 1. The variable and function names used to denote the type of account are inconsistent across the contract. Some of them can be useful when referenced within the context it is dened but results in reduced readability in general. Consider explicitly naming the account types and identiers and keeping them consistent across the contract. For example, lines 211 and 363 use both childAccount and account to specify a child account. In this case, explicitly calling out the child's account can improve readability. 2. The seal and removeOwned functions do not sound as cautious as they need to be, possibly causing their impact to be undermined. Consider making their importance more explicit in addition to the comments already given in the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. addFactory function overwrites existing types", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/CapabilityFactory.cdc:17, the function addFactory doesnt check if the type that is being added already exists or not. If the type to be added already exists, it may be overwritten by mistake.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Outstanding TODO comments in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In several TODO. This decreases the readability of the codebase. instances of the codebase, many unimplemented functionalities are marked as", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Users existing balance will be inaccessible if UpdateAccounts is called with a new denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:694-703, a users existing balance will be overwritten when the denom in the BatchUpdateRequest is not found in previously stored balances. This is caused by not including the existing balance when adding a new balance in line 721. Consequently, balances with denoms that were sent previously will be stuck in the contract. A test case demonstrating the above scenario can be found in appendix 2.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Fee denom deposited by user will be inaccessible if excluded from conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:332-347, platform funds sent by the user will not be included as deposited funds. This is problematic since there is no validation that platform funds must be included in the allowed funds vector. As a result, users that deposit platform funds would not have their account balance updated, leading to a loss of funds. A test case demonstrating the above scenario can be found in appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Migration might fail due to out of gas error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/contract.rs:183-187, the for loop tries to process all launchers stored inside the contract. Since launchers are unbounded and cannot be removed, sooner or later the launchers' storage might grow too big to process. Consequently, this might cause the migration transaction to fail due to an out of gas error. We classify this issue as minor since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Incorrect deposit history will be logged when users deposit into a prefund", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:364-373, the deposit history of users that deposited into a prefund will be incorrect. Firstly, the launcher_id value is hardcoded to None in the FundingHistory although the user deposits to a prefund in line 246. Secondly, history will be empty because it is ignored, see lines 332 to 347. if config.fee_denom is not included in config.denoms vector, the deposit Thirdly, the deposit history will record the user's deposit to be lower than intended due to double platform fee deduction if the config.fee_denom is included in config.denoms vector (see lines 295-300 and 332-336). In result, deposit_history value as seen in contracts/account/src/queries.rs:72. this would cause the Investor query message to return an incorrect The above scenarios can be demonstrated with test cases which can be found in appendix 3.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Guaranteed allocation size might be incorrectly overwritten when updating congurations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "to the contracts/prefund/src/commands.rs:80-94, In of state.guaranteed_allocation_size is forcefully updated even if there's no valid update If guaranteed_allocation_size is instantiated to contain a valid Some value and one of the admins decides to update congurations that aren't related to it (e.g. the name or description), the value of guaranteed_allocation_size will be overwritten to None in line 93. As a result, return an incorrect value in contracts/prefund/src/queries.rs:46. the State query message will max_participants corresponding value. value the A test case demonstrating the above scenario can be found in appendix 4. that leads possible scenario the Another when guaranteed_allocation_size the updated_config.total_tokens_for_sale case, has updated_config.max_particpants state.guranteed_allocation_size is set to None whilst its value should get updated to the new value of total_tokens_for_sale. is a None value while has a incorrect value. Some value that an to of In", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Missing logical validations might cause unexpected outcomes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In the prefund contract, there are several cong values that are currently not validated. For example, the value of msg.end_date should be greater than msg.start_date and the value of msg.max_prefund should be greater than msg.min_prefund. If any of these values are congured incorrectly, it would cause the contract to be unusable. For example, try_allocate in function the contracts/prefund/src/commands.rs:123-129 if msg.start_date is greater than msg.end_date. would fail", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Missing address validations might lead to failures of execution handlers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In the prefund contract, there are addresses in cong values that are not validated before storing. Incorrect addresses would lead to issues when executing functions such as the prefund whitelist_contract. This issue exists during both the instantiation of contract in contracts/prefund/src/contract.rs:46-69 and updates to the cong in contracts/prefund/src/commands.rs:43-78.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. try_update_accounts allows arbitrary balance updates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:666, the admins are able to increase any existing investors balance without any restriction limit. The team states that the amount of allocation is determined by their own Atlo rating which is calculated via an o-chain script. Since theres no validation in place (e.g. verifying the investor did invest into the prefund or making sure the refund amount lower than the deposited amount), a miscalculation in the script might cause the investor to get more/less tokens than intended. is equal to or", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Lowercasing denoms will cause issues with IBC tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs, there are several instances where token denoms are converted to lowercase via to_lowercase. Since token denoms are case sensitive, the contract will be unable to support IBC tokens.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Prefund deposit amount needs to be greater than intended", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:333-316, users deposited funds are deducted twice even though they have already been deducted in lines 295 to 300. This causes an unnecessary requirement that the prefund deposit amount must be greater by twice the value of platform fees. There might be a possibility that the users deposit is rejected due to insucient funds.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Possibility of duplicate denoms in conguration is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/contract.rs:43, denoms are added into the cong during contract instantiation phase. If the admin decides to add custom denoms via passing a valid msg.denoms vector, the corresponding denoms function will not remove duplicate denominations from the vector. Consequently, there is a possibility that the same denom is added twice to the config.denoms vector, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Users can deposit into inactive/ended launchers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In the accounts contract, a value is stored to keep track in which state the launcher is. However, the launchers state does not get automatically updated nor does it get used to validate whether the given launcher id should receive investments or not. Hence, an investor may invest in a launcher that has ended, which would lead to a failure when allocating the funds, because the prefund contract checks for the end_date. To resolve this issue, the admin would need to withdraw funds from the prefund contracts individually.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. PeriodicVesting is unintendedly releasing tokens to users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "In vesting:src/msg.rs:117-138, the vested amount of tokens that is ready to be redeemed by the user is calculated using a PeriodicVesting schedule. It is supposed to calculate the current number of elapsed intervals since start_time in order to compute the total amount of vested tokens. As demonstrated in the test case in Appendix 1, the code is not calculating the correct vested tokens though, which leads to the following problems:  At start_time, the user can already redeem the rst tranche of tokens, even if no interval has elapsed.  The user gets a token tranche more than expected at the end of the vesting period.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. LOCKINGADDRESS is never populated which will block rebasing functionality", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "The handle_lock_nft function in locking:src/contract.rs:256-266 does not store the locking address to LOCKINGADDRESS. The function creates a mutable vector of addresses from LOCKINGADDRESS where it pushes the senders address but the address is never saved to LOCKINGADDRESS. This results in the map never being populated, which will highly impact other functionality in the contract such as the calculate_rebase_reward function that performs a rebase.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Multiple rounding issues may cause zero rewards being distributed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "functions of Several the locking contract are aected by rounding issues since their mathematical operations use U128 integers for divisions where the numerator is smaller than the denominator. This causes the result to be truncated to zero instead of the desired ratio before it is multiplied, causing the whole operation to be zero. Therefore, reward distribution will result in a zero tokens distribution. In particular in the The aected operations can be found on rewards related features. calculate_bribe_reward, and calculate_surplus_reward functions. The aected instances can be found at and locking:src/contract.rs:770, locking:src/query.rs:322. calculate_rebase_reward 870, 888, 904, 919,", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Unbounded iterations may cause calculate_rebase_reward to run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "The calculate_rebase_reward function in locking:src/contract.rs:798 performs an unbounded iteration over all entries in LOCKINGADDRESS, and then for each address in LOCKINGADDRESS it will iterate through all vtokens for the gov_token_denom. Both VTOKENS and LOCKINGADDRESS are unbounded and have the potential to grow large with time and normal use. In addition, as mentioned in the nding LOCKINGADDRESS entries are never removed which may introduce state bloat, LOCKINGADDRESS can never be reduced, exacerbating this issue. The impact of this issue is that the rebasing functionality of the contract could become blocked for a specic app_id.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Lack of pool status validation in claim function leads to a race between underwriters to withdraw and insurees to claim funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The claim function in src/contract.rs:251 does not perform a check to ensure that the pool is not in a closed state. If the pool status is closed and a hack/default event occurs, swaps can still be performed. Insurees will only claim if the payout amount is bigger than the value of the covered token. Rational underwriters will anticipate that, and rush to withdraw liquidity to maximize their return. Rational insurees will anticipate that rush, and try to claim as fast as possible. This race can lower trust in the protocol, but will eventually put users to a disadvantage that act slower than others.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Wrong payout calculation may lead to last claiming insurees not being able to claim", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The calculation of payout in the claim function in src/contract.rs:302 uses the default_ratio rather than the payout_ratio. This is dierent from the calculation of the capacity in line 476 and may result in the last insuree trying to swap running into out-of-funds errors.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Owner may update default ratio to prevent claims from being made", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "default_ratio, payout_ratio, and expiration are updatable variables that are used to determine whether or not the default event occurred in src/contract.rs:288, how much to pay out in 288, and whether the pool is closed in line 512-514. If the owner account was compromised or the owner simply wanted to control whether claims should be possible and what height they should have, they could update these values, aecting any users that have not claimed yet.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Lack of validation of state parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The instantiate and update_config functions in src/contract.rs:28 and 408 lack validation of the following parameters:  expiration: If set to a time in the past, this will cause the next invocation of check_if_at_status to transition the pool status to closed.  payout_ratio: If set to zero, the next invocation of the purchase would attempt to divide by zero in line 476 while attempting to calculate the total_capicity, which would cause a panic.  price (validated in the instantiate, but not in the update_config function): If set to zero, the purchase function would panic in line 220. A price of more than one would economically not make much sense.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Pool may be congured with an incorrect credit token", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The InstantiateMsg struct in src/msg.rs:11 denes credit_token with a type of Addr, which is then stored without validation in src/contract.rs:70. This allows instantiation of a pool with an invalid credit token address, which may only be detected when claims happen after a hack/default.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Owner may update parameters that can negatively impact users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The update_config function in src/contract.rs:408-439 allows the owner to update the following values:  price  expiration  default_ratio  payout_ratio Any underwriters that provide liquidity to the pool at the time of such a change would be subject to these changes, but they have no way to withdraw the pool if the values change to their disadvantage. This disincentivizes underwriters from entering the pool in the rst place, and also adds to centralization of the protocol. We classify this nding as minor because only the owner can make these changes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Claim payout attribute value is missing tax deduction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The payout attribute in the claim function in src/msg.rs:324 contains the pre-tax payout value. This value will be dierent from the amount that is actually sent after deducting the tax.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of validation of Cw20ReceiveMsg msg can surprise users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The claim function in src/contract.rs:255 receives a Cw20ReceiveMsg but does not match/use the contained msg. This means that the contract will execute a claim regardless of the received message. This goes against user expectations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Default state assessment of protocols added in the future may be subject to manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The audited smart contract only supports protection against drops in the Anchor exchange rate. That exchange rate can only be manipulated by an attacker that is a validator and deliberately gets slashed. Future extensions of the protocol might support insurance of tokens from other protocols though, with default conditions that may be subject to manipulation. In the past, many exploits of protocols were based on manipulation of spot prices, which is a concern for the Risk Harbor protocol. Even though this issue does not aect the current iteration of Risk Harbor, we still classify it as minor since it poses a potential risk of a future iteration.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Hard-coded Anchor market address decreases exibility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The calculation of the redemption_ratio in src/contract.rs:285 uses a hard-coded (currently placeholder) address for the Anchor market contract. This decreases the exibility of the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Selective usage of CW20 features may lead to wrong user expectations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "The contract selectively imports and uses code from the CW20 reference implementation. At the same time, the contract does not expose all of the CW20 execution and query message entry points. Depending on the frontend users are using, bought coverage might show up as a CW20 token to the user, but functionality such as transferring, sending, or burning those this selective usage of CW20 code increases the tokens is not available. Moreover, complexity of the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Lack of validation of pool name length may have adverse consequences", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf", "body": "the stores contract The in src/contract.rs:38-49. The CW20_base crate performs a validation check to ensure that the token name adheres to the expected format and returns an error if this condition is not met. the CW20 format token using base info Using too long names might have adverse consequences, for example for user interfaces that expect limited token names.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Front-running audience creation opens phishing and other risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf", "body": "The aud eld, typically representing the URL of the resource server, is a unique index in the front-runs a legitimate audience creation transaction at system. x/jwk/keeper/msg_server_audience.go:19-25, they can eectively block the legitimate user from creating their intended audience. This can lead to several issues: an attacker If  Resource Allocation Disruption: The legitimate user may need to reset their server resource allocator or make other adjustments to their system to work around the blocked audience.  Phishing Risks: an attacker could use the front-run audience to set up a phishing site. Since the audience eld is typically a URL, users might be misled into interacting with the attacker's site.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Exposing shared keys during audience creation with HS256 signing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf", "body": "When creating an audience at x/jwk/keeper/msg_server_audience.go:15-40, it is possible to use shared/symmetric keys (HS256) for signing and verifying tokens. However, this approach would result in exposing the shared keys as the key is stored on a chain.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Genesis does not validate audience admin addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf", "body": "The Validate function in x/jwk/types/genesis.go:21 does not properly validate the audience admin addresses. This may create a situation where an invalid admin is added, resulting in the inability to administrate the audience in the future.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Update audience command does not support updating the admin", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf", "body": "The CmdUpdateAudience function within x/jwk/client/cli/tx_audience.go allows updating the administrator and key associated with a specic audience index. While it accepts arguments for updating the key, for specifying a new it administrator through the CLI command. Consequently, the update process assigns the current administrator (obtained from the source address) as the new administrator. This restricts the ability to change the administrator via the CLI command, which poses a signicant security risk, particularly in scenarios where the current administrator's credentials are compromised. lacks a parameter", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Incomplete validation in update audience function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf", "body": "The ValidateBasic function in x/jwk/types/message_audience.go:53 serves the purpose of validating the MsgUpdateAudience message. However, it fails to incorporate validation checks for the new_admin parameter within the message. This omission exposes the system to the risk of accepting messages containing invalid administrator data for audiences. The inclusion of such invalid data could hinder the future utilization of the audiences.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Expired tokens cannot be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf", "body": "the current implementation In in x/jwk/keeper/msg_server_audience.go:72, expired tokens are not deleted automatically and hence remain stored indenitely. Moreover, audience admins have to pay gas for transactions to delete audiences. This can lead to unnecessary consumption of storage space over time, as the number of expired tokens can potentially grow large. DeleteAudience function the of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Debit transfers always fail for tokens that return no value on success", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "The debit function allows transferring tokens from a users account to a beneciary. The transferFrom function is being called inside the following require statement: require(token.transferFrom(userAddress, amount), \"Token transfer failed\"); beneficiaryAddress, This would lead to failing transfers for tokens that return no value on success and revert or throw on failure, like USDT.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Withdrawal limit can be easily circumvented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "Whenever the function debit is called, the modier checkWithdrawalLimit checks that the requested amount is below the global withdrawal limit. However, this check is only applied per call and can be easily circumvented by splitting larger withdrawals into multiple transactions where each one is below the withdrawal limit.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. The executioner can debit any approved tokens from the users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "According to the client's comment, the main motive of this contract is to auto-top-up users' cards from their approved list of tokens. However, the current implementation has no checks against any approved lists. This allows the executioner to debit any tokens from the users that have approved spending.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing event for critical parameter change", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "limit, which is a critical The setMaxWithdrawalLimit function sets a new withdrawal change. However, it does not emit an event. Events help o-chain tools to track changes, and hence increase usability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Redundant input validations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "In a couple of instances, redundant validations are present: - - checks modier checkBeneficiaryRole the The beneficiaryAddress is not address(0) which can only happen if a privileged admin has granted BENEFICIARY_ROLE to address(0). Because this is highly unlikely and a mistake by the admin, the abovementioned check can be removed to save gas. The checkWithdrawalLimit modier checks whether the tokenAddress argument is not address(0). However, because any ERC20 call to address(0) would revert anyway, this check can be removed to save gas. whether", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Redundant checks during token transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "to a beneciary. The debit function allows transferring tokens from a users account However, before the token transfer, the function performs allowance and balance checks which are then checked again by the tokens contracts. This leads to unnecessary gas spending and reduces overall readability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Global withdrawal limit does not allow granular control", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "The contract has one global limit _maxWithdrawalLimit that can be updated by an admin. Within checkWithdrawalLimit, this value is scaled by the tokens decimals and compared with the requested amount. This approach has multiple downsides: - - An admin can only set one value, which will have very dierent monetary values for dierent tokens. For instance, a value of 10,000 results in a limit of 10,000 USD for USDC, more than 3 million USD for ETH and more than 60 million USD for WBTC. Because the value is scaled by the decimals, the smallest possible value is 1 whole unit for every token. For some tokens like WBTC, 1 WBTC may already be too large. Allowing fractional values may be desirable.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. The withdrawal limit can be used to implicitly pause the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "setMaxWithdrawalLimit to any the The to the _maxWithdrawalLimit checkWithdrawalLimit modier, setting the withdrawal limit to zero would not allow the users to debit tokens and would lead to the same outcome as pausing the contract via the pause function. This may mislead users. including zero. However, due function value allows admin set an to", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Miscellaneous", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf", "body": "- Use != 0 instead of > 0 for unsigned integer comparison to save gas. The modier name anyPrivilagedUser contains a typo, - anyPrivilegedUser. replace it with", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Blocked cross-chain requests are indenitely retried and could be exploited for denial-of-service attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In the HandleFees function in x/crosschain/abci.go:18, cross-chain requests are put in a blocked state (CROSSCHAIN_TX_BLOCKED) if fees cannot be deducted from the fee payer with the DeductFeeInboundRequest, DeductFeeOutboundRequest or DeductFeeCrosstalkRequest functions due to either not having a fee payer congured, insucient fee payer balance, or the fee payer address not being approved yet. Such blocked cross-chain requests are then retried in the EndBlocker function in line 38 after every other block, specically after every params.BlockedRetryInterval block interval. However, if deducting fees from the fee payer continues to fail, the cross-chain request will be retried indenitely. Consequently, this can potentially be exploited to cause denial-of-service attacks on Router Chain by submitting a large number of cross-chain requests that are blocked and retried indenitely. Similarly, the same issue persists for blocked ack requests if deducting fees fails in the DeductFeeInboundAckRequest and DeductFeeCrosstalkAckRequest functions the when ProcessBlockedCrosschainAckRequests function in lines 551-592. processing requests blocked the in", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Non-deterministic iteration in ClaimEventSlashing can cause consensus failure", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In x/attestation/abci.go:32121, attestations are processed by iterating over the attmap map. In Go, iterating over a map does not guarantee a consistent order of iteration, leading to non-deterministic behavior. For instance, if the UnpackAttestationClaim function in line 78 errors, a panic will occur in line 80. This could cause the resulting app hash computed by one validator to dier from others. Consequently, the validators cannot reach a consensus within Tendermint's timeouts, causing a consensus failure and halting the chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Unapproved fee payers can block legitimate requests which can be exploited for denial-of-service attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In x/crosschain/abci.go:254 and 259, any errors within the fee payer will cause the Execute function to return the execution early. This is problematic because other cross-chain requests ready to be executed will not be processed. Consequently, an attacker can submit a cross-chain request without approving the fee payer for the pending requests to to block other legitimate requests. The attacker can wait accumulate to a large number and approve the fee payer to cause all pending requests to be processed at once. Since this function is executed in the EndBlocker, block production will be slowed, potentially halting the chain. This can be exploited for a denial of service attack.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Anyone can submit forged cross-chain requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "Cross-chain requests are submitted to Router Chain via the MsgCrosschainRequest in message, x/crosschain/keeper/msg_server_crosschain_request.go:10. Requests are processed dierently based on the workow type determined by calling the WorkflowType function in line 18, which can INBOUND, OUTBOUND, or CROSSTALK. handled The INBOUND workow type is used for requests originating from a source chain and relayed to a CosmWasm contract deployed on Router Chain. The OUTBOUND workow type is used requests originating from CosmWasm contracts on Router Chain and relayed to a for destination chain. In any other case, the CROSSTALK workow type is used for requests originating from a source chain and relayed to a destination chain. INBOUND requests, constituting emitted events on a source chain, are submitted by the orchestrators of Router Chain and require a supermajority of orchestrators to attest to the request before it is considered valid. However, as there is currently no access control or in-depth validation of the submitted MsgCrosschainRequest message, anyone can send such a message, potentially with a malicious payload. For instance, setting SrcChainType to MultichainTypes.CHAIN_TYPE_ROUTER to forge an OUTBOUND request does not require attestations as it is assumed that the request originates from Router Chain itself. This results in burning Router tokens from an arbitrary address specied in RequestSender, causing a loss of funds. it is also possible for an attacker to mint unlimited native Router tokens by Additionally, forging an INBOUND request with an IBC_VALIDATION validation type. Such a validation type typically assumes that the request was received via IBC and thus is valid. In the case of a is considered valid and processed in the forged cross-chain request, HandleNativeTransfer function in x/crosschain/abci.go:81. Subsequently, the HandleInboundNativeTokenFlow function called in line 92 mints an arbitrary number of Router tokens to the attacker-controlled RouteRecipient. the request The two depicted scenarios are just examples of how an attacker can exploit the lack of access control and validation of cross-chain requests. The ability to maliciously craft a MsgCrosschainRequest message leads to serious security implications for Router Chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Anyone can submit forged cross-chain ack requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "via the MsgCrosschainAckRequest As part of the acknowledgment workow, cross-chain ack requests are submitted to Router in Chain Ack x/crosschain/keeper/msg_server_crosschain_ack_request.go:10. requests are processed dierently based on the workow type determined by calling the WorkflowType function in line 17 and can be INBOUND_ACK, OUTBOUND_ACK, or CROSSTALK_ACK. message, handled The INBOUND_ACK workow type is used to send acknowledgments to a CosmWasm contract on Router Chain. The OUTBOUND_ACK workow type is used for ack requests originating from Router Chain and relayed to a destination chain. In any other case, the CROSSTALK_ACK workow type is used. INBOUND_ACK requests, constituting emitted ack events, i.e., iReceive on a source chain, are submitted by the orchestrators to Router Chain and require a supermajority of orchestrators to attest to the ack request before it is considered valid and executed. However, as the submitted MsgCrosschainAckRequest message, anyone can send such a message, potentially with a malicious payload. there is currently no access control or in-depth validation of For instance, by sending a forged MsgCrosschainAckRequest message with an INBOUND_ACK workow type and the validation type IBC_VALIDATION, the last observed event nonce will be updated by the SetLastObservedEventNonce function in x/crosschain/keeper/ack_validation_handler.go:71. This results in potentially grieng new legitimate cross-chain requests as they will be considered as already validated in x/crosschain/keeper/validation_handler.go:45 due to the last observed event nonce being greater or equal to the submitted event nonce and thus not storing the request. Subsequently, as soon as the supermajority of orchestrators attests and observes the event, it will not get further processed by the handlers in x/crosschain/keeper/hooks.go as there is no such request stored in the database. The ability to maliciously craft a MsgCrosschainAckRequest message leads to serious security implications for Router Chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Unbonding validators can circumvent slashing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "the ClaimEventSlashing function, During the EndBlocker slashing process, implemented in x/attestation/abci.go:27-122, is called in line 22. However, only bonded validators are considered for slashing if they submit conicting attestations or miss attesting an observed claim. This is problematic because unbonding validators are not exposed to the slashing penalty. Consequently, reports such a slashable behavior, validator can unbond from the validator set to avoid the slashing penalty. if an orchestrator the corresponding", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Deactivated price feeders are not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "price conguring When x/pricefeed/proposal_handler.go:34, governance can set the Active boolean to indicate whether the price feeder is activated or deactivated (see x/pricefeed/types/price_feeder_info.pb.go:28). However, this is not enforced through the codebase. feeders in the Specically, in TokenPrices and x/pricefeed/keeper/msg_server_token_prices.go:11 x/pricefeed/keeper/msg_server_gas_prices.go:11 do not validate whether the price feeders Active status is true before allowing them to update the prices. Consequently, governance cannot remove or disable malicious price feeders after adding them. GasPrices functions and", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Failed requests will not be reected for ErrorGasOverflow panics", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In the following code locations, the recover function does not modify the exec data and exec ag when the default statement is entered:  x/crosschain/keeper/inbound_ack_execution.go:66-69  x/crosschain/keeper/inbound_execution.go:65-68  x/voyager/keeper/fund_deposit_execution.go:60-63  x/voyager/keeper/fund_paid_execution.go:52-55  x/voyager/keeper/update_deposit_info_execution.go:54-57 In comparison, the function handles the ErrorOutOfGas panic case when executing the ConsumeGas function. If that happens, the exec ag will be set to false, and the exec data will be updated with the error. However, this is not performed when the default statement is entered. This will happen if the ErrorGasOverflow panic occurs for overows when computing the gas consumption amount. Consequently, the exec ag and exec data will not be updated to indicate the failed request, causing incorrect events to be emitted.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Failed cross-chain ack requests are incorrectly stored as successful", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In x/crosschain/keeper/ack_workflow.go:93-100, no return statement is implemented to exit the HandleOutboundAck function early after the cross-chain request has failed. if an error occurs during SendIBCPayload in line 86, Specically, the cross-chain acknowledgment request status is stored as CROSSCHAIN_ACK_TX_EXECUTION_FAILED. lines 99-100 will Since no return statement is implemented after updating the status, continue as updated CROSSCHAIN_ACK_IBC_TRANSFERRED. Consequently, a cross-chain request that fails will be incorrectly stored as a success. incorrectly execute, causing status the be to to issue This x/crosschain/keeper/workflow.go:124-131. present also the in is HandleOutbound function in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Executing crosstalk requests with a missing IBC relayer cong results in indenite retries and liveness issues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "The Execute function in x/crosschain/abci.go:321-361 iterates and processes all stored cross-chain requests with the CROSSCHAIN_TX_READY_TO_EXECUTE status in the EndBlocker function at the end of every block. In the case of a CROSSTALK request, a cross-chain request originates from a source chain and is intended to get relayed to a destination chain. If the destination chain is a Cosmos chain, the relayer cong is retrieved by the CrosschainRequest.DestChainId function to determine the IBC channel, RelayerConfig.Channel. Subsequently, this IBC channel is used to send the cross-chain request from Router Chain to the destination Cosmos chain via IBC. if no for yet such exists relayer stored, conguration cong is not However, provided CrosschainRequest.DestChainId, for instance, because the chain ID is invalid or the i.e., relayer CROSSCHAIN_TX_READY_TO_EXECUTE. This results in the cross-chain request execution to be retried by the Execute function in the next block, potentially indenitely. As there is currently no validation of CrosschainRequest.DestChainId, allowing anyone to dene an arbitrary destination chain ID, this behavior can be exploited to spam Router Chain nodes with cross-chain requests that are repeatedly processed and retried, allowing a denial-of-service attack. remains unchanged, the request status the Similarly, ExecuteAck function in x/crosschain/abci.go:443-478. the same issue persists for CROSSTALK_ACK requests processed by the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. Anyone can create a new relayer conguration with a potentially invalid IBC channel, resulting in failed cross-chain requests via IBC", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "Cross-chain requests are sent to a Cosmos destination chain via IBC. The IBC channel used for sending the request is congured in the relayer conguration. Relayer congurations are created and managed via the MsgCreateRelayerConfig, MsgUpdateRelayerConfig, and x/crosschain/keeper/msg_server_relayer_config.go:11-91. MsgDeleteRelayerConfig messages handled in However, anyone can create a new relayer conguration (before the Router team is able to the legitimate relayer cong), as the CreateRelayerConfig function does not set implement any access control mechanism. Consequently, malicious users can create a new relayer cong for a specic Cosmos destination chain with an invalid IBC channel. This will result in cross-chain requests failing when attempting to send them via IBC to the destination chain with the invalid IBC channel. Once a relayer cong is created, it can only be updated and deleted by the creator of said relayer cong. An invalid relayer cong will thus prevent a correctly congured relayer cong from being created for the same Cosmos destination chain.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "12. Symbol prices requested by the BandChain oracle are not namespaced by the price feeder name, resulting in the inability to retrieve prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "StoreOracleResponsePacket The in x/pricefeed/keeper/keeper.go:210 receives an OracleResponsePacketData packet containing the requested symbol prices from the BandChain oracle. The contained prices are looped over, and the UpdatePrice function in line 220 updates the stored symbol prices. Symbol prices are namespaced by a price feeder name, PriceFeeder, which is or BAND_PRICE_FEEDER = \"band_feeder\". \"router_price_feeder\" ROUTER_PRICE_FEEDER function usually either = Retrieving the price of a specic symbol with the GetPriceBySymbol function in x/pricefeed/keeper/price.go:80 rst attempts to return the price with the the BAND_PRICE_FEEDER ROUTER_PRICE_FEEDER price feeder name. feeder found, name price with not or, if However, the StoreOracleResponsePacket function does not set the PriceFeeder eld of the Price struct when updating the symbol prices. This leads to the symbol price being incorrectly stored without a prex, resulting in the GetPriceBySymbol function not being able to retrieve the price by the symbol name. the ConvertNativeTokenFeeToRouter function, used within the Consequently, crosschain module, is unable to retrieve the price of the chain's native token and returns the error \"Token price not found\" when processing cross-chain requests.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "13. Custom application panics in EndBlocker can halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "Within the x/attestation and x/crosschain modules, custom panics are implemented in the EndBlocker if application-specic errors are encountered, which leads the chain to halt. intentionally utilize panics as preventive measures against While the SDK itself might unintended bugs, custom panics within the application's logic in ABCI methods can accidentally introduce vulnerabilities. For example, a malicious actor can halt the chain if they trigger an application-specic logic error, causing a denial of service attack. That said, it is important to note that panicking within ABCI methods can be appropriate under specic circumstances. For instance, if an error in the application-specic logic indicates a critical aw in the protocol, halting the chain and alerting stakeholders might be benecial to prevent the issue from causing further damage.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "14. Unhandled errors in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In several would cause silent failures as errors are not raised to notify users. instances of the codebase, functions that return an error are not checked. This  x/attestation/keeper/attestation.go:220, 329  x/attestation/keeper/msg_server_set_orchestrator_address.go:5  x/attestation/keeper/msg_server_valset_confirm.go:53  x/attestation/keeper/msg_server_valset_updated_claim.go:44  x/attestation/keeper/valset.go:42  x/attestation/module.go:80  x/crosschain/keeper/ack_fee_handler.go:186, 194  x/crosschain/keeper/ack_workflow.go:17, 19, 110, 113, 120  x/crosschain/keeper/event_handler.go:16, 36, 47, 56, 64, 77, 85, 93, 103, 117, 135, 146, 154, 167, 175, 183, 192, 204, 216  x/crosschain/keeper/fee_handler.go:194, 200  x/crosschain/keeper/gov/gov.go:37, 72  x/crosschain/keeper/native_token_flow.go:52  x/crosschain/keeper/workflow.go:153  x/crosschain/module.go:74  x/crosschain/types/metadata.go:61  x/pricefeed/module.go:76  x/multichain/keeper/gov/gov.go:40, 86, 125, 168, 220, 259  x/multichain/module.go:80  x/rwasm/module.go:73  x/voyager/keeper/event_handler.go:16, 38, 45, 53, 63, 81, 88, 96, 106, 123, 130, 138  x/voyager/module.go:74  x/metastore/abci.go:33  x/metastore/keeper/msg_server_approve_feepayer_request.go:30  x/metastore/keeper/msg_server_set_metadata_request.go:24, 51  x/metastore/module.go:82", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "15. Incomplete genesis handling causes loss of storage values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In several instances of the codebase, the genesis state does not handle the storage values properly in either the initialization or export functions. Firstly, the InitGenesis function in x/attestation/genesis.go:45-50 does not call SetValsetUpdatedClaim for the provided genState.ValsetUpdatedClaimList. This means that although it is exported in line 64, it cannot be added back when initializing the genesis state, causing all existing ValsetUpdatedClaimList storage values to be lost. Secondly, the InitGenesis function in x/voyager/genesis.go:30-33 does not call provided SetDepositUpdateInfoRequest genState.DepositUpdateInfoRequestList. This means that although it is exported in line 46, it cannot be added back when initializing the genesis state, causing all existing DepositUpdateInfoRequestList storage values to be lost. the for the and InitGenesis in Lastly, handle x/crosschain/genesis.go:10-84 BlockedCrosschainRequestList and BlockedCrosschainAckRequestList. This if the genesis state was exported and the chain is reinitialized, all existing means that BlockedCrosschainAckRequestList BlockedCrosschainRequestList storage values will be lost. ExportGenesis functions and not do", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "16. GetLastUnBondingBlockHeight will always return zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "the last unbonding block height In x/attestation/abci.go:135, is retrieved with GetLastUnBondingBlockHeight and compared in line 162 to determine whether SetValsetRequest needs to be called. However, there is no function that sets the storage value of types.LastUnBondingBlockHeight. Consequently, the last unbonding block height will always return zero in x/attestation/keeper/valset.go:259, rendering it useless because the value will never equal the current block height.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "17. Slashing risk due to sequential attestation processing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In x/attestation/keeper/attestation.go:192, the Attest function ensures the claim event nonce equals the incremented last claim event nonce to process attestations sequentially. This can become problematic when a validator unbonds and later re-bonds, for example, months or even a year later. In such cases, the validator is obligated to attest to all claims that occurred during their absence. Processing this backlog of in-between claims can be time-consuming, and there's a risk that the re-bonded validator might miss attesting to some claims, leading to slashing risks.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "18. Zero values initialization aects gas handling and fee refunds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In the following instances of the codebase, the variables are set to zero instead of the intended values. Firstly, the DestGasLimit and DestGasPrice in x/crosschain/abci.go:230-231 are set to zero instead of gasLimit and gasPrice. This is also the same for the AckGasLimit and AckGasPrice functions in x/crosschain/abci.go:584-585, as their value is also set to zero instead of ackGasLimit and ackGasPrice. This would cause the sudo message to fail due to an out-of-gas error because the computed gas fee limit will be zero. the in Besides that, of x/crosschain/abci.go:313 feeConsumedInRoute. This would cause the relayer to be refunded with all the fees even though the sudo message did consume gas. CreateCrosschainAckRequest to feeConsumed function instead zero sets the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "19. HandleAckDefaultValidation does not update the event block height, causing incorrect query responses to be returned", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf", "body": "In the x/crosschain/keeper/ack_validation_handler.go:71, HandleAckDefaultValidation function does not update the last observed event height with SetLastObservedEventBlockHeight after updating the last observed event nonce with SetLastObservedEventNonce. This is inconsistent with others as the last observed x/attestation/keeper/attestation.go:324, event updated height in is x/crosschain/keeper/ack_workflow.go:37, x/crosschain/keeper/workflow.go:67. and the Consequently, in x/attestation/keeper/attestation.go:244 and used in line 261 will be an outdated value, causing the LastEventNonce query to return incorrect event height in x/attestation/keeper/grpc_query_last_event_nonce.go:25. observed retrieved lowest height", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Expensive RPC methods are allowed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf", "body": "The analyzed RPC endpoints support all methods that are exposed by EVMOS. Among those, some methods may be problematic in terms of resource usage, for example:  debug_traceTransaction: This method can be used to rerun and trace a prior transaction. Moreover, a trace conguration can be provided where memory capture can be enabled and a custom JavaScript expression can be supplied as the tracer.  debug_traceBlockByNumber: Similar to debug_traceTransaction, but for a whole block.  txpool_content: Lists all transactions that are currently pending.  txpool_inspect: Similarly to txpool_content, but in text format. The invocation of these methods can consume a lot of resources on the RPC server. An attacker might abuse this to overload the servers and perform (D)DoS attacks.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Tendermint RPC API exposes private IP address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf", "body": "The Tendermint RPC API can be used to get the private IP of a node via the moniker eld: curl http://52.29.63.91:26657/status {\"jsonrpc\":\"2.0\",\"result\":{\"node_info\":{\"protocol_version\":{\"p2p\": \"8\",\"block\":\"11\",\"app\":\"0\"},\"id\":\"002408011220944cd0e92a4060e0e79b 9a0ad58b3fd7a1e92c22db5b1623b7647754f23e3d92\",\"listen_addr\":\"/ip4/ 0.0.0.0/tcp/26656\",\"network\":\"vaptra_2145170-1\",\"version\":\"\\u003cv ersion\\u003e\",\"channels\":\"01\",\"moniker\":\"ip-10-201-0-197\",\"other\":{ \"tx_index\":\"on\",\"rpc_address\":\"tcp://127.0.0.1:26657\"}},\"sync_info \":{\"latest_block_hash\":\"E3B0C44298FC1C149AFBF4C8996FB92427AE41E464 9B934CA495991B7852B855\",\"latest_app_hash\":\"E03886591492A5D62CD1164 2A294D9F08A82F0ADBA39EC0A057E9D0AA028E871\",\"latest_block_height\":\" 34852\",\"latest_block_time\":\"2024-03-16T19:45:02.643255719Z\",\"earli est_block_hash\":\"\",\"earliest_app_hash\":\"\",\"earliest_block_height\": \"0\",\"earliest_block_time\":\"0001-01-01T00:00:00Z\",\"catching_up\":fal se},\"validator_info\":{\"address\":\"25E427B4DE03FEBFAEEEB73EB7942FAE5 ABC3E03\",\"pub_key\":{\"type\":\"tendermint/PubKeyEd25519\",\"value\":\"yc/ TFWU3L8xfmxqVJvpoJfGQYOR7uG9Aqj3DSKBWTNo=\"},\"voting_power\":\"1\"}},\" id\":-1} The same information is also exposed via the net_info endpoint. While this cannot be exploited, it is generally recommended to expose as little information as possible about the internal network structure.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "3. Broken links in the Dymension EVM RollApp documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf", "body": "It has been noticed that the documentation describing the Dymension EVM RollApp contains references to links that lead to non-existent pages. This may be problematic for new users using the platform. These are:  Link in Quick guide section,  Link in Run local dymension hub node section.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Usage of deprecated functionality", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf", "body": "It has been observed that the codebase contains calls to the deprecated functions. Namely, the rand.Seed function from the math module is used to set up the RNG. The rand.Seed has been deemed deprecated. The code that is using such functionalities can be found in the and roller/cmd/config/init/flags.go roller/data_layer/celestia/generate_namespace_id.go les.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Multiple subprocesses launched directly on the OS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf", "body": "It was observed that the codebase utilizes an os/exec module to run commands directly within the OS command line interface. Such calls could be susceptible to a Command Injection attack. Although, currently, the commands executed do not seem to take the input from users directly, it is still a best practice to avoid such an approach to multithreading. Furthermore, should an administrator responsible for conguring the system make a mistake, it increases the attack surface of the whole project.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Balance updates performed from precompiles are overwritten if the precompile is executed in a transaction with other state change logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "Delegate in The precompiles/staking/tx.go:59 and precompiles/distribution/tx.go:67 are not correctly committing balance changes if the caller function performs state changes. WithdrawDelegatorRewards precompiles dened and Consequently, attackers could craft a contract where it is possible to delegate to a validator without having the delegated amount deducted from their balance. users the Additionally, WithdrawDelegatorRewards precompile could lose their rewards, depending on the contract implementation. leveraging contract interact with that a A test case reproducing the issue is provided in Appendix 1. This issue as well as the test case in Appendix 1 has been disclosed by the Evmos team to Oak Security during the audit.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. User distribution authorizations can be misused by malicious contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The state transition functions of the distribution module require the user to authorize the to execute the SetWithdrawAddress, WithdrawDelegatorRewards, and caller WithdrawValidatorCommision functions. Failure to do so would result in the transaction's inability to interact with the distribution precompile. However, the distribution precompile lacks the functionality to revoke authorization once granted, resulting in smart contracts having access granted until the authorizations expiry. Although a user can revoke the authorization directly through the Cosmos SDKs authz module, this defeats the purpose of having the precompile in the rst place.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. The bech32 precompiler is not loaded in the EVM", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The x/evm/keeper/precompiles.go:20-41, initializes the list of available precompiles. AvailablePrecompiles function, dened in However, the bech32 precompile is not added to the list, which renders the precompile inaccessible in the EVM. Additionally, return a valid precompile address. in precompiles/bech32/bech32.go:63, the Address function does not Consequently, the bech32 precompile cannot be executed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Validators and Redelegations queries are not callable from EVM precompiles", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The validators and redelegations functions are available in the staking precompile at precompiles/staking/Staking.sol:201 and 227. However, the implementation of both functions in precompiles/staking/tx.go is missing, rendering the functions uncallable from EVM-based smart contracts.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Queries do not support pagination, enabling attackers to DOS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The query implementations do not support result pagination. This could be problematic since some of the implemented Cosmos SDK queries could return a large number of items. Some examples are the ValidatorSlashes and DelegationRewards queries dened in precompiles/distribution/distribution.go:160. Additionally, gas is not charged depending on the size of the query result size, but rather on the query input size. This could allow malicious actors to execute computationally and memory-heavy queries with a disproportionate gas cost, which could slow down block production up to the point where the chain halts.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The Approve function does not allow ne-grained Coin allowances, allowing more Coins than intended in case of multiple messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf", "body": "The Approve function dened in precompiles/staking/approve.go:32 iterates through a list of user-provided Cosmos SDK message types to allow a grantee to execute them on behalf of the user with the amount of user-specied Coins. However, because of the chosen input data structure, an encoded (Address, Coin, []string) tuple, it is not possible to specify how many Coins are to be used for each individual message. This results in allowing each message type with the Coin dened in the input parameter. Consequently, the total allowance will be dierent from the specied input since it will be equal to the cardinality of messages multiplied by the provided Coin. For example, a message with an allowance of 1ucoin and four message types will result in a total allowance of 4ucoin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Truncated CW20 token transfer amount for CW20 tokens with more than 8 decimals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "The Wormhole token bridge contract truncates CW20 token amounts to 8 decimals. implies that a small amount of tokens (the so-called dust) stays in the This token-translator contract and is not transferred to the Wormhole token bridge. The user will hence receive fewer bridged CW20 tokens than initially transferred tokenfactory tokens.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Lack of conguration parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "instantiation, During contract are WORMHOLE_CONTRACT token_bridge_contract InstantiateMsg message. the storage variables TOKEN_BRIDGE_CONTRACT and the initialized the src/contract.rs:33-39 with in values wormhole_contract supplied in and However, the provided values are missing address validation. Invalid strings would lead to a non-functioning contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Contracts are not compliant with the CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "The token-translator contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Redundant check on the submessage reply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "the submessage has been successful by The token-translator validates whether checking the replys result this check is unnecessary as the submessage is declared as SubMsg::reply_on_success. For SubMsg::reply_on_success submessages, the reply handler is only called upon the success of the submessage, making it impossible that the result is an Err variant. in src/contract.rs:94-97. However, Although not a security issue, unnecessary code can negatively impact maintainability and slightly increase gas consumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Unused WORMHOLE_CONTRACT storage variable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "During contract instantiation, the WORMHOLE_CONTRACT storage variable is initialized with the wormhole_contract value in src/contract.rs:37-39, which is supplied within the InstantiateMsg message. However, the value of WORMHOLE_CONTRACT is never read from storage or used in any other way.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Missing attributes on some message handlers responses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "informative attributes when The token-translator contract does not make use of returning a response in the convert_and_transfer, convert_bank_to_cw20, and convert_cw20_to_bank message handlers. This could negatively impact o-chain services that try to monitor the state of the protocol. In addition, although the contract does not save any owner eld in the storage. the instantiation function response includes a misleading owner attribute,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Unhandled zero-amount transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "Using the ConvertAndTransfer and ConvertBankToCw20 messages, a user can send tokens to the contract. They are later validated in the context of whether more than one type of coin has been sent, but there is no validation enforcing that the transferred amount is greater than zero. As a consequence, the functions may unnecessarily perform operations, ending up with a panic, and Cw20ExecuteMsg::Transfer do not support transferring zero-amounts. TokenBridgeExecuteMsg::InitiateTransfer because both This leads to unnecessary gas consumption. Also, panics degrade the user experience since they do not provide any context why an error has occurred and how it can be resolved.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Autocompounder is vulnerable to share ination attack", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "compute_mint_amount The in contracts/autocompounder/src/handlers/reply.rs:130 is vulnerable to a share ination attack. A share ination attack represents a scenario where a malicious actor articially inates the supply of tokens, potentially manipulating the token's value and diluting other holders' shares. function Currently, the function computes the mint amount by using integer division. Due to the nature of integer division, results are always oored. This allows an attacker to inate their current shares while stealing funds from unsuspecting users. The compute_mint_amount is susceptible to this attack because the denominator of the integer division staked_lp can be manipulated for Astroport, representing the total staked amount of the proxy address. An example attack scenario: 1. The attacker makes the rst deposit of 1 token and thus receives one share", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Finally, the computed lp_tokens_withdraw_amount value will be evaluated to 7501 ((1/2) * 15002), earning the attacker an extra 2499 (7501-5002) liquidity pool tokens. redeems attacker shares. their The Recommendation We recommend enforcing a minimum amount that needs to be met in the rst deposit. This will greatly increase the cost of orchestrating a share ination attack. Note that it is common practice to mint dead shares to the protocol to increase the cost of the attack further. For more details, please see Astroports implementation. Status: Resolved 2. Attackers can cause batch unbondings to fail, preventing users from unstaking liquidity pool tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "6. Finally, the computed lp_tokens_withdraw_amount value will be evaluated to 7501 ((1/2) * 15002), earning the attacker an extra 2499 (7501-5002) liquidity pool tokens. redeems attacker shares. their The Recommendation We recommend enforcing a minimum amount that needs to be met in the rst deposit. This will greatly increase the cost of orchestrating a share ination attack. Note that it is common practice to mint dead shares to the protocol to increase the cost of the attack further. For more details, please see Astroports implementation. Status: Resolved 2. Attackers can cause batch unbondings to fail, preventing users from unstaking liquidity pool tokens", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Unbonding cooldowns are not respected", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In the contracts/autocompounder/src/handlers/execute.rs:471-488, check_unbonding_cooldown function attempts to verify the last unbonding time has the LATEST_UNBONDING exceeded the minimum unbonding cooldown time. However, storage state is never stored anywhere in the codebase. Consequently, batch unbondings can be repeatedly performed without respecting the congured cooldown period. This issue also causes the query_latest_unbonding function to fail when loading LATEST_UNBONDING from the storage. We classify this issue as major because it aects the correct functioning of the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Compounding will fail for zero performance fees", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/reply.rs:190-200, the fees are deducted from rewards and sent to the commission address. However, the swap will fail if the performance fee is zero, preventing the auto-compounding from working successfully. Please see the test_zero_performance_fees test case to reproduce the issue. We classify this issue as minor because the manager contract can recover to a correct state by updating the performance fees.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Hard-coded slippage value makes deposits susceptible to sandwich attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "deposit in The a contracts/autocompounder/src/handlers/execute.rs:143 hard-coded max spread value of 5%. Depending on the pair that liquidity is being provided for, this may be a too large value, making the deposit functionality vulnerable to a sandwich attack. species function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Non-updatable conguration can not reect changes in staking contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "the In contracts/autocompounder/src/handlers/instantiate.rs:139-148, conguration and unbonding_period directly from the staking contract. However, there is no entry point to update this data. min_unbonding_cooldown dened taking both as is In case the aected parameters are modied in the staking contract, this will cause inconsistencies in the unbonding mechanism. The underlying messages directed to the staking contract could fail without the users being able to understand why, as the reported information will not reect the new limits.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Minting of zero vault tokens possible", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The autocompounder contract allows for the minting of zero shares upon depositing in some edge cases. This is possible as CW20 tokens now allow the minting of zero tokens, and the compute_mint_amount function does not perform further validation on the returned in amount contracts/autocompounder/src/handlers/reply.rs:135-143. minted shares be to of Users depositing small amounts of funds could receive zero shares in exchange, eectively losing access to those funds. In addition, this issue causes the Autocompounder is vulnerable to share ination attack to be even more lucrative for an attacker.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Unused variable in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/execute.rs:98, _staking_address variable is declared, but is not used. deposit the function in the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Lack of validation upon deposit lead to ineciencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The deposit function performs insucient validation on funds to be forwarded for liquidity provision in contracts/autocompounder/src/handlers/execute.rs:111-121. As the funds variable is not explicitly checked to contain pool assets only, the contract would try to provide liquidity with potentially erroneous assets in lines 140-144. This will cause the execution of all the code in the function to end up erroring, consuming an unnecessary amount of gas.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Remove TODO comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The codebase includes multiple TODO comments. It is best practice to remove all pending TODO items before releasing code to production.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Unused commented code in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/instantiate.rs:78-82, there is unused commented code. It is best practice to remove all unused commented code blocks before code is released toproduction.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Misleading variable name when withdrawing liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/execute.rs:267 and 382, the swap_msg variable is set when calling withdraw_liquidity on the specic DEX. The swap_msg variable name is misleading, swaps are performed later on the DEX.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. calculate_withdrawals sets expiration to current block height which may become problematic if the function is exposed in a future upgrade", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "the contracts/autocompounder/src/handlers/execute.rs:411-414, In unbonding timestamp defaults to the current block height if config.unbonding_period is None. This is not a security concern in the current implementation, since the calculate_withdrawals function can only be called from the batch_unbond function, which ensures the unbonding period is Some(_), as seen in lines 161-163. If future code was introduced though that allows calling the calculate_withdrawals function without going through the batch_unbond functions, it might cause withdrawals to be unlocked immediately in the next block.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Users cannot query fees through smart queries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/query.rs:16-42, no exposed queries return the fee congurations. Consequently, users cannot query the protocol's congured performance, deposit, and withdrawal fees.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Panicking macros and debugging code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The autocompounder contract uses Rust panicking macros to handle undesired situations in contracts/autocompounder/src/handlers/instantiate.rs:96 and 130. Panicking macros do not report meaningful error messages for users to understand what went wrong. In addition, an eprintln! statement which is typically used for debugging purposes can be found in contracts/autocompounder/src/handlers/execute.rs:357-360.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "20. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/autocompounder/Cargo.toml  packages/forty-two/Cargo.toml  packages/forty-two-boot/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The deposit function does not check whether additional native tokens are sent along the in contracts/autocompounder/src/handlers/execute.rs:89-157. message Any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to the wrong accounts, reverting extra funds increases the user experience.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attackers can register unbonded validators in the keyshare module to submit malicious key shares, censor, or DoS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "MsgRegisterValidator The in x/keyshare/keeper/msg_server_register_validator.go:12-38 enables the registration of a new validator in the keyshare module without conducting a validation check to verify if the provided validator is bonded. handler This allows an attacker to create and register a signicant number of unbonded validators within the keyshare module. Consequently, this vulnerability enables the attacker to potentially DoS the chain, engage in chain censorship, or submit malicious key shares. To execute chain censorship, attackers can register an extensive quantity of unbonded validators. Since the creation of an aggregate key necessitates reaching a threshold that depends on the number of validators, a substantial increase in the number of validators can it unfeasible for legitimate elevate the threshold. This elevated threshold can render validators to create the aggregated key. Another possible attack scenario involves the submission of malicious key shares, where a single entity possesses all of them, front-running legitimate validators. In this scenario, the attacker can generate the aggregated key and decrypt transactions. transaction Furthermore, validators registered in the keyshare module are iterated over during the in SendKeyshare x/keyshare/keeper/msg_server_send_keyshare.go:81-87, 133-148, and 151. Consequently, this message can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt. handling without the execution of limitations any gas imposing", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can register validators in the staking module to DoS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "the execution During in x/keyshare/module.go:162, an iteration is performed over all the validators registered in the staking module, regardless of their bonded status. BeginBlock specically function, the of Since the staking module allows anyone to register a validator, an attacker could register a substantial number of them, resulting in the BeginBlock function iterating through all of these validators. As a consequence, the execution of the BeginBlock function will consume more time and resources than anticipated, potentially leading to a slowdown of the chain or, in severe cases, a complete halt. Furthermore, it is important to note that a signicant quantity of validators within the staking module can contribute to increased resource demands during the execution of the RegisterValidator message handler. iterates through all Specically, in x/keyshare/keeper/msg_server_register_validator.go:25, the handler imposing any gas limitations. registered validators without Consequently, this message can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt. the execution of", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Validators can censor the execution of encrypted transactions at a particular block height without being punished", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "Validators can censor encrypted transactions at a particular block height by not submitting their key shares. There is no mechanism in place to punish idle validators who do not submit key shares. This would aect the reliability of the transaction execution since there is no guarantee for users that their transaction will be executed. Additionally, transactions that are not executed at the target height are discarded and there is no fallback mechanism in place to try to execute them in the next block.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Encrypted transaction execution does not charge gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "The execution of submitted encrypted transactions occurs within the BeginBlock function at the designated target height, as dened in x/pep/module.go:513. However, due to the nature of these transactions being executed directly in the BeginBlock there is currently no mechanism in place to invoke the function without user initiation, AnteHandler and charge the user for gas consumption. This vulnerability can potentially be exploited by attackers to carry out a variety of attacks. For instance, attackers could attempt to launch a Denial-of-Service (DoS) attack on the chain, saturate the block space by ooding it with transactions, or execute IBC transactions with the intent of targeting the funds of relayers.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Attackers can overwrite legitimate AggregateKeyShares making the chain unable to execute transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "CreateAggregatedKeyShare The in x/pep/keeper/msg_server_aggregated_key_share.go:10 enables anyone to submit the AggregatedKeyShare to for a particular block height. function, dened Since the validation of the submitted key is executed only in the BeginBlock function, attackers could be able to overwrite the legit key submitted by FairyPort with an invalid one. The only condition needed is that their transaction is executed after the legitimate one. Consequently, the chain will not be able to decrypt and process transactions for that block height.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Attackers can submit a large number of MsgSubmitEncryptedTx targeting the same block height to DoS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "SubmitEncryptedTx The in x/pep/keeper/msg_server_submit_encrypted_tx.go:12 enables users to submit encrypted transactions that will be executed at the dened TargetBlockHeight. function, dened Those transactions are then iterated over, and each one is decrypted and executed at the target block height in the BeginBlock function in line x/pep/module.go:223. Since there is no limit to the number of transactions that could be registered to be executed at a certain block height, attackers could submit a large amount of such transactions in order to spam the network. It is worth noting that a transaction can contain multiple messages and that the attacker will only pay for the byte length of the encrypted transaction. If the PEP module is deployed on chains that support CosmWasm, it opens up the possibility of deploying ad-hoc contracts, dispatching a large number of messages with a lightweight transaction, and executing computationally intensive operations with minimal cost. the iteration, decoding, and execution of Consequently, those transactions can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt.", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Attackers can submit a transaction with a large number of MsgCreateAggregatedKeyShare messages to DoS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "ProcessUnconfirmedTxs The in x/pep/keeper/unconfirmed_txs.go:21 is executed during the BeginBlock function and iterates over a set of unconrmed transactions and their inner messages in order to nd MsgCreateAggregatedKeyShare messages and process them. function dened Since there is no limit to the number of MsgCreateAggregatedKeyShare messages in the mempool, except the mempool size, and no gas for adding them is charged to the sender because the transactions are not directly executed, an attacker could craft and send a large number of transactions containing a large amount of MsgCreateAggregatedKeyShare messages in order to DoS attack the chain. Consequently, the iteration and execution of those transactions can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt.", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Logged/emitted keys combined with ability to aggregate keys for future block heights allows decryption of transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "In x/keyshare/keeper/msg_server_send_keyshare.go:165-174, after successful creation of the aggregated key, the key is stored, emitted in an event, and logged in the console. Since it is possible for validators to submit key shares and create the aggregated key for every height, including for blocks in the future, such keys may be unintentionally exposed, allowing anyone to decrypt transactions and predict future chain states. Users can simply monitor the chain state, listen for emitted events, or check the console of a node they run to retrieve the key.", "labels": ["Oak Security", "Severity: High"]}, {"title": "9. If MsgCreateAggregatedKeyShare is not in the rst 30 transactions in the mempool, blocks are executed without the decryption key", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "During the pep modules BeginBlock function, MsgCreateAggregatedKeyShare messages are retrieved from the mempool in order to execute them before other transactions in line x/pep/module.go:188. This is needed in order to have the current block decryption key in the store. However, since the tmcore.UnconfirmedTxs function returns only the rst 30 transactions in the mempool, there is no guarantee that MsgCreateAggregatedKeyShare messages are retrieved and executed before other transactions. Consequently, the decryption key of the current block may not be processed and all the encrypted transactions with target execution at the current height might be skipped.", "labels": ["Oak Security", "Severity: High"]}, {"title": "10. Insucient validation of PepNonce can lead to transaction replay attack", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "In x/pep/module.go:457-460, during the processing of encrypted transactions, the PepNonce is utilized to prevent replay attacks. In the current depends on a comparison between a user's nonce and a stored nonce. implementation, whether a transaction is accepted or rejected primarily Specically, if the user's nonce is lower than the stored nonce, the transaction is denied. The system operates by pulling the current stored nonce, increasing it by 1, and then setting this incremented nonce minus 1 as the anticipated nonce. Afterward, the system checks whether the user's nonce is less than this anticipated nonce. If it is, the transaction is disallowed. This mechanism can be exploited as it allows a replay of the rst transaction with nonce 1. Consider this scenario: The initial value of the stored nonce is 0, and a user starts o with a nonce of 1. This transaction is validated. As per a code condition, if the user's nonce is greater than the anticipated nonce, the current nonce is updated to match the user's nonce. Consequently, the stored nonce becomes 1. Herein lies the possibility of a replay attack due to incorrect calculations. When the user attempts to execute the same transaction for a second time, using a nonce of 1, the anticipated nonce is also 1. According to the system's acceptance criteria, a transaction fails if the user's nonce is less than the anticipated nonce. However, since 1 isn't less than 1, this condition fails, resulting in the wrongful acceptance of the replayed transaction. Please refer to Appendix 1 for a detailed dry run of the code, including ow diagrams, to illustrate the scenario where transactions can be replayed.", "labels": ["Oak Security", "Severity: High"]}, {"title": "11. Attackers could overwrite the active public key via IBC, leading to the inability of executing encrypted transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "In x/pep/keeper/current_keys.go:19, during the EndBlock function, the PEP module queries the active public key using the Inter-Blockchain Communication (IBC) protocol. To construct the IBC packet, it retrieves the source channel by calling the k.getChannel function, which retrieves the value stored with a prex key determined through is KeyPrefix(\"pep-channel-\"). the set OnChanOpenConfirm method of in x/pep/module_ibc.go:115. the IBC protocol However, it is important to note that this value can be overwritten whenever a new channel connects. initially during value This to manipulate This presents a potential vulnerability, as a malicious actor can create a fraudulent IBC in channel A OnAcknowledgementPacket manipulated active public key leads to the inability to decrypt and execute encrypted transactions. key x/pep/keeper/current_keys.go:147. stored in public active value the the of", "labels": ["Oak Security", "Severity: High"]}, {"title": "12. Insucient verication of submitted key shares could lead to the inability to aggregate the key", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "the parseKeyShareCommitment In in x/keyshare/keeper/msg_server_send_keyshare.go:35, all inputs to this method, including msg.Message, msg.Commitment, msg.KeyShareIndex, and ibeID, are provided by the user. function, dened The concern is that a malicious validator can generate their own local key share and commitments within send_key_share does not raise any errors to detect potential manipulations. parseKeyShareCommitment method since used the Consequently, if a manipulated message is included, and the key share stored, it could lead to the failure of the aggregated key share generation process.", "labels": ["Oak Security", "Severity: High"]}, {"title": "13. TrustedAddresses are a single point of failure", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "The protocol depends on the participation of TrustedAddresses and stored in Params, to regularly update the public key. third-party actors, denoted as However, this process lacks an incentivization mechanism and relies on a closed set of o-chain actors. Consequently, continual availability of these actors and the accuracy of the information they provide. the operational eectiveness of the chain is entirely dependent on the This poses a centralization issue which leads to a single point of failure for the chain operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Missing validation in keyshare modules Params", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "During the validation process of the Params within the keyshare module, specically in the code the the input slice is a string. validateTrustedAddresses function solely veries that Address validation is currently not performed. x/keyshare/types/params.go:84-91, segment located in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Missing MsgSendKeyshare input elds validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "the validation process During x/keyshare/types/message_send_keyshare.go:44-50, function solely veries that the sender address is valid. the of MsgSendKeyshare, the specically in ValidateBasic Since the message contains other blockHeight, they should also be validated before handling the message. input data like message, commitment, and", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Missing validations of GenesisState", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "During the validation process of x/pep/types/genesis.go:20-54, PepNonces keys are valid addresses. the pep modules GenesisState, specically in the Validate function does not check that Similarly, during the validation of the keyshare modules GenesisState in x/keyshare/types/genesis.go, the Validate function does not check if there is a duplicate Validator or ConsAddr in lines 27-33.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Amino codec must be registered to support users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "In x/keyshare/types/codec.go:33 and x/pep/types/codec.go:29, Amino should be used to register all interfaces and concrete types for the keyshare and pep modules. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Parsing query command ags are ignored", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "CLI query in registered Most use and x/keyshare/client/cli/query.go GetClientContextFromCmd to get Context, which does not read query command ags. in GetQueryCmd x/pep/client/cli/query.go commands function the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. MsgSendKeyshare transaction silently fails", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "SendKeyshare The in x/keyshare/keeper/msg_server_send_keyshare.go:20, silently fails if the sent key share is not valid. function, dened Consequently, a third party that executes this transaction cannot correctly handle a failure, and users are not getting feedback on the execution status.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "20. Use of magic numbers decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "In x/keyshare/keeper/msg_server_send_keyshare.go:51 a hard-coded number literal without context or a description is used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Inecient execution of GetAllValidators", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "In x/keyshare/keeper/msg_server_register_validator.go:24, GetAllValidators is called in the native staking module to obtain all validators. The purpose of obtaining all validators is to verify if any of the validator addresses match the address of the transaction sender. Querying all validators is inecient though, since there is a GetValidator function available in the staking module that returns a particular validator. Replacing the GetAllValidators function with the GetValidator function will clean up the code and reduce resource as well as gas consumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "22. Open issues in a dependency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "An open issue has been identied by Trail of Bits in the Kilic/bls12-381 library, regarding zero value deserialization due to internal modulo operations. The mentioned library is utilized in the code and it is crucial to verify that the deserialization issue does not have any adverse eects on the code's functionality and security.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "23. Missing usage description for transaction and query CLI commands", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "The transaction and query CLI commands of the keyshare and pep modules are missing a long message to describe their usage, which could be helpful for users and developers.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "24. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "transaction All commands x/keyshare/client/cli/tx.go msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI. x/pep/client/cli/tx.go registered and GetTxCmd CLI the in function call in the As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI, this is an unnecessary and duplicated invocation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "25. Non-standard management of external functions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "to the ocial According in https://docs.cosmos.network/main/building-modules/keeper, external keepers are listed in the internal keepers type denition as interfaces. In the audited codebase, however, the keepers type denition of both the keyshare and pep modules directly depend on external keepers. This goes against loose-coupling best practices. documentation Cosmos SDK", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "26. Miscellaneous code quality comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf", "body": "Throughout the codebase, instances of unused imports and code have been found.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Subwallet factory updates could lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "During the creation of a subwallet, the addresses of the Anchor Money Market and Terra token contracts are passed from the subwallet factory cong to the newly instantiated wallet - see contracts/subwallet-factory/src/contract.rs:107. These addresses are then stored in the cong of the new subwallet. The subwallet factory contract owner is able to update the addresses of the Anchor Money Market and Terra token. These changes would not be reected in the existing subwallets. This could lead the subwallets to use incorrect addresses for the Anchor market and Terra token.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Product factory updates could lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "During the creation of a xed recurring subscription contract the address of the job registry contract see contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:74. This address is then stored in the cong of the subscription contract. specied is - The product factory contract is able to update the address of the job registry contract. This change would not be reected in the existing recurring subscription contract  unlike the protocol fee and other conguration parameters dened in the product factory, which are queried prior to use rather than stored. This could lead the subscriptions to use an incorrect address for the job registry contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Protocol fee decimal places incorrectly specied", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. On lines sub1-fixed-recurring-subscriptions/src/contract.rs:346 and 697, decimal places are applied incorrectly when calculating the ratio of the protocol fee. In each case, the protocol fee could be greater than 100%. Which could lead to users being charged excessive amounts for using the protocol.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Owner cannot freeze admins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "the function executing When in contracts/admin-core/src/contract.rs:84, the contract veries that the sender is a whitelisted admin. Once this function is executed the contract owner will be unable to append new admins or otherwise unfreeze the admin list. This is contrary to the documentation denition of the owner being the highest-privilege access. execute_freeze, found as Further access verication to the execute_freeze function uses the can_modify function which checks that the sender is on the admin list. However, in the case that the owners address is not on said list this check would fail. Preventing the owner from successfully calling the execute_freeze function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Owner cannot execute set permissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "le contracts/subwallet/src/contract.rs:389 In function execute_set_permissions veries that the message sender is an admin whitelisted for the wallet. However, if the sender is the owner and not present on the admin whitelist then the execution will fail. As the owner has the highest-privilege access to a wallet this is contrary to the documentation. the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Admin whitelist cannot be unfrozen", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "le contracts/admin-core/src/contract.rs:54 In function execute_freeze freezes the list of whitelisted admins for a suberra wallet. Once frozen there is no way to reverse this decision, even for the wallet owner. It may be necessary to remove, or add, an admin due to scenarios such as the case of a leaked private key. the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Protocol fee decimal places should be dened as constants", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. However, throughout the code base, there is no constant variable dened to use in protocol fee calculations. Rather values are used on an ad-hoc basis, including:  sub1-fixed-recurring-subscriptions/src/contract.rs:271  sub1-fixed-recurring-subscriptions/src/contract.rs:346  sub1-fixed-recurring-subscriptions/src/contract.rs:697  sub2-p2p-recurring-transfers/src/contract.rs:451", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Unbounded number of contract admins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "There is no limit dened in contracts/admin-core/src/state.rs:10 to the number of addresses that can be whitelisted as Suberra wallet admins. Should the number of admins be excessively large this could make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Total number of subscriptions increments on cancellation undo", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "When a cancelled subscription is undone through the execute_subscribe function, contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:389, the function create_subscription is called. This function increments the total number of In the case of an undone cancellation, this leads to the number of subscriptions by 1. subscriptions being incremented unnecessarily.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Excessive grant duration, lack of revocation mechanism, and multiple delegate grantees", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "the In contracts/puppeteer/src/contract.rs:567, during the execution of execute_setup_protocol function, a GenericAuthorization grant is created and executed on the ICA to allow the delegate_grantee to send MsgDelegate messages. However, there are several issues with the current implementation:  The grant is constructed with an expiration of 120 years and one month, an excessively long duration.  There is no mechanism to revoke the grant, which could cause issues if the delegate_grantee account needs to be changed.  It allows multiple delegate_grantee accounts to hold the grant simultaneously, which could lead to mismanagement and unauthorized actions.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Iterations over the receivers might run out of gas, failing all distributions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "In contracts/splitter/src/contract.rs:80-89, function iterates over all congured receivers. the execute_distribute If the number of receivers is too large, the operation may consume excessive gas, potentially making the execute_distribute functionality unusable due to gas exhaustion. We are reporting this issue with minor severity since the cardinality of receivers is expected to be limited and only the contract owner has the ability to set them.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Missing validation in the splitter contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "In contracts/splitter/src/contract.rs:21, during the execution of the instantiate function, the splitter contract stores the Config without performing any validation. in Similarly, the ExecuteMsg::UpdateConfig allows the owner to update the splitter contract Config without performing any validation. contracts/splitter/src/contract.rs:53, Specically, the receivers vector should be checked to ensure it does not contain duplicates and only includes valid addresses. Additionally, the amount dened for the fees should be veried to be less than 10000u128.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Centralization and misconguration risks in splitter contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "the splitter conguration is highly In contracts/splitter/src/contract.rs, versatile, allowing arbitrary conguration to route funds and set fee shares as they are collected. This exibility introduces a centralization concern, for example, if administrative errors occur. Consequently, funds could be redistributed incorrectly since distributions are permissionless.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing validation for the timeout parameter in the puppeteer contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "In contracts/puppeteer/src/contract.rs:90, the instantiate function stores the timeout value without performing any validation. This lack of validation can lead to issues if the timeout is set to zero or a relatively small value. Specically, transactions to fail and Interchain Account (ICA) channels to close prematurely. if the timeout is too short, it can cause Inter-Blockchain Communication (IBC)", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Vulnerability in curve25519-dalek package", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "The curve25519-dalek package version in use is vulnerable to timing variability, as reported in RUSTSEC-2024-0344. Timing variability of any kind is problematic when working with potentially secret values such as elliptic curve scalars, and such issues can potentially leak private keys and other secrets. Such a problem was recently discovered in curve25519-dalek. The Scalar29::sub (32-bit) and Scalar52::sub (64-bit) functions contained usage of a mask value inside a loop where LLVM saw an opportunity to insert a branch instruction ( jns on x86) to conditionally bypass this code section when the mask value is set to zero", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Partial support to CW2 contract versioning standard", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "In contracts/splitter/src/contract.rs, the instantiate function is responsible for initializing the contract. However, stores the actual CONTRACT_VERSION. it currently lacks a call to the cw2::set_contract_version function, which This omission can result in diculties with contract version tracking and management.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Use of magic numbers decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf", "body": "In contracts/factory/src/contract.rs:634, a hard-coded number literal is used without context or a description. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attackers can trigger a share ination attack to steal user funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "In ixo-swap/src/contract.rs:265, the get_lp_token_amount_to_mint function mints the LP token amount based on the sent amount if the total supply is zero. This is problematic because attackers can execute a share ination attack to steal funds provided by the user, resulting in a loss of funds scenario. An attack scenario is illustrated below: 1. The contract is newly instantiated", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. The attacker redeems their LP tokens for the underlying liquidity, which includes the users funds. Consequently, the funds provided by the user are stolen by the attacker. Since the LP tokens total supply reverts back to zero after exploitation, the attacker can repeatedly execute this attack to steal funds from subsequent users who provide liquidity to the pool. Please refer reproduce this issue. to the test_share_inflation_attack test case in the appendix to Recommendation We recommend burning a small number of dead shares to the pool contract when providing initial liquidity. Status: Resolved 2. Attackers can swap lower-value tokens for valuable assets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "6. The attacker redeems their LP tokens for the underlying liquidity, which includes the users funds. Consequently, the funds provided by the user are stolen by the attacker. Since the LP tokens total supply reverts back to zero after exploitation, the attacker can repeatedly execute this attack to steal funds from subsequent users who provide liquidity to the pool. Please refer reproduce this issue. to the test_share_inflation_attack test case in the appendix to Recommendation We recommend burning a small number of dead shares to the pool contract when providing initial liquidity. Status: Resolved 2. Attackers can swap lower-value tokens for valuable assets", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Lack of attributes emitted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "In several instances of the codebase, the emitted attributes do not include information about the entry points and values in ixo-swap/src/contract.rs:  The execute_add_liquidity, execute_remove_liquidity, and execute_swap, execute_update_config functions does not emit the action attribute to be the called function. Consider adding the attribute in the response eld, similar to line 241.  The execute_freeze_deposits function should include the freeze value in line execute_pass_through_swap, 241.  The execute_swap function should include the recipient address in line 1117.  The reply entry point should include the LP token address in line 1400. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. execute_freeze_deposits can be called with the same status", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "In ixo-swap/src/contract.rs:227, the execute_freeze_deposits function does not validate that the freeze status is not equal to the FROZEN state status. For example, if the FROZEN state is true, calling the function with freeze value as true will not trigger any actual changes to the contract as the results are the same. Consequently, this may mislead o-chain listeners and indexers since no actual changes are made to the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. FROZEN storage state is not exposed through smart queries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "the query entry point does not expose the In ixo-swap/src/contract.rs:1281, FROZEN storage state value through smart queries. This forces third-party contracts to perform a raw query to read the stored value, which is error-prone and decreases user experience.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unused error message in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "In ixo-swap/src/error.rs:13, the NoneError is dened but not implemented across the codebase. Unused code reduces the code readability and maintainability in the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Panic usage should be avoided", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "ixo-swap/src/token_amount.rs:20 In and get_single functions panic with a plain error message if the provided TokenAmount is incorrect. This decreases user experience as users will not be able to interpret the actual error that occurred. get_multiple and 29, the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Outstanding TODO comment in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "In ixo-swap/src/contract.rs:1323, the query_info function contains a TODO comment to retrieve the total supply. However, the query for the LP tokens total supply has already been implemented in line 1329.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. In-house implementation of well-known features is discouraged", "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf", "body": "In ixo-swap/src/contract.rs:493-505, the validate_input_amount function validates the user sent the actual funds as specied based on the given_amount and given_denom parameters. Although no vulnerability was found aecting the function, well-known libraries that are continuously reviewed by the community. it is still best practice to use", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Liquidation penalty is not validated during struct initialization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/LendingComptroller.cdc:125-127 of the MoneyMarket repository, the liquidation penalty is not validated to be below 1.0 (ie. 100%) during the Market struct initialization. As a result, misconguring the liquidation penalty value might cause a liquidator to receive more funds than intended, causing a loss of funds for the borrower. We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Interest rate model capability is not validated during update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/LendingPool.cdc:959-970 of the MoneyMarket repository, the newly set interest rate model capability is not validated to exist and can be borrowed. As a result, setting a non-existing capability for the interest rate model would cause several accrueInterestReadonly, functions getPoolBorrowRateScaled, and getPoolSupplyAprScaled. getPoolBorrowAprScaled contract notably fail, the to in We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Local resource reference can be used for eciency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/PriceOracle.cdc:128-130 of the Oracle repository, the certificate argument is passed as an OracleCertificate resource reference which is implemented by the OracleInterface contract interface. The certificate is then veried by checking its type against the local OracleCertificate resource to make sure the caller can only be the current contract. This validation can be removed to introduce eciency by only accepting the local OracleCertificate resource reference as an argument.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Feeders can set non expirable prices by changing the expired duration to arbitrary high value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/PriceOracle.cdc:122-124 of the Oracle repository, feeders can set an arbitrary high expired duration which makes their prices non-expirable. With that said, this doesnt directly aect the prices of assets until more than half of the feeders act maliciously and set the expired duration to an arbitrarily high value. We consider this to be a minor issue since this requires more than half of the feeders to be malicious.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Sorting algorithm can be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "the current In cadence/contracts/PriceOracle.cdc:222 of the Oracle repository, sorting algorithm is inecient due to time complexity. Since takeMedianPrice functionality will be called many times, this causes every other operation that is dependent on it to become gas inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Typographical errors found in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "there were In cadence/contracts/PriceOracle.cdc of several typographical errors found in lines 104 and 383. Specically, the word oralce_public should be replaced with oracle_public while the word _ExpriedDuration should be replaced with _ExpiredDuration. the Oracle repository,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Possible chances of path collisions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In the MoneyMarket repository, the following storage and public paths are very generic:  cadence/contracts/LendingPool:1086  cadence/contracts/LendingPool:1088  cadence/contracts/LendingPool:1089 This might lead to path collisions, potentially incorrect data access or resources overwriting.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Undelivered transfers require fee to be refunded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "In packages/xtoken-contract/contracts/base/XTokenBacking.sol:121 and packages/xtoken-contract/contracts/base/XTokenIssuing.sol:82 transfers could fail due to the daily limit set by the DAO. This is not in control of the sender because the limit could be set or consumed after the transfer has been initiated but before it is executed. is free user The a xRollbackBurnAndXUnlock or xRollbackLockAndXIssue. However, covering the protocolFee. the transfer using the function this requires to request refund of It also requires having an account on the target chain, namely _rollbackAccount, to submit the transaction. This condition should be documented properly and made clear to the users of the bridge.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Centralization risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "The contracts contain a few centralization concerns that users should be aware of:  The xToken contracts implement the guard role. While it might be intended as a safety measure to stop an attack after it is deployed and before it is executed, applying it during a real incident creates a lot of post-incident remediation work. This is caused by ultimately replacing all receivers, both on backing and issuing chains, by the guard. After a potential incident all the transfers would require manual completion or manual refund.  The operator role, which is currently an externally owned account set by the DAO, has the privilege to call the pause, unpause, and setProtocolFee functions at any time. This includes disabling slashing, liquidity withdrawals, and setting protocol fees to any amount at any time.  The function updateXToken could be used to make issued tokens non-redeemable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Daily limits are not communicated across the bridge, leading to ineciencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "In packages/xtoken-contract/contracts/base/XTokenBridgeBase.sol:163, the setDailyLimit function is dened and can be used to limit the amount of tokens In particular, this limit is checked via calls to function issued or unlocked during a day. in expendDailyLimit and packages/xtoken-contract/contracts/base/XTokenBacking.sol:121 packages/xtoken-contract/contracts/base/XTokenIssuing.sol:82. When this limit is reached, the transfer can be refunded on the other side of the bridge. However, this introduces several ineciencies, since the following steps are or need to be unnecessarily executed:  the tokens have been locked or burned on the remote chain  the underlying messaging channel has been used to pass the transfer request  the user has spent fees which will not be refunded  one more message passing back across the bridge is needed to refund the tokens  the user needs either to request the refund and cover the protocol fee, or submit a proposal to the DAO which would take time to be processed", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Input validation could be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "In several of functions, the input is not properly validated:  In lockAndXIssue le packages/xtoken-contract/contracts/base/XTokenBacking.sol, is not validated that the amount is greater than zero. A value of zero will revert on the target chain, resulting in wasted gas/transfer costs. within the it  The validation that _amount is greater than zero packages/xtoken-contract/contracts/base/XTokenIssuing.sol:81 should the lockAndXIssue packages/xtoken-contract/contracts/base/XTokenBacking.sol order to avoid the redundant lock. function moved be to in in in  In other functions of the xToken contracts, it is not checked whether the submitted addresses and/or amounts are not equal to zero. This can lead to unintended behavior in out of scope contracts.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. The contract locks up ETH received", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "The XTokenBridgeBase contract is able to receive ETH. However, there is currently no way to retrieve ETH from the contract. The funds will be locked up.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Redundant logic in the updateXToken function when approving xToken", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "The updateXToken function of the XTokenIssuing contract contains the following check: require(IXToken(_xToken).approve(address(this), type(uint256).max) == true, \"approve xtoken failed\"); This check contains a redundant condition which reduces readability and increases the gas fees. There is no need to check whether approve returns true or false, as the require itself already does this.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Excessive storage usage in XTokenBacking contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "In packages/xtoken-contract/contracts/base/XTokenBacking.sol:15 the mapping originalToken2xTokens from type bytes to type address is dened. This mapping is used to store addresses of the mapped tokens. However, the only reading of this mapping in XTokenBacking.sol:63 discards the actual value and only checks that it is not zero. This validation could be done during the address storage.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Transfer state mappings could be streamlined", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": "In packages/xtoken-contract/contracts/base/XTokenBridgeBase.sol:39 the mapping requestInfos is dened. This mapping is used to track if a transfer was requested or refunded. Further, in the same le, in line 44 the mapping filledTransfers is dened, which is used to track the delivered and refunded states of a transfer. These two mappings are used intricately to check all possible cases in the transfer ow. However, all possible states of a transfer could be easily enumerated as REQUESTED, DELIVERED, REFUND_REQUESTED, and REFUNDED.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Miscellaneous", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf", "body": " The parameter name originalSender is misleadingly used in several occurrences, where it is not related to the original token: - - It can mean the party redeemed the xToken in XTokenBacking.sol:114 and XTokenIssuing.sol:134 It can mean a sender on either chain in XTokenBridgeBase.sol:150  There are various typos and grammatical errors in the contracts. We recommend to: - - - - - Replace request exist with this request already exists. Replace request not exist with this request does not exist. Replace request has been refund with this request has already been refunded. Replace issuxToken with issueXToken. Replace not enough fee with not enough fees.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Bridge operator has full control over funds and relies on backend service controlling a hot wallet", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The centralized design of the bridge allows the bridge operator full access to the users funds. This means the operating entity has to be fully trusted since it can withdraw users funds and censor transactions. The design comes with additional security risks in the form of a backend process (MONITOR) that manages the bridge through a single private key, which is used as a hot wallet. In case of the server being compromised and an attacker gaining access to the key, all funds are at risk, and transactions can be censored or executed at will. Furthermore, a potential DoS attack on the MONITOR could block the entire bridge functionality.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Addresses are encoded as string and not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The function receiveTokens takes a string parameter as the destination address. The reasoning behind this seems to be that some receiver blockchains use dierent address encoding. However, this means that addresses are not validated and tokens might be sent to an invalid address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Adding of new blockchains can be front-run to avoid paying the minimal fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "Adding and conguring the support for a new blockchain requires multiple transactions: - addBlockchain - setMinorTokenAmount - setMinGasPrice The function receiveTokens can be called immediately after the rst addBlockchain transaction. Such a call would allow the usage of the bridge with a zero minBRZFee. This attack might be worthwhile for an attacker if a user wants to use the bridge with a high fee.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Unused sender parameter in accept transfer function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "In the acceptTransfer function, the sender parameter is passed but not included in the transaction id calculation. Whilst the sender information does not add security, it might add value to the calculation of the transaction id for o-chain purposes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Outdated dependencies in build- and deployment system", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The build- and deployment system has several outdated dependencies with known security vulnerabilities. Some of these relate to cryptographic primitives used for deployment.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Inecient array data structure for tracking supported blockchains", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The dierent blockchains supported are stored in an array of strings. This requires an iteration of the entire list in functions like existsBlockchain.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Potential data structure optimization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "mapping(string => uint256) private minBRZFee; mapping(string => uint256) private minGasPrice; mapping(string => uint256) private minTokenAmount;", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Oracle functionality mixed with bridge logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The minBRZFee variable is required to calculate fees in the receiveTokens function. The calculation happens on-chain based on quoteETH_BRZ, gasAcceptTransfer and minGasPrice in the _updateMinBRZFee function. Currently, these variables are set by admin calls. In future versions, the quoteETH_BRZ will be provided by oracles, according to the code comments. The contract is already laid out to include oracle support in a future version. However, is not considered best practice due to poor separation of concerns. integrating oracle functionality into the bridge module itself", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Admin role also controls oracle", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The information required to calculate minBRZFee is currently provided by the admin role. This concentrates a lot of functionality in a single private key managed by the admin server (MONITOR).", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Slightly outdated OpenZeppelin release used", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x vulnerabilities. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unnecessary use of modier for authorization on private method", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The private _processTransaction method is covered by access control modiers. Authorization modiers like onlyMonitor or whenNotPaused are only required for external or public methods but not for private ones. In this particular case, they are already covered in the caller function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Unnecessary long digit constant", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "A constant is dened to represent 10^18 for token decimal conversion: uint256 public constant ETH_IN_WEI = 1000000000000000000;", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Gas Optimizations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf", "body": "The contracts can be optimized for more ecient gas usage in multiple places.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Querying all strategies or user strategies of the factory might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2021-08-18 Audit Report - Apollo.pdf", "body": "The factorys GetStrategies and GetUserStrategies queries are using unbounded storage iterators in contracts/apollo-factory/src/state.rs:91 and 132. As more strategies are added to the factory, the gas cost of running those queries does increase. This is not a security concern for Apollo, since those queries are not used anywhere within the current codebase. Other projects could rely on the queries though. If they do, a high amount of strategies could lead to the queries running out of gas.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Failure in the Sudo handler causes funds to be left in the ibc-transfer contract, allowing attackers to steal them", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "Both the Osmosis and Neutron ibc-transfer contracts do not validate the caller of the IbcTransfer message to be the entry-point contract. This is problematic because the entry-point contract is responsible for ensuring the funds are sent according to the specied amount, as seen in contracts/entry-point/src/execute.rs:312-316. Specically, the current ibc-transfer implementation allows the caller to send zero funds while specifying a valid coin amount that exists in the contract. Normally, this should not be a problem since the contract is not intended to hold any funds, as the funds are either sent to refunded back to the recovery address in case of an other chains through IBC or acknowledgment error or timeout. The issue arises when there is an error when refunding the funds to the recovery address. In this case, the funds will be left in the contract and not refunded to the recovery address. This allows an attacker to execute the IbcTransfer message while specifying the coin parameter as the leftover funds and steal them by specifying the receiver as their address on another chain. This is possible because the ibc-transfer contract does not check that the coin parameter is what is provided in the info.funds of the message, as this check is performed by the entry-point contract. The above situation would likely happen when there is an error when refunding the recovery address using the bank message. For example, suppose Neutron governance updates the timeout fee to 0 funds. This would cause the bank message to fail as Cosmos SDK disallows (see amount sending contracts/networks/neutron/ibc-transfer/src/contract.rs:182). funds zero of a Additionally, this might happen when a user calls the ibc-transfer contract directly without going through the entry-point contract. Since the contract assumes the recover_address is validated by the caller in line 84, an error will occur in line 211 if the provided address is invalid. This will create a situation where the ibc-transfer contract is holding funds. Consequently, an attacker can steal funds from the contract by specifying the amount of coin held and sending them over to an address they control on another chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Swap contracts do not perform sender validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "Both the Osmosis and Neutron swap contracts do not validate that the execute_swap function is the entry-point contract. The entry-point contract performs essential validations and properly constructs the Swap message. the caller of is that directly One example of a potential misconguration that could be introduced by calling the swap function in contract create_astroport_swap_msg not does contracts/networks/neutron/swap/src/contract.rs:121-123 enforce a max_spread or minimum_receive value. the entry-point contracts execute_post_swap_action function will eectively enforce a slippage check. If a user calls the swap contract directly, there is no guarantee of the amounts to be received. In contrast, the This in also contracts/networks/osmosis/swap/src/contract.rs:115, as the osmosis swap is not constructed with a token_out_min_amount. exists issue Consequently, users will be exposed to sandwich attacks if they call the swap contracts without going through the entry-point contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Leftovers in contracts allow other users to retrieve them", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "In the entry-point contract, there is validation to ensure all funds are sent over to other chains or contracts. It is important to ensure no leftover funds remain in the contract because anyone can retrieve them. Below we demonstrate several scenarios that will cause funds to remain in the entry-point contract. The contracts/entry-point/src/execute.rs:366-368 ensures verify_and_create_user_swap_msg function that in the required coin_in amount is not greater than the received coin amount. This presents a case where if the coin_in amount is less than the received coin amount, the dierence between them will remain in the contract. The verify_and_create_fee_swap_msg function in lines 415-417 performs a swap for the required fees (presumably for the Neutron chain). Since there is no validation that all swapped fees will be fully used, leftovers might remain in the contract. The verify_and_create_ibc_transfer_adapter_msg function in line 315 will distribute the IBC funds and the post-swapped amount. At the time of writing, Osmosis does not charge fees to perform IBC fund transfers. If the user provided IBC fees, the funds would remain in the contracts/networks/osmosis/ibc-transfer contract. Consequently, excess funds will not be refunded to the user, allowing other users to receive them by performing another swap. We classify this as a major issue because it would only happen due to user miscongurations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. verify_and_create_contract_call_msg does not prevent self-calls", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "verify_and_create_contract_call_msg in The a contracts/entry-point/src/execute.rs:333 contract_call_msg from being constructed that calls the entry-point contract itself or any of the related ibc-transfer or swap contracts for various networks. function prevent does not a While very little can be done with this from an attackers perspective, it is best practice to create the verify_and_create_contract_call_msg function. This might become important as new functionality or new networks are added. As the protocol becomes more complex, this attack vector may be leveraged with other components to create an attack path. addresses blocked that set fail of in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Permissionless TransferFundsBack message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "The contracts/networks/neutron/swap/src/contract.rs:57 contracts/networks/osmosis/swap/src/contract.rs:47 are permissionless. TransferFundsBack messages in and We classify this issue as minor because the swap contracts only hold funds for the span of one transaction, so even though this message is callable by anyone, there won't be any funds It would still be best practice to in the contract to receive under normal circumstances. validate that the only caller of this message should be the contract itself.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. query_simulate_swap_exact_coin_out might return incorrect results if incorrect pair address is provided", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "In the contracts/networks/neutron/swap/src/contract.rs:226-247, query_simulate_swap_exact_coin_out function relies on the provided pool address to reverse-simulate the denom_in amount needed from the denom_out amount. In the current validation, no validation ensures that the pool address holds both denom_in and denom_out assets. If a user provides a pair address that holds the denom_out but not the denom_in, the simulation succeeds with an incorrect denom returned. This is problematic because the coin will return as the operations denom_in amount, not the other pools asset. For example, assume the denom_in is USDC while the denom_out is USDT. Naturally, the provided pool address should point to the USDC-USDT pair. If the user instead provided the OSMO-USDT pair, the simulation would return the amount denominated in OSMO. This is incorrect because the returned coin will be denominated in USDC, misleading users.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. The entry point contracts instantiate function does not check for duplicate swap venues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "In the instantiate function in contracts/entry-point/src/contract.rs:17, msg.swap_venues should be checked for duplicates. Otherwise, when the values are stored in a map, the last duplicated element would overwrite the contract address of the rst. It is best practice to check for duplicates and return errors if they exist such that the caller can revisit the instantiation message to ensure no incorrect state is introduced. We classify this issue as minor because it can only be caused by the contract instantiator.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Unused error in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf", "body": "In contracts/networks/osmosis/swap/src/error.rs, an Overflow error dened, but it is not used. Unused code decreases the readability of the codebase. is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "3. Market timestamp checks market prices Since the Recommendation We recommend performing validation on the posted prices. For instance, there could be a maximum allowed delta per time unit, such that a price of 0 would not be accepted. While this does not fully resolve the centralization issue, privilege abuse would be more involved (and require multiple transactions over a longer timespan). This would allow operators and users to react. Furthermore, bugs in the o-chain bots that result in clearly wrong prices would no longer break the whole system. Alternatively, prices could be aggregated, for example by calculating a time-weighted median price to minimize the impact of a single buggy or compromised bot. Status: Acknowledged 11. PID parameter centralization risk", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2023-04-09 Audit Report - Neptune Protocol v1.0.pdf", "body": "3. Market timestamp checks market prices Since the Recommendation We recommend performing validation on the posted prices. For instance, there could be a maximum allowed delta per time unit, such that a price of 0 would not be accepted. While this does not fully resolve the centralization issue, privilege abuse would be more involved (and require multiple transactions over a longer timespan). This would allow operators and users to react. Furthermore, bugs in the o-chain bots that result in clearly wrong prices would no longer break the whole system. Alternatively, prices could be aggregated, for example by calculating a time-weighted median price to minimize the impact of a single buggy or compromised bot. Status: Acknowledged 11. PID parameter centralization risk", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Lack of propagation of slashes to user deposits may lead to users rushing to unbond since last unbonding users may not be able to receive their stake back", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "The current architecture does not propagate slashes to user deposits, but rather relies on a slashing fund reserve to replenish slashes. That slashing fund is managed by the contract manager. There is currently no logic that reduces any users funds to account for slashes. That makes the whole protocol inherently unstable  any slashing compensation fund will eventually run out of tokens, at which point the last users to undelegate their funds will lose those funds. Rational users will anticipate that loss, which might trigger them to rush to unbond as quickly as possible. The only way to prevent this from happening is a sucient slashing fund reserve, but a rational manager would anticipate that rush and not be incentivized to replenish the reserves. The current slashing compensation is implemented as follows: The validator contracts manager can add or remove slashing funds at any time through the add_slashing_funds and remove_slashing_funds functions. Those funds are tracked in the contracts state in the slashing_funds eld. Whenever rewards are redeemed through the pools contract, the delegations of all validators are queried and a check for slashed validators is performed. If a validator got slashed, the contract uses those slashing_funds to delegate the slashed in contracts/validator/src/contract.rs:309. amount back to the validator their full deposited stake back on undelegation in Independent of slashing, users get contracts/delegator/src/contract.rs:297. As described above, this process makes the Stader protocol unstable. Apart from that, there is another issue: Slashed validators are jailed on Terra, so compensating the slashed amount will not be productive.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Validator removal happens without updating the pools contract, which leads to inconsistent state and implies that removed validators will still receive delegations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "Currently, the only way to remove validators is through the remove_validator function in the validator contract in contracts/validator/src/contract.rs:164. That implies that the validator storage of pools contract will not be updated: Validators are neither removed from the validators vector of PoolRegistryInfo, nor are they removed from the VALIDATOR_REGISTRY. Since removing a validator also leads to a re-delegation of the bonded tokens, these stake changes are not reected in the VALIDATOR_REGISTRY of the pools contract. This has several critical implications: The validator state will be inconsistent between contracts, unbonding through the pools contract will try to unbond from an already unbonded validator, and new deposits through the pools contract will be delegated to a previously removed validator through contracts/pools/src/contract.rs:231.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Rewards are double counted, leading to slashing funds being distributed as rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "In the validator contract, each validator is stored in the VALIDATOR_REGISTRY with their current stake and their accrued rewards. That accrued_rewards eld is incremented in dierent places in the contract, leading to double-counting of rewards instances are contracts/validator/src/contract.rs:238, 321, 394, 410, 490, 691, and 962. Consequently, the total calculated in contracts/validator/src/contract.rs:605 the will swap_and_transfer function transfers too many rewards, distributing funds as rewards that It will also lead to the transfer_reconciled_funds function not returning the error in line 770 even if it is expected to. should be reserved for slashing compensation. collected rewards. actually implies bigger That than that the be", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. First user to deposit rewards into an empty strategy that contains remainder tokens will lose these rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "the contracts/scc/src/helpers.rs:79, In get_strategy_shares_per_token_ratio function returns the default_s_t_ratio in the case where the total tokens in the SIC are zero. It returns zero though in the case where the token balance of the SIC is positive, but the total shares are zero in line 84. That could happen if all deposits have been redeemed, but the SIC still owns a remainder, e. g. from integer division or unclaimed rewards. In such a case, the next user to deposit tokens will not get any shares assigned in contracts/scc/src/contract.rs:1162, and hence lose their deposit.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Multiple reward coins sent to SIC auto-compound and base contracts or coins sent in wrong denom will be locked inaccessibly in contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "check The for in and contracts/sic-auto-compound/src/contract.rs:510 packages/sic-base/src/contract.rs:126 as well as the check for the wrong coin denom in lines 516 and 132 of those respective contracts do not return an Err, but rather Ok, which means that the transactions will not be reverted. Consequently, multiple coins sent multiple coins sent or coins sent in the wrong denom will not be returned, but rather locked inaccessibly in the contract.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Undelegating from a strategy with not sucient funds will lead to users losing (part of) their rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "in contracts/scc/src/contract.rs:487. In the undelegate_from_strategies function in the SCC contract, an iteration over all strategies is performed, sending the UndelegateRewards message for each strategy to its SIC contract. That message species the amount to be unbounded in the next undelegation batch that UndelegateRewards message in the SIC auto-compound contract checks whether enough suce in funds are available and returns an Ok message if contracts/sic-auto-compound/src/contract.rs:571. Since an Ok return value does not revert the transaction, no rewards will be undelegated from the SIC, but the SCC will be updated that the undelegation batch was processed, including updated shares and a new release time for the unbonding. No unbonding happened though, and thus users will not get the funds they should have gotten, with no way to recover. funds do not handler The for", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Replacing a validator that is receiving a redelegation will lead to loss of delegation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "When replacing a validator in the SIC auto-compound contract, only the funds in the in will can_redelegate contracts/sic-auto-compound/src/contract.rs:310. The can_redelegate eld will be zero if the outgoing validator is currently receiving a redelegation, and contain the full delegation amount otherwise. In the case where the outgoing validator receives a redelegation, no funds will be redelegated, but the validator will still be removed from the redelegated eld be validator_pool list in line 337. The delegation amount and the received redelegation will be locked in the pool due to the condition in line 268.", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Usage of stored rather than queried delegation amounts may lead to an inconsistent state when unbonding", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "The current logic that processes undelegation batches in the pool contract iterates over a pools validators in contracts/pools/src/contract.rs:413 to undelegate enough stake to satisfy the amount requested from users. That logic uses the stored stake of validators, rather than querying the currently delegated funds. This is problematic, since validators might have been slashed/jailed or decided to unbond since the storage was last updated. In those cases, the actual undelegated amount would be smaller than the amount requested by users, since Cosmos SDK caps the undelegated amount to the available amount, rather than returning an error. The pools contract would not be aware of the discrepancy, and the stored stake would be inconsistent with actual delegations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Util functions iterating over unordered hash maps may lead to Terra node consensus failures", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "The map_to_coin_vec and map_to_deccoin_vec functions iterate over the keys of a HashMap in packages/stader-utils/src/coin_utils.rs:111, 121 as well as in packages/sic-base/src/helpers.rs:184. Since HashMap keys are returned in an arbitrary order, the resulting vector has an arbitrary order of its entries. That could lead to dierent stored data in the contract storage between Terra nodes, which might cause consensus failures.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Conict of permissioning prevents feeder from submitting prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "When feeding prices into a price feed the contract checks that the owner is the sender of the message in contracts/oracle-proxy-feed/src/contract.rs:125. Subsequently when pushing prices to the relevant asset feeds the contract checks whether the message sender is a registered feeder in line 143. This means that only the contract owner who also is the feeder can submit prices to the feeder contracts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Incorrect price list query in oracle hub", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "hub oracle in The the query_proxy_list contracts/oracle-hub/src/contract.rs:70 function. This incorrectly returns a list of the registered proxies for a specic asset token and not the latest prices. message calls PriceList query", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Unbounded number of oracle proxies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The number of proxies that can be registered to the oracle hub is unbounded in contracts/oracle-hub/src/state.rs:39. Having a potentially large number of proxies would make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Oracle query functions contain unbounded loops", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "and Band Chainlink The contracts/oracle-proxy-band/src/contract.rs:172 contracts/oracle-proxy-chainlink/src/contract.rs:164. signicant computational resources leading to issues in the calling contracts. functions contain query unbounded loops in and They may use", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Sorting proxy list on every query is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "Every call to query_price in contracts/oracle-hub/src/query.rs:54, 84 and 118 sorts the proxy list. Doing so on every call is computationally inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Legacy price response returns last updated value for quote price in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The LegacyPriceResponse contains u64::MAX for the last_updated_quote in contracts/oracle-hub/src/query.rs:126. A last updated quote value in the future may be unexpected to callers of the query and may cause errors in calling contract if that edge case is not handled.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "Packages contracts/oracle-proxy-band/Cargo.toml, contracts/oracle-proxy-chainlink/Cargo.toml, contracts/oracle-proxy-feed/Cargo.toml packages/tefi-oracle/Cargo.toml do not enable overflow-checks for release prole. contracts/oracle-hub/Cargo.toml, and the While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Oracle price query variable naming may be confusing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:38 exposes a eld named timeframe, which does not clearly communicate the intent of the eld. Moreover, it is not obvious whether timeframe should be provided in seconds, blocks or the API should be as another unit. Since the oracle may be used by many projects, self-explanatory as possible.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Legacy price query does not support dierent bases", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:102 takes both a base and quote asset as an argument. However, if the quote asset is not base_denom the contract throws an error in line 108. This makes the API less user-friendly as requests for prices the oracle has access to would be rejected unexpectedly.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. The unused the PromiseResult::Failed case when minting ROUTE tokens fails leads to skipping event_nonce incremented previously but in event nonces and results in attestation issues within Router Chain as the nonce is supposed to be sequential without gaps. 2. If decoding the result in the handle_execute_handler_calls_callback in function gateway-contracts:near/gateway-upgradeable/src/lib.rs:925 fails, the previously incremented event_nonce remains unused and leads to gaps in the emitted event nonces and thus attestation issues. Status: Resolved 3. ROUTE tokens are not minted for invalid requests, causing a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router EVM and NEAR Gateway Contracts and WASM Bindings v1.0.pdf", "body": "In gateway-contracts:near/gateway-upgradeable/src/lib.rs:689-714, an IReceiveEvent event will be emitted as a failure when the ASM contract returns the request as invalid. In this case, the ROUTE tokens are not minted to the user. This is incorrect because the ROUTE tokens should be minted even if the is_valid_request value is false. Consequently, the route recipient will not receive the expected route amount, causing a loss of funds.", "labels": ["Oak Security", "Severity: High"]}, {"title": "1. Voting and unlocking tokens may fail due to an out-of-gas error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf", "body": "unlock_tokens in The contracts/atom_wars/src/contract.rs:495-512 and 284-293, respectively, iterate over all entries in the LOCKS_MAP state for the caller. This is problematic because if the user locks too many tokens in contracts/atom_wars/src/contract.rs:159, an out-of-gas error will occur when iterating the locks. functions vote and This may happen when users try to smoothen their power multiplier or if other contracts implement proxy voting. Consequently, users cannot vote on proposals and unlock their tokens, causing a loss of funds.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Unnished development", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf", "body": "In a few instances of the codebase, there seems to be unnished development accompanied by TODO comments. there is no entry point to execute a proposal as it Firstly, in contracts/atom_wars/src/contract.rs:116-118. This causes the executed eld to become false, as seen in contracts/atom_wars/src/state.rs:40. There may be future logic that needs to be implemented, such as quorum participation validation that inuences the proposal outcome. is commented out in contracts/atom_wars/src/contract.rs:338-341, the Secondly, validate_covenant_params function does not perform any validation although the function name indicates that validation will be performed. This is problematic because if a user votes on a proposal with non-whitelisted CovenantParams, they will not be able to claim their tribute allocation in contracts/tribute/src/contract.rs:180-187. The TopNProposals query will exclude it seen in contracts/atom_wars/src/contract.rs:787-796. from the top proposals, as", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Missing lock_epoch_length and round_length validations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf", "body": "In contracts/atom_wars/src/contract.rs:46, msg.lock_epoch_length and msg.round_length are not validated to be within a reasonable range. Misconguring these values may cause users to have little time to vote on proposals, aecting the protocols intended functionality.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. RoundProposals query may fail due to running out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf", "body": "contracts/atom_wars/src/contract.rs:756-757, In tranche_proposals function does not queries PROPOSAL_MAP for the current round/tranche combination. query_round_ implement a pagination mechanism when it the Since anyone can create proposals, a malicious user can intentionally create many proposals, causing this query to fail due to an out-of-gas error and aecting third-party protocols that integrate with it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. ProposalTributes query will not return legitimate tributes if the total tributes are larger than DEFAULT_MAX_ENTRIES", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf", "body": "the query_proposal_tributes In contracts/tribute/src/contract.rs:320, function returns an array of tributes stored in the contract. However, if the total number of tributes is larger than DEFAULT_MAX_ENTRIES, any tributes added after that will not be returned to the caller. This issue can be exploited by a malicious user who submits DEFAULT_MAX_ENTRIES + 1 fake tributes to the contract to prevent external services from retrieving any legitimate tributes added after that. A similar issue exists in contracts/atom_wars/src/contract.rs:846, aecting the query_user_lockups function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Vulnerable dependency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf", "body": "One of the dependencies of the audited code is aected by a publicly known security vulnerability:  RUSTSEC-2024-0344 We classify this issue as minor as we did not nd exploitable instances in the audited codebase. Further details on the outdated libraries can be found i", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. app.dart: Logging of sensitive information possible", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "In initCrashlytics, the following error handler is congured to record utter errors in Firebase: FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError; This conguration applies to the whole app and therefore also the wallet part. There, it is possible that sensitive information (mnemonic, private key) are included in a stack trace and sent to rebase. When an account that has access to these information is breached, an attacker can steal all coins that belong to these wallets, which happened in the past.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. No limit for unsuccessful PIN entries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "The wallet is protected by a 6-digit PIN, meaning there are 1,000,000 possible combinations (and roughly 3,000 of them are invalid because of the complexity requirements). Therefore, it will take on average 498,500 tries to nd the correct PIN, meaning a brute force attack is feasible. The wallet currently does not enforce an upper limit on the number of tries and also does not implement a measure like an exponential backo to protect users against such attacks.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Disconnecting the wallet does not require the PIN", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "When a user wants to disconnect his current wallet, he is not asked for the PIN. While this may be desirable from a UX perspective, disconnecting a wallet is a sensitive operation with potential nancial eects. For instance, when the user did not backup the wallet previously, he will lose access to the coins in the wallet.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. security_manager.dart: Initialization vector reuse in AES CBC mode", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "In onPinCodeChanged, the old key is decrypted with the old PIN and the resulting plain text then encrypted again with the new PIN. Because SecretKeyEncryptor._getInitVector returns the current initialization vector (if one exists), the same IV is used for both operations, which should not be done in AES CBC mode.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. wallet_address.dart: Insecure mnemonic generation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "To generate a mnemonic, the function generateMnemonic of the package bip39 is used. This library does not generate the mnemonic in a cryptographically secure way because of an o-by-one error: It calls _randomBytes within generateMnemonic. The _randomBytes function calls nextInt(_SIZE_BYTE) on the Random.secure() PRNG to get a random byte. This function generates random integers from 0, inclusive, to the provided maximum, exclusive. Because _SIZE_BYTE is set to 255, there is therefore no way that _randomBytes returns the value 255, meaning non-uniform randomness is used to generate the mnemonic.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. wallet_transaction_bloc.dart: Unnecessary gas estimation for FCD transfers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf", "body": "In _transferFromConnectedToExternal, the gas limit for FCD transfers is estimated. This value is then passed to fcdWallet.transfer, which further passes it to _contractService.send. However, because ContractService.send has a hard-coded limit of 62,000 for FCD transfers, the whole estimation is unnecessary and never used.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Instantiator may introduce misconguration by providing non-compliant proxy code_id", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Public Awesome/2023-01-27 Audit Report - ICS721 v1.0.pdf", "body": "function instantiate in The contracts/cw-ics721-bridge/src/contract.rs:26 does not check to ensure that the proxy code_id specied is a compliant cw721-proxy contract. The functionality for the INSTANTIATE_PROXY_REPLY_ID reply is generic contract instantiation logic which does not conrm that the contract is compliant. While it is unlikely that the instantiator of the contract would unknowingly introduce a misconguration by providing an invalid proxy, the impact of this would be that NFTs could be sent from other chains to this bridge and debt vouchers could be minted, but they would be unredeemable if the proxy contract did not support the correct interface to allow for NFTs to be sent back to their origin chain. This could be corrected by a migration to a compliant proxy contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Missing restriction on direct deposits to VirtualFrontierBankContract contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf", "body": "In the ethermint:app/ante/eth.go:392-433, NewVirtualFrontierContractDecorator AnteHandler decorator denies users from depositing coins into VirtualFrontierBankContract contracts by rejecting Ethereum transactions with a non-zero value. However, it is still possible to send funds to VirtualFrontierBankContract contracts through the Bank module. As a consequence, while direct deposits are prevented, alternative methods for transferring funds remain accessible.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Attackers can DoS the chain by sending multiple IBC coins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf", "body": "if the current chain id is prexed with i.e., denoting that the chain is some sort of testnet, the BeginBlocker the In ethermint:x/evm/keeper/abci.go:30-34, ethermint_, executes DeployVirtualFrontierBankContractForAllBankDenomMetadataRecords function. This function iterates through all the DenomMetaData retrieved from the Bank module, new marked identifying VirtualFrontierBankContract for each of them. deploying denoms, those /ibc with and a As a consequence, attackers could exploit this process by initiating a large volume of ICS-20 transfers, causing the chain to store a substantial amount of DenomMetaData items during packet processing in ibc-go. This could lead to a slowdown of nodes, consensus timeouts, and, potentially, halts of the chain. We classify this issue as minor because this feature is only activated on the Ethermint dev chain.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Long-term DenomMetaData accumulation can DoS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf", "body": "ethermint:x/evm/keeper/virtual_frontier_contract.go:128-158, In DeployVirtualFrontierBankContractForAllBankDenomMetadataRecords function is called in the BeginBlocker, iterating through all DenomMetaData in the Bank module using IterateAllDenomMetaData. the However, as the quantity of DenomMetaData grows over time, this process increasingly slows down the blockchain, potentially leading to consensus timeouts and chain halts in the long run. We classify this issue as minor because this feature is only activated on the Ethermint dev chain.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Faulty DenomMetadata halts VirtualFrontierContracts deployment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf", "body": "ethermint:x/evm/keeper/virtual_frontier_contract.go:177-192, In function DeployVirtualFrontierBankContractForAllBankDenomMetadataRecords iterates through all the new DenomMetadata and deploys a VirtualFrontierContract for each one using the DeployNewVirtualFrontierBankContract function. the These actions are rst applied to a new temporary context, cachedCtx, before the state changes are committed all at once in the defer function. However, if a single deployment errors, all subsequent deployments will not be committed in the context. As a result, the presence of faulty DenomMetadata can halt the entire module from further deploying any VirtualFrontierContract contracts. We classify this issue as minor because this feature is only activated on the Ethermint dev chain.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Attackers can front-run transactions to steal user funds after approving allowances", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In evm/contracts/AssetBridge.sol:602, the stake function allows the owner to specify the from parameter, representing which users allowance will be consumed, as seen in line 614. This is problematic because users typically approve the contract to use their allowance before calling the contract. this issue by front-running the victim after they approve the An attacker can exploit transaction but before they call the AssetBridge contract. The attacker will call the stake function by specifying the from parameter as the victim's address, the to parameter as the attackers address, and the approved token address and amount. This will consume the victims allowance and consume their funds, but the liquidity token is minted to the attacker. This issue is also present in the unstake function in lines 625 and 629. If the approved token is the liquidity token, the attacker can front-run and call the unstake function to consume the victims liquidity token allowance and receive the underlying tokens in return, causing a loss of funds scenario.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can prot by depositing dierent tokens and withdrawing as native tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In evm/contracts/AssetBridge.sol:624-627, the unstake function allows the caller to withdraw native tokens by specifying the isSourceNative parameter as true. This is problematic because attackers can provide non-ETH tokens and withdraw them as native tokens and prot from price dierences. For example, assume the attacker staked 10 TRX and received 10 TRX liquidity tokens. The price of TRX is $0.094, so the attackers cost would be $0.94. The TRX token uses decimal values of 6. then calls the unstake function with all 10 TRX and species the The attacker isSourceNative parameter as true. In decimal terms, the attacker sends 10*10^6 TRX and receives 10*10^6 wei in return, which translates to $197. After deducting the attackers cost, the attacker gains a prot of $196.06 per transaction. This prot can be leveraged to a higher value by using tokens with lower prices and higher decimal values and repeatedly performing the attack until all wrapped native tokens are stolen in the contract. Consequently, all wrapped native tokens in the contract can be stolen, causing a loss of funds scenario.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Attackers can register and deregister their accounts for prot", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In near/contracts/token/src/lib.rs:109, the register function registers the account in the fungible token contract after the caller paid 1 yoctoNEAR. This is problematic because with storage_balance_bounds().min.0, yoctoNEAR. unregistering account storage refunds which caller the the is Consequently, an attacker can steal the funds by repeatedly calling register and storage_unregister functions to prot from the account storage refunds, causing a loss of funds for the account owner. This issue also exists in near/contracts/lp-token/src/lib.rs:193, with the dierence that the user does not need to pay any funds to register their account.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Inability to decode request packet payload due to incorrect indexes results in failed cross-chain requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In decode_ireceive_deposit, near/contracts/asset-bridge/src/utils.rs, decode_ireceive_execute_with_message, the and decode_stake_payload utility functions decode the received cross-chain request packet payload and return the decoded values. However, in the following instances, incorrect indexes are used to access the decoded values, resulting in a panic since the expected and actual types do not match:  Line 250 should parse decoded_data[2] for the tuple.  Line 476 should parse decoded_data[3] for the instruction bytes.  Line 618 should parse decoded_data[3] for the recipient. Additionally, line 215 decodes the tuple as destTokenAmount, destTokenAddress, isDestNative, depositNonce, and recipient. However, in lines 258-305, the tuple is accessed as sender, src_token, src_amount, and deposit_nonce. This is incorrect because the tuples length and variable types are incorrectly used, causing the decoding to fail.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Refunding fails due to set_execute_revert_record function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "near/contracts/asset-bridge/src/setters.rs:34-40, the In the set_execute_revert_record execution_revert_completed map and validates that it equals the provided status parameter in line 32. This is problematic because a panic will occur for new key entries, and the assertion will fail if the status is updated to a dierent value for existing entries. function unwrap value tries the to in the i_receive in Firstly, near/contracts/asset-bridge/src/execution.rs:312 will fail because the destination chain ID and deposit nonce key entry are never stored before in the execution_revert_completed map. This will cause the insert function to return None in near/contracts/asset-bridge/src/setters.rs:37 and panic when the unwrap function is called. Consequently, the refund mechanism will fail to work properly. function the unlock_ireceive_fn in Secondly, calls near/contracts/asset-bridge/src/execution.rs:146 set_execute_revert_record to revert the execute record to false in case promises fail so the action can be retried later. As the key entrys value was previously set to true, the insert function will return Some(true) and unwrap it. Consequently, the assertion will fail in near/contracts/asset-bridge/src/setters.rs:39 because it expects the status to be false, which is incorrect. function", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. NEAR tokens are incorrectly transferred to the gateway contract instead of being escrowed in the AssetBridge contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "near/contracts/asset-bridge/src/call_gateway.rs:71, In i_send function sends all the attached NEAR tokens to the gateway contract. This is incorrect because only i_send_default_fee should be sent to the gateway contract to cover the fees, while the remaining funds should remain in the contract. the Consequently, the asset-bridge contract will have insucient liquidity for user token redemption, forcing users to wait for the contract owner to withdraw the funds from the gateway contract in order to unstake their LP tokens.", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Fungible token refunds will fail, causing a loss of funds for users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In the near/contracts/asset-bridge/src/call_gateway.rs:164, i_send_callback function calls ft_transfer to refund tokens to the sender if the gateway contracts i_send call fails. This is problematic because no deposits are attached, causing the transaction to fail because the NEAR SDK requires one yoctoNEAR to be sent. Consequently, the fungible token refund fails, causing a loss of funds for the sender.", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Payable keyword is not specied on functions that expect funds to be sent", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In evm/contracts/AssetBridge.sol:194-196, the setDappMetadata function allows the resource owner to call the setDappMetadata function in the gateway contract. Since no native funds are included, the transaction will fail if the iSendDefaultFee fee amount in the gateway contract is greater than zero. this that, issue also exists Besides in near/contracts/asset-bridge/src/call_gateway.rs:21. Since the payable keyword is not implemented, the set_dapp_metadata function cannot receive funds, causing the transaction to fail if the i_send_default_fee fee amount is greater than zero. in the NEAR asset-bridge contract the Lastly, in unstake near/contracts/asset-bridge/src/execution.rs:703 expects the caller to send three yoctoNEAR. This condition cannot be satised because the payable keyword is not implemented, causing the unstake function always to fail. function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Native funds cannot be attached on ft_on_transfer calls", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In the near/contracts/asset-bridge/src/execution.rs:26-28, ft_on_transfer function implements the payable annotation because it expects native funds to be attached. This is problematic because when a user calls ft_transfer_call from a fungible token contract, native funds cannot be attached, preventing the asset-bridge contract from working properly. the function i_send in Firstly, near/contracts/asset-bridge/src/call_gateway.rs:71 in order to pay the i_send_default_fee fees in the gateway contract. Since native funds cannot be attached, the actual fees sent will be zero, causing token transfers to fail if the fee amount is larger than zero. attached deposits includes all in Secondly, near/contracts/asset-bridge/src/execution.rs:669 expects the user to send stake_token function the three yoctoNEAR. As fungible tokens cannot include any deposits, the transaction will fail in line 109, preventing users from staking the fungible token for liquidity tokens.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Unstaking liquidity token fails due to incorrect token parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In evm/contracts/AssetBridge.sol:625, 629, and 630, the unstake function uses incorrect tokens to call the burnFrom and safeTransferFrom functions. This function is called when users want to burn their liquidity token to redeem the underlying token. Firstly, in lines 625 and 629, the _contractToLP mapping is called on the tokenAddress parameter. Since the mapping is used to retrieve the underlying tokens liquidity token, the transaction will fail because the provided tokenAddress is already the liquidity token. Hence, it is unnecessary to use the mapping. Secondly, in line 630, the safeTransferFrom function transfers the tokenAddress to the user after burning the liquidity tokens. This is incorrect because the liquidity tokens are instead of the underlying token, which can be retrieved via the _lpToContract sent mapping. Consequently, the transaction will fail because the contract holds no liquidity tokens after burning them.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. Failed cross-chain requests cannot be retried", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "execute_failed_request in The middleware/contracts/asset-bridge/src/execution.rs:493-510 handles the ExecuteMsg::ExecuteFailedReq message, which allows the owner of the CosmWasm asset-bridge middleware contract to retry and execute a previously failed cross-chain request. function To ensure that only failed requests can be retried, the status of the received acknowledgment is retrieved from the ACK_STATUS storage map. If the status is false, signaling a failed cross-chain request, the request is supposed to be retried. However, this check is incorrectly performed in line 501 as the assert_ne! macro asserts that the status is not equal to false, which is the opposite of the intended behavior. As a result, failed cross-chain requests can not be retried and remain stuck.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "12. Unsafe conversion from uint256 to uint128 in asset-bridge middleware", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In the middleware/contracts/asset-bridge/src/handle_inbound.rs:129, handle_evm_inbound_request function decodes the widget_id from the received the Solidity payload and attempts to convert AssetBridge contract denes the widget ID parameter as uint256. This results in a panic if the provided value is larger than uint128 and halts the execution of the inbound request, causing the locked funds on the source chain to be unrecoverable by the user. the uint value to uint128. However, As this widget ID is provided by the user or by a widget integration, the ID may be incorrectly or maliciously set to a large value, causing the request to fail in the middleware contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "13. The same gas limit is used for all destination chains, resulting in out-of-gas errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In the following instances, the asset-bridge middleware contract determines the required gas limit for a cross-chain request by calling the fetch_st_gas_limit function:  middleware/contracts/asset-bridge/src/execution.rs:478  middleware/contracts/asset-bridge/src/handle_inbound.rs:139  middleware/contracts/asset-bridge/src/handle_inbound.rs:305 However, the gas limit is not congured on a per-chain basis. Instead, the same gas limit is used for all chains. Consequently, cross-chain requests may fail on the destination chain due to an out-of-gas error. Similarly, in middleware/contracts/asset-bridge/src/handle_revert.rs:64 is hardcoded to 150000. limit gas the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "14. Unable to process refund requests on the source chain due to missing parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "If processing the inbound request in the asset-bridge middleware results in an error, the in revert_inbound_to_src_chain middleware/contracts/asset-bridge/src/handle_revert.rs:16-96 initiates a refund request to the source chain. function However, the constructed request packet payload in lines 36-40 is missing important parameters that are required by the AssetBridge Solidity and NEAR contracts. Specically, the sender address, source token address, and source token amount, specied in the in DepositData and evm/contracts/interfaces/IAssetBridge.sol:63-68 near/contracts/asset-bridge/src/types.rs:56-61 are not included in the payload. As a result, the refund request packet can not be decoded on the source chain, and the refund can not be processed, thus locking the user's funds on the source chain. ExecuteInfoArgs structs and", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "15. The reentrancy lock mechanism in the NEAR AssetBridge contract can be abused to grief the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "The ft_on_transfer function in the NEAR AssetBridge contract employs a reentrancy lock mechanism to prevent calling the same function in between callbacks, which are not executed immediately but rather after 1 or 2 blocks. This is achieved using a mutex, which is set to true at the beginning of the function and false at the very end once all callbacks have been executed. If this mutex is set to true at the start of the function execution, the call panics. Specically, in near/contracts/asset-bridge/src/execution.rs:50-51 and 74-75, the lock variables are set to true, preventing the function from being repeatedly called. Once the last callback function is executed, the locks are released. However, this lock mechanism opens up a potential Denial-of-Service (DoS) vector, as it eectively rate-limits the contract on a per-function basis. For example, an attacker can spam with many consecutive function calls every 1-2 blocks, using as little funds as possible and thus preventing any other legitimate contract calls. While it is evident that the use of such a lock mechanism is intended to prevent reentrancy attacks, broadly applying this mechanism to all functions and blocking the functionality for a few blocks is not a suitable solution.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "16. Native token transfers always fail due to improper balance check query", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "evm/contracts/AssetBridge.sol:582, In the executeProposalForReserveToken function for native tokens will fail. This is because before initiating the token transfer, the contract checks its balance by calling the balanceOf function on the token's address. calling The issue here is that the contract employs the 0xEeee address to represent native tokens. However, 0xEee... is not associated with an existing contract on the Ethereum network. Consequently, this balance check operation reverts, causing native token transfers to fail.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "17. Lowercasing case-sensitive addresses causes unexpected behavior and incorrect outbound calls", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In the CosmWasm middleware contract, a critical problem exists related to address-casing sensitivity. This issue leads to unexpected and incorrect behavior, particularly when dealing with addresses from chains that employ case-sensitive address formats, such as TRON, Solana, and Polkadot. The middleware contract keeps track of asset-bridge contracts for various chains, which may use dierent address formats. For instance, when calling the WhiteListAddresses message, the supplied contract address in converted Subsequently, middleware/contracts/asset-bridge/src/execution.rs:101. the whitelisted contract is incorrect because it belongs to a dierent TRON contract address. lowercase to is", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "18. Unintended refund due to TEMP_REVERT_STATE not being cleared and incorrectly calling of revert_inbound_to_src_chain on minting gas tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "In middleware/contracts/asset-bridge/src/handle_inbound.rs:138, 209, 304, and 373, the TEMP_REVERT_STATE storage is used to store temporary information for reverting or refunding tokens to the sender in case an outbound request on the destination chain fails. The issue is that the TEMP_REVERT_STATE storage is never appropriately cleared after the transaction is completed, causing incorrect refunds when the owner calls in mint_gas_tokens middleware/contracts/asset-bridge/src/execution.rs:480. If the send_reserve_outbound_request function (called inside mint_gas_tokens) enters middleware/contracts/asset-bridge/src/submit_outbound.rs:36, it will the revert_inbound_to_src_chain function to issue a refund in middleware/contracts/asset-bridge/src/handle_revert.rs:30, which uses the uncleared TEMP_REVERT_STATE storage state that hold previous values. call Consequently, an outbound request will be created using the previous data stored in TEMP_REVERT_STATE, causing the tokens to be incorrectly refunded and a loss of funds scenario for the contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "19. Callback functions may run out of gas, resulting in inconsistent states of the NEAR asset-bridge contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf", "body": "instances of the NEAR codebase in near/contracts/asset-bridge, In several callbacks are implemented to handle promise results. As no validation ensures the supplied prepaid gas is sucient for executing all promises, some callbacks might fail to execute due to an out-of-gas error. the Firstly, in i_send_callback near/contracts/asset-bridge/src/call_gateway.rs:81 is allocated with 5 * TGAS. This is problematic because line 159 tries to allocate the exact amount of gas if the promise fails to refund the tokens to the user. Consequently, the refund will fail, and the function reentrancy lock in line 168 cannot be unlocked, causing a loss of funds and future token transfers to fail. the handle_itransfer_burn_callback Secondly, in near/contracts/asset-bridge/src/execution.rs:183 does not enforce any static gas limit before initiating the callback. Ideally, there should be at least 15 * TGAS reserved because the i_send and i_send_callback functions allocate gas in near/contracts/asset-bridge/src/call_gateway.rs:72, lines 81, and 159. function the Thirdly, in handle_ireceive_callback near/contracts/asset-bridge/src/execution.rs:342, lines 462 and 525 does not enforce sucient gas limit. The former does not enforce any gas limit, while the latter only allocates 5 * TGAS. This is insucient because a total of 10 * TGAS needs to be allocated in lines 568 and 576, causing the transaction to fail due to an out-of-gas error and not reverting the reentrancy lock. function Fourthly, the handle_ireceive_ft_get_balance_callback function in line 364 does not enforce any static gas limit. Ideally, there should be at least 15 * TGAS allocated due to lines 504, 568, and 576. This might cause the reentrancy lock to fail to revert, or cause the event to fail to emit by the handle_event_by_tx_type function. Lastly, the handle_unstake_callback function in line 718 also does not enforce any static gas limit. This might cause the liquidity token redemption or refund to fail, but the users liquidity tokens are already burned, causing a loss of funds scenario.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Harvest message can be sandwiched to skim rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "The Harvest operation in contracts/martian-field/src/contract.rs:23-26 claims rewards from the Astroport generator and then, after treasury fees have been applied, sells ASTRO to rebalance between the primary and secondary assets (in two steps). Since the Harvest message is permissionless and can be called by anyone, there is an opportunity in contracts/martian-field/src/execute.rs:210. skim the operation, reducing bonded amount total the to An example of the arbitrage attack to skim rewards would be the following, executed as a single transaction: 1. User swaps ASTRO for the primary asset", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Go to step 1 when ASTRO rewards have accrued. Bots could perpetually exploit this arbitrage if it were economically viable, hindering the overall nancial performance of the Field of Mars protocol. Recommendation We recommend making the Harvest operation permissioned, to reduce the opportunity for arbitrage. Alternatively, the team/community could aim to call the Harvest function with enough frequency so the arbitrage attack is not economically feasible due to transaction fees, but this is also dependent on the ASTRO rewards claimed. Status: Resolved 2. High spread might cause swapped primary asset not enough to cover users debt", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "4. Go to step 1 when ASTRO rewards have accrued. Bots could perpetually exploit this arbitrage if it were economically viable, hindering the overall nancial performance of the Field of Mars protocol. Recommendation We recommend making the Harvest operation permissioned, to reduce the opportunity for arbitrage. Alternatively, the team/community could aim to call the Harvest function with enough frequency so the arbitrage attack is not economically feasible due to transaction fees, but this is also dependent on the ASTRO rewards claimed. Status: Resolved 2. High spread might cause swapped primary asset not enough to cover users debt", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Tax deduction logic is not implemented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf", "body": "The Field of Mars contract uses the cw-asset library as a dependency, to facilitate the handling of both CW20 and native assets. The cw-asset library does not account for Terra taxes logic, which may cause forward-compatibility issues in the future. Even though the tax rate is currently set to zero, the tax mechanism itself has not been removed. Whilst unlikely, a future governance vote might decide to make use of the mechanism again and augment the tax as provide_liquidity() in martian-field/src/execute_callbacks.rs:18, potentially causing the loss of native contract funds due to accounting errors, and/or panics. rate, which would functions aect such", "labels": ["Oak Security", "Severity: Low"]}]