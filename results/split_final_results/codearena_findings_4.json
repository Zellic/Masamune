[{"title": "Use of uint8 for counter in for loop increases gas costs", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  On L158 of swap.sol, you use a uint8 as the for loop variable:  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  "}, {"title": "Redundant hardhat console import ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  You import \"import \"./hardhat/console.sol\";\" and all uses are commented. You should also comment the import. SwapUtils line 9  "}, {"title": "Use calldata instead of memory for function parameters", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  (non-exhaustive) List of Examples: SwapUtils line 639 USDPoolDelegator line 53 Swap.sol line 135   "}, {"title": "unnecessary variable y in getYD ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  You could use the variable d instead of defining a new variable y at line 548 of SwapUtils.sol  "}, {"title": "Missing revert message", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/168", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  Missing revert messages in the following places:  1.  ETHPoolDelegator line 67 2.  BTCPoolDelegator line 67 3.  USDPoolDelegator lines 55, 56  "}, {"title": "Usage of deprecated safeApprove", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/166", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  safeApprove is now deprecated, see the link below. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38.  This appears for example in line 499 of AirdropDistribution.sol.  we recommend as in OpenZepplin documentation \u201cwhenever possible, use safeIncreaseAllowance and safeDecreaseAllowance instead\u201d.     "}, {"title": "Constants should be written in UPPER_CASE", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/165", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Constants should be written in UPPER_CASE, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#constants).  Constants breaking this convention:  - `decimals` in `tge/contracts/PublicSale.sol` - `coin` in `tge/contracts/PublicSale.sol` - `secondsPerDay` in `tge/contracts/PublicSale.sol` - `firstEra` in `tge/contracts/PublicSale.sol`  "}, {"title": "Contract `Vesting` should inherit from interface `IVesting`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/164", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Contract `Vesting` in `vesting/contracts/Vesting.sol` should inherit from the interface `IVesting` in `vesting/contracts/interfaces/IVesting.sol` as the contract implements the interface.  "}, {"title": "Functions should be written in mixedCase", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/163", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Functions should be written in mixedCase, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#function-names).  Functions breaking this convention:  - Function `_available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `_available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `dev_rugpull` in `vesting/contracts/InvestorDistribution.sol`  "}, {"title": "Events should be written in CapWords", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Events should be written in CapWords, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#event-names).  Events breaking this convention:  - `updateMiningParameters` in `vesting/contracts/AidropDistribution.sol` - `updateMiningParameters` in `vesting/contracts/InvestorDistribution.sol`  "}, {"title": "Remove unused variables", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Removing unused variables saves gas and increases code clarity.  Following variables are unused and can be removed:  - `Hour` in `vesting/contracts/AidropDistribution.sol` - `Day` in `vesting/contracts/AirdropDistribution.sol` - `Hour` in `vesting/contracts/InvestorDistribution.sol` - `Day` in `vesting/contracts/InvestorDistribution.sol` - `_balance` in `tge/contracts/PublicSale.sol` - `_allowance` in `tge/contracts/PublicSale.sol`  "}, {"title": "safeERC20 library imported but not used", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  loop   # Vulnerability details  `AirDropDistribution.sol` and `InvestorDistribution.sol` import the `safeERC20` library but make use of the normal ERC20 `transfer` function rather than `safeTransfer`. Considering this is called on the BOOT token there is likely no need for it to be `safeTransfer`. However, since the library is not used there is no need for it to be imported.   ## Proof of Concept - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L12 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L12  Transfer calls: - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L542 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L567  - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L132 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L156 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L207  "}, {"title": "Ideal balance is not calculated correctly when providing imbalanced liquidity", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/150", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.  Take, for example, if there's 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.  However, if the customSwap pool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI. [SwapUtils.sol#L1227-L1245](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1227-L1245) The current implementation does not calculates ideal balance correctly.  If the target price is set to be 10, the ideal balance deviates by 10. The fee deviates a lot. I consider this is a high-risk issues.  ## Proof of Concept We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.  For the first pool, we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  For the second pool, one we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  We can get roughly 4x more lp in the first case ## Tools Used None ## Recommended Mitigation Steps  The current implementation uses `self.balances`  https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236 ```soliditiy             for (uint256 i = 0; i < self.pooledTokens.length; i++) {                 uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);                 fees[i] = feePerToken                     .mul(idealBalance.difference(newBalances[i]))                     .div(FEE_DENOMINATOR);                 self.balances[i] = newBalances[i].sub(                     fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)                 );                 newBalances[i] = newBalances[i].sub(fees[i]);             } ```  Replaces `self.balances` with `_xp(self, newBalances)` would be a simple fix. I consider the team can take balance's weighted pool as a reference. [WeightedMath.sol#L149-L179](https://github.com/balancer-labs/balancer-v2-monorepo/blob/7ff72a23bae6ce0eb5b134953cc7d5b79a19d099/pkg/pool-weighted/contracts/WeightedMath.sol#L149-L179)  "}, {"title": "Reentrancy", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/148", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0v3rf10w   # Vulnerability details  ## Impact Multiple Reentrancy  ## Proof of Concept Reentrancy in BasicSale.receive() (tge/contracts/PublicSale.sol#148-156)  Reentrancy in BasicSale.burnEtherForMember(address) (tge/contracts/PublicSale.sol#158-166)   State variables written after the external call(s) in all above.  ## Tools Used Manual  ## Recommended Mitigation Steps  "}, {"title": "Missing Zero-check", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/146", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0v3rf10w   # Vulnerability details  ## Impact Missing Zero address check  ## Proof of Concept BasicSale.constructor(IERC20,IERC721,IVesting,uint256,uint256,uint256,uint256,address)._burnAddress (tge/contracts/PublicSale.sol#112)  lacks a zero-check on :- burnAddress = _burnAddress (tge/contracts/PublicSale.sol#137)  ## Tools Used Manual  ## Recommended Mitigation Steps Check that the address is zero   "}, {"title": "Unchecked low-level calls", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0v3rf10w   # Vulnerability details  ## Impact Unchecked low-level calls  ## Proof of Concept Unchecked cases at 2 places :- BasicSale.receive() (2021-11-bootfinance/tge/contracts/PublicSale.sol#148-156) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#154)  BasicSale.burnEtherForMember(address) (2021-11-bootfinance/tge/contracts/PublicSale.sol#158-166) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#164)   ## Tools Used Manual  ## Recommended Mitigation Steps The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  "}, {"title": "Can not update target price", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/143", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The sanity checks in `rampTargetPrice` are broken [SwapUtils.sol#L1571-L1581](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1571-L1581) ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,                 \"futureTargetPrice_ is too small\"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),                 \"futureTargetPrice_ is too large\"             );         } ``` If `futureTargetPricePrecise` is smaller than `initialTargetPricePrecise` 0.01 of `futureTargetPricePrecise` would never larger than `initialTargetPricePrecise`.  Admin would not be able to ramp the target price. As it's one of the most important features of the customswap, I consider this is a high-risk issue  ## Proof of Concept Here's a web3.py script to demo that it's not possible to change the target price even by 1 wei. ```python     p1, p2, _, _ =swap.functions.targetPriceStorage().call()     future = w3.eth.getBlock(w3.eth.block_number)['timestamp'] + 200 * 24 * 3600      # futureTargetPrice_ is too small     swap.functions.rampTargetPrice(p1 -1, future).transact()     # futureTargetPrice_ is too large     swap.functions.rampTargetPrice(p1 + 1, future).transact() ``` ## Tools Used None ## Recommended Mitigation Steps  Would it be something like: ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT) >= initialTargetPricePrecise,                 \"futureTargetPrice_ is too small\"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT),                 \"futureTargetPrice_ is too large\"             );         } ``` I believe the dev would spot this mistake if there's a more relaxed timeline.  "}, {"title": "Unclear Commented Out Code", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact  I'm not sure why some of this code is commented out.   It could point to items that are not done or need redesigning, be a mistake, or just be testing overhead.   ## Proof of Concept The commented out code is here:  Unclear: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L27 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L76  Obviously Test related: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L187  Guarded launch: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L42-L49 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L201-L204 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L235-L237  ## Tools Used VS Code  ## Recommended Mitigation Steps Review and remove or resolve/document the commented out lines if needed.  "}, {"title": "Rearrange state variables", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  ## Impact In BTCPoolDelegator contract, address state variables `future_owner` in lines 51 and bool state variable `is_killed` in line 55 should be placed one after another. solidity keep storage in 32 bytes slot and can optimize multiple variables that are less than 32 bytes. address is 20 bytes and bool is 1 byte, so it can be placed in one storage slot instead of two.  ## Proof of Concept Tested it on Remix, saves 50 gas per transaction  ## Recommended Mitigation Steps change ``` 50    uint256 public future_admin_fee; 51    address public future_owner; 52 53    uint256 kill_deadline; 54    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 54    bool is_killed; ``` to ``` 50    uint256 public future_admin_fee; 51    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 52 53    uint256 kill_deadline; 54    address public future_owner; 54    bool is_killed; ```  "}, {"title": "Require statement missing in fallback and burnEtherForMember() functions", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact The contract BasicSale contains a fallback function and a burnEtherForMember() function with exactly the same implementation. These 2 functions do the following call: _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);  The _recordBurn function contains the following if block: if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet     mapMemberEra_Days[_member][_era].push(_day);                                    // Add it     mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member     mapEraDay_Members[_era][_day].push(_member);                                    // Add member }  What does this mean? If a user performs multiple calls to the contract sending 0 ether as msg.value, the if block will be entered and a new key will be pushed to the mapping. Luckily the cost of an addition to or a read from a mapping does not change with the number of keys mapped. But this would totally mess the function getDaysContributedForEra output. Currently this function is only used as a view function, and not used by the smart contract itself. But it's a risk for future implementations that may make use of it.  ## Proof of Concept >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 0   Transaction confirmed   Block: 13577879   Gas used: 117368 (1.75%)  <Transaction '0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 1  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 1   Transaction confirmed   Block: 13577880   Gas used: 91568 (1.36%)  <Transaction '0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 2  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 2   Transaction confirmed   Block: 13577881   Gas used: 91568 (1.36%)  <Transaction '0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 3  ## Tools Used Manual testing  ## Recommended Mitigation Steps Add the following require statement to the fallback and the burnEtherForMember() functions: require(msg.value > 0, \"Some ether should be sent\")  "}, {"title": "Contract BasicSale is missing an approve(address(vestLock), 2**256-1) call", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/135", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact As we can see in the contracts AirdropDistribution and InvestorDistribution, they both have the following approve() call: mainToken.approve(address(vestLock), 2**256-1); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  This is necessary because both contracts transfer tokens to the vesting contract by calling its vest() function: https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158  The code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address -> vestingToken.transferFrom(msg.sender, address(this), _amount); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95  Same is done in the BasicSale contract: https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225  The problem is that this contract is missing the approve() call. For that reason, the contract is totally useless as the function _withdrawShare() will always revert with the following message: revert reason: ERC20: transfer amount exceeds allowance. This means that all the mainToken sent to the contract would be stuck there forever. No way to retrieve them.  How this issue was not detected in the testing phase? Very simple. The mock used by the team has an empty vest() function that performs no transfer call. https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10  ## Proof of Concept See below Brownie's custom output: Calling -> publicsale.withdrawShare(1, 1, {'from': user2}) Transaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5   BasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)  Call trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde': Initial call cost  [21344 gas] BasicSale.withdrawShare  0:3724  [16114 / -193010 gas] \u251c\u2500\u2500 BasicSale._withdrawShare  111:1109  [8643 / 63957 gas] \u2502   \u251c\u2500\u2500 BasicSale._updateEmission  116:405  [53294 / 55739 gas] \u2502   \u2502   \u2514\u2500\u2500 BasicSale.getDayEmission  233:248  [2445 gas] \u2502   \u251c\u2500\u2500 BasicSale._processWithdrawal  437:993  [-7726 / -616 gas] \u2502   \u2502   \u251c\u2500\u2500 BasicSale.getEmissionShare  484:859  [4956 / 6919 gas] \u2502   \u2502   \u2502   \u2502 \u2502   \u2502   \u2502   \u2514\u2500\u2500 MockERC20.balanceOf  [STATICCALL]  616:738  [1963 gas] \u2502   \u2502   \u2502           \u251c\u2500\u2500 address: mockerc20.address \u2502   \u2502   \u2502           \u251c\u2500\u2500 input arguments: \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 account: publicsale.address \u2502   \u2502   \u2502           \u2514\u2500\u2500 return value: 100000000000000000000 \u2502   \u2502   \u2502 \u2502   \u2502   \u2514\u2500\u2500 SafeMath.sub  924:984  [191 gas] \u2502   \u2514\u2500\u2500 SafeMath.sub  1040:1100  [191 gas] \u2502 \u251c\u2500\u2500 MockERC20.transfer  [CALL]  1269:1554  [1115 / 30109 gas] \u2502   \u2502   \u251c\u2500\u2500 address: mockerc20.address \u2502   \u2502   \u251c\u2500\u2500 value: 0 \u2502   \u2502   \u251c\u2500\u2500 input arguments: \u2502   \u2502   \u2502   \u251c\u2500\u2500 recipient: user2.address \u2502   \u2502   \u2502   \u2514\u2500\u2500 amount: 27272727272727272727 \u2502   \u2502   \u2514\u2500\u2500 return value: True \u2502   \u2502 \u2502   \u2514\u2500\u2500 ERC20.transfer  1366:1534  [50 / 28994 gas] \u2502       \u2514\u2500\u2500 ERC20._transfer  1374:1526  [28944 gas] \u2514\u2500\u2500 Vesting.vest  [CALL]  1705:3712  [-330491 / -303190 gas]     \u2502   \u251c\u2500\u2500 address: vesting.address     \u2502   \u251c\u2500\u2500 value: 0     \u2502   \u251c\u2500\u2500 input arguments:     \u2502   \u2502   \u251c\u2500\u2500 _beneficiary: user2.address     \u2502   \u2502   \u251c\u2500\u2500 _amount: 63636363636363636363     \u2502   \u2502   \u2514\u2500\u2500 _isRevocable: 0     \u2502   \u2514\u2500\u2500 revert reason: ERC20: transfer amount exceeds allowance <-------------     \u2502     \u251c\u2500\u2500 SafeMath.add  1855:1883  [94 gas]     \u251c\u2500\u2500 SafeMath.add  3182:3210  [94 gas]     \u251c\u2500\u2500 SafeMath.add  3236:3264  [94 gas]     \u2502     \u2514\u2500\u2500 MockERC20.transferFrom  [CALL]  3341:3700  [99923 / 27019 gas]         \u2502   \u251c\u2500\u2500 address: mockerc20.address         \u2502   \u251c\u2500\u2500 value: 0         \u2502   \u251c\u2500\u2500 input arguments:         \u2502   \u2502   \u251c\u2500\u2500 sender: publicsale.address         \u2502   \u2502   \u251c\u2500\u2500 recipient: vesting.address         \u2502   \u2502   \u2514\u2500\u2500 amount: 63636363636363636363         \u2502   \u2514\u2500\u2500 revert reason: ERC20: transfer amount exceeds allowance         \u2502         \u2514\u2500\u2500 ERC20.transferFrom  3465:3700  [-97648 / -72904 gas]             \u2514\u2500\u2500 ERC20._transfer  3473:3625  [24744 gas]  ## Tools Used Manual testing  ## Recommended Mitigation Steps The following approve() call should be added in the constructor of the BasicSale contract: mainToken.approve(address(vestLock), 2**256-1);  "}, {"title": "uint256 is always >= 0", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Proof of Concept  On Swap.sol at L190 and L191, it is checked that whether _a and _a2 is bigger equal to 0. Since they are both uint256, this condition is always satisfied. Therefore, those conditions are not required.  ## Tools Used  Manual analysis  "}, {"title": "Overwrite benRevocable", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Anyone can call the function vest() of Vesting.sol, for example with a smail \"_amount\" of tokens, for any _beneficiary.  The function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value.  So you can set any _beneficiary to Revocable. Although revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L73-L98  function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {         ...         if(_isRevocable == 0){             benRevocable[_beneficiary] = [false,false];  // just overwrites the value         }         else if(_isRevocable == 1){             benRevocable[_beneficiary] = [true,false]; // just overwrites the value         }        ## Tools Used  ## Recommended Mitigation Steps Whitelist the calling of vest() Or check if values for benRevocable are already set.   "}, {"title": "Investor can't claim the last tokens (via claim() )", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet). Then you call the function claim() of InvestorDistribution.sol, which has the following statement: \"require(investors[msg.sender].amount - claimable != 0);\" This statement will prevent you from claiming your tokens because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128  function claim() external nonReentrant { ...         require(investors[msg.sender].amount - claimable != 0);         investors[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the require statement.   "}, {"title": "Can't claim last part of airdrop", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are eligible for the last part of your airdrop (or your entire airdrop if you haven't claimed anything yet). Then you call the function claim() of AirdropDistribution.sol, which has the following statement: \"assert(airdrop[msg.sender].amount - claimable != 0);\" This statement will prevent you from claiming your airdrop because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L522-L536  function claim() external nonReentrant {        ..         assert(airdrop[msg.sender].amount - claimable != 0);         airdrop[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the assert statement. Also add the following to validate() , to prevent claiming the airdrop again:       require(validated[msg.sender]== 0, \"Already validated.\");  "}, {"title": "Claim airdrop repeatedly", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/129", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol Then airdrop[msg.sender].amount will be set to 0.  Suppose you then call validate() again.  The check \"airdrop[msg.sender].amount == 0\" will allow you to continue, because amount has just be set to 0. In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0.  Now you can claim your airdrop again (as long as there are tokens present in the contract)  Note: The function claim() prevents this from happening via \"assert(airdrop[msg.sender].amount - claimable != 0);\", which has its own problems, see other reported issues.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563  function claimExact(uint256 _value) external nonReentrant {         require(msg.sender != address(0));         require(airdrop[msg.sender].amount != 0);                  uint256 avail = _available_supply();         uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //         if (airdrop[msg.sender].claimed != 0){             claimable -= airdrop[msg.sender].claimed;         }          require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable         require(_value <= claimable);                       // _value can be equal to claimable         airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim   // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517 function validate() external nonReentrant {         ...         require(airdrop[msg.sender].amount == 0, \"Already validated.\");         ...              Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);              airdrop[msg.sender] = newAirdrop;              validated[msg.sender] = 1;   // this is set, but isn't checked on entry of this function  ## Tools Used  ## Recommended Mitigation Steps Add the following to validate() :         require(validated[msg.sender]== 0, \"Already validated.\");  "}, {"title": "No event was emitted while setting fees and admin_fees in constructor", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/128", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Event should be emitted after sensitive action like setting fees, admin_fees otherwise it will be difficult track offchain fees changes  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review ## Recommended Mitigation Steps  event should be emitted after the sensitive action  "}, {"title": "No checking of admin_fee, wether it is <= max_admin_fee ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/127", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking admin_fee, it can be greater than max_admin_fee  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review  ## Recommended Mitigation Steps  add input validation for admin_fee  "}, {"title": "claimExact does not check claimable amount", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/126", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact Inconsistency between the `claim()` function and `claimExact()` function, in that `claimExact` does not check the claimable amount. In the scenario where claimable = 0, and `investors[msg.sender].claimed != 0` then it will attempt to underflow. If `_amount` is 0, then it could potentially reach the `vestLock.vest()` function, where it will then revert with the inaccurate message \"amount must be positive\" which doesn't reflect the underlying issue.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L145 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L121 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L75  ## Tools Used manual review   ## Recommended Mitigation Steps Add `require(claimable > 0)`  "}, {"title": "Renaming variables for clarity", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact `amount` in the `Investors` struct is vague. It would be assumed to be the invested amount, however this amount decreases when the beneficiary claims. A more appropriate name could be `unclaimed_amount`. `claimable_to_send` is not appropriate name in the `claimExact()` function, as it is not the claimable total, instead `exact_claim_to_send` would make more sense. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L24 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L155   "}, {"title": "Public functions can be external", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact Functions include `updateEmission(), dev_rugpull(), setAdmin(), revoke() ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L185 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L203 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L212 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104  "}, {"title": "Unable to claim vesting due to unbounded timelock loop", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/120", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact The timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.  The `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`. The `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed. A malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.  The malicious actor could do this to each *beneficiary*, locking up all the vestments.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. - Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`  "}, {"title": "Function _getDayEmission can be simplified (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity  ## Proof of Concept  The function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L291-L298  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to simplify:    <code>     function getDayEmission() public view returns (uint) {            return (remainingSupply > emission ? emission : remainingSupply);     } </code>  "}, {"title": "Cache Reference To State Variables \"currentDay, currentEra, emission\" in _updateEmission (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Cache Reference To State Variables \"currentDay, currentEra, emission\" in _updateEmission (PublicSale.sol)  Caching the references to \"currentDay, currentEra, emission\" will decrease gas usage.   ## Proof of Concept  The variables \"currentDay, currentEra, emission\" are referenced 20 times in function \"_updateEmission\" here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L247-L276  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache those variables:    <code>  function _updateEmission() private {         uint _now = block.timestamp;                                                                                      // Find now()         if (_now >= nextDayTime) {                                                                                         // If time passed the next Day time                  uint256 _currentDay = currentDay;             uint256 _currentEra = currentEra;             uint256 _emission = emission;              if (remainingSupply > _emission) {                 remainingSupply -= _emission;                                                              }             else {                 remainingSupply = 0;                                                                     }             if (_currentDay >= daysPerEra) {                                                                                 // If time passed the next Era time                 _currentEra += 1; _currentDay = 0;                                                                        // Increment Era, reset Day                 nextEraTime = _now + (secondsPerDay * daysPerEra);                                          // Set next Era time                 _emission = getNextEraEmission();                                                                        // Get correct emission                 mapEra_Emission[currentEra] = _emission;                                                           // Map emission to Era                 emit NewEra(_currentEra, _emission, nextEraTime, totalBurnt);                            // Emit Event             }             _currentDay += 1;                                                                                                     // Increment Day             nextDayTime = _now + secondsPerDay;                                                                  // Set next Day time             _emission = getDayEmission();                                                                                // Check daily Dmission             mapEraDay_EmissionRemaining[_currentEra][_currentDay] = _emission;               // Map emission to Day             uint _era = _currentEra;             uint _day = _currentDay - 1;             if (_currentDay == 1) {                 // new era                 _era = _currentEra - 1;                 _day = daysPerEra;             }              currentDay = _currentDay;             currentEra = _currentEra;             emission = _emission;                 emit NewDay(_currentEra, _currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);         }     } </code>   "}, {"title": "Vesting.revoke is missing a require statement", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact In the Vesting contract, the function revoke() sends the vested tokens to the beneficiary and the remaining tokens that are not vested yet are sent to the multisig address. It makes no sense to allow calling this function once the address has already vested the 100% of the tokens (after 1 year in this case -> uint256 _unlockTimestamp = block.timestamp.add(unixYear);).  Basically in this case the function revoke() would behave like a claim() function but doing some extra checks which waste gas (gas paid by the owner of the contract instead of the beneficiary address) and also emitting an extra event -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L123  For that reason, it is recommended to add a require statement that handles this case:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  ## Tools Used Manual testing  ## Recommended Mitigation Steps It is recommended to add a require statement that handles this case in the Vesting.revoke() function:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  "}, {"title": "Unnecessary require statement in vesting.claim()", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact There is an unnecessary require statement in vesting.claim() -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  This check is already done in https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L186  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the require statement in the claim() function as it is totally unnecessary. The check is already performed in the function _claimableAmount(address _addr).  "}, {"title": "Use of uint256 parameter instead of bool", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact In the contract Vesting, function vest(), the parameter _isRevocable is declared as an uint256 when it is used as a boolean.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L77  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare the parameter _isRevocable as a bool.  "}, {"title": "Check ERC20 token `approve()` function return value", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact With version 4.x of the ERC20 token, the `approve()` function returns a boolean indicating whether it was successful or not.  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-  Best practice is to either check the return value or use `safeApprove()` / `safeIncreaseAllowance()` which will revert if the operation was unsuccessful  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use `safeApprove()` or `safeIncreaseAllowance()`  "}, {"title": "Tokens not recoverable", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact In both airdrop contracts: AirdropDistribution and InvestorDistribution, once all the participants have claimed their tokens, some will remain in the contract due to some imprecision in the calculations. There is no function that allows to substract them which means that those tokens will remain stuck in the contracts forever.  I have made the test with just 5 participants: user2, user3, user4, user5 & user6.  uint256[5] airdropBalances =     [     4032000,     4032000,     4032000,     4032000,     4032000     ];  >>> 4032000 * 5 20160000  Initially 20160000 tokens were transferred to the contract  mockToken.transfer(airdropdist.address, 20160000000000000000000000)  After 260 weeks, these were the results:  ----------------> mockToken.balanceOf(airdropdist.address) -> 2842805668532461833600 <-----------------  mockToken.balanceOf(user2) -> 1209429431659888052289865 vesting.benTotal(user2.address) -> 2822002007206405455343415 mockToken.balanceOf(user3) -> 1209429431659888052289984 vesting.benTotal(user3.address) -> 2822002007206405455343296 mockToken.balanceOf(user4) -> 1209429431659888052289984 vesting.benTotal(user4.address) -> 2822002007206405455343296 mockToken.balanceOf(user5) -> 1209429431659888052289984 vesting.benTotal(user5.address) -> 2822002007206405455343296 mockToken.balanceOf(user6) -> 1209429431659888052289984 vesting.benTotal(user6.address) -> 2822002007206405455343296  As we can see above 2842 tokens remain in the contract and there is no way to retrieve them.  ## Tools Used Manual testing / brownie  ## Recommended Mitigation Steps Add an onlyOwner function that allows to retrieve all the remaining tokens once all the participants of the airdrop have claimed the whole amount of their rewards.  "}, {"title": "Airdrop Supply differs", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `AirdropDistribution.sol`, the `airdrop_supply` ([line 462](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L462)) value is set to be `20160000`. However, adding all the `airdropBalances` does show that the value should be `20159997` instead.   ## Impact This does cause some operations on the contract to mislead in the results. This is more noticed on bigger airdropped accounts.  ## Proof of Concept Adding all the `airdropBalances` values do show the difference.  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `airdrop_supply` should be reflecting the actual airdropped balance without misleading the total amount. Change the value to `20159997`.  "}, {"title": "Redundant check on claim", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `claim` function ([line 524](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L524))  of the `AirdropDistribution.sol` contract, the `validated` check is redundant. The flag is only set when the `validate` function is called. Once validated, the amount will always be different than zero, meaning that the check is not necessary.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The check could be removed for gas optimization.  "}, {"title": "Duplicated code and usage of assert", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `_available_supply` and `available_supply` functions on the `AirdropDistribution` (lines [601](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L601) and [607](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L607)) do contain the exact same code.  Furthermore, the `assert` check inside those functions should be changed to a require statement since the check is not an invariant and gas refund should take place if the check fails ([SWC-110](https://swcregistry.io/docs/SWC-110)).  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `available_supply` and `_available_supply` functions should be combined into a single public function (public functions can be used internally without any extra gas) or have the public function call the internal implementation and use the private implementation in the contract.  The `assert` check in the `available_supply` function should be changed to a require statement since the check is not an invariant.  "}, {"title": "Gas optimization on InvestorDistribution.sol", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `InvestorDistribution` ([InvestorDistribution.sol](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol)) contract does contain some statements that could be removed to optimize the gas usage.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Variable set on [Line 77](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L77) can be removed since the implicit value is already zero - On lines 106 and 107 ([here](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L106-L107)), the statement could be changed to a single line containing `delete investors[_investor]`.  "}, {"title": "State variables could be declared constant", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  PranavG   # Vulnerability details  ## Impact State variables that never change can be declared constant. This can greatly reduce gas costs. Examples : airdrop_supply in AirdropDistribution.sol(#462) investors_supply in InvestorDistribution.sol(#33)  unixYear in Vesting.sol(#30)  ## Recommended Mitigation Steps Add the constant keyword for state variables whose value never change.  "}, {"title": "Unnecessary imports", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  PranavG   # Vulnerability details  ## Impact MathUtils.sol has unused import at line #5: import \"@openzeppelin/contracts/math/SafeMath.sol\"; The import is not used in any way.   ## Recommended Mitigation Steps Remove it to improve readability of the code.  "}, {"title": "Vesting contract locks tokens for less time than expected", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Tokens are locked for 1 day less than specified in spec.  ## Proof of Concept  The vesting period is calculated here in `unixYear`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L30  This results in a lockup of 364 days rather than the expected 365.  ## Recommended Mitigation Steps  Replace line with `uint256 constant private unixYear = 365 days;`   "}, {"title": "`GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `CommitOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new future admin is different than the old one.  "}, {"title": "`GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/80", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `ApplyOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  "}, {"title": "Missing emit of initial `ApplyOwnership` event in `GaugeController.__init__()`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `GaugeController.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `ApplyOwnership` event.  ## Impact The users won't know who's the initial admin by searching for the first `ApplyOwnership` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  "}, {"title": "Missing emit of initial `SetAdmin` event in `MainToken.__init__()`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `SetAdmin` event.  ## Impact The users won't know who's the initial admin by searching for the first `SetAdmin` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  "}, {"title": "`LPToken.approve()` emits `Approval` events when the allowance hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/73", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  "}, {"title": "`LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  "}, {"title": "`LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  "}, {"title": "`LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero before it sets it as the new minter.  ## Impact This function can be invoked by mistake with the zero address as `_minter`, causing the system to lose its minter forever, without the option to set a new minter.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minter` doesn't equal zero before setting it as the new minter.  "}, {"title": "`LPToken.__init__()` emits `Transfer` events when the amount minted for `msg.sender` is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  "}, {"title": "`MainToken.__init__()` emits `Transfer` events when the amount minted for `msg.sender` is zero (and it is always the case)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero. This is always the case, as the value of the constant `INITIAL_SUPPLY` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  "}, {"title": "`MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero before it sets it as the new `minting_multisig`.  ## Impact This function can be invoked by mistake with the zero address as `_minting_multisig`, causing the system to lose its `minting_multisig` forever, without the option to set a new `minting_multisig`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minting_multisig` doesn't equal zero before setting it as the new `minting_multisig`.  "}, {"title": "`MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed, and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMintMultisig` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new `minting_multisig` is different than the old one.  "}, {"title": "`MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetAdmin` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  "}, {"title": "`MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMinter` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new minter is different than the old one.  "}, {"title": "`MainToken.burn()` emits `Transfer` events when the burned amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.burn()` emits `Transfer` events when the burned amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the burned amount is not zero.  "}, {"title": "`MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the minted amount is not zero.  "}, {"title": "`MainToken.approve()` emits `Approval` events when the allowance hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  "}, {"title": "`MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  "}, {"title": "`MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  "}, {"title": "`PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero.  ## Impact There is no reason to emit these `Withdraw` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the withdrawn amount is not zero.  "}, {"title": "`PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero.  ## Impact There is no reason to emit these `Deposit` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the deposited amount is not zero.  "}, {"title": "`PoolGauge.withdraw()` can be optimized when `_value` equals zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` doesn't have to execute these lines of code when `_value` equals zero: ``` _balance: uint256 = self.balanceOf[msg.sender] - _value _supply: uint256 = self.totalSupply - _value self.balanceOf[msg.sender] = _balance self.totalSupply = _supply  self._update_liquidity_limit(msg.sender, _balance, _supply)  assert ERC20(self.lp_token).transfer(msg.sender, _value) ```  ## Impact There is no reason to execute these lines of code if `_value` equals zero because they won't affect the system. An identical optimization is already implemented in `PoolGauge.deposit()`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Execute these lines of code only if `_value` doesn't equal zero.  "}, {"title": "`Token.approve()` emits `Approval` events when the allowence hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `Token.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  "}, {"title": "`Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  "}, {"title": "`Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  "}, {"title": "Array out-of-bounds errors in `USDPoolDelegator`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `USDPoolDelegator.balances()`, `USDPoolDelegator.coins()` and `USDPoolDelegator.underlying_coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` / `_underlying_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` / `_underlying_coins` array bounds.  "}, {"title": "Array out-of-bounds errors in `ETHPoolDelegator`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `ETHPoolDelegator.balances()` and `ETHPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  "}, {"title": "Array out-of-bounds errors in `BTCPoolDelegator`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `BTCPoolDelegator.balances()` and `BTCPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  "}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling Swap.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L30\" 2. The contract has many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  "}, {"title": "If statement in _updateEmission() can be removed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact The if statement in _updateEmission() can be removed as the condition is already checked in updateEmission() https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L596 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L186  ## Proof of Concept     function _updateEmission() private {         if (block.timestamp >= startEpochTime + RATE_TIME) {             miningEpoch += 1;             startEpochTime = startEpochTime.add(RATE_TIME);             startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));              if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {                 rate = rate.mul(EPOCH_INFLATION).div(100000);             }             else {                 rate = 0;             }             emit updateMiningParameters(block.timestamp, rate, startEpochSupply);         }     }      //Update emission to be called at every step change to update emission inflation     function updateEmission() public {         require(block.timestamp >= startEpochTime + RATE_TIME, \"Too soon\"); // Condition already checked here         _updateEmission();     }  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the if condition in the _updateEmission() private function  "}, {"title": "Lack of maximum and minimum vesting amount check on the vesting function", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen maxVesting amount is disabled. However, there is no maximum and minimum vesting amount defined. Users can vest small amount. For the protocol liquditiy calculation maximum and minimum threshold should be defined.   ## Proof of Concept  1. Navigate to the following contract.  \"\"\" https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L76 \"\"\"  2. Vesting amount didnt check.  ## Tools Used  Review  ## Recommended Mitigation Steps  It is suggested to check maximum/minimum vesting amount on the contract.   "}, {"title": "Unchecked transfers", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact Multiple calls to transferFrom and transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \u201cfalse\u201d is returned. It\u2019s important to check this. If you don\u2019t, in this concrete case, some airdrop eligible participants could be left without their tokens. It is also a best practice to check this.  ## Proof of Concept AirdropDistributionMock.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistributionMock.sol:157:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:542:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:567:        mainToken.transfer(msg.sender, claimable_to_send);  InvestorDistribution.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:156:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:207:        mainToken.transfer(msg.sender, bal);  Vesting.sol:95:        vestingToken.transferFrom(msg.sender, address(this), _amount);  PublicSale.sol:224:            mainToken.transfer(_member, v_value);   ## Tools Used Manual testing  ## Recommended Mitigation Steps Check the result of transferFrom and transfer. Although if this is done, the contracts will not be compatible with non standard ERC20 tokens like USDT. For that reason, I would rather recommend making use of SafeERC20 library: safeTransfer and safeTransferFrom.  "}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  The advantages of versions 0.8.* over <0.8.0 are:  - Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.) - Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls. - Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs. - Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.    ## Proof of Concept  1. The contest repository contracts contain pragma 0.6.12^. The contracts pragma version should be updated to 0.8.4.  (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol ) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/MathUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L2) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSaleBatchWithdraw.sol#L2)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.4.  "}, {"title": "getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)  The \"else\" and returning 0, can be eliminated.  The existing but unused named return variable \"value\" can be used instead of a return statement. These changes reduce gas and improve code clarity.  ## Proof of Concept  The getEmissionShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231-L245  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units                  if (memberUnits != 0) {             uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units             uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];     // Get emission remaining for Day             uint balance = mainToken.balanceOf(address(this));             if (emissionRemaining > balance) {                 emissionRemaining = balance;                                                // In case less than required emission             }             value = (emissionRemaining * memberUnits) / totalUnits;         // Calculate share         }     }    </code>  "}, {"title": "_processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  _processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)  The \"else\", the setting of \"value to 0\", and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _processWithdrawal function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L212-L229  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units                  if (memberUnits != 0) {             value = getEmissionShare(_era, _day, _member);          // Get the emission Share for Member             mapEraDay_MemberUnits[_era][_day][_member] = 0;  // Set to 0 since it will be withdrawn             mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units             mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission             totalEmitted += value;                                                 // Add to Total Emitted             uint256 v_value = value * 3 / 10;                                 // Transfer 30%, lock the rest in vesting contract                          mainToken.transfer(_member, v_value);                      // ERC20 transfer function             vestLock.vest(_member, value - v_value, 0);             emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);         }     } </code>  "}, {"title": "_withdrawShare Can Be Rewritten To Be More Efficient (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The \"else if\", the second call to _processWithdrawal, and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _withdrawShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L201-L210  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>  function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {  _updateEmission();    if (_era < currentEra ||                                                          // Allow if in previous Era                                                                          (_era == currentEra && _day < currentDay)) {                // or current Era and previous day    value = _processWithdrawal(_era, _day, _member);   // Process Withdrawal      }   } </code>  "}, {"title": "Unused Named Returns (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L187 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L194 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named returns  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L149-L150 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1625 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1679  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L105 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L194-L197  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L152 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L162  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.    "}, {"title": "Unnecessary \"else if\" in function vest (Vesting.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The \"else if(_isRevocable == 1)\" is not needed and can be removed to save gas and improve code clarity.  ## Proof of Concept  The \"_isRevocable\" variable is guaranteed to be 0 or 1 here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L77  But it is treated like it can have some other value here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Rewrite these lines https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88 to <code>  benRevocable[_beneficiary] = (_isRevocable == 0) ? [false,false] : [true,false]; </code>  "}, {"title": "internal functions could be set private", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  Since no contract inherent from SwapUtils all internal functions could be set private. For example  getD could be set private to save gas.  "}, {"title": "optimizing for loops by caching array length", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  optimizing for loops by caching memory array length, instead of calling it every time.  For example at Swap.sol at time 158 you should have  uint8 len = _pooledTokens.length and in the next line define the forloop with stop condition of  i<len  This appears in many places in the code. At some places you did cached the array length correctly.   "}, {"title": "double reading of memory inside a loop without caching", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  When double reading a variable from memory the gas efficient way is to cache it and use the cached value.   For example in line 537, 538 of SwapUtils.sol you have two accesses to xp[i]. You can save xp[i] as local variable and then use it instead at the second time.  "}, {"title": "admin can override investor and stuck its funds in the system ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  An admin can (by mistake maybe) addInvestor with address that already exists. This way its funds are locked in the system and cannot be withdrawn, even by the admin.    "}, {"title": "multiple reading of state variables without caching", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  In InvestorDistribution line 103 you read investors[_investor] multiple times (only at this function investors[_investor] is read 6 times). You could cache the value and call the cached value instead. Investors x = investors[_investor]; And then use x.amount, x.claimed, etc.  "}, {"title": "too many bits to describe small quantities ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  In InvestorDistribution you generally use uint256 for every quantity, although 256 bits are much more than necessary. For example for Investor structure you can change all to uint128, and for every normal use it will not affect and save gas.  "}, {"title": "Unnecessary use of safeMath", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  In InvestorDistribution at line 19 you have      using SafeMath for uint256;  although you use solidity >0.8.0 therefore you don't need to use safeMath for uint256  "}, {"title": "Numerous gas optimizations in SwapUtils.sol", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Several references to storage can be cached to save significant amounts of gas.  ## Proof of Concept File lines are stated in Mitigation Steps.  ## Tools Used Manual review   ## Recommended Mitigation Steps  #### In function calculateWithdrawOneTokenDY (L406) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function _calculateRemoveLiquidity (L953) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, one of those as condition in a for loop, so at least _pooledTokensLength SLOADS are saved.  #### In function _feePerToken (L1080) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function swap (L1098) ``` IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom]; ``` The value is used 4 times, so 3 SLOADs are saved. However, this causes a stack too deep error in line 1129. To mitigate this, replace lines 1129-1132 for: ``` uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);         dyAdminFee = dyAdminFee.div(self.tokenPrecisionMultipliers[tokenIndexTo]); ```  #### In function addLiquidity (L1163) ``` uint256 _pooledTokensLength = self.pooledTokens.length; uint256 _lpTokenTotalSupply = self.lpToken.totalSupply(); ``` _pooledTokensLength is used 4 times. 3 SLOADs saved. _lpTokenTotalSupply is used 6 times, however the one in line 1266 is called after a mint() so it's not the same value and thus can't be replaced. 4 SLOADs saved.  #### In function _updateUserWithdrawFee (L1290) ``` uint256 _withdrawFee = self.defaultWithdrawFee; ``` The value is used 3 times, so 2 SLOADs are saved.  #### In function removeLiquidityImbalance (L1415) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used 5 times, twice as a for condition, so at least 2 + _pooledTokensLength SLOADs are saved.  "}, {"title": "No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jah   # Vulnerability details  ## Impact  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L66  https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  ## Tools Used Manual analysis  ## Recommended Mitigation Steps  "}, {"title": "Redundant check", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact According to the comment in line 148 of Swap.sol, the function checks for _pooledTokens and precisions parameters, however, the require at line 151 is redundant, as it will pass if both previous checks passed.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L151  ## Tools Used  ## Recommended Mitigation Steps Remove the require, or change it to validate the correct precision parameters.  "}, {"title": "No usage of immutable keyword leaves free gas savings on the table", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs + risk of accidental changes to values expected to be fixed.  ## Proof of Concept  Several contracts contain variables which are set at deploy time and never changed again. For example see `PublicSale.sol`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L70-L81  Since solidity 0.6.5, variables can be marked `immutable` which avoids the need for SLOADs when reading these variables - decreasing gas costs and protecting against accidentally modifying these variables.  https://blog.soliditylang.org/2020/05/13/immutable-keyword/#:~:text=With%20version%200.6.,time%20of%20a%20deployed%20contract.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Inspect all contracts for variables which are set once and then never modified, apply `immutable` keyword and adjust constructors to not read these values (instead use passed parameters)  "}, {"title": "What you guys mean by this line ? Its redundant imo", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x421f   # Vulnerability details  This one  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L99  Its maybe gap in my knowledge, but I have never seen this pattern  What it does ?  "}, {"title": "No need of separate indexing (NFT_ID => Vault Address)", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x421f   # Vulnerability details  If we see vault registry   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultRegistry.sol#L18  There are two mappings on L18 and L19  On 18 its map(address) => nftID, which is fine  but one on 19. we can remove,  Nft IDs are incremental, and are stored in same position in _vaults[] array so it can be accessed like for id of x => _vaults[x-1]  with this we dont need to maintain it whenever new vault is deployed, again saving gas cost :)  "}, {"title": " Constant variables can be immutable (DefaultAccessControl.sol)", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Changing the variables from constant to immutable will reduce keccak operations and save gas.  ## Proof of Concept  The variables that can be changed from `constant` to `immutable` are here: https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/DefaultAccessControl.sol#L11-L12  A previous finding with additional explanation and a pointer to the Ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable.  "}, {"title": "`YearnVault.sol#pull()` will most certainly fail", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/121", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101  ```solidity=84     for (uint256 i = 0; i < _yTokens.length; i++) {         if (tokenAmounts[i] == 0) {             continue;         }          IYearnVault yToken = IYearnVault(_yTokens[i]);         uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());         uint256 balance = yToken.balanceOf(address(this));         if (yTokenAmount > balance) {             yTokenAmount = balance;         }         if (yTokenAmount == 0) {             continue;         }         yToken.withdraw(yTokenAmount, to, maxLoss);         (tokenAmounts[i], address(this));     }     actualTokenAmounts = tokenAmounts; ```  The actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.  As a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.   ### Recommendation  Change to:  ```solidity=98 tokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss); ```  "}, {"title": "`AaveVault.sol#_pull()` may return wrong `actualTokenAmounts`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/AaveVault.sol#L80-L94  ```solidity=80 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  In Aave LendingPool, the actual amount withdrawn may be different from the requested amount, we suggest using the return amount as `actualTokenAmount`.  https://github.com/aave/protocol-v2/blob/master/contracts/protocol/lendingpool/LendingPool.sol#L155-L157  ```solidity if (amount == type(uint256).max) {     amountToWithdraw = userBalance; } ```  ### Recommendation  Change to:  ```solidity function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             tokenAmounts[i] = _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  "}, {"title": "adminApprove will not work", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/117", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function adminApprove intends to allow an admin to approve NFTs on behalf of users: ```solidity   function adminApprove(address newAddress, uint256 nft) external {     require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);     IERC721(address(this)).approve(newAddress, nft);   } ```  However, when it calls .approve, it will check the ownership again, so only the calls from admin and owner/approved will pass: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L116-L119  This makes this function ineffective.  ## Recommended Mitigation Steps Based on my understanding, it should call ._approve(...).  "}, {"title": "`ChiefTrader.sol` Wrong implementation of `swapExactInput()` and `swapExactOutput()`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  When a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59  ```solidity=59 return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options); ```  However, in the current implementation, inputToken is not approved to the `traderAddress`.  For example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.  Plus, the inputToken should also be transferred from the caller before calling the subtrader.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89  ```solidity=89     IERC20(input).safeTransferFrom(msg.sender, address(this), amount); ```  The same problem exits in `swapExactOutput()`:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75  ```solidity=63 function swapExactOutput(         uint256 traderId,         uint256 amount,         address,         PathItem[] calldata path,         bytes calldata options     ) external returns (uint256) {         require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);         _requireAllowedTokens(path);         address traderAddress = _traders[traderId];         address recipient = msg.sender;         return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);     } ```  ### Recommendation  Approve the inputToken to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.  Or maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.  "}, {"title": "Guard for initialization function of VaultGovernance", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cuong_qnom   # Vulnerability details  ### Impact There should be a guard to initialize the factory in the VaultGovernance. Otherwise, some guys (e.g. miners) can front-run the initialization transaction with fake Factory address.  ### Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultGovernance.sol#L77 ### Tools used Manual Analysis ### Recommendation steps Maybe can put some requirements at the start: _requireProtocolAdmin()   "}, {"title": "Use literal `2` instead of read from storage for `_vaultTokens.length` can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current design requires the number of `_vaultTokens` to be 2 in `UniV3Vault`, therefore `_vaultTokens.length` can be replaced with literal `2` to save ~800 gas from storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L101-L101  ```solidity=101 tokenAmounts = new uint256[](_vaultTokens.length); ```  "}, {"title": "`UniV3Vault.sol#collectEarnings()` can be front run", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/98", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  For `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).  However, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97  ### POC  Given:  - Current `tvl()` is `10 ETH` and `40,000 USDC`; - Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;  1. `strategy` calls `collectEarnings()` to collect fees and reinvest; 2. The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool; 3. After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.  As a result, the attacker has stolen half of the pending yields in about 1 block of time.  ### Recommendation  Consider including fees in `tvl()`.  For the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:  https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806  "}, {"title": "Use immutable variables can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L20-L20  ```solidity=20 IVaultGovernance internal _vaultGovernance; ```  ```solidity=35 constructor(     IVaultGovernance vaultGovernance_,     address[] memory vaultTokens_,     string memory name_,     string memory symbol_ ) ERC20(name_, symbol_) {     require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);     _vaultGovernance = vaultGovernance_;     _vaultTokens = vaultTokens_;     // ... } ```  `_vaultGovernance` will never change, use immutable variable instead of storage variable can save gas.   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L26-L30  ```solidity=26 ISwapRouter public swapRouter;  constructor(address _swapRouter) {     swapRouter = ISwapRouter(_swapRouter); } ```  `swapRouter` will never change, use immutable variable instead of storage variable can save gas.  "}, {"title": "Wrong implementation of `performanceFee` can cause users to lose 50% to 100% of their funds", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/91", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  A certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.  However, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271  ```solidity=269 address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  ### PoC  Given:  - `strategyParams.performanceFee`: `10e7` (1%)  1. Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`; 2. 3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:  - Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC); - Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.  ### Recommendation  Change to:  ```solidity address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  "}, {"title": "`LpIssuer.sol#_chargeFees()` Check `if (performanceFee > 0)` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L249-L252  ```solidity=249 uint256 performanceFee = strategyParams.performanceFee; uint256[] memory hwms = _lpPriceHighWaterMarks; if (performanceFee > 0) {     uint256 minLpPriceFactor = type(uint256).max;     ... ```  Check `if (performanceFee > 0)` at L251 can be done earlier to avoid unnecessary code execution (read `_lpPriceHighWaterMarks` and copy to memory) at L250 and save some gas when performanceFee == 0.  "}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L101-L109  ```solidity=101 function _allowTokenIfNecessary(address token) internal {     if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {         IERC20(token).approve(address(_lendingPool()), type(uint256).max);     } }  function _lendingPool() internal view returns (ILendingPool) {     return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool; } ```  Considering that `_lendingPool()` is a internal call that includes a storage read of `_vaultGovernance` and an external call of `IAaveVaultGovernance.delayedProtocolParams()`. Cache the result of `_lendingPool()` in the stack can save some gas.  ### Recommendation  Change to:  ```solidity function _allowTokenIfNecessary(address token) internal {     address lendingPool = address(_lendingPool());     if (IERC20(token).allowance(address(this), lendingPool) < type(uint256).max / 2) {         IERC20(token).approve(lendingPool, type(uint256).max);     } } ```  "}, {"title": "Unsafe token transfer", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  Calling `ERC20.transfer()` without handling the returned value is unsafe.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L81-L90  ```solidity=81 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         for (uint256 i = 0; i < tokenAmounts.length; i++) {             IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);         }         actualTokenAmounts = tokenAmounts;     } ```  ### Recommendation  Consider using OpenZeppelin's `SafeERC20` library with safe versions of transfer functions.  "}, {"title": "`YearnVault` did not cache tvl as comment described", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L14 > The TVL of the vault is cached and updated after each deposit withdraw.  But it actually does not cache tvl. This behavior is desired or otherwise would have same issue as `AaveVault`.  ## Recommended Mitigation Steps Remove the cache description in comment.   "}, {"title": "Withdraw from `AaveVault` will receive less than actual share", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.  ## Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150 https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13  ## Recommended Mitigation Steps Call `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl  "}, {"title": "Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   \"\"\" https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L96  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L106  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L88  \"\"\"   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  "}, {"title": "`maxTokensPerVault` is not used", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x0x0x   # Vulnerability details  In `protocolGovernance.sol`, there is parameter `maxTokensPerVault`. This parameter is never utilized, therefore does not provide the functionality stated in comments.  "}, {"title": "Gas Optimization: Pack `Params` struct in `IProtocolGovernance`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Reduce 1 storage slot by reordering from https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/interfaces/IProtocolGovernance.sol#L13 ```     struct Params {         bool permissionless;         uint256 maxTokensPerVault;         uint256 governanceDelay;         address protocolTreasury;     } ``` to ```     struct Params {         bool permissionless;         address protocolTreasury;         uint256 maxTokensPerVault;         uint256 governanceDelay;     } ```   "}, {"title": "User deposits don't have min. return checks", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LPIssuer.deposit` first computes _balanced amounts_ on the user's defined `tokenAmounts`. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be _balanced_, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.  But the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This frontrun can happen accidentally whenever the strategist rebalances  ## POC There's a vault with two tokens A and B, tvls are `[500, 1500]`  - The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply). - The strategist rebalances to `[1000, 1000]` - The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.  ## Impact Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their _expected LP amount_ for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.   "}, {"title": "`GatewayVault` events not used", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  The `CollectProtocolFees` and `CollectStrategyFees` events in `GatewayVault` are not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "Bad redirects can make it impossible to deposit & withdraw", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  The `GatewayVault._push()` function gets `redirects` from the `strategyParams`. If `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.  Note that the deposits for vault index `i` are cleared, as they are redirected:  ```solidity for (uint256 j = 0; j < _vaultTokens.length; j++) {     uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];     amountsByVault[vaultIndex][j] += amountsByVault[i][j];     amountsByVault[i][j] = 0; } ```  > The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.  If the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.   ## Recommended Mitigation Steps The `redirects[i] = j` matrix needs to be restricted. If `i` is redirected to `j`, `j` may not redirect itself. Check for this when setting the `redirects` array.  "}, {"title": "AaveVault does not update TVL on deposit/withdraw", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/41", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  Aave uses **rebasing** tokens which means the token balance `aToken.balanceOf(this)` increases over time with the accrued interest. The `AaveVault.tvl` uses a cached value that needs to be updated using a `updateTvls` call. This call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share _of the old tvl_, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the _new tvl_, receiving back their initial deposit + the share of the interest. This can be done risk-free in a single transaction.  ## POC - Imagine an Aave Vault with a single vault token, and current TVL = `1,000 aTokens` - Attacker calls `LPIssuer.push([1000])`. This loads the old, cached `tvl`. No `updateTvl` is called. - The `1000` underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: `aaveVault.transferAndPush([1000])`. This deposists `1000` underlying tokens to the Aave lending pool and returns `actualTokenAmounts = [1000]`. **After that** the internal `_tvls` variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited **but also the new rebased aToken amounts**, the interest the vault received from supplying the tokens since last `updateTvls` call. `_tvls = _tvls + interest + 1000` - The LP amount to mint `amountToMint` is still calculated on the old cached `tvl` memory variable, i.e., attacker receives `amount / oldTvl = 1000/1000 = 100%` of existing LP supply - Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in `deposit`'s `transferAndPush` call). Attacker receives `50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest`. - Attacker makes a profit of `0.5 * interest`  ## Impact The interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing. If the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest  ## Recommended Mitigation Steps Update the tvl when depositing and withdrawing before doing anything else.   "}, {"title": "Don't check contains before remove II", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x1f8b   # Vulnerability details  # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept The method remove of the library AddressSet doesn't fail if the entry was not found (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a05312f1b72acca6904ffe32ef83ccdbad20cb4f/contracts/utils/structs/EnumerableSet.sol#L72), this method return true or false if was removed, so it's not needed to check if _vaultGovernances.contains(addr) in the method removeFromVaultGovernances from ProtocolGovernance contract.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the contains conditional  "}, {"title": "Store Interface instead of address", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Inside the contract `ChiefTrader` It's better to store the variable `protocolGovernance` as `IProtocolGovernance` because otherwise you need to cast it everytime.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use `IProtocolGovernance` instead of address for store `protocolGovernance`  "}, {"title": "Learn from the past", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Mandatory check that could produce undesired results.  ## Proof of Concept The smart contract ChiefTrader was in charge of the swaps, and the method _requireAllowedTokens is in charge to know that all paths are valid, it's mandatory to check that token0 and token1 are not equal, you can see a previous hack in the following link, where the hacker use the same from and to for change the price of the token https://twitter.com/mudit__gupta/status/1465726874974187524?s=12 .  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require for check that token0 and token1 are different.  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AaveVaultGovernance.sol, line 3, import \"./interfaces/IProtocolGovernance.sol\";         ERC20Vault.sol, line 3, import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";         ERC20VaultGovernance.sol, line 4, import \"./interfaces/IProtocolGovernance.sol\";         GatewayVaultGovernance.sol, line 3, import \"./interfaces/IProtocolGovernance.sol\";         ILpIssuer.sol, line 3, import \"./IVault.sol\";         IProtocolGovernance.sol, line 4, import \"./IVaultRegistry.sol\";         IVaultFactory.sol, line 3, import \"./IVaultGovernance.sol\";         IVaultGovernance.sol, line 3, import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";         IVaultRegistry.sol, line 5, import \"./IVaultFactory.sol\";         IVaultRegistry.sol, line 6, import \"./IVaultGovernance.sol\";         LpIssuer.sol, line 9, import \"./interfaces/IProtocolGovernance.sol\";         LpIssuer.sol, line 11, import \"./DefaultAccessControl.sol\";         LpIssuerGovernance.sol, line 4, import \"./interfaces/IProtocolGovernance.sol\";         AaveVaultGovernanceTest.sol, line 3, import \"../interfaces/IAaveVaultGovernance.sol\";         ERC20VaultTest.sol, line 4, import \"../interfaces/IVaultFactory.sol\";         GatewayVaultTest.sol, line 4, import \"../interfaces/IVaultFactory.sol\";         TestEncoding.sol, line 4, import \"../interfaces/IVaultGovernance.sol\";         TestEncoding.sol, line 5, import \"../interfaces/IVaultRegistry.sol\";         TestFunctionEncoding.sol, line 4, import \"../interfaces/IVaultGovernance.sol\";         TestFunctionEncoding.sol, line 5, import \"../interfaces/IVault.sol\";         UniV3VaultGovernanceTest.sol, line 3, import \"../interfaces/IUniV3VaultGovernance.sol\";         UniV3VaultTest.sol, line 4, import \"../interfaces/IVaultFactory.sol\";         IChiefTrader.sol, line 3, import \"../../interfaces/IProtocolGovernance.sol\";         UniV3Vault.sol, line 3, import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";         UniV3Vault.sol, line 5, import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";         UniV3VaultGovernance.sol, line 3, import \"./interfaces/IProtocolGovernance.sol\";         VaultGovernance.sol, line 3, import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";         VaultRegistry.sol, line 6, import \"./interfaces/IVaultFactory.sol\";         YearnVault.sol, line 3, import \"./interfaces/external/aave/ILendingPool.sol\";         YearnVault.sol, line 7, import \"./libraries/ExceptionsLibrary.sol\";         YearnVaultGovernance.sol, line 3, import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";         YearnVaultGovernance.sol, line 4, import \"./interfaces/IProtocolGovernance.sol\";         YearnVaultGovernance.sol, line 7, import \"./libraries/ExceptionsLibrary.sol\";   "}, {"title": "TRANSMUTATION_PERIOD Issues", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Using existing local variables instead of reading state variables will save gas by converting SLOADs to MLOADs.   ## Proof of Concept  newTransmutationPeriod can be used here instead of TRANSMUTATION_PERIOD : https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L194  TRANSMUTATION_PERIOD is named like a constant when it is actually an updatable state variable.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Use the local variable instead of the state variable. Rename TRANSMUTATION_PERIOD appropriately.  "}, {"title": "Context and msg.sender", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contract Transmuter inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract Transmuter is Context ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender.  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.   "}, {"title": "Optimize `Alchemist.sol#_withdrawFundsTo`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept `L839-L843` is as follow: ```             AlchemistVault.Data storage _activeVault = _vaults.last();             (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(                 _recipient,                 _remainingAmount             ); ``` It can be replaced by following code block, since there is no reason to save it to memory. ```             (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults.last().withdraw(                 _recipient,                 _remainingAmount             ); ``` ## Tools Used Manual analysis  "}, {"title": "`AlchemistVault.sol` can be optimised", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept There is no need to cache calculation steps between the return values. `L98-L122` is as follows: ```         uint256 _endingBalance = _token.balanceOf(_recipient);         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _endingTotalValue = _self.totalValue();         uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue); ```  Which can be replaced by following code to save gas:  ```         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _decreasedValue = _startingTotalValue.sub(_self.totalValue()); ```  ## Tools Used  Manual analysis  "}, {"title": "Gas optimization: Reduce storage write", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L630 The line can be rewritten as  `_remainingAmount = _remainingAmount.add(_borrowFeeAmount);`  to reduce a storage write. Alternatively use a memory variable to preserve code readability.   "}, {"title": "Removing the unnecessary function", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  xxxxx   # Vulnerability details  ## Impact The unnecessary code can be removed to reduce contract size.  ## Proof of Concept In the contract \"Alchemist.sol\" the function \"_expectCaller\" is never used.   ## Tools Used Remix solidity 0.6.12 ## Recommended Mitigation Steps The function \"_expectCaller(address _expectedCaller)\" can be removed.  "}, {"title": "`CDP.sol#getUpdatedTotalDebt` can be optimized", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Current implementation has two if statements, but actually the same logic can be coded with only one if statement. Since `_unclaimedYield == 0` is a special case of `_unclaimedYield < _currentTotalDebt` and does not require any extra code.  ```   function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {     uint256 _unclaimedYield = _self.getEarnedYield(_ctx);     uint256 _currentTotalDebt = _self.totalDebt;      if (_unclaimedYield < _currentTotalDebt) {       return _currentTotalDebt - _unclaimedYield;     }     else {       return 0;     }   } ``` ## Tools Used Manual analysis  "}, {"title": "`CDP.sol#update.sol` can be optimized", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept The current code is: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       uint256 _currentTotalDebt = _self.totalDebt;       _self.totalDebt = 0;       _self.totalCredit = _earnedYield.sub(_currentTotalDebt);     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` We cache _self.totalDebt, but it is not required, since we can use it before we change it. This code block can be replaced with: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       _self.totalCredit = _earnedYield.sub(_self.totalDebt);       _self.totalDebt = 0;     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` By doing so, we don't cache `_self.totalDebt` just to use it once.  "}, {"title": "Gas Optimization: Inline instead of modifier", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `onlyAdmin` of YaxisVaultAdapter.sol is only used in `withdraw`, it is advised to inline the function to save some gas without losing readability.   ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L37  "}, {"title": "`Transmuter.unstake` updates user without first updating distributing yield", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/66", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  cmichel   # Vulnerability details  The `updateAccount` function should capture the latest distributed yield to the Transmuter (stored in `buffer`) and therefore work with the latest `totalDividendPoints` variable. This variable is updated when running a phase distribution with `runPhasedDistribution`.  Unlike all other function that call `updateAccount`, the `unstake` function does not first run a `runPhasedDistribution` modifer to distribute the latest yield.  ## Impact Users that unstake lose out on some yield by not having their alTokens transmuted.  ## Recommended Mitigation Steps Call `runPhasedDistribution` in `unstake` before the `updateAccount` call, as in `stake` or `transmute`.  "}, {"title": "`Alchemist.sol#mint()` Two storage writes can be combined into one", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `Alchemist.sol#mint()`, when `borrowFee > 0`, `_cdp.totalDebt` will be written 2 times. Combing them into one storage write can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L611-L645  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _cdp.totalDebt = _cdp.totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  ### Recommendation  Change to:  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;     uint256 _totalDebt = _cdp.totalDebt;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _totalDebt = _totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  "}, {"title": "Save `vault.getToken()` as an immutable variable in `YaxisVaultAdapter.sol` contract can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  Across the functions in `YaxisVaultAdapter.sol`, `vault.getToken()` is called many times, each one will cost a significant amount of gas due to external call.  Given that the result of `vault.getToken()` will never change, create an immutable variable named `token` in the contract and replace `vault.getToken()` with `token` can save gas.  `vault.getLPToken()` is a similar situation, it can also be cached as an immutable variable.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L45-L45  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L70-L70  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L76-L76  "}, {"title": "`YaxisVaultAdapter.sol#withdraw()` will most certainly fail", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/46", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  The actual token withdrawn from `vault.withdraw()` will most certainly less than the `_amount`, due to precision loss in `_tokensToShares()` and `vault.withdraw()`.  As a result, `IDetailedERC20(_token).safeTransfer(_recipient, _amount)` will revert due to insufficant balance.  Based on the simulation we ran, it will fail `99.99%` of the time unless the pps == 1e18.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L68-L72  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     vault.withdraw(_tokensToShares(_amount));     address _token = vault.getToken();     IDetailedERC20(_token).safeTransfer(_recipient, _amount); } ```  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/Vault.sol#L181-L187  ```solidity function withdraw(     uint256 _shares )     public     override {     uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply()); ```  ### Recommendation  Change to:  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     address _token = vault.getToken();     uint256 beforeBalance = IDetailedERC20(_token).balanceOf(address(this));          vault.withdraw(_tokensToShares(_amount));      IDetailedERC20(_token).safeTransfer(         _recipient,         IDetailedERC20(_token).balanceOf(address(this)) - beforeBalance     ); } ```  "}, {"title": "Only using `SafeMath` when necessary can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  or the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L623-L637  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount.sub(_totalCredit);     // ... } ```  `_amount - _totalCredit` will never underflow.  ### Recommendation  Change to:  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount - _totalCredit;     // ... } ```  "}, {"title": "Use immutable variable can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L23-L27  ```solidity=23 /// @dev The vault that the adapter is wrapping.     IVault public vault;      /// @dev The address which has admin control over this contract.     address public admin; ```  `vault` and `admin` will never change, use immutable variable instead of storage variable can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L55-L56  ```solidity address public AlToken; address public Token; ```  `AlToken` and `Token` can also be changed to `immutable`.  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L114-L122  ```solidity=114 /// @dev The token that this contract is using as the parent asset. IMintableERC20 public token;  /// @dev The token that this contract is using as the child asset. IMintableERC20 public xtoken; ```  `token` and `xtoken` can also be changed to `immutable`.  ### Recommendation  Change to:  ```solidity /// @dev The vault that the adapter is wrapping. IVault public immutable vault;  /// @dev The address which has admin control over this contract. address public immutable admin;  constructor(IVault _vault, address _admin) public {     vault = _vault;     admin = _admin;     address _token = _vault.getToken();     IDetailedERC20(_token).safeApprove(address(_vault), uint256(-1)); } ```  "}, {"title": "Incorrect function docs", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The functions `AlToken::setBlacklist` and `AlToken::pauseAlchemist` in `v3/alchemix` state in their docs: \"This function reverts, if the caller does not have the admin role\".  However, the functions revert if the caller does not have the **sentinel** role.  See [lines 93-98](https://github.com/code-423n4/2021-11-yaxis/blob/main/contracts/v3/alchemix/AlToken.sol#L93).  "}, {"title": "No event for `Alchemist.sol#setPegMinimum`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/24", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact The change of `pegMinimum` is crucial for the funcionality of the contract. Users should be informed about the changes. Furthermore, when `pegMinimum` is set to be maximum of `uin256`, functions such as `mint`, `liquidate` and `repay` cannot be used. Therefore, the change of `pegMinimum` should be emitted to create a safe environment for users.   ## Tools Used Manual analysis ## Recommended Mitigation Steps Emit the changes. Furthermore, it would be better if for such a change users get notified beforehand with a mechanism such as Timelock.  "}, {"title": "At `Alchemist.sol#acceptGovernance`, cache `pendingGovernance` earlier to save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact `Alchemist.sol#acceptGovernance`(L216-225) is: ```     function acceptGovernance() external {         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         address _pendingGovernance = pendingGovernance;         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` It can be replaced with following code to save gas: ```     function acceptGovernance() external {         address _pendingGovernance = pendingGovernance;         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` ## Tools Used  Manual analysis  "}, {"title": "Remove FixedPointMath ", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Including unused libraries could potentially use up gas and certainly makes the code more difficult to understand, hindering developer integrations/poor confused security auditors.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L19 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YearnVaultAdapter.sol#L19 The contract does not use FixedPointMath and compiles with these lines removed.  ## Recommended Mitigation Steps Remove line 10,19 from each contract (FixedPointMath lines). I'd also prefer the removal of  import \"hardhat/console.sol\"; but this is not having any impact and is just to tidy and shorten the files.  "}, {"title": "Prevent Minting During Emergency Exit", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Potential increased financial loss during security incident.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L611 Consider a critical incident where a vault is being drained or in danger of being drained due to a vulnerability within the vault or its strategies. At this stage, you want to trigger emergency exit and users want to withdraw their funds and repay/liquidate to enable the withdrawal of funds. However, minting against debt does not seem like a desirable behaviour at this time. It only seems to enable unaware users to get themselves into trouble by locking up their funds, or allow an attacker to do more damage.  ## Recommended Mitigation Steps Convert emergency exit check to a modifier, award wardens who made that suggestion, and then apply that modifier here.  Alternatively, it is possible that the team might want to allow minting against credit: users minting against credit would effectively be cashing out their rewards. This might be seen as desirable during emergency exit, or it might be seen as a potential extra source of risk. If this is desired, then the emergency exit check could be placed at line 624 with a modified message, instructing users to only use credit.  "}, {"title": "Convert Emergency Exit Check to Modifier.", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Gas saving on deployment. Guaranteed consistency, especially if making the same check across multiple functions (and I'm about to suggest that you might want to check this more). Increased functionality of inheriting contracts. Improved readability and code organisation. Basically, every reason that modifiers exist in the first place.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L457 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L489  ## Tools Used  ## Recommended Mitigation Steps Convert emergency exit check to modifier.   "}, {"title": "Incorrect Event Emitted in Alchemist.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact The event emitted is for the updating of a different fee (the harvest fee). This could cause potential issues for any system wishing to integrate with yAxis and wishing to monitor changes to the system and potentially react to them. Such a system could record the wrong harvest  fee and would be unaware of updates to the borrow fee.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L299 Is the same as line 284  ## Recommended Mitigation Steps Create a new event: event BorrowFeeUpdated(uint256 borrowfee); and call it on line 299 instead of HarvestFeeUpdated   "}, {"title": "Incorrect Info in Comment in Alchemist.sol (138)", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 138 of Alchemist.sol /// @dev The percent of each profitable harvest that will go to the rewards contract. This comment is incorrect. The borrow fee is charged on mint against debt, not harvest.  ## Recommended Mitigation Steps Edit the comment.   "}, {"title": "Incorrect Info in Comment in Alchemist.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 157-8 of Alchemist.sol    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either     /// create a new address or set up a proxy contract that interfaces with this contract. A proxy contract is not an option as most of the functions in the Alchemist contract have a noContractAllowed  modifier.  ## Recommended Mitigation Steps Edit the comment to remove the proxy suggestion.   "}, {"title": "Lack of 'emit' keyword in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact An event is called without the emit keyword  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L100  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'emit' keyword in the event emission.  "}, {"title": "Gas optimization in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Double calculation of the same value in mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L69  ## Tools Used Manual review  ## Recommended Mitigation Steps The _total variable in line 66 is defined as _amount + hasMinted(msg.sender). Line 69 needs that value again but recalculates it again instead of using the stored one. Replace line 69 with hasMinted(msg.sender) = _total  "}, {"title": "Gas optimization when a paused user calls mint() in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Gas saved when a paused user calls mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L68  ## Tools Used Manual review  ## Recommended Mitigation Steps Check for the paused condition before checking for the ceiling condition. If the user is paused, the function reverts earlier, saving gas.  "}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/55", "labels": ["bug", "disagree with severity", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L322-L324 ```solidity=322 function setGovernance(address _governance) external onlyGovernance {     _setGovernance(_governance); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L331-L333 ```solidity=331 function approveContractAccess(address account) external onlyGovernance {     _approveContractAccess(account); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L335-L337 ```solidity=335 function revokeContractAccess(address account) external onlyGovernance {     _revokeContractAccess(account); } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L116-L119 ```solidity=116 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L121-L124 ```solidity=121 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```    https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L130-L133 ```solidity=130 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L135-L138 ```solidity=135 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```   "}, {"title": "Missing `_token.approve()` to `curvePool` in `setZapConfig`", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/53", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/SettToRenIbbtcZap.sol#L162-L183  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  In the current implementation, when `curvePool` or `token` got updated, `token` is not approved to `curvePool`, which will malfunction the contract and break minting.  ### Recommendation  Change to:  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          if (zapConfigs[_idx].curvePool != _curvePool && _curvePool != address(0)) {             IERC20Upgradeable(_token).safeApprove(                 _curvePool,                 type(uint256).max             );         }          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  "}, {"title": "Excessive `require` makes the transaction fail unexpectedly", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/50", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check for `RENCRV_VAULT.blockLock` is only needed when `if (_amounts[1] > 0 || _amounts[2] > 0)`.   However, in the current implementation, the check is done at the very first, making transactions unrelated to `RENCRV_VAULT` fail unexpectedly if there is a prior transaction involved with `RENCRV_VAULT` in the same block.  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/IbbtcVaultZap.sol#L149-L199  ```solidity=149{154-157,182} function deposit(uint256[4] calldata _amounts, uint256 _minOut)     public     whenNotPaused {     // Not block locked by setts     require(         RENCRV_VAULT.blockLock(address(this)) < block.number,         \"blockLocked\"     );     require(         IBBTC_VAULT.blockLock(address(this)) < block.number,         \"blockLocked\"     );      uint256[4] memory depositAmounts;      for (uint256 i = 0; i < 4; i++) {         if (_amounts[i] > 0) {             ASSETS[i].safeTransferFrom(                 msg.sender,                 address(this),                 _amounts[i]             );             if (i == 0 || i == 3) {                 // ibbtc and sbtc                 depositAmounts[i] += _amounts[i];             }         }     }      if (_amounts[1] > 0 || _amounts[2] > 0) {         // Use renbtc and wbtc to mint ibbtc         // NOTE: Can change to external zap if implemented         depositAmounts[0] += _renZapToIbbtc([_amounts[1], _amounts[2]]);     }     // ... } ```   "}, {"title": "Unused local variables", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/39", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L177-L179  ```solidity=177 function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L196-L198  ```solidity=196 function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L274-L275  ```solidity=274 uint _fee; uint _ren; ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L295-L296  ```solidity=295 uint _fee; uint _wbtc; ```  "}, {"title": "ibbtcCurveLP can be simplified", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/21", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unneeded branches and returns can reduce gas usage and improve code clarity.  ## Proof of Concept  This code https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L309-L317 can be refactored to:  ```  if (bBtc <= max) {   // pesimistically charge 0.5% on the withdrawal.   // Actual fee might be lesser if the vault keeps keeps a buffer   uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);   lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);   fee = fee.add(strategyFee);  } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC  "}, {"title": "Missing overflow protection", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/13", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `deposit` in `IbbtcVaultZap.sol` computes two additions without overflow protection, see lines [158](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L158) and [166](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L166).  In the first case, i.e. line 158, the addition can be changed to an assignment, as `depositAmount[i]` is always 0.  In the second case, i.e. line 166, an overflow would lead to a wrong amount of funds deposited into Curve and from there to a wrong amount of LP tokens send to the `msg.sender`.  ## Recommended Steps of Mitigation As OpenZeppelin's `SafeMathUpgradeable` library is already imported, use their `add` function instead of the native `+` operator.  "}, {"title": "Zap.sol declares unused variable `_ren` in `calcRedeemInRen` among other functions", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/4", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  The variable `_ren` in `Zap.calcRedeemInRen` is declared but unused. This increases gas costs for no benefit.  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L272-L280  This also happens in other functions.  ## Recommended Mitigation Steps  Remove unused variable  "}, {"title": "`withdrawTo` Does Not Sync Before Checking A Position's Margin Requirements", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/74", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `maintenanceInvariant` modifier in `Collateral` aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. `maintenanceInvariant` inevitably calls `AccountPosition.maintenance` which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, `maintenanceInvariant` may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.  ## Proof of Concept  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76 ``` function withdrawTo(address account, IProduct product, UFixed18 amount) notPaused collateralInvariant(msg.sender, product) maintenanceInvariant(msg.sender, product) external {     _products[product].debitAccount(msg.sender, amount);     token.push(account, amount);      emit Withdrawal(msg.sender, product, amount); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241 ``` modifier maintenanceInvariant(address account, IProduct product) {     _;      UFixed18 maintenance = product.maintenance(account);     UFixed18 maintenanceNext = product.maintenanceNext(account);      if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))         revert CollateralInsufficientCollateralError(); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75 ```     function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {         Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());         UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();         return notionalMax.mul(provider.maintenance());     } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding `settleForAccount(msg.sender)` to the `Collateral.withdrawTo` function to ensure the most up to date oracle price is used when assessing an account's margin requirements.  "}, {"title": "On updating the Incentive fee greater than UFixedLib18.ONE, new Programs can not be created", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/72", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  hubble   # Vulnerability details  ## Impact Incentivizer.updateFee expects a value between UFixed18Lib.ZERO and UFixed18Lib.ONE. When the incentive fee is updated outside of this range, the program creation fails and the product owners would not be able to add new Programs to the Product.  ## Proof of Concept Step 1. Update incentive fee File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369             fee = newFee; ...  Step 2. Create new Program File: /protocol/contracts/incentivizer/Incentivizer.sol Line 59    function create(ProgramInfo calldata info)  File: /protocol/contracts/incentivizer/types/ProgramInfo.sol Line 55         Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee)); ...  Note: Fails at line 55, whenever fee is greater than UFixedLive.ONE  ## Tools Used Manual code review  ## Recommended Mitigation Steps Implement Range check   File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369          if(newFee.gte(UFixed18Lib.ONE)) revert NewError(\"newFee should be less than UFixed18Lib.ONE\"); Line 370          fee = newFee;  Note: Range check at line 369  "}, {"title": "At settleAccountInternal, check whether the position can be changeable to pre more efficiently", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  0x0x0x   # Vulnerability details  In case `oracleVersionCurrent != oracleVersionPreSettle`,  the following line  `accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));` ([https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136))  doesn't make any change. This line can be at the beginning of the `if` statement below to save gas.  "}, {"title": "At `Product.sol#closeAll`, cache `_position[account]`", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  0x0x0x   # Vulnerability details  At `Product.sol#closeAll` cache `_position[account]` to save gas.   In the first line of the function `_position[account]` is used twice and gas can be saved by caching it.  "}, {"title": "Fixed18 conversions don't work for all values", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  cmichel   # Vulnerability details  Certain functions in the `Fixed18` contract perform multiplications by `ONE` or `NEG_ONE` before diving by it again which leads to issues that these functions revert for all values `> MAX_UINT256 / ONE`, but they should not.  ```solidity function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {     if (s > 0) return from(m);     // @audit cannot convert large values because (m * NEG_ONE) might overflow     if (s < 0) return mul(from(m), NEG_ONE);     return ZERO; }  function abs(Fixed18 a) internal pure returns (UFixed18) {     // @audit cannot get abs value if multiplication of a * -1e18 /1e18 overflows. why not unwrap => unary minus     return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a); } ```  ## Recommendation Change the implementation to not perform the useless `* 1e18 / 1e18` computations to cover the entire input range. Consider using a typecast `int256(UFixed18.unwrap(m))` after checking the range instead of doing `* NEG_ONE / 1e18`   "}, {"title": "Missing fee parameter validation", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  cmichel   # Vulnerability details  Some fee parameters of functions are not checked for invalid values: - `Collateral.updateLiquidationFee`: The `newLiquidationFee` should be less than 100% - `Factory.updateFee`: The `newFee` should be less than 100%  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "claimFee loop does not check for zero transfer amount (Incentivizer.sol) ", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Transfer amount can be checked for > 0 before calling `push' which makes a call to `safeTransfer`. This can save gas by avoiding the external call.  ## Proof of Concept  The transfer is here: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L237-L238   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Check that transfer amount > 0 before L#237-238 are executed.  Consider checking for `amount` > 0 in these functions: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L68 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L85  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `provider`, `factory()` in `Product#settleInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L72-L100   - `provider`, `_accumulator` in `Product#settleAccountInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L123-L152   - `factory()` in `Collateral#settleProduct()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L131-L145  "}, {"title": "Best Practice: public functions not used by current contract should be external", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style does not follow the best practices:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L171-L173  ```solidity=171 function shortfall(IProduct product) public view returns (UFixed18) {     return _products[product].shortfall; } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L256-L258  ```solidity=256 function maintenance(address account) public view returns (UFixed18) {     return _positions[account].maintenance(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L266-L268  ```solidity=266 function maintenanceNext(address account) public view returns (UFixed18) {     return _positions[account].maintenanceNext(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L259-L261  ```solidity=259 function treasury() public view returns (address) {     return treasury(0); } ```  "}, {"title": "`Factory.sol#updateController()` Lack of input validation", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  `newController.owner` should be validated to make sure the new owner's address is not `address(0)`.  Otherwise, if the owner mistakenly calls `updateController()` with improper inputs can result in all the `onlyOwner(controllerId)` methods being unaccessible.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L103-L106  ```solidity=103 function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {     _controllers[controllerId] = newController;     emit ControllerUpdated(controllerId, newController.owner, newController.treasury); } ```  "}, {"title": "Cache storage read and call results in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  Caching the result of `_registry[product].length()` can save gas from unnecessary extra SLOAD, function call, and code execution, especially in for loops.  Instances include:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L144-L144  ```solidity=144 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L174-L174  ```solidity=174 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L190-L190  ```solidity=190 for (uint256 i; i < _registry[product].length(); i++) { ```  "}, {"title": "Reuse operation results can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L232-L242  ```solidity=232{234,238} function claimFee(Token18[] calldata tokens) notPaused external {     for(uint256 i; i < tokens.length; i++) {         Token18 token = tokens[i];         UFixed18 amount = fees[token];          fees[token] = UFixed18Lib.ZERO;         tokens[i].push(factory().treasury(), amount);          emit FeeClaim(token, amount);     } } ```  `tokens[i]` at L238 is already cached in the local variable `token` at L234, resuing the result instead of doing the subscript operation again can save gas.  ### Recommendation  Change  ```solidity tokens[i].push(factory().treasury(), amount); ```  to:  ```solidity token.push(factory().treasury(), amount); ```  "}, {"title": "Avoid unnecessary `SafeCast.toInt256()` can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29  ```solidity=29 uint256 private _decimalOffset; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50{52} function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  `_decimalOffset` is only used at L52\u3002  Therefore `_decimalOffset` can be defined as `int256` and avoid unnecessary `SafeCast.toInt256()`.  "}, {"title": "Use immutable variables can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L20-L20 ```solidity=20 IChainlinkFeed public feed; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29 ```solidity=29 uint256 private _decimalOffset; ```  In `ChainlinkOracle.sol`, `feed` and `_decimalOffset` will never change, use immutable variables instead of storage variables can save gas.   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/ProductProviderBase.sol#L13-L13  ```solidity=13 IOracle public oracle; ```  In `ProductProviderBase.sol`, `oracle` will never change, use immutable variables instead of storage variables can save gas.  "}, {"title": "Adding a new method `provider.currentPrice()` can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas.  There are many times across the codebase that will perform two external calls to the provider to query the current `oraclePrice`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/AccountPosition.sol#L72-L72  ```solidity=72 Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion()); ```  Consider adding a new method to the provider and return the current `oraclePrice` directly can combine two external calls into one and save some gas.  "}, {"title": "Avoid unnecessary external calls can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  If `block.timestamp - timestampAtVersion[currentVersion()] < minDelay`, there is no need to call `feed.latestRoundData()`.  ### Recommendation  Change to:  ```solidity=50 function sync() public {     if (priceAtVersion.length == 0 || block.timestamp - timestampAtVersion[currentVersion()] >= minDelay ) {         (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();         Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));          if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {             priceAtVersion.push(price);             timestampAtVersion.push(timestamp);              emit Version(currentVersion(), timestamp, price);         }     } } ```  "}, {"title": "Chainlink's `latestRoundData` might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  On `ChainlinkOracle.sol`, we are using `latestRoundData`, but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:  - https://docs.chain.link/docs/historical-price-data/#historical-rounds - https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  ### Recommendation  Consider adding missing checks for stale data.   For example:  ```solidity (uint80 roundID, int256 feedPrice, , uint256 timestamp, uint80 answeredInRound) = feed.latestRoundData(); require(feedPrice > 0, \"Chainlink price <= 0\");  require(answeredInRound >= roundID, \"Stale price\"); require(timestamp != 0, \"Round not complete\"); ```  "}, {"title": "`Token18.sol#balanceOf()` When `isEther()`, `fromTokenAmount()` is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118 function decimals(Token18 self) internal view returns (uint8) {     return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals(); } ```  Therefore, in `Token18.sol#balanceOf()`, `fromTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L137-L142  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     uint256 tokenAmount = isEther(self) ?         account.balance :         IERC20(Token18.unwrap(self)).balanceOf(account);     return fromTokenAmount(self, tokenAmount); } ```  Can be changed to:  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     return isEther(self) ?         UFixed18.wrap(account.balance) :         fromTokenAmount(self, IERC20(Token18.unwrap(self)).balanceOf(account)); } ```  "}, {"title": "`Token18.sol#push()` When `isEther()`, `toTokenAmount()` is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118     function decimals(Token18 self) internal view returns (uint8) {         return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();     } ```  Therefore, in `Token18.sol#push()`, `toTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51-L59  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  Can be changed to:  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), UFixed18.unwrap(amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  "}, {"title": "`10 ** 18` can be changed to `1e18` and save some gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L151-L154  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);     return UFixed18.unwrap(amount.mul(conversion)); } ```  Can be changed to:  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 1e18);     return UFixed18.unwrap(amount.mul(conversion)); } ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L163-L166  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```  Can be changed to:  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(1e18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```   "}, {"title": "Avoid unnecessary arithmetic operations can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/PrePosition.sol#L145-L156  ```solidity=145 function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {     Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);     Position memory positionDelta = self.openPosition.add(self.closePosition);      (UFixed18 makerNotional, UFixed18 takerNotional) = (         Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),         Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()     );      positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));     positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee())); } ```  At L154, `positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));`  can be changed to `positionFee = makerNotional.mul(provider.safeMakerFee());` as `positionFee == 0`.  Futhermore, L154-155 can be combined into:  ```solidity positionFee = makerNotional.mul(provider.safeMakerFee()).add(     takerNotional.mul(provider.safeTakerFee()) ); ```  "}, {"title": "Wrong shortfall calculation", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/18", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  kenzo   # Vulnerability details  Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.  ## Impact Loss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.  ## Proof of Concept We can see in the `settleAccount` of `OptimisticLedger` that self.shortfall ends up being self.shortfall+self.shortfall+newShortfall: [(Code ref)](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74) ```     function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)     internal returns (UFixed18 shortfall) {         Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);          if (newBalance.sign() == -1) {             shortfall = self.shortfall.add(newBalance.abs());             newBalance = Fixed18Lib.ZERO;         }          self.balances[account] = newBalance.abs();         self.shortfall = self.shortfall.add(shortfall);     } ```  Additionally, you can add the following line to the \"shortfall reverts if depleted\" test in Collateral.test.js, line 190: ``` await collateral.connect(productSigner).settleAccount(userB.address, -50) ``` Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.  ## Recommended Mitigation Steps Move the setting of `self.shortfall` to inside the if function and change the line to: ``` self.shortfall = shortfall ```  "}, {"title": "Unsecure Ownership Transfer", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Lost the owner by human error.  ## Proof of Concept The modification process of an owner is a delicate process, since the governance of our contract and therefore of the project may be at risk, for this reason it is recommended to adjust the owner\u2019s modification logic, to a logic that allows to verify that the new owner is in fact valid and does exist.  It's mandatory to create a logic of the owner\u2019s modification where a new owner is proposed first, the owner accepts the proposal and, in this way, we make sure that there are no errors when writing the address of the new owner.   Source reference: - UOwnable.transferOwnership  ## Tools Used Manual review  ## Recommended Mitigation Steps Use an ACK method for approve the new owner.  "}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  robee   # Vulnerability details  Not verified address arguments of external/public functions is a low risk issue.  It's less severe for onlyOwner methods but for any other method it's crucial since the default address is 0.          Argument account of Collateral.depositTo is not verified to be != 0         Argument account of Collateral.withdrawTo is not verified to be != 0         Argument account of Collateral.liquidate is not verified to be != 0         Argument account of Collateral.settleAccount is not verified to be != 0         Argument account of Collateral.collateral is not verified to be != 0         Argument account of Collateral.liquidatable is not verified to be != 0         Argument account of Collateral.liquidatableNext is not verified to be != 0         Argument treasury_ of Factory.initialize is not verified to be != 0         Argument controllerTreasury of Factory.createController is not verified to be != 0         Argument newPauser of Factory.updatePauser is not verified to be != 0         Argument account of Incentivizer.syncAccount is not verified to be != 0         Argument account of Incentivizer.unclaimed is not verified to be != 0         Argument account of Incentivizer.latestVersion is not verified to be != 0         Argument account of Incentivizer.settled is not verified to be != 0         Argument account of Product.settleAccount is not verified to be != 0         Argument account of Product.closeAll is not verified to be != 0         Argument account of Product.maintenance is not verified to be != 0         Argument account of Product.maintenanceNext is not verified to be != 0         Argument account of Product.isClosed is not verified to be != 0         Argument account of Product.isLiquidating is not verified to be != 0         Argument account of Product.position is not verified to be != 0         Argument account of Product.pre is not verified to be != 0         Argument account of Product.latestVersion is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument benefactor of MockToken18.pull is not verified to be != 0         Argument benefactor of MockToken18.pullTo is not verified to be != 0         Argument recipient of MockToken18.pullTo is not verified to be != 0         Argument account of MockToken18.balanceOf is not verified to be != 0         Argument newOwner of UOwnable.transferOwnership is not verified to be != 0   "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Incentivizer.sol, line 3, import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";         Program.sol, line 4, import \"../../utils/types/Token18.sol\";         IIncentivizer.sol, line 5, import \"../product/types/position/Position.sol\";         ChainlinkOracle.sol, line 5, import \"../utils/types/UFixed18.sol\";         AccountPosition.sol, line 4, import \"../accumulator/Accumulator.sol\";  "}, {"title": "Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/258", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735  ```solidity function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {     // cannot have an active incentive for the callee     require(incentives[who] == 0, \"inc\");     ... ```  When an incentiveToken is claimed after `endStream`, `incentives[who]` will be `0` for that `incentiveToken`.  If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as `who` and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.  ### PoC  1. Alice approved `USDC` to the streaming contract; 2. Alice called `createIncentive()` and added `1,000 USDC` of incentive; 3. After the stream is done, the stream creator called `claimIncentive()` and claimed `1,000 USDC`;  The compromised protocol gov can call `arbitraryCall()` and steal all the USDC in Alice's wallet balance.  ### Recommendation  Consider adding a mapping: `isIncentiveToken`, setting `isIncentiveToken[incentiveToken] = true` in `createIncentive()`, and `require(!isIncentiveToken[who], ...)` in `arbitraryCall()`.  "}, {"title": "Inconsistent check of token balance", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/249", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  `require(newBal <= type(uint112).max ...)` vs `require(newBal < type(uint112).max...)`.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L386-L386 ```solidity=386 require(newBal < type(uint112).max && newBal > prevBal, \"erc\"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L427-L427 ```solidity=427 require(newBal <= type(uint112).max && newBal > prevBal, \"erc\"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L506-L506 ```solidity=506 require(newBal <= type(uint112).max && newBal > prevBal, \"erc\"); ```  "}, {"title": "Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/241", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens); ```  In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.  As a result:  - When the protocol `governance` calls `claimFees()` and claim accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken. - Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.  ### PoC  Given:  - `feeEnabled`: true - `feePercent`: 10 (0.1%)  1. Alice deposited `1,000,000` depositToken; 2. Bob called `flashloan()` and borrowed `1,000,000` depositToken, then repaid `1,001,000`; 3. Charlie deposited `1,000` depositToken; 4. After `endDepositLock`, Alice called `claimDepositTokens()` and withdrawn `1,000,000` depositToken; 5. `streamCreator` called `recoverTokens(depositToken, recipient)` and retrieved `1,000` depositToken `(2,000 - (1,001,000 - 1,000,000))`; 6. `governance` called `claimFees()` and retrieved another `1,000` depositToken; 7. Charlie tries to `claimDepositTokens()` but since the current balanceOf depositToken is `0`, the transcation always fails, and Charlie loses all the depositToken.  ### Recommendation  Change to:  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - depositTokenFlashloanFeeAmount; ```  "}, {"title": "DOS while dealing with erc20 when value(i.e amount*decimals)  is high but less than type(uint112).max", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/228", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle\r \r hack3r-0m\r \r \r # Vulnerability details\r \r ## Impact\r \r https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229\r \r reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.\r \r ## Proof of Concept\r \r Attaching diff to modify tests to reproduce behaviour:\r \r ```\r diff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol\r index 2be8db0..aba19ce 100644\r --- a/Streaming/src/test/Locke.t.sol\r +++ b/Streaming/src/test/Locke.t.sol\r @@ -166,14 +166,14 @@ contract StreamTest is LockeTest {\r          );\r  \r          testTokenA.approve(address(stream), type(uint256).max);\r -        stream.fundStream((10**14)*10**18);\r +        stream.fundStream(1000);\r  \r -        alice.doStake(stream, address(testTokenB), (10**13)*10**18);\r +        alice.doStake(stream, address(testTokenB), 100);\r  \r  \r          hevm.warp(startTime + minStreamDuration / 2); // move to half done\r          \r -        bob.doStake(stream, address(testTokenB), (10**13)*10**18);\r +        bob.doStake(stream, address(testTokenB), 100);\r  \r          hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\r  \r @@ -182,10 +182,10 @@ contract StreamTest is LockeTest {\r          hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\r  \r  \r -        // alice.doClaimReward(stream);\r -        // assertEq(testTokenA.balanceOf(address(alice)), 533*(10**15));\r -        // bob.doClaimReward(stream);\r -        // assertEq(testTokenA.balanceOf(address(bob)), 466*(10**15));\r +        alice.doClaimReward(stream);\r +        assertEq(testTokenA.balanceOf(address(alice)), 533);\r +        bob.doClaimReward(stream);\r +        assertEq(testTokenA.balanceOf(address(bob)), 466);\r      }\r  \r      function test_stake() public {\r diff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol\r index eb38060..a479875 100644\r --- a/Streaming/src/test/utils/LockeTest.sol\r +++ b/Streaming/src/test/utils/LockeTest.sol\r @@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {\r          testTokenA = ERC20(address(new TestToken(\"Test Token A\", \"TTA\", 18)));\r          testTokenB = ERC20(address(new TestToken(\"Test Token B\", \"TTB\", 18)));\r          testTokenC = ERC20(address(new TestToken(\"Test Token C\", \"TTC\", 18)));\r -        write_balanceOf_ts(address(testTokenA), address(this), (10**14)*10**18);\r -        write_balanceOf_ts(address(testTokenB), address(this), (10**14)*10**18);\r -        write_balanceOf_ts(address(testTokenC), address(this), (10**14)*10**18);\r -        assertEq(testTokenA.balanceOf(address(this)), (10**14)*10**18);\r -        assertEq(testTokenB.balanceOf(address(this)), (10**14)*10**18);\r +        write_balanceOf_ts(address(testTokenA), address(this), 100*10**18);\r +        write_balanceOf_ts(address(testTokenB), address(this), 100*10**18);\r +        write_balanceOf_ts(address(testTokenC), address(this), 100*10**18);\r +        assertEq(testTokenA.balanceOf(address(this)), 100*10**18);\r +        assertEq(testTokenB.balanceOf(address(this)), 100*10**18);\r  \r          defaultStreamFactory = new StreamFactory(address(this), address(this));\r  \r ```\r \r ## Tools Used\r \r Manual Review\r \r ## Recommended Mitigation Steps\r \r Consider doing arithmetic operations in two steps or upcasting to u256 and then downcasting. Alternatively, find a threshold where it breaks and add require condition to not allow total stake per user greater than threshhold.\r \r "}, {"title": "Tokens can be stolen when `depositToken == rewardToken`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/215", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows the `deposit` and `reward` tokens to be the same token.  > I believe this is intended, think Sushi reward on Sushi as is the case with `xSushi`.  The reward and deposit balances are also correctly tracked independently in `depositTokenAmount` and `rewardTokenAmount`. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:  ```solidity function recoverTokens(address token, address recipient) public lock {     // NOTE: it is the stream creators responsibility to save     // tokens on behalf of their users.     require(msg.sender == streamCreator, \"!creator\");     if (token == depositToken) {         require(block.timestamp > endDepositLock, \"time\");         // get the balance of this contract         // check what isnt claimable by either party         // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens         uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);         // allow saving of the token         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }          if (token == rewardToken) {         require(block.timestamp > endRewardLock, \"time\");         // check current balance vs internal balance         //         // NOTE: if a token rebases, i.e. changes balance out from under us,         // most of this contract breaks and rugs depositors. this isn't exclusive         // to this function but this function would in theory allow someone to rug         // and recover the excess (if it is worth anything)          // check what isnt claimable by depositors and governance         // @audit-info rewardTokenAmount increased on fundStream         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  #### POC Given `recoverTokens == depositToken`, `Stream` creator calls `recoverTokens(token = depositToken, creator)`.  - The `token` balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. `ERC20(token).balanceOf(address(this)) >= (depositTokenAmount - redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)` - `if (token == depositToken)` executes, the `excess` from the deposit amount will be the reward amount (`excess >= rewardTokenAmount + rewardTokenFeeAmount`). This will be transferred. - `if (token == rewardToken)` executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, `ERC20(token).balanceOf(address(this)) >= depositTokenAmount - redeemedDepositTokens`. If this is non-negative, the transaction does not revert and the creator makes a profit.  Example: - outstanding redeemable deposit token amount: `depositTokenAmount - redeemedDepositTokens = 1000` - funded `rewardTokenAmount` (plus `rewardTokenFeeAmount` fees): `rewardTokenAmount + rewardTokenFeeAmount = 500`  Creator receives `1500 - 1000 = 500` excess deposit and `1000 - 500 = 500` excess reward.  ## Impact When using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.  ## Recommended Mitigation Steps One needs to be careful with using `.balanceOf` in this special case as it includes both deposit and reward balances.  Add a special case for `recoverTokens` when `token == depositToken == rewardToken` and then the excess should be `ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount);`  "}, {"title": "Reward token not correctly recovered", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/214", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.  However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:  ```solidity function recoverTokens(address token, address recipient) public lock {     if (token == rewardToken) {         require(block.timestamp > endRewardLock, \"time\");          // check what isnt claimable by depositors and governance         // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  Note that `rewardTokenAmount` only ever _increases_ (when calling `fundStream`) but it never decreases when claiming the rewards through `claimReward`. However, `claimReward` transfers out the reward token.  Therefore, the `rewardTokenAmount` never tracks the contract's reward balance and the excess cannot be computed that way.  #### POC Assume no reward fees for simplicity and only a single user staking.  - Someone funds `1000` reward tokens through `fundStream(1000)`. Then `rewardTokenAmount = 1000`  - The stream and reward lock period is over, i.e. `block.timestamp > endRewardLock` - The user claims their full reward and receives `1000` reward tokens by calling `claimReward()`. The reward contract balance is now `0` but `rewardTokenAmount = 1000` - Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as the `excess = balance - rewardTokenAmount = 0`  ## Impact Reward token recovery does not work.  ## Recommended Mitigation Steps The claimed rewards need to be tracked as well, just like the claimed deposits are tracked. I think you can even decrease `rewardTokenAmount` in `claimReward` because at this point `rewardTokenAmount` is not used to update the `cumulativeRewardPerToken` anymore.  "}, {"title": "Inaccurate comment in `recoverTokens`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/213", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cmichel   # Vulnerability details  The `recoverTokens` function's comment states that the excess deposit tokens are `balance - depositTokenAmount`:  >     *      1. if its deposit token: >     *          - DepositLock is fully done >     *          - There are excess deposit tokens (balance - depositTokenAmount)  But it is `balance - (depositTokenAmount - redeemedDepositTokens)` where `(depositTokenAmount - redeemedDepositTokens)` is the outstanding redeemable amount.  ## Impact The code is correct.  ## Recommended Mitigation Steps Fix the comment.  "}, {"title": "Token owner cannot claim rewardToken if they are not the original depositor", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/204", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L553 stated that:  > Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens but the reward is only tracked to the original depositor in both case, see https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L558 ```         TokenStream storage ts = tokensNotYetStreamed[msg.sender]; ``` Transferring the LockeERC20 token does not transfer the TokenStream state.   "}, {"title": "Incentives paid to creator instead of depositor", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/201", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The documentation is unclear, but it make little sense that incentives are only paid to the stream creator instead of depositors. This make the incentives more like donation to the creator but not actually incentivizing the stream.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L518  "}, {"title": "Possible incentive theft through the arbitraryCall() function", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/199", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).   However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().   In summary:  1) If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.  2) Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735  ## Recommended Mitigation Steps  ### Recommendation 1 Limit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall().  ### Recommendation 2 Validate that the allowance of the target contract (if available) has not changed.  "}, {"title": "Creating rewardTokens without streaming depositTokens", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/166", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  bitbopper   # Vulnerability details  ## Impact  `stake` and `withdraws` can generate rewardTokens without streaming depositTokens.  It does not matter whether the stream is a sale or not.  The following lines can increase the reward balance on a `withdraw` some time after `stake`: https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222 ``` // accumulate reward per token info cumulativeRewardPerToken = rewardPerToken();  // update user rewards ts.rewards = earned(ts, cumulativeRewardPerToken); ```   While the following line can be gamed in order to not stream any tokens (same withdraw tx).  Specifically an attacker can arrange to create a fraction less than zero thereby substracting zero. https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229 ``` ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate)); // WARDEN TRANSLATION: (elapsedSecondsSinceStake * stakeAmount) / (endStreamTimestamp - stakeTimestamp) ```  A succesful attack increases the share of rewardTokens of the attacker. The attack can be repeated every block increasing the share further. The attack could be done from multiple EOA increasing the share further. In short: Attackers can create loss of funds for (honest) stakers.  The economic feasability of the attack depends on: - staked amount (times number of attacks) vs total staked amount - relative value of rewardToken to gasprice    ## Proof of Concept  ### code   The following was added to `Locke.t.sol` for the `StreamTest` Contract to simulate the attack from one EOA.  ```     function test_quickDepositAndWithdraw() public {         //// SETUP         // accounting (to proof attack): save the rewardBalance of alice.         uint StartBalanceA = testTokenA.balanceOf(address(alice));         uint112 stakeAmount = 10_000;          // start stream and fill it         (             uint32 maxDepositLockDuration,             uint32 maxRewardLockDuration,             uint32 maxStreamDuration,             uint32 minStreamDuration         ) = defaultStreamFactory.streamParams();          uint64 nextStream = defaultStreamFactory.currStreamId();         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10),              maxStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );                  testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1_000_000_000);          // wait till the stream starts         hevm.warp(block.timestamp + 16);         hevm.roll(block.number + 1);          // just interact with contract to fill \"lastUpdate\" and \"ts.lastUpdate\"   // without changing balances inside of Streaming contract         alice.doStake(stream, address(testTokenB), stakeAmount);         alice.doWithdraw(stream, stakeAmount);           ///// ATTACK COMES HERE         // stake         alice.doStake(stream, address(testTokenB), stakeAmount);          // wait a block         hevm.roll(block.number + 1);         hevm.warp(block.timestamp + 16);          // withdraw soon thereafter         alice.doWithdraw(stream, stakeAmount);          // finish the stream         hevm.roll(block.number + 9999);         hevm.warp(block.timestamp + maxDepositLockDuration);          // get reward         alice.doClaimReward(stream);            // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken         uint EndBalanceA = testTokenA.balanceOf(address(alice));         uint EndBalanceB = testTokenB.balanceOf(address(alice));          // Stream returned everything we gave it         // (doStake sets balance of alice out of thin air => we compare end balance against our (thin air) balance)         assert(stakeAmount == EndBalanceB);          // we gained reward token without risk         assert(StartBalanceA == 0);         assert(StartBalanceA < EndBalanceA);         emit log_named_uint(\"alice gained\", EndBalanceA);     } ```  ### commandline  ``` dapp test --verbosity=2 --match \"test_quickDepositAndWithdraw\" 2> /dev/null Running 1 tests for src/test/Locke.t.sol:StreamTest [PASS] test_quickDepositAndWithdraw() (gas: 4501209)  Success: test_quickDepositAndWithdraw    alice gained: 13227 ```  ## Tools Used  dapptools  ## Recommended Mitigation Steps Ensure staked tokens can not generate reward tokens without streaming deposit tokens. First idea that comes to mind is making following line `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L220` dependable on a positive amount > 0 of: `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229`  "}, {"title": "`rewardPerToken()` reverts before start time.", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/147", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `rewardPerToken()` is calculated according to `lastApplicableTime`and `lastUpdate`. [Locke.sol#L343-L353](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L343-L353) Since `lastUpdate` is set to `startTime` before the start time. [Locke.sol#L203-L250](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L203-L250), it reverts before the start time.  `lastApplicableTime()) - lastUpdate` would revert when `lastUpdate` is bigger than `lastApplicableTime()`.  ## Proof of Concept This is the web3.py script: ```python     stream.functions.stake(deposit_amount).transact()     stream.functions.rewardPerToken().call() ``` Since `rewardPerToken` returns zero when totalVirtualBalance equals zero, we have to stake a few funds to trigger this bug.  ## Tools Used hardhat ## Recommended Mitigation Steps Recommend to return zero before startTime. ```solidity     function rewardPerToken() public view returns (uint256) {         if (totalVirtualBalance == 0 || lastApplicableTime() < startTime) {             return cumulativeRewardPerToken;         } else {             // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance             return cumulativeRewardPerToken + (                 // NOTE: depositDecimalsOne                 ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration)                  / totalVirtualBalance             );         }     } ```  "}, {"title": "[Gas optimization] remove command less else in an if else", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  Omik   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L472 the withdraw and stake function there is unnecessary else statement which didnt have any command inside it, this can lead to gas consumption more expensive then using only if statement for isSale check.  ## Proof of Concept pragma solidity ^0.8.0;   contract testing {      uint public counter;      function test()public {         if(true){             counter += 1;         }else{          }     }//43582 gas      function test2()public {         if(true){             counter += 1;         }     }//26449 gas      }  "}, {"title": "Business logic bug in __abdicate() function - 2 Bugs", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/132", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cyberboy   # Vulnerability details  ## Impact The __abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the \"gov\" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.  ## Proof of Concept 1. Compile the contract and set the _GOVERNOR and _EMERGENCY_GOVERNOR. 2. Now set a pendingGov but do not call acceptGov()  Bug 1 3. Call the __abdicate() function and we will notice only \"gov\" is set to zero address while emergency gov remains.  Bug2 4. Now use the address used in \"pendingGov\" to call acceptGov() function. 5. We will notice the new gov has been updated to the new address from the zero address.   Hence the __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.     ## Tools Used Remix to test the poC  ## Recommended Mitigation Steps The __abdicate() function should set emergency_gov and pendingGov as well to zero address.   "}, {"title": "ts.tokens sometimes calculated incorrectly", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/123", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.  Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0 ```JS   if (acctTimeDelta > 0 && ts.tokens > 0) { ``` Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens. However it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447  ```JS function stake(uint112 amount) public lock updateStream(msg.sender) {       ...                  uint112 trueDepositAmt = uint112(newBal - prevBal);        ...          ts.tokens += trueDepositAmt; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479  ```JS function withdraw(uint112 amount) public lock updateStream(msg.sender) {         ...         ts.tokens -= amount; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250  ```JS function updateStreamInternal(address who) internal { ...  uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;             if (acctTimeDelta > 0 && ts.tokens > 0) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);             } ```  ## Tools Used  ## Recommended Mitigation Steps Change the code in updateStream()  to:  ```JS     if (acctTimeDelta > 0 ) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 if (ts.tokens > 0)                        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)             } ```  Note: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas   "}, {"title": "Storage variable unstreamed can be artificially inflated", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The storage variable `unstreamed` keeps track of the global amount of deposit token in the contract that have not been streamed yet. This variable is a public variable, and users that read this variable likely want to use its value to determine whether or not they want to stake in the stream.  The issue here is that `unstreamed` is incremented on calls to `stake`, but it is not being decremented on calls to `withdraw`. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased `unstreamed`. They could do this repeatedly or with large amounts to intentionally inflate `unstreamed` to be as large as they want.  Other users would see this large amount and be deterred to stake in the stream, since they would get very little reward relative to the large amount of unstreamed deposit tokens that *appear* to be in the contract. This benefits the attacker as less users will want to stake in the stream, which leaves more rewards for them.  ## Proof of Concept See `stake` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417  See `withdraw` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455  Notice that `stake` increments `unstreamed` but `withdraw` does not affect `unstreamed` at all, even though `withdraw` is indeed removing unstreamed deposit tokens from the contract.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the following line to `withdraw` to fix this issue: ``` unstreamed -= amount; ```  "}, {"title": "LockeERC20 name is not implemented as comment imply", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  wuwe1   # Vulnerability details  ```solidity // locke + depositTokenName + streamId = lockeUSD Coin-1 name = string(abi.encodePacked(\"locke\", ERC20(depositToken).name(), \": \", toString(streamId))); ```  As the comment imply, the `\": \"` should be `\"-\"`  ## Recommended Mitigation Steps  Consider change the comment or the code.  "}, {"title": "Unnecessary call to lastApplicableTime() in claimReward()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  kenzo   # Vulnerability details  Since `claimReward` can only be called after `endRewardLock`, `lastApplicableTime` will always return `endStream`.  ## Impact Some gas can be saved.  ## Proof of Concept `claimReward` will only run if time > endRewardLock (which is >= endStream): ``` require(block.timestamp > endRewardLock, \"lock\"); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L556 `claimReward` is calling `lastApplicableTime`: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L567 And this is `lastApplicableTime`: ``` return block.timestamp <= endStream ? uint32(block.timestamp) : endStream; ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 Therefore, it will always return `endStream`.   ## Recommended Mitigation Steps In `claimReward`, change this line: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 To: ``` lastUpdate = endStream; ```  "}, {"title": "Delete unnecessary variable", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept In the method exit of Locke contract, ts.tokens was stored in a local variable, amount, and then this variable was used for call withdraw method, is better to call directly like `withdraw(ts.tokens)`  Source reference: - https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L492-L493  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the amount variable.  "}, {"title": "Flashloan is given for 1 token but checks balances for both reward and deposit token", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  pedroais   # Vulnerability details  ## Impact Useless checks that cost gas ## Proof of Concept Since the Flashloan function has the lock modifier reentrancy is not possible so checking both tokens is useless.  ## Recommended Mitigation Steps   Proposed new function with less code :               function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {         require(token == depositToken || token == rewardToken, \"erc\");          uint256 preTokenBalance = ERC20(token).balanceOf(address(this));          ERC20(token).safeTransfer(to, amount);          // the `to` contract should have a public function with the signature:         // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);         LockeCallee(to).lockeCall(msg.sender, token, amount, data);          uint256 postTokenBalance = ERC20(token).balanceOf(address(this));          uint112 feeAmt = amount * 10 / 10000; // 10bps fee         require(preTokenBalance + feeAmt <= postTokenBalance, \"f1\");          if (token == depositToken) {             depositTokenFlashloanFeeAmount += feeAmt;         } else {             rewardTokenFeeAmount += feeAmt;         }          emit Flashloaned(token, msg.sender, amount, feeAmt);     }   "}, {"title": "Cache the return value from rewardPerToken()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Save gas by caching the return value from rewardPerToken() in a local variable and use the local variable L220 and L222. This saves us two storage reads (1 cold = 800 gas, and 1 warm= 100 gas). It is way cheaper to read from a local variable (push/pop operations 2-3 gas each + cheap others)  Note: same for the claimReward() function on L555  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L555 ## Tools Used  ## Recommended Mitigation Steps - cache in a  local variable: uint256 _rewardPerToken = rewardPerToken(); - write the value to the storage variable: cumulativeRewardPerToken =  _rewardPerToken; - replace the occurrences of cumulativeRewardPerToken on L220/222 with _rewardPerToken   "}, {"title": "Struct TokenStream remove unused variable merkleAccess", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove the unused merkleAccess variable in the TokenStream struct. According to the struct packing it uses a single storage slot.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L106  ## Tools Used  ## Recommended Mitigation Steps - remove the unused merkleAccess variable in the TokenStream struct  "}, {"title": "depositTokens need to have a decimals() function", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Only ERC20 tokens with a decimals() function can be used as a depositToken. A stream creator maybe not be aware of this restriction and the creation of a stream would revert.  ## Proof of Concept In the constructor of the Stream contract the decimals() (L310) functions of the depositToken is called. But according to EIP20 (https://eips.ethereum.org/EIPS/eip-20) the decimals() function is optional.   https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L310  ## Tools Used  ## Recommended Mitigation Steps - clearly inform the stream creator that the depositToken needs to have the decimals() function implemented  "}, {"title": "Missing Emit in critical function", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cyberboy   # Vulnerability details  ## Impact Events for critical state changes (e.g., owner and other critical parameters) should be emitted for tracking this off-chain.   ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L41-L43 The function \"setEmergencyGov\" is missing event emit, and it is a critical function used for setting emergency governer.    ## Tools Used Slither  ## Recommended Mitigation Steps Add an event and emit it as a new emergency governor is set.   "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  wuwe1   # Vulnerability details  excesss at `Streaming/src/Locke.sol:644:18` should be excess  agains at `Streaming/test/utils/HEVMHelpers.sol:28:49` should be against  agains at `Streaming/test/utils/HEVMHelpers.sol:78:49` should be against  "}, {"title": "Division before multiple can lead to precision errors", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cyberboy   # Vulnerability details  ## Impact Performing multiplication before division is generally better to avoid loss of precision because Solidity integer division might truncate  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L237-L238 globalStreamingSpeedPerSecond is later used for unstreamed for multiplication after performing division while calculation of globalStreamingSpeedPerSecond   ## Tools Used Slither   ## Recommended Mitigation Steps The code can be optimized to use uint112((uint256(tdelta) * (uint256(unstreamed) * 10**6) / (endStream - lastUpdate) * 10**6 Or maybe just  (uint112((uint256(tdelta) * (uint256(unstreamed)) / (endStream - lastUpdate)     "}, {"title": "Gas optimization: Unnecessary return string", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/385", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L61 ```     return (       maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,       \"The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens.\"     ); ``` when the condition is true (which should be the majority of time), the reason string is unnecessary. Only return the string when the condition is false.  "}, {"title": "DOS with unbounded loop", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/380", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Koustre   # Vulnerability details  ## Impact In UniswapHandler, in the function ```removeBuyer``` there is a for loop over an unbounded Buyers array, which if the buyers array gets too large can cause a denial of service and prevents the contract from being able to remove buyer roles from users/contracts. This would allow users/contracts to circumvent recovery mode and to continue to purchase and sell tokens using the contract.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used - Manual Study ## Recommended Mitigation Steps - remove unbounded for loop  "}, {"title": "Can remove treasuryRewardCut from ForfeitHandler.sol", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/379", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In ForfeitHandler.sol, there are two values `swingTraderRewardCut ` and `treasuryRewardCut `, and these values always sum to 1000. Instead of having to go through all of the logic of setting these values independently and always ensuring that they sum to 1000, it would be simpler (and definitely save a lot of gas) if you simply removed everything related to `treasuryRewardCut` and always just used `1000-swingTraderRewardCut` in its place.  This also is more similar to what is done in StabilizerNode.sol where `treasuryCut` is simply what is left over after other components have taken their cut.  ## Proof of Concept See ForfeitHandler.sol here: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol  ## Tools Used Inspection  ## Recommended Mitigation Steps Simplify logic and save gas by removing `treasuryRewardCut`.  "}, {"title": "Unncessary statement in UniswapHandler.sol removeBuyer", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/377", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In UniswapHandler.sol within the `removeBuyer` function, there is a statement on line 308: ``` address buyer; ```  This variable is not used at all in the rest of the function, so this statement can be removed to save gas.  ## Proof of Concept See statement here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L308  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove unnecessary line to save gas  "}, {"title": "Dutch auction can be manipulated", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/375", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact When malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until _endAuction() is called. https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589  _endAuction() is called in   1. When auction.commitments >= auction.maxCommitments https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212  2. On stabilize() -> checkAuctionFinalization() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  3. On stabilize() ->_startAuction() -> triggerAuction() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  It is possible manipulate the dutch auction by preventing _endAuction() being called.  ## Proof of Concept Consider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, `_endAuction` won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because `purchaseAndBurn` (https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.  As such, the only way for the auction to finalize is to call stabilize().  However, this is not immediately possible because it require  `block.timestamp >= stabilizeWindowEnd` where `stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod` stabilizeBackoffPeriod is initially set to 5 minutes in the contract  After 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)  Also note that stabilize() might not be called since there is no incentive.  ## Recommended Mitigation Steps 1. Incentivize stabilize() or incentivize a permission-less call to _endAuction() 2. Lock-in auction price when user commit purchase  "}, {"title": "Malt Protocol Uses Stale Results From `MaltDataLab` Which Can Be Abused By Users", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/373", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.  ## Proof of Concept  Consider the following attack vector: - The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user. - The `_stabilityWindowOverride` function is satisfied, hence the function will execute. - The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate. - `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction. - As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments. - If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.  This threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.  `trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.  "}, {"title": "AMM pool can be drained using a flashloan and calling `stabilize`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/372", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  stonesandtrees   # Vulnerability details  ## Impact All of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.  ## Proof of Concept In the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  However, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275  Attack: 1. Wait for TWAP to rise above the stabilization threshold 2. Flashloan remove all but a tiny amount of Malt from the pool. 3. Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg.  4. Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool. 5. The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.  The amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use a short TWAP to calculate the trade size instead of reading directly from the pool.  "}, {"title": "Cache decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/371", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Consider caching decimals when initializing malt and collateralToken to avoid repeated external calls, as they are not supposed to change unless initialized again: ```solidity   uint256 maltDecimals = malt.decimals();   uint256 decimals = collateralToken.decimals(); ```   "}, {"title": "MiningService.setBonding should use BONDING role instead of REINVESTOR one", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/370", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  BONDING_ROLE cannot be managed after it was initialized.  ## Proof of Concept  ```setBonding``` set the wrong role via _swapRole:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116  ## Recommended Mitigation Steps  Set ```BONDING_ROLE``` instead of ```REINVESTOR_ROLE``` in ```setBonding``` function:  Now: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, \"Must have admin privs\") {  require(_bonding != address(0), \"Cannot use address 0\");  _swapRole(_bonding, bonding, REINVESTOR_ROLE);  bonding = _bonding; } ```  To be: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, \"Must have admin privs\") {  require(_bonding != address(0), \"Cannot use address 0\");  _swapRole(_bonding, bonding, BONDING_ROLE);  bonding = _bonding; } ```  "}, {"title": "(10000 - thresholdBps) can be pre-calculated", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/369", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract PoolTransferVerification sets thresholdBps but in calculations uses only ```(10000 - thresholdBps)```. Consider pre-calculating to avoid re-evaluation again and again when this function is invoked.  "}, {"title": "purchaseArbitrageTokens 0 amount", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/359", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function purchaseArbitrageTokens should validate that amount > 0, otherwise it may be possible to spam accountCommitmentEpochs with 0 amounts: ```solidity   if (auction.accountCommitments[msg.sender].commitment == 0) {     accountCommitmentEpochs[msg.sender].push(currentAuctionId);   } ```  ## Recommended Mitigation Steps require amount > 0  "}, {"title": "Unbounded loops", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/358", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are several loops in the contract which can eventually grow so large as to make future operations of the contract cost too much gas to fit in a block, e.g.: ```solidity   for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) // function outstandingArbTokens()   while (true) // function allocateArbRewards ```  ## Recommended Mitigation Steps Consider introducing a reasonable upper limit based on block gas limits. Also, you can consider using EnumerableSet (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) where possible, e.g. 'buyers' or 'verifierList'.  "}, {"title": "maxAmount and balance", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/357", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think this if check is incorrect, because in theory maxAmount parameter can be greater than totalMaltBalance: ```solidity     if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {       // If all malt is spent we want to reset deployed capital       deployedCapital = deployedCapital - rewards;     } else {       deployedCapital = 0;     } ```  ## Recommended Mitigation Steps If my assumption is correct, the check should use balance, not maxAmount: ``solidity   balance != totalMaltBalance ``` Another possible solution: ``solidity   maxAmount <= totalMaltBalance ``` However, I think the best approach would be to eliminate 'balance' altogether: ```solidity   uint256 totalMaltBalance = malt.balanceOf(address(this));    if (totalMaltBalance == 0) {     return 0;   }    (uint256 basis,) = costBasis();    if (maxAmount > totalMaltBalance) {     maxAmount = totalMaltBalance;   }    malt.safeTransfer(address(dexHandler), maxAmount);   uint256 rewards = dexHandler.sellMalt();    if (rewards <= deployedCapital && maxAmount < totalMaltBalance) {     // If all malt is spent we want to reset deployed capital     deployedCapital = deployedCapital - rewards;   } else {     deployedCapital = 0;   }   ```  "}, {"title": "Inclusive checks", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/356", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact These checks should be inclusive: ```solidity        require(amountOut > minOut, \"EarlyExit: Insufficient output\");   require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");   require(newThreshold > 0 && newThreshold < 10000, \"Threshold must be between 0-100%\");   require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\"); ```  ## Recommended Mitigation Steps Replace > with >= and < with <= where necesseary.  "}, {"title": "Auction.claimArbitrage: if calculated claimable amount is too big, the remaining committed amount cannot be retrieved", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/353", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  A condition requires that calculated retrievable amount shouldn't be too big. If it is the function fails and the remaining portion of commitment is frozen.  As the amount is calculated by the system a user cannot do anything to retrieve remaining part of commitment, if any.  ## Proof of Concept  ```claimArbitrage``` fails if calculated redemption is higher than remaining commitment: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L230  ```userClaimableArbTokens``` calculated amount can be bigger than remaining user funds: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L279  ## Recommended Mitigation Steps  If the freezing of remainder amount is not intentional then substitute require with ceiling the amount to be retrieved with the remaining part.  Now: ``` require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\"); ```  To be: ``` if (redemption > remaining) {  redemption = remaining; } ```   "}, {"title": "Inconsistencies when checking if the auction is active", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/352", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When auction.endingTime == now, function purchaseArbitrageTokens thinks that auction is still active, while isAuctionFinished and earlyExitReturn think that it has ended: purchaseArbitrageTokens: ```solidity   require(auction.endingTime >= now, \"Auction is already over\"); ``` isAuctionFinished: ```solidity   return auction.endingTime > 0 && (now >= auction.endingTime || ...); ``` earlyExitReturn: ```solidity   if(active || block.timestamp < auctionEndTime) {     return 0;   } ```  ## Recommended Mitigation Steps Consider unifying it across the functions.  "}, {"title": "Validation of 'to' in transferAndCall and transferWithPermit", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/350", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In functions transferAndCall and transferWithPermit the condition should be AND, not OR: ```solidity   require(to != address(0) || to != address(this)); ```  ## Recommended Mitigation Steps ```solidity   require(to != address(0) && to != address(this)); ```   "}, {"title": "DOMAIN_SEPARATOR can change", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/349", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact The variable DOMAIN_SEPARATOR in contract ERC20Permit is assigned in the constructor and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  Also, you don't need an assmebly to retrieve chainid, you can get it from a built in variable block.chainid.  Similar issues were reported in a previous contest and were assigned a severity of low:  https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  https://github.com/code-423n4/2021-09-swivel-findings/issues/98  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  "}, {"title": "Inaccurate revert messages", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/343", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Inaccurate revert messages: ```solidity           _delay >= 0 && _delay < gracePeriod,   \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"    require(startEpoch < endEpoch, \"Start cannot be before the end\");   require(rewardAmount <= rewardEarned, \"< earned\");   require(bondedBalance > 0, \"< bonded balance\");   require(amount <= bondedBalance, \"< bonded balance\"); ```   "}, {"title": "RewardReinvestor - safeTransfer used unnecessarily on Malt token", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/339", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  Inside `provideReinvest` and `_bondAccount` gas can be saved by using the standard transfer method on the Malt token, since we know its implementation is correct and will return true/false.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  Replace `malt.safeTransfer(address(dexHandler), balance);` with something like:  ```solidity require(malt.transfer(address(dexHandler), balance), 'malt transfer failed'); ```   "}, {"title": "AbstractRewardMine - Re-entrancy attack during withdrawal", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/333", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  The internal `_withdraw` method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as `withdraw()`) before proper internal accounting was completed. Because the `earned` function looks up the `_userWithdrawn` mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter `_withdraw` repeatedly and drain the pool.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  The internal accounting should be done before the transfer occurs:  ```solidity function _withdraw(address account, uint256 amountReward, address to) internal {     _userWithdrawn[account] += amountReward;     _globalWithdrawn += amountReward;f     rewardToken.safeTransfer(to, amountReward);      emit Withdraw(account, amountReward, to);   } ```   "}, {"title": "Various contracts - stricter function mutability for gas savings", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/330", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  There are four functions that can have stricter function mutability declarations. Using a stricter declaration can help the compiler save gas when it knows whether reads and writes will occur in a function  ## Proof of Concept  N/A  ## Tools Used  solc  ## Recommended Mitigation Steps  Implement the changes suggested by the Solidity compiler. For examples like `AbstractTransferVerification`, the solidity compiler is wrong because it doesn't know you plan to override this function declaration. Instead, `AbstractTransferVerification` could be an interface without a function definition  ``` contracts/AbstractTransferVerification.sol:9:3: Warning: Function state mutability can be restricted to pure   function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionEscapeHatch.sol:168:3: Warning: Function state mutability can be restricted to view   function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionParticipant.sol:127:3: Warning: Function state mutability can be restricted to pure   function _handleRewardDistribution(uint256 rewarded) virtual internal {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/MaltDataLab.sol:202:3: Warning: Function state mutability can be restricted to pure   function _normalizedPrice(   ^ (Relevant source part starts here and spans across multiple lines). ```  "}, {"title": "Permissions - return values not checked when sending ETH", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/329", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  On lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance  ## Proof of Concept  Enter the following in remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Call `emergencyWithdrawGAS` with the receiver address and you'll see it reverts. This would not be caught in the current code  ```solidity pragma solidity ^0.8.0;  contract Receivier{}  contract Permissions {     constructor() payable {}      function emergencyWithdrawGAS(address payable destination) external {         (bool ok, ) = destination.call{value: address(this).balance}('');         require(ok, \"call failed\");     } } ```  ## Tools Used  Remix  ## Recommended Mitigation Steps  In `emergencyWithdrawGAS`:  ```diff - destination.call{value: address(this).balance}(''); + (bool ok, ) = destination.call{value: address(this).balance}(''); + require(ok, \"call failed\"); ```  And similar for `partialWithdrawGAS`  "}, {"title": "AuctionBurnReserveSkew - remove `for` loop from initializer", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Estimated risk level Gas Optimization  ## Impact Instantiating an array of length n is better than `push(0)`  n times and saves 20k gas in tests.  ## Proof of Concept  ## Tools Used   ## Recommended Mitigation Steps change the initializer  ```diff ## Saves ~20,000 gas on initialize  diff --git a/src/contracts/AuctionBurnReserveSkew.sol b/src/contracts/AuctionBurnReserveSkew.sol index 4ed6fa6..87d5959 100644 --- a/src/contracts/AuctionBurnReserveSkew.sol +++ b/src/contracts/AuctionBurnReserveSkew.sol @@ -51,9 +51,7 @@ contract AuctionBurnReserveSkew is Initializable, Permissions {      auction = IAuction(_auction);      auctionAverageLookback = _period;   -    for (uint i = 0; i < _period; i++) { -      pegObservations.push(0); -    } +    pegObservations = new uint256[](_period);    }      function consult(uint256 excess) public view returns (uint256) { ```  "}, {"title": "User can bypass Recovery Mode via UniswapHandler to buy Malt ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/325", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact One of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.  ## Proof of Concept 1) User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted `swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);` 2) User send matching amount of dai to uniswapHandler 3) User call addLiquidity() and get back LP token 4) User call removeLiquidity() and get back both dai and malt  ## Recommended Mitigation Steps According to documentation in https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode. , this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue \"Unable to remove liquidity in Recovery Mode\") This exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode  "}, {"title": "Unable to remove liquidity in Recovery Mode", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/323", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact According to https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > When the Malt price TWAP drops below a specified threshold (eg 2% below peg) then the protocol will revert any transaction that tries to remove Malt from the AMM pool (ie buying Malt or removing liquidity). Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.  However, in https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L236 liquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L53  ## Recommended Mitigation Steps Liquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender  "}, {"title": "Missing `maltDataLab.trackReserveRatio()` in some cases after `swingTrader.sellMalt()`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/320", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, `maltDataLab.trackReserveRatio()` should be called once a market buy/sell is made.  However, in `_distributeSupply()` when `swingAmount >= tradeSize`, after a market sell, the function returned without `maltDataLab.trackReserveRatio()`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L145-L174  ```solidity=145{168,170,172}   function stabilize() external notSameBlock {     auction.checkAuctionFinalization();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       \"Can't call stabilize\"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      rewardThrottle.checkRewardUnderflow();      uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);      if (!_shouldAdjustSupply(exchangeRate)) {       maltDataLab.trackReserveRatio();        lastStabilize = block.timestamp;       return;     }      emit Stabilize(block.timestamp, exchangeRate);      if (exchangeRate > maltDataLab.priceTarget()) {       _distributeSupply();     } else {       _startAuction();     }      lastStabilize = block.timestamp;   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L211-L246  ```solidity=211{228-230,244}   function _distributeSupply() internal {     if (supplyDistributionController != address(0)) {       bool success = ISupplyDistributionController(supplyDistributionController).check();       if (!success) {         return;       }     }      uint256 priceTarget = maltDataLab.priceTarget();     uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);      if (tradeSize == 0) {       return;     }      uint256 swingAmount = swingTrader.sellMalt(tradeSize); // @Auditor: At this time, a market operation occurred, affecting the reserveRatio      if (swingAmount >= tradeSize) {       return;     }      tradeSize = tradeSize - swingAmount;      malt.mint(address(dexHandler), tradeSize);     emit MintMalt(tradeSize);     uint256 rewards = dexHandler.sellMalt();      auctionBurnReserveSkew.addAbovePegObservation(tradeSize);      uint256 remaining = _replenishLiquidityExtension(rewards);      _distributeRewards(remaining);      maltDataLab.trackReserveRatio();     impliedCollateralService.claim();   } ```  ### Recommendation  Consider moving `maltDataLab.trackReserveRatio()` from `_distributeSupply()`, `_startAuction()` to `stabilize()` before L173.  "}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/317", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L135-L141  ```solidity=135   function _notSameBlock() internal {     require(       block.number > lastBlock[_msgSender()],       \"Can't carry out actions in the same block\"     );     lastBlock[_msgSender()] = block.number;   } ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L223-L223 ```solidity=223 require(!auction.active, \"Cannot claim tokens on an active auction\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L230-L230 ```solidity=230 require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L659-L659 ```solidity=659 require(auction.startingTime > 0, \"No auction available for the given id\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L177-L177 ```solidity=177 require(!active, \"Cannot exit early on an active auction\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L136-L136 ```solidity=136 require(_index > replenishingIndex, \"Cannot replenishingIndex to old value\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L56-L56 ```solidity=56 require(block.timestamp >= getEpochStartTime(epoch + 1), \"Cannot advance epoch until start of new epoch\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L81-L81 ```solidity=81 require(balance >= value, \"ERC20Permit: transfer amount exceeds balance\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L122-L122 ```solidity=122 require(balance >= value, \"ERC20Permit: transfer amount exceeds balance\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Malt.sol#L65-L65 ```solidity=65 require(_service != address(0), \"Cannot use address 0 as transfer service\"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L412-L412 ```solidity=412 require(_sampleLength > 0, \"Cannot have 0 second sample length\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L154-L154 ```solidity=154 require(forfeited <= _globals.declaredBalance, \"Cannot forfeit more than declared\"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L275-L275 ```solidity=275 require(amount <= _globals.declaredBalance, \"Can't decrement more than total reward balance\"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L118-L121 ```solidity=118     require(       eta >= block.timestamp.add(delay),       \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"     ); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L165-L176 ```solidity=165     require(       queuedTransactions[txHash],       \"Timelock::executeTransaction: Transaction hasn't been queued.\"     );     require(       block.timestamp >= eta,       \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"     );     require(       block.timestamp <= eta.add(gracePeriod),       \"Timelock::executeTransaction: Transaction is stale.\"     ); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L195-L198 ```solidity=195     require(       success,       \"Timelock::executeTransaction: Transaction execution reverted.\"     ); ```  "}, {"title": "Redundant checks", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/316", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L114-L132  ```solidity=114 function unbondAndBreak(uint256 amount)     external   {     require(amount > 0, \"Cannot unbond 0\");      uint256 bondedBalance = balanceOfBonded(msg.sender);      require(bondedBalance > 0, \"< bonded balance\");     require(amount <= bondedBalance, \"< bonded balance\");      // Avoid leaving dust behind     if (amount.add(1e16) > bondedBalance) {       amount = bondedBalance;     }      miningService.onUnbond(msg.sender, amount);      _unbondAndBreak(amount);   } ```  L121, the check of `bondedBalance > 0` is unnecessary, since the L122 already included the same check.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L118-L127  ```solidity=118{121-122, 124}   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {     require(to != address(0) || to != address(this));      uint256 balance = balanceOf(msg.sender);     require(balance >= value, \"ERC20Permit: transfer amount exceeds balance\");      _transfer(msg.sender, to, value);      return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);   } ```  L121-L122, the check of `balance >= value` is unnecessary, since the L124 already included the same check.  "}, {"title": "`MovingAverage.setSampleMemory()` may broke MovingAverage, making the value of `exchangeRate` in `StabilizerNode.stabilize()` being extremely wrong", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/313", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442  ```solidity=424   function setSampleMemory(uint256 _sampleMemory)     external     onlyRole(ADMIN_ROLE, \"Must have admin privs\")   {     require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");      if (_sampleMemory > sampleMemory) {       for (uint i = sampleMemory; i < _sampleMemory; i++) {         samples.push();       }       counter = counter % _sampleMemory;     } else {       activeSamples = _sampleMemory;        // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST     }      sampleMemory = _sampleMemory;   } ```  In the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.  ## PoC  -  When initial sampleMemory is `10` -  After `movingAverage.update(1e18)` being called for 120 times -  The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`  The current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`  After `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.  ### Recommendation  Consider removing `setSampleMemory` function.  "}, {"title": "Checking if `lpProfitCut > 0` can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/310", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L136-L141  ```solidity if (profit > 0) {     uint256 lpCut = profit.mul(lpProfitCut).div(1000);      collateralToken.safeTransfer(address(rewardThrottle), lpCut);     rewardThrottle.handleReward();   } ```  Given that `lpProfitCut` can be `0`, checking if `lpProfitCut > 0` can avoid unnecessary code execution (including external calls) and save some gas.  "}, {"title": "Checking `uint256` variables `>= 0` is redundant", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/309", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Checking `uint256` variables >= 0 is redundant as they always >= 0.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L169-L172  ```solidity function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, \"Must have admin privs\") {     require(_profitCut >= 0 && _profitCut <= 1000, \"Must be between 0 and 100%\");     lpProfitCut = _profitCut;     } ```  `_profitCut >= 0` at L170.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77  ```solidity function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")   {     require(       _delay >= 0 && _delay < gracePeriod,       \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"     );     delay = _delay;      emit NewDelay(delay);   } ```  `_delay >= 0` at L71.  "}, {"title": "Only use `SafeMath` when necessary can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L238-L242  ```solidity=238     if (amountTokens > unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);     } ```  `unclaimedArbTokens - amountTokens` will never underflow.  ### Recommendation  Change to:  ```solidity=238     if (amountTokens >= unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens -= amountTokens;     } ```    https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L76-L80  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend.sub(premiumExcess); ```  `maxBurnSpend - premiumExcess` will never underflow.  ### Recommendation  Change to:  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend - premiumExcess; ```  "}, {"title": "`AuctionBurnReserveSkew.sol#getRealBurnBudget()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/306", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69-L89  ```solidity=69{76,82-84}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess > maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      if (usableExcess == 0) {       return premiumExcess;     }      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  L82-84 `if (maxBurnSpend == premiumExcess)` can be combined with L76-78.  ### Recommendation  Change to:  ```solidity=69{76}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess >= maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  "}, {"title": "Users may lose a small portion of promised returns due to precision loss", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/305", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L131-L140  ```solidity=131     uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {         progressionBps = 10000;     }      if (fullReturn > amount) {         // Allow a % of profit to be realised         uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;         return amount + maxProfit;     } ```  If we assume that `maxEarlyExitBps` is 200 and `cooloffPeriod` is 1 day, when `progressionBps` less than 50, `(maxEarlyExitBps * progressionBps / 10000)` will be 0 due to precision loss, which resulted in `maxProfit` is 0.  When `maxEarlyExitBps` is set smaller, the margin of error will be even larger.  # POC  Given:  - Current price of arb token is 0.8 DAI  1. Alice calls `purchaseArbitrageTokens()` and purchase with 8,000 DAI; 2. 7 mins later, the market price of MALT become 0.9 DAI; Alice calls `exitEarly()`, it will mint 8,888.88 Malt and receive 8,000 DAI, while it's expected to 8,890 MALT and 8,000.96 DAI.  ### Recommendation  Change to:  ```solidity if (fullReturn > amount) {     // Allow a % of profit to be realised     uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * 1000 * progressionBps / 10000) / 1000 / 1000;     return amount + maxProfit; } ```  "}, {"title": "`AuctionBurnReserveSkew.sol#getPegDeltaFrequency()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  ### Recommendation  Change to:  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 availablePegObservationsCount;     {       uint256 auctionAverageLookback_ = auctionAverageLookback;       uint256 count_ = count;       availablePegObservationsCount = count_ > auctionAverageLookback_ ? auctionAverageLookback_ : count_;     }      uint256 total = 0;     for (uint256 i = 0; i < availablePegObservationsCount; ++i) {       total += pegObservations[i];     }     return total * 10000 / availablePegObservationsCount;   } ```  "}, {"title": "`++i` is more gas efficient than `i++`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/295", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Using `++i` is more gas efficient than `i++`, especially in a loop.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L54-L56 ```solidity=54 for (uint i = 0; i < _period; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L193-L195 ```solidity=193 for (uint i = auctionAverageLookback; i < _lookback; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60-L62 ```solidity=60 for (uint i = 0; i < sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L187-L195  ```solidity=187 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L292-L300 ```solidity=292 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L431-L433 ```solidity=431 for (uint i = sampleMemory; i < _sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/libraries/UniswapV2Library.sol#L66-L69 ```solidity=66 for (uint i; i < path.length - 1; i++) {     (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);     amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); } ```  "}, {"title": "`AuctionBurnReserveSkew.getPegDeltaFrequency()` Wrong implementation can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/294", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116{131}   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  When `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.  The result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.  "}, {"title": "`StabilizerNode.sol` The current implementation is misconfiguration-prone for rewardToken with non-18 decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/293", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  The default `upperStabilityThreshold` and `lowerStabilityThreshold` assumes that `rewardToken.decimals()` is 18.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L32-L33  ```solidity=32   uint256 public upperStabilityThreshold = (10**18) / 100; // 1%   uint256 public lowerStabilityThreshold = (10**18) / 100; ```  When the `StabilizerNode.sol` contract is initialized with a rewardToken with decimals of 8 (eg. USDC). `upperThreshold` and `lowerThreshold` will be much larger than expected.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L198-L206 ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals); ```  ### Recommendation  Consider changing to:  ```solidity   uint256 public upperStabilityThresholdBps = 100; // 1%   uint256 public lowerStabilityThresholdBps = 100; ```  ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10000);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10000); ```  "}, {"title": "The value of `reward` parameter of the `ProvideReinvest` event can be wrong", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/292", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardReinvestor.sol#L62-L76  ```solidity=62 function provideReinvest(uint256 rewardLiquidity) external {     _retrieveReward(rewardLiquidity);      uint256 rewardBalance = rewardToken.balanceOf(address(this));      // This is how much malt is required     uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);      // Transfer the remaining Malt required     malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);      _bondAccount(msg.sender);      emit ProvideReinvest(msg.sender, rewardLiquidity);   } ```  `_retrieveReward` will call `MiningService.sol#withdrawRewardsForAccount()` which uses `amount` as max withdrawnAmount, if there are no enough rewards, the actual rewarded amount will be less than `amount`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MiningService.sol#L155-L179  ```solidity=155 function withdrawRewardsForAccount(address account, uint256 amount)     public     onlyRole(REINVESTOR_ROLE, \"Must have reinvestor privs\")   {     _withdrawMultiple(account, amount);   }    /*    * INTERNAL FUNCTIONS    */   function _withdrawMultiple(address account, uint256 amount) internal {     for (uint i = 0; i < mines.length; i = i + 1) {       if (!mineActive[mines[i]]) {         continue;       }        uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);        amount = amount.sub(withdrawnAmount);        if (amount == 0) {         break;       }     }   } ```  ### Recommendation  Consider using `rewardBalance` as the value of the `reward` parameter.  "}, {"title": "Custom size uint is not more efficient than uint256", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/289", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept  In `MovingAverage.sol`, `uint64` is used for computation of time etc. But computations with `uint64` does cost more gas and furthermore `block.timestamp` is `uint256`, which is additionally casted to `uint64`. `uint32` is used for indexes, but this can also be changed with `uint256`.  Same applies for `RewardDistributer.sol.`  ## Recommendation  Use `uint256` rather than custom `uint`.  "}, {"title": "Dont calculate progressionBps, when not needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/288", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept  [https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212](https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212):  ```   uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {       progressionBps = 10000;     }      if (fullReturn > amount) {       // Allow a % of profit to be realised       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  `progressionBps` is only used, if there is a profit. Calculations of this parameter should be under if statement checking whether there is a profit to save gas and increase readability as follows:  ```      if (fullReturn > amount) {       // Allow a % of profit to be realised    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;      if (progressionBps > 10000) {        progressionBps = 10000;      }       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  "}, {"title": "Unused storage variables", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/287", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L57-L57 ```solidity=57 address public uniswapV2Factory; ```  "}, {"title": "Misleading error message", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/286", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80-L86  ```solidity=80 function emergencyWithdrawGAS(address payable destination)     external      onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")   {     // Transfers the entire balance of the Gas token to destination     destination.call{value: address(this).balance}('');   } ```  The error message \"Only timelock can assign roles\" can be changed to \"Only timelock can emergencyWithdrawGAS\".  Other examples include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104-L110  ```solidity=104 function partialWithdraw(address _token, address destination, uint256 amount)     external      onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")   {     ERC20 token = ERC20(_token);     token.safeTransfer(destination, amount);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L94-L94  ```solidity=94 require(_pool != address(0), \"Cannot have 0 lookback\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L230-L230  ```solidity=230 require(_period > 0, \"Cannot have 0 lookback period\"); ```  "}, {"title": "AbstractRewardMine.sol#setRewardToken is dangerous", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/285", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact  In case the reward token is changed, `totalDeclaredReward` will be changed and likely equal to `0`.  Since `_userStakePadding` and `_globalStakePadding` are accumulated, changing the reward token will not reset those values. Thus, it will create problems.  ## Recommendation  I think it would be the best to remove this function.   If you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.  "}, {"title": "Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/276", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L112-L116  ```solidity=112   function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {     _approve(msg.sender, spender, value);      return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);   } ```  ```solidity=208 function _transfer(address sender, address recipient, uint256 amount) internal virtual {     require(sender != address(0), \"ERC20: transfer from the zero address\");     require(recipient != address(0), \"ERC20: transfer to the zero address\");      _beforeTokenTransfer(sender, recipient, amount);      _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");     _balances[recipient] = _balances[recipient].add(amount);     emit Transfer(sender, recipient, amount); } ```  Using approve() to manage allowances opens yourself and users of the token up to frontrunning. Best practice, but doesn't usually matter.  [Explanation](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit) of this possible attack vector  See also: [0xProject/0x-monorepo#850](https://github.com/0xProject/0x-monorepo/issues/850)  Using increase/decreaseAllowance instead is recommended.  "}, {"title": "`uint64(block.timestamp % 2**64)` can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L154-L154  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp % 2**64);  ```  Use `uint64(n)` can cut off higher-order bits already, `n % 2**64` is redundant.  See: https://docs.soliditylang.org/en/v0.8.10/types.html#explicit-conversions  ### Recommendation  Change to:  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp);  ```  "}, {"title": "For uint `> 0` can be replaced with ` != 0` for gas optimisation", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/271", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurences  ```  ./AbstractRewardMine.sol:147:    if (rewardDenominator > 0) { ./Auction.sol:219:    require(amountTokens > 0, \"No claimable Arb tokens\"); ./Auction.sol:265:    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments); ./Auction.sol:385:    return auction.startingTime > 0; ./Auction.sol:639:    if (realBurnBudget > 0) { ./Auction.sol:659:    require(auction.startingTime > 0, \"No auction available for the given id\"); ./Auction.sol:663:    if (auction.maltPurchased > 0) { ./Auction.sol:861:          if (auction.commitments > 0 || !auction.finalized) { ./Auction.sol:894:    require(_length > 0, \"Length must be larger than 0\"); ./Auction.sol:972:    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\"); ./Auction.sol:980:    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\"); ./Auction.sol:988:    require(_lookback > 0, \"Must be above 0\"); ./Auction.sol:996:    require(_lookback > 0, \"Must be above 0\"); ./Auction.sol:1004:    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\"); ./Auction.sol:1012:    require(_threshold > 0, \"Must be between greater than 0\"); ./AuctionBurnReserveSkew.sol:109:    if (aggregate.maxCommitments > 0) { ./AuctionBurnReserveSkew.sol:190:    require(_lookback > 0, \"Cannot have zero lookback period\"); ./AuctionEscapeHatch.sol:191:    require(amount > 0, \"Nothing to claim\"); ./AuctionEscapeHatch.sol:222:    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\"); ./AuctionEscapeHatch.sol:230:    require(_period > 0, \"Cannot have 0 lookback period\"); ./AuctionPool.sol:118:    if (globalRewarded > 0 && userReward > 0) { ./AuctionPool.sol:125:    if (forfeitAmount > 0) { ./AuctionPool.sol:129:    if (declaredRewardDecrease > 0) { ./AuctionPool.sol:141:    if (forfeitedRewards > 0) { ./Bonding.sol:87:    require(amount > 0, \"Cannot bond 0\"); ./Bonding.sol:97:    require(amount > 0, \"Cannot unbond 0\"); ./Bonding.sol:101:    require(bondedBalance > 0, \"< bonded balance\"); ./Bonding.sol:117:    require(amount > 0, \"Cannot unbond 0\"); ./Bonding.sol:121:    require(bondedBalance > 0, \"< bonded balance\"); ./Bonding.sol:283:      if (diff > 0) { ./DAO.sol:47:    if (offeringMint > 0) { ./DAO.sol:78:    require(amount > 0, \"Cannot have zero amount\"); ./DAO.sol:94:    require(_length > 0, \"Cannot have zero length epochs\"); ./ERC20VestedMine.sol:93:    if (globalRewarded > 0 && userReward > 0) { ./ERC20VestedMine.sol:115:    if (forfeitReward > 0) { ./ERC20VestedMine.sol:119:    if (declaredRewardDecrease > 0) { ./ForfeitHandler.sol:49:    if (swingTraderCut > 0) { ./ForfeitHandler.sol:53:    if (treasuryCut > 0) { ./ImpliedCollateralService.sol:64:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:68:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:71:      // if (maxAmount > 0) { ./ImpliedCollateralService.sol:74:      //   if (maxAmount > 0) { ./LiquidityExtension.sol:161:    require(_ratio > 0 && _ratio <= 100, \"Must be between 0 and 100\"); ./MaltDataLab.sol:234:    require(_price > 0, \"Cannot have 0 price\"); ./MaltDataLab.sol:242:    require(_lookback > 0, \"Cannot have 0 lookback\"); ./MaltDataLab.sol:250:    require(_lookback > 0, \"Cannot have 0 lookback\"); ./MaltDataLab.sol:258:    require(_lookback > 0, \"Cannot have 0 lookback\"); ./MovingAverage.sol:385:    if (oldSample.timestamp > 0 && activeSamples > 1) { ./MovingAverage.sol:412:    require(_sampleLength > 0, \"Cannot have 0 second sample length\"); ./MovingAverage.sol:428:    require(_sampleMemory > 0, \"Cannot have sample memroy of 0\"); ./PoolTransferVerification.sol:76:    require(newThreshold > 0 && newThreshold < 10000, \"Threshold must be between 0-100%\"); ./PoolTransferVerification.sol:85:    require(lookback > 0, \"Cannot have 0 lookback\"); ./RewardReinvestor.sol:93:    require(rewardLiquidity > 0, \"Cannot reinvest 0\"); ./RewardReinvestor.sol:115:    if (maltBalance > 0) { ./RewardReinvestor.sol:119:    if (rewardTokenBalance > 0) { ./RewardSystem/RewardDistributor.sol:144:    require(reward > 0, \"Cannot declare 0 reward\"); ./RewardSystem/RewardDistributor.sol:266:    if (amount > 0) { ./RewardSystem/RewardDistributor.sol:277:    if (amount > 0) { ./RewardSystem/RewardOverflowPool.sol:76:    require(_maxFulfillment > 0, \"Can't have 0 max fulfillment\"); ./RewardSystem/RewardThrottle.sol:85:    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) { ./RewardSystem/RewardThrottle.sol:89:      if (remainder > 0) { ./RewardSystem/RewardThrottle.sol:271:          if (underflow > 0) { ./RewardSystem/RewardThrottle.sol:323:    require(_smoothingPeriod > 0, \"No zero smoothing period\"); ./StabilizerNode.sol:270:    if (callerCut > 0) { ./StabilizerNode.sol:274:    if (auctionPoolCut > 0) { ./StabilizerNode.sol:278:    if (swingTraderCut > 0) { ./StabilizerNode.sol:282:    if (treasuryCut > 0) { ./StabilizerNode.sol:286:    if (daoCut > 0) { ./StabilizerNode.sol:290:    if (lpCut > 0) { ./StabilizerNode.sol:359:    require(_period > 0, \"Must be greater than 0\"); ./StabilizerNode.sol:406:    require(_incentive > 0, \"No negative incentive\"); ./StabilizerNode.sol:417:    require(amount > 0, \"No negative damping\"); ./StabilizerNode.sol:449:    require(_upper > 0 && _lower > 0, \"Must be above 0\"); ./StabilizerNode.sol:488:    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\"); ./StabilizerNode.sol:552:    require(_period > 0, \"Cannot have 0 period\"); ./StabilizerNode.sol:561:    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\"); ./StabilizerNode.sol:570:    require(_period > 0, \"Cannot have 0 period\"); ./SwingTrader.sol:136:    if (profit > 0) { ./libraries/SafeBurnMintableERC20.sol:70:        if (returndata.length > 0) { // Return data is optional ./libraries/UniswapV2Library.sol:37:        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); ./libraries/UniswapV2Library.sol:38:        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:44:        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:45:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:54:        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:55:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) {  ```  "}, {"title": "`MovingAverage.sol` Use inline expression can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/269", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L356-L360  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     uint32 currentSampleIndex = _getIndexOfSample(counter - 1);     currentSample = samples[currentSampleIndex];   } ```  The local variable `currentSampleIndex` is used only once. Making the expression inline can save gas.  Similar issue exists in `_getFirstSample()`, `_getNthSample()`, `AuctionBurnReserveSkew.sol#getRealBurnBudget()`, `MovingAverage.sol#_getFirstSample()`.  ### Recommendation  Change to:  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     currentSample = samples[_getIndexOfSample(counter - 1)];   } ```  "}, {"title": "AuctionEschapeHatch.sol#exitEarly updates state of the auction wrongly", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/268", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Vulnerability  `AuctionEschapeHatch.sol#exitEarly` takes as input `amount` to represent how much of the   When the user exits an auction with profit, to apply the profit penalty less `maltQuantity` is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is `auction.amendAccountParticipation()` simply subtracts the malt quantity with penalty and full `amount` from users auction stats. This causes a major problem, since in `_calculateMaltRequiredForExit` those values are used for calculation by calculating maltQuantity as follow:  `uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);`   The ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking (since penalty is applied to substracted `maltQuantity` from `userMaltPurchased`), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing `exitEarly` calls in several calls.  In other words, the ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all `userMaltPurchased` is claimed the user can have `userCommitment` left over, which can be used to `claimArbitrage`, when possible.  ## Mitigation Step  Make sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.  "}, {"title": "Code Style: private/internal function names should be prefixed with `_`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/265", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - MaltDAO#incrementEpoch()      https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L106-L119  ```solidity=106{107} /* Internal methods */ function incrementEpoch() internal {     epoch = epoch.add(1); }  function _setEpochLength(uint256 length) internal {     epochLength = length;     emit SetEpochLength(length); }  function _setMaltToken(address _malt) internal {     malt = IBurnMintableERC20(_malt);     emit SetMaltToken(_malt); } ```  "}, {"title": "Timelock can be bypassed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/263", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  The purpose of a Timelock contract is to put a limit on the privileges of the `governor`, by forcing a two step process with a preset delay time.  However, we found that the current implementation actually won't serve that purpose as it allows the `governor` to execute any transactions without any constraints.  To do that, the current governor can call `Timelock#setGovernor(address _governor)` and set a new `governor` effective immediately.  And the new `governor` can then call `Timelock#setDelay()` and change the delay to `0`, also effective immediately.  The new `governor` can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.  In conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105 ```solidity=98{100,102-103}   function setGovernor(address _governor)     public     onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")   {     _swapRole(_governor, governor, GOVERNOR_ROLE);     governor = _governor;     emit NewGovernor(_governor);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77 ```solidity=66{71,74}   function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")   {     require(       _delay >= 0 && _delay < gracePeriod,       \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"     );     delay = _delay;      emit NewDelay(delay);   } ```   ## Recommendation  Consider making `setGovernor` and `setDelay` only callable from the Timelock contract itself.  Specificaly, changing from `onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")` to `require(msg.sender == address(this), \"...\")`.  Also, consider changing `_adminSetup(_admin)` in `Timelock#initialize()` to `_adminSetup(address(this))`, so that all roles are managed by the timelock itself as well.  "}, {"title": "Slippage checks when adding liquidity are too strict", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/257", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  When adding liquidity through `UniswapHandler.addLiquidity`, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances. If the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.  See `UniswapHandler.buyMalt`:  ```solidity (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(   address(malt),   address(rewardToken),   maltBalance, // @audit-info amountADesired   rewardBalance,   // @audit assumes that whatever is in this contract is already balanced. good assumption?   maltBalance.mul(95).div(100), // @audit-info amountAMin   rewardBalance.mul(95).div(100),   msg.sender, // transfer LP tokens to sender   now ); ```  ## Impact If the contract has unbalanced balances, then the `router.addLiquidity` call will revert. Note that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.  ## Recommended Mitigation Steps It needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio. It might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.  "}, {"title": "`UniswapHandler.maltMarketPrice` returns wrong decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price. However, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:  ```solidity else if (rewardDecimals < maltDecimals) {   uint256 diff = maltDecimals - rewardDecimals;   price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);   decimals = maltDecimals; } ```  Note that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals). Then, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`. However `decimals = maltDecimals` is wrongly returned.  ## Impact Callers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount. Luckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.  ## Recommendation Fix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.  "}, {"title": "`_getFirstSample` returns wrong sample if count < sampleMemory", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/252", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer: - `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations. - `counter`: The pending sample index (modulo `sampleMemory`)  The `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only _if the ring buffer is full_, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).  If the `samples` array does not wrap around yet, the zero index should be returned instead.  ## Impact Returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index. This then leads to a wrong computation of the TWAP.  ## Recommended Mitigation Steps Add an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.  "}, {"title": "Bonding doesn't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/251", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  Certain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.  ## Impact The `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.  ## Recommended Mitigation Steps To support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.  "}, {"title": "Wrong permissions on `reassignGlobalAdmin`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/250", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")`.  However, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.  ## Recommended Mitigation Steps The idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller _only_ has the `TIMELOCK` roll and will revert in this case. Maybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.  "}, {"title": "Initial `SetTransferService` event not emitted", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/249", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The initial `SetTransferService` event in `Malt.initialize` is not emitted.  ## Impact Off-chain programs might not correctly track the initial `transferService` variable as the initial event is missing.  ## Recommended Mitigation Steps Emit it in `initialize`.  "}, {"title": "`approve` return values not checked & unsafe", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/247", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ERC20.approve()` function returns a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.  In addition, some tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ```solidity IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  This issue exists for example in `AuctionParticipant.purchaseArbitrageTokens`:  ```solidity auctionRewardToken.approve(address(auction), balance); ```  As well as in `UniswapHandler.buyMalt`:  ```solidity rewardToken.approve(address(router), rewardBalance); ```  ## Impact Tokens that don't correctly implement the latest EIP20 spec, by either returning `false` on failure or reverting if approved from a non-zero value, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeApprove(0)` functions that handle the return value check as well as non-standard-compliant tokens.  "}, {"title": "`initialize` functions can be frontrun", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/245", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `initialize` function that initializes important contract state can be called by anyone. See: - `ERC20VestedMine.initialize` - `AuctionPool.initialize` - all contracts that extend `Permissions`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.  "}, {"title": "Implementations should inherit their interface", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/242", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice for the contract implementations to inherit their interface definition.  Doing so would improve the contract's clarity, and force the implementation to comply with the defined interface.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/TransferService.sol#L14-L14 ```solidity=14 contract TransferService is Initializable, Permissions { ```  `TransferService` should inherit `ITransferService`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L20-L20  ```solidity=20 contract UniswapHandler is Initializable, Permissions { ```  `UniswapHandler` should inherit `IDexHandler`.  "}, {"title": "Bonding.sol _unbondAndBreak does not account for edge case where no tokens are returned", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/234", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In Bonding.sol, the internal function `_unbondAndBreak` transfers a user's stake tokens to the dexHandler and then calls `removeLiquidity` on the dexHandler. Within the Uniswap handler (which is the only handler so far) `removeLiquidity` takes special care in the edge case where `router.removeLiquidity` returns zero tokens. Specifically, the Uniswap handler has this code: ``` if (amountMalt == 0 || amountReward == 0) {  liquidityBalance = lpToken.balanceOf(address(this));  lpToken.safeTransfer(msg.sender, liquidityBalance);  return (amountMalt, amountReward); } ```  If this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.  ## Proof of Concept See `_unbondAndBreak` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226  Notice how the edge case where `amountMalt == 0 || amountReward == 0` is not considered in this function, but it is considered in the Uniswap handler's `removeLiquidity` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240  ## Tools Used Inspection.  ## Recommended Mitigation Steps Add a similar edge case check to `_unbondAndBreak`. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.  "}, {"title": "`permit` Double Emits An `Approval` Event", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `permit` function is intended to facilitate approvals though signature verification. This helps to merge the two-step token transfer process consisting of an initial token approval and subsequent transfer. The `permit` function emits an `Approval` event, however, the `_approve` function also emits the same `Approval` event. As a result, off-chain scripts monitoring the blockchain for such events will see the same event emitted twice which may cause unintended issues.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ERC20Permit.sol#L58-L59 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L314  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider not emitting an `Approval` event in `permit`.  "}, {"title": "`_distributeRewards` Does Not Reset Approval If Not All Tokens Were Allocated", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/229", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.  "}, {"title": "`addLiquidity` Does Not Reset Approval If Not All Tokens Were Added To Liquidity Pool", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/228", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.  "}, {"title": "Auction collateralToken won't work if token is fee-on-transfer token ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/227", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact There are several ERC20 tokens that take a small fee on transfers/transferFroms (known as \"fee-on-transfer\" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.  For example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.  ## Proof of Concept See `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  See `purchaseAndBurn` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117  ## Tools Used Inspection  ## Recommended Mitigation Steps Add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.  "}, {"title": "Frontrunning in UniswapHandler calls to UniswapV2Router", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/219", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  thank_you   # Vulnerability details  ## Impact UniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.  - addLiquidity - removeLiquidity - swapExactTokensForTokens (swaps for both DAI and Malt)  In all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.  UniswapHandler correctly handles price slippage when calling [addLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for [removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.  How does this work? Let's assume UniswapHandler makes a call to [UniswapV2Router#swapExactTokensForTokens](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to [zero](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.  It's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.  The following functions when called are vulnerable to frontrunning attacks:  - [UniswapHandler#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131) - [UniswapHandler#sellMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160) - [UniswapHandler#removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)  And by extension the following contract functions since they also call the UniswapHandler function calls:  - [Bonding#unbondAndBreak](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114) - [LiquidityExtension#purchaseAndBurn](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117) - [RewardReinvestor#splitReinvest](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78) - [StabilizerNode#stabilize](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145) - [SwingTrader#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)   ## Proof of Concept Refer to the impact section for affected code and links to the appropriate LoC.  ## Tools Used N/A  ## Recommended Mitigation Steps The UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.   ## Anything Else We Should Know I wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.  "}, {"title": "Missing zero address check which will put forfeited rewards at risk(ForefeitHandler.sol) ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/216", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0xwags   # Vulnerability details  ## Impact Since users forfeited awards will be shared between either the treasury and the swing trader, there should be a zero address in the initialize() function to ensure rewards are not lost and thereby affecting  Malt's collateralisation and other such funding mechanism.   This will have implications for safetransfer() functions in lines 50 & 54 in handleForfeit().   ## Tools Used Manual Analysis.   ## Recommended Mitigation Steps  require(treasuryMultisig&& swingTrader ! =address(0), \"0x0\");  "}, {"title": "`_calculateMaltRequiredForExit` Uses Spot Price To Calculate Malt Quantity In `exitEarly`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109 https://shouldiusespotpriceasmyoracle.com/  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing/integrating a TWAP oracle to track the price of Malt.  "}, {"title": "Timelock reuse function argument as argument for the event emit", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse the function argument in the event emit instead of the storage variable. This saves a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L82   ## Tools Used  ## Recommended Mitigation Steps - L76 write: emit NewDelay(_delay); - L92: write: emit NewGracePeriod(_gracePeriod);  "}, {"title": "MovingAverage:getValueWithLookback move sampleDiff  to save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/212", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Move the initialization of sampleDiff below the if block to save gas in the case of return of the if block.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L128  ## Tools Used  "}, {"title": "MovingAverage:getValue move the declaration/initialization of sampleDiff to save gas in the case of an early return", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact move the sampleDiff (L86) below the if statement L88 to save the declaration/initialization of sampleDiff in the case the if block gets executed and the function returns early  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L86 ## Tools Used  ## Recommended Mitigation Steps - move the declaration/initialization of of sampleDiff below the if statement  "}, {"title": "MovingAverage:initialize reuse argument variable instead storage variable in the loop condition", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse _sampleMemory instead of the storage variable sampleMemory in the condition statement of the loop to save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60 ## Tools Used  ## Recommended Mitigation Steps - rewrite L60 as: for (uint i = 0; i < _sampleMemory ; i++)  "}, {"title": "Reduce external calls", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L219  Before call _distributeSupply function, it already get priceTarget, But in _distributeSupply, it again call external call to get price target. This will use higher gas.   ## Tools Used Manual  ## Recommended Mitigation Steps Send price target in _distributeSupply() function argument, and please review all duplicated external calls and optimize them.  "}, {"title": "In TransactionService, store index of source to avoid loop when removing verifier", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact In removeVerifier function, it loop until last index - 1 to find source index. If you added many verifiers, then the gas cost of removeVerifier will be very high, and it can be reverted due to gas limit as well.   ## Tools Used Manual  ## Recommended Mitigation Steps Store index of address in addVerifier function, and remove loop in removeVerifier, and use stored index.  "}, {"title": "Revert transaction if it is unable to change data", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/198", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L62 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L78  In addVerifier and removeVerifier functions of TransferService.sol, it just returns instead of revert if it is unable to change data. Revert transaction to avoid creating unnecessary transaction and save transaction cost.   ## Tools Used Manual  ## Recommended Mitigation Steps Revert transaction instead of return.  "}, {"title": "_notSameBlock() can be circumvented in bondToAccount() ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/195", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function bondToAccount() of Bonding.sol has a check based on _notSameBlock()  _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.  However this can be circumvented in this case: Suppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract. For a pseudo code proof of concept see below.  I'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount(). But if it is important then circumventing this check it will pose a risk.  ## Proof of Concept call function attack1.attack() ```JS contract attack1 {    function attack(address account, uint256 amount) {          call attack2.forward(account, amount);          call any other function of malt   } }  contract attack2 {    function forward(address account, uint256 amount) {        call bonding.bondToAccount(account, amount); // uses msg.sender of attack2    } } ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92  ```JS function bondToAccount(address account, uint256 amount) public {     if (msg.sender != offering) {          _notSameBlock();     }     ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141 ```JS function _notSameBlock() internal {     require( block.number > lastBlock[_msgSender()],\"Can't carry out actions in the same block\" );     lastBlock[_msgSender()] = block.number;   } ```  ## Tools Used  ## Recommended Mitigation Steps Add access controls to the function bondToAccount() An end-user could still call bond()   "}, {"title": "Adapt count in setAuctionAverageLookback?", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/194", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setAuctionAverageLookback of AuctionBurnReserveSkew.sol change auctionAverageLookback  However there is also the variable \"count\" that is used in amongst others, addAbovePegObservation(). The modulo of count with auctionAverageLookback is calculated via _getIndexOfObservation(). When you change auctionAverageLookback then the modulo will result in a different value, so you end up in a different location of the circular buffer.  You should probably adapt count as well in the function setAuctionAverageLookback() (see also function setSampleMemory of MovingAverage.sol where a similar pattern is used)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L186-L200  ```JS function setAuctionAverageLookback(uint256 _lookback) external onlyRole(ADMIN_ROLE, \"Must have admin role\") { ..     if (_lookback > auctionAverageLookback) {       for (uint i = auctionAverageLookback; i < _lookback; i++) {         pegObservations.push(0);       }     }      auctionAverageLookback = _lookback;  ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L143-L153 ```JS  function addAbovePegObservation(uint256 amount)  public onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\") {     uint256 index = _getIndexOfObservation(count);     ...     pegObservations[index] = 1;     count = count + 1; ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L134-L136 ```JS  function _getIndexOfObservation(uint _index) internal view returns (uint index) {     return _index % auctionAverageLookback;   } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: Add the following statement in the function  setAuctionAverageLookback(), before auctionAverageLookback is updated.  ```JS  count = count  % auctionAverageLookback ; // the old version of auctionAverageLookback  ```   "}, {"title": "setSampleMemory counter set to right value?", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/193", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setSampleMemory of MovingAverage.sol takes the modulo of counter with the new value of _sampleMemory: \"counter = counter % _sampleMemory;\"  Suppose: counter =15 ; sampleMemory=10 and  _sampleMemory=12 Then:   counter = counter % _sampleMemory ==> 3,  which means processing will continue at position 3.  However I think it should use: counter = counter % sampleMemory,  so it will continue at position 5  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/MovingAverage.sol#L424-L442  ```JS function setSampleMemory(uint256 _sampleMemory) external onlyRole(ADMIN_ROLE, \"Must have admin privs\")  {   ...     if (_sampleMemory > sampleMemory) {       ...       counter = counter % _sampleMemory;     } else {    }     sampleMemory = _sampleMemory; } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: change ```JS  counter = counter % _sampleMemory; ``` to ```JS  counter = counter %  sampleMemory; ```   "}, {"title": "Max value of upperStabilityThreshold and lowerStabilityThreshold not checked", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/192", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setStabilityThresholds of StabilizerNode.sol set the values for upperStabilityThreshold and lowerStabilityThreshold, however there is no check for a maximum value. This means that in function _shouldAdjustSupply() the values for upperThreshold and lowerThreshold  could get larger than priceTarget. When they are subtracted from priceTarget a revert will occur.  Thus it is useful the make sure that upperStabilityThreshold and lowerStabilityThreshold don't get too large.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L445-L454  ```JS function setStabilityThresholds(uint256 _upper, uint256 _lower) external onlyRole(ADMIN_ROLE, \"Must have admin role\") {     require(_upper > 0 && _lower > 0, \"Must be above 0\");     upperStabilityThreshold = _upper;     lowerStabilityThreshold = _lower; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L198-L206  ```JS function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {    ...     uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals); // upperStabilityThreshold could be > 10**dec => upperThreshold could be > priceTarget     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);  // lowerStabilityThreshold could be > 10**dec => lowerThreshold could be > priceTarget      return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold); // can revert   } ```  ## Tools Used  ## Recommended Mitigation Steps In function setStabilityThresholds() check for a maximum value of upperStabilityThreshold and lowerStabilityThreshold  "}, {"title": "`StabilizerNode` Will Mint An Incentive For Triggering An Auction Even If An Auction Exists Already", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.  ## Proof of Concept  `_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.  "}, {"title": "No max for advanceIncentive", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/190", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive. If incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.  The function setAdvanceIncentive() can only be called by an admin, but a mistake could be made. Also if an admin would want to do a rug pull, this would be an ideal place to do it.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104  ```JS   function setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, \"Must have admin role\") {    ...     advanceIncentive = incentive; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  ```JS function advance() external { ...     malt.mint(msg.sender, advanceIncentive * 1e18);  ```  ## Tools Used  ## Recommended Mitigation Steps Check for a reasonable maximum value in advance()  "}, {"title": "Users Can Contribute To An Auction Without Directly Committing Collateral Tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/188", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.  ## Proof of Concept  Consider the following scenario: - An auction is currently active. - A user sends collateral tokens to the `LiquidityExtension` contract. - The same user calls `purchaseArbitrageTokens` with amount `0`. - The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.  As a result, a user could effectively influence the average malt price used throughout the `Auction` contract.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.  "}, {"title": "governor or timelock", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/187", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the contract Timelock.sol the following onlyRole expression occurs a few times, referring GOVERNER and timelock: onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")  Whereas several other onlyRole expressions are referring to governor: onlyRole(GOVERNOR_ROLE, \"Timelock::...: Call must come from governor.\")  Either the role should be TIMELOCK_ROLE or the messages should refer consistently to governor. Otherwise it might be more difficult to solve error messages from reverts.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L68  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L84  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L100  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L115  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L140  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L159  ## Tools Used  ## Recommended Mitigation Steps Make the error messages consistent   "}, {"title": "Outdated Solidity Version Provides No Protections Against Arithmetic Underflows And Overflows", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/185", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  Malt Finance uses solidity version `>=0.6.6` throughout all of its contracts. This solidity version provides no protections against arithmetic underflows and overflows. As a result, it is incredibly difficult to guarantee that the protocol enforces the necessary arithmetic checks during sensitive actions.  There are several instances where the OpenZeppelin's `SafeMath` library is not used. This exposes the protocol to potential exploits via arithmetic underflows and overflows. The liveness of the protocol depends on safety guarantees that are not provided/enforced. Therefore, this issue should be deemed high severity.  ## Proof of Concept  Solidity version shown in all contracts.  ## Tools Used  Manual code review. https://docs.soliditylang.org/en/v0.8.10/080-breaking-changes.html  ## Recommended Mitigation Steps  Consider updating the smart contract suite to use the latest solidity version or at the very least integrate OpenZeppelin's `SafeMath` library in all areas of the code containing arithmetic operations.  "}, {"title": "`setupParticipant` function should be internal", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/183", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact No vulnerability, however as `setupPartipant` would only ever be executed by the constructor in its deriving contracts, it would make sense if it was internal instead of public. If it was not executed in the constructor of the deriving contract, then at least it is safer with internal visibility.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L30   "}, {"title": "Similar code in `getCollateralValueInMalt` and `totalUsefulCollateral` functions ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact The code in `getCollateralValueInMalt` of ImpliedCollateralService.sol, can leverage the `totalUsefulCollateral` function, reducing code size and gas cost when calling the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L104-L124  ## Tools Used manual  ## Recommended Mitigation Steps Remove L108-L110, then in the return of `getCollateralValueInMalt` return `totalUsefulCollateral().mul(target).div(maltPrice) + swingTraderMaltBalance`  "}, {"title": "Duplicated code in `unbond` and `unbondAndBreak` functions", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact A large portion of the `unbond` and `unbondAndBreak` code of Bonding.sol is the same, to reduce code bloat and gas when calling the contract   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L97-L109  ## Tools Used Manual  ## Recommended Mitigation Steps I would suggest wrapping the duplicated code into an internal function called by `unbond` and `unbondAndBreak`.  "}, {"title": "Malt decimals inconsistency: StabilizerNode and DAO contracts use 18 as hard coded Malt decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/175", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  If Malt token be set to have lower decimals the incentives will be too big to be issued and DAO advance epoch and StabilizerNode auction start functions will fail, the system will have to be redeployed.  For example, if Malt was set to have 6 decimals like USDC, then 100*1e18 StabilizerNode defaultIncentive will be 100 trillions Malt.  ## Proof of Concept  Now some parts of the system use ```malt.decimals()``` (SwingTrader, UniswapHandler), some (StabilizerNode, DAO) use 18.  DAO advanceIncentive:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DAO.sol#L60   StabilizerNode defaultIncentive:  stabilize function https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145  calls _startAuction in low exchangeRate case, minting defaultIncentive * 10**18 = 100 * 1e18 Malt to the sender as a caller fee. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L344   ## Recommended Mitigation Steps  If Malt decimals are meant to be set to 18, add a constant variable and use it across the system to save gas.  If the flexibility is desired ```malt.decimals()``` to be used, in a form of contract storage variable for gas optimization (```decimals()``` can be saved to storage once on initialization, and read from there afterwards).   "}, {"title": "Lack of precision", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/168", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  This issue is about arithmetic computation that could have been done more percise.  The following are places in the codebase in which you multiplied after the divisions.  Doing the multiplications at start lead to more accurate calculations.  This is a list of places in the code that this appears (Solidity file, line number, actual line):           DAO.sol, 105,   /* Internal methods */          UniswapHandler.sol, 265,         buyBase.div(priceTarget).mul(buyBase).mul(997)          RewardDistributor.sol, 113,   /* PUBLIC VIEW FUNCTIONS */          RewardDistributor.sol, 118,   /* INTERNAL VIEW FUNCTIONS */          RewardDistributor.sol, 129,   /* INTERNAL FUNCTIONS */   "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function getRewardOwnershipFraction in AbstractRewardMine.sol could be set external         The function balanceOfStakePadding in AbstractRewardMine.sol could be set external         The function withdrawnBalance in AbstractRewardMine.sol could be set external         The function earned in AbstractRewardMine.sol could be set external         The function setMiningService in AbstractRewardMine.sol could be set external         The function totalReleasedReward in AbstractRewardMine.sol could be set external         The function totalStakePadding in AbstractRewardMine.sol could be set external         The function totalBonded in AbstractRewardMine.sol could be set external         The function totalWithdrawn in AbstractRewardMine.sol could be set external         The function setRewardToken in AbstractRewardMine.sol could be set external         The function onBond in AbstractRewardMine.sol could be set external         The function withdrawAll in AbstractRewardMine.sol could be set external         The function onUnbond in AbstractRewardMine.sol could be set external         The function balanceOfBonded in AbstractRewardMine.sol could be set external         The function verifyTransfer in AbstractTransferVerification.sol could be set external         The function getAuctionCore in Auction.sol could be set external         The function getAuctionPrices in Auction.sol could be set external         The function getAuction in Auction.sol could be set external         The function auctionActive in Auction.sol could be set external         The function getAuctionCommitments in Auction.sol could be set external         The function isAuctionFinalized in Auction.sol could be set external         The function balanceOfArbTokens in Auction.sol could be set external         The function auctionExists in Auction.sol could be set external         The function consult in AuctionBurnReserveSkew.sol could be set external         The function getAverageParticipation in AuctionBurnReserveSkew.sol could be set external         The function addAbovePegObservation in AuctionBurnReserveSkew.sol could be set external         The function getPegDeltaFrequency in AuctionBurnReserveSkew.sol could be set external         The function addBelowPegObservation in AuctionBurnReserveSkew.sol could be set external         The function getRealBurnBudget in AuctionBurnReserveSkew.sol could be set external         The function earlyExitReturn in AuctionEscapeHatch.sol could be set external         The function setReplenishingIndex in AuctionParticipant.sol could be set external         The function usableBalance in AuctionParticipant.sol could be set external         The function outstandingArbTokens in AuctionParticipant.sol could be set external         The function getAllAuctionIds in AuctionParticipant.sol could be set external         The function setupParticipant in AuctionParticipant.sol could be set external         The function usableBalance in AuctionPool.sol could be set external         The function setBonding in AuctionPool.sol could be set external         The function totalReleasedReward in AuctionPool.sol could be set external         The function totalBonded in AuctionPool.sol could be set external         The function setForfeitDestination in AuctionPool.sol could be set external         The function onUnbond in AuctionPool.sol could be set external         The function totalDeclaredReward in AuctionPool.sol could be set external         The function balanceOfBonded in AuctionPool.sol could be set external         The function setMiningService in Bonding.sol could be set external         The function epochData in Bonding.sol could be set external         The function totalBonded in Bonding.sol could be set external         The function bondedEpoch in Bonding.sol could be set external         The function setDAO in Bonding.sol could be set external         The function setDexHandler in Bonding.sol could be set external         The function setCurrentEpoch in Bonding.sol could be set external         The function bondToAccount in Bonding.sol could be set external         The function averageBondedValue in Bonding.sol could be set external         The function balanceOfBonded in Bonding.sol could be set external         The function deploy in Create2Deployer.sol could be set external         The function getEpochStartTime in DAO.sol could be set external         The function epochsPerYear in DAO.sol could be set external         The function mint in DAO.sol could be set external         The function setEpochLength in DAO.sol could be set external         The function setMaltToken in DAO.sol could be set external         The function maltMarketPrice in UniswapHandler.sol could be set external         The function reserves in UniswapHandler.sol could be set external         The function constructor in ERC20Permit.sol could be set external         The function setBonding in ERC20VestedMine.sol could be set external         The function totalReleasedReward in ERC20VestedMine.sol could be set external         The function totalBonded in ERC20VestedMine.sol could be set external         The function setDistributor in ERC20VestedMine.sol could be set external         The function onUnbond in ERC20VestedMine.sol could be set external         The function totalDeclaredReward in ERC20VestedMine.sol could be set external         The function balanceOfBonded in ERC20VestedMine.sol could be set external         The function handleForfeit in ForfeitHandler.sol could be set external         The function totalUsefulCollateral in ImpliedCollateralService.sol could be set external         The function getCollateralValueInMalt in ImpliedCollateralService.sol could be set external         The function collateralDeficit in LiquidityExtension.sol could be set external         The function reserveRatio in LiquidityExtension.sol could be set external         The function hasMinimumReserves in LiquidityExtension.sol could be set external         The function constructor in Malt.sol could be set external         The function burn in Malt.sol could be set external         The function mint in Malt.sol could be set external         The function smoothedMaltPrice in MaltDataLab.sol could be set external         The function trackReserveRatio in MaltDataLab.sol could be set external         The function maltInPoolAverage in MaltDataLab.sol could be set external         The function smoothedMaltInPool in MaltDataLab.sol could be set external         The function reserveRatioAverage in MaltDataLab.sol could be set external         The function maltPriceAverage in MaltDataLab.sol could be set external         The function smoothedReserves in MaltDataLab.sol could be set external         The function smoothedReserveRatio in MaltDataLab.sol could be set external         The function balanceOfRewards in MiningService.sol could be set external         The function removeRewardMine in MiningService.sol could be set external         The function earned in MiningService.sol could be set external         The function withdrawRewardsForAccount in MiningService.sol could be set external         The function setReinvestor in MiningService.sol could be set external         The function withdrawAccountRewards in MiningService.sol could be set external         The function setBonding in MiningService.sol could be set external         The function isMineActive in MiningService.sol could be set external         The function onBond in MiningService.sol could be set external         The function numberOfMines in MiningService.sol could be set external         The function onUnbond in MiningService.sol could be set external         The function addRewardMine in MiningService.sol could be set external         The function getValue in MovingAverage.sol could be set external         The function getValueWithLookback in MovingAverage.sol could be set external         The function isWhitelisted in PoolTransferVerification.sol could be set external         The function setPool in PoolTransferVerification.sol could be set external         The function addToWhitelist in PoolTransferVerification.sol could be set external         The function verifyTransfer in PoolTransferVerification.sol could be set external         The function setThreshold in PoolTransferVerification.sol could be set external         The function setPriceLookback in PoolTransferVerification.sol could be set external         The function removeFromWhitelist in PoolTransferVerification.sol could be set external         The function setForfeitor in RewardDistributor.sol could be set external         The function addFocalLengthUpdater in RewardDistributor.sol could be set external         The function setRewardMine in RewardDistributor.sol could be set external         The function setBonding in RewardDistributor.sol could be set external         The function forfeit in RewardDistributor.sol could be set external         The function vest in RewardDistributor.sol could be set external         The function setThrottler in RewardDistributor.sol could be set external         The function setRewardToken in RewardDistributor.sol could be set external         The function removeFocalLengthUpdater in RewardDistributor.sol could be set external         The function decrementRewards in RewardDistributor.sol could be set external         The function totalDeclaredReward in RewardDistributor.sol could be set external         The function setFocalLength in RewardDistributor.sol could be set external         The function averageAPR in RewardThrottle.sol could be set external         The function targetEpochProfit in RewardThrottle.sol could be set external         The function epochData in RewardThrottle.sol could be set external         The function targetAPR in RewardThrottle.sol could be set external         The function getTargets in RewardThrottle.sol could be set external         The function handleReward in RewardThrottle.sol could be set external         The function checkRewardUnderflow in RewardThrottle.sol could be set external         The function epochAPR in RewardThrottle.sol could be set external         The function costBasis in SwingTrader.sol could be set external         The function setLpProfitCut in SwingTrader.sol could be set external         The function addVerifier in TransferService.sol could be set external         The function numberOfVerifiers in TransferService.sol could be set external         The function verifyTransfer in TransferService.sol could be set external         The function removeVerifier in TransferService.sol could be set external   "}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           AbstractRewardMine.sol Variable miningService is read 3 times in the function:  setMiningService         Auction.sol Variable currentAuctionId is read 3 times in the function:  purchaseArbitrageTokens         Auction.sol Variable nextCommitmentId is read 2 times in the function:  purchaseArbitrageTokens         Auction.sol Variable currentAuctionId is read 4 times in the function:  _checkAuctionFinalization         Auction.sol Variable replenishingAuctionId is read 4 times in the function:  allocateArbRewards         Auction.sol Variable stabilizerNode is read 2 times in the function:  setStabilizerNode         Auction.sol Variable amender is read 2 times in the function:  setAuctionAmender         AuctionBurnReserveSkew.sol Variable auctionAverageLookback is read 2 times in the function:  getPegDeltaFrequency         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addAbovePegObservation         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addBelowPegObservation         AuctionBurnReserveSkew.sol Variable stabilizerNode is read 2 times in the function:  setNewStabilizerNode         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  claim         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  setReplenishingIndex         AuctionPool.sol Variable forfeitedRewards is read 2 times in the function:  _checkForForfeit         AuctionPool.sol Variable forfeitedRewards is read 3 times in the function:  _handleRewardDistribution         UniswapHandler.sol Variable router is read 2 times in the function:  addLiquidity         MaltDataLab.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MiningService.sol Variable reinvestor is read 2 times in the function:  setReinvestor         MiningService.sol Variable bonding is read 2 times in the function:  setBonding         MovingAverage.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MovingAverage.sol Variable cumulativeValue is read 11 times in the function:  update         MovingAverage.sol Variable blockTimestampLast is read 5 times in the function:  update         MovingAverage.sol Variable activeSamples is read 2 times in the function:  update         MovingAverage.sol Variable sampleLength is read 3 times in the function:  update         MovingAverage.sol Variable cumulativeValue is read 10 times in the function:  updateCumulative         MovingAverage.sol Variable blockTimestampLast is read 4 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable sampleLength is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  _createNewSample         MovingAverage.sol Variable counter is read 2 times in the function:  setSampleMemory         RewardReinvestor.sol Variable dexHandler is read 2 times in the function:  _bondAccount         RewardReinvestor.sol Variable treasury is read 2 times in the function:  _bondAccount         RewardDistributor.sol Variable FOCAL_LENGTH_UPDATER_ROLE is read 2 times in the function:  initialize         RewardDistributor.sol Variable focalLength is read 2 times in the function:  _resetFocalPoint         RewardDistributor.sol Variable focalID is read 3 times in the function:  _incrementFocalPoint         RewardDistributor.sol Variable throttler is read 2 times in the function:  setThrottler         RewardDistributor.sol Variable rewardMine is read 2 times in the function:  setRewardMine         RewardOverflowPool.sol Variable throttler is read 2 times in the function:  setThrottler         RewardThrottle.sol Variable _activeEpoch is read 3 times in the function:  handleReward         StabilizerNode.sol Variable stabilizeWindowEnd is read 2 times in the function:  stabilize         StabilizerNode.sol Variable lastStabilize is read 2 times in the function:  stabilize         StabilizerNode.sol Variable liquidityExtension is read 2 times in the function:  _replenishLiquidityExtension         StabilizerNode.sol Variable auction is read 2 times in the function:  setAuctionContract         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  buyMalt         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  sellMalt   "}, {"title": "Unused declared local variables", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <in which function we found it>, <unused local variable name>:           AbstractRewardMine.sol, _handleStakePadding, totalRewardedWithStakePadding         AbstractRewardMine.sol, _handleStakePadding, INITIAL_STAKE_SHARE_MULTIPLE         AbstractRewardMine.sol, _handleStakePadding, bondedTotal         Auction.sol, _finalizeAuction, avgMaltPrice         AuctionParticipant.sol, claim, replenishingId         AuctionParticipant.sol, claim, claimableTokens         AuctionParticipant.sol, claim, claimable         Create2Deployer.sol, deploy, addr         UniswapHandler.sol, removeBuyer, buyer         MaltDataLab.sol, trackPoolReserves, rewardDecimals         MovingAverage.sol, update, elapsedSamples         MovingAverage.sol, updateCumulative, elapsedSamples         StabilizerNode.sol, stabilize, exchangeRate         StabilizerNode.sol, _startAuction, decimals         SwingTrader.sol, sellMalt, maltDecimals         SwingTrader.sol, costBasis, maltDecimals         TransferService.sol, removeVerifier, verifier   "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  In the following files, there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AuctionBurnReserveSkew.sol, line 4, import \"@openzeppelin/contracts/access/AccessControl.sol\";         AuctionParticipant.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         AuctionParticipant.sol, line 3, import \"@openzeppelin/upgrades/contracts/Initializable.sol\";         AuctionPool.sol, line 9, import \"./interfaces/IAuction.sol\";         AuctionPool.sol, line 10, import \"./interfaces/IBurnMintableERC20.sol\";         AuctionPool.sol, line 11, import \"./interfaces/IDexHandler.sol\";         Bonding.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         ERC20VestedMine.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         ImpliedCollateralService.sol, line 12, import \"./interfaces/IRewardThrottle.sol\";         LiquidityExtension.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         LiquidityExtension.sol, line 3, import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";         MaltDataLab.sol, line 7, import \"./interfaces/IStabilizerNode.sol\";         MaltDataLab.sol, line 9, import \"./interfaces/IDAO.sol\";         MiningService.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         MiningService.sol, line 3, import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";         PoolTransferVerification.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         PoolTransferVerification.sol, line 6, import \"./Permissions.sol\";         RewardDistributor.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         RewardDistributor.sol, line 11, import \"hardhat/console.sol\";         RewardOverflowPool.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         RewardThrottle.sol, line 2, import \"@openzeppelin/contracts/math/SafeMath.sol\";         RewardThrottle.sol, line 13, import \"hardhat/console.sol\";         SwingTrader.sol, line 8, import \"./interfaces/IAuction.sol\";         TransferService.sol, line 4, import \"./interfaces/IMaltDataLab.sol\";   "}, {"title": "AuctionBurnReserveSkew:addAbovePegObservation gas optimization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++); so we save at least a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L143  ## Tools Used  ## Recommended Mitigation Steps Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++);  "}, {"title": "AuctionBurnReserveSkew:getRealBurnBudget no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact After teh if statement on L74, we have premiumExcess <= maxBurnSpend and therefore don't need to do a save subtraction (underflow check) on L80.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69  ## Tools Used  ## Recommended Mitigation Steps - rewrite L80 as: uint256 usableExcess = maxBurnSpend - premiumExcess;  "}, {"title": "Auction:amendAccountParticipation no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Else block on L805 satisfies amountArbTokens <= unclaimedArbTokens and therefore no safe subtraction (underflow check) is needed (saves gas).  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L786  ## Tools Used  ## Recommended Mitigation Steps - rewrite L805 as: unclaimedArbTokens = unclaimedArbTokens - amountArbTokens;  "}, {"title": "Auction:claimArbitrage no underflow checks needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  # Vulnerability details  ## Impact The else block on L241 satisfies amountTokens <= unclaimedArbTokens and therefore we don't need to do a safe subtraction (underflow check).  The else block on L247 satisfies amountTokens <= claimableArbitrageRewards and therefore we don't need to do a safe subtraction (underflow check).     ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L216 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L247  ## Tools Used  ## Recommended Mitigation Steps - rewrite L241 as: unclaimedArbTokens = unclaimedArbTokens - amountTokens; - rewrite L274 as: claimableArbitrageRewards = claimableArbitrageRewards - amountTokens-;   "}, {"title": "Auction:purchaseArbitrageTokens gas optimization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L209 nextCommitmentId = nextCommitmentId + 1; can be removed and L202 can be changed to nextCommitmentId++; to save a SLOAD  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  "}, {"title": "RewardThrottle:handleReward gas optimizations", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Storage variable _activeEpoch is read a lot and can be cached in a local variable (epochTmp, maybe choose a better name =)) to save gas. Also the State struct can be loaded into a State storage (currentState, maybe also choose a better name) variable such that we don't have to access the storage array each time.   In the gas optimized code of \"Recommended Mitigation Steps\" section, the _activeEpoch only gets read once. Also note after the first \"if\" we write epoch to the storage variable \"_activeEpoch\" but then also write epoch to the local var \"epochTmp\" so we can use this local var in the whole function.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L63  ## Tools Used  ## Recommended Mitigation Steps   function handleReward() public {     uint256 balance = rewardToken.balanceOf(address(this));      uint256 epoch = dao.epoch();     uint256 epochTmp = _activeEpoch;     State storage currentState;      checkRewardUnderflow();      if (epoch > epochTmp) {       _activeEpoch = epoch;       epochTmp = epoch;        currentState = _state[epochTmp];        currentState.bondedValue = bonding.averageBondedValue(epochTmp);        currentState.profit = balance;       currentState.rewarded = 0;       currentState.throttle = throttle;     } else {       currentState = _state[epochTmp];       currentState.profit = currentState.profit.add(balance);       currentState.throttle = throttle;      }      // Fetch targetAPR before we update current epoch state     uint256 aprTarget = targetAPR();      // Distribute balance to the correct places     if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {       uint256 remainder = _getRewardOverflow(balance, aprTarget);       emit RewardOverflow(epochTmp, remainder);        if (remainder > 0) {         rewardToken.safeTransfer(address(overflowPool), remainder);          if (balance > remainder) {           _sendToDistributor(balance - remainder, epochTmp);         }       }     } else {       _sendToDistributor(balance, epochTmp);     }      emit HandleReward(epoch, balance);   }  "}, {"title": "RewardDistributor:decrementRewards no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require statement conditions checks that no underflow can happen, therefore we don't need to use safe subtraction (underflow check).  - L275:  require(amount <= _globals.declaredBalance, \"Can't decrement more than total reward balance\"); - L278:  _globals.declaredBalance = _globals.declaredBalance.sub(amount); => Rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L271 ## Tools Used  ## Recommended Mitigation Steps - rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  "}, {"title": "RewardDistributor:_incrementFocalPoint() save storage read", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L185:  focalID = focalID + 1; can be removed and L197 can be adapted to:  _resetFocalPoint(++focalID, newEndTime); to save at least one warm storage read (100 gas)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L180 ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "RewardDistributor:_forfeit no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require condition checks already underflow condition. There for no underflow check is needed.  - L154: require(forfeited <= _globals.declaredBalance, \"Cannot forfeit more than declared\"); - L156:_globals.declaredBalance = _globals.declaredBalance.sub(forfeited);  Therefore L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L153 ## Tools Used  ## Recommended Mitigation Steps - L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;  "}, {"title": "AbstractRewardMine._handleStakePadding logic cases can be separated and function simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on operations.  ## Proof of Concept  The function contains two non-intersecting logic pathways, which can be separated to lighten calculations.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L179   ## Recommended Mitigation Steps  Now: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   uint256 bondedTotal = totalBonded();   uint256 newStakePadding = bondedTotal == 0 ?   totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :   totalRewardedWithStakePadding.mul(amount).div(bondedTotal);   _addToStakePadding(account, newStakePadding); } ```  To be: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 bondedTotal = totalBonded();    uint256 newStakePadding;  if (bondedTotal == 0) {   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   newStakePadding = totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0;  } else {   newStakePadding = (totalDeclaredReward().add(totalStakePadding())).mul(amount).div(bondedTotal);  }   if (newStakePadding > 0)   _addToStakePadding(account, newStakePadding); } ```  "}, {"title": "setupParticipant() function does not check for zero address", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/130", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact The setupParticipant() function in AuctionParticipant.sol does not have require statements to protect again contracts that do not yet exist.  It sets the addresses for \" _impliedCollateralService\", \"_rewardToken\", and \"_auction\" and can only be called once so its vital to have this guard in place.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L26  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add require checks for the addresses that are passed in the setupParticipant() function checking if they exist like: require(\"address\" != address(0), \"contract does not exist\")  "}, {"title": " AbstractRewardMine._handleStakePadding calls totalDeclaredReward and this way balanceOf function twice", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and function calls.  ## Proof of Concept  totalDeclaredReward is called by _handleStakePadding twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L180  While totalDeclaredReward does expensive balanceOf call: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L97  ## Recommended Mitigation Steps  It is viable to at least remove its double usage:  Now: ``` uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :  totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  To be: ``` uint256 declaredRewardTotal =  rewardToken.balanceOf(address(this)); uint256 totalRewardedWithStakePadding = declaredRewardTotal.add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  declaredRewardTotal == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 : totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  "}, {"title": "sellMalt(), addLiquidity() and removeLiquidity() Allow Non Privileged Users Withdraw Fund", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact Is Not Uncommon Normal Users Accidentally Send Tokens into Contract.  ENS Airdrop is a Good Example Normal Users Accidentally Send Tokens into Contract: https://discuss.ens.domains/t/social-amend-airdrop-proposal-to-include-accidentally-returned-funds/6975  In UniswapHandler.sol, sellMalt(), addLiquidity() and removeLiquidity() Have No Access Control. When Normal Users Accidently Deposit Tokens into the Contract, Any Random Persons/Bot Can Withdraw the Tokens because it will safeTransfer to msg.sender who find out there is token balance in the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L185-L219 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221-L245  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add relevant access control, probably Only StabilizerNode and Admin have Access to this contract various functions like sellMalt(), addLiquidity() and removeLiquidity() etc.   "}, {"title": "removeVerifier() Repeat SLOAD During Loop Is Waste of Gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact removeVerifier() loops follows this for-each pattern: for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` }  In such for loops, the array.length is read on every iteration, instead of caching it once in a local variable and read it again using the local variable.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87-L88  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read these values from memory once, cache them in local variables and then read them again using the local variables. For example:  Before: for (uint i = 0; i < verifierList.length - 1; i = i + 1) { if (verifierList[i] == _address) {  After: uint256 verifierList_temp = verifierList  for (uint i = 0; i < verifierList_temp.length - 1; i = i + 1) { if (verifierList_temp[i] == _address) {  "}, {"title": "Avoiding Initialization of Loop Index If It Is 0", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionBurnReserveSkew.sol#L54 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L34-L37 More...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.   Before: for (uint i = 0; After for (uint i;  "}, {"title": "_setupRole() Deprecated and Not Using With Constructor Effectively Circumventing the Admin System", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact      * [WARNING]      * ====      * This function should only be called from the constructor when setting      * up the initial roles for the system.      *      * Using this function in any other way is effectively circumventing the admin      * system imposed by {AccessControl}.      * ====      *      * NOTE: This function is deprecated in favor of {_grantRole}.  There are multiple contracts that import Permissions.sol and using Deprecated Function _setupRole() with Security Problem that Applicable to all these contracts because all of the contracts use initialize() Rather Than Constructor.   ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L174-L186 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L53 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L121  ## Tools Used Manual Review  ## Recommended Mitigation Steps Replace _setupRole() with _grantRole()  "}, {"title": "AbstractRewardMine.getRewardOwnershipFraction shouldn't be used internally", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function calls.  ## Proof of Concept  ```earned``` function calls public ```getRewardOwnershipFraction``` function: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L144  ## Recommended Mitigation Steps  Now: ``` function totalDeclaredReward() virtual public view returns (uint256) {  return rewardToken.balanceOf(address(this)); } function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {  numerator = balanceOfRewards(account);  denominator = totalDeclaredReward(); } ... function earned(address account) public view returns (uint256 earnedReward) {  (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);  ```  To be: ``` function earned(address account) public view returns (uint256 earnedReward) {  uint256 rewardNumerator = balanceOfRewards(account);  uint256 rewardDenominator = rewardToken.balanceOf(address(this)); ```  "}, {"title": "reassignGlobalAdmin() Lack of Zero Address Check ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/113", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or Users'FUND Locked inside the Contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_admin != address(0), \"Address Can't Be Zero\")  "}, {"title": "reassignGlobalAdmin() Have No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact The current ownership transfer process involves the current TIMELOCK_ROLE calling reassignGlobalAdmin().  If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the TIMELOCK_ROLE modifier.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider implementing a two step process where the TIMELOCK_ROLE nominates an account and the nominated account needs to call an accept_TIMELOCK_ROLE() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   "}, {"title": "Redundant require statements in `Auction:purchaseArbitrageTokens`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  loop   # Vulnerability details  When invoking `purchaseArbitrageTokens()` is will first check whether the auction is active using: ``` require(auctionActive(currentAuctionId), \"No auction running\"); ``` `auctionActive()` checks for the following things: ``` auction.active && now >= auction.startingTime; ``` As a result the require statement will fail if either `!auction.active` or `now < auction.startingTime`.   Later on in `purchaseArbitrageTokens()` two more require statements will check the same thing: ``` require(auction.startingTime <= now, \"Auction hasn't started yet\"); (...)  require(auction.active == true, \"Auction is not active\"); ``` These will always pass if `auctionActive(currentAuctionId)` is `true` and never be reached if it is `false`, making them redundant.  ## Proof of Concept - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L178 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L188-L190 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272  ## Recommended Mitigation Steps Remove redundant require statements  "}, {"title": "Cache array length in `for` loops", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  Caching the array length in a `for`-loop saves gas as the length does not need to be read on every iteration.  The following loops could be refactored: ``` ./Malt.sol:34:    for (uint256 i = 0; i < minters.length; i = i + 1) { ./Malt.sol:37:    for (uint256 i = 0; i < burners.length; i = i + 1) { ./TransferService.sol:87:    for (uint i = 0; i < verifierList.length - 1; i = i + 1) { ./Auction.sol:407:    for (uint i = 0; i < epochCommitments.length; ++i) { ./libraries/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./AuctionParticipant.sol:107:    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) { ./MiningService.sol:49:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:69:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:86:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:96:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:142:    for (uint i = 0; i < mines.length - 1; i = i + 1) { ./MiningService.sol:166:    for (uint i = 0; i < mines.length; i = i + 1) { ./DexHandlers/UniswapHandler.sol:317:    for (uint i = 0; i < buyers.length - 1; i = i + 1) { ```  ## Tools used  `grep -rn \".length\" .`  "}, {"title": "Incorrect error messages in `StabilizerNode.sol`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  The functions `setDefaultIncentive` and `setExpansionDamping` in `StabilizerNode.sol` require their arguments to be non-zero, i.e. to be positive, as their argument types are `uint`.  However, the error messages state that the arguments should not be non-negative.  See lines [406](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L406) and [417](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L417).  ## Recommended Mitigation Steps  Change the error messages to something like: \"Must be above 0\".  "}, {"title": "Don't try bonding zero liquidity in `RewardReinvestor`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  Function `RewardReinvestor::_bondAccount` tries to bond liquidity to an account, even though it is known whether the liquidity is zero.  ## Proof of Concept  The return value `liquidityCreated` in [line 105](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L105) can be zero. The following function call, `bondToAccount()`, then reverts with \"Cannot bond 0\".  ## Recommended Mitigation Steps  Gas could be saved if the function would revert earlier, i.e. in [line 106](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L106), if the `liquidityCreated` is zero.  "}, {"title": "No message in require statements.", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description There is multiple instances within the **Malt** protocol codebase that do not append messages to the require statements.  ## Impact add a custom message to the require statement to create a better sense of what's is the reason of failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L681 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L56 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L76 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L78 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L119  ## Tools Used manual code review.  ## Recommended Mitigation Steps append custom message to the require statements.  "}, {"title": "functions visibility on contract AuctionEscapeHatch", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **AuctionEscapeHatch** there is a function labeled as Public, However this function is not used within the contracts of **Malt** protocol.  ## Impact Improve coding style quality for developers and audit.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L94  ## Tools Used manual code review.  ## Recommended Mitigation Steps Evaluate functions labeled as public and set to external if needed just like the rest of functions inside this contract.  "}, {"title": " Cache Reference To State Variable \"currentAuctionID\" in _checkAuctionFinalization (Auction.sol)", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the references to \"currentAuctionID\" will decrease gas usage.   ## Proof of Concept  The state variable \"currentAuctionID\" is read 7 times in function \"_checkAuctionFinalization\" here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L746-L762  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache the variable:    ```   function _checkAuctionFinalization(bool isInternal) internal {      uint256 currentId = currentAuctionId;     if (isInternal && !isAuctionFinished(currentId)) {       // Auction is still in progress after internal auction purchasing.       _resetAuctionMaxCommitments();     }      if (isAuctionFinished(currentId)) {       if (auctionActive(currentId)) {         _endAuction(currentId);       }        if (!isAuctionFinalized(currentId)) {         _finalizeAuction(currentId);       }       currentAuctionId = currentId + 1;     }   } ```   "}, {"title": "AuctionParticipant.sol: `setReplenishingIndex` mistake could freeze unclaimed tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/88", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.  Right now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.  ## Proof of Concept See code for `setReplenishingIndex` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove the require statement on line 136, so that an admin can set the index to a smaller value.  "}, {"title": "AuctionParticipant.sol: `purchaseArbitrageTokens` should not push duplicate auctions", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.   Specifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).   It is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.  NOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.  ## Proof of Concept See code for `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40  Notice that `currentAuction` is always appended to `auctionIds`.   ## Tools Used Inspection  ## Recommended Mitigation Steps Add a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.  "}, {"title": "AuctionParticipant.sol: `replenishingIndex` incrementing should be improved", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the `claim` function is called to claim arb tokens from auctions the participant has entered. This is achieved through the global variable `replenishingIndex` which keeps track of which auction `claim` should be claiming from next. The logic for incrementing `replenishingIndex` is at the end of claim.   I agree with the current logic at the end of the function. The comment on lines 96/97 says \"Don't increment replenishingIndex if replenishingAuctionId == auctionId as claimable could be 0 due to the debt not being 100% replenished\". Notice the keyword \"could\" - it is possible that replenishingAuctionId == auctionId but we will never be able to claim any more arb tokens from this contract, and in this case `replenishingIndex` will NOT be incremented.  In this case, all subsequent calls to `claim` will simply do nothing. Line 77 will have `claimableTokens` be 0, and then the function will immediately return since it thinks it needs to wait longer to get more tokens, which will never happen. In this case, a manual intervention by an admin would be required to set `replenishingIndex', which is obviously annoying and should be avoided. Since `claim` is an external function, a malicious user/troll could intentionally call `claim` at the worst times to trigger this issue to happen. In this case, manual intervention would be required quite often.  The following logic should be added immediately after line 77 to account for this issue:  if (claimableTokens == 0 && replenishingId > auctionId) { // in this case, we will never receive any more tokens from this auction     replenishingIndex = replenishingIndex + 1;     auctionId = auctionIds[replenishingIndex]; }  // retry check for 0 claimable amount  ## Proof of Concept See the code for `claim` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L65  Other than manual intervention, the only place where `replenishingIndex` is set is at the end of `claim`.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the code described above.  "}, {"title": "Assignment Of Variables To Default ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Variables are being assigned their default value which is unnecessary. Removing the assignment will save gas when deploying and improve code clarity.  ## Proof of Concept  State: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L19  Local: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L351 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L626 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L92 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L108 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L124 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionPool.sol#L115 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20VestedMine.sol#L90 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L94 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L125 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L149-L150 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L112  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unneeded assignments.  Or if you feel it is important to show the default assignment will occur then replace the assignments with a comment.  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L716 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L68 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L18 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L73 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L98 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L438 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L72 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L81 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L114 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L200 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L251 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L328  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  "}, {"title": "Lack Of Return Value Check On the Dex Handler Malt Price Calculation", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen that malt price return value has not been checked on the function.  If oracle is returned price as a 0, fullReturn will be zero on the earlyExitReturn function.  ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L124\" 2. The return value maltMarketPrice() function has not been checked.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add return value check. The maltPrice should be more than zero for the calculation.  \"\"\" require(dexHandler.maltMarketPrice()>0, \"Price should be more than zero\"); \"\"\"  "}, {"title": "Missing zero-address checks on contract initialization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration, the contract is inoperable and deploy gas costs will be lost. If misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  The checks for zero addresses during contract construction and initialization are considered to be the best-practice.  Now basically all the contract do not check for correctness of constructor arguments:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L29  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardSystem/RewardOverflowPool.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol#L31  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L30  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L47  ...  ## Recommended Mitigation Steps  Add zero-address checks and key non-address variables checks in all contract constructors. Small increase of gas costs are far out weighted by wrong deploy costs savings and additional coverage against misconfiguration.   "}, {"title": "SwingTrader.costBasis function should have internal version that uses Malt balance from sellMalt", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  ERC20 balanceOf call is costly. Malt balance is read twice in sellMalt call, which isn't needed, so gas is overspent here.  ## Proof of Concept  Malt balanceOf(address(this)) is called twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L86 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L150  ## Recommended Mitigation Steps  It's recommended to make internal version of costBasis that takes Malt balance as an argument.  Now: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = costBasis(); ... function costBasis() public view returns (uint256 cost, uint256 decimals) { ... uint256 maltBalance = malt.balanceOf(address(this)); ... ``` To be: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = _costBasis(totalMaltBalance); ... function _costBasis(uint256 maltBalance) internal view returns (...) { ... function costBasis() public view returns (...) {  return _costBasis(malt.balanceOf(address(this))); } ```  "}, {"title": "SwingTrader: sellMalt and costBasis functions can be simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function call and calculations  ## Proof of Concept  First, save Malt and Collateral tokens decimals difference to storage variable. As neither Malt, nor Collateral token decimals change since initial setup, both can be saved and accessed as a storage variable instead of calling ```decimals()``` function and calculating the difference each time.  Second, now sellMalt calls costBasis, which already retrieved decimals and their difference, but sellMalt ignores those, retrieving them from functions/storage again. This could be unified as discussed below.  sellMalt: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L77 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L109  costBasis: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L146   ## Recommended Mitigation Steps   Save both decimals values to contract storage variables and use them instead of ```decimals()``` function. As the calculations use decimals difference it might be enough to save and use the difference only. In any case saving is preferred to calling as the latter spend gas on call and storage access anyway.   Also, return the difference along with decimals from costBasis and use them in sellMalt instead of obtaining afresh. I.e. first reuse ```costBasis``` returned ```decimals``` instead of ```collateralToken.decimals()```, then add ```maltDecimals``` and the difference, whether ```maltDecimals - decimals``` or ```decimals - maltDecimals``` to its output and use in rewards / soldBasis calculations. Function arguments and returned values are memory and are cheaper than another storage access.  Now: ``` (uint256 basis,) = costBasis(); ... uint256 maltDecimals = malt.decimals(); uint256 decimals = collateralToken.decimals(); ... uint256 diff = maltDecimals - decimals;  ``` To be: ``` (uint256 basis, uint256 decimals, uint256 maltDecimals, uint256 diff) = costBasis(); ... ```  "}, {"title": "Unused event or missed emit on SetAnnualYield()", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The event **SetAnnualYield** on Contract **StabilizerNode** is defined but never emitted inside the Contract.  ## Impact Unused events in the codebase can be confusing, each declared event should have a corresponding emit statement.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps it's better to remove unused events from the code to improve coding quality, Also monitoring will be effected since no emit statements is there.  "}, {"title": "Auction.userClaimableArbTokens amountOut calculations can be simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```amountOut``` is calculated in 3 steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L302-305  ## Recommended Mitigation Steps  Now: ``` uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); ```  To be (```amountTokens``` and ```redeemedTokens``` aren't used elsewhere): ```  /* * uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); * uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); * uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); */ uint256 redeemed = commitment.redeemed.mul(auction.pegPrice); uint256 amountOut = commitment.commitment.mul(claimablePerc).sub(redeemed).div(price); ```   "}, {"title": "Multiple Zero address transfer functions on contract Permissions", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **Permissions.sol** there is multiple functions to withdraws funds, these functions currently do not check for zero value address before doing the transaction.  ## Impact Loss of funds, ETHs and ERC20.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L88 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L97 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104  ## Tools Used manual code review.  ## Recommended Mitigation Steps use require() statement to validate address address(0) before sending the funds.  "}, {"title": "getAuctionCore function returns wrong values out of order", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/63", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In the AuctionEscapeHatch.sol file both earlyExitReturn() and _calculateMaltRequiredForExit call the getAuctionCore() function which has 10 possible return values most of which are not used.  It gets the wrong value back for the \"active\"  variable since it's the 10th argument but both functions have it as the 9th return value where \"preAuctionReserveRatio\" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.    ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527   ## Tools Used Manual code review   ## Recommended Mitigation Steps In AuctionEscapeHatch.sol change the following in _calculateMaltRequiredForExit() and earlyExitReturn() functions:  From:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      bool active     ) = auction.getAuctionCore(_auctionId);  To:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      ,      bool active     ) = auction.getAuctionCore(_auctionId);   "}, {"title": "SafeMath library is not always used in the contracts", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  SafeMath library functions are not always used in arithmetic operations in the contracts, which could potentially cause integer underflow/overflows. Although in the reference lines of code, there are upper limits on the variables to ensure an integer underflow/overflow could not happen, using SafeMath is always a best practice, which prevents underflow/overflows completely (even if there were no assumptions on the variables) and increases code consistency as well.   ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L795  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L821  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L64  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L76  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L188  ```  2. SafeMath functions are not used in the every functionality.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.   "}, {"title": " Missing events for admin only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The admin only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  Missing events  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/SwingTrader.sol#L169  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1000  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1008  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L992  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L984  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L976  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L968  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L960  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L937  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L930  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L923  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L916  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L132  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L226  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L234  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L218   See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  "}, {"title": "Auction.userClaimableArbTokens claimablePerc calculations can be simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```claimablePerc``` is calculated in two steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L294  ## Recommended Mitigation Steps  Now: ``` uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice); uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens); ```  To be (```totalTokens``` isn't used elsewhere): ``` uint256 claimablePerc = auction.claimableTokens.mul(auction.finalPrice).div(auction.commitments); ```  "}, {"title": "Auction.userClaimableArbTokens nonzero auction.finalPrice check is redundant", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  As there is a check in the beginning of the function that includes the ```auction.finalPrice == 0``` condition: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L285  ## Recommended Mitigation Steps  The same condition down the line is never true and its check is redundant: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L298  "}, {"title": "initialized storage variables are set again in the initializer function ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  sabtikw   # Vulnerability details  ## Impact  storage variables are initialized in the contract and overwritten in the initializer function.   ## Proof of Concept Auction.sol L#89 L#164 auctionLength AuctionBurnReserveSkew.sol L#25 auctionAverageLookback MaltDataLab.sol L#69 priceTarget  ## Tools Used  manual review   ## Recommended Mitigation Steps  remove initialization outside of initializer function  "}, {"title": "The Contract Should safeApprove(0) first", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L59  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L252  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/RewardReinvestor.sol#L107 ``` 2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  "}, {"title": "Storage Optimization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Cheaper storage.  ## Proof of Concept  The struct AuctionData file Auction.sol is optimizable. It looks like this:  ``` struct AuctionData {   // The full amount of commitments required to return to peg   uint256 fullRequirement;   // total maximum desired commitments to this auction   uint256 maxCommitments;   // Quantity of sale currency committed to this auction   uint256 commitments;   // Malt purchased and burned using current commitments   uint256 maltPurchased;   // Desired starting price for the auction   uint256 startingPrice;   // Desired lowest price for the arbitrage token   uint256 endingPrice;   // Price of arbitrage tokens at conclusion of auction. This is either   // when the duration elapses or the maxCommitments is reached   uint256 finalPrice;   // The peg price for the liquidity pool   uint256 pegPrice;   // Time when auction started   uint256 startingTime;   uint256 endingTime;   // Is the auction currently accepting commitments?   bool active;   // The reserve ratio at the start of the auction   uint256 preAuctionReserveRatio;   // Has this auction been finalized? Meaning any additional stabilizing   // has been done   bool finalized;   // The amount of arb tokens that have been executed and are now claimable   uint256 claimableTokens;   // The finally calculated realBurnBudget   uint256 finalBurnBudget;   // The amount of Malt purchased with realBurnBudget   uint256 finalPurchased;   // A map of all commitments to this auction by specific accounts   mapping(address => AccountCommitment) accountCommitments; } ``` But `active` and `finalized`, the unique boolean values, should be together, otherwise they will spend two slots instead of one. ```   uint256 preAuctionReserveRatio;   bool active;   bool finalized; ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  "}, {"title": "Index address of events for better filtering", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Use `indexed` on address to filter through logs better https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L105 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L112   "}, {"title": "Use bps uniformly", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Some variables are in form of bps https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L90  while some are not https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L91 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L92  As a good programming practice, should use bps everywhere if you accepting it as a unit    "}, {"title": "SafeMath Not Used Nearly At All In MovingAverage.sol", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In MovingAverage.sol the safeMath.sol library is imported but I counted at least 25 places in the file where it should be used (Nearly the entire file).  This can result in values wrapping around which has caused devastating effects on many protocols in the past.  These values directly effect the exchangeRate variable given in the stabilize() function in StabilizerNode.sol so they must be treated with care.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MovingAverage.sol#L3  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  ## Tools Used Manual code review   ## Recommended Mitigation Steps The MovingAverage.sol file should be completely reviewed making use of safeMath through out the entire file.  "}, {"title": "Deprecated Function Usage", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  \"https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L153\"  \"https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L178\"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.  "}, {"title": "Should include non-existing contract check", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/9", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact The executeTransaction() function in Timelock.sol does not include a check if the contract being called actually exists. The extcodesize is not used when using .call on addresses directly as per the solidity docs.  This is important because the EVM allows calls to a non-existing contract to always succeed.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Timelock.sol#L191  solidity docs: https://docs.soliditylang.org/en/v0.8.10/units-and-global-variables.html#address-related  \"Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity includes an extra check using the extcodesize opcode when performing external calls. This ensures that the contract that is about to be called either actually exists (it contains code) or an exception is raised. The low-level calls which operate on addresses rather than contract instances (i.e. .call(), .delegatecall(), .staticcall(), .send() and .transfer()) do not include this check, which makes them cheaper in terms of gas but also less safe.\"   ## Tools Used Manual code review  ## Recommended Mitigation Steps A check should be included to make sure the contract being called actually exists to avoid making possible errors in the executeTransaction() function  "}, {"title": "Unnecessary event fields", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Greater costs of epoch advancement  ## Proof of Concept  The `Advance` event emits the block number and timestamp in its data  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L24  These fields are attached to events by default so it's unnecessary to manually emit them (and pay the associated gas costs)  ## Recommended Mitigation Steps  Remove `block` and `timestamp` fields from `Advance` event  "}, {"title": "Reducing the epoch length results in leaking value from advancement incentives", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Unintended advancement incentives being paid out to third party  ## Proof of Concept  `DAO.sol` incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the `advance` function. This is limited by checking that the start timestamp of the next epoch has passed.   https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  This start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67  This method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114  In the case where the epoch length is reduced, `DAO` will think that the epoch number can be incremented potentially many times. Provided the `advanceIncentive` is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.  ## Recommended Mitigation Steps  Rather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.  "}, {"title": "Change state mutability in NoYield.sol", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/165", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact The `liquidityToken` function in `NoYield.sol` can have its state mutability changed to `pure` instead of `view`. This has no other effect than suppressing compiler warnings, but may help the compiler optimize this function in the future  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Change state mutability of `liquidityToken` to `pure`  "}, {"title": "Not needed zero address check", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x0x0x   # Vulnerability details  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150)  In `Verfication.sol#unlinkAddress`, there is a not needed zero address check.  ```  require(_linkedTo != address(0), 'V:UA-Address not linked'); require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');  ```  Since, `msg.sender != address(0)`, there is no need for a zero address check here.  "}, {"title": "Loops can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept  Example:  ```  for (uint i = 0; i < arr.length; i++) {  //Operations not effecting the length of the array.  }  ```  Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Furthermore, there is no need to assign the initial value 0. This costs extra gas.  Recommended implementation:  ```  uint length = arr.length;  for (uint i; i < length; ++i) {  //Operations not effecting the length of the array.  }  ```  By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences  ```  ./CreditLine/CreditLine.sol:484:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:662:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:738:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:892:        for (uint256 index = 0; index < _strategyList.length; index++) { ./CreditLine/CreditLine.sol:959:        for (uint256 index = 0; index < _strategyList.length; index++) { ./SavingsAccount/SavingsAccount.sol:289:        for (uint256 i = 0; i < _strategyList.length; i++) { ./SavingsAccount/SavingsAccount.sol:467:        for (uint256 i = 0; i < _strategyList.length; i++) {  ```  "}, {"title": "In `CreditLine#_borrowTokensToLiquidate`, oracle is used wrong way", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/155", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x0x0x   # Vulnerability details  Current implementation to get the price is as follows:  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050)  But it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.  ## Mitigation step  Replace it with  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`  "}, {"title": "denial of service", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/154", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  certora   # Vulnerability details   https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645 if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.    ## Recommended Mitigation Steps the bug is in  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccountUtil.sol It is wrong to use msg.value in transferTokens because it'll be the msg.value of the calling function. therefore every transfer of ether using this function is wrong and dangerous, the solution is to remove all msg.value from this function and just transfer _amount regularly.  "}, {"title": "Gas: Use `else if` in `withdrawLiquidity`", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The `if` conditions in `Pool.withdrawLiquidity` are distinct conditions on the pool status. Therefore, `else if` is semantically equivalent but more gas efficient.  ```solidity if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {     uint256 _totalAsset;     if (poolConstants.borrowAsset != address(0)) {         _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));     } else {         _totalAsset = address(this).balance;     }     //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()     _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply()); } // @audit gas: use else if, status fields are distinct, only one of the branches is (if ever) executed anyway if (_loanStatus == LoanStatus.CANCELLED) {     _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply())); }  if (_loanStatus == LoanStatus.CLOSED) {     //transfer repayment     _withdrawRepayment(msg.sender); } ```   "}, {"title": "Self-transfer leads to wrong withdrawable repayments", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/146", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  When transferring pool tokens to oneself the `Pool._beforeTokenTransfer` overwrites the `effectiveInterestWithdrawn` of the user with a higher amount than expected. It uses the previous balance + the transfer amount instead of just the previous balance:  ```solidity // @audit if from == to: overwrites with last _to statement => bug lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply); lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply); ```  # Impact The bug is not in the user's favor and would lead to them being able to withdraw fewer repayments in the future.  #### POC - user calls `Pool.transfer(from=user, to=user, amount=pool.balanceOf(user))` - pending repayments are withdrawn first by the `_withdrawRepayment` calls. (second one does not lead to a second withdrawal as the `effectiveInterestWithdrawn` is already increased in the first call) - `lenders[user].effectiveInterestWithdrawn` is then set using `2 * userBalance`. - This has the effect that the user appears to have claimed twice as many repayments as their balance indicates already and they won't be able to claim anymore for a while.  ## Recommended Mitigation Steps We still recommend fixing this bug, for example, by disallowing self-transfers.   "}, {"title": "Extension voting threshold check needs to rerun on each transfer", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension. This leads to issues where an extension should be granted but is not:  #### POC - `to` address has 100 tokens and votes for the extension - `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to` - `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again. - But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.  ## Impact Extensions that should be granted after a token transfer are not granted.  ## Recommended Mitigation Steps Rerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.   "}, {"title": "`unlockShares` wrong comment", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The strategy contracts define an `unlockShares` function that must accept an `asset` parameter as the **share** token (yield token, aToken, cToken, etc.), otherwise, the code does not work. However, all comments say that `asset` is the address of the **underlying token**.  ```solidity /**   * @notice Used to unlock shares   * @param asset the address of underlying token   * @param amount the amount of shares to unlock   * @return received amount of shares received   **/ function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {     if (amount == 0) {         return 0;     } } ```  ## Recommended Mitigation Steps Fix the comments for all `unlockShares` by saying `asset` is the share token, not the underlying token.   "}, {"title": "Yearn token <> shares conversion decimal issue", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/134", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:  ``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {     if (shares == 0) return 0;     // @audit should divided by vaultDecimals      amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18); } ```  But Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`. The vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)  ## Impact The token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals. Too much or too little might be paid out leading to a loss for either the protocol or user.  ## Recommended Mitigation Steps Divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`. Apply a similar fix in `getSharesForTokens`.  "}, {"title": "Wrong returns of `SavingsAccountUtil.depositFromSavingsAccount()` can cause fund loss", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/132", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267  ```solidity /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } } ```  However, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26  ```solidity     function depositFromSavingsAccount(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy,         bool _withdrawShares,         bool _toSavingsAccount     ) internal returns (uint256) {         if (_toSavingsAccount) {             return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);         } else {             return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);         }     } ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80  ```solidity     function savingsAccountTransfer(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy     ) internal returns (uint256) {         if (_from == address(this)) {             _savingsAccount.transfer(_amount, _token, _strategy, _to);         } else {             _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);         }         return _amount;     } ```  As a result, the recorded `_sharesReceived` can be wrong.   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223  ```solidity     function _depositCollateral(         address _depositor,         uint256 _amount,         bool _transferFromSavingsAccount     ) internal nonReentrant {         uint256 _sharesReceived = _deposit(             _transferFromSavingsAccount,             true,             poolConstants.collateralAsset,             _amount,             poolConstants.poolSavingsStrategy,             _depositor,             address(this)         );         poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);         emit CollateralAdded(_depositor, _amount, _sharesReceived);     } ```  ### PoC  Given:  - the price per share of yearn USDC vault is `1.2`  1. Alice deposited `12,000 USDC` to `yearn` strategy, received `10,000` share tokens; 2. Alice created a pool, and added all the `12,000 USDC` from the saving account as collateral; The recorded `CollateralAdded` got the wrong number: `12000` which should be `10000`; 3. Alice failed to borrow money with the pool and tries to `cancelPool()`, it fails as the recorded collateral `shares` are more than the actual collateral.  As a result, Alice has lost all the `12,000 USDC`.  If Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.  ### Recommendation  Change to:  ```solidity function savingsAccountTransfer(     ISavingsAccount _savingsAccount,     address _from,     address _to,     uint256 _amount,     address _token,     address _strategy ) internal returns (uint256) {     if (_from == address(this)) {         return _savingsAccount.transfer(_amount, _token, _strategy, _to);     } else {         return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);     } } ```  "}, {"title": "Gas Optimization: Struct layout", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gzeon   # Vulnerability details  Rewrite the PoolConstants struct as follow can save some gas ```     struct PoolConstants {         uint256 borrowAmountRequested;         uint256 loanStartTime;         uint256 loanWithdrawalDeadline;         uint256 idealCollateralRatio;         uint256 borrowRate;         uint256 noOfRepaymentIntervals;         uint256 repaymentInterval;         address borrower;         address borrowAsset;         address collateralAsset;         address poolSavingsStrategy; // invest contract         address lenderVerifier;     }      ``` https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L46  "}, {"title": "`Pool.sol#withdrawBorrowedAmount()` Validation of pool status can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check if `_poolStatus` and `block.timestamp` earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L310-L348  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         uint256 _tokensLent = totalSupply();         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  ### Recommendation  Change to:  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         uint256 _tokensLent = totalSupply();         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  "}, {"title": "`10**30` can be changed to `1e30` and save some gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L379-L383  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  Can be changed to:  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 1e30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  and save some gas from unnecessary arithmetic operation in `10**30`.  "}, {"title": "Remove unused local variables", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  The local variables `_receivedToken` in the functions `SavingsAccount.withdraw` and `SavingsAccount.withdrawFrom` are unused.  Removing them would save gas.  ## Tools used  slither  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `wethGateway` in `AaveYield#_withdrawETH()`      https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307-L312  "}, {"title": "Wrong implementation of `NoYield.sol#emergencyWithdraw()`", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/115", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83  ```solidity=78{81} function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  `received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.  As a result, the `emergencyWithdraw()` does not work, in essence.  ### Recommendation  Change to:  ```solidity=78 function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     received = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received); } ```  "}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L691-L727  ```solidity=691{693-694} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  `_borrowableAmount` is unnecessary. The code above can be changed to:  ```solidity=691{693} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(_amount <= calculateBorrowableAmount(_id), \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L391-L399  ```solidity=391 function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; } ```  `_interest` is unnecessary.  "}, {"title": "`Pool.sol` should use the Upgradeable variant of OpenZeppelin Contracts", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  Given that `Pool` is deployed as a proxied contract, it should use the Upgradeable variant of OpenZeppelin Contracts.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L320-L355  ```solidity=320{348} function _createPool(     uint256 _poolSize,     uint256 _borrowRate,     address _borrowToken,     address _collateralToken,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     bytes32 _salt,     address _lenderVerifier ) internal {     bytes memory data = _encodePoolInitCall(         _poolSize,         _borrowRate,         _borrowToken,         _collateralToken,         _idealCollateralRatio,         _repaymentInterval,         _noOfRepaymentIntervals,         _poolSavingsStrategy,         _collateralAmount,         _transferFromSavingsAccount,         _lenderVerifier     );     bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));     bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));     uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;      address pool = _deploy(amount, salt, bytecode);      poolRegistry[pool] = true;     emit PoolCreated(pool, msg.sender); } ```  Otherwise, the constructor functions of `Pool`'s parent contracts which may change storage at deploy time, won't work for deployed instances.  The effect may be different for different OpenZeppelin libraries.  Take `ReentrancyGuard` for example, the code inside `ReentrancyGuard.sol#constructor` won't work, should use `ReentrancyGuardUpgradeable.sol` instead:  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L6-L8  ```solidity=6{6} import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L24-L24  ```solidity=24 contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard { ```  ### Recommendation  Change to:  ```solidity=6{6} import \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\"; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  ```solidity=24 contract Pool is Initializable, ReentrancyGuardUpgradeable, ERC20PausableUpgradeable, IPool { ```  ```solidity=133{164} function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ReentrancyGuard_init();     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} } ```  "}, {"title": "Best Practice: Contract file name should follow coding conventions", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  Having a consistent naming style in the project leads to fewer errors.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Proxy.sol#L6-L6  ```solidity=6 contract SublimeProxy is TransparentUpgradeableProxy { ```  The filename `Proxy.sol` should be `SublimeProxy.sol`.  "}, {"title": "Missing timelock for critical contract setters of privileged roles (Price Oracles)", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Setter functions for critical contract parameters accessible only by privileged roles e.g. admin should consider adding timelocks (along with emitted events) so that users and other privileged roles can detect upcoming changes and have the time to react to them.  Changes to whitelists, oracle addresses and migrator address may have a financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when such changes are made effective immediately.  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)    ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L189  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L203  2. The functions are responsible for the price oracles. Therefore, If the price oracle is set to wrong. All price feeds will be affected by this.   ## Tools Used  None  ## Recommended Mitigation Steps  Consider adding timelocks to such contracts with critical setter functions.    "}, {"title": "Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   \"\"\" https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/YearnYield.sol#L42  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/CompoundYield.sol#L43  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/AaveYield.sol#L71  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/NoYield.sol#L31  \"\"\"   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  "}, {"title": "Unnecessary receive()", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact There doesn't seem to be a use case for the existence of the `receive()` function. In fact, I will recommend removing it as it will prevent accidental native token transfers to the contract.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  ## Tools Used VSC ## Recommended Mitigation Steps https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  "}, {"title": "Missing approve(0)", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  There are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement [at line 199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).  ## Proof of Concept  - [CreditLine/CreditLine.sol:647](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647) - [CreditLine/CreditLine.sol:779](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779) - [yield/AaveYield.sol:324](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)  Note: the usage of `approve()` in yield/CompoundYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of `approve()` in [yield/AaveYield.sol:307](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.  "}, {"title": "Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/96", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.   Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.  ## Proof of Concept The current implementation of liquidate is here: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.  Notice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code: ``` ...  if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {   uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);   if (_borrowAsset == address(0)) {    uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');    if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');    }   } else {   IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);   }  }    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);   emit  CreditLineLiquidated(_id, msg.sender); } ```  So, if `autoLiquidation` is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if `autoLiquidation` is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.  For a further proof of concept, consider the test file here: https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed from `let  _autoLiquidation: boolean  =  true;` to `let  _autoLiquidation: boolean  =  false;`, all the test cases will still pass. This confirms the issue, as the final test case \"Liquidate credit line\" has the `admin` as the liquidator, which should not work in non-autoLiquidations since they are not the lender.   ## Tools Used Inspection and confirmed with Hardhat.  ## Recommended Mitigation Steps Add the following require statement somewhere in the `liquidate` function:  ``` require(  creditLineConstants[_id].autoLiquidation ||   msg.sender == creditLineConstants[_id].lender,  \"not autoLiquidation and not lender\"); ```  "}, {"title": "Two Steps Verification before Transferring Ownership", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  robee   # Vulnerability details   The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ILendingPoolAddressesProvider.sol         IUniswapV3Factory.sol         Controller.sol         Strategy.sol         yVault.sol  "}, {"title": "Redundant use safeMath", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Using the safeMath to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.   ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L461  ``` if (_maxPossible > _currentDebt) {             return _maxPossible.sub(_currentDebt); ```  ## Tools Used  ## Recommended Mitigation Steps Consider using: ``` if (_maxPossible > _currentDebt) {             return _maxPossible - _currentDebt; ```  "}, {"title": "CreditLine.liquidate doesn't transfer borrowed ETH to a lender", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.  ## Proof of Concept  ETH sent to CreditLine.liquidate by an external liquidator when `autoLiquidation` is enabled remain with the contract and aren't transferred to the lender: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015  ## Recommended Mitigation Steps  Add transfer to a lender for ETH case:  Now: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');   if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');   } } ```  To be: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');      (bool success, ) = _lender.call{value: _borrowTokens}('');   require(success, 'liquidate: Transfer failed');      if (_returnETH != 0) {     (success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'liquidate: Return transfer failed');   } } ```  "}, {"title": "calculateInterest() comments missing input parameter", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The public `calculateInterest` function in CreditLine.sol is missing a @param comment for the `_timeElapsed` parameter. This parameter is obviously important and the units should be clearly stated as seconds.  ## Proof of Concept  The `calculateInterest` function in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L385-L395   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the following line to the `calculateInterest` function comments in CreditLine.sol: `* @param _timeElapsed Seconds elapsed since lastPrincipalUpdateTime`  "}, {"title": "No validation of protocol fee fraction", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `updateProtocolFeeFraction` function in CreditLine.sol does not validate the value submitted. Fee fractions of 0%, 100%, or 200% are equally valid. A maximum fee value check is recommended and a similar check is used in `_updateLiquidatorRewardFraction` in CreditLine.sol to set a maximum liquidator fraction. However, if the assumption is that the owner is trusted and does not make mistakes, this may not be considered a problem.   ## Proof of Concept  The `updateProtocolFeeFraction` function calls `_updateProtocolFeeFraction` in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L335-L338   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Apply a maximum fee hard cap with a require statement to make sure the fee does not exceed a certain limit, whether by admin error or theoretical malicious overtake of the contract  "}, {"title": "Magic number 30 could be a constant", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  There are many instances of the value 30, usually used for exponents of base 10. Currently this integer value is used directly without a clear indication that this value relates to the decimals value, which could lead to one of these values being modified but not the other (perhaps by a typo), which is the basis for many past hacks. Coding best practices suggests using a constant integer to store this value in a way that clearly explains the purpose of this value to prevent confusion.  ## Proof of Concept The magic number 30 is found in dozens of places, including:  Pool/Repayments.sol https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L164-L165  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L190  PriceOracle.sol file https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L130-L131  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L88-L93   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Replace the magic number 30 with a variable explaining the meaning of this value, such as: `uint8 private constant DECIMALS_EXPONENT = 30;`  "}, {"title": "`idealCollateralRatio` is confusingly named", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Weird naming ## Proof of Concept  Credit lines have an \"ideal collateral ratio\" which acts very much like a minimum collateral ratio, i.e. if you fall below it you can be liquidated.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1002  \"Ideal\" to me implies that you'll be hovering around that value sometimes drifting above and sometimes below but the systems drives the value back to the ideal so this is quite confusingly named imo.  ## Recommended Mitigation Steps  Change `idealCollateralRatio` to `minCollateralRatio`  "}, {"title": "Credit Line acceptance logic can be simplified to avoid SLOAD in some cases", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L600-L604  ``` (msg.sender == creditLineConstants[_id].borrower && _requestByLender) || (msg.sender == creditLineConstants[_id].lender && !_requestByLender) ```  is equivalent to   ``` _requestByLender ? (msg.sender == creditLineConstants[_id].borrower) : (msg.sender == creditLineConstants[_id].lender) ``` or ``` msg.sender == (_requestByLender ? creditLineConstants[_id].borrower : creditLineConstants[_id].lender) ```  Which avoid loading the borrower address in the case where the borrower made the request.  ## Recommended Mitigation Steps  Use simplified logic  "}, {"title": "Argument order for SavingsAccount approval functions is odd", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Possible confusion  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L326-L368  Compare this to the standard ERC20 versions.  ``` approve(address spender, uint256 amount)  vs   approve(uint256 amount, address token, address to)  ```  Having the amount at the beginning is very odd imo and I'd expect it at the end.  ## Recommended Mitigation Steps  Change `approve(uint256 amount, address token, address to)` to `approve(address token, address to, uint256 amount)` and similar for other functions.  I'd also change `to` to the standard `spender` but this is nbd.     "}, {"title": "LinkedAddress struct can be packed to save an SSTORE", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs on linking/unlinking addresses  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L10-L13  The activation timestamp can be restricted to a `uint64` variable so that it shares a slot with the `masterAddress`. This will save an SSTORE and a substantial amount of gas.  ## Recommended Mitigation Steps  As above.  "}, {"title": "`poolSizeLimit` does not account for differing unit values between borrow assets", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Inability to set a sensible range which covers all borrow assets without being overly wide.  ## Proof of Concept  `PoolFactory` has a set requirement that created pool must ask to borrow an amount of assets which are within a certain range as encoded in the `poolSizeLimit`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L286  This doesn't take into account the relative values of each borrow asset so it's hard to choose a one-size-fits-all value for these limits (A 100 WBTC loan could be sensible but a 100 USDC loan will be dwarfs by the gas costs to deploy the pool.)  ## Recommended Mitigation Steps  Place limits on the USD value of the borrowed amount as reported by the factory's price oracle.  "}, {"title": "Typo in liquidateCancelPenalty natspec", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  Typo in \"cancelled\"  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L545  "}, {"title": "Check on `poolConstants.loanWithdrawalDeadline` for liquidation is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L322-L340  In `Pool.withdrawBorrowedAmount` we set the loan to active and delete the withdrawal deadline (see link).  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L802  When checking whether we can liquidate the pool we check that the loan is active and that `block.timestamp > poolConstants.loanWithdrawalDeadline`. This second condition always resolves true as `poolConstants.loanWithdrawalDeadline = 0` after deletion. We can then save an SLOAD by skipping this second check.  ## Recommended Mitigation Steps  As above.  "}, {"title": "Overflow in _repay()", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function repayPrincipal() calls _repay() with MAX_INT as parameter. In _repay() this value (_amount) is multiplied by 10**30. As _amount already has the maximum value of an int256 it will overflow. Because solidity 7.6.0 is used and mul() isn't used (!) this actually works. The resulting value is still large and thus the function repayPrincipal() does still work.  It is not recommended to rely on overflow working and when moving to solidity 0.8.x this will no longer work.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L23  ```JS     uint256 constant MAX_INT = 2**256 - 1; ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L377-L425  ```JS      function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {         ....         uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);         ...   function _repay( ... uint256 _amount,..) internal returns (uint256) { ..         _amount = _amount * 10**30;     ```  ## Tools Used  ## Recommended Mitigation Steps Use safemath in _replay() and change MAX_INT to something like: ```JS uint256 constant LARGE_INT = 2**128 ``` Note: 10**30 ~ 2**100  "}, {"title": "transferTokens should use _from instead of msg.sender", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function transferTokens of SavingsAccountUtil.sol sends the excess ETH to msg.sender, while a _from parameter is also present in the function. It seems more logical to send it to _from, like the similar function _transferTokens of Repayments.sol  Luckily in the current code the _from is always msg.sender so it doesn't pose a direct risk. However if the code is reused or forked it might lead to unexpected issues.  Note: transferTokens and _transferTokens are very similar so they could be integrated; they have to be checked carefully when doing this  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L98-L127 ```JS function transferTokens(.... ,   address _from,   address _to ) {      ...        (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}(''); // uses msg.sender instead of _from // also uses - instead of sub  ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L457-L473 ```JS     function _transferTokens(  address _from,  address _to,.... ) {        (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}(''); ```  ## Tools Used  ## Recommended Mitigation Steps In function transferTokens() change msg.sender to _from   "}, {"title": "Unlinked address can link immediately again", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission. The address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set. Assuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.  Note: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154  ```JS     function unlinkAddress(address _linkedAddress) external {         address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;         require(_linkedTo != address(0), 'V:UA-Address not linked');         require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');         delete linkedAddresses[_linkedAddress];         ... }     function linkAddress(address _masterAddress) external {         require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)         require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)         _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset     }  function cancelAddressLinkingRequest(address _linkedAddress) external {         ...          delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset ```  ## Tools Used  ## Recommended Mitigation Steps Add something like to following at the end of linkAddress: ```JS  delete pendingLinkAddresses[msg.sender][_masterAddress];  ```  "}, {"title": "Unable To Call `emergencyWithdraw` ETH in `NoYield` Contract", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/52", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `emergencyWithdraw` function is implemented in all yield sources to allow the `onlyOwner` role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on `_asset` which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the `NoYield` contract in the event of an emergency.  ## Proof of Concept  Consider the case where `_asset == address(0)`. An external call is made to check the contract's token balance for the target `_asset`. However, this call will revert as `_asset` is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency.  ``` function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  Affected function as per below: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.  "}, {"title": "Reduce length of require error messages to save in deployment costs", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0xngndev   # Vulnerability details  ### Impact  Some of your contracts are quite large byte-wise and require the optimizer with low runs to not reach the code size limit of 24576 bytes. The code size of these contracts can be drastically reduced by shortening the length of your error messages, reducing their deployment cost.  The best example of contracts having unnecessary long erorr messages are `CreditLine.sol` and `PoolFactory.sol`. When it comes to factories, whose primary goal is to deploy contracts, reducing the cost  of doing so is something to keep in mind.  ### Mitigation Steps  Reduce the length of your error strings. Error messages like:  `'PoolFactory::createPool - Repayment interval not within limits'`  Could be reduced to:  `Interval out of limits`  You could save even more by doing something similar to what Uniswap does. They have very short error messages like: `ST`, and they expand on what they mean in their documentation.  Another approach is to use revert with CustomErrors, something like this:  `if (....) revert CustomError()`  Following the example I used above, you could have a custom error message that says:  `OutOfBounds()` and expand what it means in the natspec.  Custom error messages are cheaper than strings error messages. Here's a snippet of Solidity's documentation about this:  > Using a\u00a0**custom**\u00a0**error**\u00a0instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs. >  "}, {"title": "AaveYield: Misspelled external function name making functions fail", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  In `AaveYield.sol` the functions:  - `liquidityToken` - `_withdrawETH` - `_depositETH`  Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`  This function does not exist in the `wethGateway` contract, causing these function to fail with the error `\"Fallback not allowed\"`.  The function they should be calling is `getWethAddress()` without the \"A\".  Small yet dangerous typo.  ### Mitigation Steps  Simply modify:   `IWETHGateway(wethGateway).getAWETHAddress()`  to:  `IWETHGateway(wethGateway).getWETHAddress()`  In the functions mentioned above.  "}, {"title": "Gas: Inlining logic that's used only once in the contract", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0xngndev   # Vulnerability details  ### Impact  Reduce code size and gas expenditure by inlining internal functions that are only used once throughout your contract.  In some of your contracts, like `AaveYield.sol`, you have an `initialize` function that calls the internal functions `updateSavingsAccount` and `updateAaveAddresses`. These two functions are only called in the `initialize` function, so you can save some gas and code size by simply inlining their logic inside `initialize`. **The tradeoff, of course, is that you lose readability, and because `initialize` will only be called once, perhaps it's not worth the tradeoff.**  To test the difference in code size and gas expenditure I wrote a example contract replicating the behaviour to see how much cheaper inlining the logic was.  **The results:**  Inlining the logic:  - Gas spent: 45155 - Code size: 453 bytes  Separating into internal functions:  - Gas spent: 45189 - Code size: 467 bytes  ### Proof of Concept  Contracts I used to test the gas expenditure and code size differences:  - InliningLogic  ```bash //SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.10;  contract InliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - InliningLogic.t \u2014> DappTools test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import \"ds-test/test.sol\"; import \"../InliningLogic.sol\";  contract InliningLogicTest is DSTest {   InliningLogic inliningLogicContract;    function setUp() public {     inliningLogicContract = new InliningLogic();   }    function testInliningLogic() public logs_gas {     inliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  - NotInliningLogic  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract NotInliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     _assignAddresses(_someRandomAddress, _anotherRandomAddress);   }    function _assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) internal {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - NotInliningLogic.t \u2014> test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import \"ds-test/test.sol\"; import \"../NotInliningLogic.sol\";  contract NotInliningLogicTest is DSTest {   NotInliningLogic notInliningLogicContract;    function setUp() public {     notInliningLogicContract = new NotInliningLogic();   }    function testNotInliningLogic() public logs_gas {     notInliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  ### Tools  DappTools  "}, {"title": "Unnecessary uint zero initialization", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  uint256 variable are initialized to a default value of zero per Solidity docs: https://docs.soliditylang.org/en/latest/control-structures.html#default-value   Setting a variable to the default value is unnecessary. Removing lines of code where variables are initialized to zero can save gas. Here are a few articles describing this gas optimization: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#53bd  https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde#4135   ## Proof of Concept  - contracts/Pool/Pool.sol:358 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L358  - contracts/CreditLine/CreditLine.sol:812 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L812   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Instead of initializing a variable to zero, such as `uint256 abc = 0;`, the line can be shortened to `uint256 abc;` as Solidity automatically initializes uint variables to zero.  "}, {"title": "Gas optimization", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method initializeRepayment inside the contract Repayments has multipe storage access, it's better to get a pointer of the `RepaymentConstants` with the `storage` keyword in order to avoid seeking and storage access.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use storage keyword in order to save gas  "}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: CreditLine.sol, _index, 484         change to prefix increment and unchecked: CreditLine.sol, _index, 661         change to prefix increment and unchecked: CreditLine.sol, _index, 735         change to prefix increment and unchecked: CreditLine.sol, index, 888         change to prefix increment and unchecked: CreditLine.sol, index, 955         change to prefix increment and unchecked: SavingsAccount.sol, i, 286         change to prefix increment and unchecked: SavingsAccount.sol, i, 464    "}, {"title": "Gas saving by struct reorganization", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept  It's possible to optimize the struct CreditLineConstants from CreditLine contract, the last 4 fields spend 3 storage slots, moving the boolean values between the address values, it will spend only two slots as follows:  ```struct CreditLineConstants {         address lender;         address borrower;         uint256 borrowLimit;         uint256 idealCollateralRatio;         uint256 borrowRate;         address borrowAsset;         bool autoLiquidation;         address collateralAsset;         bool requestByLender;     }```.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Reorder the structs fields  "}, {"title": "Gas saving using delete", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the method updateStrategy and removeStrategy of StrategyRegistry contract, when the contract want to remove a strategy, the old one, it's set to false, instead of use delete, this will remaing the storage space and it has expensive than use delete.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use delete instead of set to `false`  "}, {"title": "Gas saving removing safe math", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method addStrategy inside StrategyRegistry do a require with safe math: `require(strategies.length.add(1) <= maxStrategies, \"StrategyRegistry::addStrategy - Can't add more strategies\");` is not possible to has a map that could lead in an integer overflow, so remove this `add` and use a regular +  will safe gas.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove safe math in this call  "}, {"title": "Gas saving by duplicate check", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the contract `StrategyRegistry` the method `initialize` execute a require in order to check that the `_maxStrategies` is different than 0, this check will be done later inside the method `_updateMaxStrategies`, so it's duplicated and can be removed.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the _maxStrategies checks inside the initialize method.  "}, {"title": "Deprecated safeApprove() function", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  The OpenZeppelin ERC20 `safeApprove()` function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Impact Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ [issue #2219](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219).  ## Proof of Concept  The deprecated function is found in: - SavingsAccount/SavingsAccount.sol [line 173](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccount.sol#L173) - SavingsAccount/SavingsAccountUtil.sol [line 61](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L61) - mocks/yVault/yVault.sol [line 164](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/yVault.sol#L164) - mocks/yVault/Controller.sol [line 196 and 197](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/Controller.sol#L196)   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.  "}, {"title": "unsafe cast", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/151", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  danb   # Vulnerability details  oracle.pcvStats returns newProtocolEquity as  int256, it is then casted to uint256 in recalculate. If it is possible that newProtocolEquity will be negative, consider using SafeCast instead.  "}, {"title": "denial of service", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/150", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  danb   # Vulnerability details  ## Impact in the first call to requery, If the oracle returns newProtocolEquity = 0, it can never be changed and would lead to denial of service of the system. ## Proof of Concept  In requery, init is checked to be false if newProtocolEquity = 0, and then set to true. so if it is already initialized and newProtocolEquity = 0, it wouldn't change anything ## Tools Used manual review  "}, {"title": "`preMergeCirculatingTribe` can be constant", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  loop   # Vulnerability details  `preMergeCirculatingTribe` is a `uint256` set to a constant value which isn't changed by any function in the contract and can thus be declared as a constant state variable to save some gas during deployment and when using `preMergeCirculatingTribe`.  ## Proof of Concept https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L28  "}, {"title": "Inaccurate revert reason in TRIBERagequit.sol", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The revert reason in L74 is inaccurate. It should be \"ragequit more than assigned\". L72-75 ```         require(             (claimed[thisSender] + multiplier) <= key,             \"already ragequit all you tokens\"         ); ``` The original revert string wrongly implies that claimed[thisSender] >= key Might cause confusing when user who have not yet claimed mistakenly supplied a multiplier > key  "}, {"title": "TRIBERageQuit: Redundant oracleAddress variable", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The following line  ```jsx address public constant oracleAddress =  0xd1866289B4Bd22D453fFF676760961e0898EE9BF; // oracle with caching ```  is only used in the instantiation of the oracle  `IOracle public constant oracle = IOracle(oracleAddress);`  The first instantiation can be combined with the second to save gas.  ## Recommended Mitigation Steps  `IOracle public constant oracle = IOracle(0xd1866289B4Bd22D453fFF676760961e0898EE9BF);`  "}, {"title": "TRIBERagequit: Make verifyClaim() public", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/107", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Suggestion  Based on past experiences with on-chain actions involving merkle proofs, users tend to ask for the merkle tree data so that they can, in this case, ragequit their TRIBE for FEI by directly interacting with the contract on Etherscan.  It would therefore be helpful for `verifyClaim()` to be made public for users to verify that the merkle proof they input via Etherscan is correct.  "}, {"title": "PegExchanger#giveTo(): Use transfer() method instead of transferFrom()", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Looking at the TRIBE token implementation, it would be cheaper to call the `transfer()` method as opposed to the the `transferFrom()` method since the latter contains additional logic (Eg. additional SLOAD to fetch the allowance).  ## Recommended Mitigation Steps  ```jsx function giveTo(address target, uint256 amount) internal {   bool check = token1.transfer(target, amount);  require(check, \"erc20 transfer failed\"); } ```  "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L141`  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L165`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  "}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L205-L208  ```solidity require(             msg.sender == party0Timelock,             \"Only the timelock for party 0 may call this function\"         ); ```  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L217-L220  ```solidity require(             msg.sender == party1Timelock,             \"Only the timelock for party 1 may call this function\"         ); ```  "}, {"title": "False information given to the user", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact In `TribeRagequit` when a user tries to withdraw more than is left, a `\"already ragequit all you tokens\"` error is displayed. This is not necessarily true.\\ For example, if one may withdraw multiplier 1000 times and calls `ngmi(...)` function, stating their balance as 1001 tokens, they would get an information that they have already ragequit all tokens, whic is false as non of them have been ragequit yet.  ## Proof of Concept [code](https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L74)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the information to correctly reflect the situation.  "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function setExpirationBlock in PegExchanger.sol could be set external         The function isEnabled in PegExchanger.sol could be set external         The function party0Accept in PegExchanger.sol could be set external         The function isExpired in PegExchanger.sol could be set external         The function party1Accept in PegExchanger.sol could be set external         The function exchange in PegExchanger.sol could be set external         The function isEnabled in TRIBERagequit.sol could be set external         The function ngmi in TRIBERagequit.sol could be set external         The function requery in TRIBERagequit.sol could be set external         The function party0Accept in TRIBERagequit.sol could be set external         The function isExpired in TRIBERagequit.sol could be set external         The function party1Accept in TRIBERagequit.sol could be set external         The function recalculate in TRIBERagequit.sol could be set external    "}, {"title": "Internal functions to private", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could be set private to save gas and improve code quality:         The function takeFrom in PegExchanger.sol could be set internal         The function giveTo in PegExchanger.sol could be set internal         The function verifyProof in TRIBERagequit.sol could be set internal         The function takeFrom in TRIBERagequit.sol could be set internal         The function processProof in TRIBERagequit.sol could be set internal         The function giveTo in TRIBERagequit.sol could be set internal         The function _startCountdown in TRIBERagequit.sol could be set internal  "}, {"title": "Gas saving in ngmi(uint256,uint256,bytes32[])", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Saving of one SLOAD instruction  ## Proof of Concept The value of `claimed[thisSender] + multiplier` is used twice in `ngmi(uint256,uint256,bytes32[])`. This involves a SLOAD each time it is calculated. Usages in lines 73 and 76 of TRIBERagequit.sol.  ## Tools Used Manual review  ## Recommended Mitigation Steps Precache the value of the expression right before line 72. Worst case, if the require fails, no extra gas is used. Best case, if the require succeeds, the SLOAD in line 76 is saved.  "}, {"title": "Implement _calculateRewardAmount more efficiently", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/134", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  0x0x0x   # Vulnerability details  [https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321) is as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );          uint64[] memory _epochStartTimestamps = new uint64[](1);         _epochStartTimestamps[0] = uint64(_epochStartTimestamp);          uint64[] memory _epochEndTimestamps = new uint64[](1);         _epochEndTimestamps[0] = uint64(_epochEndTimestamp);          uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(             _epochStartTimestamps,             _epochEndTimestamps         );          if (_averageTotalSupplies[0] > 0) {             return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  Since `_averageBalance` is always bigger than `_averageTotalSupplies[0]`. We can implement the, if statement earlier. This will ensure to output 0 earlier. Furthermore, `_averageBalance` is in stack and this check costs less gas. Therefore, the code can be implemented as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );     if (_averageBalance > 0) {           uint64[] memory _epochStartTimestamps = new uint64[](1);           _epochStartTimestamps[0] = uint64(_epochStartTimestamp);              uint64[] memory _epochEndTimestamps = new uint64[](1);           _epochEndTimestamps[0] = uint64(_epochEndTimestamp);              uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(               _epochStartTimestamps,               _epochEndTimestamps           );              return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  "}, {"title": "event PromotionCancelled should also emit the _to address", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/127", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  hubble   # Vulnerability details  ## Impact Since there is an option for the promoter to provide an alternate address while issuing cancelPromotion apart from the creator(promoter address) It is good to track the _to address where the remainingRewards are sent on cancelPromotion  ## Proof of Concept contract : TwabRewards line 50 :    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _remainingRewards);  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'to address' in the event, as below  line 50 :    event PromotionCancelled(uint256 indexed promotionId, address to, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _to, _remainingRewards);    "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L153-L153  ```solidity=153 uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch; ```  `_numberOfEpochs` is uint8 `_promotion.tokensPerEpoch` is uint216  `_numberOfEpochs * _promotion.tokensPerEpoch` will never overflow.  "}, {"title": "`getCurrentEpochId()` Malfunction for ended promotions", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  For ended promotions, `getCurrentEpochId()` may return a `epochId` larger than `numberOfEpochs`.  If the result of this view method is to be used as parameters of `claimRewards()`, it may cause `claimRewards()` to fail.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if `block.timestamp > _promotionEndTimestamp` in `_getCurrentEpochId()` and return `_promotion.numberOfEpochs - 1` for ended promotions.  "}, {"title": "`cancelPromotion()` Unable to cancel unstarted promotions", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/101", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  For unstarted promotions, `cancelPromotion()` will revert at `block.timestamp - _promotion.startTimestamp` in `_getCurrentEpochId()`.  Call stack: `cancelPromotion()` -> `_getRemainingRewards()` -> `_getCurrentEpochId()`.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336  ```solidity=331 function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {     // _tokensPerEpoch * _numberOfEpochsLeft     return         _promotion.tokensPerEpoch *         (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion)); } ```  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if ` _promotion.startTimestamp > block.timestamp` and refund `_promotion.tokensPerEpoch * _promotion.numberOfEpochs` in `cancelPromotion()`.  "}, {"title": "Avoid unnecessary dynamic size array `_averageTotalSupplies` can save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L308-L323  ```solidity=308{314,319,320} uint64[] memory _epochStartTimestamps = new uint64[](1); _epochStartTimestamps[0] = uint64(_epochStartTimestamp);  uint64[] memory _epochEndTimestamps = new uint64[](1); _epochEndTimestamps[0] = uint64(_epochEndTimestamp);  uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(     _epochStartTimestamps,     _epochEndTimestamps );  if (_averageTotalSupplies[0] > 0) {     return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0]; }  return 0; ```  As there is only one time frame, `uint256[] memory _averageTotalSupplies = getAverageTotalSuppliesBetween(...)` can be changed to `uint256 _averageTotalSupply = getAverageTotalSuppliesBetween(...)[0]`, and `_averageTotalSupplies[0]` can be changed to `_averageTotalSupply` for gas saving.  "}, {"title": "`_requireTicket()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L230-L244  ```solidity=230{233,237-243}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), \"TwabRewards/ticket-not-zero-address\");          (bool succeeded, bytes memory data) = address(_ticket).staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          address controllerAddress;          if (data.length > 0) {             controllerAddress = abi.decode(data, (address));         }          require(succeeded && controllerAddress != address(0), \"TwabRewards/invalid-ticket\");     } ```  ### Recommendation  Change to:  ```solidity=230{233,237}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), \"TwabRewards/ticket-not-zero-address\");          (bool succeeded, bytes memory data) = _ticket.staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          require(succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0, \"TwabRewards/invalid-ticket\");     } ```  -   Removing redundant casting of `address(_ticket)` as `_ticket` is `address`; -   `controllerAddress` is unnecessary as it's being used only once; -   Checking if `succeeded` earlier can avoid unnecessary code execution when this check failed; -   Replacing `abi.decode(data, (address)) != address(0)` with `abi.decode(data, (uint160)) != 0` to avoid type casting.  "}, {"title": "`getRewardsAmount` might return wrong result", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  certora   # Vulnerability details  getRewardsAmount gets epochs ids as uint256[]. However, it should be uint8[].  In _calculateRewardAmount, the epoch start time and end time are calculated: ``` uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId); uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration; ```  and then are casted to uint64 for the rest of the function. if it's greater than 2**64, it will be truncated. ## Impact `getRewardsAmount` might return wrong result  ## Tools Used manual review ## Recommended Mitigation Steps get _epochIds as uint8[] instead uint256[]  "}, {"title": "TwarbRewards: don't use the onlyPromotionCreator modifier to save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact cancelPromotion() and its modifier both call _getPromotion() to get the Promotion struct. We can save one such call by removing the modifier and do the check of the modifier at the beginning of the cancelPromotion() block to save storage reads.   ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119  ## Tools Used  ## Recommended Mitigation Steps - remove the modifier onlyPromotionCreator - do the require statement at the beginning of cancelPromotion()       function cancelPromotion(uint256 _promotionId, address _to)         external         override         returns (bool)     {         Promotion memory _promotion = _getPromotion(_promotionId);                // do here the modifiers check          require(             msg.sender == _promotion .creator,             \"TwabRewards/only-promotion-creator\"         );          _requirePromotionActive(_promotion);         require(_to != address(0), \"TwabRewards/recipient-not-zero-address\");          uint256 _remainingRewards = _getRemainingRewards(_promotion);          delete _promotions[_promotionId];         _promotion.token.safeTransfer(_to, _remainingRewards);          emit PromotionCancelled(_promotionId, _remainingRewards);          return true;     }  "}, {"title": "Dust Token Balances Cannot Be Claimed By An `admin` Account", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the `_calculateRewardAmount` calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste.  ## Proof of Concept  https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing an `admin` account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances.  "}, {"title": "uint256 types can be uint64", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calculateRewardAmount()` function in TwabRewards.sol uses the uint256 type for the three variables `_epochDuration`, `_epochStartTimestamp`, and `_epochEndTimestamp`. However, there is no need for these variable to be uint256 instead of uint64 because 1. these variables are later cast as uint64 values anyway 2. the block.timestamp value is orders of magnitude less than the uint64 max value. To expand on this second point, if the the block.timestamp values were on the same order of magnitude as the uint64 max value, then the casting of the uint256 timestamp values to uint64 could cause overflow issues because the OpenZeppelin SafeCast library is not used.  The timestamp values could even be of type uint32 (Uniswap v3 does this in places, and the max uint32 timestamp equates to the year 2106), but since the ITicket.sol contract imported by TwabRewards.sol uses uint64, it would be better to use uint64 to maintain consistency.  ## Proof of Concept  The uint256 variables that can be uint64 are found in TwabRewards.sol: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L294-L296   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Make these variables uint64 for gas savings and consistency with Iticket.sol timestamps. Remove unnecessary uint64() casting when all variables in the `_calculateRewardAmount()` function consistently use uint64 types.  "}, {"title": "Inconsistent definition of when an epoch ends", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The implementation of `_getCurrentEpochId` is: ``` function  _getCurrentEpochId(Promotion  memory  _promotion) internal  view  returns (uint256) {  return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  This means that if exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then  the current epoch is 1, and the 0th epoch is completed. However, there are the following lines of code in `_calculateRewardAmount`:  ``` function  _calculateRewardAmount(  address  _user,  Promotion  memory  _promotion,  uint256  _epochId ) internal  view  returns (uint256) {  uint256 _epochDuration = _promotion.epochDuration;  uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);  uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;  require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");  ... } ```  If exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then this function will revert since the require has a `>` instead of a `>=`.  Thus there are two conflicting definitions of when an epoch ends. In the case of `_getCurrentEpochId`, it is when `_promotion.epochDuration` seconds elapse. In the case of `_calculateRewardAmount`, it is when *more than* `_calculateRewardAmount` seconds elapse. This only makes a difference in one exact second, but it is best to be consistent.  ## Proof of Concept See `_getCurrentEpochId` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L276  See `_calculateRewardAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L289  ## Tools Used Inspection  ## Recommended Mitigation Steps Change  ``` require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\"); ``` to  ``` require(block.timestamp >= _epochEndTimestamp, \"TwabRewards/epoch-not-over\"); ``` in `_calculateRewardAmount`.  "}, {"title": "getRewardsAmount doesn't check epochs haven't been claimed", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In ITwabRewards.sol, it is claimed that `getRewardsAmount` should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says `@dev Will be 0 if user has already claimed rewards for the epoch.`)  However, no such check is done in the implementation of `getRewardsAmount`. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.  ## Proof of Concept See the implementation of `getRewardsAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L209  Notice that there are no checks that the epochs have not already been claimed. Compare this to `claimRewards` which *does* check for epochs that have already been claimed with the following require statement: ``` require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), \"TwabRewards/rewards-already-claimed\"); ``` A similar check should be added `getRewardsAmount` so that previously claimed epochs are not included in the sum.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add a similar check for previously claimed epochs as described above.  "}, {"title": "Check Zero Address Before Function Call Can Save Gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact <code>require(_to != address(0), \"TwabRewards/recipient-not-zero-address\");</code>  Check Zero Address Before Function Call eg. _requirePromotionActive() Can Save Gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L128  ## Tools Used Manual Review  ## Recommended Mitigation Steps Move Zero Address Check to Line L125: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L125  "}, {"title": "Contract does not work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/30", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  There exist ERC20 tokens that charge a fee for every transfer.  This kind of token does not work correctly with the `TwabRewards` contract as the rewards calculation for an user is based on `promotion.tokensPerEpoch` (see line [320](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L320)).  However, the actual amount of tokens the contract holds could be less than `promotion.tokensPerEpoch * promotion.numberOfEpochs` leading to not claimable rewards for users claiming later than others.  ## Recommended Mitigation Steps  To disable fee-on transfer tokens for the contract, add the following code in `createPromotion` around line 11: ``` uint256 oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs); uint256 newBalance = _token.balanceOf(address(this)); require(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance); ```  "}, {"title": "No sanity checks for user supplied promotion values", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  kenzo   # Vulnerability details  User supplied values are not checked and can lead to unexpected behavior (such as division by 0, underflows...)  ## Impact I believe the high risk impact has been detailed and mitigated in other findings. However, for cleanliness and preventive measures, I suggest not allowing illogical inputs.  ## Proof of Concept There is no validation on the user supplied promotion inputs. [(Code ref)](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L88:#L116) Therefore for example, a user can supply _numberOfEpochs = 0, _epochDuration = 0, _tokensPerEpoch = 0. This leads to garbage values in the contract. A user can create a promotion without paying any tokens (if _numberOfEpochs or _tokensPerEpoch  = 0). These may confuse front ends, or compound to lead to more serious errors.  ## Recommended Mitigation Steps Add sanity checks (such as inputs > 0) to `createPromotion` and `extendPromotion`.  "}, {"title": "cancelPromotion is too rigorous", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/23", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When you cancel a promotion with cancelPromotion() then the promotion is complete deleted. This means no-one can claim any rewards anymore, because  _promotions[_promotionId] no longer exists.  It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119-L138 ```JS function cancelPromotion(uint256 _promotionId, address _to) ... {        ...         uint256 _remainingRewards = _getRemainingRewards(_promotion);         delete _promotions[_promotionId];         ```  ## Tools Used  ## Recommended Mitigation Steps In the function cancelPromotion() lower the numberOfEpochs or set a state variable, to allow user to claim their rewards.  "}, {"title": "Continue claiming reqrds after numberOfEpochs are over", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/20", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When claiming rewards via claimRewards(), the function _calculateRewardAmount() is called. The function _calculateRewardAmount() has a check to make sure the epoch is over  ```JS   require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");  ``` However neither functions check if the _epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.  The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log: \u2003Claiming for epoch 1 1 \u2003Claiming for epoch 2 1 \u2003Claiming for epoch 3 1 \u2003Claiming for epoch 4 1 \u2003Claiming for epoch 5 1  ## Proof of Concept ```JS  // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.6; import \"hardhat/console.sol\";    contract TwabRewards {      struct Promotion {         uint216 tokensPerEpoch;         uint32 startTimestamp;         uint32 epochDuration;         uint8 numberOfEpochs;     }     mapping(uint256 => Promotion) internal _promotions;     uint256 internal _latestPromotionId;     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;          constructor() {         uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);         claimRewards(id,1);         claimRewards(id,2);         claimRewards(id,3);         claimRewards(id,4);         claimRewards(id,5);     }           function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {         uint256 _nextPromotionId = _latestPromotionId + 1;         _latestPromotionId = _nextPromotionId;         _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);         return _nextPromotionId;     }       function claimRewards(         uint256 _promotionId,         uint256 _epochId     ) public  returns (uint256) {         Promotion memory _promotion = _getPromotion(_promotionId);         address _user=address(0);         uint256 _rewardsAmount;         uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];          for (uint256 index = 0; index < 1; index++) {             require(                 !_isClaimedEpoch(_userClaimedEpochs, _epochId),                 \"TwabRewards/rewards-already-claimed\"             );             _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);             _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);         }         _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;         console.log(\"Claiming for epoch\",_epochId,_rewardsAmount);         return _rewardsAmount;     }      function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {         return _getPromotion(_promotionId);     }   function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {         return _promotions[_promotionId];     }          function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)     {         return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;     }   function _calculateRewardAmount(                 Promotion memory _promotion,         uint256 _epochId     ) internal view returns (uint256) {         uint256 _epochDuration = _promotion.epochDuration;         uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);         uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;         require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");         return 1;     }   function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {         return _userClaimedEpochs | (uint256(1) << _epochId);     }        function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {                 return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;     }       function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {         // _tokensPerEpoch * _numberOfEpochsLeft         return             _promotion.tokensPerEpoch *             (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));     }   } ```  ## Tools Used  ## Recommended Mitigation Steps In the function _calculateRewardAmount() add something like the following in the beginning after the require. if ( _epochId >= _promotion.numberOfEpochs) return 0;   "}, {"title": "simplify require in _requirePromotionActive()", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _requirePromotionActive() contains the following check in a require statement: ```JS  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, ``` When _promotionEndTimestamp is larger than block.timestamp it will also be larger than 0. Thus the statement can be simplified to save some gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L250-L258  ```JS function _requirePromotionActive(Promotion memory _promotion) internal view {         ...         require(  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, \"TwabRewards/promotion-not-active\" );     } ```   ## Tools Used  ## Recommended Mitigation Steps Change the require statement to:         require( _promotionEndTimestamp >= block.timestamp, \"TwabRewards/promotion-not-active\" ); // will certainly be > 0  "}, {"title": "Caching array length can save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  robee   # Vulnerability details  Caching the array length is more gas efficient.  This is because access to a local variable in solidity is more efficient than query storage / calldata / memory  We recommend to change from:  for (uint256 i=0; i<array.length; i++) { ... } to: uint len = array.length   for (uint256 i=0; i<len; i++) { ... } These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           TwabRewards.sol, _epochIds, 172         TwabRewards.sol, _epochIds, 217   "}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TwabRewards.sol, In line 128, Require message length to shorten: 38, The message: TwabRewards/recipient-not-zero-address         Solidity file: TwabRewards.sol, In line 175, Require message length to shorten: 35, The message: TwabRewards/rewards-already-claimed         Solidity file: TwabRewards.sol, In line 231, Require message length to shorten: 35, The message: TwabRewards/ticket-not-zero-address   "}, {"title": "Struct packing", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  robee   # Vulnerability details  In ITwabRewards.sol, Promotion is optimized to: 4 slots from: 5 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint216         3. uint32         4. uint8         5. address         6. uint32         7. address   "}, {"title": "Backdated _startTimestamp can lead to loss of funds", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/8", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact This can lead to loss of funds as there is no recovery function of funds stuck like this  ## Proof of Concept 1. User A creates a new promotion using createPromotion function. By mistake he provides 1 year ago value for _startTimestamp with promotion duration as 6 months  2. Since there is no check to see that _startTimestamp > block.timestamp so this promotion gets created  3. User cannot claim this promotion if they were not having promotion tokens in the 1 year old promotion period. This means promotion amount remains with contract  4. Even promotion creator cannot claim back his tokens since promotion end date has already passed so cancelPromotion will fail  5. As there is no recovery token function in contract so even contract cant transfer this token and the tokens will remain in this contract with no one able to claim those   ## Recommended Mitigation Steps Add below check in the createPromotion function  ``` function createPromotion(         address _ticket,         IERC20 _token,         uint216 _tokensPerEpoch,         uint32 _startTimestamp,         uint32 _epochDuration,         uint8 _numberOfEpochs     ) external override returns (uint256) { require(_startTimestamp>block.timestamp,\"should be after current time\"); } ```  "}, {"title": "Rewards can be claimed multiple times", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/3", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  johnnycash   # Vulnerability details  ## Impact  An attacker can claim its reward 256 * `epochDuration` seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.    ## Analysis  `claimRewards()` claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping [_claimedEpochs](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L32) keeps track of claimed rewards per user:  ```     /// @notice Keeps track of claimed rewards per user.     /// @dev _claimedEpochs[promotionId][user] => claimedEpochs     /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs; ```  (The comment is wrong, epochs are packed into a uint256 which allows **256** epochs to be stored).  `_epochIds` is an array of `uint256`. For each `_epochId` in this array, `claimRewards()` checks that the reward associated to this `_epochId` isn't already claimed thanks to  `_isClaimedEpoch()`. [_isClaimedEpoch()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L371) checks that the bit `_epochId` of `_claimedEpochs` is unset:  ``` (_userClaimedEpochs >> _epochId) & uint256(1) == 1; ```  However, if `_epochId` is greater than 255, `_isClaimedEpoch()` always returns false. It allows an attacker to claim a reward several times.  [_calculateRewardAmount()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L289) just makes use of `_epochId` to tell whether the promotion is over.   ## Proof of Concept  The following test should result in a reverted transaction, however the transaction succeeds.  ```         it('should fail to claim rewards if one or more epochs have already been claimed', async () => {             const promotionId = 1;              const wallet2Amount = toWei('750');             const wallet3Amount = toWei('250');              await ticket.mint(wallet2.address, wallet2Amount);             await ticket.mint(wallet3.address, wallet3Amount);              await createPromotion(ticket.address);             await increaseTime(epochDuration * 257);              await expect(                 twabRewards.claimRewards(wallet2.address, promotionId, ['256', '256']),             ).to.be.revertedWith('TwabRewards/rewards-already-claimed');         }); ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  A possible fix could be to change the type of `_epochId` to `uint8` in:  - `_calculateRewardAmount()` - `_updateClaimedEpoch()` - `_isClaimedEpoch()`  and change the type of `_epochIds` to `uint8[]` in `claimRewards()`.  "}, {"title": "_getPromotion() doesn't revert on invalid _promotionId", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  johnnycash   # Vulnerability details  ## Impact  `_getPromotion()` doesn't revert if the specified `_promotionId` doesn't exist. It can lead to unexpected behaviors in callers of this function.  For instance, [claimRewards](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L162) will continue its execution and call `_calculateRewardAmount()` and eventually `_promotion.token.safeTransfer()` (probably with `_rewardsAmount` equal to 0).   ## Analysis  In contrary to the following comment:  ``` @dev Will revert if the promotion does not exist. ```  [_getPromotion()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L260-L268) doesn't revert if the specified `_promotionId` doesn't exist, but return a `Promotion` structure with all fields set to 0.   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Fix suggestion:  ```     function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory _promotion) {         _promotion = _promotions[_promotionId];         require(_promotion.creator != address(0), \"TwabRewards/invalid-promotion\");         return _promotion;     } ```  "}, {"title": "Malicious tickets can lead to the loss of all tokens", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  johnnycash   # Vulnerability details  ## Impact  It allows an attacker to retrieve all the tokens of each promotions.   ## Analysis  Anyone can create a new promotion using `createPromotion()`. An attacker can create a new malicious promotion with the following parameters:  - the address of a malicious ticket smart contract - the token address from the targeted promotion(s) - optionally, `_numberOfEpochs` equal to 0 to create this promotion for free  The only verification made on the ticket address given by [_requireTicket()](https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the `ITicket` interface.  The attacker can then call `claimRewards()` with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.  1. `_calculateRewardAmount()` is first called to get the reward amount with the following formula `(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween()`. The malicious ticket can return an arbitrary  `_averageBalance` and an `_averageTotalSupplies` of 1, leading to an arbitrary large reward amount. 2. `_promotion.token.safeTransfer(_user, _rewardsAmount)` is called. It transfers the amount of tokens previously computed to the attacker.  The attacker receives the tokens of other promotions without having spent anything.   ## Proof of Concept  The malicious smart contract is a copy/paste of [TicketHarness.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and [Ticket.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol)with the following changes:  ```     /// @inheritdoc ITicket     function getAverageTotalSuppliesBetween(         uint64[] calldata _startTimes,         uint64[] calldata _endTimes     ) external view override returns (uint256[] memory) {         uint256[] memory _balances = new uint256[](1);         _balances[0] = uint256(1);         return _balances;     }      /// @inheritdoc ITicket     function getAverageBalanceBetween(         address _user,         uint64 _startTime,         uint64 _endTime     ) external view override returns (uint256) {         return 1337;     } ```  The test for HardHat is:  ```     describe('exploit()', async () => {         it('this shouldnt happen', async () => {             const promotionIdOne = 1;             const promotionIdTwo = 2;              await expect(createPromotion(ticket.address))                 .to.emit(twabRewards, 'PromotionCreated')                 .withArgs(promotionIdOne);                          let evilTicketFactory = await getContractFactory('EvilTicket');             let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);             let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;             await expect(twabRewards.connect(wallet2).createPromotion(                 evilTicket.address,                 rewardToken.address,                 tokensPerEpoch,                 createPromotionTimestamp,                 1,//epochDuration,                 0,//epochsNumber,             )).to.emit(twabRewards, 'PromotionCreated')               .withArgs(promotionIdTwo);              await increaseTime(100);             const epochIds = ['100'];             await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);         });     }); ```  It results in the following error:  ```  1) TwabRewards        exploit()          this shouldnt happen:      Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'       at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)       at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)       at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)       at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)       at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)       at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186) ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Maybe add a whitelist of trusted tickets?  "}, {"title": "Reentrancy vulnerability in `Basket` contract's `initialize()` method.", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/176", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  broccolirob   # Vulnerability details   A malicious \"publisher\" can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in it's `approve()` method. When the `initialize()` method is called on the newly cloned `Basket` contract, a method called `approveUnderlying(address(auction))` is called, which would trigger the reentrancy, call `initialize()` again, passing in altered critical values such as `auction` and `factory`, and then removes its self from `proposal.tokens` and `proposal.weights` so it doesn't appear in the token list to basket users.  https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L44-L61  ## Impact `Auction` and `Factory` can be set to custom implementations that do malicious things. Since all baskets and auctions are clones with their own addresses, this fact would be difficult for users to detect. `Auction` controls ibRatio, which a malicious version could send back a manipulated value to `Basket`, allowing the malicious \"publisher\" to burn basket tokens till all users underlying tokens are drained.  ## Tools Used Manual review and Hardhat.  ## Recommended Mitigation Steps Since `Basket` inherits from `ERC20Upgradeable` the `initializer` modifier should be available and therefore used here. It has an `inititializing` variable that would prevent this kind of reentrancy attack.  "}, {"title": "Change in `auctionMultiplier/auctionDecrement` change profitability of auctions and factory can steal all tokens from a basket abusing it", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  0x0x0x   # Vulnerability details  When factory changes `auctionMultiplier` or `auctionDecrement` profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.  ## Proof of concept  1- Factory owners call `bondForRebalance` for an auction.  2- Factory owners sets `auctionMultiplier` as 0 and `auctionDecrement` as maximum value  3- `settleAuction` is called. `newRatio = 0`, since `a = b = 0`. All tokens can be withdrawn with this call, since `tokensNeeded = 0`.  ## Extra notes  Furthermore, even the factory owners does not try to scam users. In case `auctionMultiplier` or `auctionDecrement` is changed, all current `auctionBonder` from `Auctions` can only call `settleAuction` with different constraints. Because of different constraints, users/bonder will lose/gain funds.  ## Mitigation step  Save `auctionDecrement` and `auctionMultiplier` to global variables in `Auction.sol`, when `startAuction` is called.  "}, {"title": "`Basket.sol#auctionBurn` calculates `ibRatio` wrong", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/144", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  0x0x0x   # Vulnerability details  The function is implemented as follows:  ``` function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {         uint256 startSupply = totalSupply();         handleFees(startSupply);         _burn(msg.sender, amount);          uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);         ibRatio = newIbRatio;          emit NewIBRatio(newIbRatio);         emit Burned(msg.sender, amount);     } ```  When `handleFees` is called, `totalSupply` and `ibRatio` changes accordingly, but for `newIbRatio` calculation tokens minted in `handleFees` is not included. Therefore, `ibRatio` is calculated higher than it should be. This is dangerous, since last withdrawing user(s) lose their funds with this operation. In case this miscalculation happens more than once, `newIbRatio` will increase the miscalculation even faster and can result in serious amount of funds missing. At each time `auctionBurn` is called, at least 1 day (auction duration) of fees result in this miscalculation. Furthermore, all critical logic of this contract is based on `ibRatio`, this behaviour can create serious miscalculations.   ## Mitigation step  Rather than  `uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);`  A practical solution to this problem is calculating `newIbRatio` as follows:  ``` uint256 supply = totalSupply(); uint256 newIbRatio = ibRatio * (supply + amount) / supply; ```  "}, {"title": "`BasketLicenseProposed` better emit proposal id", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/134", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Since tokenName is user supplied and can be duplicated, it is better to emit proposal id instead.  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L91 ```         emit BasketLicenseProposed(msg.sender, tokenName); ```  "}, {"title": "`Auction.sol#settleAuction()` Bonder may not be able to settle a bonded auction, leading to loss of funds", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102  ```solidity=97     uint256 a = factory.auctionMultiplier() * basket.ibRatio();     uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();     uint256 newRatio = a - b;      (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();     require(newRatio >= minIbRatio); ```  In the current implementation, `newRatio` is calculated and compared with `minIbRatio` in `settleAuction()`.  However, if `newRatio` is less than `minIbRatio`, `settleAuction()` will always fail and there is no way for the bonder to cancel and get a refund.  ### PoC  Given:  - `bondPercentDiv` = 400 - `basketToken.totalSupply` = 40,000 - `factory.auctionMultiplier` = 2 - `factory.auctionDecrement` = 10,000 - `basket.ibRatio` = 1e18 - p`endingWeights.minIbRatio` = 1.9 * 1e18  1. Alice called `bondForRebalance()` `2,000` blocks after the auction started, paid `100` basketToken for the bond; 2. Alice tries to `settleAuction()`, it will always fail because `newRatio < minIbRatio`; - a = 2 * 1e18 - b = 0.2 * 1e18 - newRatio = 1.8 * 1e18; 3. Bob calls `bondBurn()` one day after, `100` basketToken from Alice will been burned.  ### Recommendation  Move the `minIbRatio` check to `bondForRebalance()`:  ```solidity=58 function bondForRebalance() public override {         require(auctionOngoing);         require(!hasBonded);          bondTimestamp = block.timestamp;         bondBlock = block.number;          uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();         require(newRatio >= minIbRatio);          IERC20 basketToken = IERC20(address(basket));         bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();         basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);         hasBonded = true;         auctionBonder = msg.sender;          emit Bonded(msg.sender, bondAmount);     } ```  "}, {"title": "Basket can be fully drained if the auction is settled within a specific block", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/74", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The `settleAuction()` function allows someone to settle the auction by transferring funds in a way that the new pending index is fulfilled. As a reward, they are able to take out as many tokens as they want as long as the pending index is fulfilled after that. The function verifies that the basket has received everything it wanted using the following logic: ```sol         for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The attack vector here is to manipulate `tokensNeeded` to be 0. That way we can drain the basket completely without the function reverting.  For that, we manipulate `newRatio` to be 0 then the whole thing will be 0. `newRatio` is defined as: ```sol         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ``` There's 1 value the attacker controls, `bondBlock`. That value is the block in which the `bondForRebalance()` function was triggered. So the goal is to get `newRatio` to be 0. With the base settings of the contract:  - auctionMultiplier == 2 - ibRatio == 1e18 - BASE == 1e18 - auctionDecrement == 10000  `bondBlock` has to be `auctionStart + 20000`. Meaning, the `bondForRebalance()` function has to be triggered exactly 20000 blocks after the action was started. That would be around 3 1/2 days after auction start.  At that point, `newRatio` is 0, and thus `tokensNeeded` is 0. The only thing left to do is to call `settleAuction()` and pass the basket's tokens and balance as the output tokens and weight.  ## Proof of Concept Here's a test implementing the above scenario as a test. You can add it to `Auction.test.js`.:  ```js       it.only(\"should allow me to steal funds\", async() => {         // start an auction         let NEW_UNI_WEIGHT = \"2400000000000000000\";         let NEW_COMP_WEIGHT = \"2000000000000000000\";         let NEW_AAVE_WEIGHT = \"400000000000000000\";          await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],              [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;         await increaseTime(60 * 60 * 24)         await increaseTime(60 * 60 * 24)         await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],            [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;          let auctionAddr = await basket.auction();         let auction = AuctionImpl.attach(auctionAddr);          ethers.provider.getBlockNumber();         // increase the block number for `bondBlock - auctionStart` to be 20000.         // When that's the case, the result of `newRatio` in `settleAuction()`          // is `0`. And that means `tokensNeeded` is 0. Which means,         // we can take out all the tokens we want using the `outputTokens` array         // without having to worry about basket's balance at the end.         // The math changes depending on the settings of the factory contract or the         // Basket contract. But, the gist is that you try to get newRatio to be 0.         // The only values you can control as a attacker is the bondBlock after the auction         // was started.         for (let i = 0; i < 20000; i++) {           await hre.network.provider.send(\"evm_mine\")         }         await basket.approve(auction.address, '5000000000000000');         await expect(auction.bondForRebalance()).to.be.ok;         await expect(auction.settleAuction([], [], [], [UNI.address, AAVE.address], [\"200720000000000000\", \"200120000000000000\"])).to.be.ok;       }); ```  Again, this test uses the base values. The math changes when the settings change. But, it should always be possible to trigger this attack. The gap between auction start and bonding just changes.  ## Tools Used manual analysis  ## Recommended Mitigation Steps - Verify that `newRatio != 0`  "}, {"title": "Wrong fee calculation after totalSupply was 0", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/58", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  `handleFees` does not update `lastFee` if `startSupply == 0`. This means that wrongly, extra fee tokens would be minted once the basket is resupplied and `handleFees` is called again.  ## Impact Loss of user funds. The extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens' value.  ## Proof of Concept Scenario: - All basket token holders are burning their tokens. The last burn would set totalSupply to 0. - After 1 day, somebody mints basket tokens. `handleFees` would be called upon mint, and would just return since totalSupply == 0. Note: It does not update `lastFee`. ``` } else if (startSupply == 0) {             return; ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L136:#L137 - The next block, somebody else mints a token. Now `handleFees` will be called and will calculate the fees according to the current supply and the time diff between now and `lastFee`: ``` uint256 timeDiff = (block.timestamp - lastFee); ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L139 But as we saw, `lastFee` wasn't updated in the previous step. `lastFee` is still the time of 1 day before - when the last person burned his tokens and the basket supply was 0. So now the basket will mint fees as if a whole day has passed since the last calculation, but actually it only needs to calculate the fees for the last block, since only then we had tokens in the basket.  ## Recommended Mitigation Steps Set `lastFee = block.timestamp` if `startSupply == 0`.  "}, {"title": "Incorrent visibility for \"initialized\" variable", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  neslinesli93   # Vulnerability details  ## Impact The `initialized` variable has its visibility set to `public`, while it should be private. The reason is that any contract that inherits from `Auction.sol` or `Basket.sol` may reset the value for  the `initialized` variable  ## Recommended Mitigation Steps Reduce `initialized` visibility to `private` in both contracs  "}, {"title": "Basket:handleFees fee calculation is wrong", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE - feePct)  ## Proof of Concept This shows dividing only by BASE is correct: Assumptions:  - BASE is 1e18 accordign to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%),  uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions uint256 fee = startSupply * feePct / BASE; // only divide by BASE => insert values => fee = 1e18 * licenseFee  / 1e18 = licenseFee    This shows the math is wrong:  Assumptions:  - BASE is 1e18 according to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%), but the fee is bigger than that.   uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions  uint256 fee = startSupply * feePct / (BASE - feePct); insert the values => fee = 1e18 * 1e15 / (1e18 - 1e15) => (factor out 1e15) => fee = 1e15 * 1e18 / (1e15 * ( 1e3 - 1) => (cancel 1e15) => 1e18 / ( 1e3 - 1)  math: if we increase the divisor but the dividend stays the same we get a smaller number e.g. (1 / (2-1)) is bigger than (1 / 2) apply this here => 1e18 / ( 1e3 - 1) > 1e18 / 1e3 => 1e18 / ( 1e3 - 1) > 1e15  this shows that the fee is higher than 1e15   https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133 https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps - only divide by BASE  "}, {"title": "Emit for publishNewIndex / killAuction part", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Most of the public functions have an emit, however in function publishNewIndex(), there is no emit for the \"killauction\" part. It might be useful to have an emit there too.  ## Proof of Concept https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L216-L244  ```JS  function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {    ...             } else {                 auction.killAuction();                 pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.timestamp = block.timestamp;                 pendingWeights.minIbRatio = _minIbRatio;                // no emit             } ```  ## Tools Used  ## Recommended Mitigation Steps Possibly add an emit in the \"killauction\" part   "}, {"title": "claimYeti inclusive check", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/300", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact condition should be inclusive >= : ```solidity   if (available > totalClaimed.add(_amount)) ```  "}, {"title": "Gas Optimization: Unnecessary variables", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/299", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The 3 variable defined in L365-367 are used only once https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/Whitelist.sol#L365-367 ```         uint256 price = getPrice(_collateral);         uint256 decimals = collateralParams[_collateral].decimals;         uint256 ratio = collateralParams[_collateral].ratio; ```  We can skip them and do everything inline: ``` return (getPrice(_collateral).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals))); ```  Similarly, L352-354 ```         return getPrice(_collateral).mul(_amount).div(10**collateralParams[_collateral].decimals); ```  "}, {"title": "_isBeforeFeeBootstrapPeriod inside the loop", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/296", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact _isBeforeFeeBootstrapPeriod() is re-evaluated again and again inside the loop, although its value could be cached outside the loop and re-used to reduce gas costs.   "}, {"title": "Cache repeated calculations", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/294", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In function _transfer, shares.to128(); can be cached to skip the same calculation again: ```solidity   users[from].balance = fromUser.balance - shares.to128();   users[to].balance = toUser.balance + shares.to128(); ``` Same here, the result can be extracted to a constant as it never changes: ```solidity   (DECIMAL_PRECISION / 2) ```  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/289", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `troveManager` in `TroveManagerRedemptions#_updateBaseRateFromRedemption()`      https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L432-L447      ```solidity=432     function _updateBaseRateFromRedemption(uint256 _YUSDDrawn, uint256 _totalYUSDSupply)     internal     returns (uint256)     {         uint256 decayedBaseRate = troveManager.calcDecayedBaseRate();          /* Convert the drawn Collateral back to YUSD at face value rate (1 YUSD:1 USD), in order to get          * the fraction of total supply that was redeemed at face value. */         uint256 redeemedYUSDFraction = _YUSDDrawn.mul(10**18).div(_totalYUSDSupply);          uint256 newBaseRate = decayedBaseRate.add(redeemedYUSDFraction.div(BETA));         newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%          troveManager.updateBaseRate(newBaseRate);         return newBaseRate;     }     ```  "}, {"title": "Only using `SafeMath` when necessary can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/281", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L791-L795  ```solidity=791 if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease      newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee)); } else { // otherwise increase by opposite subtraction     newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange)); } ```  `_debtChange - _variableYUSDFee` at L792 and `_variableYUSDFee - _debtChange` at L794 will never underflow.   https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L240-L241  ```solidity=240 _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); ```  `_balances[account] + amount` will not overflow if `_totalSupply.add(amount)` dose not overflow.    https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L248-L249  ```solidity=248 _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); _totalSupply = _totalSupply.sub(amount); ```  `_totalSupply - amount` will not underflow if `_balances[account].sub(amount)` dose not underflow.   "}, {"title": "Only use `amount` when needed can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/279", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L839-L847  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {         for (uint i = 0; i < _colls.tokens.length; i++) {             address token = _colls.tokens[i];             uint amount = _colls.amounts[i];             if (whitelist.isWrapped(token)) {                 IWAsset(token).updateReward(_borrower, _newOwner, amount);             }         }     } ```  Since `amount` is only needed in `if (whitelist.isWrapped(token)) {...}`, so `uint amount = _colls.amounts[i];` should be moved to inside `if (whitelist.isWrapped(token)) {...}`.  Furthermore, considering that `amount` is only used once, it can be replaced with `_colls.amounts[i]`.  ### Recommendation  Change to:  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     for (uint i = 0; i < _colls.tokens.length; i++) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } } ```  "}, {"title": "Inline unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/278", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L297-L301  ```solidity=297     function _requireCallerIsTMLorSP() internal view {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             \"YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool\");     } ```  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L128-L131  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         _requireCallerIsTMLorSP();         _transfer(_poolAddress, _receiver, _amount);     } ```   `_requireCallerIsTMLorSP()` is unnecessary as it's being used only once. Therefore it can be inlined in `returnFromPool()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             \"YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool\");         _transfer(_poolAddress, _receiver, _amount);     } ```  Other examples include:  -   `TroveManagerRedemptions.sol#_getRedemptionFee()` can be inlined in `TroveManagerRedemptions.sol#redeemCollateral()`  "}, {"title": "TeamLockup releases more tokens that it should", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/263", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  TeamLockup mentions on \"vestingLength\" that it is the \"number of YETI that are claimable every day after vesting starts\". However, the vesting calculation treats it as if was the number of YETI that are claimable every second, not every day.  ## Impact Tokens would be released faster than planned. Or, if the tokens are planned to be released every second and not every day (I'm guessing it's less likely), then this is a wrong comment.  ## Proof of Concept The description of `vestingLength`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L15) ```     uint immutable vestingLength; // number of YETI that are claimable every day after vesting starts ```  The calculation to decide how many tokens can be released: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L41:#L43) ```         uint timePastVesting = block.timestamp.sub(vestingStart);         uint available = _min(totalVest,(totalVest.mul(timePastVesting)).div(vestingLength)); ``` The problem is that `timePastVesting` is in seconds, and `vestingLength` is in days.  ## Recommended Mitigation Steps Divide the calculation by `1 day` to align the units.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/ERC20_8.sol#L68-L70  ```solidity=68         require(_num_tokens <= balances[msg.sender], \"You are trying to transfer more tokens than you have\");          balances[msg.sender] = balances[msg.sender] - _num_tokens; ```  `balances[msg.sender] - _num_tokens` will never underflow.  "}, {"title": "Wrong vesting schedule for YETI mentioned in LockupContract", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/250", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  LockupContract, LockupContractFactory amd ShortLockupContract all have comments that say: ``` Within the first year from deployment, the deployer of the YETIToken (Liquity AG's address) may transfer YETI only to valid LockupContracts, and no other addresses (this is enforced in YETIToken.sol's transfer() function). The above two restrictions ensure that until one year after system deployment, YETI tokens originating from Liquity AG cannot enter circulating supply and cannot be staked to earn system revenue. ```  This comment is outdated (verified with sponsor). There is no such lockup on YETI tokens issued to team/treasury. (There might be other type of vesting which is probably implemented using TeamLockup.)  ## Impact Confusion, wrong description of team's capability to use yeti tokens issued.  ## Proof of Concept [Code ref](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/LockupContract.sol#L13:#L18).  ## Recommended Mitigation Steps Remove outdated comments.  "}, {"title": "ecrecover 0 address", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/244", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact ecrecover returns an empty address when the signature is invalid. As far as I checked, with the current codebase, there is no way to exploit it to gain any benefits, but it is a good practice to check against that. ```solidity   address recoveredAddress = ecrecover(digest, v, r, s);   require(recoveredAddress == owner, 'YUSD: invalid signature'); ```  ## Recommended Mitigation Steps require recoveredAddress != address(0)  You could also consider using OZ's ECDSA library for signature verifications: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol  "}, {"title": "setAddresses should only be callable once", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/240", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setAddresses in contract Whitelist is intended to be invoked only once (confirmed with the sponsor) but currently, it has no prevention from being called multiple times.  Maybe this should also be prevented in sYETIToken's setAddresses and ThreePieceWiseLinearPriceCurve's setAddresses.  ## Recommended Mitigation Steps Prevent repeated access of setAddresses in Whitelist and potentially in sYETIToken and ThreePieceWiseLinearPriceCurve.  "}, {"title": "`WJLP.getPendingRewards()` should be aview function", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact View functions consume less gas. `WJLP.getPendingRewards()` is technically also a view function but not specified as one. Because the `IMasterChefJoeV2` interface used by the contract is wrong. It says `poolInfo()` is not a view function, which it is.  ## Proof of Concept getPendingRewards: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L190  Faulty interface function: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L29  actually poolinfo is just an array so its getter is a view function: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV2.sol#L85  ## Tools Used none  ## Recommended Mitigation Step Declare both functions as `view` to save gas  "}, {"title": "CollSurplusPool doesn't verify that the passed `_whitelistAddress` is an actual contract addres", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/230", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact All the other passed variables are checked. Only `_whitelistAddress` is ignored. This allows passing a zero function which would break the functionality.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/CollSurplusPool.sol#L51-L54  ## Tools Used none  ## Recommended Mitigation Steps add `checkContract(_whitelistAddress)`  "}, {"title": "No sanity check of safe ratio when adding collateral", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/217", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  When changing collateral's ratio, it is rightly checked to be smaller than 110%. However when adding new collateral, the ratio check is not there, so it can be added with ratio that is larger than 110%.  ## Impact Accidentally adding an asset with larger ratio would result in users being able to withdraw more YUSD than supplied VC.  ## Proof of Concept When an asset is being added, there is no sanity check that the ratio is within the correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L92:#L127)  This is unlike `changeRatio`, which validates that the new ratio is in correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L204) ``` require(_ratio < 1100000000000000000, \"ratio must be less than 1.10 => greater than 1.1 would mean taking out more YUSD than collateral VC\"); ```  ## Recommended Mitigation Steps Add the same ratio check to `addCollateral`.  "}, {"title": "ActivePool unwraps but does not update user state in WJLP", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/209", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  Calling `WJLP.unwrap` burns WJLP, withdraws the amount from the master chef and returns the same amount of JLP back to the `to` address. However, it does not update the internal accounting in `WJLP` with a `_userUpdate` call.  This needs to be done on the caller side according to the comment in the `WJLP.unwrap` function: > \"Prior to this being called, the user whose assets we are burning should have their rewards updated\"  This happens when being called from the `StabilityPool` but not when being called from the `ActivePool.sendCollateralsUnwrap`:  ```solidity function sendCollateralsUnwrap(address _to, address[] memory _tokens, uint[] memory _amounts, bool _collectRewards) external override returns (bool) {     _requireCallerIsBOorTroveMorTMLorSP();     require(_tokens.length == _amounts.length);     for (uint i = 0; i < _tokens.length; i++) {         if (whitelist.isWrapped(_tokens[i])) {             // @audit this burns the tokens for _to but does not reduce their amount. so there are no tokens in WJLP masterchef but can keep claiming             IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]);             if (_collectRewards) {                 IWAsset(_tokens[i]).claimRewardFor(_to);             }         } else {             _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails         }     }     return true; } ```  ## Impact The `unwrapFor` call withdraws the tokens from the Masterchef and pays out the user, but their user balance is never decreased by the withdrawn amount. They can still use their previous balance to claim rewards through `WJLP.claimReward` which updated their unclaimed joe reward according to the old balance. Funds from the WJLP pool can be stolen.  ## Recommended Mitigation Steps As the comment says, make sure the user is updated before each `unwrap` call. It might be easier and safer to have a second authorized `unwrapFor` function that accepts a `rewardOwner` parameter, the user that needs to be updated.   "}, {"title": "Wrong `lastBuyBackPrice`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/206", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:  ```solidity function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {     require(YUSDToSell > 0, \"Zero amount\");     require(lastBuybackTime + 69 hours < block.timestamp, \"Must have 69 hours pass before another buyBack\");     yusdToken.approve(routerAddress, YUSDToSell);     uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);     lastBuybackTime = block.timestamp;     // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]     // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)     lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);     emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]); } ```  It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap `path` parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).  ## Impact The `lastBuyBackPrice` will be wrong when using a different path. This will lead `rebase`s using a different yeti amount and the `effectiveYetiTokenBalance` being updated wrong.  ## Recommended Mitigation Steps Verify the first and last element of the path are YETI/YUSD and use the first and last amount parameter.   "}, {"title": "sYETIToken does not emit Approval event in `transferFrom`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `sYETIToken.transferFrom` function does not emit a new `Approval` event when decreasing the allowance. Most ERC20 implementations, like OpenZeppelin's, emit this event when the `allowance` is decreased.  ## Impact Off-chain scripts and frontends will not correctly track the `allowance`s of users when listening to the `Approval` event. This can lead to failed transactions as a higher approval is assumed than it actually is.  ## Recommended Mitigation Steps Emit the `Approval` event also in `transferFrom` if the approval is decreased.   "}, {"title": "Fee not decayed if past `decayTime`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/204", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..  ```solidity if (decay > 0 && decay < decayTime) {     // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     fee = lastFeePercent; } ```  ## Recommended Mitigation Steps It seems wrong to handle the `decay == 0` case (decay happened in same block) the same way as the `decay >= decayTime` case (decay happened long time ago) as is done in the `else` branch. I believe it should be like this instead:  ```solidity // decay == 0 case should be full lastFeePercent if(decay < decayTime) {     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     // reset to zero if decay >= decayTime     fee = 0; } ```  "}, {"title": "rong comment in `getFee`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/203", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap:  > If dollarCap == 0, then it is not capped. Otherwise, **then the total + the total input** must be less than the cap.  The code only checks if the input is less than the cap:  ```solidity // @param _collateralVCInput is how much collateral is being input by the user into the system if (dollarCap != 0) {     require(_collateralVCInput <= dollarCap, \"Collateral input exceeds cap\"); } ```  ## Recommended Mitigation Steps Clarify the desired behavior and reconcile the code with the comments.   "}, {"title": "Cannot use most piecewise linear functions with current implementation", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/200", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1, f2, f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0), b3 = f_3(0)`) for each of these but uses **unsigned integers** for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.  #### Example: Check out this two-piece linear interest curve of Aave:  ![Aave](https://docs.aave.com/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M51Fy3ipxJS-0euJX3h-2670852272%2Fuploads%2Fycd9OMRnInNeetUa7Lj1%2FScreenshot%202021-11-23%20at%2018.52.26.png?alt=media&token=7a25b900-7023-4ee5-b582-367d56d31894) The intersection of the second steep straight line with the y-axis `b_2 = f_2(0)` would be negative.  Example: Imagine a curve that is flat at `10%` on the first 50% utilization but shoots up to `110%` at 100% utilization.  - `m1 = 0, b1 = 10%, cutoff1 = 50%`  - `m2 = 200%` => `b2 = m1 * cutoff1 + b1 - m2 * cutoff1 = f1(cutoff1) - m2 * cutoff1 = 10% - 200% * 50% = 10% - 100% = -90%`. (`f2(100%) = 200% * 100% - 90% = 110%` \u2705) This function would revert in the `b2` computation as it underflows due to being a negative value.  ## Impact Most curves that are actually desired for a lending platform (becoming steeper at higher utilization) cannot be used.  ## Recommended Mitigation Steps Evaluate the piecewise linear function in a different way that does not require computing the y-axis intersection value. For example, for `cutoff2 >= x > cutoff1`, use `f(x) = f_1(cutoff) + f_2(x - cutoff)`. See [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol#L85).   "}, {"title": "Missing cutoff checks in `adjustParams`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/199", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function does not check that `_cutoff1 <= _cutoff2` and also does not revert in this case. However, this always indicates an error in how this function should be used.  ## Recommended Mitigation Steps Add a `_cutoff1 <= _cutoff2` check.  "}, {"title": "contracts/Dependencies/CheckContract.sol has a potential gas optimization", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/189", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  CheckContract is used in ActivePool, BorrowerOperations, CollSurplusPool, DefaultPool, HintHelpers, PriceFeed, SortedTroves, StabilityPool, TroveManager, TroveManagerLiquidations, TroveManagerRedemptions but this is a view function and could easily be implemented as an internal library call.  This would result in slightly larger contract bytecode but should be far more gas efficient than an external contract call as is the current case.  ## Proof of Concept  https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678  \"\"\" Use any of the internal calling methods. We prefer internal library calls, because of the associated class features (see Class Features of Solidity by the same author). Using an external call to a public library function is very expensive, and will only be worth it to avoid including a lot of code into the bytecode for your contract. Using a local contract component is the most expensive option and should be avoided unless essential. \"\"\"  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/CheckContract.sol#L6  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare CheckContract as an internal library:  https://medium.com/coinmonks/all-you-should-know-about-libraries-in-solidity-dd8bc953eae7  \"\"\" Embedded Library: If a smart contract is consuming a library which have only internal functions than EVM simply embeds library into the contract. Instead of using delegate call to call a function, it simply uses JUMP statement(normal method call). There is no need to separately deploy library in this scenario. \"\"\"  "}, {"title": "contracts/TroveManagerRedemptions.sol is missing inheritance", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/188", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerRedemptions does not inherit contracts/Interfaces/ITroveManagerRedemptions.sol but should.  Note that TroveManager.sol does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L38  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as \"TroveManagerRedemptions is TroveManagerBase, ITroveManagerRedemptions\"  "}, {"title": "contracts/TroveManagerLiquidations.sol is missing inheritance", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/187", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerLiquidations does not inherit contracts/Interfaces/ITroveManagerLiquidations.sol but should.  Note that TroveManager.sol  does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L14  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as \"TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations\"  "}, {"title": "NamespaceCollision: Multiple SafeMath contracts", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/181", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  Got an error attempting Slither analysis due to several contracts defining \"SafeMath\"   - In this case there are *two* distinct safe math libraries, one dependent on solc 0.6.11 and one dependent on solc ^0.8.0. This can lead to confusion during development.  Ideally the safe math version of the application contract [0.6.11] would be standardized but in this case *re-naming* the SafeMath contracts also suffices.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol#L15  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/SafeMath.sol#L21    ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol to SafeMath080.sol [and updating the declared contract to the same name]  "}, {"title": "Multiple contracts or interfaces with the same name", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/180", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact Got an error attempting Slither analysis due to Pool2Unipool and Unipool declaring the same contract named LPTokenWrapper.  It is confusing and error prone to have such similarly named contracts and there is no clear benefit to re-using the name.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename LPTokenWrapper in Pool2Unipool to 'Pool2LPTokenWrapper' and correct any related imports.  "}, {"title": "\"constants\" expressions are expressions, not constants, so constant\u00a0`keccak`\u00a0variables results in extra hashing (and so gas).", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact In a number of places a `keccak(\"string\")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  ## Proof of Concept ``` YETI\\YETIToken.sol:   50:     bytes32 private constant _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");   51:     bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");  YETI\\BoringCrypto\\Domain.sol:   10:     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change all `constant` hashes to be `immutable`  "}, {"title": "Check if transfer amount > 0", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.   ## Proof of Concept Instances missing a non-zero check: ``` ActivePool.sol:   156:         bool sent = IERC20(_collateral).transfer(_to, _amount);  BorrowerOperations.sol:   742:             bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);  DefaultPool.sol:   121:         bool success = IERC20(_collateral).transfer(activePool, _amount);  StabilityPool.sol:   947:                 IERC20(assets[i]).transfer(_to, amounts[i]);  TeamAllocation.sol:   69:             require(YETI.transfer(member, amount));   77:         YETI.transfer(_to, _amount);  YetiFinanceTreasury.sol:   25:         _token.transfer(_to, _amount);  AssetWrappers\\WJLP\\WJLP.sol:   127:         JLP.transferFrom(_from, address(this), _amount);   166:         JLP.transfer(_to, _amount);   273:             JOE.transfer(_to, _amount);  Dependencies\\LiquityBase.sol:   170:             if (!token.transfer(_to, _coll.amounts[i])) {  LPRewards\\Dependencies\\SafeERC20.sol:   23:         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));   27:         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));  YETI\\CommunityIssuance.sol:   125:         yetiToken.transfer(_account, _YETIamount);  YETI\\LockupContract.sol:   68:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\\ShortLockupContract.sol:   67:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\\sYETIToken.sol:   203:         yetiToken.transfer(to, amount);  YETI\\TeamLockup.sol:   47:             require(YETI.transfer(multisig, _amount)); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0. It is done at some places already, like here: https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/LPRewards/Unipool.sol#L189-L192  "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L890`  ``` https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L699  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L873  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L920  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L929  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/ActivePool.sol#L167  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  "}, {"title": "Declare state variables as immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  In `WJLP.sol`, state variables `JLP` and `JOE` are initialized in the constructor and never reassigned again. Thus, they can be declared `immutable` rather than `constant` in order to save gas  ## Proof of Concept  [https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41)  ## Tools Used  Editor  "}, {"title": "ActivePool does not update rewards before unwrapping wrapped asset", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  When ActivePool sends collateral which is a wrapped asset, it first unwraps the asset, and only after that updates the rewards. This should be done in opposite order. As a comment in WJLP's `unwrapFor` rightfully mentions - \"Prior to this being called, the user whose assets we are burning should have their rewards updated\".  ## Impact Lost yield for user.  ## Proof of Concept In ActivePool's `sendCollateralsUnwrap` (which is used throughout the protocol), it firsts unwraps the asset, and only afterwards calls `claimRewardFor` which will update the rewards: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol#L186:#L188) ``` IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]); if (_collectRewards) {         IWAsset(_tokens[i]).claimRewardFor(_to); } ``` `claimRewardFor` will end up calling `_userUpdate`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L246:#L263) ```     function _userUpdate(address _user, uint256 _amount, bool _isDeposit) private returns (uint pendingJoeSent) {         uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;         UserInfo storage user = userInfo[_user];         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12);     } ``` Now, as ActivePool has already called `unwrapFor` and has burnt the user's tokens, and let's assume they all were used as collateral, it means user.amount=0*, and the user's unclaimedJOEReward won't get updated to reflect the rewards from the last user update. This is why, indeed as the comment in `unwrapFor` says, user's reward should be updated prior to that.  *Note: at the moment `unwrapFor` doesn't updates the user's user.amount, but as I detailed in another issue, that's a bug, as that means the user will continue accruing rewards even after his JLP were removed from the protocol.  ## Recommended Mitigation Steps Change the order of operations in `sendCollateralsUnwrap` to first send the updated rewards and then unwrap the asset. You can also consider adding to the beginning of `unwrapFor` a call to `_userUpdate(_to, 0, true)` to make sure the rewards are updated before unwrapping. Note: as user can choose to have JOE rewards accrue to a different address than the address that uses WJLP as collateral, you'll have to make sure you update the current accounts. I'll detail this in another issue.  "}, {"title": "WJLP loses unclaimed rewards when updating user's rewards", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/141", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  After updating user's rewards in `_userUpdate`, if the user has not claimed them, and `_userUpdate` is called again (eg. on another `wrap`), the user's unclaimed rewards will lose the previous unclaimed due to wrong calculation.  ## Impact Loss of yield for user.  ## Proof of Concept When updating the user's unclaimedJoeReward, the function doesn't save it's previous value. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L251:#L253) ```         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         // update for JOE rewards that are already accounted for in user.unclaimedJOEReward         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12); ``` So for example, rewards can be lost in the following scenario. We'll mark \"acc1\" for the value of \"accJoePerShare\" at step 1. 1. User Zebulun wraps 100 tokens. After  `_userUpdate` is called: unclaimedJOEReward  = 0, rewardDebt = 100*acc1. 2. Zebulun wraps 50 tokens: unclaimedJOEReward = 100*acc2 - 100*acc1, rewardDebt = 150 * acc2. 3. Zebulun wraps 1 token: unclaimedJOEReward = 150*acc3 - 150*acc2, rewardDebt = 151*acc3 So in the last step, Zebulun's rewards only take into account the change in accJoePerShare in steps 2-3, and lost the unclaimed rewards from steps 1-2.  ## Recommended Mitigation Steps Change the unclaimed rewards calculation to: ``` user.unclaimedJOEReward = user.unclaimedJOEReward.add(user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt)); ```  "}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact Gas wastage  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/YetiCustomBase.sol  2. Observe that in _subColls function the last for loop is not required if n=0 since this means that all token amount is 0   "}, {"title": "Unused WJLP can't be simply unwrapped", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/138", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  WJLP can only be unwrapped from the Active Pool or Stability Pool. A user who decided to wrap his JLP, but not use all of them in a trove, Wouldn't be able to just unwrap them.  ## Impact Impaired functionality for users. Would have to incur fees for simple unwrapping.  ## Proof of Concept The unwrap functionality is only available from `unwrapFor` function, and that function is only callable from AP or SP. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L149) ``` function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP(); ```  ## Recommended Mitigation Steps Allow anybody to call the function. As it will burn the holder's WJLP, a user could only unwrap tokens that are not in use.  "}, {"title": "WJLP will continue accruing rewards after user has unwrapped his tokens", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/136", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  WJLP doesn't update the inner accounting (for JOE rewards) when unwrapping user's tokens. The user will continue to receive rewards, on the expanse of users who haven't claimed their rewards yet.  ## Impact Loss of yield for users.  ## Proof of Concept The unwrap function just withdraws JLP from MasterChefJoe, burns the user's WJLP, and sends the JLP back to the user. It does not update the inner accounting (`userInfo`). [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L167) ```     function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP();         _MasterChefJoe.withdraw(_poolPid, _amount);         // msg.sender is either Active Pool or Stability Pool         // each one has the ability to unwrap and burn WAssets they own and         // send them to someone else         _burn(msg.sender, _amount);         JLP.transfer(_to, _amount);     } ```  ## Recommended Mitigation Steps Need to keep userInfo updated. Have to take into consideration the fact that user can choose to set the reward claiming address to be a different account than the one that holds the WJLP.  "}, {"title": "Gas saving in ShortLockupContract", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variables `yetiToken` and `unlockTime` inside the `ShortLockupContract` contract are never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  "}, {"title": "Use immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variable `yetiToken` inside the `LockupContract` contract is never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  "}, {"title": "Yeti token rebase checks the additional token amount incorrectly", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/121", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to `effectiveYetiTokenBalance` during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.  The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users\u2019 claims. In other words, the contract will be in default if enough users claim after that.  ## Proof of Concept  Now the whole balance amount is used instead of the amount bought back from market.  Rebasing amount is added to `effectiveYetiTokenBalance`, so it should be limited by extra Yeti tokens, not the whole balance: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L247  ## Recommended Mitigation Steps  It looks like only extra tokens should be used for the check, i.e. `yetiToken.balance - effectiveYetiTokenBalance`.  Now: ``` function rebase() external {   ...   uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));   uint256 valueOfContract = _getValueOfContract(yetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (yetiTokenBalance < additionalYetiTokenBalance) {     additionalYetiTokenBalance = yetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {   uint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```  As the `_getValueOfContract` function isn't used elsewhere, the logic can be simplified. To be: ``` function rebase() external {   ...   uint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);   uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (additionalYetiTokenBalance > adjustedYetiTokenBalance) {     additionalYetiTokenBalance = adjustedYetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```   "}, {"title": "BorrowerOperations and StabilityPool trove status check depends on the enumeration order", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Core system logic can break up if enumeration structure be updated.  ## Proof of Concept  BorrowerOperations and StabilityPool check the active status of a trove by comparing TroveManager's getTroveStatus with 1: BorrowerOperations: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L902 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L907 StabilityPool: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1104  TroveManagers inherit Status enumeration from TroveManagerBase: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TroveManagerBase.sol#L72  ## Recommended Mitigation Steps  With further system development it will be harder to track fixes needed on enumeration change. Consider implementing TroveManager.isTroveActive(borrower) where trove.status is checked against Status.active and the corresponding boolean is returned.   "}, {"title": "WJLP contract doesn't check for JOE and JLP token transfers success", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Transactions will not be reverted on failed transfer call, setting system state as if it was successful. This will lead to wrong state accounting down the road with a wide spectrum of possible consequences.  ## Proof of Concept  _safeJoeTransfer do not check for JOE.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L268  _safeJoeTransfer is called by _sendJoeReward, which is used in reward claiming.  JOE token use transfer from OpenZeppelin ERC20: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/JoeToken.sol#L9  Which does return success code: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L113  Trader Joe also uses checked transfer when dealing with JOE tokens: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L102   Also, unwrapFor do not check for JLP.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L166   ## Recommended Mitigation Steps  Add a require() check for the success of JOE transfer in _safeJoeTransfer function and create and use a similar function with the same check for JLP token transfers  "}]