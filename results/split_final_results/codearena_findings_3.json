[{"title": "getAMMOrderedAmounts and _exitTempusAmmAndRedeem functions use explicit token comparison for ordering instead of relying on Balancer's PoolTokens", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/37", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  hyh   # Vulnerability details  ## Vulnerability Details getAMMOrderedAmounts, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L692, and _exitTempusAmmAndRedeem, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L644, functions use explicit token comparison for ordering, while it is based on current Balancer pool implementation, which can change, leading to contract logic discrepancies.  In the same time _getAMMDetailsAndEnsureInitialized (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L673) do rely on PoolTokens, which obtain token list in Balancer's call sequence as follows: PoolTokens._getPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolBalances -> TwoTokenPoolsBalance._twoTokenPoolTokens[].  TwoTokenPoolsBalance._twoTokenPoolTokens[] is ordered during _registerTwoTokenPoolTokens, but this is current implementation.  It is safer to use vault.getPoolTokens(poolId) in getAMMOrderedAmounts to obtain an ordered pair.  This can matter as AMM token usage isn't symmetric (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L84).  ## Impact Probability here is low and risk rating is minimal, but the impact can vary as TempusController contract  logic rely on token ordering.  "}, {"title": "for loop with _TOTAL_TOKENS", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/36", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact The loop here is not really necessary as _TOTAL_TOKENS is a constant of 2 so there is always just 1 iteration:         for (uint256 i = 1; i < _TOTAL_TOKENS; ++i) {             uint256 currentBalance = balances[i];             if (currentBalance > maxBalance) {                 chosenTokenIndex = i;                 maxBalance = currentBalance;             }         }  ## Recommended Mitigation Steps Consider if you want to reduce gas usage by eliminating this loop here but taking the risk that _TOTAL_TOKENS will not be updated to a different value.  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/33", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. Examples of such imports are:   In TempusAMMUserDataHelpers   import \"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol\";  In TempusController   import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";  In TempusAMM   import \"@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol\";  ## Recommended Mitigation Steps Consider removing them to reduce deployment gas usage.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/30", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L375-L375  ```solidity uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0; ```  `maturityTime - currentTime` will never underflow.  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/29", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/aave/WadRayMath.sol#L59-L59  ```solidity require(a <= (type(uint256).max - halfWAD) / b, \"multiplication oveflow\"); ```  `oveflow` should be `overflow`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/VecMath.sol#L10-L10  ```solidity /// @dev Substracting two vectors ```  `Substracting` should be `Subtracting`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/lido/StETH.sol#L302-L302  ```solidity * @dev This is used for calaulating tokens from shares and vice versa. ```  `calaulating` should be `calculating`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L779-L779  ```solidity //  - endTime is alawys larger than startTime ```  `alawys` should be `always`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L47-L47  ```solidity /// @param recipient Address of user that recieved Yield Bearing Tokens ```  `recieved` should be `received`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L163-L163  ```solidity /// @param recipient Address of user that will recieve yield bearing tokens ```  `recieve` should be `receive`.  "}, {"title": "Gas: Don't store cToken twice", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/26", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  In `CompoundTempusPool`, the `cToken` and the base class' `yieldBearingToken` storage fields are the same. Remove the `cToken` field and the assignment in the constructor to save gas.   "}, {"title": "No `swap` slippage checks", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/23", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  The (second) `TempusController._exitTempusAmmAndRedeem` function swaps the difference of yield and principal shares using the AMM.  ```solidity swap(     tempusAMM,     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),     tokenIn,     tokenOut,     0 // @audit min return of zero ); // yields and principals are updated to the received amounts and redeemed // ... ```  It does not use a min return value for this swap and it is, therefore, susceptible to sandwich attacks.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone\u2019s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker\u2019s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  ## Impact Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the user's loss.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the transaction sender, then check that the actually received amount is above this parameter. Similar to `minLpAmountsOut` but for the yields & principal shares (or the redeemed tokens).  "}, {"title": "`exitTempusAMM` can be made to fail", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/21", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail. In `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares. The LP amounts to redeem are determined by the function parameter `lpTokensAmount`. A final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit. This is only true if no other LP shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `exitTempusAMM` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  "}, {"title": "`depositAndFix` can be made to fail", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/20", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail. In `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments. A final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap. This is only true if no other yield shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `depositAndFix` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  "}, {"title": "TempusAMM freezing all actions except proportional exit on maturity seems unnecessary", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/18", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced flexibility of AMM + additional gas costs on swaps  ## Proof of Concept  As the relative payouts of the principal and yield tokens are fixed at the point of finalisation, there's no need to freeze the AMM as it will just rapidly be arbed to the final prices of each token. No funds will be lost by LPs.  Making this change would reduce gas costs as swaps won't have to check maturity (load the TempusPool then perform SLOAD for maturity state variable).  ## Recommended Mitigation Steps  Remove `beforeMaturity` modifier from AMM.  "}, {"title": "Inheritance from BaseGeneralPool is unused", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/17", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  ## Proof of Concept  As the `TempusAmm` only ever registers with the Balancer Vault with the two token specialization the `GeneralPool` interface will never be used as the Vault will call the `MinimalSwapInfoPool` hooks instead.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L107-L110  See here in the Balancer Vault code:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/62c5cba7cae1d481f913c90fe0d9d94e101570c5/pkg/vault/contracts/Swaps.sol#L287-L292  ## Recommended Mitigation Steps  Remove the inheritance from `BaseGeneralPool` and remove the functions highlighted in the link below. This will help reduce bytecode from the AMM factory and reduce deployment costs.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L283-L309  "}, {"title": "Repeated token transfers on deposits are unnecessary", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/16", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Higher gas costs on transfers of tokens from user to TempusPool  ## Proof of Concept  Following the flow of tokens from the user to their the `TempusPool contract`:  1. User calls `TempusController.depositBacking`, `TempusController` transfers user's tokens to itself and approves relevant `TempusPool`  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L412-L414  2. `TempusController` calls `TempusPool.deposit` which in turn transfers tokens from the `TempusController` and then invests them.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L178  This first transfer is then superfluous as the `TempusPool` trusts the `TempusController` (it's the only contract which may call `deposit`). We're then incurring the costs of 1 `transfer` and 1 `approve` unnecessarily.  ## Recommended Mitigation Steps  As `TempusPool` trusts `TempusController`, `TempusController` can transfer the tokens directly to `TempusPool` and just tell it how much has been deposited.  L412-L414 of `TempusController.sol` would then be replaced with: ``` // Deposit to directly to targetPool uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, targetPool, yieldTokenAmount); ```  "}, {"title": "Use of `matured` storage variable is unnecessary", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/15", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs on several `TempusPool` functions  ## Proof of Concept  `TempusPool`s have a `finalize` function which checks whether `block.timestamp >= maturityTime` and flips the `maturity` storage variable as well as setting `maturityInterestRate` to the current interest rate.  https://github.com/tempus-finance/tempus-protocol/blob/0240b4d172d7aa093a70e0401f4140c99aa30dc6/contracts/TempusPool.sol#L126-L135  `maturity` is used in several places to check whether the pool has expired however checking this variable is more expensive than checking `block.timestamp >= maturityTime` (due to the need for a SLOAD whereas `maturityTime` is immutable so no SLOAD is needed). I'd recommend making a `function matured() public view` to keep the readability.  However `maturityInterestRate` still needs to be set correctly. This could be done by reading the current interest rate when `matured()` returns true but `maturityInterestRate == 0` this could cause issues with some functions which are currently view functions however.   ## Recommended Mitigation Steps  Half solution:  Replace `matured` state variable with a `matured()` view function which returns `maturityInterestRate > 0`. This removes an SSTORE from `finalize` and an `SLOAD` from any function which uses `maturityInterestRate` as you can just check if it's greater than zero to see if the pool has matured.  Full solution:   Replace `matured` state variable with a `matured()` view function which returns  `block.timestamp >= maturityTime`. This combined with setting `maturityInterestRate` when you see that `matured() == true` and `maturityInterestRate == 0` would remove the need for the `finalize` function entirely.  "}, {"title": "Param `initInterestRate` in `TempusPool::constructor` should not be 0", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/12", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact If `initInterestRate` in the `TempusPool`'s constructor is given as 0,  no funds can be withdrawn as `getRedemptionAmounts()` always panic errors with _division by 0_ ([link](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L305)).  ## Recommended Mitigation Steps It should be stated in the constructor's specs that `initInterestRate` should not be 0.  "}, {"title": "Make `protocolName` variables in protocol pools constant", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/11", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The `protocolName` variables in the protocol-specific `TempusPool`s are set as _immutable_ but could be set as _constant_.  See [Compound](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/CompoundTempusPool.sol#L19),  [Aave](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/AaveTempusPool.sol#L18),  [Lido](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/LidoTempusPool.sol#L9).  "}, {"title": "Steal tokens from TempusController", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/10", "labels": ["bug", "sponsor confirmed", "disagree with severity", "3 (High Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.  As the test contract of TempusController.sol https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.  The problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity.  tempusAMM could be a fake contract that supplies values that are completely fake.  At the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back any tokens held in the contract \"ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);\"  The Proof of Concept shows an approach to do this.    ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335  Create a fake Vault contract (fakeVault) with the following functions: fakeVault.getPoolTokens(poolId) --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0 fakeVault.JoinPoolRequest() --> do nothing fakeVault.joinPool() --> do nothing  Create a fake Pool contract (fakePool) with the following functions: fakePool.yieldBearingToken() --> returns fakeYieldBearingToken fakePool.deposit() --> returns fakeMintedShares,....  Create a fake ammTokens contract with the following functions: tempusAMM.getVault() --> returns fakeVault tempusAMM.getPoolId() --> returns 0 tempusAMM.tempusPool() --> returns fakePool   call depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken _getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2} _deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares _provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts _provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))  the calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked. _provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts  Now fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender  As you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender  ## Tools Used  ## Recommended Mitigation Steps Create a whitelist for tempusAMMs   "}, {"title": "PermanentlyOwnable does not prevent transferring ownership to a dead address.", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/9", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  chenyu   # Vulnerability details  ## Impact [PermanentlyOwnable](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/utils/PermanentlyOwnable.sol) does not prevent transferring to a dead address. It's possible to have a human error that transfers the contract ownership to a address not owned by the old owner.  ## Recommended Mitigation Steps Recommend a two step transfer that owner nominates an account, then the nominated account call an accept function to ensure the nominated account is valid.  "}, {"title": "Scaling factors for token 0/1 might swap in TempusAMM constructor.", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/7", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  chenyu   # Vulnerability details  ## Impact In TempusAMM constructor [L138](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L138), the scaling factor 0 always maps to yieldShare, and scaling factor 1 always maps to principalShare, even though in L134 the two token might swap if principalShare < yieldShare, which makes _token0 = principalShare and _token1 = yieldShare, but scaling factor 0 is based on yieldShare.  Later [_scalingFactor](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L802) is based on _token0, so it might get the wrong scaling factor if principalShare and yieldShare had swapped.  ## Recommended Mitigation Steps Update the lines to ```         _scalingFactor0 = _computeScalingFactor(IERC20(address(_token0)));         _scalingFactor1 = _computeScalingFactor(IERC20(address(_token1))); ```  "}, {"title": "No zero address check for controller in TempusPool", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/6", "labels": ["bug", "sponsor confirmed", "disagree with severity", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  loop   # Vulnerability details  TempusPool needs to be initialized with a valid and existing controller. When initializing a pool `address controller` is passed to the constructor of a pool implementation. This `address` is then passed as `address ctrl` to the TempusPool constructor where it is set to the immutable `address controller`. If a pool accidentally gets initialized with the zero address passed to the constructor there is no way to change it and the pool needs to be reinitialized.  ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L66-L100  ## Recommended Mitigation Steps Add something along the lines of `require(ctrl != address(0), \"controller can not be zero` to avoid potential invalid pool initializations.   "}, {"title": "Named Return Issues", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/4", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  AaveTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/AaveTempusPool.sol#L74  LidoTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/LidoTempusPool.sol#L59  TempusAMM.sol: Unneeded return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L533  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return variables or return.  "}, {"title": "LibBytes uses itself", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/58", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I don't think it's necessary for the library to use itself here:   library LibBytes {     using LibBytes for bytes;  ## Recommended Mitigation Steps Remove this 'using' statement as it does not give anything in this case.  "}, {"title": "Duplicate math operations", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/57", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact First perform the addition and only then check the length to avoid this duplicate math operation:     require(b.length >= index + 32, \"BytesLib: length\");     // Arrays are prefixed by a 256 bit length parameter     index += 32; Or if you want to stay with this approach, then at least consider using the 'unchecked' keyword when this addition is performed the second time as then ready know this can't overflow. Also, in function recoverAddrImpl the same operation is performed twice:   sig.length - 33  ## Recommended Mitigation Steps Refactor duplicate math operations.  "}, {"title": "ecrecover may return empty address", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/56", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is a common issue that ecrecover returns empty (0x0) address when the signature is invalid. function recoverAddrImpl should check that before returning the result of ecrecover.  ## Recommended Mitigation Steps See the solution here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L68  "}, {"title": "block.chainid may change in case of a hardfork", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/55", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact The 'DOMAIN_SEPARATOR' is not recalculated in the case of a hard fork. The variable DOMAIN_SEPARATOR in contract QuickAccManager is cached in the contract storage and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  A similar issue was reported in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  "}, {"title": "Hardcoded WETH", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/54", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact WETH address is hardcoded but it may differ on other chains, e.g. Polygon, so make sure to check this before deploying and update if neccessary:   address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  ## Recommended Mitigation Steps You should consider injecting WETH address via the constructor.  "}, {"title": "lack of require message", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/53", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact require message give the idea what was the cause of failure , so its the best practise to  add message in require()  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L218  ## Tools Used manual reveiw  ## Recommended Mitigation Steps add message in require()  "}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/51", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of contract used floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  "}, {"title": "Inconsistent code style of for loops", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/45", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  Most of the for loops in the codebase use `<` to control the loop:  ```solidity for (uint i=0; i<len; i++) { ```  However, in `Zapper.sol`, all 7 for loops are using `!=`:  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  ```solidity for (uint i=0; i!=spenders.length; i++) { ```  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87   https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L110-L110  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131-L131  Using `for (uint i=0; i!=len; i++) {}` to control for loops introduces inconsistent code style.  ### Recommendation  Change from `!=` to `<` for all for loops.  "}, {"title": "Gas: `SignatureValidatorV2.recoverAddrImpl` should use `else if`", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/42", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SignatureValidatorV2.recoverAddrImpl` function currently uses three `if (mode == *)` checks but the modes are all distinct enum values and therefore an `else if` can be used. This is more efficient because if the first branch is already matched, there's no need to check the `mode` against the remaining values anymore.  "}, {"title": "Gas: `BytesLib` addition can be unchecked", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/41", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  The `index += 32` addition in `readBytes32` can be put in an `unsafe` block as the array length is already checked to be greater than the addition.  "}, {"title": "QuickAccManager Smart Contract signature verification can be exploited", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/40", "labels": ["bug", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:  ```solidity address signer = SignatureValidator.recoverAddrImpl(hash, signature, true); // signer will be QuickAccountContract require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE'); ```  It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:  ```solidity // @audit id is attacker-controlled (address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes)); // @audit this may not be used for authorization, attacker can return desired value if (Identity(id).privileges(address(this)) == accHash) {   // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")   return 0x1626ba7e; } else {   return 0xffffffff; } ```  ## POC  Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.  We can construct a `SignatureMode.SmartWallet` signature for an _arbitrary_ hash: 1. Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)` 2. This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))` 3. The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value. 4. The checks in `Identity.execute` pass and the transactions `txns` are executed.  ## Impact Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.  ## Recommendation The issue is that `QuickAccManager` blindly trusts the values in `signature`. It might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`. This seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity. In that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.   "}, {"title": "Signature replay attacks for different identities (nonce on wrong party)", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/39", "labels": ["bug", "duplicate", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  A single `QuickAccount` can serve as the \"privilege\" for multiple identities, see the comment in `QuickAccManager.sol`:  > NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]. this is by design  If there exist two different identities that _both share the same QuickAccount_ (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:  Upon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker by calling `send` with the same arguments and just changing the `identity` to the second identity.  This is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.  Two fresh identities will both take on nonces on zero and lead to the same hash.  ## Impact Transactions on one identity can be replayed on another one if it uses the same `QuickAccount`. For example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.  ## Recommended Mitigation Steps 1. Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the _signer_ (`QuickAccount` in this case), not on the target contract to call. 2. The `identity` _address_ itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.  ## Other occurrences This issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`: - `cancel`: attacker can use the same signature to cancel the same transactions on the second identity - `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted. - `sendTransfer`: same transfers can be replayed on second identity - `sendTxns`: same transactions can be replayed on second identity   "}, {"title": "If zero address is added as privilege anyone can execute arbitrary transactions", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/37", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SignatureValidator.recoverAddrImpl` function does not revert on invalid signatures and returns zero instead. Thus if anyone added the zero address to their `privileges` by accident, funds can be stolen in `Identity.execute`.  ## Recommended Mitigation Steps Unless there's a valid reason for the `SignatureMode.NoSig` mode, consider reverting if `ecrecover` returns the zero address indicating an invalid signature.   "}, {"title": "`QuickAccManager.sol` Constants should be marked as `constant`", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/31", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L128-L128  The variables `TRANSFER_TYPEHASH`, `TXNS_TYPEHASH`, `BUNDLE_TYPEHASH` are named in all caps, which implies that they are constants. However, they are not being marked as `constant`. Mark them as `constant` can also help save some gas.  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/30", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `scheduled[hashTx]` in `QuickAccManager.sol#cancel()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L92-L92  - `scheduled[hash]` in `QuickAccManager.sol#execScheduled()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L102-L102  "}, {"title": "Unnecessary storage variables", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/29", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L69-L72  Some storage variables include `admin`, `lendingPool` and `aaveRefCode` are unnecessary as they will never be changed.  Change to `immutable` can save gas.  "}, {"title": "`Zapper.sol#tradeV3Single()` Remove unnecessary variable can make the code simpler and save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/28", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  At L149, `params.recipient` is read and put into a local variable `recipient`. However, `recipient` is only read once when `wrapOutputToLending` is true. Thus, the variable `recipient` is unnecessary.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L147-L159  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     address recipient = params.recipient;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);     }     return amountOut; } ```  ### Recommendation  Change to:  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, params.recipient, aaveRefCode);     }     return amountOut; } ```  "}, {"title": "`Zapper.sol#wrapETH()` Use `WETH.deposit` can save some gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/27", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L137-L140  ```solidity function wrapETH() payable external {     // TODO: it may be slightly cheaper to call deposit() directly     payable(WETH).transfer(msg.value); } ```  ### Recommendation  Change to:  ```solidity interface IWETH {     function deposit() external payable; } function wrapETH() payable external {     IWETH(WETH).deposit{ value: msg.value }(); } ```  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/26", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `Zapper.sol#constructor()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  - `Zapper.sol#approveMaxMany()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87  - `Zapper.sol#exchangeV2()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L104-L104  - `Zapper.sol#wrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  - `Zapper.sol#unwrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131  - `QuickAccManager.sol#sendTxns()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L162-L162  "}, {"title": "`QuickAccManager.sol#send()` Avoid unnecessary read from storage can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/25", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#send()`, `nonces[address(identity)]` is being read 2 times (1st at L58, 2nd at L64), the second read is unnecessary, cache it in the stack at the first read can save some gas.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L55-L67  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)];     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         nonces[address(identity)]++,         txns,         sigs.isBothSigned     )); ```  ### Recommendation  Change to:  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)]++;     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         initialNonce,         txns,         sigs.isBothSigned     )); ```  "}, {"title": "Assignment Of Variable To Default (Identity.sol)", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/17", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  A variable is being assigned its default value which is unnecessary. Removing the assignment will save gas when deploying.  ## Proof of Concept  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L9  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the assignment.  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/16", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L33 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L55 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L59 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L64 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L65  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  "}, {"title": "Compare with 0 and 1 in a more efficient way", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/15", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function setAddrPrivilege of Identity.sol the value of privileges[addr] is compare to 0 and 1 in the following way: \"if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))\"  As 0 and 1 are adjacent, you could also check \"uint(privileges[addr]) > 1\". This saves a (small amount) of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L59  ## Tools Used  ## Recommended Mitigation Steps replace if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1))) ... with if (uint(privileges[addr]) > 1) ...  "}, {"title": "Prevent execution with invalid signatures", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/13", "labels": ["bug", "duplicate", "sponsor confirmed", "disagree with severity", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose one of the supplied addrs[i] to the constructor of Identity.sol happens to be 0 ( by accident).  In that case: privileges[0] = 1  Now suppose you call execute() with an invalid signature, then recoverAddrImpl will return a value of 0 and thus signer=0. If you then check \"privileges[signer] !=0\"  this will be true and anyone can perform any transaction.  This is clearly an unwanted situation.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98  ## Tools Used  ## Recommended Mitigation Steps In the constructor of Identity.sol, add in the for loop the following: require (addrs[i] !=0,\"Zero not allowed\");  "}, {"title": "IdentityFactory.withdraw can be external", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/10", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  loop   # Vulnerability details  The `withdraw` function in `IdentityFactory.sol` is declared as public but can be external since it is not used internally.  ## Impact Saves some gas in case it ever needs to be called.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/IdentityFactory.sol#L52  "}, {"title": "Set `QuickAccManager::CANCEL_PREFIX` as constant", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/7", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `CANCEL_PREFIX` in the `QuickAccManager` is never reset after initialization. Declaring it as a constant saves gas.  "}, {"title": "Set `IdentityFactory::creator` as immutable", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/6", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `creator` in the `IdentityFactory` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  "}, {"title": "Set `QuickAccManager::DOMAIN_SEPARATOR` as immutable", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/4", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `DOMAIN_SEPARATOR` in the `QuickAccManager` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  "}, {"title": "Address with privilege for QuickAccount with `address(0)`'s can execute arbitrary transactions", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/3", "labels": ["bug", "sponsor confirmed", "disagree with severity", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact If a caller has privileges for a QuickAccount consisting of two `address(0)`'s, then the caller can execute arbitrary transactions through the  `QuicAccManager::send()` function.  ## Proof of Concept A caller of the `QuickAccManager::send()` needs to be privileged for the  QuickAccount the caller provides as argument ([line 57](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L57)).  As an arbitrary value can be set as `privileged[caller]` in `Indentity.sol`, so can a QuickAccount struct consisting of two `address(0)`'s.  The following calls to `SignatureValidator::recoverAddr()` (line 69, 70 and 73) can be made to always return `address(0)` if the signature has  `SignatureMode.NoSig`.  As the signature is provided as argument in `QuickAccManager::send()`, the  caller has total control of it.  The checks in line [69, 70](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L69) and [73](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L73) now always pass as long as the accounts in the QuickAccount struct are  `address(0)` too.  Therefore, a caller with permissions for such a QuickAccount can execute and  schedule arbitrary transactions without the need for valid signatures.  ## Tools Used -  ## Recommended Mitigation Steps Add a check in the `QuickAccManager::send()` function to forbid  QuickAccounts with `address(0)`.  "}, {"title": "`QuickAccManager.sol#cancel()` Wrong `hashTx` makes it impossible to cancel a scheduled transaction", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/1", "labels": ["bug", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.  As a result, users will be unable to cancel a scheduled transaction.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91  ```solidity=81{91} function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');      bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));     address signer = SignatureValidator.recoverAddr(hash, sig);     require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');      // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief     // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled     bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));     require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');     delete scheduled[hashTx];      emit LogCancelled(hashTx, accHash, signer, block.timestamp); } ```  ### Recommendation  Change to:  ```solidity bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false)); ```  "}, {"title": "Math's operations order in Swivel's functions", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact There are multiple instances of divisions performed before multiplications, whereas the opposite is generally suggested. To mitigate the precision loss, a factor like `1e18` is multiplied and then divided, but this solution is arbitrary and can be avoided.  For example: ```js uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18; ```  can be rewritten like: ```js uint256 principalFilled = a * o.principal / o.premium; ```  ## Proof of Concept Run `grep '1e18' Swivel.sol` for a complete list.  ## Tools Used grep, editor  ## Recommended Mitigation Steps Suggested checking all instances and trying to simplify the math.  "}, {"title": "Better Math in `calculateReturn`", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact `Marketplace.calculateReturn` can be rewritten from: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate   uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;   uint256 interest = (yield * a) / 1e26;    // calculate the total amount of underlying principle to return   return a + interest; } ```  to: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   uint256 rate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();   return  a*rate/ maturityRate[u][m]; } ```  Less math operations means less approximations and less gas used.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L160-L167  ## Tools Used editor  "}, {"title": "'matured' can be replaced by 'maturityRate' > 0", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact boolean flag 'matured' could be removed if you agree to accept maturityRate > 0 as a matured vault, basically replacing:   require(!matured, 'already matured'); with:   require(maturityRate == 0, 'already matured'); This would eliminate one storage variable and thus reduce gas usage. The risk is that exchangeRateCurrent can never be 0 as this would mean an immature state.  ## Recommended Mitigation Steps Consider getting rid of 'matured' as per suggestion.   "}, {"title": "Functions returning boolean", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why there are many functions that always return a boolean value of true. While this may be your agreed practice that you try to follow, it also incurs more gas consumption as the caller needs to receive and check these returned values.  ## Recommended Mitigation Steps If you want to optimize for gas, consider dropping return values for functions that actually do not need them.  "}, {"title": "'onlyAdmin' and 'onlySwivel' modifiers", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Having both modifiers 'onlyAdmin' and 'onlySwivel' is not only more expensive but also misleading as these modifiers basically do the same job of checking an address against msg.sender.  ## Recommended Mitigation Steps Better have a generalized modifier, something like onlyAddress(address a), and re-use it with both admin and swivel:   modifier onlyAddress(address a) {     require(msg.sender == a, 'sender not authorized');     _;   }   onlyAddress(admin)   onlyAddress(swivel)  "}, {"title": "Underlying can be fetched from cToken", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/142", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When creating the market (function createMarket), you do not need to specify the address of underlying, it would be less error-prone to dynamically get this from cToken: https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol#L254   ## Recommended Mitigation Steps While only the admin can create new markets, I think it would still be nice to algorithmically ensure that this underlying token belongs to this cToken and do not leave a chance for human errors.  "}, {"title": "Redundant `require` in Swivel.sol", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The line:     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');  in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L171  Is checking for the return value of `MarketPlace.p2pZcTokenExchange`, however `p2pZcTokenExchange` will always return true or revert  As such the require is not necessary, and doesn't provide any additional guarantees.  ## Recommended Mitigation Steps  Replace `     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed'); `  With  ` MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a) `  "}, {"title": "require(mPlace.custodialExit) in Swivel.sol is redundant", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `custodialExit` in Marketplace.sol: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L194  Always returns true or reverts  In swivel.sol the check  `require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); ` will always pass, unless the function `custodialExit` reverts  This extra require is not necessary, and provides no additional guarantees as `custodialExit` will always return true or revert   ## Recommended Mitigation Steps Replace ` require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); `  With ` mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a) `  "}, {"title": "Swivel.sol - marketplace is an immutable address, yet is always casted to MarketPlace - store as MarketPlace to make code cleaner", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The variable `marketplace` in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L21  is stored as an immutable address  However, every single instance of it's usage casts it to `MarketPlace`  Would recommend storing `marketplace` as `MarketPlace` to make the code cleaner   ## Recommended Mitigation Steps Replace `  address public immutable marketPlace; ` With `   Marketplace public immutable marketPlace; `  "}, {"title": "Bounded array lengths or checking gasleft will save gas from OOGs", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Swivel initiate() and exit() functions accept unbounded arrays from users which may lead to OOG exceptions with insufficient gas sent in transaction.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L55-L77  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L209-L234  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Bounding array lengths or checking gasleft are a good idea to reduce risk of OOG and save user\u2019s gas.  "}, {"title": "Avoiding initialization of loop index can save a little gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.  "}, {"title": "+= can be replaced by =", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  to.notional += a  can be replaced by to.notional = a because to.notional = 0 in the else part. This will save a few MLOADs.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L189  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Replace to.notional += a  by to.notional = a  "}, {"title": "Removing redundant require() can save gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The require(matureMarket(u, m) is redundant because matureMarket always returns true and reverts if any of its require() check fails.  Removing this can save a little gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L127  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L75-L91  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove redundant require()  "}, {"title": "Caching state variables in local/memory variables avoids SLOADs to save gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are few places across contracts where the same state variables are read multiple times or the same external calls are made multiple times within a function. Caching state variables or results from external calls in local/memory variables avoids SLOADs and CALLs to save gas. Warm SLOADs cost 100 gas and CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache swivel: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L61-L64  Cache markets[u][m]: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L76-L86  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L99-L100  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L111-L112  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L181-L182  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L195-L196   Cache matured and maturityRate: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L156-L179\\  Cache vaults: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L244   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Cache state variables or results from external calls in local/memory variables to save gas.  "}, {"title": "Missing input validation, threshold check, event and timelock in setFee function", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The setFee onlyAdmin function sets the fee denominator but does not perform input validation to check that the fenominator index is between 0-3 which are the only valid values for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit].  The onlyAdmin function performs no threshold check on the new values, emits no event and immediately changes the fenominator value to any arbitrary value proposed by the admin.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L399-L405  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L23-L24  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L46  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Add input validation, threshold check, event and timelock  "}, {"title": "Compact signatures not being supported could lead to DoS", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  This implementation of Sig.sol doesn\u2019t support compact signature (EIP-2098), where signature length can be 64 bytes instead of 65, as supported in the widely used OpenZeppelin\u2019s ECDSA library. This lack of support could lead to DoS for users/clients that use compact signatures.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Sig.sol#L41  See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1b27c13096d6e4389d62e7b0766a1db53fbb3f1b/contracts/utils/cryptography/ECDSA.sol#L57  https://eips.ethereum.org/EIPS/eip-2098  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support for compact signatures, use OZ ECDSA library or highlight in documentation about this lack of support for EIP-2098.  "}, {"title": "Use of ecrecover is susceptible to signature malleability", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The\u00a0ecrecover\u00a0function is used to verify and execute EIP-2612 permit transactions. The built-in EVM precompile ecrecover is susceptible to signature malleability (because of non-unique s and v values) which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   While this is not exploitable for replay attacks in the current implementation because of the use of nonces, this may become a vulnerability if used elsewhere.   ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/tokens/Erc2612.sol#L48  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Consider using OpenZeppelin\u2019s ECDSA library (which prevents this malleability) instead of the built-in function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol  "}, {"title": "Abstract contracts should really be interfaces", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Interfaces are not allowed to define any functions while abstract contracts can have a few defined functions (with at least one undefined function). Abstract contracts declared in the project should really be interfaces because they do not define any functions.   Keeping them abstract is risky because they allow defining functions that may be mistakenly exposed in inherited contracts. Interfaces by design prevent this security risk.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Abstracts.sol#L5-L40  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Convert contracts that do not define any functions to interfaces.  "}, {"title": "Different parameter used in  while emitting event", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact In matureMarket(address u, uint256 m) function , different parameter is used in event      emit Mature(u, m, block.timestamp, currentExchangeRate);  maturity rate should before matured timestamp //   event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);  impact of this can be severe .   This   error   may   negatively   impact    off-chain   tools   that   are   monitoring   events data  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L88  ## Tools Used manual review  ## Recommended Mitigation Steps   "}, {"title": "Gas: Approve `cToken` address only once for underlying", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Swivel` contract approves the `cToken` address whenever it wants to mint `cTokens` upon order fulfilment, see `initiateVaultFillingZcTokenInitiate`.  It could just approve the `cToken` contract once for each market underlying it supports with the max value and save the approval call for each order fulfilment.   "}, {"title": "Missing Dev Comments", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `cTokenAddress()` getter function in `MarketPlace.sol` is missing relevant dev comments and appropriate matching syntax. `address a` does not correctly match the proper representation which is the underlying token, typically referenced as `address u`.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L169-L171  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding relevant dev comments and updating `address a` -> `address u` to better reflect its meaning.  "}, {"title": "transferNotionalFrom doesn't check from != to", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/65", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  gpersoon   # Vulnerability details  # Impact The function transferNotionalFrom of VaultTracker.sol uses temporary variables to store the balances. If the \"from\" and \"to\" address are the same then the balance of \"from\" is overwritten by the balance of \"to\". This means the balance of \"from\" and \"to\" are increased and no balances are decreased, effectively printing money.  Note: transferNotionalFrom can be called via transferVaultNotional by everyone.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/vaulttracker/VaultTracker.sol#L144-L196   function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {     Vault memory from = vaults[f];     Vault memory to = vaults[t];     ...     vaults[f] = from;     ...     vaults[t] = to;    // if f==t then this will overwrite vaults[f]    https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L234-L238 function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {     require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');     ## Tools Used  ## Recommended Mitigation Steps Add something like the following:    require (f != t,\"Same\");  "}, {"title": "Prevent underflow in require", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "sponsor disputed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The contract Swivel.sol contains a few of the following requires:  require(a <= (o.premium - filled[hash]), 'taker amount > available volume');    If \"o.premium\" happens to be smaller than \"filled[hash]\", a revert will occur at \"o.premium - filled[hash]\" and no error message will be displayed.  Also note the statements use slightly different syntax with the parentheses.   ## Proof of Concept Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require((a <= o.principal  - filled[hash]),  'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume');  ## Tools Used  ## Recommended Mitigation Steps replace  require(a <= (o.xxxx - filled[hash]), 'taker amount > available volume');   with  require( (a + filled[hash]) <= o.xxxx), 'taker amount > available volume');  Use the same parentheses structure everywhere.  "}, {"title": "Sig.split function could be private instead internal.", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pants   # Vulnerability details  The Sig.split function (defined at Line 40 of Sig library) is called only inside the library. Thus function could be set as private.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Sig.sol#L40  ## Recommended Mitigation Steps Make it private :)  ## Tool Used Manual code review.   "}, {"title": "Title: Double reading from calldata o", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "# Handle  pants   # Vulnerability details  At both line 59 and 61 the code reads o[i]. It happens inside a loop therefore the best practice which is more gas efficient is to cache o[i] once and use it instead.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Swivel.sol#L59  ## Tool Used Manual code review.   "}, {"title": "Complex state variable copied to memory in redeemZcToken (MarketPlace.sol)", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Operating on a copy of a state variable seems inefficient and confusing in this case.   From a \"gas\" standpoint it's less efficient.  And future changes could render the addresses in the copied struct invalid if functions being called in redeemZcToken operate on the original state variable.  ## Proof of Concept The copy occurs here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  The \"mkt\" variable is referenced here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove line #123: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  Replace \"mkt\" with \"markets[u][m]\" in line #131 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131   "}, {"title": "Swivel: Taker is charged fees twice in exitVaultFillingVaultInitiate", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/39", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Taker is charged fees twice in `exitVaultFillingVaultInitiate()` . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled - 2*fee  ## Recommended Mitigation Steps  ```jsx function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= (o.principal - filled[hash]), 'taker amount > available volume');          filled[hash] += a;              uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;      Erc20 uToken = Erc20(o.underlying);     // transfer premium from maker to sender     uToken.transferFrom(o.maker, msg.sender, premiumFilled);      // transfer fee in underlying to swivel from sender     uToken.transferFrom(msg.sender, address(this), fee);      // transfer <a> vault.notional (nTokens) from sender to maker     require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');      emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  "}, {"title": "Swivel: implementation for initiateZcTokenFillingZcTokenExit is incorrect", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  In `initiateZcTokenFillingZcTokenExit()` , this comment `// transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)`  is incorrect because you are actually transferring the underlying tokens - premium paid to the maker (from sender) AND you have to pay fee separately to swivel.  initiateZCTokenFillingZcTokenExit means I want to sell my nTokens so that means `a` is the amount of principal I want to fill. Let's use a hypothetical example where I (taker) wants to fill 10 units of ZcTokenExit for maker.  1. I transfer 10 units of underlying to Swivel. The net balances are: me (-a), swivel (+a) 2. I transfer fee (in underlying) to Swivel. The net balances are: me (-a-fee), swivel (+a+fee)  3. Swivel initiates my position, sends me the ZcToken and sends Maker the nTokens 4. Maker pays me premiumFilled for the nTokens. The net balances are: me (-a-fee+premiumsFilled), swivel (+a+fee), maker (-premiumsFilled) 5. Maker closes position. The net balances are: me (-a-fee+premiumsFilled), swivel (+fee), maker (-premiumsFilled+a)  So effectively, I (taker) should be paying a-premium to maker and fee to swivel.  ## Recommended Mitigation Steps  ```jsx function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= o.principal - filled[hash]), 'taker amount > available volume'); // Note: you don't need to wrap these in brackets because if you look at the https://docs.soliditylang.org/en/latest/cheatsheet.html#order-of-precedence-of-operators, subtraction will always go before comparison       filled[hash] += a;      uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;      // transfer underlying tokens - the premium paid in underlying to maker (from sender)     Erc20(o.underlying).transferFrom(msg.sender, o.maker, a - premiumFilled);   Erc20(o.underlying).transferFrom(msg.sender, swivel, fee);     // transfer <a> zcTokens between users in marketplace     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');                  emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  "}, {"title": "Swivel: Implement check effect interaction to align with best practices", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  There is no impact to the funds but to align with [best practices]([https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)), it is always better to update internal state before any external function calls.  ## Recommended Mitigation Steps  For functions `exitVaultFillingZcTokenExit()` and `exitZcTokenFillingVaultExit()`, you should do `mPlace.custodialExit(...)` to update the internal accounting before transferring the tokens out.  "}, {"title": "Swivel: Incorrect dev comments for the 4 initiate functions", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Misleading comments  ## Recommended Mitigation Steps  For these 4 functions, it should say \"taker's init\" instead of \"taker's exit\"  "}, {"title": "VaultTracker.sol: init sVault.exchangeRate in constructor", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation. In the function `transferNotionalFee()`,  `sVault.exchangeRate` is only 0 for the very first time this function is called so the if check to see if `sVault.exchangeRate != 0` is only used once to handle this edge case.  It makes more sense to set the exchangeRate when the vault is created and remove these if conditions.  ## Recommended Mitigation Steps  ```jsx constructor(uint256 m, address c, address s) {    admin = msg.sender;    maturity = m;    cTokenAddr = c;    swivel = s;   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   vault[swivel] = Vault({        notional: 0,        redeemable: 0,        exchangeRate: exchangeRate    }); } ... function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {     Vault memory oVault = vaults[f];     Vault memory sVault = vaults[swivel];      // remove notional from its owner     oVault.notional -= a;      uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();     uint256 yield;     uint256 interest;      // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate     if (sVault.exchangeRate != exchangeRate) {        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate        // otherwise, calculate marginal exchange rate between current and previous exchange rate.        if (matured) {            // calculate marginal interest            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;        } else {            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;        }          interest = (yield * sVault.notional) / 1e26;        sVault.redeemable += interest;       sVault.exchangeRate = exchangeRate;     }      // add notional to swivel's vault     sVault.notional += a;      // store the adjusted vaults     vaults[swivel] = sVault;     vaults[f] = oVault;     return true;   } ```  "}, {"title": "VaultTracker.sol: pass in exchangeRate as a variable to matureVault()", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Since you are already querying the exchangeRate for the current block in `MarketPlace.matureMarket()` , might as well pass it along to `VaultTracker.sol` instead of querying it a second time.  ## Recommended Mitigation Steps  ```jsx // In VaultTracker.sol function matureVault(uint256 _maturityRate) external onlyAdmin(admin) returns (bool) {    require(!matured, 'already matured');    require(block.timestamp >= maturity, 'maturity has not been reached');    matured = true;   maturityRate = _maturityRate;    return true; } ```  ```jsx // In MarketPlace.sol function matureMarket(address u, uint256 m) public returns (bool) {    require(!mature[u][m], 'market already matured');    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), \"maturity not reached\");      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault \"matured\" to true   require(VaultTracker(markets[u][m].vaultAddr).matureVault(currentExchangeRate), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  "}, {"title": "MarketPlace.sol: Remove maturity from VaultTracker and ZcToken", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  You don't need to store maturity in `VaultTracker.sol` or `ZcToken.sol` because `mapping (address => mapping (uint256 => bool)) public mature;` should already cover it. This will help to remove unnecessary external calls and also reduce the number of maturity checks.  ## Recommended Mitigation Steps  ```jsx // In MarketPlace.sol function createMarket(    address u,    uint256 m,    address c,    string memory n,    string memory s,    uint8 d ) public onlyAdmin(admin) returns (bool) {    require(swivel != address(0), 'swivel contract address not set');    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?   address zctAddr = address(new ZcToken(u, n, s, d));    address vAddr = address(new VaultTracker(c, swivel));    markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true; } ... function matureMarket(address u, uint256 m) public returns (bool) {   require(block.timestamp >= m, \"maturity not reached\");    require(!mature[u][m], 'market already matured');      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault \"matured\" to true    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  ```jsx  // In VaultTracker.sol ... // uint256 public immutable maturity; // deleted this ... constructor(address c, address s) {    admin = msg.sender;    cTokenAddr = c;    swivel = s; } ... function matureVault() external onlyAdmin(admin) returns (bool) {    matured = true;    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();    return true; } ```  ```jsx // uint256 public immutable maturity; // deleted this ... constructor(address u, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {    admin = msg.sender;    underlying = u; } ```  "}, {"title": "VaultTracker.sol: Gas optimisation for addNotional", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas op. Since vlt.notional has to be updated in both branches of the if check, you can take vlt.notional out of both branches and skip the else check.  ## Recommended Mitigation Steps  ```jsx function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   Vault memory vlt = vaults[o];      if (vlt.notional > 0) {      uint256 yield;      uint256 interest;          // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate      // otherwise, calculate marginal exchange rate between current and previous exchange rate.      if (matured) { // Calculate marginal interest         yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;      } else {         yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;      }          interest = (yield * vlt.notional) / 1e26;      // add interest and amount to position, reset cToken exchange rate      vlt.redeemable += interest;       }      vlt.notional += a;   vlt.exchangeRate = exchangeRate;   vaults[o] = vlt;      return true; } ```  "}, {"title": "Use bytes32 rather than string/bytes", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.   ## Proof of Concept  1. Navigate to \"https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol\" contract. 2. Investigate createMarket function. n and s variables can be replaced with bytes32 variable.  ```   function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d   ) public onlyAdmin(admin) returns (bool) {     require(swivel != address(0), 'swivel contract address not set');     // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?     address zctAddr = address(new ZcToken(u, m, n, s, d));     address vAddr = address(new VaultTracker(m, c, swivel));     markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true;   } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to replace string variables with bytes32. That should be definitely cheaper.   "}, {"title": "Array .length Used Directly In For Loops", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  There is additional gas usage when an array's length value is used directly in a \"for\" loop.  ## Proof of Concept  The array's length value is used directly in a for loop here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the loops above from: <code> for (uint256 i=0; i < o.length; i++) </code>  to <code> unit256 length = o.length; for (uint256 i=0; i < length; i++) </code>  When I tested these changes there was a small gas saving.   "}, {"title": "createMarket function missing parameter description", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  loop   # Vulnerability details  the parameter `uint8 d` of the `createMarket` function is lacking a parameter description in function spec.    ## Impact No direct impact, but with the parameter naming scheme of only using the first letter of its description the parameter spec is essential.  ## Proof of Concept Code snippet for funciton spec + declaration: ``` /// @notice Allows the owner to create new markets /// @param u Underlying token address associated with the new market /// @param m Maturity timestamp of the new market /// @param c cToken address associated with underlying for the new market /// @param n Name of the new zcToken market /// @param s Symbol of the new zcToken market function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d ) public onlyAdmin(admin) returns (bool) ```  ## Recommended Mitigation Steps Add parameter spec for `uint8 d`  "}, {"title": "Wrong parameter name used in function spec", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  loop   # Vulnerability details  Line 124 of Swivel.sol describes the parameter `uint256 a`, but has wrong parameter name: `/// @param o Amount of volume (principal) being filled by the taker's exit`  ## Impact No direct impact apart from code readability  ## Proof of Concept Code snippet for function declaration + spec: ``` /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order   /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate   /// @param o Order being filled   /// @param o Amount of volume (principal) being filled by the taker's exit   /// @param c Components of a valid ECDSA signature   function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal ```  ## Recommended Mitigation Steps Change the second `o` to `a`  "}, {"title": "token out of range check can be simplified", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Because 'token' is of type uint here, this comparison can be simplified to reduce gas costs:   require(token == 0 || token == 1, \"Pool: token out of range\"); //before  ## Recommended Mitigation Steps   require(token < 2, \"Pool: token out of range\"); //after  "}, {"title": "Useless multiplication by 1", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Uneccesarry multiplication by 1 here:   require(initialization._fee < 1 * PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\");  ## Recommended Mitigation Steps   require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\");  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas.   Examples of such imports are:   in contract PoolKeeper import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\"; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"@openzeppelin/contracts/proxy/Clones.sol\";  imported twice: import \"../interfaces/IERC20DecimalsWrapper.sol\";  in contract PoolCommitter import \"../interfaces/IOracleWrapper.sol\";  ## Recommended Mitigation Steps Remove unnecessary imports.  "}, {"title": "Immutable state variables", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: scaler and oracle in ChainlinkOracleWrapper, factory in PoolCommitterDeployer, poolName in LeveragedPool and there are many more.  ## Recommended Mitigation Steps Consider applying 'immutable' to reduce gas costs.   "}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Not used variables.  In library PoolSwapLibrary:   bytes16 public constant zero = 0x00000000000000000000000000000000;   bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000; In contract PoolKeeper:   uint256 public constant MAX_DECIMALS = 18;  ## Recommended Mitigation Steps Remove if you don't need them to save some gas.  "}, {"title": "BLOCK_TIME of Arbitrum is less than 13 seconds", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why the block time is based on ETH mainnet 13s intervals, when in Arbitrum where these contracts are supposed to be deployed block times are faster:     uint256 public constant BLOCK_TIME = 13; /* in seconds */ I wanted to ask this Tracer's representative on Discord but received no answer so submitting this and you can decide if that was intentional.    "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/27", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  - `LeveragedPool.sol#intervalPassed()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L259-L261      ```solidity         function intervalPassed() public view override returns (bool) {             return block.timestamp >= lastPriceTimestamp + updateInterval;         }     ```      `lastPriceTimestamp + updateInterval` will never overlow.  - `LeveragedPool.sol#executePriceChange()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L175-L204      ```solidity     emit PoolRebalance(         int256(newShortBalance) - int256(_shortBalance),         int256(newLongBalance) - int256(_longBalance)     );     ```      `int256(newShortBalance) - int256(_shortBalance)` and `int256(newLongBalance) - int256(_longBalance)` will never underflow.  "}, {"title": "Wrong keeper reward computation", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/23", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PoolKeeper.keeperReward` computation mixes WADs and Quads which leads to issues. 1. Note that `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, the same way `BASE_TIP = 5 = 5%`. Thus `_tipPercent = ABDKMathQuad.fromUInt(keeperTip)` is a Quad value of this keeper tip, and not in \"wad units\" as the comment above it says.  ```solidity // @audit \ud83d\udc47 this comment is not correct, it's in Quad units // tip percent in wad units bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)); ```  2. Now the `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards: It tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it does a wrong division by `fixedPoint` (1e18 as a quad value) because it think the `_tipPercent` is a WAD value (100%=1e18) as a quad, when indeed `100%=100`. It seems like it should divide by `100` as a quad instead.  ``` ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```  ## Impact The keeper rewards are off as the `_keeperGas * _tipPercent` is divided by 1e18 instead of 1e2. Keeper will just receive their `_keeperGas` cost but the tip part will be close to zero every time.  ## Recommended Mitigation Steps Generally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time. This complicates the code. I'd make `keeperTip()`  return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)`. This temporary float result can then be used in a different ABDKMathQuad computation.  Alternatively, divide by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value, but simply a percentage where `1 = 1%`.  ```solidity ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```   "}, {"title": "Gas: Inefficient modulo computation", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  `PoolFactory.uint2str` computes `i % 10` as `uint8(_i - (_i / 10) * 10)`. This intuitively seems more gas-expensive than doing `i % 10`. Consider using `i % 10` instead which also makes the code simpler to read.   "}, {"title": "Validate max fee", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/21", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  `PoolFactory.setFee` does not check if the `_fee` parameter is at most 100%.  ## Impact Setting a very high fee, even above 100%, will lead to the pool's funds being drained.  ## Recommended Mitigation Steps Validate `_fee` against a reasonable max-fee value, ideally < 100%.   "}, {"title": "Gas: `transferGovernance` can save an sload", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LeveragedPool.transferGovernance` function emits an event and reads the new governance variable from storage.  ```solidity emit ProvisionalGovernanceChanged(provisionalGovernance); ```  It is cheaper to use the `_governance` parameter instead which is the same value.   "}, {"title": "Gas: shadow pools are only required for burn types", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PoolCommiter.shadowPools` track commitments for all four `Long/Short Mint/Burn` types and uses these to reconstruct the initial total supply to correctly compute the token amounts for the sequence of commitments (as short/long tokens already get burned in the commitment phase and reduced the total supply). However, the two burn types `LongBurn` and `ShortBurn` are all that's needed for the reconstruction which can be seen from the fact that `shadowPools[.]` is only accessed with them.  #### Recommendation Only store `shadowPools` for `LongBurn` and `ShortBurn` types, and remove the `shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;` statement in `_uncommit` which is unnecessary for the mints as it just pays out what's already tracked in the commitments (`_commit`).   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/11", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `PoolFactory.constructor: _feeReceiver`: The parameters should be checked to be non-zero - `ChainlinkOracleWrapper.constructor: _oracle`: The parameters should be checked to be non-zero or contracts  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "LeveragedPool has require statements which are also checked in library", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  loop   # Vulnerability details  When making external calls to ERC20 functions LeveragedPool checks for zero addresses. These checks are already available in the OpenZeppelin ERC20 implementation which is used. This results in redundant checks which increase gas costs when calling these functions.   ## Proof of Concept Require statements used in LeveragedPool: - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L148 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L163-L164 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L234 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L251  Checks in OpenZeppelin implementation: - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L226 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L275  ## Tools Used Remix  "}, {"title": "Contradiction in comment/require statement", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/7", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)"], "target": "2021-10-tracer-findings", "body": "# Handle  loop   # Vulnerability details  The comment for the `withdrawQuote()` function states 'Pool must not be paused'. Require statement requires paused to be true.  ## Impact Comment seems to be wrong, so no direct impact on functioning of protocol.  ## Proof of Concept Comment: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L359  Require: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L363  "}, {"title": "Unused Named Returns Can Be Removed", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  The unused named return variables are here.  ChainlinkOracleWrapper.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/ChainlinkOracleWrapper.sol#L57-L67  LeveragedPool.sol https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L327-L340 https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L353-L355  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Remove the unused named return variables or use them instead of creating additional variables.   "}, {"title": "Minimize Storage Slots (LeveragedPool.sol)", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In  LeveragedPool.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L22-L44  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Arrange the uint32, bytes32, and bool variables such that they fit into the same slot.   "}, {"title": "Set initial value for lastFee", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function handleFees can become cheaper by eliminating this surrounding if/else statement if you initially assign the value to the lastFee upon creation or initialization.  ## Recommended Mitigation Steps   uint256 public override lastFee = block.timestamp; or in function initialize as it will get this value anyway when doing the initial mintTo. But then you would probably need to skip handleFees if the timeDiff is 0.  "}, {"title": "Cache factory.ownerSplit()", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function handleFees calls factory.ownerSplit() twice. To save some gas and reduce the number of external calls, you should save the value after the first call and re-use it later.  ## Recommended Mitigation Steps Cache factory.ownerSplit() in a local variable and re-use it.  "}, {"title": "Cache basketAsERC20.totalSupply()", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Here basketAsERC20.totalSupply() does not change inside the loop so it can be called outside the loop to avoid multiple duplicate external calls:   uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps Cache basketAsERC20.totalSupply() in a temporary variable and re-use it.  "}, {"title": "There may be no bounties or user is not interested in any of them", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function settleAuction could skip withdrawBounty if there are no bounties.  ## Recommended Mitigation Steps if (bountyIDs.length > 0) {   withdrawBounty(bountyIDs); }   "}, {"title": "createBasket re-entrancy", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function createBasket in Factory should also be nonReentrant as it interacts with various tokens inside the loop and these tokens may contain callback hooks.  ## Recommended Mitigation Steps Add nonReentrant modifier to the declaration of createBasket.  "}, {"title": "Missing events for owner only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in Factory.sol.  Missing event :  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L39  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L43  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L47  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L51  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L55 ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  "}, {"title": " Missing events for basket only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are basket functions that do not emit any events in Auction.sol.   Missing event :   https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L44   ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.   "}, {"title": "`Basket.sol#changePublisher()` Remove redundant assertion can save gas", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L152  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {         require(newPublisher != address(0));          if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {             require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);             publisher = newPublisher; ```  `pendingPublisher.publisher` will never be `address(0)` if `newPublisher != address(0)` and `pendingPublisher.publisher == newPublisher`.  Removing `pendingPublisher.publisher != address(0)` can make the code simpler and save some gas.  ### Recommendation  Remove the redundant assertion.  "}, {"title": "`Basket.sol#changeLicenseFee()` Remove redundant check can save gas", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  `Basket.sol#changeLicenseFee()` checks for `pendingLicenseFee.licenseFee  != 0`, while the assertion above already making sure that `newLicenseFee >= factory.minLicenseFee()`.  If we can make sure `factory.minLicenseFee() > 0`, then the check of `pendingLicenseFee.licenseFee != 0` will be redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L170  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION); ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Factory.sol#L39-L41  ```solidity function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {     minLicenseFee = newMinLicenseFee; } ```  ### Recommendation  Consider adding `require(newMinLicenseFee > 0);` to `Factory.sol#setMinLicenseFee()`.  Remove the redundant check.  "}, {"title": "`Basket.sol#changePublisher()` Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  As per the test, changePublisher to the current publisher should not be allowed:  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/test/Basket.test.js#L122-L122  ```javascript let publisher = await basket.publisher(); expect(publisher).to.equal(addr2.address);  await expect(basket.connect(addr2).changePublisher(addr2.address)).to.be.reverted; ```  However, there is no such check to make sure that.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L148  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0)); ```  ### Recommendation  Change to:  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0) && newPublisher != publisher); ```  "}, {"title": "`Basket.sol` should have methods to cancel pending changes", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  While changing publisher and licenseFee is timelocked, there are no methods to cancel pending changes.  As a result, wrong changes may not be able to get canceled  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L163  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0));      if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {         require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);         publisher = newPublisher;          pendingPublisher.publisher = address(0);          emit ChangedPublisher(publisher);     } else {         pendingPublisher.publisher = newPublisher;         pendingPublisher.block = block.number;          emit NewPublisherSubmitted(newPublisher);     } } ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L182  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);         licenseFee = newLicenseFee;          pendingLicenseFee.licenseFee = 0;          emit ChangedLicenseFee(licenseFee);     } else {         pendingLicenseFee.licenseFee = newLicenseFee;         pendingLicenseFee.block = block.number;          emit NewLicenseFeeSubmitted(newLicenseFee);     } } ```  ### Recommendation  Consider adding methods to cancel pending changes.  "}, {"title": "`Basket.sol#mint()` Malfunction due to extra `nonReentrant` modifier", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L83-L88  ```solidity function mint(uint256 amount) public nonReentrant override {     mintTo(amount, msg.sender); }  function mintTo(uint256 amount, address to) public nonReentrant override {     require(auction.auctionOngoing() == false); ```  The `mint()` method is malfunction because of the extra `nonReentrant` modifier, as `mintTo` already has a `nonReentrant` modifier.  ### Recommendation  Change to:  ```solidity function mint(uint256 amount) public override {     mintTo(amount, msg.sender); } ```  "}, {"title": "Unnecessary new list in Basket's validateWeights()", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  # Vulnerability details  The function creates and populates a new array to check for duplicates, this is not necessary.  ## Impact Some amount of gas unnecessarily spent.  ## Proof of Concept The relevant area: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Basket.sol#L71:#L80 ## Tools Used Manual analysis, hardhat gas estimator.  ## Recommended Mitigation Steps Change the check to the following: ``` for (uint i = 0; i < length; i++) {   require(_tokens[i] != address(0));   require(_weights[i] > 0);   for (uint256 x = 0; x < i; x++) {       require(_tokens[i] != _tokens[x]);   } } ```  "}, {"title": "Auction bonder can steal user funds if bond block is high enough", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondBlock, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();         IERC20 basketAsERC20 = IERC20(address(basket));          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         }  ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondBlock increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ``` Maybe you would require newRatio to be > BASE but not sure.  "}, {"title": "Basket becomes unusable if everybody burns their shares", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts (..after you remove \"nonReentrant\" from \"mint\", see other issue): it(\"should divide by 0\", async () => {     await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));     await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));      await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await basket.connect(addr1).mint(ethers.BigNumber.from(1)); });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  "}, {"title": "Minimize Storage Slots (Auction.sol)", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In Auction.sol: https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L16-L28  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Arrange the bool and address variables such that they fit into the same slot. For example: <code>     uint256 private constant BASE = 1e18;     uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks          bool public override auctionOngoing;     bool public override hasBonded;     bool public override initialized;     address public override auctionBonder;          uint256 public override auctionStart; </code>        "}, {"title": "`nonReentrant` modifier should be used before any other modifier", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Basket.auctionBurn()` uses the `onlyAuction` and `nonReentrant` modifier, with this order.  ## Impact The `nonReentrant` modifier doesn't protect agains reentrancy during the execution of the first modifier. Practically, there cannot be any reentrancy there when considering the current implementation of `onlyAuction`, but it is still a best practice recommendation for safe programming.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the `nonReentrant` modifier before any other modifier.  "}, {"title": "`Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()` accept arguments with different data locations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` claims to override `IFactory.proposeBasketLicense()`, but some of their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()`.  "}, {"title": "`Basket.publishNewIndex()` and `IBasket.publishNewIndex()` accept arguments with different data locations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` claims to override `IBasket.publishNewIndex()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Basket.publishNewIndex()` and `IBasket.publishNewIndex()`.  "}, {"title": "`Auction.settleAuction()` and `IAuction.settleAuction()` accept arguments with different data locations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Auction.settleAuction()` claims to override `IAuction.settleAuction()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Auction.settleAuction()` and `IAuction.settleAuction()`.  "}, {"title": "Empty `else if` block in `Basket.publishNewIndex()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` contains the following code: ``` if (auction.auctionOngoing() == false) {  // ... } else if (auction.hasBonded()) {  } else {  // ... } ```  ## Impact Empty code blocks increase gas costs (add overheads) and make the code less readable.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Get rid of the empty block by changing this code to: ``` if (auction.auctionOngoing() == false) {  // ... } else if (!auction.hasBonded()) {  // ... } ```  "}, {"title": "Unnecessary `SLOAD`s and `MLOAD`s in for-each loops", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ```  In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there.  ## Impact Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  "}, {"title": "Unnecessary `SLOAD`s in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Factory.getProposalWeights()` and `Factory.createBasket()` read values from storage multiple times instead of caching them in local variables: - `Factory.getProposalWeights()` reads `_proposals[id]` twice. - `Factory.createBasket()` reads `_proposals[idNumber]` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  "}, {"title": "Unnecessary `SLOAD`s in `Basket`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Basket.handleFees()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()`, `Basket.deleteNewIndex()`, `Basket.updateIBRatio()`, `Basket.approveUnderlying()`, `Basket.pushUnderlying()` and `Basket.pullUnderlying()` read values from storage multiple times instead of caching them in local variables: - `Basket.handleFees()` reads `lastFee` up to twice, `factory` 3 times and `ibRatio` once (when `newIbRatio` can be used). - `Basket.changePublisher()` reads `pendingPublisher.publisher` up to twice and `publisher` up to once (when `newPublisher` can be used). - `Basket.changeLicenseFee()` reads `pendingLicenseFee.licenseFee` up to twice and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.publishNewIndex()` reads `auction` up to 3 times and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.deleteNewIndex()` reads `publisher` twice and `auction` up to twice. - `Basket.updateIBRatio()` reads `ibRatio` twice. - `Basket.approveUnderlying()` reads `tokens[i]` twice. - `Basket.pushUnderlying()` reads `ibRatio` once per iteration. - `Basket.pullUnderlying()` reads `ibRatio` once per iteration.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  "}, {"title": "Unnecessary `SLOAD`s in `Auction`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Auction.bondForRebalance()`, `Auction.settleAuction()`, `Auction.bondBurn()` and `Auction.withdrawBounty()` read values from storage multiple times instead of caching them in local variables: - `Auction.bondForRebalance()` reads `bondAmount` twice. - `Auction.settleAuction()` reads `bondBlock` twice, `basket` 8 times and `factory` twice. - `Auction.bondBurn()` reads `basket` twice and `bondAmount` twice. - `Auction.withdrawBounty()` reads `bounty.token` twice and `bounty.amount` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  "}, {"title": "Array out-of-bounds error in `Auction`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Auction.withdrawBounty()` accept an argument called `bountyIds` and use it as indices to determine which elements in the `_bounties` array should be loaded and treated. However, this function don't check that the indices it receives as an argument actually fits the bounds of the `_bounties` array.  ## Impact If one of the indices exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to this function to validate that the given argument fits the `_bounties` array bounds.  "}, {"title": "Array out-of-bounds errors in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Factory.proposal()`, `Factory.getProposalWeights()` and `Factory.createBasket()` accept an argument called `proposalId`, `id` or `idNumber`, respectively, and use it as an index to determine which element in the `_proposals` array should be loaded and treated. However, these functions don't check that the index they receive as an argument actually fits the bounds of the `_proposals` array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_proposals` array bounds.  "}, {"title": "Unnecessary require statement in `Auction.initialize()` and `Basket.initialize()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Auction.initialize()` and `Basket.initialize()` look like this: ``` require(address(factory) == address(0)); require(!initialized); // ... factory = ...; // ... initialized = true;  ```  The second require statement is enough to make sure that these functions can only be called once. The first require statement is redundent.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the first require statement in these functions.  "}, {"title": "Unnecessary cast in `Basket.onlyPublisher()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The modifier `Basket.onlyPublisher()` casts `publisher` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  "}, {"title": "Unnecessary cast in `Factory.proposeBasketLicense()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` casts `msg.sender` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  "}, {"title": "`internal` function in `Auction` can be `private`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `internal` function `Auction.withdrawBounty()` is never called by a contract that inherits `Auction`. Therefore, its visibility can be reduced to `private`.  ## Impact `private` functions are cheaper than `internal` functions.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define this function as `private`.  "}, {"title": "`public` functions in `Factory` can be `external`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `public` functions `Factory.setMinLicenseFee()`, `Factory.setAuctionDecrement()`, `Factory.setAuctionMultiplier()`, `Factory.setBondPercentDiv()`, `Factory.setOwnerSplit()` and `Factory.proposeBasketLicense()` are never called by `Factory`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  "}, {"title": "`public` functions in `Basket` can be `external`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `public` functions `Basket.mint()`, `Basket.burn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()` and `Basket.deleteNewIndex()` are never called by `Basket`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  "}, {"title": "`public` functions in `Auction` can be `external`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `public` functions `Auction.startAuction()`, `Auction.killAuction()`, `Auction.initialize()`, `Auction.bondForRebalance()`, `Auction.settleAuction()` and `Auction.addBounty()` are never called by `Auction`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  "}, {"title": "State variables in `Factory` can be `immutable`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The state variables `Factory.auctionImpl` and `Factory.basketImpl` can be `immutable` since they are only set once, at the constructor.  ## Impact Reading from immutable state variables is much cheaper than from regular state variables.  ## Proof of Concept https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these state variables as `immutable`.  "}, {"title": "`Ownable` Contract Does Not Implement Two-Step Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `Swap.sol` inherits OpenZeppelin's `Ownable` contract which enables the `onlyOwner` role to transfer ownership to another address. It's possible that the `onlyOwner` role mistakenly transfers ownership to the wrong address, resulting in a loss of the `onlyOwner` role.  ## Proof of Concept  https://github.com/code-423n4/2021-10-tally/blob/main/contracts/governance/EmergencyGovernable.sol https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider overriding the `transferOwnership()` function to first nominate an address as the pending owner and implementing an `acceptOwnership()` function which is called by the pending owner to confirm the transfer. Alternatively, as the `onlyOwner` role is not used throughout the contract, it may be useful to remove this contract entirely from the `EmergencyGovernable.sol` contract.  "}, {"title": "Unnecessary `SLOAD` in `Swap.setSwapFee()`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  pants   # Vulnerability details  This line in `Swap.setSwapFee()` perfoms an `SLOAD` operation for a value that is already stored in a local variable: ``` emit NewSwapFee(swapFee); ```  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the already existing local variable instead of loading this value from storage: ``` emit NewSwapFee(swapFee_); ```  "}, {"title": "Gas: Math library could be \"unchecked\"", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Math` library uses Solidity version 0.8 which comes with built-in overflow checks which cost gas.  The code already checks for underflows (`a > b` before doing the division), and therefore the built-in checks can be disabled everywhere for improved gas cost.  ```solidity pragma solidity ^0.8.0;  library Math {     function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint128 a, uint128 b) internal pure returns (uint128) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint64 a, uint64 b) internal pure returns (uint64) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint32 a, uint32 b) internal pure returns (uint32) {       unchecked {         return a > b ? a - b : 0;       }     } } ```  "}, {"title": "Gas: SafeMath is not needed when using Solidity version 0.8", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Swap` contract uses Solidity version 0.8 which already implements overflow checks by default. At the same time, it uses the `SafeMath` library which is more gas expensive than the 0.8 overflow checks.  It should just use the built-in checks and remove `SafeMath` from the dependencies:  ```solidity // @audit can just normal arithmetic here uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);  // uint256 toTransfer = (SWAP_FEE_DIVISOR - swapFee) * boughtERC20Amount / SWAP_FEE_DIVISOR;  // same with many other computations ```  "}, {"title": "Gas: minReceived check can be simplified", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  cmichel   # Vulnerability details  The `minimumAmountReceived` check in `Swap.swapByQuote` is implemented like this:  ```solidity require(     (         !signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtERC20Amount >= minimumAmountReceived     ) ||     (         signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtETHAmount >= minimumAmountReceived     ),     \"Swap::swapByQuote: Minimum swap proceeds requirement not met\" ); ```  It can be simplified to this which performs less calls to `signifiesETHOrZero` and less logical operators:  ```solidity require( (signifiesETHOrZero(zrxBuyTokenAddress) ? boughtETHAmount : boughtERC20Amount) >= minimumAmountReceived, \"...\"); ```   "}, {"title": "Arbitrary contract call allows attackers to steal ERC20 from users' wallets", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/37", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData); ```  A call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.  ### Impact  The wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.  ### PoC  Given:  - Alice has approved 1000 WETH to `Swap.sol`;  The attacker can:  ``` TallySwap.swapByQuote(     address(WETH),     0,     address(WETH),     0,     address(0),     address(WETH),     abi.encodeWithSignature(         \"transferFrom(address,address,uint256)\",         address(Alice),         address(this),         1000 ether     ) ) ```  As a result, 1000 WETH will be stolen from Alice and sent to the attacker.  This PoC has been tested on a forking network.  ### Recommendation  Consider adding a whitelist for `zrxTo` addresses.  "}, {"title": "Wrong calculation of `erc20Delta` and `ethDelta`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/34", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData);     require(success, \"Swap::fillZrxQuote: Failed to fill quote\");      uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);     uint256 erc20Delta;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);         require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");     } else {         require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");     }      return (erc20Delta, ethDelta); } ```  When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`.   That's because `originalETHBalance` already includes the `msg.value` sent by the caller.  Let's say the ETH balance of the contract is `1 ETH` before the swap.  - A user swaps `10 ETH` to USDC; - `originalETHBalance` will be `11 ETH`; - If there is `1 ETH` of refund; - `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.  Similarly, `erc20Delta` is also computed wrong.  Consider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.  For example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.  ### Impact  - User can not get ETH refund for swaps from ETH to ERC20 tokens; - Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.  ### Recommendation  Consider subtracting the input amount from the originalBalance.  "}, {"title": "Wrong value for `SwappedTokens` event parameter", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L174-L180  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     amountToSell,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  `amountToSell` will be 0 according to the comment: `If selling unwrapped ETH via msg.value, this should be 0.`, therefore, `msg.value` should be used instead.  ### Recommendation  Change to:  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     msg.value,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  "}, {"title": "Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  `Swap.sol#constructor()` validates `owner_` but does not validate `swapFee_`. While in `setSwapFee()`, it does validates the input to make sure `swapFee_ < SWAP_FEE_DIVISOR`.  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L51-L58  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {         require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");         transferOwnership(owner_);         feeRecipient = feeRecipient_;         emit NewFeeRecipient(feeRecipient);         swapFee = swapFee_;         emit NewSwapFee(swapFee);     } ```  ### Recommendation  Change to:  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {     require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");     require(swapFee_ < SWAP_FEE_DIVISOR, \"Swap::constructor: Swap fee must not exceed 100%\");     transferOwnership(owner_);     feeRecipient = feeRecipient_;     emit NewFeeRecipient(feeRecipient);     swapFee = swapFee_;     emit NewSwapFee(swapFee); } ```  "}, {"title": "Incorrect FeesSwept amount being emitted in sweepFees function", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In the sweepFees function, address(this).balance is being used as the \"amount\" in the SweepFees event immediately after a transfer. So, the amount in the event on line 258 will always be 0, but it should be what address(this).balance was before the transfer. This has implications on overall functionality, tools that are monitoring this event will receive incorrect information. A fix is to store the value before calling the transfer.  ## Proof of Concept referenced lines in sweepFees function: https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol#:~:text=feeRecipient.transfer(address,this).balance%2C%20feeRecipient)%3B  A more correct implementation would be:  uint256 amount = address(this).balance; feeRecipient.transfer(address(this).balance); emit FeesSwept(address(0), amount, feeRecipient);  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Store balance before calling transfer, as above.  "}, {"title": "`MochiTreasuryV0.sol` Is Unusable In Its Current State", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.  ## Proof of Concept  https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Consider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.  "}, {"title": "`MochiTreasuryV0.sol` Implements `receive()` Function With No Withdraw Mechanism", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `MochiTreasuryV0.sol` contract freely receives ETH from users/other contracts. In the event this does happen, ETH is permanently locked and unrecoverable by the protocol's governance framework.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol  ## Tools Used  Manual code review Slither  ## Recommended Mitigation Steps  Consider enabling ETH withdraws for the governance role.  "}, {"title": "`MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding `require(lockCrv, \"!lock\");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.  "}, {"title": "Improper Validation Of `create2` Return Value", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31  ## Tools Used  Manual code review Discussions with the Mochi team Discussions with library dev  ## Recommended Mitigation Steps  The recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.  "}, {"title": "Useless imports", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract USDM does not need to import IERC3156FlashLender again as it was already imported in IUSDM.   import \"../interfaces/IERC3156FlashLender.sol\";  contract DutchAuctionLiquidator makes no use of these imports:   import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";   import \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";   import \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";  ## Recommended Mitigation Steps Consider reviewing all the unused imports and removing them to reduce the size of the contract and thus save some deployment gas.  "}, {"title": "Pack structs tightly", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Gas efficiency can be achieved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage. For example, startedAt or boughtAt in Auction struct hold block.number so realistically this does not need uint256 and you can consider storing it in lower type. You can read more here: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html or in the official documentation: https://docs.soliditylang.org/en/v0.4.21/miscellaneous.html  ## Recommended Mitigation Steps Search for an optimal size and order of structs to reduce gas usage.  "}, {"title": "Improve precision and gas costs in_shareMochi", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This not only loses some precision (cuz of multiplication and division) but also consumes more gas:     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );  ## Recommended Mitigation Steps Proposed improvement:   // send Mochi to vMochi Vault   uint toVault = (mochiBalance * vMochiRatio) / 1e18;   mochi.transfer(       address(engine.vMochi()),       toVault   );   // send Mochi to veCRV Holders   mochi.transfer(       crvVoterRewardPool,       mochiBalance - toVault;   );  This way you the whole mochiBalance will be transferred and it will cost less to do that as fewer math operations are performed.  "}, {"title": "Open TODOs/questions", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/139", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Open TODOs can point to programming or other errors that still need to be fixed.  ## Proof of Concept  These are TODOs written as comments: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L57 https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L163  ## Tools Used VS Code  ## Recommended Mitigation Steps Resolve the TODOs/open questions.   "}, {"title": "UniswapV2/SushiwapLPAdapter update the wrong token", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/134", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again. This will end up with the router calling this function again recursively.  ## Impact This function fails as there's an infinite recursion and eventually runs out of gas.  ## Recommendation The idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.  Call `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.   "}, {"title": "Changing engine.nft contract breaks vaults", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  Governance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP). When minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.  ## Impact Changing the NFT address will allow overwriting existing CDPs.  ## Recommended Mitigation Steps Disallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.  "}, {"title": "Debt accrual is path-dependant and inaccurate", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  The total `debt` in `MochiVault.accrueDebt` increases by the current `debt` times the debt index growth. This is correct but the total `debt` is then _reduced_ again by the calling _user's_ discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.  This should not be the case.  ## POC Assume we have a total debt of `2000`, two users A and B, where A has a debt of 1000, and B has a debt of 100. The (previous) `debtIndex = 1.0` and accruing it now would increase it to `1.1`.  There's a difference if user A or B first does the accrual.  #### User A accrues first User A calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 1000 * 1.1 / 1.0 - 1000 = 100` and assume a discount of `10%`, thus `discountedDebt = 100 * 10% = 10`. Then `debts = 2200 - 10 = 2190`.  The next accrual will work with a total debt of `2190`.  #### User B accruess first User B calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 100 * 1.1 / 1.0 - 100 = 10` and assume a discount of `10%`, thus `discountedDebt = 10 * 10% = 1`. Then `debts = 2200 - 1 = 2199`.  The next accrual will work with a total debt of `2199`, leading to more debt overall.  ## Impact The total debt of a system depends on who performs the accruals which should ideally not be the case. The discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.  ## Recommended Mitigation Steps Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of **all users** (instead of current caller only) when accruing to correctly track the debt.   "}, {"title": "A malicious user can potentially escape liquidation by creating a dust amount position and trigger the liquidation by themself", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, a liquidated position can be used for depositing and borrowing again.  However, if there is a liquidation auction ongoing, even if the position is now `liquidatable`, the call of `triggerLiquidation()` will still fail.   The liquidator must `settleLiquidation` first.  If the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.  Considering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.  Since the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.  The malicious user will then deposit borrow the actual loan.  When this loan becomes `liquidatable`, liquidators may:  1. confuse the current dust auction with the `liquidatable` position; 2. unable to proceed with such a complex liquidation.  As a result, the malicious user can potentially escape liquidation.  ### Recommendation  Consider making liquidated positions unable to be used (for depositing and borrowing) again.  "}, {"title": "liquidation factor < collateral factor for Sigma type", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MochiProfileV0` defines liquidation and collateral factors for different asset types. For the `AssetClass.Sigma` type, the liquidation factor is _less_ than the collateral factor:  ```solidity function liquidationFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {         return float({numerator: 40, denominator: 100});     } }  function maxCollateralFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) {         return float({numerator: 45, denominator: 100});     } } ```  This means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%. There should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:  > A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. [Docs](https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)   ## Recommended Mitigation Steps The max collateral factor for the Sigma type should be higher than its liquidation factor.   "}, {"title": "Flashloan fee griefing attack for existing approvals", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  If a flashloan contract does not properly authenticate the `USDM` flashloan contract callbacks, anyone can perform a griefing attack which will lead to the caller losing tokens equal to the fees.  This is because the flashloan `receiver` is not authenticated and anyone can start flashloans on behalf of another contract. They don't even need to approve the `usdm` contract as it uses internal `_burn` and `_transfer` functions instead of `burnFrom`/`transferFrom`.  #### POC  1. Call `FlashLoan.flashLoan(receiver=victim, ...)`. 2. Loan amount + fees will be burned/transferred from the `receiver` in `_loan`.  If fees are non-zero, it's possible to drain the victim's balance if their contract is implemented incorrectly without proper authentication checks.  #### Recommendation This is an inherent issue with EIP-3156 which defines the interface with an arbitrary `receiver`. Contracts should be aware to revert if the flashloan was not initiated by them.  To mitigate this issue one could use functions that work with explicit approvals from the victim, instead of using internal `_burn` and `_transfer` functions. This way, the victim must first have approved the tokens for transfer.   "}, {"title": "Declaring unnecessary immutable variables as constant can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `MochiProfileV0.sol`, `secPerYear` is defined as an immutable variable while it's not configured as a parameter of the constructor. Thus, it can be declared as constant to save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L23-L28  ```solidity=23 uint256 public immutable secPerYear;  uint256 public override delay;  constructor(address _engine) {     secPerYear = 31536000; ```  ### Recommendation  Change to:  ```solidity=23 uint256 public constant SEC_PER_YEAR = 31536000; ```  "}, {"title": "Simplify `sqrt()` can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check of `x > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `x <= 3`.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/UniswapV2LPAdapter.sol#L106-L117  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/SushiswapV2LPAdapter.sol#L106-L117  ```solidity=106 function sqrt(uint x) internal pure returns (uint y) {     if (x > 3) {         uint z = x / 2 + 1;         y = x;         while (z < y) {             y = z;             z = (x / z + z) / 2;         }     } else if (x != 0) {         y = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  "}, {"title": "`FeePoolV0.sol#distributeMochi()` will unexpectedly flush `treasuryShare`, causing the protocol fee cannot be properly accounted for and collected", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/114", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  `distributeMochi()` will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. It wont touch the `treasuryShare`.  However, in the current implementation, `treasuryShare` will be reset to `0`. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95  ```solidity=79 function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );     // flush mochiShare     mochiShare = 0;     treasuryShare = 0; } ```  ### Impact  Anyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`.  Repeat the steps above and the `treasuryShare` will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.  ### Recommendation  Change to:  ```solidity=64 function _buyMochi() internal {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = address(engine.mochi());     usdm.approve(address(uniswapRouter), mochiShare);     uniswapRouter.swapExactTokensForTokens(         mochiShare,         1,         path,         address(this),         type(uint256).max     );     // flush mochiShare     mochiShare = 0; }  function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     ); } ```  "}, {"title": "`FeePoolV0.sol` Lack of input validation", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/106", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  `treasuryRatio` and `vMochiRatio` must be `<= 1e18` to make sure the contract works correctly. Therefore, the input should be checked in the setters.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L45-L53  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     vMochiRatio = _ratio; } ```  ### Recommendation  Change to:  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     require(_ratio <= 1e18, \">1e18\");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     require(_ratio <= 1e18, \">1e18\");     vMochiRatio = _ratio; } ```  "}, {"title": "Minor precision loss", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L67-L68  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount / 2); ```  Change to:  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount - _amount / 2); ```  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L59-L65  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee / 2; ```  Change to:  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee - updatedFee / 2; ```  "}, {"title": "`DutchAuctionLiquidator.sol#triggerLiquidation()` Adding precondition check can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  When liquidators race to liquidate a position, all other besides the first liquidator will be handling an empty (liquidated) position.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#L69-L81  ```solidity=69 function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");     uint256 debt = vault.currentDebt(_nftId);      (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  In the current implementation, even if the position is liquidated, at L77 and L79, it still tries to get the details and call `vault.liquidate()`, until it reverts at L285-L288 on `MochiVault.sol#liquidate()`. That's going to cost a decent amount of gas due to these unnecessary external calls and code executions.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L277-L288  ```solidity=277{285-288} function liquidate(     uint256 _id,     uint256 _collateral,     uint256 _usdm ) external override updateDebt(_id) {     require(msg.sender == address(engine.liquidator()), \"!liquidator\");     require(engine.nft().asset(_id) == address(asset), \"!asset\");     float memory price = engine.cssr().getPrice(address(asset));     require(         _liquidatable(details[_id].collateral, price, currentDebt(_id)),         \"healthy\"     );     ... ```  Therefore, adding a precondition check can save gas.    ### Recommendation  Change to:  ```solidity=69{77} function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");     uint256 debt = vault.currentDebt(_nftId);     require(debt > 0, \"!debt\");     (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  "}, {"title": "`VestedRewardPool.sol#checkClaimable()` Add `vesting[recipient].ends > 0` to the condition can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  When the vesting ends, `vesting[recipient].ends` will be `0` which always passes the check of `vesting[recipient].ends < block.timestamp` and causes unnecessary code execution.  Adding a check of `vesting[recipient].ends > 0` can avoid unnecessary code execution and save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  ### Recommendation  Change to:  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends > 0 && vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  "}, {"title": "`ReferralFeePoolV0.sol#claimRewardAsMochi()` Array out of bound exception", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/97", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42  ```solidity=28 function claimRewardAsMochi() external {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = uniswapRouter.WETH();     path[2] = address(engine.mochi());     usdm.approve(address(uniswapRouter), reward[msg.sender]);     // we are going to ingore the slippages here     uniswapRouter.swapExactTokensForTokens(         reward[msg.sender],         1,         path,         address(this),         type(uint256).max     ); ```  In `ReferralFeePoolV0.sol#claimRewardAsMochi()`, `path` is defined as an array of length 2 while it should be length 3.  As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.  ### Impact  `claimRewardAsMochi()` will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.  "}, {"title": "Tokens Can Be Stolen By Frontrunning `VestedRewardPool.vest()` and `VestedRewardPool.lock()`", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/92", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46 https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.   "}, {"title": "`treasuryShare` is Overwritten in `FeePoolV0._shareMochi()`", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/89", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract.   ## Proof of Concept  Consider the following scenario:   - The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.   - `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.   - A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.   - As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.   - Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).   - The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`.    - `mochiShare` is now set to 16 `usdm` tokens.   - The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.   - The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94  ## Tools Used  Manual code review Discussions with the Mochi team.  ## Recommended Mitigation Steps  Consider removing the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.   "}, {"title": "Chainlink's `latestRoundData` might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  nikitastupin   # Vulnerability details  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49   The `ChainlinkAdapter` calls out to a Chainlink oracle receiving the `latestRoundData()`. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).  ## Recommended Mitigation Steps  Add the following checks:  ``` ... ( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData(); require(rawPrice > 0, \"Chainlink price <= 0\"); require(updateTime != 0, \"Incomplete round\"); require(answeredInRound >= roundId, \"Stale price\"); ... ```  ## References  - https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results - https://github.com/code-423n4/2021-05-fairside-findings/issues/70  "}, {"title": "Save Gas With The Unchecked Keyword (MochiVault.sol)", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept  The \"unchecked\" keyword can be applied here since there is an \"if\" statement before to ensure the arithmetic operations, would not cause an integer underflow or overflow. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L267  Change the code at 267 to: <code> unchecked {    debts -= _amount; } </code>  A similar change can be made here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L269  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the \"unchecked\" keyword as shown above.  "}, {"title": "anyone can create a vault by directly calling the factory", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details   ## Impact [MochiVaultFactory.sol#L26-L37](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37) There's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.  As the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.    I consider this is a medium-risk issue.  ## Proof of Concept  Here's a web3.py script to trigger the bug. ```py vault_factory.functions.deployVault(usdt.address).transact() ## this tx would be reverted profile.functions.registerAssetByGov([usdt.address], [3]).transact() ```  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add a check. ```solidity require(msg.sender == engine, \"!engine\"); ```  "}, {"title": "Remove extra calls in updateReserve (FeePoolV0.sol)", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Cache the result of engine.usdm().balanceOf to simplify code and save gas.  ## Proof of Concept  engine.usdm().balanceOf is called twice in function updateReserve here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L32-L38  I suggest modifying the code as follows: <code> function updateReserve() external override {   uint256 balanceOf = engine.usdm().balanceOf(address(this));  treasuryShare += ((balanceOf - mochiShare - treasuryShare) * treasuryRatio) / 1e18;  mochiShare = balanceOf - treasuryShare; } </code>  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC   "}, {"title": "Unnecessary require in settleLiquidation ", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact On line 100 of DutchAuctionLiquidator.sol (within settleLiquidation), there is a require statement for auction.boughtAt == 0. This is already checked on line 121 within the \"buy\" function, and this is the only function that can possibly call settleLiquidation, so this require statement always passes. Removing it would save gas.  ## Proof of Concept Link to require statement here: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=require(auction.boughtAt%20%3D%3D%200%2C%20%22liquidated%22)%3B  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps Remove unnecessary require statement described above to save gas.  "}, {"title": "Liquidation will never work with non-zero discounts", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/66", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact Right now, there is only one discount profile in the github repo: the \"NoDiscountProfile\" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.  Suppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable \"debt\" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function - this will be important. Back within the triggerLiquidation function, the variable \"collateral\" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107.   Eventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.  ## Proof of Concept Liquidate function in MochiVault.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-(  triggerLiquidation function in DutchAuctionLiquidator.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-(address%20_asset%2C%20uint256  Retracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:  details[_id].debt -= _usdm;  throwing an error since _usdm will be larger than details[_id].debt.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps An easy fix is to simply change:  details[_id].debt -= _usdm;  to be:  details[_id].debt = 0;  as liquidating a position should probably just be equivalent to repaying all of the debt in the position.   Side Note: If there are no other discount profiles planned to be added other than \"NoDiscountProfile\", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything  "}, {"title": "Cached length of arrays to avoid loading them repeadetly", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  0x0x0x   # Vulnerability details   ## Impact Gas optimization.  ## Proof of Concept  ``` for (uint i = 0; i < arr.length; i++) {     //Operations not effecting the length of the array. } ``` Loading length for storage arrays cost 100 gas and for memory arrays it costs 3 gas. When arr.length is defined as the condition of for loop, at the start of every iteration the length is loaded from memory. If the length doesn't change during the loop, loading the length of arrays repeatedly can be avoided by saving the length to the stack. ``` uint length = arr.length; for (uint i = 0; i < length; i++) {     //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Locations ``` ./mochi-core/contracts/profile/MochiProfileV0.sol:68:        for (uint256 i = 0; i < _asset.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:86:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:95:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-cssr/contracts/MochiCSSRv0.sol:41:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:47:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:66:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:77:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/adapter/ChainlinkAdapter.sol:34:        for(uint256 i = 0; i<_assets.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:63:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:122:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:175:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:36:  for (uint i=0; i<parentNodes.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:78:  for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:108:  for(uint i=offset; i<nibbleArray.length; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ./mochi-library/contracts/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ``` ## A similar case  nibblePath.length is constant but it is read at every iteration for require statement.  ```./mochi-library/contracts/MerklePatriciaVerifier.sol:36: require(pathPtr <= nibblePath.length, \"Path overflow\");```    "}, {"title": "Changing NFT contract in the MochiEngine would break the protocol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/63", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact MochiEngine allows the operator to change the NFT contract. [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93) All the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.  IMHO, A function that would break the entire protocol shouldn't exist.  I consider this is a high-risk issue. ## Proof of Concept [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)  ## Tools Used None ## Recommended Mitigation Steps Remove the function.   "}, {"title": "regerralFeePool is vulnerable to MEV searcher", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details  # regerralFeePool is vulnerable to MEV searcher  ## Impact `claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.  Given the current state of the Ethereum network. Users would likely be sandwiched. I consider this is a high-risk issue.  ## Proof of Concept [ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)  Please refer to https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f  to see a possible attack pattern.   ## Tools Used  None  ## Recommended Mitigation Steps I recommend adding minReceivedAmount as a parameter.  ```solidity function claimRewardAsMochi(uint256 _minReceivedAmount) external {     // original logic here     require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, \"!min\");     engine.mochi().transfer(         msg.sender,         engine.mochi().balanceOf(address(this))     ); } ``` Also, the front-end should calculate the min amount with the current price.  "}, {"title": "treasury is vulnerable to sandwich attack", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/60", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details  # treasury is vulnerable to sandwich attack.   ## Impact There's a permissionless function `veCRVlock` in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds. [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.  ## Proof of Concept [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Here's an exploit pattern 1. Flashloan and buy CRV the uniswap pool 2. Trigger `veCRVlock()` 3. The treasury buys CRV at a very high price. 4. Sell CRV and pay back the loan.  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add `onlyOwner` modifier.   "}, {"title": "Referrer can drain ReferralFeePoolV0", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/55", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact function claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol L28-47 did not reduce user reward balance  ## Tools Used None  ## Recommended Mitigation Steps Add the following lines > rewards -= reward[msg.sender]; > reward[msg.sender] = 0;   "}, {"title": "Gas optimization: Struct layout in DutchAuctionLiquidator.sol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Auction struct in DutchAuctionLiquidator.sol can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol L18-L25: the struct can changed into struct Auction {         uint256 nftId;         address vault;         uint48 startedAt;         uint48 boughtAt;         uint256 collateral;         uint256 debt;     } startedAt and boughtAt store block numbers, and 2^48 is be enough for a very long time.  ## Tools Used None  ## Recommended Mitigation Steps Change the struct as suggested above, also need to cast whenever startedAt and boughtAt is used.  "}, {"title": "Vault status is not set to Liquidated after liquidation", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact There is a status enum Liquidated but was not used anywhere in the code.   ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L277-296 status was not set to Status.Liquidated after liquidation  ## Tools Used None  ## Recommended Mitigation Steps details[id].status = Status.Liquidated;  "}, {"title": "Reduce State Variable Use in VestedRewardPool.sol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the \"vesting\" state variable instead of repeatedly reading and writing it will decrease deployment and runtime gas.  This is especially true for the modifier \"checkClaimable\" which is used on every function in the contract.   ## Proof of Concept  The checkClaimable function is here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  An example of its use is here along with many other accesses to the \"vesting\" state variable. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest modifying \"checkClaimable as follows:     <code> function checkClaimable(Vesting memory v) internal pure returns(Vesting memory) {   if (v.ends < block.timestamp) {   v.claimable += v.vested;   v.vested = 0;   v.ends = 0;  }  return v; } </code>  and I suggest these changes to function \"vest\"   <code> function vest(address _recipient) external {  Vesting memory v = checkClaimable(vesting[_recipient]);  uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;  uint256 weightedEnd = (v.vested *   v.ends +   amount *   (block.timestamp + 90 days)) /   (v.vested + amount);  v.vested += amount;  v.ends = weightedEnd;  vesting[_recipient] = v;  mochiUnderManagement += amount; } </code>  These functions are also candidates for similar changes: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L48-L71   "}, {"title": "Gas Optimization on the Public Function", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L75  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Clone repository for Mochi Smart Contracts. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.  "}, {"title": "Gas optimization: Struct layout", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/interfaces/IMochiVault.sol L6-L12: the struct can be reordered into struct Detail {     Status status;     address referrer;     uint256 collateral;     uint256 debt;     uint256 debtIndex; }  such that status and referrer are put into the same slot, should save ~2000 gas per borrow  ## Tools Used None  ## Recommended Mitigation Steps Reorder the struct as suggested, and modify impacted code at  IMochiVault.sol L28-L34 DutchAuctionLiquidator.sol L77  ## Extra Realistically, the range of debtIndex (start at 1e18 and increase by fee per year) probably fit in a uint88(11bytes) so you can pack (status(1byte), referrer(20bytes), debtIndex(11bytes)) all in 32 bytes, saving another storage slot.   "}, {"title": "Gas optimization: Placement of require statements in MochiVault.sol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Some of the require statements in MochiVault.sol can be placed earlier to reduce gas usage on revert  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L226-227: can be placed at the very top of the function to avoid the expensive cssr call L237: can be placed before initialization of increasingDebt  ## Tools Used None  ## Recommended Mitigation Steps Relocate the said require statements  "}, {"title": "debts calculation is not accurate", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/25", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.  In the function borrow() the variable debts is increased with a value excluding the fee. However in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased,, which is including the fee.  This would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.  In the mean time the value of debts isn't accurate. This value is used directly or indirectly in:  - utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol  - liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol  This means the entire debt and claimable calculations are slightly off.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol  function borrow(..)     details[_id].debt = totalDebt; // includes the fee     debts += _amount;     // excludes the fee   function repay(..)     debts -= _amount;       details[_id].debt -= _amount;  function liquidate(..)    debts -= _usdm;    details[_id].debt -= _usdm;  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L263-L268  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L272-L283  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L242-L256  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L258-L269  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L66-L73  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L79-L88  ## Tools Used  ## Recommended Mitigation Steps In function borrow(): replace     debts += _amount; with     debts += totalDebt  "}, {"title": "griefing attack to block withdraws", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then \"lastDeposit[_id]\" is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for \"delay()\" blocks. The default value for delay() is 3 minutes.  Knowing this delay you can do a griefing attack: On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets). On chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()  This way the owner of the NFT-id can never withdraw the funds.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33  ## Tools Used  ## Recommended Mitigation Steps Create a mechanism where you only block the withdraw of recently deposited funds   "}, {"title": "Move Function _stake Validator Declaration", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The variable v is declared after the first use of its contents.  Moving the declaration before the first use will save gas.  ## Proof of Concept  \"v\" is declared here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L180  But \"v\"s contents (validators[validatorId]) is used here first: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L178  Move line 180 above line 178 and change line 178 to use \"v\".  I've run out of contest time to continue testing but I'd recommend looking through the following functions for how \"validators[validatorId]\" may be used more efficiently. https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L272 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L346   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See Proof of Concept  "}, {"title": "Change lines to save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  Change lines 178 to 173. We know it's minor but it's still optimizing gas and more elegant :)  "}, {"title": "Inconsistent definition of integer sizes in function `getDelegatorDetails()`", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `getDelegatorDetails()` declares three arrays of type `uint`  (alias for `uint256`).  The variables saved in the arrays are of type `uint128`.  See lines [451-453](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L451).  The suggestion is to be consistent with the integer sizes.  "}, {"title": "Unclear definition of `validatorId`'s integer size", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The mapping `validators` is defined with `uint` (alias for `uint256`) as key  type.  In the functions receiving the `validatorId` as parameter however, the  `validatorId` is defined as `uint128`.  See lines [166](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L166), [214](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L214).  The suggestion is to be consistent with the integer size.  "}, {"title": "Declare variable `CQT` as constant", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The variable `CQT` is used as constant but not declared as such.  Declaring it as constant saves gas.  "}, {"title": "Misleading parameter name", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L423-L433  ```solidity function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 stakingId) public {     Unstaking storage us = validators[validatorId].unstakings[msg.sender][stakingId];     require( uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\" );     require(us.amount >= amount, \"Amount is too high\");     transferFromContract(msg.sender, amount);     us.amount -= amount;     // set cool down end to 0 to release gas if new unstaking amount is 0     if (us.amount == 0)         us.coolDownEnd = 0;     emit UnstakeRedeemed(validatorId, msg.sender, amount); } ```  The last parameter of `transferUnstakedOut()` is named `stakingId`, while other functions is using `unstakingId`. This is inconsistent and can be misleading.  ### Recommendation  Change from `stakingId` to `unstakingId`.  "}, {"title": "`unstake` should update exchange rates first", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/57", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  cmichel   # Vulnerability details  The `unstake` function does not immediately update the exchange rates. It first computes the `validatorSharesRemove = tokensToShares(amount, v.exchangeRate)` **with the old exchange rate**.  Only afterwards, it updates the exchange rates (if the validator is not disabled):  ```solidity // @audit shares are computed here with old rate uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate); require(validatorSharesRemove > 0, \"Unstake amount is too small\");  if (v.disabledEpoch == 0) {     // @audit rates are updated here     updateGlobalExchangeRate();     updateValidator(v);     // ... } ```  ## Impact More shares for the amount are burned than required and users will lose rewards in the end.  ## POC Demonstrating that users will lose rewards:  1. Assume someone staked `1000 amount` and received `1000 shares`, and `v.exchangeRate = 1.0`. (This user is the single staker) 2. Several epochs pass, interest accrues, and `1000 tokens` accrue for the validator, `tokensGivenToValidator = 1000`. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens. 3. But user calls `unstake(1000)`, which sets `validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000`. **Afterwards**, the exchange rate is updated: `v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0`. The staker is updated with `s.shares -= validatorSharesRemove = 0` and `s.staked -= amount = 0`. And the user receives their 1000 tokens but notice how the user's shares are now at zero as well. 4. User tries to claim rewards calling `redeemAllRewards` which fails as the `rewards` are 0.  If the user had first called `redeemAllRewards` and `unstake` afterwards they'd have received their 2000 tokens.  ## Recommended Mitigation Steps The exchange rates always need to be updated first before doing anything. Move the `updateGlobalExchangeRate()` and `updateValidator(v)` calls to the beginning of the function.   "}, {"title": "Code Style: private/internal function names should be prefixed with `_`", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L74  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L82  - updateGlobalExchangeRate() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L118  - updateValidator() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L134  - sharesToTokens() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L157-L164  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L183-L188  ```solidity if (msg.sender == v._address){     require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, \"Amount is less than minimum staked required\"); } else {     // otherwise need to check for max cap     uint128 validatorStaked = v.stakings[v._address].staked; ```  `v._address` is read twice.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L345-L351  ```solidity function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {         validators[validatorsN]._address = validator;         validators[validatorsN].operator = operator;         validators[validatorsN].commissionRate = commissionRate;         emit ValidatorAdded(validatorsN, validator, operator);         validatorsN +=1;     } ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L437-L446  ```solidity function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {         commissionRates = new uint128[](validatorsN);         delegated = new uint128[](validatorsN);         for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];             commissionRates[i] = v.commissionRate;             delegated[i] = v.delegated - v.stakings[v._address].staked;         }         return (commissionRates, delegated);     } ```  `validatorsN` is read 3 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L450-L459  ```solidity function getDelegatorDetails(address delegator) public view returns( uint[] memory delegated,  uint[] memory rewardsAvailable, uint[] memory commissionRewards) {        delegated = new uint[](validatorsN);        rewardsAvailable = new uint[](validatorsN);        commissionRewards = new uint[](validatorsN);        uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;        uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;          for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];  ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L313-L322  ```solidity if(msg.sender == v._address){     require(rewards + v.commissionAvailableToRedeem >= amount, \"Cannot redeem more than available\");     // first redeem rewards from commission     uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;     // if there is more, redeem  it from regular rewards     if (commissionLeftOver == 0){         uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);         s.shares -= validatorSharesRemove;         v.totalShares -= validatorSharesRemove;     } ```  `v.commissionAvailableToRedeem` is read 4 times.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L111-L111  ```solidity rewardsLocked -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L201-L202  ```solidity totalGlobalShares += globalSharesToAdd; v.globalShares += globalSharesToAdd; ```   https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L261-L261  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L350-L350  ```solidity validatorsN +=1; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L415-L415  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L428-L428  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L316-L319  ```solidity uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0; // if there is more, redeem  it from regular rewards if (commissionLeftOver == 0){     uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate); ```  "}, {"title": "Avoid unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L101-L115  ```solidity function takeOutRewardTokens(uint128 amount) public onlyOwner {     require(amount > 0, \"Amount is 0\");     uint128 currentEpoch = uint128(block.number);     uint128 epochs = amount / allocatedTokensPerEpoch;     if (endEpoch != 0){         require(endEpoch - epochs > currentEpoch, \"Cannot takeout rewards from past\");         endEpoch = endEpoch - epochs;     }     else{         require(rewardsLocked >= amount, \"Amount is greater than available\");         rewardsLocked -= amount;     }     transferFromContract(owner(), amount);     emit AllocatedTokensTaken(amount); } ```  Since the `takeOutRewardTokens()` function is `onlyOwner`, `transferFromContract(owner(), amount);` can be changed to `transferFromContract(msg.sender, amount);` to avoid unnecessary internal call and storage read to save some gas.  "}, {"title": "Code duplication", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  Duplicated or logically equivalent code can be hard to maintain. Avoiding code duplication is recommended when feasible.  For example, most of the business logic in `redeemAllRewards()` and `redeemRewards()` is the same.  Consider calculating the amount of the total rewards in `redeemAllRewards()` and call `redeemRewards()` with the amount to reduce code duplication.  "}, {"title": "Usage of an incorrect version of `Ownbale` library can potentially malfunction all `onlyOwner` functions", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/45", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L62-L63  ```solidity // this is used to have the contract upgradeable function initialize(uint128 minStakedRequired) public initializer { ```  Based on the context and comments in the code, the `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract.  However, the current implementaion is using an non-upgradeable version of the `Ownbale` library: `@openzeppelin/contracts/access/Ownable.sol` instead of the upgradeable version: `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`.  A regular, non-upgradeable `Ownbale` library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.  As a result, all the `onlyOwner` functions will be inaccessible.  ### Recommendation  Use `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol` and `@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol` instead.  And change the `initialize()` function to:  ```solidity function initialize(uint128 minStakedRequired) public initializer {     __Ownable_init();     ... } ```  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L57  ```solidity=57 event TransferedUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId); ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L419  ```solidity=419 emit TransferedUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId); ```  `Transfered` should be `Transferred`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L303-L304  ```solidity // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards     function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) public { ```  `comissions` should be `commissions`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L392-L393  ```solidity // only owner can change comission rate     function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner { ```  `comission` should be `commission`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L374-L375  ```solidity // calclate how much rewards would be distribited with the old emission rate uint128 futureRewards = allocatedTokensPerEpoch * epochs; ```  `calculate` should be `calculate`. `distribited` should be `distributed`.  "}, {"title": "getDelegatorDetails declaration inside a loop", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  Declaration inside a loop is less gas efficient than before it. See line 462 for example.  "}, {"title": "++i is more gas efficient than i++ in loops forwarding", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  ++i is more gas efficient than i++ in loops forwarding. At line 440 for example. We would also recommend to use unchecked{++i} and change i declaration to uint256  "}, {"title": "Line 127 lack of precision", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  The following calculation can be more numeric precise: uint128 perEpochRateIncrease =uint128(uint256(allocatedTokensPerEpoch)*divider/uint256(totalGlobalShares));  globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch);   Change it to: uint128 perEpochRateIncrease =uint256(allocatedTokensPerEpoch)*divider; globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch) / uint256(totalGlobalShares);  "}, {"title": "emit initialize", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  You forgot emit event at the end of initialize function.  "}, {"title": "state variable divider could be set immutable.", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  state variable divider could be set immutable. At line 9.  "}, {"title": "takeOutRewardTokens(): Optimise epochs calculation and comparison ", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The following lines in `takeOutRewardTokens()` are only needed in the case where `endEpoch != 0`.  ```jsx uint128 currentEpoch = uint128(block.number); uint128 epochs = amount / allocatedTokensPerEpoch; ```  Hence, they can be shifted inside the \"if\" block.  Furthermore, a double calculation of `endEpoch - epochs` can be avoided by saving the result into a new variable `newEpoch`.  ## Recommended Mitigation Steps  ```jsx if (endEpoch != 0) {   uint128 newEpoch = endEpoch - (amount / allocatedTokensPerEpoch);   require(newEpoch  > uint128(block.number), \"Cannot takeout rewards from past\");   endEpoch = newEpoch; } ```  "}, {"title": "addValidator(): Validator's commission rate should be checked to not exceed divider", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The check `require(amount < divider, \"Rate must be less than 100%\");` exists in `setValidatorComissionRate()` but not in `addValidator()`.  ### Recommended Mitigation Steps  Add the check in `addValidator()` as well.  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L75 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L83 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L91 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L184 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L218 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L233 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L314 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L326 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L358 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L410 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L411  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  Or in contracts using solc version 0.8.4 or greater use the Custom Errors feature.    "}, {"title": "Incorrect updateGlobalExchangeRate implementation", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact UpdateGlobalExchangeRate has incorrect implementation when `totalGlobalShares` is zero.  If any user didn't start stake, `totalGlobalShares` is 0, and every stake it will increase. but there is possibility that `totalGlobalShares` can be 0 amount later by unstake or disable validator.  ## Proof of Concept https://github.com/xYrYuYx/C4-2021-10-covalent/blob/main/test/c4-tests/C4_issues.js#L76 This is my test case to proof this issue.  In my test case, I disabled validator to make `totalGlobalShares` to zero. And in this case, some reward amount will be forever locked in the contract. After disable validator, I mined 10 blocks, and 4 more blocks mined due to other function calls, So total 14 CQT is forever locked in the contract.   ## Tools Used Hardhat test  ## Recommended Mitigation Steps Please think again when `totalGlobalShares` is zero.  "}, {"title": "reset rewardsLocked to 0 when no longer used", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _stake() initializes endEpoch using the value of rewardsLocked. Afterwards rewardsLocked is no longer used (because now endEpoch !=0)  So you can set rewardsLocked to 0 save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L171-L176  ## Tools Used  ## Recommended Mitigation Steps Update to code of  _stake() to: if (endEpoch == 0) {            endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch;            rewardsLocked = 0; // no longer used and saves a bit of gas }  "}, {"title": "reward tokens could get lost due to rounding down", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function depositRewardTokens divides the \"amount\" of tokens by allocatedTokensPerEpoch to calculate the endEpoch. When \"amount\" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down, effectively losing a number of tokens for the rewards.  For example if allocatedTokensPerEpoch is set to 3e18 and \"amount\" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.  A similar problem occurs here: - in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch  - in takeOutRewardTokens(), with the retrieval of tokens  - in _stake(), when initializing endEpoch (e.g. when endEpoch==0)   ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L90-L98  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L368-L383  ## Tools Used  ## Recommended Mitigation Steps In depositRewardTokens() add, in the beginning of function, before the if statement: require(amount % allocatedTokensPerEpoch == 0,\"Not multiple\");  In takeOutRewardTokens() add: require(amount % allocatedTokensPerEpoch == 0,\"Not multiple\");  Update setAllocatedTokensPerEpoch() to something like:  if (endEpoch != 0) {       ...    uint128 futureRewards = ...    require(futureRewards % amount ==0,\"Not multiple\");    ...    } else { // to prevent issues with _stake()     require(rewardsLocked % allocatedTokensPerEpoch==0,\"Not multiple\"); }    "}, {"title": "Unnecessary require checker", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact In `disableValidator` function, validatorId checker is not required, or it is good to change require order for better contract.  ## Proof of Concept If `validatorId` is higher than `validatorsN`, it means, that validator is not initialized, so `validator._address` is always `address(0)`. so it will revert in Line 358. It means that Line 359 cannot be executed at all.  ## Tools Used  ## Recommended Mitigation Steps Move Line 359 (https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L359) at the top of function body, before get validator storage variable. This is good to track correct issue.  Or   You can remove that line. So if validatorId is invalid, the error message will be `Caller is not the owner or the validator`, because validator._address = address(0) which cannot be caller.  "}, {"title": "Recommend to use OZ SafeERC20 library", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact This is too complicated steps to transfer ERC20 token which could use more gas. You don't need to check balance before transfer. If there is no enough balance, it SafeERC20 will revert. Also you don't need to check balance after transfer, because CQT does not have transaction fee.  ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used  ## Recommended Mitigation Steps Since there is no transaction fee in CQT token, you can use OZ SafeERC20 library to send or receive.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L28   "}, {"title": "WadRayMath state variables", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  WadRayMath state variables WAD, halfWAD could be set private.  "}, {"title": "caching multiple used variables", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  In Treasury.editSchedule      function editSchedule(         uint256 dripStart_,         uint256 dripRate_,         address target_,         uint256 amount_     ) public onlyAdmin {         require(tokenSchedules[target_].target != address(0), \"Target schedule doesn't exist\");         tokenSchedules[target_].dripStart = dripStart_;         tokenSchedules[target_].dripRate = dripRate_;         tokenSchedules[target_].amount = amount_;     }   We suggest to cache  tokenSchedules[target_] at start and then use the cached value to save repeated access to a *storage* state variable.  "}, {"title": "double reading from memory inside a for loop.", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  See for example the AssetsManager.rebalance function. There you read the value moneyMarkets[i] twice at the same iteration instead of caching it. This happens in the same file in many other places, deposit, withdraw and more. Inside a loop caching is very important.   "}, {"title": "UToken.__UToken_init can be frontrun", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/97", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  The function __UToken_init can be frontrun. We recommend adding an initializer owner which only it allowed to call such functions, instead of the current _admin there.  Not sure whether frontrunning is Low / Medium risk.  "}, {"title": "UToken.sol _redeemFresh could be set private instead internal", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  This is one of many examples of the appearance of private instead of internal. Since we manually code reviewing and writing issues we don't list all the appearances. Calling a private function is more gas efficient than calling internal.   Here we refer to UToken.sol._redeemFresh function that is used only in UToken.sol file.   "}, {"title": "Open TODOs in `Treasury.sol`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  Line 57  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  "}, {"title": ".length in a loop", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads. An example where this could be applied:   for (uint256 i = 0; i < moneyMarkets.length; i++) Solution:   uint moneyMarketsLength = moneyMarkets.length;   for (uint256 i = 0; i < moneyMarketsLength; i++) Cache the length of the array and use this local variable when iterating over the storage array.  "}, {"title": "Pre-calculate known values", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This duration calculation does not change so can be pre-calculated to reduce gas costs:   // before   amount = (vestingAmount * (block.timestamp - lastUpdate)) / (vestingEnd - vestingBegin);    // after   uint256 public constant VESTING_DURATION; // constant state variable   VESTING_DURATION = vestingEnd - vestingBegin; // assign value in the constructor   amount = (vestingAmount * (block.timestamp - lastUpdate)) / VESTING_DURATION;  Same with this:   return (token.getPastTotalSupply(blockNumber) * 4e16) / 1e18; //4%   "}, {"title": "Struct with only 1 element", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is not efficient to have a struct with only 1 field as structs are meant for grouping related information together. A market struct can be replaced by directly pointing to a bool value:     //before     mapping(address => Market) public supportedMarkets;     struct Market {         bool isSupported;     }     //after    mapping(address => bool) public supportedMarkets;   "}, {"title": "Two-step change of a critical parameter", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In Treasury function setAdmin allows an admin to change it to a different address. This function has no validations, even a simple check for zero-address is missing, and there is no validation of the new address being correct. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked because the swivel cannot be corrected and none of the other functions that require admin caller can be executed. A similar issue was reported in a previous contest and was assigned a severity of medium: https://github.com/code-423n4/2021-06-realitycards-findings/issues/105  ## Recommended Mitigation Steps Consider either introducing a two-step process or making a test call to the new admin before updating it.  "}, {"title": "Comptroller rewards can be artificially inflated and drained by manipulating [totalStaked - totalFrozen] (or: wrong rewards calculation)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  kenzo   # Vulnerability details  By adding a small of amount of staking to a normal user scenario, and not approving this small amount as a loan for anybody, a staker can gain disproportionate amounts of comptroller rewards, even to the point of draining the contract. For example: Stakers A,B,C stake 100, 65, 20, approve it for borrower Z, then staker B stakes an additional 0.07 DAI, and borrower Z borrows 185. This will result in disproportionate amount of rewards.   As far as I see, this is the main line that causes the inflated amount (*deep breath*): In calculateRewardsByBlocks, you set: ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Note that a staker can make this amount very small (depending of course on the current numbers of the protocol). (A more advanced attacker might diminish the effect of the current numbers of the protocol by initiating fake loans to himself and not paying them.) This field is then passed to calculateRewards, and passed further to _getInflationIndexNew, and further to _getInflationIndex. passed to calculateRewards : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167 passed to _getInflationIndexNew : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L259 passed to _getInflationIndex : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L238 Now we actually use it in the following line (as effectiveAmount): ``` return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L315 So 2 things are happening here: 1. mul by ```inflationPerBlock(effectiveAmount)``` - uses the lookup table in Comptroller. This value gets bigger as effectiveAmount gets smaller, and if effectiveAmount is in the area of 10**18, we will get the maximum amount of the lookup. 2. div by ```effectiveAmount``` - as we saw, this can be made small, thereby enlarging the result. All together, this calculation will be set to ```curInflationIndex``` and then used in the following line: ``` return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex); ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L263 Note the ```curInflationIndex - startInflationIndex```: per my POC (see below), this can result in a curInflationIndex which is orders of magnitude larger (200x) than startInflationIndex. This creates a huge inflation of rewards.  ## Impact Comptroller rewards can be drained.  ## Proof of Concept See the following script for a POC of reward drainage. It is based on the scenario in test/integration/testUserManager: Stakers A,B,C stake 100, 65, 20, and borrower Z borrows 185. But the difference in my script is that just before borrower Z borrows 185, staker B stakes an additional 0.07 DAI. (This will be the small amount that is ```totalStaked - totalFrozen```). Then, we wait 11 blocks to make the loan overdue, call updateOverdueInfo so totalFrozen would be updated, and then staker B calls withdrawRewards. He ends up with 873 unionTokens out of the 1000 the Comptroller has been seeded with. And this number can be enlarged by changing the small additional amount that staker B staked. In this scenario, when calling withdrawRewards, the calculated ```curInflationIndex``` will be 215 WAD, while ```startInflationIndex``` is 1 WAD, and this is the main issue as I understand it.  File password: \"union\". https://pastebin.com/3bJF8mTe   ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Are you sure that this line should deduct the totalFrozen? ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Per my tests, if we change it to just  ``` userManagerData.totalStaked = userManagerContract.totalStaked(); ``` Then we are getting normal results again and no drainage. And the var _is_ called just totalStaked... So maybe this is the change that needs to be made? But maybe you have a reason to deduct the totalFrozen. If so, then a mitigation will perhaps be to limit curInflationIndex somehow, maybe by changing the lookup table, or limiting it to a percentage from startInflationIndex ; but even then, there is also the issue of dividing by ```userManagerData.totalStaked``` which can be made quite small as the user has control over that.  "}, {"title": "`UToken.sol` should inherits and complies with `IUToken.sol`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/77", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, `UToken.sol` does not inherit and comply with `IUToken.sol`. This is against the best practices and inconsistent with other contracts in the codebase that do inherit and comply with their interfaces.  For example, the `repay()` function defined in `IUToken.sol` is implementated as `repayBorrowBehalf()` and `repayBorrow()`.  It makes the `IUToken.sol` unable to be used and misleading.  ### Recommendation  Make `UToken.sol` inherits and complies with `IUToken.sol`.  "}, {"title": "Gas: Explicit overflow checks even though solidity 0.8 is used (2)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `removeReserves` can be removed:  ```solidity // We checked reduceAmount <= totalReserves above, so this should never revert. // @audit this overflow check already happened implicitly require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\"); ```  "}, {"title": "Gas: Explicit overflow checks even though solidity 0.8 is used (1)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `addReserves` can be removed:  ```solidity /* Revert on overflow */ // @audit this overflow check already happened implicitly require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\"); totalReserves = totalReservesNew; ```  "}, {"title": "`UnionToken` should check whitelist on `from`?", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UnionToken` can check for a whitelist on each transfer in `_beforeTokenTransfer`:  ```solidity if (whitelistEnabled) {     require(isWhitelisted(msg.sender) || to == address(0), \"Whitelistable: address not whitelisted\"); } ```  This whitelist is checked on `msg.sender` not on `from`, the token owner.  ## Impact A single whitelisted account can act as an operator (everyone calls `unionToken.allow(operator, max)` where the operator is a whitelisted trusted smart contract) for all other accounts. This essentially bypasses the whitelist.  ## Recommended Mitigation Steps Think about if the whitelist on `msg.sender` is correct or if it should be on `from`.  "}, {"title": "`repayBorrowWithPermit` is missing `nonReentrant`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken.repayBorrowWithPermit` function is missing the `repayBorrowWithPermit` modifier which the other repay functions (`repayBorrow`, `repayBorrowBehalf`) have.  ## Impact There's a possibility for re-entrancy. Even though I did not find a way to exploit it, it seems like this function should have the `nonReentrant` modifier as the other similar `repay*` functions have it as well.  ## Recommended Mitigation Steps Add `nonReentrant` to `repayBorrowWithPermit`.  "}, {"title": "`borrow` must `accrueInterest` first", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/66", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken.borrow` function first checks the borrowed balance and the old credit limit _before_ accruing the actual interest on the market:  ```solidity // @audit this uses the old value require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");  require(     // @audit this calls uToken.calculateInterest(account) which returns old value     uint256(_getCreditLimit(msg.sender)) >= amount + fee,     \"UToken: The loan amount plus fee is greater than credit limit\" );  // @audit accrual only happens here require(accrueInterest(), \"UToken: accrue interest failed\"); ```  Thus the borrowed balance of the user does not include the latest interest as it uses the old global `borrowIndex` but the new `borrowIndex` is only set in `accrueInterest`.  ## Impact In low-activity markets, it could be that the `borrowIndex` accruals (`accrueInterest` calls) happen infrequently and a long time is between them. A borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued. This will lead to borrowers being able to borrow more than `maxBorrow` and **more than their credit limit** as these checks are performed before updating accruing interest.  ## Recommended Mitigation Steps The `require(accrueInterest(), \"UToken: accrue interest failed\");` call should happen at the beginning of the function.   "}, {"title": "Unbounded iteration in `deleteMarket`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MarketRegistry.deleteMarket` iterates over all `uTokenList` elements.  ## Impact The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Recommended Mitigation Steps Keep the array small or use an [EnumerableSet])(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) that can delete in constant time.  "}, {"title": "Rebalance will fail due to low precision of percentages", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:  ```solidity require(token.balanceOf(address(this)) == 0, \"AssetManager: there are remaining funds in the fund pool\"); ```  The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to `1e4`). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`. This will leave dust in the contract in most cases as the tokens have much higher precision.  ## POC Assume the last market does not support the token and thus `percentages` are chosen as `[5000, 5000]` to rebalance the first two markets. Withdrawing all tokens form the markets leads to a `tokenSupply = token.balanceOf(address(this)) = 10,001`:  Then the deposited amount is `amountToDeposit = (tokenSupply * percentages[i]) / 10000 = 10,001 * 5,000 / 10,000 = 5,000`. The two deposits will leave dust of `10,001 - 2 * 5,000 = 1` in the contract and the `token.balanceOf(address(this)) == 0` balance check will revert.  ## Impact Rebalancing will fail in most cases if the last market does not support the token due to precision errors.  ## Recommended Mitigation Steps Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens.   "}, {"title": "`withdrawSeq` might not be set", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `AssetManager.withdraw` function iterates through the markets based on the `withdrawSeq` array field. This field must be manually set to cover all markets on each new market addition.  ## Impact It could be that a market is added but this array is not updated. Thus not all markets are iterated and users might not be able to withdraw their entire `amount` as the new market is skipped  ## Recommended Mitigation Steps Ensure that `withdrawSeq` is always up-to-date when `addAdapter` is called, for example, `addAdapter` could add the new adapter as the last element to `withdrawSeq` until it's manually set through `changeWithdrawSequence`.   "}, {"title": "UserManager: totalStaked \u2265 totalFrozen should be checked before and after totalFrozen is updated", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  The require statement in `updateTotalFrozen` and `batchUpdateTotalFrozen` to check that totalStaked \u2265 totalFrozen should be done both before and after `_updateTotalFrozen` is called to ensure that totalStake is still \u2265 totalFrozen. This will serve as a sanity check to ensure that the integrity of the system is not compromised.  "}, {"title": "For Loops Need Break Statements (UserManager.sol)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  There is no need to keep iterating through a loop for the full length once the condition being searched for is met.  This will save gas.  ## Proof of Concept  The loops are here: https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L436-L441 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L444-L449 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L479-L485 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L488-L495  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a \"break\" statement to the loops mentioned above. Note also that there are unnecessary default value initializations of variables associated with the loops.  "}, {"title": "Change in interest rate can disable repay of loan", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The ability of a borrower to repay a loan is disabled if the interest rate is  set too high by the `InterestRateModel`.  However, there is neither a check when setting the interest rate nor an  indication in the `IInterestRateModel`'s specs of this behavior.  But this issue could also be used in an adversarial fashion by the  `FixedInterestRateModel`-owner if he/she would disable the repay functionality  for some time and enables it at a later point again with the demand of a  higher interest to be paid by the borrower.  ## Proof of Concept If an account wants to repay a loan, the function  `UToken::_repayBorrowFresh()` is used. This function calls  `UToken::accrueInterest()` ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L465) 465)  which fetches the current borrow rate of the interest rate model  ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L546) 546  and [line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L330) 330).  The function `UToken::borrowRatePerBlock()` requires an not \"absurdly high\"  rate, or fails otherwise ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L331) 331).  However, there is no check or indicator in `FixedInterestRateModel.sol` to  prevent the owner to set such a high rate that effectively disables repay of borrowed funds ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/FixedInterestRateModel.sol#L36) 36).  ## Recommended Mitigation Steps Disallow setting the interest rate too high with a check in  `FixedInterestRateModel::setInterestRate()`.  "}, {"title": "Missing events for owner only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in UserManager.sol.  ## Proof of Concept   Missing events  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L156  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L160   See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  "}, {"title": "setHalfDecayPoint check allowed values", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setHalfDecayPoint allows setting an arbitrary value of halfDecayPoint. However if halfDecayPoint == 0 then inflationPerBlock will have a division by 0.  Probably it is also useful to have an upper limit for halfDecayPoint.  ## Proof of Concept https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L67-L69  https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L275-L278   ## Tools Used  ## Recommended Mitigation Steps In the function setHalfDecayPoint: Verify that the new value of halfDecayPoint is within an allowable range ( certainly != 0)  "}, {"title": "Zero-address checks are missing", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Zero-address checks are a best-practise for input validation of critical address parameters. While the codebase applies this to most addresses in setters, there are many places where this is missing in constructors and setters.  Impact: Accidental use of zero-addresses may result in exceptions, burn fees/tokens or force redeployment of contracts.  ## Proof of Concept  The following code sections are missing zero address check.   https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L36 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L104 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/TreasuryVester.sol#L19 https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Whitelistable.sol#L55 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L157 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L170 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L138 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L142 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L721 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/MarketRegistry.sol#L59 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L78 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L72 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L89 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L93   ## Tools Used  None  ## Recommended Mitigation Steps  Consider to Add zero-address checks.    "}, {"title": "Null check in pricePerShare", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L73  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123  oracle can `0` as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L148 ) resulting in Denial Of Service.  Add a null check to ensure that on every update, the price is greater than 0.  "}, {"title": "WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/87", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  ## Proof of Concept In WrappedIbbtcEth pricePerShare variable is updated by externally run updatePricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72, and then used in mint/burn/transfer functions without additional checks via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155.  In WrappedIbbtc price is requested via pricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123, and used in the same way without additional checks via balanceToShares function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L147.   ## Recommended Mitigation Steps Introduce minting/burning query that runs on schedule, separating user funds contribution and actual mint/burn. With user deposit or burn the corresponding action to be added to commitment query, which execution for mint or redeem will later be sparked by off-chain script according to fixed schedule. This also can be open to public execution with gas compensation incentive, for example as it's done in Tracer protocol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolKeeper.sol#L131 Full code of an implementation is too big to include it in the report, but viable versions are available publicly (Tracer protocol version can be found at the same repo, https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolCommitter.sol).  Once the scheduled mint/redeem query is added, the additional logic to control for price outliers will become possible there, as in this case mint/redeem execution can be conditioned to happen on calm market only, where various definitions of calm can be implemented. One of the approaches is to keep track of recent prices and require that new price each time be within a threshold from median of their array.  Example:  // Introduce small price tracking arrays: uint256[] private times; uint256[] private prices;  // Current position in array uint8 curPos;  // Current length, grows from 0 to totalMaxPos as prices are being added uint8 curMaxPos;  // Maximum length, we track up to totalMaxPos prices uint8 totalMaxPos = 10;  // Price movement threshold uint256 moveThreshold = 0.1*1e18;  We omit the full implementation here as it is lengthy enough and can vary. The key steps are: * Run query for scheduled mint/redeem with logic: if next price is greater than median of currently recorded prices by threshold, add it to the records, but do not mint/redeem. * That is, when scheduled mint/redeem is run, on new price request, WrappedIbbtcEth.core.pricePerShare() or WrappedIbbtc.oracle.pricePerShare(), get newPrice and calculate current price array median, curMed * prices[curPos] = newPrice * if (curMaxPos < totalMaxPos) {curMaxPos += 1} * if (curPos == curMaxPos) {curPos = 0} else {curPos += 1} * if (absolute_value_of(newPrice - curMed) < moveThreshold * curMed / 1e18) {do_mint/redeem; return_0_status} * else {return_1_status}  Schedule should be frequent enough, say once per 30 minutes, which is kept while returned status is 0. While threshold condition isn't met and returned status is 1, it runs once per 10 minutes. The parameters here are subject to calibration. This way if the price movement is sustained the mint/redeem happens after price array median comes to a new equilibrium. If price reverts, the outbreak will not have material effect mint/burn operations. This way the contract vulnerability is considerably reduced as attacker would need to keep distorted price for period long enough, which will happen after the first part of deposit/withdraw cycle. I.e. deposit and mint, burn and redeem operations will happen not simultaneously, preventing flash loans to be used to elevate the quantities, and for price to be effectively distorted it would be needed to keep it so for substantial amount of time.  "}, {"title": "WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/86", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact Malicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.  ## Proof of Concept WrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason. The variable is used via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155  This is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages). updatePricePerShare function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72  ## Recommended Mitigation Steps The risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:  Introduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.  Then 2 variants of transferFrom and transfer functions can be introduced, both check condition {now - time since last price update < threshold}. If condition holds both variants do the transfer. If it doesn't the first variant reverts, while the second do costly price update. I.e. it will be cheap transfer, that works only if price is recent, and full transfer, that is similar to the first when price is recent, but do price update on its own when price is stalled. This way this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.  After this whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.  Example code:    // Added threshold      uint256 public pricePerShare;     uint256 public lastPricePerShareUpdate;   uint256 public priceUpdateThreshold;      event SetPriceUpdateThreshold(uint256 priceUpdateThreshold);        /// ===== Permissioned: Price update threshold =====     function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external onlyGovernance {         priceUpdateThreshold = _priceUpdateThreshold;         emit SetPriceUpdateThreshold(priceUpdateThreshold);     }      // The only difference with current transfer code is that Full versions call balanceToSharesFull      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));         return true;     }      function transfer(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }        function transferFromFull(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));         return true;     }      function transferFull(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }      // Now balanceToShares first checks if the price is stale   // And reverts if it is   // While balanceToSharesFull do the same check   // But asks for price instead of reverting   // Having guaranteed execution with increased costs sometimes   // Which is fully deterministic, as user can track SetPricePerShare event   // To understand whether it be usual or increased gas cost if the function be called now      function balanceToShares(uint256 balance) public view returns (uint256) {     require(block.timestamp < lastPricePerShareUpdate + priceUpdateThreshold, \"Price is stalled\");         return balance.mul(1e18).div(pricePerShare);     }        function balanceToSharesFull(uint256 balance) public view returns (uint256) {     if (block.timestamp >= lastPricePerShareUpdate + priceUpdateThreshold) {       updatePricePerShare();     }         return balance.mul(1e18).div(pricePerShare);     }  "}, {"title": "use of depreciated \"now\" ", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact In updatePricePerShare() instead of \"block.timestamp\" , \"now\"  is used which is deprciated.  \"block.timestamp\" is way more explicit in showing the intent while \"now\"  relates to the timestamp of the block controlled by the miner  more on this -> https://github.com/ethereum/solidity/issues/4020    ## Tools Used manual review  ## Recommended Mitigation Steps use block.timestamp  "}, {"title": "Check if amount is not zero", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions mint, burn, transfer and transferFrom could skip other steps if the amount is 0.   "}, {"title": "onlyOracle never used", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact modifier onlyOracle in WrappedIbbtc is never used, so can be removed to reduce deployment gas costs.   "}, {"title": "ICore import", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact You import ICore interface but actually need only one function from it: pricePerShare(). Consider importing a minimal ICore interface with only the functions that you actually use to reduce deployment gas costs. Or you can just simply re-use ICoreOracle.   "}, {"title": "Consider making contracts Pausable", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are many external risks (mentioned https://github.com/code-423n4/2021-10-badgerdao#risks) so my suggestion is that you should consider making the contracts pausable, so in case of an unexpected event, the governance can pause transfers.  ## Recommended Mitigation Steps Consider making contracts Pausable https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol  "}, {"title": "pendingGovernance and  Governace address can be same", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact when pendingGovernance  call acceptPendingGovernance() , governance value get updated  but pendingGovernance  remain same its not updated to address(0)   governance = pendingGovernance;  due to which pendingGovernace and Governace share same address which should not happen  ## Tools Used manual review  ## Recommended Mitigation Steps update pendingGovernance to address(0)  "}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of the contract use floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed pragma  "}, {"title": "PREVENT DIV BY 0", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn\u2019t done.  Especially in the balanceToShares function div(pricePerShare) which isn\u2019t checked.   That will cause to revert on the transfer and transferFrom function. Oracle pricePerShare variable should be cheked on the balance calculation.  ## Proof of Concept  1. Navigate to the following contracts,  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L156\"  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L148\"  2. If oracle fails, the pricePerShare variable will be equal to zero therefore div by zero will occur.  ## Tools Used  Review  ## Recommended Mitigation Steps  Recommend making sure division by 0 won\u2019t occur by checking the variables beforehand and handling this edge case.  "}, {"title": "Deprecated Function Usage", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  \"https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L74\"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.   "}, {"title": "No sanity check on pricePerShare might lead to lost value", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  kenzo   # Vulnerability details  pricePerShare is read either from an oracle or from ibBTC's core.  If one of these is bugged or exploited, there are no safety checks to prevent loss of funds.  ## Impact As pricePerShare is used to calculate transfer amount, a bug or wrong data which returns smaller pricePerShare than it really is could result in drainage of wibbtc from Curve pool.  ## Proof of Concept Curve's swap and remove liquidity functions will both call wibbtc's `transfer` function: https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L790 https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L831 The `transfer` function calculates the amount to send by calling `balanceToShares`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L127 `balanceToShares` calculates the shares (=amount to send) by dividing in `pricePerShare`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L156 Therefore, if due to a bug or exploit in ibBTC core / the trusted oracle pricePerShare is smaller than it really is, the amount that will be sent will grow larger. So Curve will send to the user/exploiter doing swap/remove liquidity more tokens that he deserves.  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Add sanity check:  pricePerShare should never decrease but only increase with time (as ibbtc accrues interest) (validated with DefiDollar team). This means that on every pricePerShare read/update, if the new pricePerShare is smaller than the current one, we can discard the update as bad data.   This will prevent an exploiter from draining Curve pool's wibbtc reserves by decreasing pricePerShare.  "}, {"title": "The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/65", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the documentation, `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.  Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.  The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the `pricePerShare` increases.  Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored `reserves` to match the balances.  ### PoC  Given:  - The current `pricePerShare` is: `1`; - The Curve pool is newly created with 0 liquidity;  1. Alice added `100 wibBTC` and `100 wBTC` to the Curve pool; Alice holds 100% of the pool; 2. After 1 month with no activity (no other users, no trading), and the `pricePerShare` of `ibBTC` increases to `1.2`; 3. Alice removes all the liquidity from the Curve pool.  While it's expected to receive `150 wibBTC` and `100 wBTC`, Alice actually can only receive `100 wibBTC` and `100 wBTC`.  ### Recommendation  Consider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.  "}, {"title": "Redundant use of `virtual`", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, the functions listed below are not expected to be overridden, thus the use of the keyword `virtual` is redundant.  - transfer() - updatePricePerShare() - transferFrom() - pricePerShare()  ### Recommendation  Consider removing `virtual` for these functions.  "}, {"title": "`updatePricePerShare` should be run atomically with `setCore()` to make sure `pricePerShare` is up-to-date with the new Core", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Given that `setCore()` could potentially lead to a change of `pricePerShare`, and `pricePerShare` will not be updated until `updatePricePerShare()` is called separately.  To ensure `pricePerShare` is up-to-date, `updatePricePerShare` should be run atomically with `setCore()`.  ### Recommendation  Consider changing `setCore()` to:  ```solidity function setCore(address _core) external onlyGovernance {     core = ICore(_core);      updatePricePerShare();      emit SetCore(_core); } ```  "}, {"title": "Avoid unnecessary external calls and storage writes can save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L69-L77  ```solidity /// @dev Update live ibBTC price per share from core /// @dev We cache this to reduce gas costs of mint / burn / transfer operations. /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  Per the comment above `function updatePricePerShare()`, `updatePricePerShare()` may get called quite often when `wibBTC` token is being used more often.  There could potentially be multiple calls to `updatePricePerShare()` in one block. In that case, checking if `pricePerShare` was updated earlier in the same block can save some gas from unnecessary external calls and storage writes.  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     if (lastPricePerShareUpdate < now) {         pricePerShare = core.pricePerShare();         lastPricePerShareUpdate = now;          emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);     } } ```  "}, {"title": "Constants are not explicitly declared", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  The literal `1e18` is used throughout the contracts multiple times.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  "}, {"title": "Consider removing `ICore.sol`", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Most of the interfaces defined in `ICore.sol` are unused. The only method used is `pricePerShare()` which is identical to `ICoreOracle.sol#pricePerShare()`.  Therefore, `ICore.sol` can be removed and replaced by `ICoreOracle.sol`.  "}, {"title": "Consider caching `pricePerShare` for `WrappedIbbtc.sol` to save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current implementation of `WrappedIbbtc.sol` will do an external call `oracle.pricePerShare()` every time `pricePerShare` is used, it can be gas consuming considering that the basic features include: `balanceOf()`, `transfer()`, `transferFrom()` will be used very often.  ### Recommendation  Consider caching `pricePerShare` in storage.  "}, {"title": "Inconsistent use of `_msgSender()`", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L23-L36  ```solidity modifier onlyPendingGovernance() {     require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");     _; }  modifier onlyGovernance() {     require(msg.sender == governance, \"onlyGovernance\");     _; }  modifier onlyOracle() {     require(msg.sender == address(oracle), \"onlyOracle\");     _; } ```  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131  ```solidity function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")     /// Some naming confusion emerges due to maintaining original ERC20 var names      uint256 amountInShares = balanceToShares(amount);      _transfer(_msgSender(), recipient, amountInShares);     return true; } ```  "}, {"title": "Cache external call result in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L72-L77  ```solidity function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     uint256 lastPricePerShare = core.pricePerShare();     pricePerShare = lastPricePerShare;     lastPricePerShareUpdate = now;      emit SetPricePerShare(lastPricePerShare, lastPricePerShareUpdate); } ```  "}, {"title": "Approved spender can spend too many tokens", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/43", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  cmichel   # Vulnerability details  The `approve` function has not been overridden and therefore uses the internal _shares_, whereas `transfer(From)` uses the rebalanced amount.  ## Impact The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.  Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).  ## Recommended Mitigation Steps The `_allowances` field should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding the `approve` function.) In `transferFrom`, the approvals should then be subtracted by the _transferred_ `amount`, not the `amountInShares`:  ```solidity // _allowances are in rebalanced amounts such that they don't grow // need to subtract the transferred amount _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")); ```  "}, {"title": "Pending governance is not cleared", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  cmichel   # Vulnerability details  The `acceptPendingGovernance` function does not reset `pendingGovernance` to zero.  ## Impact The pending governor can repeatedly accept the governance, emitting an `AcceptPendingGovernance` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Validate the parameters.   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `WrappedIbbtcEth.initialize`: The parameters could be checked to be non-zero or even if they're contracts implementing the desired interfaces.  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "Add zero address validation in the setPendingGovernance function", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Since the _pendingGovernance parameter in the setPendingGovernance are used to add governance. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract.  ## Proof of Concept  1. Navigate to the following contract functions.  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L50\"  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L49\"  2. Adding zero address into the pending governance leads to failure of governor only functions.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.   "}, {"title": "Lack of `address(0)` check", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The arguments of type `address` in the following functions miss a zero-check.  - `initialize()` - `setPendingGovernance()` - `setOracle()`  In the case of `setPendingGovernance()`, where a zero-address could be legitim, it should be stated as such in the docs, or forbidden otherwise.  ## Tools Used slither  "}, {"title": "hard to clear balance", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The contract does not allow users to transfer by share. It's hard for users to clear out all the shares. There will be users using this token with Metamask. There's likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.  ## Proof of Concept [WrappedIbbtc.sol#L110-L118](https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L110-L118)  ## Tools Used  ## Recommended Mitigation Steps I consider a new `transferShares` beside the original `transfer()` would build a better UX. I consider sushi's bento box would be a good ref [BentoBox.sol](https://github.com/sushiswap/bentobox/blob/master/contracts/BentoBox.sol)  "}, {"title": "No Initial Ownership Event  (WrappedIbbtcEth.sol, WrappedIbbtcEth.sol)", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  ye0lde   # Vulnerability details  For \"core\", which can be changed by the governance process, an event is emitted when it is changed from 0 to a hopefully valid value in the initialize function.  In the same initialize function the _governance address itself is not verified nor is there an event emitted showing that the governance address has changed from 0 to a different address.  ## Proof of Concept  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37-L46  Similar but with Oracle instead of Core. https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L38-L45  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Emit an event reporting governance change or if it is not important to report these initialization events remove the emit for the core initialization.  "}, {"title": "Unable to transfer WrappedIbbtc if Oracle go down", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact In WrappedIbbtc, user will not be able to transfer if oracle.pricePerShare() (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().   If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it use the cached value in a local variable pricePerShare which is only updated upon call to updatePricePerShare().  ## Recommended Mitigation Steps Depending on the specification, one of them need to be changed.  "}, {"title": "use safeTransfer instead of transfer of ibbtc", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pants   # Vulnerability details  ibbtc is ERC20Upgradeable. Not all ERC20 contracts supports \"blind\" transfer method - i.e transfer that you can ignore the return value. You should either check the return value or use openzeppilin safeTransfer   "}, {"title": "missing zero-address check ", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  jah   # Vulnerability details  ## Impact The parameter that are used in initialize() function to initialize the state variable,these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract  ## Proof of Concept https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37  ## Tools Used Manual Analysis ## Recommended Mitigation Steps add require condition which check zero address validation   "}, {"title": "receive function", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Slingshot contract does not need a 'receive' function as it is not supposed to receive ETH directly. Executioner has this function too and it needs to receive ETH from the WETH contract. Because it expects only WETH to send the native asset directly, it should check that the msg.sender is actually WETH contract.  ## Recommended Mitigation Steps receive() external payable {   require(msg.sender == wrappedNativeToken, \"...\"); }   "}, {"title": "Combine external calls into one can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L76-L79  ```solidity=76 for(uint256 i = 0; i < trades.length; i++) {     // Checks to make sure that module exists and is correct     require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\"); } ```  An external call to `moduleRegistry.isModule()` will be called each time in this for loop. They can be combined into one external call by creating an `moduleRegistry.isModuleBatch(address[] memory _moduleAddresses)` function and call that function instead.  ### Recommendation  Change to:  ```solidity address[] memory moduleAddresses = new address[](trades.length); for(uint256 i = 0; i < trades.length; i++) {     moduleAddresses[i] = trades[i].moduleAddress; } require(moduleRegistry.isModuleBatch(moduleAddresses), \"Slingshot: not a module\"); ```  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L57-L73  ```solidity=57 /// @notice Executes multi-hop trades to get the best result ///         It's up to BE to whitelist tokens /// @param fromToken Start token address /// @param toToken Target token address /// @param fromAmount The initial amount of fromToken to start trading with /// @param trades Array of encoded trades that are atomically executed /// @param finalAmountMin The minimum expected output after all trades have been executed /// @param depricated to be removed function executeTrades(     address fromToken,     address toToken,     uint256 fromAmount,     TradeFormat[] calldata trades,     uint256 finalAmountMin,     address depricated ) external nonReentrant payable {     depricated; ```  `depricated` should be `deprecated`.   "}, {"title": "Code Style: consistency", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  WatchPug   # Vulnerability details  1. Use of `uint256` vs `uint`;      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L86      ```solidity=65     function executeTrades(         address fromToken,         address toToken,         uint256 fromAmount,         TradeFormat[] calldata trades,         uint256 finalAmountMin,         address depricated     ) external nonReentrant payable {         depricated;         require(finalAmountMin > 0, \"Slingshot: finalAmountMin cannot be zero\");         require(trades.length > 0, \"Slingshot: trades cannot be empty\");         for(uint256 i = 0; i < trades.length; i++) {             // Checks to make sure that module exists and is correct             require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");         }          uint256 initialBalance = _getTokenBalance(toToken);         _transferFromOrWrap(fromToken, _msgSender(), fromAmount);          executioner.executeTrades(trades);          uint finalBalance;     ```  2. Error message prefixed by the module name.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ApprovalHandler.sol#L14-L17      ```solidity=14     modifier onlySlingshot() {         require(isSlingshot(_msgSender()), \"Adminable: not a SLINGSHOT_CONTRACT_ROLE\");         _;     }     ```      `ApprovalHandler.sol#onlySlingshot()` The prefix `Adminable` in the error message should be `ApprovalHandler`.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L36-L38      ```solidity=36     function registerSwapModule(address _moduleAddress) public onlyAdmin {         require(!modulesIndex[_moduleAddress], \"oops module already exists\");         require(ISlingshotModule(_moduleAddress).slingshotPing(), \"not a module\");     ```      `ModuleRegistry.sol#registerSwapModule()` Error messages are not prefixed.  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `ModuleRegistry.sol#registerSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L46-L46  - `ModuleRegistry.sol#unregisterSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L61-L61  - `Executioner.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L34-L34  - `Slingshot.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L75-L76  "}, {"title": "`Adminable::setupAdmin` uses deprecated function", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The `setupAdmin` function in `Adminable.sol` uses the `_setupRole` function from OpenZeppelin's `AccessControl.sol`.  This function is marked as deprecated in favor of `AccessControl::_grantRole`.  See [line 21 in Adminable.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L21) and [line 183 in OpenZeppelin's AccessControl.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183)  "}, {"title": "Function documentation incorrect for `ConcatStrings::appendUint`", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/47", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The documentation for the function `appendUint` in `ConcatStrings.sol` is incorrect. It states: \"Concat two strings\". However, the function concats a string and a uint256.  See: [line 19 in ConcatStrings.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/lib/ConcatStrings.sol#L19)  "}, {"title": "Executioner: Restrict funds receivable to be only from wrapped native token", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/40", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Native fund transfers into the executioner contract are only expected from the wrapped token contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(wrappedNativeToken), 'only wrapped native token'); } ```  "}, {"title": "BalancerV2ModuleMatic: Ensure tokenOut is not native token", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The executioner is designed to handle only ERC20-ERC20 token trades by modules. The balancer V2 vault is able to [automatically unwrap the wrapped native token](https://dev.balancer.fi/helpers/using-native-eth#overview). Hence, it is recommended to ensure that the `tokenOut` parameter passed into the `swap()` function is not the sentinel value.  The [sentinel value used is the null address.](https://dev.balancer.fi/helpers/using-native-eth#sentinel-value)  ## Recommended Mitigation Steps  Consider adding the following check in the function.  `require(tokenOut != address(0), 'native token swap not supported');`  "}, {"title": "String concatenation in revert messages results in increased gas costs + code complexity", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Switching to custom errors results in reduced deployment/runtime gas cost + ease of decoding revert message  ## Proof of Concept  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L38  Should any of the calls to individual modules fail an error message of the form \"<ERROR> Executioner: swap failed: <STEP>\" where ERROR is the underlying error message and STEP displays which trade failed  This requires the inclusion of the `ConcatStrings` library and in order to isolate ERROR, knowledge of the string format is necessary. If instead [custom errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) were used, `ConcatStrings` could be removed which results in reduced deployment + runtime costs along with simplifying the codebase. (see [\"Errors in Depth\"](https://blog.soliditylang.org/2021/04/21/custom-errors/))  ``` // old require(success, appendString(string(data), appendUint(string(\"Executioner: swap failed: \"), i)));  // new error SwapFailed(uint256 step, bytes errorMessage); // at top of file if (!success) revert SwapFailed(i, data); ```  If this is done the Executioner's error messages can then be decoded with a standard abi decoder giving greater compatibility with other tools (helpful should you want to filter for certain error strings at some point) without them having to understand the format of your error messages.  Example of a decoded error message with arguments https://rinkeby.etherscan.io/tx/0x37004044a0a55cce13e2f1dd1813a5f21531cd875fed87ec23ae193e0bb96876  ## Recommended Mitigation Steps  Replace `ConcatStrings` library with custom errors.  "}, {"title": "Redundant Code Statement", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. Navigate to the following code sections.   https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/ApprovalHandler.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Executioner.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L3  ## Tools Used  None  ## Recommended Mitigation Steps  ABI coder v2 is activated by default. It is recommended to delete redundant codes.   From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  "}, {"title": "Use of constant `keccak` variables results in extra hashing (and so gas).", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact Increase gas costs on all `onlyAdmin` operations  ## Proof of Concept  The `SLINGSHOT_ADMIN_ROLE` variable is marked as `constant`: https://github.com/code-423n4/2021-10-slingshot/blob/f6e7a0a39e3267bbe3c7fe60d6074cbf54f5750f/contracts/Adminable.sol#L11  This results in the `keccak` operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to `immutable` will only perform hashing on contract deployment which will save gas.  See: https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646  ## Recommended Mitigation Steps  Change the variable to be `immutable` rather than `constant`  "}, {"title": "OverlayV1OVLCollateral.liquidate storage pos.market variable is read up to three times, can be saved to memory", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on storage access.  ## Proof of Concept  ```pos.market``` variable is being read up to three times from storage: https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L371  ## Recommended Mitigation Steps  Save the needed storage variable to memory and use it.  Now: ``` Position.Info storage pos = positions[_positionId]; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos.market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos.market]; ... IOverlayV1Market(pos.market).exitOI(... ```  To be: ``` Position.Info storage pos = positions[_positionId]; address memory pos_market = pos.market; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos_market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos_market]; ... IOverlayV1Market(pos_market).exitOI(... ```  "}, {"title": "Fee double counting for underwater positions", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/134", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Actual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than value of fees stored.  This can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse be failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.  ## Proof of Concept  The fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.  https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311  ## Recommended Mitigation Steps  Adjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.  Now: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt; else _userValueAdjusted = 0; ```  To be: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) {  _userValueAdjusted -= _userDebt; } else {  _userValueAdjusted = 0;  _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0; } ```   "}, {"title": "Cached version of ovl may be outdated", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address: ```solidity  IOverlayTokenNew immutable public ovl; ``` This variable is initialized in the constructor and fetched from the mothership contract: ```solidity   mothership = IOverlayV1Mothership(_mothership);   ovl = IOverlayV1Mothership(_mothership).ovl(); ``` ovl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address: ```solidity function setOVL (address _ovl) external onlyGovernor {     ovl = _ovl; } ```  OverlayV1OVLCollateral and OverlayV1Governance will still use this old cached value.  ## Recommended Mitigation Steps Consider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).  "}, {"title": "OZ ERC1155Supply vulnerability", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/127", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Overlay uses OZ contracts version 4.3.2: ```yaml   dependencies:     - OpenZeppelin/openzeppelin-contracts@4.3.2 ``` and has a contract that inherits from ERC1155Supply: ```solidity   contract OverlayV1OVLCollateral is ERC1155Supply ``` This version has a recently discovered vulnerability: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg  In your case, function unwind relies on totalSupply when calculating _userNotional, _userDebt, _userCost, and _userOi, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.  ## Recommended Mitigation Steps Consider updating to a patched version of 4.3.3.  "}, {"title": "Context and msg.sender", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contract OverlayTokenNew inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract OverlayTokenNew is Context ``` Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol  OverlayTokenNew mixes usage of msg.sender and _msgSender().  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.  "}, {"title": "Open TODOs in Codebase", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are TODOs left in the code. While this does not cause any direct issue, it indicates a bad smell and uncertainty. In previous reports, such submissions were assigned a score of 'low' so I think it's a fair game to submit this as an issue here also.  Reference: https://github.com/code-423n4/2021-09-swivel-findings/issues/67 https://github.com/code-423n4/2021-10-tempus-findings/issues/39  Also, there are some misleading comments, e.g.: ```solidity     /// @notice Internal update function to price, cap, and pay funding.     function update () public virtual returns ( ``` the comment says that function is internal but it is actually declared as public.  ## Recommended Mitigation Steps Consider implementing or removing TODOs and updating misleading comments.  "}, {"title": "Change unnecessary storage variables to constants can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/OverlayV1UniswapV3Market.sol#L14-L14  ```solidity=14 uint256 internal X96 = 0x1000000000000000000000000; ```  Some storage variables include `X96` will not never be changed and they should not be.  Changing them to `constant` can save gas.  "}, {"title": "Missing setter function for `OverlayV1Mothership#marginBurnRate`", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, `marginBurnRate` should be able to be updated after deployment. However, there is no function to update it.  ### Recommendation  Change to:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L158-L166  ```solidity=158 function adjustGlobalParams(     uint16 _fee,     uint16 _feeBurnRate,     address _feeTo,     uint _marginBurnRate ) external onlyGovernor {     fee = _fee;     feeBurnRate = _feeBurnRate;     feeTo = _feeTo;     marginBurnRate = _marginBurnRate; } ```  Or change `marginBurnRate` to immutable if it's not supposed to be updated later (for gas saving).  "}, {"title": "`OverlayV1UniswapV3Market` computes wrong market liquidity", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`. To get the market liquidity _in ETH_ (and not the other token pair), it uses the `ethIs0` boolean.  ```solidity _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  However, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the _market_ feed where the liquidity is taken from:  ```solidity // in constructor, if token0 is eth refers to ovlFeed ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;  // in fetchPricePoint, _liquidity comes from different market feed ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo); _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  ## Impact If the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted). For example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.  ## Recommended Mitigation Steps It seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.   "}, {"title": "Missing `macroWindow > microWindow` check", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.constructor` does not verify that the `marcoWindow > microWindow` but the code implicitly uses this assumption when computing the TWAPs.  ## Recommended Mitigation Steps Validate that `macroWindow > microWindow` in the constructor.   "}, {"title": "`OverlayV1UniswapV3Market` assumes one of the tokens is ETH", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/79", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market` contract assumes that one of the tokens of `_ovlFeed` is ETH but does not check it in the constructor:  ```solidity constructor(     address _mothership,     address _ovlFeed,     address _marketFeed,     address _quote,     address _eth,     uint128 _baseAmount,     uint256 _macroWindow,     uint256 _microWindow,     uint256 _priceFrameCap ) OverlayV1Market (     _mothership ) OverlayV1Comptroller (     _microWindow ) OverlayV1OI (     _microWindow ) OverlayV1PricePoint (     _priceFrameCap ) {      // immutables     eth = _eth;     // could be that token1 is not ETH either     ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;     // ... } ```  ## Impact If `token0` is _not_ ETH, then it assumes `token1` is ETH but never validates this assumption. This could lead to wrong market liquidity and prices calculations if an `_ovlFeed` is supplied that is not actually the OVL/ETH feed.  ## Recommended Mitigation Steps Check that `(token0 == OVL && token1 == WETH) || (token1 == OVL && token0 == WETH)` for `_ovlFeed`.  "}, {"title": "Use _userOiShares everywhere in unwind()", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function unwind() of OverlayV1OVLCollateral.sol a tmp variable _userOiShares is used the store the value of _shares. However _shares is still uses multiple times in the function.  Using _userOiShares everywhere would save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L273-L336  ```JS  function unwind (  uint256 _positionId,  uint256 _shares ) external {         require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), \"OVLV1:!shares\");    // uses _shares         ...         uint _userOiShares = _shares; // move to start of the function         uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;    // uses _shares         uint _userDebt = _shares * pos.debt / _totalPosShares;                                                          // uses _shares         uint _userCost = _shares * pos.cost / _totalPosShares;                                                           // uses _shares         uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;                                          // uses _shares ...         _burn(msg.sender, _positionId, _shares);   // uses _shares ```  ## Tools Used  ## Recommended Mitigation Steps Move \"uint _userOiShares = _shares;\" to the start of function unwind() Replace all other instances of \"_shares\" with \"_userOiShares\"    "}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In the adjustGlobalParams function on line 1603of \"https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L1630\", adjustGlobalParams function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFee function that begins on line 163 of adjustGlobalParams sets the liquidity and transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to \"https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L163\" contract and go to line #163. - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the adjustGlobalParams function.  "}, {"title": "Check for liquidation in value() ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function value() of OverlayV1OVLCollateral.sol doesn't explicitly check for liquidated positions. However because oiShares and debt are set to 0 during liquidation the resulting value will still be 0.  It seems more logical to check for liquidation in the beginning of the function and immediately return 0. This saves gas for the situation where the function value() is called from another smart contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L424-L448 ``` function value (  uint _positionId ) public view returns ( uint256 value_) {         Position.Info storage pos = positions[_positionId];         IOverlayV1Market _market = IOverlayV1Market(pos.market);         (   uint _oi,  uint _oiShares,   uint _priceFrame ) = _market.positionInfo( pos.isLong, pos.pricePoint );         value_ = pos.value(  _oi, _oiShares,  _priceFrame ); } ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following to function value(): ```JS         if (pos.oiShares == 0) return 0; // liquidated ```    "}, {"title": "Avoiding external calls can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. In `OverlayV1OVLCollateral.sol`, `mothership.fee()` can be cached as a storage variable and save ~21000 gas each time.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L305-L305  ```solidity=305 uint _feeAmount = _userNotional.mulUp(mothership.fee()); ```  ## Recommendation  - Add a storage variable in `OverlayV1OVLCollateral.sol`; - Add a function `updateFee()` - Call `updateFee()` after `OverlayV1Mothership.sol#adjustGlobalParams()`  "}, {"title": "No user friendly error message when _leverage==0", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/71", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you try to build a position and have set the _leverage accidentally to 0  (which can be done if you call the smart contract directly). Then the function build() will call enterOI() which will revert when trying to calculate debtAdjusted_ .  However no user friendly error message is given.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Market.sol ```JS function enterOI ( bool _isLong,  uint _collateral,  uint _leverage ) external onlyCollateral returns (...) {  ...         collateralAdjusted_ = _collateral - _impact - fee_;       // will be > 0         oiAdjusted_ = collateralAdjusted_ * _leverage;            // if _leverage==0 then oiAdjusted_  == 0         debtAdjusted_ = oiAdjusted_ - collateralAdjusted_;   // will be negative and thus will revert ```     ## Tools Used  ## Recommended Mitigation Steps Add something like the following to the function build() require(_leverage != 0, \"OVLV1:leverage==0\")  "}, {"title": "Use _brrrrdExpected everywhere in oiCap() ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function oiCap() of OverlayV1Comptroller.sol save the value of brrrrdExpected in a tmp variable _brrrrdExpected. Lateron brrrrdExpected is still used while _brrrrdExpected could also be used. This saves a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L255-L279  ```JS  function oiCap() public virtual view returns (  uint cap_ ) {     ...         uint _brrrrdExpected = brrrrdExpected;     ...         cap_ = _surpassed ? 0 : _burnt || _expected             ? _oiCap(false, depth(), staticCap, 0, 0)             : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected);  // can also use _brrrrdExpected  ``` ## Tools Used  ## Recommended Mitigation Steps Replace ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected); ``` with ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, _brrrrdExpected); ```  "}, {"title": "Simplify function roll()", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function roll() of OverlayV1Comptroller.sol can be simplified. This saves some gas and also makes the function easier to read.  See below at \"Recommended Mitigation Steps\"  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L352-L385 ```JS function roll( Roller[60] storage rollers, Roller memory _roller, uint _lastMoment, uint _cycloid ) internal returns ( uint cycloid_) {         if (_roller.time != _lastMoment) {             _cycloid += 1;             if (_cycloid < CHORD) {                 rollers[_cycloid] = _roller;             } else {                 _cycloid = 0;                 rollers[_cycloid] = _roller;             }         } else {             rollers[_cycloid] = _roller;         }         cycloid_ = _cycloid;     } ```  ## Tools Used  ## Recommended Mitigation Steps Change the function to: ```JS     function roll (Roller[60] storage rollers,Roller memory _roller,uint _lastMoment,uint _cycloid) internal returns (uint cycloid_) {         if (_roller.time != _lastMoment)               _cycloid = (_cycloid + 1) % CHORD;                                       rollers[_cycloid] = _roller;         cycloid_ = _cycloid;     } ```    "}, {"title": "`OverlayToken.sol` Check of allowance can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier to save some gas for failure transactions.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L118-L137  ```solidity=119 function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (     bool success_ ) {      _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];      require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");      unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }      success_ = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L167-L186 ```solidity=167 function transferFromBurn(     address sender,     address recipient,     uint256 amount,     uint256 burnt ) public override onlyBurner returns (     bool success ) {      _transferBurn(sender, recipient, amount, burnt);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount + burnt, \"OVL:allowance<amount+burnt\");      unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }      success = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L241-L260 ```solidity=241 function transferFromMint(     address sender,     address recipient,     uint256 amount,     uint256 minted ) public override onlyMinter returns (     bool ) {      _transferMint(sender, recipient, amount, minted);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount, \"OVL:allowance<amount\");      unchecked { _approve(sender, msg.sender, currentAllowance - amount); }      return true;  } ```  "}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L75-L79  ```solidity function setOVL (address _ovl) external onlyGovernor {          ovl = _ovl;      } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L87-L116  ```solidity     function initializeMarket(address market) external onlyGovernor {          require(!marketExists[market], \"OVLV1:!!initialized\");          marketExists[market] = true;         marketActive[market] = true;          allMarkets.push(market);      }      /// @notice Disables an existing market contract for a mirin market     function disableMarket(address market) external onlyGovernor {          require(marketActive[market], \"OVLV1: !enabled\");          marketActive[market] = false;      }      /// @notice Enables an existing market contract for a mirin market     function enableMarket(address market) external onlyGovernor {          require(marketExists[market], \"OVLV1: !exists\");          require(!marketActive[market], \"OVLV1: !disabled\");          marketActive[market] = true;      } ```  And all functions in `OverlayV1Governance.sol`.  "}, {"title": "_totalSupply not updated in _transferMint() and _transferBurn() ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/59", "labels": ["bug", "question", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply. Whereas the similar functions _mint() and _burn() do update _totalSupply.  This means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.  For the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see). But other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364 ```JS function _mint( address account, uint256 amount) internal virtual {    ...       _totalSupply += amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395 ```JS function _burn(address account, uint256 amount) internal virtual {    ...         _totalSupply -= amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286  ## Tools Used  ## Recommended Mitigation Steps Update _totalSupply  in _transferMint() and _transferBurn()   "}, {"title": "Can't enableCollateral after a disableCollateral ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false; But it does revoke the roles.  Now enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require. So you can never grant the roles again.  Note: enableCollateral also doesn't set collateralActive[_collateral] = true  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153  ```JS  function enableCollateral (address _collateral) external onlyGovernor {         require(collateralExists[_collateral], \"OVLV1:!exists\");         require(!collateralActive[_collateral], \"OVLV1:!disabled\");         OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     }      function disableCollateral (address _collateral) external onlyGovernor {         require(collateralActive[_collateral], \"OVLV1:!enabled\");         OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     } ```  ## Tools Used  ## Recommended Mitigation Steps In function enableCollateral() add the following (after the require): collateralActive[_collateral] = true;  In function disableCollateral add the following (after the require): collateralActive[_collateral] = false;  "}, {"title": "isUnderwater returns opposite boolean for short positions", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The function isUnderwater should return true iff the position value is < 0. In the case of a short position, this is when oi * (2 - priceFrame) - debt < 0 (based on the logic given in the _value function). Rearranging this equation, a short position is underwater iff oi * 2 < oi * priceFrame + debt. However, in the function _isUnderwater in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.  Fortunately, the V1 implementation of OverlayOVLCollateral does not directly use the isUnderwater function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:  // TODO: think through edge case of underwater position ... and fee adjustments ...  which hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.  ## Proof of Concept See code for _isUnderwater here: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70  Notice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that isUnder will be false, which is obviously incorrect).  Also, see the TODO comment here that shows isUndewater is important: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304   ## Tools Used Inspection  ## Recommended Mitigation Steps Flip the left and right side of the inequality for short positions in _isUnderwater.  "}, {"title": "Commented out code (no explanation) ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L261 https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L317  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I suggest removing the commented-out code or adding an explanation.  "}, {"title": "Incorrect comments ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  \"@param\" should be \"@return\" https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/market/OverlayV1Market.sol#L83-L85  Not sure what this comment is for maybe just needs to be deleted. https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L155  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the comments if the suggestions are valid.  "}, {"title": "Incorrect naming issue", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/OverlayV1UniswapV3Market.sol#L171  _tickToPrice function has underscore even it is public function. Underscore is used to indicate internal or private functions.   ## Tools Used Manual  ## Recommended Mitigation Steps Change function to internal or private, or remove underscore if you want to keep it as public function.  "}, {"title": "Anyone Can Arbitrarily Call `FSDVesting.updateVestedTokens()`", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/101", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.  There are two main reasons as to why the beneficiary or an attacker would want to call this function: - To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration. - An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134  ## Tools Used  Manual code review. Discussions with dev.  ## Recommended Mitigation Steps  Ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.  "}, {"title": "Various typos", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  None/Code clarity  ## Proof of Concept  \"is\" to \"in\"   https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L347  \"the\" not needed https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/timelock/Timelock.sol#L16  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the typos.  "}, {"title": "FSD.mintBeta function has potentially blocking condition unrelated with documented logic", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  As funding pool should be filled with Hatch phase deposits, the phase advance should happen only after it is filled, but when this happen the minting in Beta phase would be frozen by 'fundingPool.balance < 2000 ether' condition. As mintBeta is the only logic for Beta phase the contract will be frozen until phase change.  If there is a setup when Hatch phase advances to Beta before funding pool is filled, mintBeta will work only while it has below 2000 ether, i.e. mintBeta behavior will not be controlled explicitly: anyone can end the Beta phase by sending enough ether directly to funding pool and the contract mint will be frozen until next phase advance.   ## Proof of Concept  'fundingPool.balance < 2000 ether' condition for minting in Beta phase can be blocking as funding pool transfers happen only in mintHatch function during Hatch phase, while subsequent phases do not have any funding pool related logic neither in code, nor in documentation. https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSD.sol#L204 https://fairside-network.gitbook.io/fairside-network/white-paper/augmented-bonding-curve  ## Recommended Mitigation Steps  Remove 'fundingPool.balance < 2000 ether' condition from mintBeta  "}, {"title": "Calling require on a tautology", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Finding ```  contracts/token/FSD.sol:174: require(bonded > 0, \"FSD::mintHatch: Insufficient Deposit\"); ``` On L170, we check whether `bonded` is bigger than 5 ETH. After multiplying with `HATCH_CURVE_RATIO`, it is still over 0. Therefore, it is a tautology and not needed.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  Manual analysis  "}, {"title": "Gas: Reorder conditions in `claimGovernanceTribute`", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  The `FSD.claimGovernanceTribute` function first performs the expensive `getPriorConvictionScore` instead of the cheap `isGovernance[msg.sender]` check.  ```solidity function claimGovernanceTribute(uint256 num) external {     require(         governanceThreshold <=             getPriorConvictionScore(                 msg.sender,                 governanceTributes[num].blockNumber             ) &&             // @audit gas: rearrange this to be first for short circuiting             isGovernance[msg.sender],         \"FSD::claimGovernanceTribute: Not a governance member\"     );     _claimGovernanceTribute(num); } ```  Reordering the conditions to first do the cheap governance check would allow this function to short-circuit if the user is not a governor, which will save gas on average. The last assignment `membership[msg.sender] = user;` is not required.   "}, {"title": "ERC20ConvictionScore._writeCheckpoint` does not write to storage on same block", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  In `ERC20ConvictionScore._writeCheckpoint`, when the checkpoint is overwritten (`checkpoint.fromBlock == blockNumber`), the new value is set to the `memory checkpoint` structure and never written to storage.  ```solidity // @audit this is MEMORY, setting new convictionScore doesn't write to storage Checkpoint memory checkpoint = checkpoints[user][nCheckpoints - 1];  if (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {     checkpoint.convictionScore = newCS; } ```  Users that have their conviction score updated several times in the same block will only have their first score persisted.  #### POC - User updates their conviction with `updateConvictionScore(user)` - **In the same block**, the user now redeems an NFT conviction using `acquireConviction(id)`. This calls `_increaseConvictionScore(user, amount)` which calls `_writeCheckpoint(..., prevConvictionScore + amount)`. The updated checkpoint is **not** written to storage, and the user lost their conviction NFT. (The conviction/governance totals might still be updated though, leading to a discrepancy.)  ## Impact Users that have their conviction score updated several times in the same block will only have their first score persisted.  This also applies to the total conviction scores `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` (see `_updateConvictionTotals`) which is a big issue as these are updated a lot of times each block.  It can also be used for inflating a user's conviction by first calling `updateConvictionScore` and then creating conviction tokens with `tokenizeConviction`. The `_resetConviction` will not actually reset the user's conviction.  ## Recommended Mitigation Steps Define the `checkpoint` variable as a `storage` pointer:  ```solidity Checkpoint storage checkpoint = checkpoints[user][nCheckpoints - 1]; ```  "}, {"title": "Avoid unnecessary storage reads in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, especially in for loops, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dependencies/TributeAccrual.sol#L77-L88  ```solidity=77     function totalAvailableTribute(uint256 offset)         external         view         override         returns (uint256 total)     {         for (uint256 i = offset; i < totalTributes; i++)             total = total.add(availableTribute(i));          for (uint256 i = offset; i < totalGovernanceTributes; i++)             total = total.add(availableGovernanceTribute(i));     } ```  `totalTributes` and `totalGovernanceTributes` can be cached.  "}, {"title": "Beneficiary cant get `fairSideConviction` NFT unless they only claim once, and only after it's fully vested", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/62", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, once the beneficiary claimed all their vesting tokens, they should get the `fairSideConviction` NFT.  However, in the current implementation, if the beneficiary has claimed any amounts before it's fully vested, then they will never be able to get the `fairSideConviction` NFT, because at L138, it requires the `tokenbClaim` to be equal to the initial vesting amount.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/FSDVesting.sol#L124-L142  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         \"FSDVesting::claimVestedTokens: Zero claimable tokens\"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == tokenClaim) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  ### Recommendation  Change to:  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         \"FSDVesting::claimVestedTokens: Zero claimable tokens\"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == totalClaimed) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  "}, {"title": "`user.creation` is updated incorrectly when the user tries to extend membership", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L274-L291  ```solidity=274 if (user.creation == 0) {     user.creation = block.timestamp;     user.gracePeriod =         membership[msg.sender].creation +         MEMBERSHIP_DURATION +         60 days; } else {     uint256 elapsedDurationPercentage = ((block.timestamp -         user.creation) * 1 ether) / MEMBERSHIP_DURATION;     if (elapsedDurationPercentage < 1 ether) {         uint256 durationIncrease = (costShareBenefit.mul(1 ether) /             (totalCostShareBenefit - costShareBenefit)).mul(                 MEMBERSHIP_DURATION             ) / 1 ether;         user.creation += durationIncrease;         user.gracePeriod += durationIncrease;     } } ```  ### PoC  1. Alice calls `function purchaseMembership()` and adds 20 ether of `costShareBenefit` on day 1:  ``` alice.creation = day 1 timestamp; alice.gracePeriod = day 791 timestamp; ```  2. Alice calls `function purchaseMembership()` again and adds 20 ether of `costShareBenefit` on day 2:  ``` elapsedDurationPercentage = 1/720 durationIncrease = 730 day  alice.creation = day 731 timestamp; alice.gracePeriod = day 1521 timestamp; ```  Making Alice unable to use any membership features until two years later.  "}, {"title": "Use `else if` in for loops can save gas and simplify code", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  The checks in the for loop can be changed to `else if` to save gas and make sure `msg.sender != sigAssessor`.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L616-L649  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             }             if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             \"FSDNetwork::_isApprovedByAssessors: Not an Assessor\"         );         require(             msg.sender != sigAssessor,             \"FSDNetwork::_isApprovedByAssessors: Cannot be the single Assessor\"         );          return true;     } ```   ### Recommendation  Change to:  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             } else if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             \"FSDNetwork::_isApprovedByAssessors: Not an Assessor\"         );          return true;     } ```  "}, {"title": "Using fixed length array as parameter type can avoid checks to save gas and improve consistency", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L482-L495  ```solidity=482 function setAssessors(address[] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             \"FSDNetwork::setAssessors: Insufficient Privileges\"         );          uint256 assessorsLength = _assessors.length;         require(             assessorsLength == 3,             \"FSDNetwork::setAssessors: Number of assessors must be three\"         );          assessors = _assessors;     } ```  ### Recommendation  Change to:  ```solidity=482 function setAssessors(address[3] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             \"FSDNetwork::setAssessors: Insufficient Privileges\"         );          assessors = _assessors;     } ```  "}, {"title": "Remove redundant check can save gas", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check if `_wallets.length <= 2` is redundant as the length of `_wallets` parameter must be 2.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L520-L533  ```solidity=520 function setMembershipWallets(address[2] calldata _wallets) external {     //todo internal     require(         membership[msg.sender].wallets[0] == address(0) &&             membership[msg.sender].wallets[1] == address(0),         \"FSDNetwork::setMembershipWallets: Cannot have more than three wallets per membership\"     );     require(         _wallets.length <= 2,         \"FSDNetwork::setMembershipWallets: Too many wallets\"     );     membership[msg.sender].wallets = _wallets; } ```  ### Recommendation  Remove the redundant check.  "}, {"title": "Avoid unnecessary external calls can save gas", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L310-L315  ```solidity=310 // 20% as staking rewards fsd.safeTransfer(address(fsd), stakingRewards); fsd.addRegistrationTribute(stakingRewards);  // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards); ```  The 2 transfers to the same address can be done in one external call to save gas  ### Recommendation  Change to:  ```solidity=310 // 20% as staking rewards // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards + stakingRewards); fsd.addRegistrationTribute(stakingRewards); ```  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/ABC.sol#L53 https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L521  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  "}, {"title": "Double update on storage pointer can lead to massive gas consumption", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact When you are reading a value from a storage and using a storage pointer instead of memory, you write directly to the storage instead of the memory.  In the https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234 this line is reading membership[msg.sender] with a storage pointer,  this means any changes to the user variable, is updating directly to the membership[msg.sender],  therefore https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 this line update, makes it useless since the data already written to the membership[msg.sender]  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234-L294   ## Tools Used  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 membership[msg.sender] = user;  "}, {"title": "FSDVesting: Redundant _start input parameter in initiateVesting()", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Tracing the function calls, the `_start` parameter in `initiateVesting()` will always be `block.timestamp`. Hence, this input parameter can be removed from the function.  ## Recommended Mitigation Steps  ```jsx // TODO: Modify relevant function calls function initiateVesting(   address _beneficiary,   uint256 _amount ) external onlyFactory {  require(     start == 0,     \"FSDVesting::initiateVesting: Vesting is already initialized\"   );  beneficiary = _beneficiary;  start = block.timestamp;  amount = _amount; } ```  "}, {"title": "FSDVesting: Optimise updateVestedTokens()", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  1. The `_user` input in `updateVestedTokens()` is redundant because each user will have at most 1 vesting contract, and this function should be restricted to the FSD token contract only (kindly refer to related submitted issue), which stores and retrieves the mapping of users to vesting contracts. 2. The zero amount check is redundant because it is already checked in `FSD._createVesting()`.  ## Recommended Mitigation Steps  ```jsx /** * @dev Allows a vesting beneficiary to extend their vested token amount. */ function updateVestedTokens(uint256 _amount)   external   override  onlyFsd {   amount = amount.add(_amount); } ```  "}, {"title": "FSDVesting: Define new constant LINEAR_VEST_AFTER_CLIFF", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  `DURATION.sub(CLIFF)` is calculated in `calculateVestingClaim()`. Since both are constants, it would be better to define a new constant `LINEAR_VEST_AFTER_CLIFF` that refers to the vest duration after the cliff.  ## Recommended Mitigation Steps  `uint256 private constant LINEAR_VEST_AFTER_CLIFF = 18 * ONE_MONTH;`  "}, {"title": "FSDVesting: Constants can be made internal / private", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Since the defined constants are unneeded elsewhere, it can be defined to be `internal` or `private` to save gas.  ## Recommended Mitigation Steps  ```jsx // One month in seconds uint256 internal constant ONE_MONTH = 30 days; // Cliff period for a vest uint256 internal constant CLIFF = 12 * ONE_MONTH; // Duration of a vest uint256 internal constant DURATION = 30 * ONE_MONTH; ```  "}, {"title": "FSDVesting: Claiming tributes should call FSD token's corresponding functions", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The claiming of staking and governance tributes for the a beneficiary's vested tokens should be no different than other users / EOAs. However, the `claimTribute()` and `claimGovernanceTribute()` are missing the actual claiming calls to the corresponding functions of the FSD token contract. As a result, the accrued rewards are taken from the beneficiary's vested token while not claiming (replenishing) from the FSD token contract.  ## Recommended Mitigation Steps  In addition to what has been mentioned above, the internal accounting for claimedTribute states can be removed because they are already performed in the FSD token contract.  ```jsx // TODO: Remove _claimedTribute and _claimedGovernanceTribute mappings  /** * @dev Allows claiming of staking tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimTribute(uint256 num) external onlyBeneficiary {     uint256 tribute = fsd.availableTribute(num);     require(tribute != 0, \"FSDVesting::claimTribute: No tribute to claim\");   fsd.claimTribute(num);     fsd.safeTransfer(msg.sender, tribute);     emit TributeClaimed(msg.sender, tribute); }  /** * @dev Allows claiming of governance tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimGovernanceTribute(uint256 num) external onlyBeneficiary {   uint256 tribute = fsd.availableGovernanceTribute(num);   require(     tribute != 0,     \"FSDVesting::claimGovernanceTribute: No governance tribute to claim\"   );   fsd.claimGovernanceTribute(num);   fsd.safeTransfer(msg.sender, tribute);   emit GovernanceTributeClaimed(msg.sender, tribute); } ```  "}, {"title": "Offchain voting can't be renabled in DAO", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The comment for the `disableOffchainVoting()` function specifies that the feature can be reenabled in the future through a proposal. But, there seems to be no function to do that in the DAO contract.  ## Proof of Concept Function with the comment: https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dao/FairSideDAO.sol#L619  No way to reassign the value: `grep offchain`  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Either remove the comment if the feature is not intended or add a function to reassign the `offchain` and `guardian` state variable  "}, {"title": "Assigning keccak operations to constant variables results in extra gas costs", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs  ## Proof of Concept  In a number of places a `keccak(\"string\")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dao/FairSideDAO.sol#L43-L49  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: https://github.com/ethereum/solidity/issues/9232  ## Recommended Mitigation Steps  Change all `constant` hashes to be `immutable`  "}, {"title": "Mixing different types of LP shares can lead to losses for Synth holders", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/257", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "VaderPoolV2", "BasePoolV2"], "target": "2021-11-vader-findings", "body": "# Handle  hyh   # Vulnerability details   ## Impact  Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.  ## Proof of Concept  3 types of mint/burn: NFT, Fungible and Synths. Synths are most vilnerable as they do not have share: LP own the pool, so Synth's funds are lost in scenarios similar to: 1. LP deposit both sides to a pool 2. Synth deposit and mint a Synth 3. LP withdraws all as she owns all the pool liquidity, even when provided only part of it 4. Synth can't withdraw as no assets left  burn NFT LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L270  burn fungible LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L374  ## Recommended Mitigation Steps  Take into account liquidity that was provided by Synth minting.  "}, {"title": "`VaderRouter.calculateOutGivenIn` calculates wrong swap", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/162", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "VaderRouter"], "target": "2021-11-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter.calculateOutGivenIn` is supposed to first swap **foreign** assets to native assets **in pool0**, and then the received native assets to different foreign assets again **in pool1**.  The first argument of `VaderMath.calculateSwap(amountIn, reserveIn, reserveOut)` must refer to the same token as the second argument `reserveIn`. The code however mixes these positions up and first performs a swap in `pool1` instead of `pool0`:  ```solidity function calculateOutGivenIn(uint256 amountIn, address[] calldata path)     external     view     returns (uint256 amountOut) {   if(...) {   } else {     return         VaderMath.calculateSwap(             VaderMath.calculateSwap(                 // @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0                 amountIn,                 nativeReserve1,                 foreignReserve1             ),             foreignReserve0,             nativeReserve0         );   }   /** @audit instead should first be trading in pool0!     VaderMath.calculateSwap(         VaderMath.calculateSwap(             amountIn,             foreignReserve0,             nativeReserve0         ),         nativeReserve1,         foreignReserve1     );   */ ```  ## Impact All 3-path swaps computations through `VaderRouter.calculateOutGivenIn` will return the wrong result. Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.  ## Recommended Mitigation Steps Return the following code instead which first trades in pool0 and then in pool1:  ```solidity return   VaderMath.calculateSwap(       VaderMath.calculateSwap(           amountIn,           foreignReserve0,           nativeReserve0       ),       nativeReserve1,       foreignReserve1   ); ```   "}, {"title": "`VaderRouter._swap` performs wrong swap", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/161", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "VaderRouter"], "target": "2021-11-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter._swap` is supposed to first swap **foreign** assets to native assets, and then the received native assets to different foreign assets again.  The `pool.swap(nativeAmountIn, foreignAmountIn)` accepts the foreign amount as the **second** argument. The code however mixes these positional arguments up and tries to perform a `pool0` foreign -> native swap by using the **foreign** amount as the **native amount**:  ```solidity function _swap(     uint256 amountIn,     address[] calldata path,     address to ) private returns (uint256 amountOut) {     if (path.length == 3) {       // ...       // @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)       return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);     } }  // @audit should be this instead return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to); ```  ## Impact All 3-path swaps through the `VaderRouter` fail in the pool check when `require(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)` is checked, as foreign amount is sent but _native_ amount is specified.  ## Recommended Mitigation Steps Use `return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);` instead.  "}, {"title": "mintWithMetadata onlyFactory ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function \"mintWithMetadata\" does not need onlyFactory modifier as it will be checked in function \"mint\" later.   "}, {"title": "OperatorResolver.areAddressesImported doesn't check lengths of argument arrays", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/210", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Array bounds check violation will happen if the function be called with arrays of different lengths.  ## Proof of Concept  Loop is performed by names array, while both arrays are accessed: ``` for (uint256 i = 0; i < names.length; i++) {   if (operators[names[i]] != destinations[i]) { ``` https://github.com/code-423n4/2021-11-nested/blob/main/contracts/OperatorResolver.sol#L27  ## Recommended Mitigation Steps  Add a check: ``` require(names.length == destinations.length, \"OperatorResolver::areAddressesImported: Input lengths must match\"); ```  "}, {"title": "_burnNST", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think it is not necessary to have function _burnNST as a separate private function. It is called only once and has just one LOC so it just incurs in extra gas cost which can be avoided by moving this line to function trigger and getting rid of _burnNST.   "}, {"title": "index + 1 can be simplified", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This can be simplified to reduce gas costs by eliminating math operation: ```solidity   // before   require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");   // after   require(_accountIndex < shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");  ```  "}, {"title": "INestedToken interface", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/206", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact INestedToken is declared as an abstract contract, yet it contains no function bodies and is located under the interfaces directory, so I think it should be declared as an interface.  ## Recommended Mitigation Steps Consider making INestedToken an interface.  "}, {"title": "NestedAsset.setFactory should be named addFactory", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/204", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ```setFactory``` should be named ```addFactory``` as it doesn't set the only factory, but adds to the list of factories  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L133  "}, {"title": "Can't revoke factory in NestedRecrods", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/203", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact NestedRecords contains no removeFactory function so there is no way to revoke a factory in case you no longer want to support it. This function is present in NestedAsset contract so I thought you might want to also have it here.  ## Recommended Mitigation Steps Consider if you are missing removeFactory or is this an intended functionality.   "}, {"title": "NestedFactory.addTokens and withdraw functions require NFT reserve check", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/199", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  NFT token operations will fail if wrong reserve is used.  ## Proof of Concept  ```NestedFactory``` ```reserve``` is used in ```addtokens``` and ```withdraw``` function for a given NFT, but the NFT to reserve contract correspondence isn't checked.  addtokens: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L119  withdraw: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L241  ## Recommended Mitigation Steps  Add the ```require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"...\")``` check in the beginning of the functions.  "}, {"title": "Check condition before calling NestedFactory._handleUnderSpending", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/198", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Whenever condition of the ```_handleUnderSpending``` function fails function call gas costs are wasted. The cost of checking the condition is paid anyway, while when it doesn't hold the function call costs are avoidable.  ## Proof of Concept  ```_handleUnderSpending``` checks for ```_amountToSpent - _amountSpent > 0```.  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L481  ## Recommended Mitigation Steps  When the check condition is false ```_handleUnderSpending``` shouldn't be called and this way the check with corresponding variables to be placed in caller functions:  _submitInOrders https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L306  _safeSubmitOrder https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L415  "}, {"title": "Small refactor for functions to save some gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact In `FeeSplitter.sol` by doing a small refactory gas can be saved in case of a revert in the functions: `getAmountDue` and `_releaseToken` . We can swap the order of two lines so we return earlier in case of a bad input, this way we save some gas because the evm would execute less opcodes before reverting.  ## Mitigation steps getAmountDue: Swap line 83 with 84 to avoid computing unnecessary logic. Remove the \"else\"  and combine it with line 83. Something like this:  ```   function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];     if (_tokenRecords.totalShares == 0) return 0;         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         return amountDue;     } ``` _releaseToken: move line 252 after the require in line 254. Like this:  ```   function _releaseToken(address _account, IERC20 _token) private returns (uint256) {         uint256 amountToRelease = getAmountDue(_account, _token);         require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];          _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;         _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;          return amountToRelease;     } ```   "}, {"title": "Unnecessary Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  1. Navigate to the following contracts.  \"https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L135\" \"https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L111\" \"https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L32\"  ## Tools Used  Code review  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.    "}, {"title": "`_handleUnderSpending` reverts if condition is false", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/183", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NestedFactory._handleUnderSpending` function implements a condition as `_amountToSpent - _amountSpent > 0` instead of `_amountToSpent > _amountSpent`. The former reverts if `_amountSpent > _amountToSpent` while the latter doesn't.  It's unclear which behavior is preferred.  ## Recommended Mitigation Steps Think about if `_amountSpent > _amountToSpent` should revert or not. If not, the `if` condition can be rewritten as `_amountSpent > _amountToSpent` which would also save gas.  "}, {"title": "Can add duplicate operators", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/180", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NestedFactory.addOperator` function pushes the `operator` even if it already exists in `operators`.  ## Impact When this duplicated operator is removed through a `removeOperator` call, only the first instance is removed. The operator can now still be called which can lead to unexpected behavior.  ## Recommended Mitigation Steps Check if the operator already exists before adding it.  "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/178", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for non-zero values: - `NestedFactory.constructor`: address parameters could be zero or not a contract - `NestedReserve.constructor`: address parameters could be zero or not a contract - `NestedBuybacker.constructor`: address parameters could be zero or not a contract  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.   "}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L152-L162  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");      _sendFees(_token, _amount, totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token)); } ```  ### Recommendation  Change to:  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");      uint256 _totalWeights = totalWeights;      _sendFees(_token, _amount, _totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, _totalWeights), address(_token)); } ```  "}, {"title": "Consider making `_calculateFees` inline to save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/167", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L553-L559  ```solidity=553 /// @dev Calculate the fees for a specific user and amount (1%) /// @param _user The user address /// @param _amount The amount /// @return The fees amount function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {     return _amount / 100; } ```  The function `_calculateFees()` is a rather simple function, replacing it with inline expression `_amount / 100` can save some gas.  "}, {"title": "Avoid unnecessary storage writes can save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  `releaseToken()` has `nonReentrant` modifier, making `releaseTokens()` to set storage `_status` multiple times in the for loop.  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L116-L129  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         releaseToken(_tokens[i]);     } } ```  ### Recommendation  Change to:  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     _releaseTokenAndTransfer(_token); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         _releaseTokenAndTransfer(_tokens[i]);     } }  function _releaseTokenAndTransfer(IERC20 _token) private {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); } ```  "}, {"title": "Misleading error message", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/161", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedRecords.sol#L56-L79  ```solidity=56{67} /// @notice Add a record for NFT data into our mappings /// @param _nftId The id of the NFT /// @param _token The address of the token /// @param _amount The amount of tokens bought /// @param _reserve The address of the reserve function createRecord(     uint256 _nftId,     address _token,     uint256 _amount,     address _reserve ) public onlyFactory {     require(records[_nftId].tokens.length < maxHoldingsCount, \"NestedRecords: TOO_MANY_ORDERS\");     require(         _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),         \"NestedRecords: INVALID_RESERVE\"     );      Holding memory holding = records[_nftId].holdings[_token];     require(!holding.isActive, \"NestedRecords: HOLDING_EXISTS\");      records[_nftId].holdings[_token] = Holding({ token: _token, amount: _amount, isActive: true });     records[_nftId].tokens.push(_token);     records[_nftId].reserve = _reserve; } ```  The error message \"NestedRecords: TOO_MANY_ORDERS\" should be changed to \"NestedRecords: TOO_MANY_TOKENS\".  "}, {"title": "NestedFactory: Ensure zero msg.value if transferring from user and inputToken is not ETH ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  A user that mistakenly calls either `create()` or `addToken()` with WETH (or another ERC20) as the input token, but includes native ETH with the function call will have his native ETH permanently locked in the contract.  ## Recommended Mitigation Steps  It is best to ensure that `msg.value = 0` in `_transferInputTokens()` for the scenario mentioned above.  ```jsx } else if (address(_inputToken) == ETH) {  ... } else {  require(msg.value == 0, \"NestedFactory::_transferInputTokens: ETH sent for non-ETH transfer\");   _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); } ```  "}, {"title": "NestedFactory: _fromReserve param in _submitOutOrders() is redundant", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  `_submitOutOrders()` is invoked by 2 functions `sellTokensToNft()` and `sellTokensToWallet()`, both of which specify the `_fromReserve` parameter to be `true`. This parameter is therefore unneeded.  ## Recommended Mitigation Steps  ```jsx function _submitOutOrders(   uint256 _nftId,   IERC20 _outputToken,   uint256[] memory _inputTokenAmounts,   Order[] calldata _orders,   bool _reserved ) private returns (uint256 feesAmount, uint256 amountBought) {  ...    IERC20 _inputToken = _transferInputTokens(     _nftId,     IERC20(_orders[i].token),     _inputTokenAmounts[i],     true  ); } ```  "}, {"title": "NestedRecords: createRecord() can be made internal", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  `createRecord()` is only invoked by `store()`. Its visibility can therefore be made internal / private.  ## Recommended Mitigation Steps  ```jsx function createRecord(   uint256 _nftId,   address _token,   uint256 _amount,  address _reserve ) internal onlyFactory {...} ```  "}, {"title": "NestedReserve: Redundant valid token address checks", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The `transferFromFactory()` function is missing the `valid(address(_token))` modifier that is present in the `transfer()` and `withdraw()` functions.  It is in our opinion that these sanity checks on the token address are redundant, because the transaction will revert anyway in the SafeERC20 library.  ## Recommended Mitigation Steps  Either add in the modifier check for the `transferFromFactory()` function. Alternatively, remove them from all the functions as a gas optimization.  "}, {"title": "MixinOperatorResolver: variables are declared multiple times in rebuildCache()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The `name` and `destination` local variables in the `rebuildCache` function are declared multiple times within the loop. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination; // The resolver must call this function whenever it updates its state for (uint256 i = 0; i < requiredAddresses.length; i++) {  name = requiredAddresses[i];  // Note: can only be invoked once the resolver has all the targets needed added  destination = resolver.getAddress(name);   ... } ```  "}, {"title": "NestedRecords: Unnecessary variable in the Holding struct", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  It is unnecessary to store the `token` variable in the `Holding` struct because the token is used as the key to access the `Holding` struct.  ## Recommended Mitigation Steps  Remove the `token` variable in the `Holding` struct.  ```jsx /// @dev Info about assets stored in reserves struct Holding {   uint256 amount;   bool isActive; } ```  "}, {"title": "OperatorResolver: importOperators() function redeclares local variable multiple times", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The `importOperators()` declares the `name` and `destination` variables multiple times. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination;  for (uint256 i = 0; i < names.length; i++) {  name = names[i];  destination = destinations[i];   operators[name] = destination;   emit OperatorImported(name, destination); } ```  "}, {"title": "No used library added", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/114", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L15  There is only NST.safeTransfer used, and NST is INestedToken interface. SafeERC20 is not used for IERC20 interface.  ## Tools Used  ## Recommended Mitigation Steps Remove Line 79  "}, {"title": "Use `calldata` keyword instead of `memory` keyword in function arguments", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact `calldata` use less gas than `memory` in function arguments  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L124  ## Tools Used Manual  ## Recommended Mitigation Steps Use `calldata` keyword in function argument instead of `memory`  "}, {"title": "Unused Named Return", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  Unused named return: https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L69  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return  "}, {"title": "Missing input validation on array lengths ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The functions below fail to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  names, destinations https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/OperatorResolver.sol#L27-L39  _inputTokenAmounts, orders https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L321-L337  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of both arrays match.  "}, {"title": "double reading of state variable inside a loop", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/98", "labels": ["bug", "question", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pants   # Vulnerability details  MixinOperatorResolver.rebuildCache (addressCache[name]), isResolverCached (addressCache[name])  You can cache the value after the first read into a local variable to save the other SLOAD and also the \"out of bounds\" check.  "}, {"title": "reordering struct fields", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pants   # Vulnerability details  NestedRecords line 22 - you can save storage by reordering Holding struct fields in the following way:  original:     struct Holding {         address token;         uint256 amount;         bool isActive;     }  change to:      struct Holding {         uint256 amount;         address token;         bool isActive;     }   "}, {"title": "Missing events on changes", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  palina   # Vulnerability details  ## Impact Function performing important changes to contract state should emit events to facilitate monitoring of the protocol operation (e.g., NestedRecords::setReserve(), deleteAsset(), removeNFT()).  ## Proof of Concept setReserve(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L201 deleteAsset(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L207 removeNFT(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L221  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider emitting events on the discussed changes. E.g.,  event ReserveUpdated(address newReserve); ... function setReserve(...) {     emit ReserveUpdated(_nextReserve); }  "}, {"title": "`NestedFactory.unlockTokens` fails to use safe transfer", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  elprofesor   # Vulnerability details  ## Impact The use of `_token.transfer()` in `NestedFactory.unlockTokens` may have unintended consequences. ERC20 tokens can implement contra to the EIP20 spec (USDT for instance returns VOID). This may result in tokens that return anything from false to void and these return values would not throw on failure. As a result transfer's in `unlockTokens` may not appropriately throw on failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271-L273  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s SafeERC20 versions with the `safeTransfer` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "Unchecked return value in triggerForToken()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  palina   # Vulnerability details  ## Impact The Nestedbuybacker::triggerForToken() function does not check the return value of the `ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);` call, which returns a boolean. Even if the swap in the fillQuote() is not successful and no NST was bought, the function proceeds with the trigger() function execution. trigger() also does not check if the `balance` variable (indicating the amount of NST bought) is positive, although there is (at best) no point in executing the rest of the function if there's no NST in the contract.  ## Proof of Concept Unchecked result of the fillQuote() call: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L101 Missing validation in trigger(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L108  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a return value check in the triggerForToken() function: `bool success = ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData); require(success);` and/or a `balance` value validation in trigger(): `uint256 balance = NST.balanceOf(address(this)); require(balance > 0);`  "}, {"title": "Public functions can be declared external", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  palina   # Vulnerability details  ## Impact Functions that are only called from outside the contract can be declared external instead of public since they are more gas-efficient.  ## Proof of Concept NestedBuybacker::setBurnPart(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L81, MixinOperatorResolver::rebuildCache(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/MixinOperatorResolver.sol#L29  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the 'public' visibility modifier into 'external'.  "}, {"title": "Refactor `FeeSplitter::getAmountDue` to save one variable slot", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `getAmountDue` in `FeeSplitter.sol` defines the variable  `totalReceived` in [line 83](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L83) eventhough it is already known if the variable is even necessary.  The variable is uneccessary if `_tokenRecords.totalShares == 0`. Not declaring it, if not necessary, saves gas.  ## Recommended Mitigation Steps Rewrite the function to something like: ``` TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; if (_tokenRecords.totalShares == 0) return 0; uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); // Rest same as before ```  "}, {"title": "Remove unnecessary `balanceOf` call in `NestedBuybacker::triggerForToken`", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Function `triggerForToken` in `NestedBuybacker.sol` makes a `balanceOf` call on the `_sellToken`, see [line 100](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L100).  However, the result of the call is never used.  It would save gas to remove the unnecessary call and variable declaration.  "}, {"title": "`removeFactory` has `==true` comparison in require statement", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  loop   # Vulnerability details  The `removeFactory` has an unnecessary `==true` comparison in its require statement. Since require already checks if the condition is `true`, there is no need for it to be compared.  ## Impact Removing `== true` saves a tiny amount of gas if `removeFactory` is called.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L142  "}, {"title": "_sendFees() Repeat SLOAD shareholders In Loop", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact _sendFees() repeat Read Storage variable shareholders. Every Storage read is expensive.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L227-L232  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read the values from storage once, cache them in local variables and then read them again using the local variables. For example:  Shareholder[] shareholders_temp = shareholders;         for (uint256 i = 0; i < shareholders_temp.length; i++) {             _addShares(                 shareholders_temp[i].account,                 _computeShareCount(_amount, shareholders_temp[i].weight, _totalWeights),                 address(_token)             );  "}, {"title": "ExchangeHelpers: in setMaxAllowance, safeApprove shouldn't be used", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [setMaxAllowance](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/libraries/ExchangeHelpers.sol#L34), `safeApprove` is used to increase allowance. As stated in the following Pull Request, `safeApprove` has been deprecated in favor of `safeIncreaseAllowance` and `safeDecreaseAllowance`.  https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2268/files  This is because `safeApprove` shouldn't check for allowance, as explained in the issue below:  https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219  `approve` is actually vulnerable to a sandwich attack as explained in the following document and this check for allowance doesn't actually avoid it.  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit  ## Proof of Concept `safeIncreaseAllowance` should be used to increase allowance and `safeDecreaseAllowance` to decrease allowance to 0. We can also gain in code clarity by refactoring the `if else` statement and calling `_token.safeIncreaseAllowance(_spender, type(uint256).max);` only once.  ## Recommended Mitigation Steps The following changes are recommended.  ``` function setMaxAllowance(IERC20 _token, address _spender) internal {     uint256 _currentAllowance = _token.allowance(address(this), _spender);      if (_currentAllowance != type(uint256).max) {         // Decrease to 0 first for tokens mitigating the race condition         _token.safeDecreaseAllowance(_spender, _currentAllowance);     }      _token.safeIncreaseAllowance(_spender, type(uint256).max); } ```  "}, {"title": "NestedFactory: in deleteAsset and freeToken, tokens should only be declared once ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [deleteAsset](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedRecords.sol#L213), `tokens` is declared once in the function and then a second time in the function `freeToken`.  ## Proof of Concept The `freeToken` function being used only in `deleteAsset`, the code from this function can be moved to `deleteAsset` and the function removed. This way, we don't have to pass `tokens` to the `freeToken` function and we avoid declaring it here a second time.  ## Recommended Mitigation Steps The following change is recommended.  ``` function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {     address[] storage tokens = records[_nftId].tokens;     address token = tokens[_tokenIndex];     Holding memory holding = records[_nftId].holdings[token];      require(holding.isActive, \"NestedRecords: HOLDING_INACTIVE\");      delete records[_nftId].holdings[token];     tokens[_tokenIndex] = tokens[tokens.length - 1];     tokens.pop(); } ```  "}, {"title": "OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure We don't read any storage variables, only use the arguments therefore, it can be restricted to pure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/libraries/OperatorHelpers.sol#L45  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps set function state mutability to pure  "}, {"title": "Remove empty file OwnableOperator.so", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Empty/useless file OwnableOperator.sol is against best practices / code housekeeping.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/operators/OwnableOperator.sol  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Delete file  "}, {"title": "Subtraction from totalWeights can be done unchecked to save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details   ## Impact FeeSplitter.so: totalWeights is the sum of shareholder weights and royaltiesWeight, therefore a subtraction of a shareholder weight or royaltiesWeight can be done unchecked because we can't underflow and save gas.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143 can be rewritten as:      function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {         _sendFees(_token, _amount, unchecked {totalWeights - royaltiesWeight});     }  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169 can be written as unchecked { _totalWeights -= shareholders[_accountIndex].weight; }  "}, {"title": "Different coding style for same pattern: x += y and sometimes x = x + y", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  The pattern of adding/subtracting a variable to/from another value is sometimes written as x += y; and sometimes as x = x + y; (x -= y; and sometimes x = x - y;) The shorter version x += y;/x -= y; increases readability.  ## Proof of Concept  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L241  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L256  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L229  and possible others  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use the x += y; / x -= y; pattern   "}, {"title": "Comment for PaymentReceived event should state \"received\" instead of \"released\"", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Comment in FeeSplitter  \"/// @dev Emitted when a payment is released\" for the PaymentReceived event should say \"received\" instead of \"released\".  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L25  ## Tools Used Manal Analysis  ## Recommended Mitigation Steps Change line to: /// @dev Emitted when a payment is received  "}, {"title": "FeeSplitter: totalWeights can be set to 0 by onlyOwner", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The storage variable totalWeights can be set 0 by onlyOwner and therefore we would have a division by zero in the function \"_computeShareCount\" https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L268  ## Proof of Concept -Assumption we have one shareholder with weight S1 > 0 and royaltiesWeight > 0. -With the function updateShareholder the onlyOwner sets the S1 of our shareholder to 0.  - updateShareholder: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  - require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\") condition is met because _totalWeights is the sum of all shareholder weights + royaltiesWeight, and royaltiesWeight is > 0 - With the function setRoyaltiesWeight the onlyOwner sets the royaltiesWeight to 0.  - setRoyaltiesWeight: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 - => setRoyaltiesWeight is 0 and totalWeights is 0   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps At the end of the function setRoyaltiesWeight check for 0 weight with a require: require(totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\"); https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94  "}, {"title": "Missing events for critical privileged functions", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L103 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L74 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L79 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271  and possible other  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Emit events for privileged actions  "}, {"title": "Typo", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact Found the same small typo at NestedBuybacker.sol#constructor::line 54 and at NestedBuybacker.sol#constructor::line 87.  The error messages says: \"NestedBuybacker::constructor: Burn part to high\" It should be \"too high\".  "}, {"title": "Store hash of `type(ZeroExStorage).creationCode` rather than recalculating it on each call", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Deployment + runtime gas cost increase  ## Proof of Concept  On each time we calculate the address of `ZeroExStorage` we hash the entirety of the creation code for `ZeroExStorage`. This means that not only do we have to perform a large hash operation over the entire creation bytecode of this contract, we need to store all of this bytecode in the `ZeroExOperator`'s deployed bytecode.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L61  This hash could be calculated once at deployment and then have this used cheaply each time, reducing both deployment and runtime costs.  ## Recommended Mitigation Steps  Store `keccak256(type(ZeroExStorage).creationCode)` in an `immutable` (not `constant` as this still results in hashing being applied each time) variable.  "}, {"title": "1:1 linkage between factory and reserve prevents desired upgradability path.", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  NFTs can't be managed from future versions of `NestedFactory` without manual migration or removing support for the previous `NestedFactory`.  ## Proof of Concept  From discussion with NestedFinance team members, it's desired that multiple `NestedFactories` can interact with the NFT portfolios and be interoperable into the future.  NestedFinance has two singleton contracts which store the state of NFTs `NestedAsset` and `NestedRecords`  `NestedAsset` allows multiple factories to interact with a given NFT ([asset](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedAsset.sol#L18-L19)) `NestedRecords` lists a single reserve which holds an NFT's assets ([records](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L32))  This is fine however `NestedFactory` and `NestedReserve` are linked together 1:1 ([factory](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L31), [reserve](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L14))  This means that each NFT can only be managed by a single factory as calls from other factories to the relevant reserve will revert due to insufficient permissions. Should I want to update to use the newest factory I would have to manually migrate my portfolio across.  ## Recommended Mitigation Steps  Allow `NestedReserve` to have multiple factories connect to it. Make sure to have the `NestedReserve` secure from reentrancy attacks utilising multiple factories in parallel.   "}, {"title": "Mix of external and public function visibility with the same access modifier", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Functions in the same contract with the same access modifier (e.g. onlyOwner or onlyFactory) have have a mix of public and external visibility.  Set their visibility to external to save gas.  Affected contracts (see ): - NestedRecords - NestedFactory - FeeSplitter - NestedAsset   ## Tools Used Visial Studio Code + Solidity Visual Developer (Plugin)  ## Recommended Mitigation Steps  Set the visibility to external to save gas.   Extract from Solidity Visual Developer (Plugin) of the Contracts and visibility:  |  Contract  |         Type        |       Bases      |                  |                 | |:----------:|:-------------------:|:----------------:|:----------------:|:---------------:| |     \u2514      |  **Function Name**  |  **Visibility**  |  **Mutability**  |  **Modifiers**  | |||||| | **NestedRecords** | Implementation | Ownable ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  |NO\u2757\ufe0f | | \u2514 | createRecord | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | updateHoldingAmount | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | getAssetTokens | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | freeHolding | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | store | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | getAssetHolding | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | setFactory | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | updateLockTimestamp | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | setMaxHoldingsCount | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | getAssetReserve | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | getAssetTokensLength | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | getLockTimestamp | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | setReserve | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | removeNFT | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | deleteAsset | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | freeToken | Private \ud83d\udd10 | \ud83d\uded1  | | |||||| | **NestedFactory** | Implementation | INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  | MixinOperatorResolver | | \u2514 | <Receive Ether> | External \u2757\ufe0f |  \ud83d\udcb5 |NO\u2757\ufe0f | | \u2514 | resolverAddressesRequired | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | addOperator | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | removeOperator | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | setReserve | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | setFeeSplitter | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | create | External \u2757\ufe0f |  \ud83d\udcb5 | nonReentrant | | \u2514 | addTokens | External \u2757\ufe0f |  \ud83d\udcb5 | nonReentrant onlyTokenOwner | | \u2514 | swapTokenForTokens | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | sellTokensToNft | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | sellTokensToWallet | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | destroy | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | withdraw | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | increaseLockTimestamp | External \u2757\ufe0f | \ud83d\uded1  | onlyTokenOwner | | \u2514 | unlockTokens | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | _submitInOrders | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _submitOutOrders | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _submitOrder | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _safeSubmitOrder | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _transferToReserveAndStore | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _transferInputTokens | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _handleUnderSpending | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _transferFeeWithRoyalty | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _decreaseHoldingAmount | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _safeTransferAndUnwrap | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _safeTransferWithFees | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _calculateFees | Private \ud83d\udd10 |   | | |||||| | **FeeSplitter** | Implementation | Ownable, ReentrancyGuard ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  |NO\u2757\ufe0f | | \u2514 | <Receive Ether> | External \u2757\ufe0f |  \ud83d\udcb5 |NO\u2757\ufe0f | | \u2514 | getAmountDue | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | setRoyaltiesWeight | Public \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | setShareholders | Public \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | releaseToken | Public \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | releaseTokens | External \u2757\ufe0f | \ud83d\uded1  |NO\u2757\ufe0f | | \u2514 | releaseETH | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | sendFees | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | sendFeesWithRoyalties | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | updateShareholder | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | totalShares | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | totalReleased | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | shares | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | released | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | findShareholder | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | _sendFees | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _addShares | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _releaseToken | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _addShareholder | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _computeShareCount | Private \ud83d\udd10 |   | | |||||| | **NestedAsset** | Implementation | ERC721Enumerable, Ownable ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  | ERC721 | | \u2514 | tokenURI | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | originalOwner | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | mint | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | mintWithMetadata | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | backfillTokenURI | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory onlyTokenOwner | | \u2514 | burn | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory onlyTokenOwner | | \u2514 | setFactory | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | removeFactory | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | _setTokenURI | Internal \ud83d\udd12 | \ud83d\uded1  | |   Legend  |  Symbol  |  Meaning  | |:--------:|-----------| |    \ud83d\uded1    | Function can modify state | |    \ud83d\udcb5    | Function is payable |   "}, {"title": "More gas efficient calculation of weights", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Calculation of the weights in the function \"setRoyaltiesWeight\" of FeeSplitter.sol (row 95) can be done more gas efficient.      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights -= royaltiesWeight;         royaltiesWeight = _weight;         totalWeights += _weight;     }  can be rewritten as      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights = totalWeights - royaltiesWeight + _weight;         royaltiesWeight = _weight;     }  => write only once to the storage of totalWeights.  ## Proof of Concept  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps see above  "}, {"title": "`NestedReserve.transferFromFactory` function increases deployment gas costs unnecessarily", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  `NestedReserve.transferFromFactory` is unused and so increases deployment costs for no gain  ## Proof of Concept  `NestedReserve` has a `transferFromFactory` which can be seen not to be used in the codebase (and in the case the `NestedFactory` needs to send tokens to the reserve it can do so directly.)  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L55-L60  ## Recommended Mitigation Steps  Remove this function.  "}, {"title": "Reduce require messages length to save contract size", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact Running a quick contract size check in the NestedFactory contract, I noticed it sat at 27590 bytes, exceeding the allowed 24576 bytes to deploy on mainnet. I removed the require messages alone in that contract and found the contract size dropped to 23172 bytes. Considering you are using large require messages in all the codebase, I would suggest considering a change of approach as to how you expose the error messages. I'll add my suggestions below.  ## Recommended Mitigation Steps Two ways: 1) Shorten the length of the string messages to just the error instead of including the contract and the function. UniswapV3 repo may be a good example of how to do this. You can always explain errors further in the natspec, or in your documentation (you can make a common errors section). 2) Change require statements for if (...) revert CustomError(). Per solidity docs:  \"Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs.\"  Link: https://docs.soliditylang.org/en/v0.8.10/control-structures.html?highlight=error#revert  ## Tools Used dapptools make size  "}, {"title": "`updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Explanation  `updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently. The updated version consumes less gas and also has the second `require` statement earlier, which reduces  the gas cost in case the statement of second `require` is not fullfilled.   `FeeSplitter.sol` : L166-174: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");         uint256 _totalWeights = totalWeights;         _totalWeights -= shareholders[_accountIndex].weight;         shareholders[_accountIndex].weight = _weight;         _totalWeights += _weight;         require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");         totalWeights = _totalWeights;     } ``` can be replaced with: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;         require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");         shareholders[_accountIndex].weight = _weight;     } ``` ## Tools Used  Manual analysis  "}, {"title": "For `uint` replace `> 0` with `!= 0`", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept For unsigned integers, it is cheaper to check ` != 0` than ` > 0`. Both provide the same logic. ## Occurences ``` contracts/FeeSplitter.sol:105:        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\"); contracts/FeeSplitter.sol:172:        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\"); contracts/FeeSplitter.sol:263:        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\"); contracts/NestedBuybacker.sol:97:        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) { contracts/NestedFactory.sol:69:        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\"); contracts/NestedFactory.sol:94:        require(_orders.length > 0, \"NestedFactory::create: Missing orders\"); contracts/NestedFactory.sol:110:        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\"); contracts/NestedFactory.sol:124:        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\"); contracts/NestedFactory.sol:143:        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\"); contracts/NestedFactory.sol:163:        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\"); contracts/NestedFactory.sol:194:        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\"); contracts/NestedFactory.sol:333:            if (_inputTokenAmounts[i] - amountSpent > 0) { contracts/NestedFactory.sol:467:        if (_amountToSpent - _amountSpent > 0) { contracts/NestedRecords.sol:171:        require(_maxHoldingsCount > 0, \"NestedRecords: INVALID_MAX_HOLDINGS\"); contracts/operators/Flat/FlatOperator.sol:18:        require(amount > 0, \"FlatOperator::commitAndRevert: Amount must be greater than zero\"); contracts/operators/ZeroEx/ZeroExOperator.sol:42:        assert(amountBought > 0); contracts/operators/ZeroEx/ZeroExOperator.sol:43:        assert(amountSold > 0); ```  "}, {"title": "Save gas by caching array length used in for loops", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Example: ``` for (uint i = 0; i < arr.length; i++) { //Operations not effecting the length of the array. } ``` Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Recommended implementation: ``` uint length = arr.length; for (uint i = 0; i < length; i++) { //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences ``` contracts/FeeSplitter.sol:108:        for (uint256 i = 0; i < _accounts.length; i++) { contracts/FeeSplitter.sol:125:        for (uint256 i = 0; i < _tokens.length; i++) { contracts/FeeSplitter.sol:210:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/FeeSplitter.sol:227:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/MixinOperatorResolver.sol:32:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/MixinOperatorResolver.sol:48:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/NestedFactory.sol:203:        for (uint256 i = 0; i < tokens.length; i++) { contracts/NestedFactory.sol:280:        for (uint256 i = 0; i < _orders.length; i++) { contracts/NestedFactory.sol:316:        for (uint256 i = 0; i < _orders.length; i++) { contracts/OperatorResolver.sol:33:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:45:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:56:        for (uint256 i = 0; i < destinations.length; i++) { ```  "}, {"title": "NestedFactory: _transferToReserveAndStore can be simplified to save on gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [_transferToReserveAndStore](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L426), `_token` is casted 3 times to `IERC20` and `reserve` is loaded and casted to `address` 4 times. We can simplify the function and save on gas.  ## Proof of Concept `_token` should be passed to the function as an `IERC20`, this way we avoid to cast it 3 times. `reserve` should be stored in a variable to avoid 3 unnecessary sloads and casting.  ## Recommended Mitigation Steps The following changes are recommended.  ```     function _transferToReserveAndStore(         IERC20 _token,         uint256 _amount,         uint256 _nftId     ) private {         address reserveAddress = address(reserve);         uint256 balanceReserveBefore = _token.balanceOf(reserveAddress);          // Send output to reserve         _token.safeTransfer(reserveAddress, _amount);          uint256 balanceReserveAfter = _token.balanceOf(reserveAddress);          nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddress);     } ```  After this subsequent change, `_outputToken` will need to be casted to `IERC20` on [L386](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L386).  `_transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);`  And no need to cast `_outputToken` anymore on [L357](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L357).  `_transferToReserveAndStore(_outputToken, amountBought - feesAmount, _nftId);`  "}, {"title": "Weak guarantees on ZeroExOperator using correct create2 salt to recompute storage address", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Potential for a broken deploy of operators which use a storage contract (not in the case of `ZeroExOperator` however)  ## Proof of Concept  `ZeroExOperator` uses a create2 salt of `bytes32(\"nested.zeroex.operator\")` to deploy its storage contract and this salt must be used to recompute this address in future.  It's then important to enforce that both steps use the same salt, however this is not strictly enforced. Currently a change to one must be manually updated in the other, if this was not done then calculation of the storage address would be incorrect.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L15  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L60  This is not an issue in the current case but this is a potential footgun for future operators which use storage.  ## Recommended Mitigation Steps  Place `bytes32(\"nested.zeroex.operator\")` into a constant variable and use this variable instead.  "}, {"title": "ZeroExOperator", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced ease of verifying correctness  ## Proof of Concept  `ZeroExOperator` uses the `Create2` library to deploy `ZeroExOperatorStorage`. `Create2` also exposes a `computeAddress` function which can be used to recalculate the address of `ZeroExOperatorStorage` but `ZeroExOperator` instead uses a homebrew calculation in `storageAddress`.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L55-L65  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/57630d2a6466dff65aa7ca67b3fa23d5e6d1474a/contracts/utils/Create2.sol#L57-L64  The implementation is identical but using standard library code avoids the need for verification and minimises possible mistakes.  ## Recommended Mitigation Steps  Replace `storageAddress` with  ```     function storageAddress(address own) public pure returns (address) {        return Create2.computeAddress(             bytes32(\"nested.zeroex.operator\"),             keccak256(type(ZeroExStorage).creationCode)             own,         );     }  ```  "}, {"title": "use msg.sender rather than _msgSender() in FeeSplitter.receive", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  In the `receive` function of `FeeSplitter` we check that the address sending ETH is the WETH contract: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L74  As we can safely say that the WETH contract will never send a metatransaction, we can just use msg.sender and avoid the extra gas costs of `_msgSender()`  ## Recommended Mitigation Steps  Replace `_msgSender()` with `msg.sender`  "}, {"title": "tokenByIndex returns wrong token id", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _assignNewTokenId first increments _totalSupply and then assigns token id, so ids start from 1, not 0. However, function tokenByIndex in MixinERC721Enumerable expects the index to be less than totalSupply: ```solidity   /// @notice Enumerate valid NFTs   /// @dev Throws if `_index` >= `totalSupply()`.   /// @param _index A counter less than `totalSupply()`   /// @return The token identifier for the `_index`th NFT,   ///  (sort order not specified)   function tokenByIndex(     uint256 _index   ) public view     returns (uint256)   {     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index;   } ``` This mismatch between indexes and token ids may trick other platforms or integrations.  ## Recommended Mitigation Steps I think the solution is simply returning index + 1: ```solidity     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index + 1; // index 0 = token id 1 ```  "}, {"title": "msg.value should be 0 when token is not native", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/220", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function purchase is payable, thus it should validate that msg.value is 0 when tokenAddress != address(0) to prevent accidental sent Ether.  ## Recommended Mitigation Steps Check no ether was sent when the token is not a native currency.  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L109-L140  ```solidity=109   function tokenURI(     uint256 _tokenId   ) external     view     returns(string memory)   {     string memory URI;     string memory tokenId;     string memory lockAddress = address(this).address2Str();     string memory seperator;      if(_tokenId != 0) {       tokenId = _tokenId.uint2Str();     } else {       tokenId = '';     }      if(bytes(baseTokenURI).length == 0) {       URI = unlockProtocol.globalBaseTokenURI();       seperator = '/';     } else {       URI = baseTokenURI;       seperator = '';       lockAddress = '';     }      return URI.strConcat(         lockAddress,         seperator,         tokenId       );   } ```  `seperator` should be `separator`.  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinRefunds.sol#L40-L43  ```solidity=40 /**    * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation    * of the key    */ ```  `user's ket` should be `user's key`.  "}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/204", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L54-L60  ```solidity=54   function updateLockName(     string calldata _lockName   ) external     onlyLockManager   {     name = _lockName;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L92-L98  ```solidity=92   function setBaseTokenURI(     string calldata _baseTokenURI   ) external     onlyLockManager   {     baseTokenURI = _baseTokenURI;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L204-L214  ```solidity=204   function setEventHooks(     address _onKeyPurchaseHook,     address _onKeyCancelHook   ) external     onlyLockManager()   {     require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');     require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');     onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);     onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);   } ```  "}, {"title": "Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/188", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of thier time to another user using `shareKey`.  This makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.  ### PoC  Given:  - `keyPrice` is 1 ETH; - `expirationDuration` is 360 days; - `freeTrialLength` is 31 days.  The attacker can create two wallet addresses: Alice and Bob.  1. Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times; 2. Bob calls `cancelAndRefund()` and get 1 ETH.  ### Recommendation  Consider disabling `cancelAndRefund()` for users who transferred time to another user.  "}, {"title": "Code Style: Unnecessary public function visibility", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/184", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice to limit the visibility to `external` if the function is expected to be called externally only.  ```solidity=180{185}   /**    * Public function which returns the total number of unique owners (both expired    * and valid).  This may be larger than totalSupply.    */   function numberOfOwners()     public     view     returns (uint)   {     return owners.length;   } ```  `numberOfOwners()` can be changed to `external`.  "}, {"title": "`MixinTransfer.sol#transferFrom` Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/182", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152  ```solidity     if (toKey.tokenId == 0) {       toKey.tokenId = _tokenId;       _recordOwner(_recipient, _tokenId);       // Clear any previous approvals       _clearApproval(_tokenId);     }      if (previousExpiration <= block.timestamp) {       // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration       // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID       toKey.expirationTimestamp = fromKey.expirationTimestamp;       toKey.tokenId = _tokenId;        // Reset the key Manager to the key owner       _setKeyManagerOf(_tokenId, address(0));        _recordOwner(_recipient, _tokenId);     } else {       // The recipient has a non expired key. We just add them the corresponding remaining time       // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow       toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;     } ```  Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.  However, in L131-136, the key manager is not being reset.  This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.  ### PoC  Given:  - Alice owns a key that is valid until 1 year later.  1. Alice calls `setKeyManagerOf()`, making herself the keyManager; 2. Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key; 3. Alice calls `transferFrom()` again, transferring the key back from Bob.  ### Recommendation  Consider resetting the key manager regardless of the status of the recipient's key.  "}, {"title": "Inaccurate fees computation", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:  ```solidity uint fee = getTransferFee(keyOwner, _timeShared); uint timePlusFee = _timeShared + fee; ```  However, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**. The fee is now simply taken on the remaining time.  ```solidity if(timePlusFee < timeRemaining) {   // now we can safely set the time   time = _timeShared;   // deduct time from parent key, including transfer fee   _timeMachine(_tokenId, timePlusFee, false); } else {   // we have to recalculate the fee here   fee = getTransferFee(keyOwner, timeRemaining);   // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time   time = timeRemaining - fee; } ```  It should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  #### POC To demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.  The correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.  However, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as: (Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.  They would receive 100 seconds less than what they are owed.  ## Impact When transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).  ## Recommended Mitigation Steps It should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal). In the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  "}, {"title": "No ERC20 safeApprove called & not success check", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/161", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  For the tokens that return a success value, the contract does not check it.  Non-safe transfers are used in: - `MixinLockCore.approveBeneficiary`: `IERC20Upgradeable(tokenAddress).approve(_spender, _amount)`   ## Impact Tokens that return `false` on a failed `approve` or that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  "}, {"title": "Approvals not cleared after key transfer", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/160", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview: - key manager (map `keyManagerOf`) - single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf` - operator approvals (map `managerToOperatorApproved`)  The `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.  Notice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:  ```solidity function transferFrom(   address _from,   address _recipient,   uint _tokenId )   public   onlyIfAlive   hasValidKey(_from)   onlyKeyManagerOrApproved(_tokenId) {   // @audit this is skipped if user had a key that expired   if (toKey.tokenId == 0) {     toKey.tokenId = _tokenId;     _recordOwner(_recipient, _tokenId);     // Clear any previous approvals     _clearApproval(_tokenId);   }    if (previousExpiration <= block.timestamp) {     // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration     // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID     toKey.expirationTimestamp = fromKey.expirationTimestamp;     toKey.tokenId = _tokenId;      // Reset the key Manager to the key owner     // @audit  doesn't clear approval if key manager already was 0     _setKeyManagerOf(_tokenId, address(0));      _recordOwner(_recipient, _tokenId);   }   // ... }  //  function _setKeyManagerOf(   uint _tokenId,   address _keyManager ) internal {   // @audit-ok only clears approved if key manager updated   if(keyManagerOf[_tokenId] != _keyManager) {     keyManagerOf[_tokenId] = _keyManager;     _clearApproval(_tokenId);     emit KeyManagerChanged(_tokenId, address(0));   } } ```  ## Impact It's possible to sell someone a key and then claim it back as the approvals are not always cleared.  ## POC - Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future. - A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`. - A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom` - A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`. - A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.) - A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.  ## Recommended Mitigation Steps The `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types. The `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.   "}, {"title": "Can set arbitrary lock templates", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/158", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Unlock.setLockTemplate` function sets the default lock tempalte for new lock creations. However, it does not verify that this lock template is a valid template that was added to `_publicLockVersions` via `addLockTemplate`.  ## Impact A default template with a wrong version number can be set which is incompatible with updating locks through `upgradeLock` (requires `version == currentVersion + 1`).  ## Recommended Mitigation Steps Add new lock templates using `addLockTemplate` first and restrict `setLockTemplate` to only use these templates, not arbitrary code.   "}, {"title": "ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter should checked for success.  See `Unlock.recordKeyPurchase` which performs ERC20 transfers without checking for the return value.  ## Impact As the trusted `udt` token is used which supposedly reverts on failed transfers, not checking the return value does not lead to any security issues. We still recommend checking it to abide by the EIP20 standard.  ## Recommended Mitigation Steps Consider using `require(IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward), \"transfer failed\")` instead.  "}, {"title": "Initialization parameters of new lock template are hardcoded", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/137", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  `setLockTemplate` is initializing the new template using hardcoded values. This means that if a new lock version is set which has different/additional `initialize` parameters, Unlock protocol would have to be updated in order to initialize it.  ## Impact Less convenient adding of new locks as Unlock would have to be upgraded if their initialize function has changed.  ## Proof of Concept `setLockTemplate` uses the following code to initialize the template: ```     IPublicLock(_publicLockAddress).initialize(       address(this), 0, address(0), 0, 0, ''     ); ``` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L430:#L432 Which is hardcoded. This is unlike `createLock` for example, where the initialize call is being received as parameter, to allow different future versions. https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L219   ## Recommended Mitigation Steps Change `setLockTemplate` so the initializing parameters would be received as parameter.  "}, {"title": "MEV miner can mint larger than expected UDT total supply", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/135", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  elprofesor   # Vulnerability details  ## Impact `UnlockProtocol` attempts to calculate gas reimbursement using tx.gasprice, typically users who falsify tx.gasprice would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the tx.gasprice used. As the following calculation is made; ```     uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice; ```  we can see that arbitrary tx.gasprices can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.  ## Proof of Concept  ## Recommended Mitigation Steps Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.  "}, {"title": "Reduce rounding error when minting UDT in Unlock", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact `maxTokens` in Unlock's `recordKeyPurchase` currently rounds more than is required.  ## Proof of Concept Plug the formula in Wolfgram Alpha to simplify from:  ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct; ```  to ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 * (valueInETH + grossNetworkProduct)); ```  Example inputs: ``` balance: 10000 price: 0.012345678912345678 gnp: 1000 + 0.012345678912345678 (for this purchase)  61728394561728390 old formula 61727632492197622 new formula (smaller than old) 61726870441482920.98 actual per wolfgram (smaller than new) 1524120245470 delta old - actual 762050714702 delta new - actual ```  The \"new\" formula proposed above is closer to the expected value. It's also easier to read and saves 123 gas.  ## Tools Used https://www.wolframalpha.com/  ## Recommended Mitigation Steps  "}, {"title": "Fix event params for `KeyManagerChanged`", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact KeyManagerChanged does not emit the new manager address as expected. Additionally there's a small gas savings of 1.5k gas by not emitting the event twice in `grantKeys`.  ## Proof of Concept Per the event param names, this event should emit the new keyManager's address. That would allow an indexer such as subgraph to track the current manager for each token. However the event currently emits address(0):  https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinKeys.sol#L229  Change that line to: `emit KeyManagerChanged(_tokenId, _keyManager);`  Additionally this line may be removed: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L48 as the call right before it to `_setKeyManagerOf` will emit the event already.  ## Tools Used `yarn test`  ## Recommended Mitigation Steps When testing this change only one test failed, and it was due to assuming the index of the event: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L80  It would be nice to be more robust like some other tests are, e.g. https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L49   Also add a test to confirm that the keyManager is emitting in the event.  Personally I like Waffle for testing events: https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html?highlight=emits#writing-tests  ```  it('Transfer emits event', async () => {     await expect(token.transfer(walletTo.address, 7))       .to.emit(token, 'Transfer')       .withArgs(wallet.address, walletTo.address, 7);   }); ```  "}, {"title": "MixinLockCore.sol has wrong comments", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Wrong comment for withdraw(): modifier onlyLockManagerOrBeneficiary also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123)  Wrong comment for updateBeneficiary(): require statement also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189)  ## Recommended Mitigation Steps - Fix comments, because the implementation seems to be correct    "}, {"title": "a single user can become owner of multiple token ids", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact / POC  A single user can become the owner of multiple token ids and break the assumption of the comment [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181) of the function numberOfOwners() that it returns \"total number of unique owners\"   If a key manager/approved transfers a key with transferFrom() [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109) to a recipient that also owns a valid key then we don't go into the \"if block\" L131 and also not into the \"if block\" L138 (this is important s.t. no key owner change happens) and go into the \"else block\" L148 (not really important).   We end with: fromKey.expirationTimestamp = block.timestamp; and fromKey.tokenId = 0;  If the key owner or someone else buys for this key owner again a \"key\" [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51) satisfies the condition idTo ==0 (bcs of tokenId = 0) and in _assignNewTokenId(toKey); the key gets a new token id and the owner gets also registered as the new owner of the new token id in _recordOwner(_recipient, idTo);  The \"old\" key got overwritten but we are now the owner of two token ids.  This breaks the comment of numberOfOwners() that it returns \"total number of unique owners\" but for this the key owner that owns now two token ids, we executed \"_recordOwner\" twice and therefore added the same address twice to the owner array  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327)   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  - need to also implement the removal of ownership of a tokenId when it is set 0 zero to be congruent with the state of the key, and also adapt the other logic depending on it  "}, {"title": "Remove fallback function", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact Unimplemented calls do not revert, this may cause unexpected behavior in wallets or other contracts.  ## Proof of Concept Locks are ERC721s, they also implement some ERC20 style calls such as `transfer`. If a wallet or another contract attempted to treat the contract as a ERC77, `send` would incorrectly appear to work but nothing happens under the hood. It would be better if this call reverted so that the user was aware the function is not supported before even broadcasting the transaction (Metamask will warn you if estimate gas fails).  This test currently fails (i.e. calling send does not revert).  ```   it(\"Should fail on unknown calls\", async () => {       const mock777 = await erc777.at(lock.address);       await reverts(         mock777.send(destination, 1, '0x', { from: singleKeyOwner })       )     }) ```  ## Tools Used `yarn test`  ## Recommended Mitigation Steps Remove this line https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/PublicLock.sol#L72  Per the comments there is not a clear reason it's currently included. The test suite still passes when it is removed.  "}, {"title": "shareKey onERC721Received tokenId", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact A contract implementing `ERC721TokenReceiver` is called with a tokenId that was not sent to that address when `shareKey` is used. If the `onERC721Received` implementation included any logic which assumed ownership it may fail, e.g. checking `ownerOf`, `balanceOf` or performing a task such as `transferFrom` to forward the asset to another destination.  ## Proof of Concept `shareKey` accepts a `_tokenId` as the source of expiration time to share. It then either mints a new token for the target account or adds time to their existing key. Either way the receiver has a different tokenId than the one that was passed to the `shareKey` function.  ## Tools Used n/a  ## Recommended Mitigation Steps Change https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinTransfer.sol#L106  from: `require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  to: `require(_checkOnERC721Received(keyOwner, _to, idTo, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  "}, {"title": "Unconventional log emittance confuses Etherscan", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/90", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  Unlock doesn't follow standard ERC721 log emittance. This leads to wrong display values regarding to the lock NFT on Etherscan.  ## Impact Etherscan does not show txs correctly, does not count token holders correctly in token page, does not count tokens correctly in user page.  ## Proof of Concept A scenario: - Create a new lock - User 1 mints 1 token - User 1 uses `shareKey` and transfers some amount to User 2 At this point Etherscan will show that 3 transfers have been made, under user 2's address page user 2 has 2 keys , and under lock's holders tab user 2 has 2 keys. All this is obviously wrong. This is probably because the transfer event is emitted twice during shareKey: [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L87) and [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L100).  Additionally, if user 1 now calls `Cancel And Refund`, user 1 will still have a key under his tokens in his account, and the lock's token page will still list him as a holder, and the transaction won't get shown in Etherscan's token transfers (unlike contract transactions). Probably because it has not emitted any burn event. It just emits a [CancelKey event](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L111).  ## Recommended Mitigation Steps You can align the logs emittance to match regular ERC721 logs if you'd like Etherscan to show correct amounts. It might get confusing to keep it like this.  "}, {"title": "Key transfer will destroy key if from==to", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  If calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).  ## Impact A key manager or approved might accidently destroy user's token.  Note: this requires user error and so I'm not sure if this is a valid finding. However, few things make me think that it is valid: - Unlock protocol checks for transfer to 0-address, so some input validation is there - Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen. - This scenario manifests a unique and probably unintended behavior   ## Proof of Concept By following `transferFrom`'s execution: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166 One can see that in the case where `_from == _recipient` with a valid key: - The function will deduct transfer fee from the key - The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151)) - The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158)) Therefore, the user will lose his key without getting a refund.  ## Recommended Mitigation Steps Add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`  "}, {"title": "Wrong event parameter emitted at _setKeyManagerOf", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  `_setKeyManagerOf` always emits `address(0)` as the new key manager.  ## Impact Wrong event emitted.  ## Proof of Concept The code is: `emit KeyManagerChanged(_tokenId, address(0));` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L229  ## Recommended Mitigation Steps Change line to `emit KeyManagerChanged(_tokenId, _keyManager);`  "}, {"title": "Missing `_beforeTokenTransfer` Token Transfer Handle", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  hagrid   # Vulnerability details  ## Details `UnlockDiscountTokenV2.sol` has override for `_afterTokenTransfer` handler function to control events or operations after token transfers. Also, the `UnlockDiscountTokenV2.sol` uses another token contracts from `ERC20Patched.sol`. In `ERC20Patched.sol` contract there are also `_beforeTokenTransfer` transfer handles. However, the `UnlockDiscountTokenV2.sol`  token does not have any override for `_beforeTokenTransfer` method.   ## Impact Contract will not react to any operations before token transfers. If gas calculations are aimed on UnlockToken's transfer, it will not be possible to calculate correct gas amounts without these both handlers (_beforeTokenTransfer and _afterTokenTransfer)  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Recommended Mitigation Steps Possible fix is implementing additional override for `_beforeTokenTransfer` method:  ```  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {     return ERC20VotesUpgradeable._beforeTokenTransfer(from, to, amount);   } ```  "}, {"title": "Function type from public to external tokenByIndex()", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability Description Some of the implemented functions inside the smart contracts are of type Public, However these functions are not used within the contracts. The function **tokenByIndex()** is part of the EIP721 which define it as external function.  ## Impact Coding style quality.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinERC721Enumerable.sol#L35  ## Tools Used manual code review.  ## Recommended Mitigation Steps Change the function to external and follow the ERC721 Specs when implementing: https://eips.ethereum.org/EIPS/eip-721#specification  "}, {"title": "Missing event for critical updateBeneficiary function", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The function **updateBeneficiary** in the **MixinLockCore** smart contract is used to lets the owner of the lock update the beneficiary account which receives funds on withdrawal.   ## Impact Attackers can change the beneficiary address using this function before continue with the withdrawal function. Unlock protocol team and users can't log or monitor this critical changes.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinLockCore.sol#L192  ## Tools Used manual code review  ## Recommended Mitigation Steps define event and emit it to track changes done to the system.  "}, {"title": "Unimplemented function computeAvailableDiscountFor ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The function computeAvailableDiscountFor is left unimplemented in Unlock.sol. Recommend implementing this function or removing it.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L269  ## Tools Used Inspection.  ## Recommended Mitigation Steps Implement function or remove it to save gas.  "}, {"title": "Missing maxNumberOfKeys checks in shareKey and grantKey", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  More keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.  ## Impact More keys can be minted than intended.  ## Proof of Concept In both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`. This is unlike `purchase`, which has the `notSoldOut` modifier. `grantKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42 `shareKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84 Both functions call `_assignNewTokenId` which does not check maxNumberOfKeys.  https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322 So you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).  ## Recommended Mitigation Steps Add a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.  "}, {"title": "Fund stuck in `Liquidator` if `stopLiquidation` is called ", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `stopLiquidation` does not pull fund from `Liquidator` while setting `_liquidator` to address(0). Since the `DebtLocker` own `Liquidator` and there are no way to set `_liquidator` to existing address, fund still in `Liquidator` would be stuck unless `DebtLocker` is upgraded to support such behavior.  Also, when `stopLiquidation` is called, remaining fund in Liquidator can still be liquidated by keepers.  ## Proof of Concept https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L112 ```     function stopLiquidation() external override {         require(msg.sender == _getPoolDelegate(), \"DL:SL:NOT_PD\");          _liquidator = address(0);          emit LiquidationStopped();     } ```  ## Recommended Mitigation Steps Pull remaining fund in `stopLiquidation`    "}, {"title": "Reuse arithmetic results can save gas ", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L205-L215  ```solidity function _handleClaimOfRepossessed() internal returns (uint256[7] memory details_) {     ...     details_[0] = recoveredFunds + fundsCaptured;     details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : 0;     details_[2] = fundsCaptured;     details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;     details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : 0;      _fundsToCapture = uint256(0);     _repossessed    = false;      require(ERC20Helper.transfer(fundsAsset, _pool, recoveredFunds + fundsCaptured), \"DL:HCOR:TRANSFER\"); } ```  `recoveredFunds + fundsCaptured` at L215 is calculated before at L205, since it's a checked arithmetic operation with two memory variables, resue the result instead of doing the arithmetic operation again can save gas.  ### Recommendation  Change to:  `require(ERC20Helper.transfer(fundsAsset, _pool, details_[0]), \"DL:HCOR:TRANSFER\");`  "}, {"title": "Avoid unnecessary arithmetic operations can save gas", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `MapleLoanInternals.sol#_getCollateralRequiredFor`, when `principal_ <= drawableFunds_`, `0 / principalRequested_` can be avoid.  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L359-L359  ```solidity=359 return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_; ```  ### Recommendation  Change to:  ```solidity if (principal_ <= drawableFunds_) {     return uint256(0); }  return (collateralRequired_ * (principal_ - drawableFunds_)) / principalRequested_; ```  "}, {"title": "`Liquidator.sol#_locked` Switching between 1, 2 instead of true, false is more gas efficient", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/Liquidator.sol#L45-L62  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(!_locked, \"LIQ:LP:LOCKED\");      _locked = true;     ...     _locked = false; } ```  `SSTORE` from false (0) to true (1) (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  ### Recommendation  Change to:  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(_locked = 1, \"LIQ:LP:LOCKED\");      _locked = 2;     ...     _locked = 1; } ```  "}, {"title": "Cache external call result in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  Instances include:  `IERC20Like(collateralAsset).decimals()` in `DebtLocker.sol#getExpectedAmount()` can be cached to avoid an extra external call.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L237-L253  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** IERC20Like(collateralAsset).decimals()                      // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** IERC20Like(collateralAsset).decimals();      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  ### Recommendation  Change to:  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** collateralAssetDecimals                                     // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** collateralAssetDecimals;      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  "}, {"title": "`makePayment()` Lack of access control allows malicious `lender` to retrieve a large portion of the funds earlier, making the borrower suffer fund loss", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/56", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L86-L93  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");          ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  The current implementation allows anyone to call `makePayment()` and repay the loan with `_drawableFunds`.  This makes it possible for a malicious `lender` to call `makePayment()` multiple times right after `fundLoan()` and retrieve most of the funds back immediately, while then `borrower` must continue to make payments or lose the `collateral`.  ### PoC   Given:  - `_collateralRequired` = 1 BTC - `_principalRequested` = 12,000 USDC - `_paymentInterval` = 30 day - `_paymentsRemaining` = 12 - `_gracePeriod` = 1 day - `interestRate_` = 2e17  1. The borrower calls `postCollateral()` and added `1 BTC` as `_collateralAsset`; 2. The lender calls `fundLoan()` and added `12,000 USDC` as  `_fundsAsset`; 3. The lender calls `makePayment()` 11 times, then: - `_drawableFunds` = 96 - `_claimableFunds` = 11903 - `_principal` = 1553  4. The lender calls `_claimFunds()` get 11,903 USDC of `_fundsAsset` back;  Now, for the borrower `1,579 USDC` is due, but only `96 USDC` can be used. The borrower is now forced to pay the interests for the funds that never be used or lose the collateral.  ### Recommendation  Change to:  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");          require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");              ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  "}, {"title": "Gas Optimization: Use constant instead of block.timestamp", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Use type(uint).max instead of block.timestamp to save gas  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L71 https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L71  "}, {"title": "Unchecked return value for `ERC20.approve` call", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  There are a few functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  "}, {"title": "Unsafe implementation of `fundLoan()` allows attacker to steal collateral from an unfunded loan", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273  ```solidity=257     uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.     uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Drawable funds is the amount funded, minus any fees.     _drawableFunds = fundsLent_ - treasuryFee - delegateFee;      require(         treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),         \"MLI:FL:T_TRANSFER_FAILED\"     );      require(         delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),         \"MLI:FL:PD_TRANSFER_FAILED\"         ); ```  In the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.  This allows the attacker to set very high fees, making `_drawableFunds` near 0.  Since `mapleTreasury` and `poolDelegate` are also read from `lender_`, `treasuryFee` and `investorFee` can be retrieved back to the attacker.  As a result, the borrower won't get any `_drawableFunds` while also being unable to remove collateral.  ### PoC  Given:  - `_collateralRequired` = 10 BTC - `_principalRequested` = 1,000,000 USDC - `_paymentInterval` = 1 day - `_paymentsRemaining` = 10 - `_gracePeriod` = 1 day  1. Alice (borrower) calls `postCollateral()` and added `10 BTC` as `_collateralAsset`; 2. The attacker calls `fundLoan()` by taking `1,000,000 USDC` of flashloan and using a fake `lender`contract; 3. Alice calls `drawdownFunds()` with any amount > 0 will fail; 4. Alice calls `removeCollateral()` with any amount > 0 will get \"MLI:DF:INSUFFICIENT_COLLATERAL\" error; 5. Unless Alice make payment (which is meaningless), after 2 day, the attacker can call `repossess()` and get `10 BTC`.  ### Recommendation  Consider reading `treasuryFee`, `investorFee`, `mapleTreasury`, `poolDelegate` from an authoritative source instead.  "}, {"title": "Anyone can call `closeLoan()` to close the loan", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L56-L63  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  Based on the context, we believe that the `closeLoan()` should only be called by the `borrower`. However, the current implementation allows anyone to call `closeLoan()` anytime after `fundLoan()`.  If there is no `earlyFee`, this enables a griefing attack, causing the `borrower` and `lender` to abandon this contract and redo everything which costs more gas.  If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in `fundLoan()`.  ### Recommendation  Change to:  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");          require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  "}, {"title": "Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L85-L89  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), \"DL:SAS:NOT_PD\");          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  Considering that `_allowedSlippage` is a crucial settings for `getExpectedAmount()`, it's necessary to add `require(_allowedSlippage <  10000, \"...\")` to validate the input.  If `_allowedSlippage` is misconfigured to a value > `10000`, `getExpectedAmount()` will always revert.  ### Recommendation  Change to:  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), \"DL:SAS:NOT_PD\");         require(_allowedSlippage <  10000, \"!slippage\")          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  "}, {"title": "Functionality of liquidation strategies can be broken", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  cmichel   # Vulnerability details  The liquidations strategies (`code-423n4/evm-league/56-maple/repo/liquidations-1.0.0-beta.1/contracts/SushiswapStrategy.sol/UniswapStrategy.sol`) check that the current contract balance in the `swap` callback exactly equals the `swapAmount_` parameter from `flashBorrowLiquidation`. (The `swap` is called as a callback from `flashBorrowLiquidation`'s `liquidatePortion`).  ```solidity function swap(     uint256 swapAmount_,     uint256 minReturnAmount_,     address collateralAsset_,     address middleAsset_,     address fundsAsset_,     address profitDestination_ )     external override {     // @audit grifer can send 1 wei. should >=     require(IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_, \"SushiswapStrategy:WRONG_COLLATERAL_AMT\"); } ```  There's a griefing attacker where a keeper tries to liquidate and calls `flashBorrowLiquidation`  but an attacker frontruns this transaction and sends the smallest unit of the `collateralAsset_` to the contract, making this `require` call fail.  ## Impact The important automated liquidation strategies that Keepers might use do not work anymore, no liquidations are done in time, and bad debt can occur.  I'd rate this as high severity as the impact is big and it's also very easy to break this contract entirely with a single transfer: - there's only one strategy contract for many liquidation contracts which means it's important that it's reliable - it's enough to send a few tokens of collateral assets to the contract _once_ to break the `flashBorrowLiquidation/swap` functionality. Because when calling `flashBorrowLiquidation(swapAmount)`, the liquidation contract will always send exactly this `swapAmount` to the strategy, meaning the `IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_` comparison will always fail if there already were tokens in the contract.  ## Recommended Mitigation Steps Use a `IERC20Like(collateralAsset_).balanceOf(address(this)) >= swapAmount_` comparison instead.   "}, {"title": "Same implementation can be registerd for several versions", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  cmichel   # Vulnerability details  It's possible to overwrite the `_versionOf[implementationAddress_]` field through the `proxy-factory-1.0.0-beta.1/contracts/ProxyFactory._registerImplementation` function and register the implementation as several distinct versions.  ```solidity function _registerImplementation(uint256 version_, address implementationAddress_) internal virtual returns (bool success_) {     // Cannot already be registered and cannot be empty implementation.     if (_implementationOf[version_] != address(0) || !_isContract(implementationAddress_)) return false;     _versionOf[implementationAddress_] = version_;     _implementationOf[version_]        = implementationAddress_;      return true; } ```  #### POC - call `_registerImplementation(1, impl)` - call `_registerImplementation(2, impl)`. This does not check that the versions has not already been registered by checking `_versionOf[impl] == 0`. Then the old `_versionOf[impl] = 1` is overwritten with `2`.  ## Recommended Mitigation Steps Check if being able to set a new version for the same contract is desired. If not, add a `_versionOf[impl] == 0` check.  "}, {"title": "Function poolDelegate does not have a named return (DebtLocker.sol)", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity or possibly gas savings if all the other named returns are in error.  ## Proof of Concept  Function `poolDelegate` does not have a named return even though its interface definition does. The named return isn't used so the fact that it's missing doesn't matter.  Function `pool` and tens of other functions do have a named return. Most of these named returns are not used and could be deleted. I'm assuming this is a project convention and may be used in off-chain reporting, etc.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L279-L285  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a named return to function `poolDelegate' for consistency/reporting.  Or if all those other named returns are in error, remove the unused named returns and kick this ticket over to gas optimization.    "}, {"title": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings   ## Proof of Concept  \"> 0\" is used in the following location(s):  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L312  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Change \"> 0\" to \"!=0\" for small gas savings.    "}, {"title": "Floating pragma", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  saian   # Vulnerability details  ## Impact  Contracts should be deployed with the same version of compilers with which it was tested,  Using a unlocked pragma might result in contract being deployed with a version it was not tested with, and might result in bugs and unwanted behaviour.   ## Proof of Concept  Contracts in below repositories :     maple-labs/debt-locker     maple-labs/erc20-helper     maple-labs/loan     maple-labs/maple-proxy-factory     maple-labs/proxy-factory   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Lock the pragma version, it is advised not to use unlocked pragma in production.  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  wuwe1   # Vulnerability details  liquidations-1.0.0-beta.1/contracts/interfaces/ILiquidator.sol:79:17    * @dev   3. Perfroms a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user.  `Perfroms` should be `Performs`   maple-proxy-factory-1.0.0-beta.1/contracts/interfaces/IMapleProxied.sol:11:42  *  @param toVersion_ The new version ot the loan.  `ot` should be `of`  "}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:                approve without approving 0 first SushiswapStrategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first SushiswapStrategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);          approve without approving 0 first UniswapV2Strategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first UniswapV2Strategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);   "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/10", "labels": ["bug", "question", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:          Open TODO in DebtLocker.sol line 77 :     // TODO: Discuss pros/cons of pause on this function  "}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:  There are some variables that I was not sure if are assigned actually twice in real use. I added them anyway.          DebtLockerStorage.sol, _repossessed         DebtLockerStorage.sol, _loan         DebtLockerStorage.sol, _liquidator         DebtLockerStorage.sol, _pool         DebtLockerStorage.sol, _allowedSlippage         DebtLockerStorage.sol, _amountRecovered         DebtLockerStorage.sol, _fundsToCapture         DebtLockerStorage.sol, _minRatio         DebtLockerStorage.sol, _principalRemainingAtLastClaim         Liquidator.sol, collateralAsset         Liquidator.sol, destination         Liquidator.sol, fundsAsset         Liquidator.sol, owner         MapleLoanFactory.sol, isLoan         MapleLoanInternals.sol, _borrower         MapleLoanInternals.sol, _lender         MapleLoanInternals.sol, _pendingBorrower         MapleLoanInternals.sol, _pendingLender         MapleLoanInternals.sol, _collateralAsset         MapleLoanInternals.sol, _fundsAsset         MapleLoanInternals.sol, _collateralRequired         MapleLoanInternals.sol, _principalRequested         MapleProxyFactory.sol, mapleGlobals         MapleProxyFactory.sol, defaultVersion         MapleProxyFactory.sol, upgradeEnabledForPath         MapleProxyFactory.t.sol, governor         MapleProxyFactory.t.sol, notGovernor         MapleProxyFactory.t.sol, globals         MapleProxyFactory.t.sol, factory         MapleProxyFactory.t.sol, implementation1         MapleProxyFactory.t.sol, implementation2         MapleProxyFactory.t.sol, initializerV1         MapleProxyFactory.t.sol, initializerV2         MapleProxyFactory.t.sol, user     "}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/4", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           Liquidator.sol Variable _locked is read 2 times in the function:  liquidatePortion         MapleLoanInternals.sol Variable _drawableFunds is read 2 times in the function:  _closeLoan         MapleLoanInternals.sol Variable _refinanceCommitment is read 2 times in the function:  _acceptNewTerms         MapleLoanInternals.sol Variable _fundsAsset is read 3 times in the function:  _fundLoan         MapleProxyFactory.t.sol Variable governor is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable globals is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable initializerV1 is read 2 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable factory is read 3 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable factory is read 5 times in the function:  test_enableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_disableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation2 is read 2 times in the function:  test_upgradeInstance   "}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: SushiswapStrategy.sol, In line 53, Require message length to shorten: 38         Solidity file: SushiswapStrategy.sol, In line 74, Require message length to shorten: 33         Solidity file: UniswapV2Strategy.sol, In line 53, Require message length to shorten: 38         Solidity file: UniswapV2Strategy.sol, In line 74, Require message length to shorten: 33         Solidity file: MapleProxyFactory.sol, In line 33, Require message length to shorten: 36         Solidity file: MapleProxyFactory.sol, In line 42, Require message length to shorten: 36  "}, {"title": "`Timelock` Struct Packing in `Vesting.sol`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `Timelock` struct is used to reference the `releaseTimestamp` and vested `amount` for each vesting. These values can likely be safely stored as `uint64` and `uint192` values respectively, enabling the struct to be stored within a single slot instead of two slots.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L32-L35  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating `releaseTimestamp` to `uint64` and `amount` to `uint192` within the `Timelock` struct. It might be worthwhile performing sanity checks when storing these values by using OpenZeppelin's safe math and safe cast libraries.  "}, {"title": "Incorrect `require` Statement in `Vesting.claim()`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/306", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `claim()` function asserts that the claimable amount is strictly less than `benTotal` for a given user. However, this does not take into account previously claimed tokens, hence the `require` does not accurately depict its intended behaviour.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating this `require` statement to account for already claimed tokens. This could look like the following: `require(amount.add(benClaimed[msg.sender]) <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");`  "}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/301", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact  function burnEtherForMember should validate that the address of the member is not empty (0x0) to prevent accidental burns.   When adding an investor distribution (function addInvestor) should validate that the total amount is not above the investors_supply. but then you also need to store the total amount that is already assigned to investors.   function modifyInvestor should validate that _investor != _new, otherwise it will delete the investor unless this is an expected feature.   function claimExact should validate that _value > 0 to prevent useless claims.  "}, {"title": "_recordBurn _payer", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/300", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn does not really need this parameter of address _payer as it is always equal to msg.sender.   Consider replacing: function _recordBurn(address _payer, ... emit Burn(_payer, ...  with: function _recordBurn(... emit Burn(msg.sender, ...   "}, {"title": "Useless nonReentrant", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/293", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions validate and modifyInvestor do not need nonReentrant modifier as they do not execute any external calls where you can hook up to re-enter.   "}, {"title": "Optimize structs", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/290", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Member total_tokens in both structs Airdrop and Investors is practically not used and is a duplicate of the amount so you can remove it to save some storage. Also, gas efficiency can be improved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage, e.g. airdropBalances which are later translated to the amount in Airdrop struct (10**18) can be stored in a smaller version of uint as we know all the exact values at compile time.   "}, {"title": "Itteration over all the timelocks when revoking the user", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/285", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When revoking the user, there is no need to iterrate over all his timelocks again and calculate the total amount as it should already be stored in a benTotal[_addr] mapping:   uint256 locked = 0;   for (uint256 i = 0; i < timelocks[_addr].length; i++) {       locked = locked.add(timelocks[_addr][i].amount);   }   "}, {"title": "function claim optimizations", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/283", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function claim can save gas and eliminate duplicate storage access and math operations by caching claimableAmount and re-using it later when setting the benClaimed.   before:   uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);  after:   uint256 claimableAmount = _claimableAmount(msg.sender);   uint256 amount = claimableAmount.sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = claimableAmount;  Also, it looks strange that in function revoke the amount is checked with 'assert': assert(amount <= benTotal[_addr]); but in function claim 'require' is used: require(amount <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");  In both places probably 'assert' should be used as it is checking a scenario that should never happen under normal circumstances.   "}, {"title": "modifyInvestor does not need to check if _investor is not empty", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/281", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This check in function modifyInvestor is not neccessary:   require(_investor != address(0), \"Invalid old address\");  as empty address cannot be added in function addInvestor and later this check will fail:   require(investors[_investor].amount != 0);  "}, {"title": "Usage of assert", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/279", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contracts use assert() instead of require() in multiple places. Assert is recommended to be used to check for internal errors, or to check invariants.  In your case, I think these validations could better use 'require' as they are likely to be triggered: assert(claimable > 0); assert(airdrop[msg.sender].amount - claimable != 0); assert(block.timestamp - startEpochTime <= RATE_TIME); assert(block.timestamp - initTime >= YEAR * 5);  A similar issue was submitted in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/83  ## Recommended Mitigation Steps Consider replacing 'assert' with 'require' in the cases mentioned above.  "}, {"title": "burnAddress is not actually meant to burn anything", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/275", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact burnAddress is hardcoded to 0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2. I see this address is a Gnosis safe multisig. So the eth is not actually burned even though I expected the burn by looking at the code. This confusion happens because the codebase was adopted from Vader protocol but with no actual intention of burning.  ## Recommended Mitigation Steps To reduce this confusion and improve the readability of the codebase you should either rename the burn variables and functions or leave it as it is but comment and document the actual mechanics of the sale.   "}, {"title": "_recordBurn does not handle 0 _eth appropriately", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/274", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn should validate that _eth > 0. Now it is possible to spam this function with 0 eth burns and fictitiously increase member statistics.  I have previously reported this issue in a Vader's contest. You can read find details here: https://github.com/code-423n4/2021-04-vader-findings/issues/269  ## Recommended Mitigation Steps Handle case when _eth = 0 in function _recordBurn.  "}, {"title": "payable vest", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/273", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is no reason for the function vest to be 'payable' as it does not handle ether in any way and there is no way to rescue it later in case someone accidentally sends it.  ## Recommended Mitigation Steps Remove 'payable' from the vest function.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  ## Proof of Concept  1. Review the all contracts and add unchecked keyword where overflow is not possible.  \"https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L579\"  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying 'unchecked' keyword where overflows/underflows are not possible.    "}, {"title": "Packing of state variable ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact bool _iskilled  state variable can be packed with one of the address state variable like {token , owner}  which will save on slot of memory  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/BTCPoolDelegator.sol#L55  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/USDPoolDelegator.sol#L51   ## Tools Used  manual review  ## Recommended Mitigation Steps   "}, {"title": "wrong operator used in checking the fees, adminfee, withdrawfee", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/254", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact wrong operator used in checking the fees, adminfee, withdrawfee instead of      require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");       _fee < = SwapUtils.Max_Swap_Fee , should be there same with adminfee & withdrawfee becuase in using <= it does not exceed the max value     ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/customswap/contracts/Swap.sol#L192   ## Tools Used manual review  ## Recommended Mitigation Steps use correct operator to check the value  "}, {"title": "`SwapUtils.sol` Wrong implementation", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/252", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.  However, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.  As a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.  ### Recommendation  Consider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     return _xp(balances, self.tokenPrecisionMultipliers); } ```  To:  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;     tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)     return _xp(balances, tokenPrecisionMultipliers); } ```  "}, {"title": "Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/247", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L525-L525 ```solidity=525 require(airdrop[msg.sender].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L561-L561 ```solidity=561 require(airdrop[msg.sender].amount >= claimable); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L100-L100 ```solidity=100 require(investors[_investor].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L126-L126 ```solidity=126 require(investors[msg.sender].amount - claimable != 0); ```   "}, {"title": "`Vesting.sol#_claimableAmount()` Remove unnecessary storage variables can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/246", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/Vesting.sol#L184-L184  ```solidity=184     benVested[_addr][1] = partial_sum; ```  `benVested[_addr][1]` is never used in the contract and the sum of partial claimable vesting is changing every second. Removing it can save gas.  "}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/242", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1163-L1270  - `self.lpToken.totalSupply()` can be cached.  "}, {"title": "Use literal `2` instead of read from storage for `pooledTokens.length` can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/241", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current design requires the number of pooledTokens to be 2, therefore `pooledTokens.length` can be replaced with literal `2` to save ~100 gas from each storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1027-L1027  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1068-L1068  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1082-L1082  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1169-L1169  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1230-L1230  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1332-L1334  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1369-L1369  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1421-L1421  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1447-L1447  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1471-L1471  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L336-L336  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L295-L295  "}, {"title": "`SwapUtils.sol#getD()` Remove unnecessary variable and internal call can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/238", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L620-L623  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256 a = determineA(self, _xp(self));            // determine the correct A     return getD(_xp(self), a); } ```  `a` is unnecessary as it's being used only once. The result of `_xp(self)` can be cached to avoid calling it twice.  ### Recommendation  Change to:  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256[] memory xp = _xp(self);     return getD(xp, determineA(self, xp)); } ```  "}, {"title": "`SwapUtils.sol` Inconsistent parameter value of `lpTokenSupply` among `Liquidity` related events", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/237", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  There are 4 events with the parameter `lpTokenSupply` in `SwapUtils.sol`, but the value of `lpTokenSupply` is not consistent.  For the event `RemoveLiquidityOne`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1349-L1349  ```solidity=1349 emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply()); ```  For the event `RemoveLiquidityOne`, `lpTokenSupply` is pre burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1368-L1368  For the event `removeLiquidityImbalance`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1475-L1481  For the event `AddLiquidity`, `lpTokenSupply` is post mint:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1261-L1267  ### Recommendation  Given that 3 out of the 4 events are using updated `totalSupply` as `lpTokenSupply`, consider changing `RemoveLiquidityOne` to post burn `totalSupply`.  "}, {"title": "External call can be done later to save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1362-L1375  ```solidity=1362 function removeLiquidityOneToken(     Swap storage self,     uint256 tokenAmount,     uint8 tokenIndex,     uint256 minAmount ) external returns (uint256) {     uint256 totalSupply = self.lpToken.totalSupply();     uint256 numTokens = self.pooledTokens.length;     require(         tokenAmount <= self.lpToken.balanceOf(msg.sender),         \">LP.balanceOf\"     );     require(tokenIndex < numTokens, \"Token not found\");  ```  The external call to get the `totalSupply` of the `lpToken` can be done later to avoid unnecessary code execution when the check of `tokenAmount` and `tokenIndex` does not pass.  "}, {"title": "`SwapUtils.sol#getYD()` Remove redundant code can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  `getYD()` already `require(tokenIndex < numTokens, \"...\")`, so the check in `getYDC()` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L477-L502  ```solidity=477 function getYDC(     Swap storage self,     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal view returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, \"Token not found\");      // calculate y     uint256 y = getYD(a, tokenIndex, xp, d);     // ... } ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L522-L557 ```solidity=522 function getYD(     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal pure returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, \"Token not found\");     // ... } ```   ### Recommendation  Remove the redundant code.  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1710-L1714  ```solidity=1710 /**      * @notice Stops ramping Target price immediately. Once this function is called, rampTargetPrce()      * cannot be called for another 24 hours      * @param self TargetPrice struct to update      */ ```  `rampTargetPrce` should be `rampTargetPrice`.  "}, {"title": "Code Style: consistency", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/228", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  The parameter names of event `RampTargetPrice` should be the same as the struct `TargetPrice` for consistency.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L61-L78  ```solidity=61 event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTime,     uint256 futureTime ); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L117-L124  ```solidity=117{120-121} struct TargetPrice {     uint256 initialTargetPrice;     uint256 futureTargetPrice;     uint256 initialTargetPriceTime;     uint256 futureTargetPriceTime;          uint256[2] originalPrecisionMultipliers; } ```  ### Recommendation  Consider changing to:  ```solidity event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTargetPriceTime,     uint256 futureTargetPriceTime ); ```  "}, {"title": "Remove unnecessary variables can save some gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  `transferredDx` is unnecessary, it can be replaced with `dx`.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1098-L1123  ```solidity=1098{1119-1123} function swap(     Swap storage self,     uint8 tokenIndexFrom,     uint8 tokenIndexTo,     uint256 dx,     uint256 minDy ) external returns (uint256) {     require(         dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),         \"Cannot swap more than you own\"     );      // Transfer tokens first to see if a fee was charged on transfer     uint256 beforeBalance =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this));     self.pooledTokens[tokenIndexFrom].safeTransferFrom(         msg.sender,         address(this),         dx     );      // Use the actual transferred amount for AMM math     uint256 transferredDx =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(             beforeBalance         );     // ... ```  ### Recommendation  Change to:  ```solidity // Use the actual transferred amount for AMM math uint256 dx =     self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(         beforeBalance     ); // ... ```  "}, {"title": "Gas: Unnecessary msg.sender != 0 check", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `AirdropDistribution.claimExact` and `InvestorDistribution.claimExact` functions check that `msg.sender != address(0)`.  This is always true, nobody has the private key of the zero address and it cannot be spoofed. This check can be removed.  "}, {"title": "Gas: Unnecessary length check in `Swap.constructor`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Swap.constructor` checks if both arrays `_pooledTokens` and `decimals` are of length two, but then does another check if these arrays have the same length.  ```solidity require(     _pooledTokens.length == decimals.length,     \"_pooledTokens decimals mismatch\" ); ```  This check will always be true as it has been checked that both arrays are of length two.  "}, {"title": "Swaps are not split when trade crosses target price", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/216", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see `SwapUtils.determineA`. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.  However, the `SwapUtils.swap / _calculateSwap` function does not do this, it only uses the \"new A\", see `getYC` step 5.  ```solidity // 5. Check if we switched A's during the swap if (aNew == a){     // We have used the correct A     return y; } else {    // We have switched A's, do it again with the new A     return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d); } ```  ## Impact Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the _entire trade_. This can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.  In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.  ## Recommended Mitigation Steps Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.   "}, {"title": "`BasicSale` uses inaccurate `secondsPerDay` value", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/211", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `BasicSale` contract uses a `secondsPerDay` value of `84200` but one day has `86400` seconds.  ## Impact The `secondsPerDay` does not reflect seconds per day.  ## Recommended Mitigation Steps Change the value.  "}, {"title": "`BasicSale` has unused ERC20 code", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/210", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `BasicSale` contract includes ERC20 code like `_balances`, `_allowances` storage variables and `Transfer`, `Approval` events. This code is never used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "# Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/209", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `Swap.setAdminFee`: The `newAdminFee` should be validated the same way as in the constructor - `Swap.setSwapFee`: The `newSwapFee` should be validated the same way as in the constructor - `Swap.setDefaultWithdrawFee`: The `newWithdrawFee` should be validated the same way as in the constructor  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "Stop ramp target price would create huge arbitrage space.", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  # Stop ramp target price would create huge arbitrage space. ## Impact `stopRampTargetPrice` would set the `tokenPrecisionMultipliers` to `originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);` Once the `tokenPrecisionMultipliers` is changed, the price in the AMM pool would change. Arbitrager can sandwich `stopRampTargetPrice` to gain profit.  Assume the decision is made in the DAO, an attacker can set up the bot once the proposal to `stopRampTargetPrice` has passed. I consider this is a medium-risk issue.  ## Proof of Concept The `precisionMultiplier` is set here: [Swap.sol#L661-L666](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L661-L666)  We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python print(swap.functions.getVirtualPrice().call()) swap.functions.setPrecisionMultiplier(2).transact() print(swap.functions.getVirtualPrice().call())  # output log: #     1000000000000000000 #     1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is setup would create multiple issues. This function could be implemented in a safer way IMHO.  A quick fix I would come up with is to ramp the `tokenPrecisionMultipliers` as the `aPrecise` is ramped. As the `tokenPrecision` is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers.  Please refer to `_getAPreceise`'s implementation [SwapUtils.sol#L227-L250](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L227-L250)  "}, {"title": "SwapUtils's getD, getY, getYD functions do repetitive calculations of contant expression within the cycles", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  getD, getY, getYD functions calculate mul(d).div(xp[i].mul(numTokens) within the token cycles https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L538 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L588 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L861  d, numTokens are constant there, so the divisions are redundant.  ## Recommended Mitigation Steps  Introduce (d / numTokens) variable and simplify the multiplication  Now: uint256 c = d; ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d).div(xp[i].mul(numTokens));  To be: uint256 c = d; uint256 d_num = d.div(numTokens); ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d_num).div(xp[i]);  "}, {"title": "revoke() Does Not Check Zero Address for _addr", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/202", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact revoke() Does Not Check Zero Address for _addr  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104-L105  more...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Check _addr for Zero Address  "}, {"title": "SwapUtils.calculateTokenAmount does repetitive checks of static condition", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  SwapUtils.calculateTokenAmount's 'deposit' bool variable is checked on each iteration, while one check is enough https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1031  ## Recommended Mitigation Steps  It's recommended to separate the cycles:  Now: for (uint256 i = 0; i < numTokens; i++) {   if (deposit) {     balances1[i] = balances1[i].add(amounts[i]);   } else {     balances1[i] = balances1[i].sub(       amounts[i],       \"Cannot withdraw more than available\"     );   } }  To be: if (deposit) {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].add(amounts[i]);   } } else {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].sub(      amounts[i],      \"Cannot withdraw more than available\"    );   } }   "}, {"title": "SwapUtils's addLiquidity does multiple LP token total supply calls", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive external function calls  ## Proof of Concept  SwapUtils's addLiquidity function calls LP token totalSupply() several times: 6 code occurrences, one is in cycle. The very last occurrency should be kept as it is, the first 5 of them should be replaced with memory variable as the supply changes only once when LP mint() is called at the end of the function. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1163  ## Recommended Mitigation Steps  Code update:  Now: if (self.lpToken.totalSupply() != 0) { ...  To be: uint256 lpTotalSupply = self.lpToken.totalSupply(); // storage read and function call if (lpTotalSupply != 0) { ...  "}, {"title": "validate() to Verify Airdrop Address On Chain is Unnecessary", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact Verify Airdrop Address Holders On Chain by Spending Gas is Unnecessary and probably cost a lot after adding up everyone cost.  ## Recommended At UI Frontend, wallet eg. Metamask allow UI to Verify Address Holders Without Spending Any Gas.  "}, {"title": "SwapUtils.getVirtualPrice double calling to storage reading function _xp(self)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads  ## Proof of Concept  SwapUtils's getVirtualPrice repetitively calls _xp(self), which reads storage https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L705  ## Recommended Mitigation Steps  Now: uint256 a = determineA(self, _xp(self)); uint256 d = getD(_xp(self), a);  To be: uint256[] memory xP = _xp(self.balances, self.tokenPrecisionMultipliers); uint256 d = getD(xP, determineA(self, xP));  "}, {"title": "Multiple double storage reading _xp(self) function calls", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads and function calls  ## Proof of Concept  SwapUtils's removeLiquidityImbalance does multiple _xp(self) calls, which can be saved to memory when balances don't change inbetween executions https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1415  ## Recommended Mitigation Steps  Now: uint256[] memory balances1 = self.balances; v.preciseA = determineA(self, _xp(self)); v.d0 = getD(_xp(self), v.preciseA); ... v.d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1))); ... v.d2 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));  To be: uint256[] memory balances1 = self.balances; uint256[] memory tokenPM = self.tokenPrecisionMultipliers; // doesn't change, save and reuse uint256[] memory xP = _xp(balances1, tokenPM); // We already copied self.balances, no need to reread storage v.d0 = getD(xP, determineA(self, xP)); // v.preciseA isn't used elsewhere and can be dropped ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d1 = getD(xP, determineA(self, xP)); ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d2 = getD(xP, determineA(self, xP));  "}, {"title": "'From' and 'to' tokens are read from storage multiple times in SwapUtils's swap function", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent due to excessive storage reads  ## Proof of Concept  SwapUtils's swap: saving self.pooledTokens[tokenIndexFrom], which do not change, to memory and reusing will reduce gas costs. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1098  ## Recommended Mitigation Steps  Now: self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender)... ... uint256 beforeBalance = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)); self.pooledTokens[tokenIndexFrom].safeTransferFrom( ... uint256 transferredDx = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(beforeBalance); To be: IERC20 memory fromToken = self.pooledTokens[tokenIndexFrom]; fromToken.balanceOf(msg.sender)... ... uint256 beforeBalance = fromToken.balanceOf(address(this)); fromToken.safeTransferFrom( ... uint256 transferredDx = fromToken.balanceOf(address(this)).sub(beforeBalance);  "}, {"title": "Vesting.benVested storage variable can be simplified, while _claimableAmount's \"s <= benTotal[_addr]\" check is redundant and to be removed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  The only usage is in _claimableAmount function and can be rewritten with one uint256 storage variable. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L183 benVested cannot be used to get current state as it is updated only during claim() and revoke() calls and calcClaimableAmount() to be used instead.  The timelocks totals and benTotal cannot differ as timelocks are updated and deleted in vest() and revoke() functions only correspondingly, while there benTotal is updated with very same amount without any additional conditions. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L91 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L128  This way the 's <= benTotal[_addr]' check is redundant and to be removed.  ## Impact  's <= benTotal[_addr]' check can be dangerous: the totals and benTotal cannot differ, while if there would be such a possibility, various attacks might be possible, for example a griefing one, when claim() always fails because of this check, and so on.  I.e. now benVested can be simplified and check is not needed, while if there would be such a situation when it is needed, simple check as it is cannot be sufficient, and some code redesign should be done instead.  ## Recommended Mitigation Steps  Code update: Now: mapping(address => uint256[2]) public benVested; ... uint256 completely_vested = 0; uint256 partial_sum = 0; ... completely_vested = completely_vested.add(timelocks[_addr][i].amount); ... partial_sum = partial_sum.add(claimable); ... benVested[_addr][0] = benVested[_addr][0].add(completely_vested); benVested[_addr][1] = partial_sum; uint256 s = benVested[_addr][0].add(partial_sum); assert(s <= benTotal[_addr]); return s;  To be: mapping(address => uint256) public benVested; ... uint256 currently_vested = 0; ... currently_vested = currently_vested.add(timelocks[_addr][i].amount); ... currently_vested = currently_vested.add(claimable); ... uint256 s = benVested[_addr].add(currently_vested); benVested[_addr] = s; return s;  Also, cleaning in revoke() simplifies to benVested[_addr] = 0; https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L127  "}, {"title": "Get virtual price is not monotonically increasing ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact There's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.  There're two issues here: The meaning of `virtualPrice` would be vague. This may damage the lp providers as the protocol that adopts it may be hacked.  I consider this is a medium-risk issue.  ## Proof of Concept We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python     print(swap.functions.getVirtualPrice().call())     swap.functions.setPrecisionMultiplier(2).transact()     print(swap.functions.getVirtualPrice().call())  # output log: #   1000000000000000000 #   1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is set up would create multiple issues. This function could be implemented in a safer way IMHO.  The quick fix would be to remove the `getVirtualPrice` function. I can't come up with a safe way if other protocol wants to use this function.   "}, {"title": "`customPrecisionMultipliers` would be rounded to zero and break the pool", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/183", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact CustomPrecisionMultipliers are set in the constructor: ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18); ``` `originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.  If the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.  If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.  I consider this is a high-risk issue.   ## Proof of Concept Please refer to the implementation. [Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)  We can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18) ## Tools Used None ## Recommended Mitigation Steps I recommend providing extra 10**18 in both multipliers. ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);         customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18); ``` The customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.   "}, {"title": "Use bytes32 instead of string when possible", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.  An example is revert messages. For example look at line 32 of PublicSale.sol.  "}]