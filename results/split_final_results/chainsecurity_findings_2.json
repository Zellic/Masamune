[{"title": "6.4   Inputs for Triggering Settlement", "body": "  When the StableMaster contract triggers a settlement on the CollateralSettler contract it passes the current sanRate along. During this process any queued lockedInterests that were supposed to be added to the sanRate later are ignored. Hence, the sanRate is not entirely correct.  Risk Accepted:  Angle replied:  We decided to leave it as is. lockedInterests supposed to be added to the sanRate remain ignored. It could be a vector of attack to include these interests to SLPs. If trigger settlement was to be activated, then this means that governance failed to maintain the pool in a healthy way, and in this situation, interests should not be distributed to SLPs (we expect that there will also be fees aside)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Removing From Perpetual Potentially", "body": " Impossible  When a perpetual position develops well and its margin has significantly increased, users might decide to remove some of the margin through the removeFromCollateral function. However, if the amount of collateral to be removed exceeds the initially set margin, this removal is not allowed, even though it might not violate any of the system restrictions such as maximum leverage:  Angle - Angle Protocol -   15  CorrectnessLowVersion2RiskAcceptedDesignLowVersion2Acknowledged                \frequire(         ...         (amount < perpetual.margin) &&  Acknowledged:  Angle replied:  In fact the margin of a perpetual never increases if the perpetual develops well: the margin is the initial amount of collateral in the perpetual, and this does not evolve with price. If we allowed HAs to remove more than their margin in case of price increase, we would be back to the situation we had before your audit where we also update the oracle value, and what we called the cashOutAmount at each perpetual update. For the HA to get more collateral than the margin, position should be cashed out  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Sandwich Attacks Against harvest", "body": " Invocations  The harvest functions of certain strategies, e.g., GenericAave, are susceptible to sandwich attacks. As these harvest functions can be called by anyone and perform a token sale, the following attack is possible:   An attacker contract manipulates the relevant Uniswap pools   That attacker contract calls the harvest function of one of the strategies, which triggers a Uniswap  trade   The attacker contract arbitrages the Uniswap pools to benefit from the previous trade  In the currently present strategies, such attacks are limited to the reward tokens.  Risk accepted:  Angle replied:  We forked these strategies from Yearn, we have hence decided to keep it as is, and we are aware of this risk. It is important to note that to mitigate such attacks, however costly it is, the harvest function needs to be called pretty regularly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   HA Fees May Exceed 100%", "body": "  There are no limitations for the values of haBonusMalusDeposit or haBonusMalusWithdraw. These can  be  set  arbitrarily  by  the  Guardian  /  Governor  in  the  FeeManager  and  are  later  propagated  to  the PerpetualManager.  Inside the PerpetualManager, the fee for HAWithdraw is calculated as follows:  haFeesWithdraw = (haFeesWithdraw * haBonusMalusWithdraw) / BASE; return (amount * (BASE - haFeesWithdraw)) / BASE;  Angle - Angle Protocol -   16  SecurityLowVersion2RiskAcceptedDesignLowVersion1RiskAccepted                \fIn case haFeesWithdraw exceeds BASE the transaction will revert and the withdrawal is blocked. The same applies for HADeposit accordingly.  Risk accepted:  Angle replied:  No specific change has been made for that, if this situation happens, then the transaction will fail anyway and there is no need to add a require for that.  We thought of adding a require in the setters of the fees to make sure that fees will never be able to be bigger than 100% (especially for users minting/burning fees), but we decided not to do it. The reason is that our fees are of the form f(x)g(y), with 0 <= f(x) <= 1.  Therefore it may happen that for some value of the y parameters, you have g(y) > 1, and for some couples (x,y), you have f(x)g(y)>1. We do not want to enforce that the product is always <1.  In our case, the evolution of the bonusMalus (depending on the collateral ratio for users) and the evolution of the fees computed using the coverage curve are different. It is possible that the product in the max element in the array yBonusMalusMint and in the array yFeeMint are superior to BASE but that this situation is never observed in practice because the evolution of the collateral ratio is not correlated to the evolution of the coverage curve.  Governance will still have to be wary and to make sure when setting these parameters that even though a situation where  f(x) g(y)>1 can happen in theory, it will never happen in practice.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Small Perpetual Position, Too Low Keeper", "body": " Incentive  The system enforces no minimum amount for a perpetual position and corresponding minimum fee paid. The  reward  /  incentive  for  a  keeper  to  liquidate  a  perpetual  that  meets  the  condition  to  be  liquidated respectively to be forcefully cashed out is a part of fees paid by this perpetual.  The  incentive  for  keepers  must  at  least  cover  their  transaction  costs.  As  no  minimum  amount  for  a perpetual (hence keeper fee) is enforced, perpetuals bringing a small amount of collateral to the system and hence paying a small fee may not be liquidated as the reward exceeds the keeper's transaction fees.  Risk accepted:  Angle replied:  Although we slightly changed the keeper incentives (as a portion of the cashOutAmount at the time the perpetual is cashed out), we decided not to have a minimum position or a minimum incentive for keeper. If the incentives are too low, we will do it ourselves, even if it implies loosing money on it. Another thing we think about implementing is an off-chain reward mechanism based on on-chain verifiable data. This way we/our community could reward keepers which performed actions for which they did not make a profit but that were still helpful for the protocol. We could also upgrade our smart contracts to arrive to the solution you propose (minimum incentive for keeper coupled with a minimum position - you cannot do one without the other otherwise you may be subject to attacks).  Angle - Angle Protocol -   17  SecurityLowVersion1RiskAccepted          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  4  15  32  -Severity Findings  -Severity Findings   Burning AgTokens in BondingCurve Does Not Update stocksUsers    Collecting Keeper Fees, Closing Perpetuals   Incorrect Maximum Collateral Amount    Untracked Bad Debt / System Health   -Severity Findings   Everybody Can Pause Pools   Incorrect Check During removeFromPerpetual   Incorrect Handling of profitFactor    Potentially Incorrect Strategy Report    Reentrancy When Creating Perpetual Position    Adding to Unhealthy Perpetual Liquidates and Consumes New Collateral    Broken/Partial ERC165 Support    Conversion of Locked Interest to SanRate in the Same Block*    Governance Not Fully Propagated    Guardian Cannot Be Managed by Guardian   Incorrect Cash Out Amount    Non 18 Decimals Protocol Tokens    Unaccounted Collateral, Unrestricted updateStocksUsersGov()    Unit Errors for Tokens With Decimals Different Than 18    safeApprove Not Used, USDT Not Supported   -Severity Findings   BondingCurve Specification Mismatches    Gas-inefficient Strategies   Inefficiency in Binary Search    No Slippage Protection in BondingCurve    Reference Coin Changes May Affect the Bonding Curve    Specification Mismatch in Strategy    StableMaster Might Be Unnecessarily Paused    Cache Value Instead of Reading From Storage    Consistency Checks for Oracles Missing   Angle - Angle Protocol -   18  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrected     \f Different Calculation of Cashout Fees    Double Getters    Enhance Check During Deployment of Collateral    Events Missing    Gas Inefficiencies When Removing From List    Gas Inefficiencies When Searching Lists    Governance Changes   Inconsistencies Between Staking Contract   Inconsistent Parameters in RewardsDistributor Possible   Incorrect Comment   Inefficient Structs    No Check if onERC721Received Is Implemented    No Checks Performed in Constructor    Outdated Compiler Version    Overhead Due to Loading Struct Into Memory    Possibly Failing Assert    Potential Confusing readLower(uint256 lower)    Reward Token Issues    Specification Mismatch in OracleMath    Unnecessary Double Checks    Updated SanRate When Converting to SLP    Wrong Incentive for Which Perpetuals to Forcefully Cash Out    capOnStablecoin May Be Violated by Guardians   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Burning AgTokens in BondingCurve Does Not", "body": " Update stocksUsers  The BondingCurve contract allows users to buy tokens (most likely Angle tokens). To receive tokens from the  BondingCurve,  AgTokens  get  burned  according  to  the  bonding  curve  price.  This  may  significantly reduce  the  amount  of  AgTokens  minted  and  improve  the  protocol  health.  However,  no  stocksUsers variable  is  updated.  Several  issues  may  arise  regarding  such  accounting  issues.  For  example,  the coverage  ratio  of  the  protocol  may  be  much  higher  than  the  one  indicated  and  the  system  create  bad debt through that mismatch.  Note that regular burn operations also do not update the stocksUsers variable.    When  buying  tokens  the  AgTokens  are  transferred  to  the  bonding  curve  contract  and  not  burned. and Governance   BondingCurve.recoverERC20   functions   make   use   can   of   Angle - Angle Protocol -   19  CodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedAcknowledgedCodeCorrectedCorrectnessHighVersion2CodeCorrected              \fAgToken.burnNoRedeem which calls StableMaster.updateStocksUsers to transfer AgTokens to itself and burn them while updating the stocks users for a specified pool manager.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Collecting Keeper Fees, Closing Perpetuals", "body": "  Should  the  maximum  covered  amount  of  collateral  be  exceeded,  anyone  can  forcefully  cash  out  any perpetual  in  order  to  bring  the  amount  of  covered  collateral  back  below  the  limit.  However  this  can  be abused as one can manipulate the amount of collateral to be covered.  Assume a working StableMaster issuing AgUSD with several collateral pools like USDC, DAI and WETH. There is a decent amount of liquidity provided by standard liquidity providers and the coverage ratio of the pools is around 80% with a limit at 90%. Many perpetuals of different sizes exist. An arbitrary attacker can now do the following:  1. Either the Attacker has funds available or borrows them using a flashloan  2. These funds are exchanged into AgUSD on a third party exchange  3. These AgUSD are now burned for the collateral under attack.  4. Burning  the  AgUSD  tokens  increases  the  collateralization  ratio  for  this  collateral  as  collateral  is  withdrawn. The attacker does this at least until the coverage limit is exceeded.  5. The attacker is now able to forcefully cash out perpetuals until the amount covered is below the limit.  While forcefully cashing out perpetuals the attacker collects the fees.  6. Pay back the flashloan using the collateral.  This  attack  is  profitable  when  the  transaction,  flashloan  and  burn  fees  are  below  the  keeper  reward collected for closed perpetuals. As keeper fees for each perpetual have to cover for the transaction base fees (as they may have to be closed individually by keepers due to reaching the cashout leverage) the collected  rewards  likely  exceed  the  fees  when  the  attacker  manages  to  forcefully  cash  out  multiple perpetuals during this action.    The  new  fee  structure  rewards  keepers  reaching  the  targeted  coverage  ratio.  Moreover,  the  keeper reward  is  capped  such  that  the  profit  of  the  keeper  is  lower  than  the  estimated  cost  of  the  flash  loan needed for such an attack. For more information see the description of System Accounting.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Incorrect Maximum Collateral Amount", "body": "  The  function  _testMaxCAmount  computes  the  \"Maximum  amount  of  collateral  that  can  be  insured\". This is computed as follows:  1. The stocksUsers variable is queried from the StableMaster contract.  2. The amount of minted stable coins is queried from the StableMaster contract and converted into  a collateral amount using the current rate.  3. The smaller of the two values above is multiplied with maxALock (the maximum percentage to be  insured) and then returned.  Both of these values are sometimes incorrect and hence shouldn't be used for the calculation:  1. stocksUsers is defined as:  Angle - Angle Protocol -   20  SecurityHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                \f// Amount of collateral in the reserves that comes from users // + capital losses from HAs - capital gains of HAs  Due to the capital losses and capital gains it might be bigger or smaller than needed for the present calculation. Consider the following example:  After  a  late  liquidation  stocksUsers  =  15  ETH,  with  a  rate  of  500,  but  previously  10,000  stable coins have been minted. The system needs to insure 20 ETH, but would return 15 ETH * maxALock.  2. The amount of minted stable coins can only be used for this calculation if only a single collateral is used for this stable coin. However, multiple collaterals might be available to mint this stable coin and hence the system would calculate an incorrect amount of insurable collateral.    Now,  the  stocksUsers  variable  represents  the  amount  of  stablecoins  minted  per  collateral  and  the system  separates  the  stable  coins  minted  against  different  collaterals.  For  more  information  see  the description of System Accounting.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Untracked Bad Debt / System Health", "body": "  A  stablemarket  attempts  to  keep  the  equilibrium  between  the  positions  of  stable  seekers  and  hedging agents. At times the attempt to keep the equilibrium may not be successful:   Should they price of a collateral decrease too fast and keepers can't or don't forcefully cash out bad perpetuals in time, the situation arises where the collateral put up by the perpetual evaluated at the current rate can no longer cover its committed amount at the rate the perpetual has been created. In this case the perpetual is liquidated leaving bad debt to the system.  Should the collateral of the stablecoin not be fully covered at all times (This means the collateral brought by stable seekers equals the amount covered by the hedging agents), 2 kinds of bad debt can occur:   Coverage of the collateral is less than 100% and the price of the collateral decreases from x to y:  For the uncovered collateral stablecoins have been minted a the higher collateral price x. Now the value of the collateral dropped to y. The minted stablecoins are now only partially covered by the value of the collateral. Note that should a new Hedging Agent now enter the system and covers some more of the collateral, this is done at the current exchange rate, not the rate used to mint the stablecoin. At this point the virtual loss of the system is converted into actual bad debt of the system.  Vice versa, should the price of uncovered collateral increase the system makes a profit.   Coverage of the collateral is more than 100% and the price of a collateral increases.  (Note that this cannot happen if maxALock is set to less than 100%)  Here profits made by Hedging Agents would exceed the increase in value of the collateral held by the system to back the minted stablecoins. This loss is taken by the system.  Overall  bad  debt  is  neither  tracked  nor  handled  otherwise.  If  possible  it  could  be  accounted  for  and compared with what is currently called \"system surplus\" which includes the fees collected and other gains made by the system.  No  functionality  to  query  the  health  of  the  system  exist.  Such  information  however  is  vital  for  all  users investing funds into the system.  Angle - Angle Protocol -   21  DesignHighVersion1CodeCorrected        \f  The  new  stocksUsers  enables  to  keep  better  track  of  the  current  system  health  and  the  bad  debt. However, these computations need to be performed off-chain, e.g., in the front-end. For more information see the description of System Accounting.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Everybody Can Pause Pools", "body": "  In the second version of the code, a pool will be paused, if during a user's burn, the amount of AgTokens to  be  burned  is  higher  than  the  stocks  users  of  the  collateral.  However,  there  is  no  check  whether  the user  actually  owns  the  necessary  amount  of  AgTokens.  Thus,  any  user  can  specify  a  high  amount  to burn  to  pause  the  contract.  The  pool  will  remain  paused  until  the  governance  unpauses  this  change. Malicious parties could act as follows:   Stableholders: In case of expected collateral price drop can pause to make HAs and SLPs lose.   SLPs: A SLP providing much liquidity in a state with much HA capital could pause the contract to  keep other SLPs from entering the protocol so that his profit is maximized.   HAs:  HAs  can  front-run  liquidations  and  force-cashouts  by  pausing  the  contract.  Ultimately,  that  could lead to a highly unbalanced state.  In  conclusion,  anybody  can  pause  the  protocol  at  any  time.  Such  actions  could  be  profitable  for  the parties and could throw the system into an unhealthy state if they are executed repeatedly.    When  the  amount  of  AgTokens  burned  exceeds  the  stocksUsers,  the  transaction  reverts  instead  of pausing the contracts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Incorrect Check During ", "body": " removeFromPerpetual  The function removeFromPerpetual contains the following check:  // Withdrawing collateral should not make the leverage of the perpetual too important perpetual.committedAmount * BASE_PARAMS <= (perpetual.margin - amount) * maxLeverage,  The  maxLeverage  check  is  performed  based  on  perpetual.margin  -  amount,  however,  in  case the  cashOutAmount  <  perpetual.margin  then  this  check  underestimates  the  actual  leverage. Hence, a perpetual above the leverage limit might go undetected.    Now, an additional check was added to ensure that the new cashout amount is not exceeded.  Angle - Angle Protocol -   22  DesignMediumVersion2CodeCorrectedDesignMediumVersion2CodeCorrected                  \f7.7   Incorrect Handling of profitFactor  The  profit  factor  serves  to  reduce  the  profit  keepers  can  make  from  calling  harvest.  Thus,  following condition occurs:  profitFactor * rewardAmount < want.balanceOf(address(this)) + profit  This condition needs to be fulfilled for a reward payment to be made and is hence quite important.  Incorrectly, the condition is unaware of the decimals of the tokens since profitFactor is initialized to be 100 for any pair. Moreover, it is unaware of the prices of the tokens.  The decimal unawareness may cause the following behaviour:   Assume  the  reward  token  is  USDC  (6  decimals)  and  the  want  token  is  DAI  (18  decimals).  The condition  will  almost  always  pass  since  profit  factor  does  not  account  for  the  base  differences between the tokens.   Assume the reward token is DAI (18 decimals) and the want token is USDC (6 decimals). Then, this condition  will  almost  never  pass  to  since  the  reward  amount  will  already  be  much  larger  than  the right-hand-side.  The price unawareness may cause the following behaviour:   Assume the reward token is AgEUR and one strategy's want token is DAI while for the second one the want token is WETH. If now both strategies have similar balances and profits (when converted to USD), they will still be treated very differently.  To  conclude,  inconsistencies  in  the  keeper  reward  payouts  between  strategies  could  occur  since  the above condition is unaware of the decimal representation and prices of the tokens.    profitFactor  has  been  removed.  Now,  a  minimum  amount  minimumAmountMoved  denotes  how much needs to be at least in the contract plus the profits. Also, this amount and the reward amount are set jointly now to prevent errors.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Potentially Incorrect Strategy Report", "body": "  Calling the harvest function on a strategy contract may result in a bad report to the pool manager. If the reward  token  the  keepers  receive  is  equal  to  the  want  token  of  the  strategy,  then  the  transfer  to  the keeper can be successful even though no specific allocation of funds to the strategy for the rewards was made.  Incorrectly,  the  keeper's  fee  will  still  be  part  of  the  reported  profit  as  the  profit  is  computed beforehand and not adjusted.    In the constructor of the strategy it checked that want and reward token are not the same.  Angle - Angle Protocol -   23  CorrectnessMediumVersion2CodeCorrectedCorrectnessMediumVersion2CodeCorrected                \f7.9   Reentrancy When Creating Perpetual Position  When creating a new perpetual position there is a possibility for a reentrancy attack. During the mint() operation of the token a callback is triggered that can be used for a reentrancy attack.  Among other things, possible consequences of such an attack could be:  that the coverage exceeds the expected values  that a non-liquidatable perpetual exists  that a mismatch between NFTs and positions exists    The call to _mint() is done after all state changes.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.10   Adding to Unhealthy Perpetual Liquidates", "body": " and Consumes New Collateral  addToPerpetual() allows a hedging agent to increase the cash out amount of the perpetual. Should a hedging agent attempt to add collateral to an unhealthy perpetual, the perpetual is liquidated while the collateral  amount  intended  to  increase  the  position  is  transferred  to  the  pool  manager  contract  without being accounted for.  Unaware  users  are  at  risk,  especially  as  a  hedging  agent  may  attempt  to  increase  the  collateral  of  a position which is just short of being liquidated. Any oracle update now may change the situation and the perpetual can be liquidated while the hedging agent loses his added collateral to the pool manager.    Attempting to add collateral to an unhealthy perpetual results in the perpetual being liquidated, which is intended. In this case, the new collateral amount however is no longer transferred to the pool manager in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.11   Broken/Partial ERC165 Support", "body": "  Through inheritance, mostly when inheriting AccessControl or AccessControlUpgradable multiple contracts inherit ERC165.  This contract implements the ERC165 standard which defines a standard method to publish and detect what interfaces a smart contract implements.  function supportsInterface(bytes4 interfaceID) external view returns (bool);  The more derived contracts of Angle with the exception of the PerpetualManager contract, that does it partially,  do  not  expand  or  overwrite  this  function.  Hence,  their  functionality  is  not  included  and supportedInterface() will not return true for the public/external functions they implement.  Angle - Angle Protocol -   24  SecurityMediumVersion2CodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                         \fEither the more derived contracts should implement this function in order to make complete the ERC165 functionality  or  if  this  is  not  required,  overwrite  supportsInterface()  with  an  empty  function  which would even slightly reduce the contract's code size.    Angle  forked  the  code  of  AccessControl  and  AccessControlUpgradaeable  and  removed  the ERC165 support. The only contract which implements the ERC165 interface is the PerpetualManager as it emits the perpetual futures as ERC721-NFTs. The supportsInterface function will return true for all interfaces it implements.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.12   Conversion of Locked Interest to SanRate in", "body": " the Same Block*  *While the review was ongoing Angle informed us about this issue independently in parallel.  _updateSanRate() consists of two parts: In the first half the locked interest accrued in previous blocks are added to the sanRate while in the second part the new amount of tokens to be distributed are added to the locked interests. These should be distributed in the next block this function is executed.  lastBlockUpdated however is only updated if some of the locked interest where added to the sanRate in this block.  This leads to following corner case when _updateSanRate() is executed: In case there are no locked interest to distribute, lastBlockUpdated is not updated to the current block.timestamp but rewards to be distributed are added to lockedInterests. However a second call to _updateSanRate() will now convert these lockedInterests and add them to the sanRate before updating lastBlockUpdated blocking a future update in this same block.  The  sanRate  is  updated  upon  collection  of  profit  from  strategies  or  when  a  part  of  the  fees  for  stable seeker is distributed to standard liquidity provider.  The profit from strategies can be attacked as follows:  At a time where lockedInterests is equal to zero and a strategy has a significant amount of rewards to collect, the attacker executes the following steps:   Deposits  a  large  amount  of  collateral  (e.g.  acquired  through  a  flashloan)  for  San  Tokens.  While updateSanRate()  is  called,  this  currently  has  no  effect  as  lockedInterests  is  equal  to  zero and the amount to distribute is 0, so lockedInterests remains zero.   Call  harvest()  on  the  Strategy.  This  collects  the  profit  and  executes  _updateSanRate().  As currently  no  locked  interests  are  to  be  distributed,  the  first  part  is  skipped  and  lastBlockUpdated` remains unchanged. In the second part the  lockedInterests to be distributed in the future are updated.   Withdraw  the  collateral  by  burning  the  san  tokens.  _updateSanRate()  is  executed  once  again, this  times  with  lockedInterests  being  nonzero  the  sanRate  is  now  actually  updated  and lastBlockUpdated is set to the current block. Hence the user can withdraw more collateral than deposited.  This may be abused to drain the profit of the strategy.  Note that this is a rough description only and the actual execution of this attack is a bit more complicated: In order to extract most of the protocols interest more calls will be needed than described above. As the initial deposit() by the attacker will have significantly increased the amount of total assets available to  Angle - Angle Protocol -   25  SecurityMediumVersion1CodeCorrected        \fthe PoolManager, the PoolManager will push a lot of funds into the strategy during the call to report (in order  to  keep  the  planned  debtRatio).  Hence  the  withdraw()  cannot  really  withdraw  sufficient amounts. Multiple calls with carefully crafted arguments to withdraw() and harvest() are necessary to complete the attack successfully and repay the flashloan.    lastBlockUpdated is now updated each time updateSanRate() is executed, this prevents the issue described above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.13   Governance Not Fully Propagated", "body": "  The documentation specifies the following:  The Core contract has the ability to add a new governor or remove a governor from the system and propagate this change across all underlying contracts of the protocol.  Similarly, the Core contract should propagate guardian changes. However, that is not the case for some contracts.  For  example,  the  changes  are  not  propagated  to  OracleMulti  or  RewardsDistributor.  That mismatches  the  specification.  Fortunately,  the  governance  can  use  functions  grantRole()  and revokeRole() to perform the changes jointly with the functions from Core.  Specification changed:  The documentation has been updated and now describes how the governance change propagates from the Stablemaster. Additionally the code of the core contract now contains following comment:  Keeps track of all the StableMaster contracts and facilitates governance by allowing the propagation include  oracle  contract, of  changes  across  most  contracts  of  RewardsDistributor, and some  the  protocol   (does  not   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.14   Guardian Cannot Be Managed by Guardian", "body": "  The documentation specifies the following:  The guardian is indeed able to transfer its power to another address or to revoke itself.  However,  that  is  not  possible.  Core  functions  setGuardian  and  revokeGuardian  call  the  inherited grantRole() and revokeRole(). The administrator of the guardian role is the governor role. Thus, the calls grantRole() and revokeRole() would fail since the guardian is not allowed to access these and the guardian cannot set or revoke guardians.    Access control has been reimplemented. In the new implementation the guardian can transfer its power to another address or revoke itself.  Angle - Angle Protocol -   26  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                  \f7.15   Incorrect Cash Out Amount  Existing  perpetual  positions  can  be  updated.  Any  perpetual  position  that  is  modified  through addToPerpetual or removeFromPerpetual results in the wrong cashOutAmount. Please consider the following example in which all transactions happen shortly after each other. Hence, we assume that the oracle prices do not change and are 1000 and 1125 respectively. Please note that changing oracle prices can make the problem worse. We will also ignore fees in this example.  1. A new position is created and its cashOutAmount = 10 ETH, while committedAmount = 20 ETH.  The initialRate = 1125.  2. The  position  is  updated  through  addToPerpetual  and  1  ETH  is  added.  The  new  committed amount  is  calculated  as  20  ETH  *  1125  /  1000  =  22.5  ETH.  Hence  the  new  cashOutAmount  is calculated as 20 ETH + 10 ETH - 22.5 ETH + 1 ETH = 8.5 ETH. The initialRate remains 1125.  3. The  user  performs  a  cash  out  using  cashOutPerpetual.  The  newly  committed  amount  is calculated as 20 ETH * 1125 / 1000 = 22.5 ETH. Hence the new cashOutAmount is calculated as 20 ETH + 8.5 ETH - 22.5 ETH = 6 ETH. Therefore, the user receives 6 ETH, despite depositing 11 ETH.  In short, whenever the oracle rates significantly deviate from each other, users can lose significant value. This issue can grow in severity with fees, repetitive operations and price fluctuations.    This issue has been addressed by only storing the initial rate. Hence, errors can no longer accumulate with the number of actions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.16   Non 18 Decimals Protocol Tokens", "body": "  The documentation states:  Decimals  To be consistent with the BASE chosen when computing numbers, it has been decided that all the ERC20 tokens created by the Angle protocol would involve 18 decimals.  Although this is not specified anywhere in the code, this means that the base for agTokens and sanTokens is 18.  The  decimal  of  the  sanToken  however  is  set  equal  to  the  decimal  of  the  underlying  collateral.  For collaterals with decimals different than 18, the sanTokens decimal will not be equal to 18.  function initialize(     string memory name_,     string memory symbol_,     address poolManager ) public initializer {     __ERC20Permit_init(name_);     __ERC20_init(name_, symbol_);     stableMaster = IPoolManager(poolManager).stableMaster();     decimal = IERC20MetadataUpgradeable(IPoolManager(poolManager).token()).decimals(); }  Angle - Angle Protocol -   27  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged              \fSpecification changed:  The developer documentation will be changed to accurately reflect this.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.17   Unaccounted Collateral, Unrestricted ", "body": " updateStocksUsersGov()  Function updateStocksUsersGov of a stablemaster contract allows the Guardian / the Governance to update col.stocksUsers arbitrarily. There are no checks at all, e.g. whether the update respects the actual amount of free collateral available.  This variable is described as:  // Amount of collateral in the reserves that comes from users // + capital losses from HAs - capital gains of HAs  While  col.stocksUsers  is  updated  as  described  during  the  actions  of  stable  seekers  and  hedging agents an additional function updateStocksUsersGov exists allowing the Guardian / the Governance to change this variable arbitrarily.  Amongst others, this function is annotated with  Updates the `stocksUsers` for a given collateral to allow or prevent HAs from coming in This function can typically be used if there is some surplus that can be put in `stocksUsers`.  The system surplus arises due to the fees collected by the system. When minting or burning stablecoin only a part of the fee collected is incorporated into the sanrate. The rest remains as surplus collateral in the  poolmaster  contract.  When  creating  or  cashing  out  a  perpetual  a  fee  is  taken.  This  fee  collected resides in form of unaccounted for collateral at the poolmaster. A part of the fee must be set aside while the perpetual is active as it may be needed to pay the keeper slashing this perpetual.  Note that not all balance of the collateral token held by the poolmaster is available to use freely. Some of this balance may belong to standard liquidity providers.  Overall  there  is  no  automatic  accounting  of  the  fees  collected,  the  system  rather  relies  on  a  manual update where the caller can freely specify the parameter. The description of the function hints that the function  may  be  used  to  steer  whether  to  allow/prevent  more  HAs  from  coming  in.  Note  this  can  also steer  whether  perpetual  can  be  cashed  out  forcefully.  Allowing  the  update  of  this  value  without  any checks may let the system reach an incorrect state.    The  function  name  was  changed  to  rebalanceStocksUsers.  It  reduces  the  stocksUsers  of  one collateral and adds it to another one. However, the cap for the maximum stocks users value cannot be exceeded with this operation. Hence, the number of stablecoins minted in total stays the same. For more information see the description of System Accounting.  Angle - Angle Protocol -   28  CorrectnessMediumVersion1CodeCorrected          \f7.18   Unit Errors for Tokens With Decimals Different Than 18  Perpetuals  earn  a  reward  in  form  of  governance  tokens.  Additionally  the  staking  contract  may  allow AgToken and SanToken to be staked in order to earn governance tokens. For both, the calculation of the reward does not work correctly for collaterals with decimals different than 18.  Using the example of the PerpetualManager, the reward per committed collateral token of the perpetual is calculated as follows:  function _rewardPerToken() internal view returns (uint256) {     if (totalCAmount == 0) {         return rewardPerTokenStored;     }     return         rewardPerTokenStored + ((_lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * BASE) / totalCAmount; }  and  function _earned(uint256 perpetualID) internal view returns (uint256) {     return         (perpetualData[perpetualID].committedAmount *             (_rewardPerToken() - perpetualRewardPerTokenPaid[perpetualID])) /         BASE +         rewards[perpetualID]; }  The  governance  token,  the  angle  token  has  18  decimals.  Hence  rewardPerTokenStored  and  the returned value of _rewardPerToken() should be in 18 decimals as well for the calculation in _earn() to work correctly.  In  both  calculations  however,  BASE  is  used  as  unit  instead  of  the  actual  base  of  the  collateral.  As  a consequence, the calculation breaks for tokens not having 18 decimals.    Now, the calculations are done correctly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.19   safeApprove Not Used, USDT Not", "body": " Supported  some   Since not all ERC-20 tokens adhere to the standard, it is recommended to use safeApprove such that interactions with a broader range of tokens are possible. Especially, this is important since interactions with  function _changeTokenApprovalAmount  in  PoolManagerInternal.sol  a  simple  approve  call  is  made  with regards to the underlying pool tokens. As this method is used during the deployment of some collateral to give  infinite  approval  to  the  perpetual  manager  and  the  stable  master,  this  means  that  USDT  pools cannot be deployed.  safeApprove.   However,   tokens,   require   USDT,   e.g.   in     Angle - Angle Protocol -   29  CorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected              \fThe new version of the code now uses either safeApprove or safeIncreaseAllowance.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.20   BondingCurve Specification Mismatches", "body": "  There  are  several  mismatches  between  the  implementation  of  BondingCurve  and  its  documentation. Examples are:   The power parameter is fixed in the implementation. However, it is not stored anywhere but instead the  formulas  have  been  implemented  assuming  power  to  be  two.  In  contrast,  the  specification states only that power should be strictly greater than one.   The documentation specifies that the guardian should have the same powers as the governors with  the exception of recovering tokens.   Moreover, the code is divided in different sections. changeOracle() is in the guardian role section. Both documentation and code structuring imply that this function should be callable by the guardian. However, only governors can call this function.  The inconsistencies may confuse users.    The specification has changed for the power parameter while the code has been corrected to restrict the guardian's power.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.21   Gas-inefficient Strategies", "body": "  The gas consumption of the strategies could reduced by reducing the storage reads. Some examples of inefficiencies in the strategies are:   _estimateAdjustPosition: the element with the highest and the element with the lowest APR are searched. The code iterates through the lenders array twice and always reads from storage. Storage reads could be reduce by a factor of two.   _removeLender: lenders[i] is read first in the if condition and then in the first line of the if  body.   _withdrawSome: in the while loop the for loop reads always from storage, hence wasting gas.    Gas consumption has been reduced for the functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.22   Inefficiency in Binary Search", "body": "  The binary search within the _piecewiseLinear function works as follows:  Angle - Angle Protocol -   30  CorrectnessLowVersion2CodeCorrectedDesignLowVersion2CodeCorrectedDesignLowVersion2CodeCorrected                        \fuint256 lower; uint256 upper = xArray.length - 1; uint256 mid = (upper - lower) / 2; while (upper - lower > 1) {     if (xArray[mid] <= x) {         lower = mid;     } else {         upper = mid;     }     mid = lower + (upper - lower) / 2; }  Here the following improvements can be made:  1. The  initial  value  of  mid  is  computed  using  the  wrong  formula  as  the  computation  should  read upper  +  lower  rather  than  upper  -  lower.  However,  it  doesn't  matter  in  the  current  code version  as  lower  is  always  initialized  to  0.  Hence,  it  is  unclear  why  lower  is  part  of  this computation.  2. The value of mid is needlessly computed once at the end of the loop. This could be refactored to  save a computation of mid.  The  gas  savings  of  these  improvements  are  negligible,  however,  they  might  contribute  to  more maintainable code.    The code is now more gas-efficient.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.23   No Slippage Protection in BondingCurve", "body": "  The  BondingCurve  contract  allows  the  purchase  of  governance  tokens  (most  likely  Angle  tokens)  in exchange for other tokens. However, the function buySoldToken does not protect users from growing prices.  The  user  could  experience  an  unexpectedly  trade  result  if  they  have  given  a  high  or  infinite approval to the BondingCurve contract.    Users  can  now  specify  the  maximum  amount  of  AgTokens  they  are  willing  to  pay  for  the  specified amount of ANGLE tokens.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.24   Reference Coin Changes May Affect the", "body": " Bonding Curve  The BondingCurve contract contains a referenceCoin variable. This referenceCoin can be set to the zero-address by being revoked. This may affect the BondingCurve in several ways:   getCurrentPrice()  will  return  the  price  in  the  reference  coin.  However,  there  is  no  reference  coin.  Angle - Angle Protocol -   31  SecurityLowVersion2CodeCorrectedCorrectnessLowVersion2CodeCorrected                \f buySoldToken() will take the oracle value based on the previous stablecoin. However, having the  0-address suggests that the reference price is currently to be determined.  Similar issues may occur if the referenceCoin is set then to another token. Now, if the oracles are not updated,  the  price  will  differentiate  highly  from  what  governance  would  have  expected.  Also,  the startPrice  variable  is  in  the  currency  of  the  reference  token.  Thus,  it  could  be  possible  that  the bonding curve changes if the start price stays the same when the reference currency changes.    The contract will be paused to give the governance time to change the parameters.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.25   Specification Mismatch in Strategy", "body": "  The documentation of rewardAmount specifies in Strategy.sol:  /// @dev If this is null rewards will never be distributed  In contrast, the documentation of setRewardAmount in Strategy.sol specifies:  /// @dev A null reward amount corresponds to reward distribution being activated  However,  if  the  reward  amount  is  null,  then  the  rewards  can  be  eventually  distributed  if  the  reward amount  is  changed.  Moreover,  the  reward  amount  being  null  means  that  the  reward  distribution  is deactivated.  Specification changed:  The specification has been changed to correctly specify the reward amount.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.26   StableMaster Might Be Unnecessarily", "body": " Paused  When  the  signalLoss  function  registers  a  loss  exceeding  sanRate  *  sanMint  it  will  pause  the StableMaster contract. However, during this calculation it does not consider any lockedInterests that  were  queued  to  increase  the  sanRate.  Hence,  when  factoring  in  the  correct  sanRate  pausing might not be necessary.    The code has been corrected.  Angle - Angle Protocol -   32  CorrectnessLowVersion2Speci\ufb01cationChangedCorrectnessLowVersion2CodeCorrected                  \f7.27   Cache Value Instead of Reading From Storage  In function update of the PerpetualManager, perpetual.fees is first updated and later read from storage in order be emitted in the event.  Caching the value would result in lower gas used.    Function _update has been removed from the PerpetualManagerInternal contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.28   Consistency Checks for Oracles Missing", "body": "  ModuleChainlinkMulti  checks  whether  circuitChainlink  and  circuitChainlinkIsMultiplied have  the  same  length.  In  contrast,  ModuleUniswapMulti  does  not  check  this  property  for  Uniswap circuits.    The check was added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.29   Different Calculation of Cashout Fees", "body": "  Should the coverage of a collateral exceed the limit, the fees for withdrawal differ depending on whether the perpetual is cashed out using forceCashOutPerpetual() or cashOutPerpetual():  In forceCashOutPerpetual() the withdrawal fee is computed with a margin of 0 (representing the status before the cashout of this perpetual).  In  cashOutPerpetual()  the  withdrawal  fee  is  computed  based  on  the  new  margin  calculated after the perpetual has been cashed out.    The  structure  of  the  two  functions  has  been  changed.  Both  initially  cashout  the  perpetual  and  then compute the withdrawal fee.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.30   Double Getters", "body": "  Angle - Angle Protocol -   33  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                \fIn  Core.sol,  governorList()  can  be  accessed  through  the  automatically  generated  governorList getter and through the manually implemented getGovernorList(). Having only one getter will reduce code size, gas consumption on deployment, and confusion.  In OracleAbstract.sol, inBase has two getters: the automatically generated one and getInBase().    governorList was made internal and getInBase() was removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.31   Enhance Check During Deployment of", "body": " Collateral  deployCollateral()  of  the  StableMaster  contract  checks  that  the  passed  arguments  are  non-zero address before the struct for the collateral is initialized.  Some of these checks may be made more thorough with low effort:  It may be checked whether the collateral token of the perpetual manager matches the collateral.  Furthermore, it is possible to create a shared SanToken for multiple pool managers which may lead to unwanted behaviour. Also the number of decimals of the SanToken is not checked when a new collateral is deployed.  Also the oracle is not checked for compatibility with the pool manager.    Checks were added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.32   Events Missing", "body": "  Even though many events are emitted by the protocol, not all important state changes emit events. For example,  guardians  are  allowed  to  set  a  new  fee  manager  with  function  setFeeManager()  in StableMaster. As this sets a new address as a fee manager, emitting an event could help users notice this  change.  Another  example  is  that  not  all  ERC-721  events  are  emitted.  For  example,  no  events  are emitted for approvals.    ERC-721  event  are  now  emitted.  For  setFeeManager(),  an  event  was  added  to  the  StableMaster contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.33   Gas Inefficiencies When Removing From List", "body": "  Angle - Angle Protocol -   34  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fCore  keeps  track  of  governors  and  stable  masters  with  governorList  and  stablecoinList. StableMaster  keeps  track  of  all  pool  managers  with  managerList.  PoolManager  records  all  active strategies in strategyList. Each strategy registers lenders in lenders and RewardsDistributor keeps all staking contracts in stakingContractList.  In all cases, elements from the arrays can be removed. Removing a list item is always done using the following scheme (code from removing a governor in Core).  for (uint256 i = 0; i < governorList.length - 1; i++) {     if (governorList[i] == _governor) {         indexMet = 1;     }     if (indexMet == 1) {         governorList[i] = governorList[i + 1];     } } require(indexMet == 1 || governorList[governorList.length - 1] == _governor, \"governor not in the list\"); governorList.pop();  Assume  the  element  to  be  removed  is  the  first  in  the  array.  That  shifts  all  elements  by  one  position creating many storage reads and writes. Since the order of the array is not system relevant, the item to be  removed  could  be,  if  found,  overwritten  with  the  value  of  the  last  element  in  the  array,  and  the  last entry could then be popped. That would reduce the number of storage reads and writes significantly for large arrays and, hence, reduce gas consumption.    Instead of moving all element, the value of the last entry is written to the position of the element to be removed. Then, the last entry is popped.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.34   Gas Inefficiencies When Searching Lists", "body": "  When pushing a new StableMaster to stablecoinList in deployStableMaster() of Core.sol, it is checked if the item to push is already in the array. However, once found the loop continues and does not early  quit.  The  overhead  in  storage  reads  could  be  avoided  in  a  similar  way  as  in  function addGovernor().  Also, the search in _piecewiseLinear() could be optimized. Since xArray is sorted, a binary search may reduce the total number of operations if the array is large enough.    Checking whether an element is pushable to an array is now implemented using a mapping to booleans, faciliating the search. For the piecewise linear interpolation, a binary search was implemented.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.35   Governance Changes", "body": "  The documentation specifies the following:  The way a governance change occurs is that it is notified by governance (or by the guardian) to the Core which then propagates this change to all the StableMaster contracts of the protocol. Each StableMaster then notifies the AgToken contract it relates to as well as all the PoolManager.  Angle - Angle Protocol -   35  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fChanges in governance should be propagated from Core to all other contracts.  However,  usage  of  access  control  functions  inherited  from  OpenZeppelin's  contracts  may  lead  to inconsistencies.  For example following scenarios could occur:  In function removeGovernor in Core.sol, the call reverts if there is only one governor. However, it is still possible to remove the last governor by calling one of the inherited methods renounceRole or revokeRole. Ultimately, the check in removeGovernor() can easily be circumvented.   A governor may change the Core role using grantRole() and revokeRole() for a StableMaster. This may lead to inconsistencies with the core state variable in StableMasterStorage.sol. Moreover, removing or adding a guardian or governor would always revert in such a scenario (if the change is not manually undone). Also, multiple core contracts could be allowed in StableMaster.   A governor could grant or revoke a governor or guardian role to someone in Core. These changes are not propagated and may lead to inconsistencies in governance between the different contracts.    The  core  does  not  inherit  any  access  control  functionality  anymore.  The  access  control  for  Core  was customly implemented. Thus, the issues cannot occur anymore.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.36   Inconsistencies Between Staking Contract", "body": "  There are two types of staking contracts. The StakingRewards and the perpetual managers. They have similar  functionality  and  their  staking  mechanism  should  be  similar.  However,  inconsistencies  in  their implementations can be found.  Some of the inconsistencies are:   Difference  in  setNewRewardsDistributor():  The  perpetual  manager  checks  whether  a  new reward distributor contract has the same reward token as itself. StakingRewards does not do that.   Difference in emitting events: In the above function the two contracts emit different events.   Recovered event is not emitted in recoverERC20() in PerpetualManager but in StakingRewards.    The  same  events  are  now  emitted  and  the  RewardsDistributor,  the  only  contract  allowed  to  call  the staking  contracts'  setNewRewardsDistributor(),  checks  whether  the  new  rewards  distributor  has the same reward token as itself.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.37   Inconsistent Parameters in", "body": " RewardsDistributor Possible  In  contract  RewardsDistributor  consistency  checks  are  missing  and  some  parameters  could  contradict each other. Examples are:  Angle - Angle Protocol -   36  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                 \f No   check   StakingParameters.updateFrequency  StakingParameters.duration in function setUpdateFrequency.  that   is   smaller   than   No   check   that   StakingParameters.updateFrequency   is   smaller   than  StakingParameters.duration in function setDuration.    Checks were added in the mentioned functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.38   Incorrect Comment", "body": "  In PerpetualManagerFront.forceCashOutPerpetual() there is a check whether a perpetual can forcefully be cashed out due to the maximal collateralization amount has been exceeded:  // Now checking if too much collateral is not covered by HAs (uint256 currentCAmount, uint256 maxCAmount) = _testMaxCAmount(0, rateUp); // If too much collateral is covered then the perpetual can be cashed out canBeCashedOut = currentCAmount > maxCAmount ? 1 : 0;  The \"not\" in the first comment is incorrect. The code is checking if too much collateral is currently covered by HAs.  Specification changed:  The comment has been corrected to suit the modified force cashout functionality.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.39   Inefficient Structs", "body": "  There are multiple structs with multiple uint256 fields. Each of these fields uses a full storage slot of 32 bytes. Storing data in Ethereum is expensive. A significant amount of gas is used when reading from or writing  to  storage.  For  example  struct  SLPData  stores  eight  uint256.  Given  the  nature  of  the  data stored in SLPData all of these variables would not need to be of type uint256. Using smaller datatypes would  allow  to  group  multiple  of  the  variables  into  one  storage  slots.  If  done  appropriately,  this  would reduce the total amount of storage reads/writes resulting in lower gas costs. The same applies for other structs which could be optimized similarly.    Smaller  datatypes  have  been  chosen  for  some  parameters  and,  hence,  gas  consumption  has  been reduced.  Angle - Angle Protocol -   37  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                  \f7.40   No Check if onERC721Received Is Implemented  Perpetuals are treated as NFTs and are implemented as ERC-721 tokens. Much code is adapted from OpenZeppelin's  ERC-721  implementation.  In  createPerpetual()  of  PerpetualManagerFront.sol, _mint() is is used to mint tokens. The documentation of _mint() specifies that using this method is unsafe  and  _safeMint()  should  be  used.  However,  the  _safeMint()  method  was  removed  when code  from  OpenZeppeling  was  adapted.  The  intention  behind  this  function  is  to  check  if  the  address receiving  the  NFT,  if  it  is  a  contract,  implements  onERC721Received().  Thus,  there  is  no  check whether  the  receiving  address  supports  ERC-721  tokens  and  perpetuals  could  be  not  transferrable  in some cases.    mint() checks if a receiving contract implements onERC721Received().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.41   No Checks Performed in Constructor", "body": "  Contrary  to  the  constructor  of  ModuleChainlinkMulti,  the  constructor  of  ModuleUniswapMulti  does  not perform sanity checks on the length of _circuitUniswap and _circuitUniIsMultiplied.    The check was added to the constructor of ModuleChainlinkMulti.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.42   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity 0.8.2;  Known bugs in version 0.8.2 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1530  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.6 which contains some bugfixes but no breaking changes.    In  the  meantime,  the  compiler  version  has  been  updated  to  0.8.7  which  was  also  set  in  the  hardhat configuration file.  Angle - Angle Protocol -   38  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f7.43   Overhead Due to Loading Struct Into Memory  loaded   Inside the else branch in function removeFromPerpetual the whole perpetual struct of this perpetual that  only  perpetual.creationBlock  and is  perpetual.committedAmount  are  read  later  on,  loading  the  whole  struct  into  memory  is  an unnecessary overhead.  into  memory.  Given   from  storage     The  code  of  removeFromPerpetual  has  changed  significantly,  loading  from  storage  into  memory  is now more efficient.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.44   Possibly Failing Assert", "body": "  In  UniswapUtils.sol  in  function  _readUniswapPool()  an  assert  statement  checks  if  the  cast  of twapPeriod  from  uint32  to  int32  overflowed.  However,  this  may  fail  and,  thus,  consume  all remaining gas. The usage of require, in contrast, would refund the remaining gas to the user.  Actually, the value is checked in the constructor and could be checked in function changeTwapPeriod, removing the need for checking it in every execution of _readUniswapPool().    The  check  is  now  in  the  constructor  and  the  setter.  Moreover,  the  assert  has  been  replaced  with  a require statement.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.45   Potential Confusing ", "body": " readLower(uint256 lower)  Function readLower defined in OracleAbstract returns the lower rate if parameter lower is equal to 1 or else the higher rate returned by _readAll().  The  function  name  increases  the  risk  that  the  function  is  used  incorrectly  in  the  future.  It  could  be considered to split this functionality in two functions with distinct names.    readLower() always returns the lower rate. rateUpper() was introduced to get the upper rate and avoid confusion.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.46   Reward Token Issues", "body": "  Angle - Angle Protocol -   39  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                              \fThe  documentation  specifies  that  governance  could  decide  to  choose  a  reward  token  different  from ANGLE.  Thus,  RewardDistributor  must  be  generic  in  terms  of  tokens.  However,  some  inconsistencies can be found.   event  ANGLEWithdrawn  is  emitted  in  function  governorWithdrawRewardToken.  The  event  name is inconsistent with the possible use cases.  In  _incentivize(),  the  error  message  in  the  require  statement  specifies  that  an  ANGLE transfer failed. That does not have to be the case since it could be the COMP token.   Function _incentivize uses transfer(). Non ERC-20 compliant tokens may fail, e.g. USDT is unsupported  as  a  reward  token.  Generally  when  interacting  with  unknown  ERC-20  tokens  the safeXYZ  functions  may  be  used.  These  wrappers  allow  a  safe  interaction  with  non-compliant ERC-20 tokens.  Furthermore, since rewardToken cannot be modified, it can be made immutable.    The code, comments and the naming was generalized to fit the general purpose of this class as specified in the documentation. Furthermore, safeXYZ functions are used to support a broader ranger of reward tokens. Also, rewardToken is now immutable.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.47   Specification Mismatch in OracleMath", "body": "  The  OracleMath  contract  implements  functionality  for  retrieving  UniSwap  rates.  The  documentation specifies the following:  /// @return rate uint256 representing the ratio of the two assets `(token1/token0) * decimals(token1)`  However,  this  is  not  correct.  The  specification  should  specify  that  the  rate  is  multiplied  with  base 10**decimals instead of the number of decimals.  Specification changed:  The specification was changed to document the correct base.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.48   Unnecessary Double Checks", "body": "  The Angle Protocol uses the access control library of OpenZeppelin to restrict access to some functions. However,  some  functions  have  double  checks  whether  a  caller  can  execute  a  certain  function.  This occurs when rights are granted or revoked. For example, in StableMaster.sol in deploy(), the core sets the governors and guardian. First, the onlyRole modifier of deploy() checks whether the caller has the  appropriate  role  or  not.  Then,  for  each  governor  grantRole()  is  called  from  the  access  control library. grantRole() calls the onlyRole modifier. Thus, many redundant checks are executed due to the modifier of deploy() and the repetitive calls to onlyRole modifier in the grantRole() function. Similar inefficiencies occur in other contracts and function with grantRole() and revokeRole().  Angle - Angle Protocol -   40  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                 \f  OpenZeppelin's access control libraries have been forked and modified such that _grantRole() and _revokeRole()  are  now  internal.  Now,  these,  instead  of  the  public  methods,  are  used  to  avoid double checks.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.49   Updated SanRate When Converting to SLP", "body": "  Function convertToSLP of the StableMaster contains following commented out code:  // we could potentially add // _updateSanRate(0, col);  This function is used during the cash out of perpetuals should there be an insufficient amount of collateral available.  It  converts  an  amount  of  collateral  into  santokens,  hence  should  be  treated  equally  as depositing  this  amount  of  collateral.  The  san  rate  should  be  updated  indeed,  this  distributes  accrued interests which have been collected before the collateral of this HA is converted into san tokens.  Note that contrary to the deposit() function, there is no check whether the stablemaster is paused.    The  line  was  uncommented.  Now,  the  sanrate  is  updated  and  it  is  checked  if  the  contract  is  paused. Thus, the behaviour is consistent with deposit().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.50   Wrong Incentive for Which Perpetuals to", "body": " Forcefully Cash Out  Whenever the covered amount of collateral exceeds the maximum allowed amount, keepers can freely choose which perpetuals to liquidate.  The  incentive  for  how  the  perpetuals  to  be  liquidated  are  chosen  may  not  be  ideal.  Although  the maximum  fee  for  the  keeper  can  be  capped  (depending  on  the  parameter  set  by  the  governance),  in general the reward for the keeper depends on the fee the perpetual has paid.   Although fees are variable, generally larger perpetuals have paid more in fees and hence may be  more attractive for keepers  to forcefully cash out.   Using functions addToPerpetual() or removeFromPerpetual() increases the fees paid by the  perpetual and hence increases the  risk of the perpetual to be selected by keepers.  For the system however, it would be more beneficial if keepers choose to liquidate perpetuals which bring the covered amount just short of the limit for the maximum amount to be covered. E.g. the coverage limit may be 90%, however currently 91% is covered. Multiple perpetuals exist, one of them may cover 2% while another covers 20%. In case a keeper cashes out the perpetual that covered 20%, the system now only  has  roughly  70%  of  its  collateral  covered,  significantly  below  the  targeted  90%.  If  the  keeper however  had  chosen  to  cashout  the  smaller  perpetual,  the  resulting  new  covered  amount  would  have been just short of the target.  Angle - Angle Protocol -   41  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedAcknowledged                  \f  The system introduced changes on how fees are computed. Keepers are now earning more fees if they cashout/liquidate perpetuals so that the covered amount is close to the target amount.  Acknowledged:  Since  now  multiple  perpetuals  can  be  liquidated  at  the  same  time,  cashing  out  multiple  perpetuals  will cost more gas than one big one. Angle acknowledged that a commented:  In a future protocol upgrade, we could weight the amount of fees going to keepers by using another piecewise linear function that depends on the number of perpetuals cashed out: this would kill the incentive to only cash out in priority the biggest perpetuals.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.51   capOnStablecoin May Be Violated by", "body": " Guardians  capOnStableCoin is documented as follows:  /// @notice Maximum amount of stablecoin in circulation  Assume that currently 1000 AgUSD are minted. Then a guardian may call setCapOnStablecoin and set  capOnStablecoin  invariant AgUSD.totalSupply() <= capOnStablecoin could be violated in such a scenario.  though  no  new  stablecoins  can  minted   to  500.  Even   the     capOnStablecoin  was  removed.  However,  there  is  now  a  cap  on  the  issueable  stablecoins  per collateral for which it is checked that it is always higher than or equal to stocksUser.  Angle - Angle Protocol -   42  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  Hence,  the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead,  they  should  raise  awareness  in  order  to  improve  the  overall  understanding  for  users  and developers.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Frontrunning Keepers", "body": "  Keepers  are  responsible  to  keep  the  system  in  balance.  As  an  incentive  they  collect  part  of  the  fees. However, another party could see the transactions coming from the keepers and front run them without much computational effort. The incentive for keepers may be lost.  Note that Angle is aware of this and it's documented in the code above the respective keeper functions:  As keepers may directly profit from this function, there may be front-running problems with miners bots, /// we may have to put an access control logic for this function to only allow white-listed addresses to act /// as keepers for the protocol  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   New BASEFEE Opcode", "body": "  The recent hardfork introduced EIP-1559 and EIP-1398. While the first EIP introduces a new fee system for  transaction,  the  later  introduces  a  new  opcode  BASEFEE  allowing  to  query  the  new  basefee parameter of the transaction.  Roughly speaking the previous gasprice now consist of the basefee + a tip. Overall transaction prices are now much more predictable.  Appropriate  Keeper  rewards  should  cover  their  transaction  costs  and  an  additional  incentive.  While previously  the  GASPRICE  opcode  could  not  really  be  used  as  this  opened  possibilities  for  abuse  for miners, the new BASEFEE opcode is now much more suitable. It may be considered to use it as base for the keeper reward calculation.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   Oracle-related Issues", "body": "  The system uses two different oracles: Chainlink and Uniswap.  In principle these oracles provide reliable data sources, however, it is not impossible to manipulate them. For Uniswap the cost of manipulation depends on the liquidity and the activity within the affected pools.  As  volumes  increase  within  the  system  the  following  oracle-based  attacks  become  possible.  We  split them  between  attacks  that  require  manipulation  of  one  oracle  and  attacks  that  require  manipulation  of both oracles.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3.1   Single-Oracle Manipulation", "body": "   Whenever there is a big mint or burn operation of agTokens, existing system participants have an incentive  to  attack  this  mint  or  burn  with  a  manipulated  oracle.  As  a  result  the  system  will accumulate a surplus. The value of the attack is limited by the value of the mint or burn.  Angle - Angle Protocol -   43  NoteVersion1NoteVersion1NoteVersion1          \f When there an innocent user cashes out a perpetual, existing system participants have an incentive to manipulate an oracle in order to increase the system surplus. The value of the attack is limited by the value of the perpetual position.   A  malicious  user  could  perform  an  oracle  attack  to  liquidate  a  large  percentage  of  the  perpetual positions to collect the keeper fees. The value of the attack is limited by the combined keepers fees of the perpetual positions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3.2   Multi-Oracle Manipulation", "body": "   A  malicious  user  can  extract  large  amounts  of  collateral  by  manipulating  both  oracles  before performing  an  agToken  burn  operation.  The  value  of  the  attack  is  limited  by  the  total  collateral deposited of this type.   A  malicious  user  can  extract  large  amounts  of  collateral  by  manipulating  both  oracles  before performing a cashout of a perpetual position. The value of the attack is limited by the total collateral deposited of this type.  As seen from the list, some of these attacks increase in impact as the system accumulates more liquidity. Hence, the risk of such attacks grows with the rise of the system and hence needs to be monitored.  Please  note  that  some  of  the  mentioned  attacks  against  other  users  can  be  evaded  through  slippage protections as mentioned in the separate issue above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Perpetual NFTs May Not Be Composable With", "body": " Other Protocols  Perpetual  positions  are  represented  as  NFTs.  That  allows  them  to  be  transferrable.  Thus,  users  may want to sell the NFTs on secondary marketplaces. However, the design of the NFTs is not composable with other protocols.  1. A perpetual is opened and an NFT for it is issued.  2. The user wants to sell the NFT on a marketplace. The NFT is deposited on a marketplace contract.  3. The perpetual is force-closed by a keeper. The NFT is burned.  The  marketplace,  as  the  current  owner,  receives  the  underlying  funds  while  the  NFT  gets  burned. However, the marketplace is unaware of the NFT being burned and the funds being received. Thus, the underlying funds could be lost.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   SLPs Timing Their Entry", "body": "  Although the san rate is updated before a new standard liquidity provider enters the system, a new SLP may still profit from interest accrued previously:   Due to the maximum update of the san rate in one block there may be some locked interest  which are to be distributed in the next / over the next block.   An outsider may observe the performance of the strategies and may forsee that a call to  Strategy.harvest() will be profitable.  Angle - Angle Protocol -   44  NoteVersion1NoteVersion1        \fIn  both  scenarios  an  SLP  entering  at  the  right  time  may  benefit  from  interests  accrued  before  his participations at the cost of other participants.  To mitigate both, Strategy.harvest() should be called frequently in order to distribute the rewards accrued smoothly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.6   Setting Variables May Lead to Inconsistent", "body": " State  When  setting  a  new  core  from  the  old  core,  it  is  ensured  that  the  governors  and  the  guardian  of  both However, cores  deployedStableMasterMap  is  not  checked.  That  should  be  ensured  in  the  constructor  of  the  new core contract. Otherwise, stable masters could be redeployed.  stablecoinList   Similarly,   checked.   same.   are   the   the   is   Moreover,  a  guardian  can  set  a  new  fee  manager  through  the  stable  master  contract.  However,  it  is never checked whether this fee manager has the same governance structure. The governance structure must be setup in the constructor.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.7   Special ERC-20 Token Behavior May Be", "body": " Problematic  Tokens  with  fees  or  rebasing  tokens  may  be  errorneous  if  added  as  collateral.  Some  ERC-20  tokens have transfer fees. Supporting such tokens as collateral for a stablecoin may lead to accounting errors. When a user mints some AgToken in exchange for collateral, he specifies how many collateral tokens should  be  transferred  from  him  to  the  pool  manager.  This  amount  is  used  to  update  stocksUsers. However, the amount received by the pool manager may differ from the amount specified by the user due to transfer fees. Not only would accounting issues occur but also too many AgTokens would be minted. The amount of AgTokens the user would receive depends on the amount he sent but not on the amount the  pool  manager  received.  To  conclude,  the  current  system  will  not  work  as  intended  if  tokens  have fees.  Similarly this applies for rebalancing tokens where the balance of token holders changes.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.8   System Accounting", "body": "  Certain system states are not tracked by the smart contracts and need to be tracked by interested users and the operators separately in order to properly react.  1. Bad  debt  and  system  surplus  are  not  obviously  visible  in  the  system  but  can  be  computed  by retracing all the relevant system actions or by through a computation based on system variables and token balances.  2. The  amount  of  stablecoins  minted  against  a  particular  collateral  (which  is  newly  saved stocksUsers)  can,  for  different  reasons,  become  out-of-sync  with  the  actual  backing  collateral. The operators need to step in by adjusting parameters accordingly.  3. Certain stablecoin-collateral imbalances can be rebalanced using the system function, however, this  only works if there is a roughly matching positive and negative imbalance.  Angle - Angle Protocol -   45  NoteVersion1NoteVersion1NoteVersion2            \f4. Certain payments, such as the fees paid by hedging agents are not being accounted but generally support the system's health. Users hence need to query token balances to evaluate collateral value.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.9   The Devil Takes the Hindmost", "body": "  Contrary to other similar systems, the loss of the system is not evenly distributed across all participants. For  example,  such  loss  may  stem  from  uncovered  collateral  and  a  decreasing  price,  or  keepers  not liquidating  perpetuals  timely.  In  such  situations,  the  system  continues  to  operate  normally  as  long  as there are sufficient funds available. The first actors redeeming / withdrawing their assets get everything at market  prices  while  slow  users  are  left  behind  as  they  can  no  longer  burn  their  stable  tokens,  redeem their san tokens or cash out their perpetuals due to insufficient funds.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.10   Transferable Perpetuals and Reward", "body": "  Perpetual  positions  are  NFT  tokens  adhering  to  the  ERC-721  standard,  hence  perpetuals  are transferable. Note that Perpetuals are eligible to earn a reward. While such a reward is associated with the NFT, holders of the perpetual should be aware that it's to their advantage to claim their reward before transferring the perpetual.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.11   Unbounded Decrease of sanRate", "body": "  The sanRate which is the conversion rate of SanTokens cannot increase arbitrarily to limit economic attacks. However, it can decrease arbitrarily when a strategy reports losses. Such a change is harder to exploit by an economic attacker, however, it is still possible if there exists a platform when SanTokens can be borrowed. Through such a borrow operation the sanRate drop can be exploited.  Angle - Angle Protocol -   46  NoteVersion1NoteVersion1NoteVersion2            \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Gas Inefficiencies", "body": "  0  0  0  1  addExtraRewards  iterates  over  all  extra  reward  tokens  to  check  whether  the  rewardTokens  array contains them. However, the rewardTokens array is loaded from storage on every iteration. The gas consumption  could  be  reduced  by  caching  the  array  into  memory  or  using  a  set  like  data  structure  for checking whether a token is already present.  Acknowledged:  Avantgarde Finance replied:  We attempted implementing the suggested optimization, but rather than leading to savings, it led to inefficiencies in the most frequent case and a more complex code surface area. The case where Convex extra pool tokens are >1 is extremely rare (the vast majority of Curve pools have 0 or 1 extra rewards tokens), and the extra logic involved with copying `rewardTokens` into memory, validating that it is a unique set, etc makes the refactor more expensive rather than less in the vast majority of cases. For those rare cases, since `rewardTokens` is already accessed in the first loop, all SLOAD operations are already warm lookups, so the gas hit isn\u2019t significant.  Avantgarde Finance - Sulu Extensions II -   10  SecurityDesignCriticalHighMediumLowAcknowledgedDesignLowVersion1Acknowledged            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Potential Reentrancy   0  0  0  1  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Potential Reentrancy", "body": "  Transfers  modify  balances  of  users.  Hence,  checkpointing  is  required  to  be  performed  before  any balances  modification  to  ensure  fair  distribution  of  rewards.  However,  transfer  functions  are  not reentrancy-protected which offers the following attack vector:  1. Assume a Convex pool staking wrapper contract where one user holds 50 out of 100 tokens while no rewards have been earned so far. Also assume that one reward token has an on-receive-hook to the recipient of the token.  2. Now,   the  attacker  contract  calls  claimRewardsFor()   itself. ___checkpointAndClaim is called internally which harvests the Convex pool and then proceeds to checkpointing and claiming with __updateHarvestAndClaim.  to  send   rewards   to   3. 100  reward  tokens  are  harvested.  The  total  and  the  user  integral  are  updated  accordingly.  The amount to transfer to the attacking contract is 50 reward tokens. However, the claimable amount is set to 0 in storage due to the transfer. Note, that lastCheckpointBalance is not updated.  4. The transfer starts and modifies the balance to 50 and then calls the attacking contracts  hook.  1. The  attacking  contract  reenters  the  wrapper  contract  in  the  reentereable  transfer()  function inherited from ERC20.  2. ___checkpoint   is  called.  Harvesting  Convex  has  no  effect  but  now  __updateHarvest is called.  3. The last checkpointed balance (still 0) and the current balance (now 50) are queried. The  difference implies more rewards.  4. Now, the integrals are updated and so is the claimable amount is now set to 25 for the  attacking contract. The checkpointed balance is now set to 150.  5. The  execution  returns  and  nothing  happens  since  the  checkpointed  balance  is  equal  to  the  balance. No event is emitted.  6. The attacking contract claims his claimable amount. Totally, the attacking contract has claimed 75  instead of 50 reward tokens.  Ultimately,  accounting  issues  occur  since  there  are  less  rewards  available  than  expected.  Also,  some user will potentially not be able to withdraw their LP tokens due to impossible transfers.  Avantgarde Finance - Sulu Extensions II -   11  CriticalHighMediumLowCodeCorrectedSecurityLowVersion1CodeCorrected        \fEven though we specify reward tokens to be regular ERC-20 tokens, it could be possible that, since the future is unforeseeable, ERC-777 tokens could be added as rewards, which would open up such attack vectors. Hence, the underlying issue is that the Checks-Effect-Interaction design pattern is not followed.    The  nonReentrant  modifier  was  added  to  _transfer.  Hence,  all  entrypoints  that  perform checkpointing  are  protected  from  reentrancy.  Additionally,  all  checkpointing  variables  were  made private.  Hence,  more  derived  contracts  are  protected  from  reentrancy  attack  vectors  modifying checkpointing state.  Avantgarde Finance - Sulu Extensions II -   12  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Inefficient Defaulting to _newton_y", "body": "  The analytical solution implemented in get_y defaults back to the iterative _newton_y in the following situation:  CS-TRICRYPTO-NG-001  if sqrt_arg > 0:     sqrt_val = convert(isqrt(convert(sqrt_arg, uint256)), int256) else:     return [self._newton_y(_ANN, _gamma, x, _D, i), 0]  However, this means that the _newton_y starts over from scratch and has to recalculate everything from the initial values. Instead, a new method could be written that uses the existing values for a, b, c, and d which calculates K0 using Newton's method to solve the equation: 0 + cK0 + d = 0  0 + bK 2  aK 3  Then,  the  value  for  y  could  be  determined  from  this  result.  This  way,  the  get_y  function  can  return  a useful value for K0 instead of just defaulting to 0. This value can then be used as an initial guess for the next call to newton_D, saving further gas in the future.  Acknowledged:  Defaulting  to  _newton_y()  is  rare  when  running  the  new  code  on  historic  tricrypto  data,  so  Curve accepts the risk of incurring more gas costs in rare edge cases.  Curve - tricrypto-ng -   12  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedCodePartiallyCorrectedRiskAcceptedDesignLowVersion1Acknowledged              \f5.2   Typo in Event, Unused Variables  Event  UpdatePoolImplementation  first  argument  called _implementtion_id.  Field  token  in  struct  PoolArray  of  CurveTricryptoFactory  is  unused. Argument calc_price of _calc_withdraw_one_coin() is unused.  in  CurveTricryptoFactory  has   CS-TRICRYPTO-NG-002  Code partially corrected:  The token field of the PoolArray struct was removed. The calc_price argument was removed from the _calc_withdraw_one_coin() function.  The first argument of the UpdatePoolImplementation event was changed to _implemention_id, which is still spelled incorrectly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   CREATE in Pool Deployment Could Reuse", "body": " Addresses on Different Chains  If  the  address  of  the  pool  factory  is  the  same  on  two  blockchains,  then  the  deployment  addresses  of pools will match on different chains, even if the pool parameters are different (different coins). This can result in user mistakes or scam attempts.  CS-TRICRYPTO-NG-003  Risk accepted:  Curve accepts the risk of pool contracts on different chains having the same address.  Curve - tricrypto-ng -   13  DesignLowVersion1CodePartiallyCorrectedSecurityLowVersion1RiskAccepted                \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  5  10  -Severity Findings  -Severity Findings   Loss of Precision in get_p() for Some Values of A   -Severity Findings   First Depositor Can Manipulate the Share Value to Steal Future Deposits    Safety Parameters Differ Between Factory, Swap, and Math Contract    Simpler Price Calculations    Unsafe Operations    _log2() Returns Incorrect Results   -Severity Findings   Admin Can Set Unsafe Parameters Through commit_new_parameters()    Fee on remove_liquidity_one_coin() Is Computed on Initial Balance   Incomplete Validation of Coins in Factory   Initial Value K0_prev Recalculated Needlessly    Magic Number 10000 Used Instead of Constant A_MULTIPLIER    Math Implementation Cannot Be Upgraded in the Factory    No Getter for Length of Markets List in Factory    Pool Registered Twice in the Markets List for Each Key    Possible Precision Loss in get_y    Redundant Asserts in Call to _newton_y()   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Loss of Precision in get_p() for Some Values", "body": " of A  Line 851 of CurveCryptoMathOptimized3.vy performs a division of ANN by 10000:  CS-TRICRYPTO-NG-014  unsafe_div(ANN, 10000)  Value ANN ranges from 2700 to 270000000. The division can incur a substantial loss of precision that affects the return value of get_p(). With ANN = 1707629, the current USDT/WBTC/WETH A value, a price error of close to 1% is returned by get_p()  Curve - tricrypto-ng -   14  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected          \f  The  order  of  operation  has  been  modified  so  that  the  division  by  10000  is  performed  when  the denominator has sufficient precision. The relative loss of precision on the c coefficient is now at most of 1e-5.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   First Depositor Can Manipulate the Share", "body": " Value to Steal Future Deposits  A malicious user can mint a single wei of shares before any deposit exists, then increase the price of the single  share  through  a  direct  transfer  to  the  pool  followed  by  calling  claim_admin_fees(),  which sweeps unaccounted tokens and recomputes D. The next depositors will suffer severe rounding errors on the number of shares they receive.  The shares distributed for the next deposits are calculated according to  CS-TRICRYPTO-NG-004  d_token = token_supply * D / old_D - token_supply ... d_token -= 1  Since  token_supply  will  be  1,  if  D  is  between  2*old_D  and  3*old_D,  the  tokens  received  by  the victim  will  round  down  to  zero,  but  their  deposit  will  still  be  transferred  to  the  pool.  old_D  is  under complete control of the attacker, who can steal legitimate deposits by investing half of the deposit value.    The  share  value  manipulation  was  enabled  by  being  able  to  call  claim_admin_fees()  to  increase significantly the value of single shares, when the total supply is low. claim_admin_fees() now will not gulp tokens when the total supply is below 10**18. This makes the attack unfeasible, while not affecting general operation, since the total supply in normal conditions will be in the order of magnitude of the D parameter, which is between 10**17 (generally more) and 10**33.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Safety Parameters Differ Between Factory,", "body": " Swap, and Math Contract  CS-TRICRYPTO-NG-016  Safety bounds on pools parameters are different in the factory and the math contract.  Some are more restrictive in the factory:  1. MAX_GAMMA is 2*10**16 in the factory and swap, and 5*10**16 in MATH  2. MIN_A is 27000 in the factory and 2700 in MATH and swap  Some are less restrictive in the factory, which may lead to the deployment of invalid pools:  1. MAX_A is 27*10**9 in the factory, but 27*10**7 in MATH and swap  Curve - tricrypto-ng -   15  SecurityMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  1. MAX_GAMMA is 5*10**16 across all contracts.  2. MIN_A is 2700 across all contracts.  3. MAX_A is 27 * 10**7 across all contracts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Simpler Price Calculations", "body": "  The  derivation  of  the  price  calculations  leads  to  more  expensive  calculations  than  necessary.  The  gas costs  of  the  get_p  can  be  greatly  reduced  by  simplifying  the  formula  for  the  price.  For  example,  by defining the value G as follows:  The formula for the price of y with respect to x becomes:  G \u22c5 K0 = 2K0  3 \u2212 K0  2(2\u03b3 + 3) + (\u03b3 + 1)2  CS-TRICRYPTO-NG-017  An efficient implementation of this formula can reduce the costs of the price calculation by around 66%.  py = x y \u22c5  G \u22c5 K0 + N NA\u03b32K0 G \u22c5 K0 + N NA\u03b32K0  y D x D    The suggested formula was implemented in get_p. The _snekmate_mul_div function was removed as it was no longer used.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Unsafe Operations", "body": "  Some  multiplications  in  the  get_y  function  are  performed  using  unsafe_mul.  However,  several  of these can potentially overflow:  1. The following multiplication in the calculation of b can overflow:  CS-TRICRYPTO-NG-019  unsafe_mul(unsafe_mul(unsafe_div(D**2, x_j), gamma**2), ANN)  For example with the following values:  D=10**33, x_j=10**31, gamma=5*10**16, ANN=2.7*10**8  In this case, the result is greater than 2**255 and hence overflows the int256 type.    The outermost unsafe_mul, where the second factor is ANN, which could cause an overflow, has been replaced with a safe multiplication.  2. This multiplication occurs when calculating delta1:  unsafe_mul(9, a * c)  Curve - tricrypto-ng -   16  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \fIt can overflow when 2**255 / 9 < a*c < 2**255 / 3. Previously, only the multiplication of 3a * c is done using overflow checks.    The expression is now evaluated as 3 * (unsafe_mul(3, a) * c), which is safe.  3. Again in the calculation of delta1:  unsafe_mul(27, a**2)  This can overflow when a**2 is close to 2^255, but not greater. For example, this can occur when b is very close to zero.    The expression has been replaced with 27 * a**2, which is safe.  4. Lastly, the following multiplication in the calculation of sqrt_arg could potentially overflow when  delta0**2 is close to 2^255:  unsafe_mul(4, delta0**2)    The expression has been replaced with 4 * delta0**2, which is safe.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   _log2() Returns Incorrect Results", "body": "  Results of function _log2() in CurveCryptoMathOptimized3 are off by one.  CS-TRICRYPTO-NG-009  Example:  In [2]: math.log2_(2**1) Out[2]: 0  In [3]: math.log2_(2**2) Out[3]: 1  In [4]: math.log2_(2**130) Out[4]: 129  In [5]: math.log2_(2**255) Out[5]: 254  In [6]: math.log2_(2**256-1) Out[6]: 254  The only values for which a correct result is produced are x = 0, and x in [2**128, 2**129-1]  In [7]: math.log2_(2**0) Out[7]: 0  In [8]: math.log2_(2**128)  Curve - tricrypto-ng -   17  CorrectnessMediumVersion1CodeCorrected        \fOut[8]: 128  In [9]: math.log2_(2**129-1) Out[9]: 128    The  custom  _log2()  implementation  has  been  replaced  with  Snekmate  log_2().  The  new implementation is correct, except for the value of log2(0), which evaluates to 0 but which ought to be undefined.  In  the  context  where  _snekmate_log_2()  is  used,  which  is  evaluation  of  the  cube  root, returning 0 for log2(0) leads to the correct result.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Admin Can Set Unsafe Parameters Through ", "body": " commit_new_parameters()  The  same  bounds  are  not  applied  when  setting  parameters  at  commit_new_parameters().  CS-TRICRYPTO-NG-005  initialization  or  with  mid_fee can be set down to 0 through commit_new_parameters(), but must be at least MIN_FEE in deploy_pool().  allowed_extra_profit  can  be  set  commit_new_parameters(), but it can be at most 10**16 with deploy_pool().  to  values  between  10**16  and  10**18   through  Specification changed:  The  MIN_FEE  check  has  been  allowed_extra_profit has been increased from 10**16 to 10**18  removed   from   the   factory.  Max  value   for  parameter  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Fee on remove_liquidity_one_coin() Is", "body": " Computed on Initial Balance  The fee for remove_liquidity_one_coin() is computed in _calc_withdraw_one_coin() at line 1349 as  CS-TRICRYPTO-NG-015  fee: uint256 = self._fee(xp)  At  this  point,  xp  is  still  the  unchanged  balance  of  the  pool.  Removing  liquidity  with  one  coin  from  a perfectly  balanced  pool,  and  making  it  unbalanced,  will  ask  for  mid_fee.  Making  an  unbalanced  pool balanced by removing liquidity will ask for out_fee. This is the opposite of what should happen.    Curve - tricrypto-ng -   18  DesignLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1CodeCorrected                \fA  rough  but  gas  inexpensive  calculation  of  the  resulting  balance  is  performed,  for  the  purpose  of calculating the fee. The fee calculation is not exact but more accurate than in the previous version.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Incomplete Validation of Coins in Factory", "body": "  Coins in a pool shouldn't be duplicated, the following line in CurveTricryptoFactory.vy asserts it:  CS-TRICRYPTO-NG-008  assert _coins[0] != _coins[1] and _coins[1] != _coins[2], \"Duplicate coins\"  However,  the  case  where  coins[0]  ==  coins[2]  is  not  covered.  Therefore,  a  pool  could  be deployed with the same coin listed twice.    The missing check has been included.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Initial Value K0_prev Recalculated", "body": " Needlessly  The value K0_prev is used to compute an initial value for newton_D(). In _exchange(), K0_prev is first computed during the call to MATH.get_y(), but is discarded and the same value is recomputed a few lines later in MATH.get_K0_prev(). This is unnecessary since the same value is returned during both calls.  The method get_K0_prev() of CurveCryptoMathOptimized3 is redundant.  CS-TRICRYPTO-NG-018    The  K0_prev  value  obtained  from  MATH.get_y()  is  now  used.  The  get_K0_prev  function  was removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Magic Number 10000 Used Instead of", "body": " Constant A_MULTIPLIER  Despite  the  constant  A_MULTIPLIER  being  defined,  code  in  CurveCryptoMathOptimized3.vy  at lines 737, 766, 835, 851 uses the magic number 10000 directly.  CS-TRICRYPTO-NG-010    Curve - tricrypto-ng -   19  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe magic numbers have been replaced with the constant.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Math Implementation Cannot Be Upgraded in", "body": " the Factory  New  pool  implementations  can  be  deployed  in  the  factory,  but  the  math  implementation  can't  be changed.  The  event  UpdatePoolImplementation  is  unused.  A  new  pool  implementation  using another math contract could still be added to the factory, by changing the hardcoded value of the math contract in the pool implementation's constructor, instead of receiving it from the factory.  CS-TRICRYPTO-NG-011    Function  set_math_implementation  has  been  introduced  in  the  factory  so  that  the  admin  can change the math implementations of newly deployed pools.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   No Getter for Length of Markets List in", "body": " Factory  Private variable self.market_counts does not have a getter. The only way to know how many pools have been deployed for a coin pair is to iterate find_pool_for_coins() until a zero value is returned.  CS-TRICRYPTO-NG-012    Public function get_market_counts has been introduced to return the market count for a token couple.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Pool Registered Twice in the Markets List for", "body": " Each Key  The following logic includes pools in the self.markets[key] list of the factory:  CS-TRICRYPTO-NG-013  for coin_a in _coins:     for coin_b in _coins:          if coin_a == coin_b:             continue          key: uint256 = (             convert(coin_a, uint256) ^ convert(coin_b, uint256)  Curve - tricrypto-ng -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f        length = self.market_counts[key]         self.markets[key][length] = pool         self.market_counts[key] = length + 1  Each coin pair is iterated twice, first as (A,B) and then as (B,A). The keys for the two pairs are the same. As a consequence, each pool is included twice for a certain key.    The code has been refactored so that the three token couples are now individually added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   Possible Precision Loss in get_y", "body": "  In the get_y function, additional precision is added conditionally:  CS-TRICRYPTO-NG-007  d0: int256 = abs(unsafe_mul(3, a) * c / b - b)  # <------------ a is smol.  divider: int256 = 0 if d0 > 10**48:     divider = 10**30 elif d0 > 10**44:     divider = 10**26 elif d0 > 10**40:     divider = 10**22 elif d0 > 10**36:     divider = 10**18 elif d0 > 10**32:     divider = 10**14 elif d0 > 10**28:     divider = 10**10 elif d0 > 10**24:     divider = 10**6 elif d0 > 10**20:     divider = 10**2 else:     divider = 1  additional_prec: int256 = 0 if abs(a) > abs(b):     additional_prec = abs(unsafe_div(a, b))     a = unsafe_div(unsafe_mul(a, additional_prec), divider)     b = unsafe_div(b * additional_prec, divider)     c = unsafe_div(c * additional_prec, divider)     d = unsafe_div(d * additional_prec, divider) else:     additional_prec = abs(unsafe_div(b, a))     a = unsafe_div(unsafe_mul(a, additional_prec), divider)     b = unsafe_div(b * additional_prec, divider)     c = unsafe_div(c * additional_prec, divider)     d = unsafe_div(d * additional_prec, divider)  Curve - tricrypto-ng -   21  DesignLowVersion1CodeCorrected        \fHowever,  there  are  some  cases  where  divider  >  additional_prec  and  a  precision  loss  occurs instead. For example, when b \u00bb a, divider can still be as large as 10**18, but additional_prec will be 1. Therefore, up to 18 decimals are removed from a, b, c and d, resulting in a precision loss.  It  should  be  considered  whether  it  is  necessary  to  adjust  the  decimals  in  the  case  where divider > additional_prec.    The  additional  precision  calculations  were  incorrect  in  the  original  version.  The  else  branch  has  been updated to the following:  else:     additional_prec = abs(unsafe_div(b, a))     a = unsafe_div(a / additional_prec, divider)     b = unsafe_div(unsafe_div(b, additional_prec), divider)     c = unsafe_div(unsafe_div(c, additional_prec), divider)     d = unsafe_div(unsafe_div(d, additional_prec), divider)  Curve also provided an explanation for the precision adjustment:  The idea behind this is that a is always high-precision constant 10**36 / 27 while b, c, and d may have  excessive  or  insufficient  precision,  so  we  compare  b  to  a  and  add  or  remove  precision  via additional_prec. But we should also take into account not only difference between a and other coefficients, but their value by themselves (10**36 precision will lead to overflow if coin values are overflow.  The reduce  high),  divider > additional_prec case is fine unless it produces vulnerability.  use  divider   precision   so  we   avoid   and   to   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Redundant Asserts in Call to _newton_y()", "body": "  The arguments of get_y() are checked to be in a reasonable range through the following asserts:  # Safety checks assert _ANN > MIN_A - 1 and _ANN < MAX_A + 1, \"dev: unsafe values A\" assert _gamma > MIN_GAMMA - 1 and _gamma < MAX_GAMMA + 1, \"dev: unsafe values gamma\" assert _D > 10**17 - 1 and _D < 10**15 * 10**18 + 1, \"dev: unsafe values D\"  CS-TRICRYPTO-NG-006  The same checks are duplicated when entering the internal function _newton_y(), which is only called in the body of get_y()    The redundant asserts were removed from _newton_y().  Curve - tricrypto-ng -   22  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Funds Could Be Transferred Before Callback", "body": "  When  using  exchange_extended(),  a  callback  to  the  caller  is  executed  to  transfer  the  inbound exchange  amount.  The  callback  is  executed  before  the  outgoing  tokens  are  received  by  the  user. Executing  the  callback  after  the  outgoing  tokens  have  been  received  would  allow  more  flexible  use cases, by acting as a flashloan.  Curve - tricrypto-ng -   23  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   ChainExitERC1155Predicate No Exit Event", "body": "  No  Exit  event  is  defined  in  ChainExitERC1155Predicate.  Hence,  upon  calling  exitTokens  no useful  and  informative  event  gets  emitted.  Furthermore  this  behavior  is  inconsistent  with  the  other predicates.  Specification changed:  Polygon has acknowledged lack of an exit event in ChainExitERC1155Predicate mentioning that:  \"Contract is deprecated and was never deployed.\"  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   ChildChainManager cleanMapToken Emits", "body": " Wrong Event  By  calling  cleanMapToken,  a  certain  bijection  mapping  between  root  and  child  tokens  gets  removed. However, the event emitted wrongly indicates a mapping has taken place.    Polygon defined a new event TokenUnmapped which gets emitted once a certain mapping between a root and a child token gets removed.  Polygon - PoS Portal -   13  CriticalHighMediumLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedDesignLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1CodeCorrected                  \f7.3   Unused ExitedERC721Batch Event  ERC721Predicate  defines  event  ExitedERC721Batch,  however;  exitTokens  does  not  support batch exiting of tokens and this event is not used at all.    Polygon has removed the definition of ExitedERC721Batch from their codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   _processMessageFromChild Comment", "body": " Incorrect  The  comment  of  _processMessageFromChild()  in  BaseRootTunnel  says  that  is  called  from  the onStateReceive function. This is incorrect. It is actually called from receiveMessage().  Specification changed:  Polygon  has  corrected  the  comments  on  the  function  _processMessageFromChild  saying  that  it  is called from receiveMessage().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   MetaTransactionExecuted Event Has No", "body": " Indexed Arguments  The aforementioned event is defined as  event MetaTransactionExecuted(     address userAddress,     address payable relayerAddress,     bytes functionSignature );  None of its arguments are marked as indexed, which could degrade user experience. Indexing fields of events, e.g. addresses, allows to search for them easily.    Polygon  defined  userAddress  and  relayerAddress  as  MetaTransactionExecuted.  indexed   fields  of   the  event  event MetaTransactionExecuted(     address indexed userAddress,     address payable indexed relayerAddress,  Polygon - PoS Portal -   14  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                      \f    bytes functionSignature );  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Gas Optimisation Issues Informational", "body": "  The  codebase  has  several  inefficiencies  in  terms  of  gas  costs  when  deploying  and  executing  smart contracts. Here, we report a list of non-exhaustive possible gas optimizations:  1. ChildMintableERC1155.deposit  performs  a  sanity  check  on  user  !=  address(0)  after decoding depositData. This check however has already been done by the RootChainManager.  2. NativeMetaTransaction.executeMetaTransaction  has  a  visibility  of  public.  As  this function in the current implementation gets called only externally, it ca be defined as external, which subsequently  lets  memory  location  of  functionSignature  be  calldata.  In  this  way,  gas consumption can be reduced.  3. UpgradableProxy.updateImplementation checks _newProxyTo is non-zero. However, the  exact same check is done when calling into isContract.  4. UpgradableProxy.updateAndCall  is  a  public  function.  Its  visibility  can  be  changed  to  external letting its argument data be defined as calldata.  5. RootChainManager.receive  calls  into  _depositEtherFor  with  _msgSender  as  the  input argument. However, given the fact that sending ETH does not happen through a meta transaction, simply using msg.sender can be used.  6. ITokenPredicate.exitTokens takes an address as its first argument (sender). However, this  argument is never used in any implementation of the token predicates.  7. exitTokens  function  for  tokens  with  multiple  transfer  signatures  is  implemented  as  an  if-else body, and in each branch same flow of subfield extractions is done. To reduce code footprint, these operations can be moved out of if-else and only logic be kept in each branch.  8. exitTokens  function  in  call  predicates  can  have  an  external  visibility  and  calldata  memory  location for it log argument.  9. In  mintable  version  of  each  token,  inside  an  if-else  statement,  it  checks  whether  an  excessive amount  should  be  minted  and  then  transfers  the  actual  amount  to  the  receiver.  Calling  transfer functions can be done outside of if-else to decrease code footprint and reduce deployment cost.  10. NativeMetaTransaction.getNonce,  which  returns  current  valid  nonce  of  each  user.  As  this  view function gets called only externally, its visibility can be changed to external.  11. ChainExitERC1155Predicate.exitTokens  checks  the  withdrawer  is  not  address  zero. However, as the log data fed to it comes from a valid burn event on the child chain, from cannot be zero.  12. BaseChildTunnel.onStateReceive can be defined as external with message having calldata  type.  13. BaseRootTunel.receiveMessage  is  never  called  internally.  Therefore,  it  can  be  define  as  external with inputData being calldata.    Polygon has addressed most of the gas optimisation issues. However, for those below they have decided to keep the code as-is:  Polygon - PoS Portal -   15  Version1CodeCorrected    \f1. \"That is correct but we are in favour of retaining this as an assertion.\"  5. \"some relayers support ETH metatxs, retaining for backwards compatibility.\"  7. No further explanations.  9. No further explanations.  11. \"That is correct but we are in favour of retaining this as an assertion.\"  Polygon - PoS Portal -   16       \f8   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Enhance Documenation of Inline Assembly", "body": "  Code  forked  from  Biconomy  is  used  to  implement  support  for  Meta  Transactions.  The  assembly  in function msgSender() used to retrieve the sender of the message is not as trivial as it might look. The comment documenting the code section is not appropriately describing what's happening.  if (msg.sender == address(this)) {     bytes memory array = msg.data;     uint256 index = msg.data.length;     assembly {         // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.         sender := and(             mload(add(array, index)), //@okaudit-issue todo investigate calculation here, what data do we read?             0xffffffffffffffffffffffffffffffffffffffff         )     }  Intuitively the code seems to read 32 bytes past the end of msg.data. However, note that for variable length  data  in  memory  solidity  uses  the  first  32  bytes  to  store  the  length  of  the  data.  Hence, mload(add(array, index)) loads the last 32 bytes of msg.data and the code works correctly. Due to the delicate nature of assembly within Solidity, this might be documented appropriately.  Polygon - PoS Portal -   17  InformationalVersion1  \f9   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "9.1   ChildERC721 Static domainSeparator", "body": "  In  all  variants  of  ChildERC721,  once  and  only  once  upon  deployment,  domainSeparator  gets calculated using the name of token and chain ID:  domainSeperator = keccak256(     abi.encode(         EIP712_DOMAIN_TYPEHASH,         keccak256(bytes(name)),         keccak256(bytes(ERC712_VERSION)),         address(this),         bytes32(getChainId())     ) );  However, in RootChainManager and UChildERC20, a functionality is devised to let recomputation of domainSeparator,  e.g.  when  name  of  token  gets  updated.  Despite  the  fact,  that  forking  and  a consequent change of chain ID may not be very possible, implementing this functionality in derivations of ERC721Child could make the system more robust.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "9.2   Exiting MintableERC721", "body": "  MintableERC721Predicate offers several exit possibilities:   TRANSFER_EVENT_SIG   WITHDRAW_BATCH_EVENT_SIG   TRANSFER_WITH_METADATA_EVENT_SIG  Due to the uniqueness of an NFT (tokenID) a token can only exist once. However, please consider all withdrawal  options  emit  the  Transfer  event  on  the  child  chain  and  hence  all  can  be  exited  using  the TRANSFER_EVENT_SIG. This has the following consequences:  For an exit initiated using:   withdrawBatch: If one transfer has been exited using the TRANSFER_EVENT_SIG, all transfers of  the batch must be individually exited using their individual transfer event.   withdrawWithMetadata: If the TRANSFER_EVENT_SIG is used for the exit, the metadata is lost.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "9.3   Minting of ERC721 Tokens", "body": "  Polygon - PoS Portal -   18  NoteVersion1NoteVersion1NoteVersion1          \fWhen  using  ChildMintableERC721  and  MintableERC721Predicate,  it  is  important  that  only  the predicate has minting rights for the token on the root chain.  On the child chain ChildMintableERC721 allows addresses holding an admin role to mint tokens with arbitrary token ID's given they do not exist on the child chain and have not been withdrawn to the root chain yet.  This protection is only effective when no arbitrary token can be minted on the root chain.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "9.4   Recipient of Withdrawn Tokens", "body": "  None of the withdraw functions of the child tokens allows to specify the recipient on the root chain. The recipient address is the token owner on the child chain.  It is important to ensure one can access these tokens on the root chain before initiating the withdrawal. Although this generally is not an issue for EOAs, special care must be taken for contracts.  For ERC721/ERC1155 if the recipient is a contract, the contract must implement the appropriate interface or the tokens may be stuck in the bridge as they cannot be exited successfully.  Polygon - PoS Portal -   19  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Default Arguments Evaluated Incorrectly for", "body": " Internal Calls  Internal  calls  with  default  arguments  are  compiled  incorrectly.  Depending  on  the  number  of  arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. In the bar() function in the following code, self.foo(13) is compiled to self.foo(13,12) instead of self.foo(13,1337).  CS-VYPER_MARCH_2023-001  @internal def foo(a:uint256 = 12, b:uint256 = 1337):  Vyper - Vyper Compiler -   10  SecurityDesignCorrectnessCriticalHighMediumLowCorrectnessHighVersion1            \f    pass  @internal def bar():     self.foo(13)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Out of Bound Memory Accesses With", "body": " DynArray  Access  to  invalid  memory  can  be  performed  through  the  use  of  DynArray  assignments  and  mutating operations.  In  the  following  code  snippets,  uninitialized  memory  can  be  read.  Since  memory  frames  are  reused between function calls, that memory can contain information belonging to other functions.  CS-VYPER_MARCH_2023-002  Literal assignment to ``DynArray``:  @internal def foo():     c:DynArray[uint256, 1] = []     c = [c[0]]  In the previous example, in line c = [c[0]], the out-of-bound access check is perform after having set the length of c to 1. The check succeeds but the memory is uninitialized.  append:  @internal def foo():     c:DynArray[uint256, 1] = []     c.append(c[0])  In the previous example, c.append(c[0]) reads uninitialied memory, but the bounds check succeed because .append() increases the length of c before evaluating its arguments.  Furthermore, writing to locations beyond an array length is possible with the use of pop().  pop:  @internal def foo():     c:DynArray[uint256, 1] = [1]     c[0] = c.pop()  Here the check to write to c[0] is performed before the length of the array is reduced by pop() to 0. It should revert but it succeeds.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   StringT Not Handled in HashMap Access", "body": "  Vyper - Vyper Compiler -   11  SecurityHighVersion1CorrectnessHighVersion1            \fThe code generation for index HashMap index should treat in the same way StringT and BytesT. The condition  at  line  337  of  vyper.codegen.expr  only  checks  isinstance(index.typ,  BytesT), instead of isinstance(index.typ, _BytesArray). BytesLike got incorrectly turned into BytesT in  the  context  of  PR3182.  As  a  consequence,  the  pointer  to  a  string  is  used  to  access  a  HashMap, instead of its hash.  CS-VYPER_MARCH_2023-003  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Skip_Contract_Check Skips Return Data", "body": " Existence Check  CS-VYPER_MARCH_2023-004  When  calling  an  external  function,  the  contract  existence  check  can  be  skipped  with  the  keyword argument skip_contract_check. The skip_contract_check however also bypasses the checks that the external function call returned the right amount of data, by foregoing the following assert (line 111 of vyper.codegen.external_call) :  [\"assert\", [\"ge\", \"returndatasize\", min_return_size]]  Since the arguments buffer is reused as the return data buffer for the external call, if the called contract does not return data, the unchanged input data is mistaken as the output data of the called function.  As  an  example,  we  are  calling  address  0  with  function  selector  for  f(uint256,uint256)  and arguments  1337  and  6969.  The  call  should  revert,  because  it  resulted  in  no  return  data,  or  at  most  it should return (0,0). However the call returns (1337, 6969). The only reason for this is that the argument buffer is reused as the return buffer.  interface A:     def f(a:uint256, b:uint256) -> (uint256, uint256): view  @external @view def foo() -> (uint256, uint256):     return empty(A).f(1337, 6969, skip_contract_check=True)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   String to Bool Conversion Incorrect", "body": "  The  to_bool  conversion  of  _convert.py  accepts  StringT,  which  should  be  treated  likely  like BytesT. However it receives the same treatement as value types, so the pointer is converted to a bool (is zero comparison).  CS-VYPER_MARCH_2023-005  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.6   BytesT to BytesM_T Conversion Can Perform", "body": " Invalid Memory Access  CS-VYPER_MARCH_2023-006  Vyper - Vyper Compiler -   12  DesignMediumVersion1CorrectnessMediumVersion1DesignLowVersion1                  \fAn out-of-bound memory access is performed, with no consequences, when converting from an empty byte sequence (b\"\") to bytes32.  The following code:  @internal def f() -> bytes32:    return convert(b\"\", bytes32)  generates the following IR:  /* convert(b\"\", bytes32) */ [with,   arg,   /* b\"\" */ [seq, [mstore, 64, 0], 64],   [with,     bits,     [shl, 3, [sub, 32, [mload, arg]]],     [shl,       bits,       [shr, bits, [mload, [add, arg, 32]]]]]]  An mload to arg + 32 is performed, which is out of bounds with respect to the memory size allocated, which is of 1 word for a bytestring of length 0. However, the loaded value is accessed only after shifting it by 256 bits, which means it is zeroed, and its value does not leak to the user.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.7   Contract With Only Internal Functions Is", "body": " Executable  If a contract only has internal functions, beside the constructor, it might still compile to executable code. Internals are not pruned, and execution of the internal functions section is not guarded. Upon calling the contract, execution will start at the first internal function. The execution will however generally fail when POPping the RETURN_PC from the stack, which should be empty upon function exit.  CS-VYPER_MARCH_2023-007  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.8   Cost of Memory Expansion for Callees Always", "body": " Payed  For functions that perform internal calls conditionally, the gas cost of the memory expansion caused by the  internal  call  is  payed  even  when  the  internal  functions  are  not  called,  because  the  caller  memory frame is placed at higher memory addresses than the the callees memory frame.  CS-VYPER_MARCH_2023-008  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.9   Dead Code", "body": "  Vyper - Vyper Compiler -   13  CS-VYPER_MARCH_2023-009  DesignLowVersion1DesignLowVersion1DesignLowVersion1                  \fArgument  constant_override  of  method  FunctionSignature.from_definition  defined  in vyper.ast.signatures.function_signature is unused throughout the codebase.  Function  parse_Name  in  vyper.codegen.stmt  is  likely  never  executed,  as  a  Name  can't  be  a statement. The vdb directive seems to be a left-over from long ago.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.10   IR Labels for Different Functions Can Collide", "body": "  Labels for goto statements are generated in vyper.ast.signatures.function_signature. The function _ir_identifier is in charge of generating unique IR labels for every function. Depending on the  function  and  the  type  names,  different  functions  can  generate  the  same  labels.  IR  generation  will succeed but assembly generation wil fail.  CS-VYPER_MARCH_2023-010  Example:  struct A:     a:uint256 struct _A:     a:uint256 @external @view def f(b:_A) -> uint256:    return 1 @external def f_(b:A):     pass  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.11   Internal Function Arguments Location Set to", "body": " CALLDATA in Typechecking  In vyper.semantics.analysis.local, when a FucntionNodeVisitor is created, its arguments DataLocation are set to CALLDATA, regardless if they belong to an internal or external function. For internal  functions,  the  DataLocation  should  be  memory.  DataLocation  is  not  used  during  code generation, so there are currently no consequences beside a wrong error message when trying to assign an internal function argument.  CS-VYPER_MARCH_2023-011  As an example, compiling the following:  @internal def foo(a:uint256):     a = 1  raises the following exception: ImmutableViolation: Cannot write to calldata. In this case we would not be writing to calldata.  Vyper - Vyper Compiler -   14  CorrectnessLowVersion1CorrectnessLowVersion1              \f5.12   Internal Functions Only Called by __init__ Are Also in the Runtime Code  Internal functions that are only called in the constructor are still included in the runtime code, increasing its size.  Furthermore, the constructor can call internal functions, but these can't call other internal functions. This is not checked at compile time, but it causes an excecution failure upon deployment.  CS-VYPER_MARCH_2023-012  Example of failing deployment:  @external def __init__():     self.f() @internal def f():     self.g()  @internal def g():     pass  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.13   parse_type() Can Be Avoided in Favor of", "body": " Annotations  In the code generation phase, types are parsed from AST objects when they could be recovered from the annotation metadatas added during typechecking.  CS-VYPER_MARCH_2023-013  In  vyper.ast.signatures.function_signature,  at  line  135  and  169,  the  arguments  and  return type  are  already  contained  instance  of ContractFunctionT.  in  func_ast._metadata['type'],  which   is  an   In parse_AnnAssign` in vyper.codegen.stmt, the type could be stored in the AST node during local function analysis (AnnAssign nodes currently do not store _metadata['type']).  Vyper - Vyper Compiler -   15  DesignLowVersion1DesignLowVersion1          \f6   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Default Return Value Evaluated Conditionally", "body": "  Calling an external function with default_return_value=a() will only evaluate a() after the external call  has  been  performed,  if  the  call  resulted  in  no  return  data.  This  behavior  is  undocumented  and clashes with the usual semantics, where all arguments are evaluated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Order of Evaluation of Event Arguments", "body": "  As in solidity, the order of evaluation of event arguments in Vyper is counter-intuitive, and doesn't follow the  usual  conventions.  First  the  indexed  parameters  are  evaluated  right  to  left,  then  the  non-indexed parameters are evaluated left to right.  In the example, the internal calls are performed in the order self.a(), self.b(), self.c(), self.d():  event A:     b:indexed(uint256)     c:uint256     d:uint256     a:indexed(uint256)  @internal def a() -> uint256:     return 1 @internal def b() -> uint256:     return 2 @internal def c() -> uint256:     return 3 @internal def d() -> uint256:     return 4  @internal def foo():     log A(self.b(), self.c(), self.d(), self.a())  This unusual behavior should be highlighted.  Vyper - Vyper Compiler -   16  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Curve Base Adapter Misconfiguration", "body": "  The Curve base adapter does not sanitize _nCoins and could be initialized with only one coin. Such a misconfiguration  would  not  have  security  implication,  but  the  adapter  is  likely  to  revert  on  most  of  the interactions.  CS-GEARV21-001  Risk accepted:  Gearbox Protocol states:  This contract is never deployed by itself, and we never have to manually enter the value for this parameter, since it\u2019s defined as constant in derived adapters.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Unusable Inherited Functions", "body": "  The contract CurveV1AdapterDeposit inherits CurveV1AdapterBase but the inherited exchange* and  functions  do  not  exist  on  the  Curve's  deposit  zappers.  These  functions  will  be  available  through CurveV1AdapterDeposit but will revert if called.  CS-GEARV21-002  Risk accepted:  Gearbox Protocol states:  Gearbox Protocol - Gearbox V2.1 -   20  DesignCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedDesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \fPotential costs of changing contracts hierarchy exceed additional deployment costs.  Gearbox Protocol - Gearbox V2.1 -   21    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Wrong WaToken Distribution   -Severity Findings   Compound Adapter's redeemUnderlying() Not Executed   Inheriting ACLTrait Includes Pause/Unpause   -Severity Findings  Inconsistent Test for Reward Token Wrapper    Missing Event    Query of Curve's Tricrypto Pool Virtual Price    BlacklistHelper Claimable Balance Is 1 Wei off    UniswapConnectorChecker Missing Sanity Check   0  1  2  5  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Wrong WaToken Distribution", "body": "  The  exchange  rate  depends  on  the  contract's  balance  of  aTokens  and  the  total  supply  of  the WrappedAtokens:  CS-GEARV21-016  function exchangeRate() public view override returns (uint256) {     uint256 supply = totalSupply();     if (supply == 0) return WAD;     return (aToken.balanceOf(address(this)) * WAD) / supply; }  In  WrappedAToken.deposit(),  the  exchange  rate  is  computed  after  the  contract  received  the aToken, so its balance has already been updated. This leads to a wrong computation of the distributed shares or WaToken.  function deposit(uint256 assets) external override returns (uint256 shares) {     aToken.transferFrom(msg.sender, address(this), assets);     shares = _deposit(assets); }  function _deposit(uint256 assets) internal returns (uint256 shares) {     shares = (assets * WAD) / exchangeRate();     _mint(msg.sender, shares);  Gearbox Protocol - Gearbox V2.1 -   22  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected          \f    emit Deposit(msg.sender, assets, shares); }  Example:  For simplicity, we assume that the exchange rate of the aToken is 1.  User A deposits 10 aToken, the computed shares are 10 / 1 = 10 since the total supply is 0. After this transaction, the contract has 10 aToken and the total supply is 10.  User  B  deposits  10  aToken,  the  computed  shares  are  10  /  (20  /  10)  =  5  because  the  contract already holds the new 10 aToken. After this transaction, the contract has 20 aToken and the total supply is 15.  If  user  A  or  B  wants  to  withdraw  at  that  point,  each  should  get  their  10  aToken  back.  But  if  user  B withdraws, the computed amount of aToken he will receive is 5 * (20 / 15) = 6.666..., which is clearly not the expected amount.    The updated code does not take the balances into account anymore for the computation of the exchange rate. Now, the exchange rate is computed as the ratio of the current Aave pool's normalized income and the normalized income at WaToken contract deployment.  function exchangeRate() public view override returns (uint256) {     return WAD * lendingPool.getReserveNormalizedIncome(address(underlying)) / _normalizedIncome; }  Doing so, the contract only sees the exchange rate grow, as long as Aave's interest rate is growing, and the shares cannot be maniputaled by users of the WaToken contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Compound Adapter's redeemUnderlying()", "body": " Not Executed  CS-GEARV21-014  the   In  and CompoundV2_CEtherAdapter._redeemUnderlying()  only  encode  the  call  to  the  target  contract, but _execute() is not called:  CompoundV2_CErc20Adapter._redeemUnderlying()   error = abi.decode(_encodeRedeemUnderlying(amount), (uint256));  This has no security implications for Gearbox, but users cannot use this function.    The code has been updated to execute the call:  error = abi.decode(_execute(_encodeRedeemUnderlying(amount)), (uint256));  Gearbox Protocol - Gearbox V2.1 -   23  DesignMediumVersion1CodeCorrected          \f6.3   Inheriting ACLTrait Includes Pause/Unpause  The  AbstractAdapter  (which  is  inherited  by  all  Adapters)  and  the  BlacklistHelper  inherit  ACLTrait.  This abstract contract implements pause functionality:  CS-GEARV21-012  ///@dev Pause contract function pause() external {     if (!_acl.isPausableAdmin(msg.sender))         revert CallerNotPausableAdminException();     _pause(); }  /// @dev Unpause contract function unpause() external {     if (!_acl.isUnpausableAdmin(msg.sender))         revert CallerNotUnPausableAdminException();      _unpause(); }  Hence  contracts  inheriting  from  ACLTrait  will  have  external  functions  pause  and  unpause  exposed. These  functions  may  make  it  look  like  the  contract  can  be  paused  -  despite  no  function  actually  being pausable.    The  inheritance  from  ACLTrait  has  been  removed  in  the  AbstractAdapter  and  kept  in BlacklistHelper. Gearbox Protocol responded:  Abstract adapter no longer inherits ACL trait (for adapters, it could have potentially caused problems if we introduced some pausable functions, because credit facade is, in fact, a pausable admin, so users would then be able to pause an adapter in the multicall; for blacklist helper there is no risk so no change)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Inconsistent Test for Reward Token Wrapper", "body": "  To  check  whether  a  reward  token  is  wrapped,  a  call  to  the  booster()  function  of  the  contract  is performed. If the call succeeds, then the reward token is further unwrapped. However, the test whether the  second  reward  token  is  wrapped  or  not  in  the  constructor  of  ConvexV2_BaseRewardPool  is inconsistent. The check for is using _extraReward1 instead of _extraReward2.  CS-GEARV21-013    Now booster() is called on _extraReward2.  Gearbox Protocol - Gearbox V2.1 -   24  DesignMediumVersion1CodeCorrectedDesignLowVersion6CodeCorrected                \f6.5   Missing Event  CS-GEARV21-010  Events should be emitted whenever an important state change happens in a smart contract. Since setting isIncreaseDebtForbidden  in CreditFacade._closeLiquidatedAccount()  is  an  important  state  change,  an  event  may  be useful.  occurred   true   when   pool   loss   the   to   a     If the pool occurred a loss during liquidation, the IncurLossOnLiquidation event is emitted.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Query of Curve's Tricrypto Pool Virtual Price", "body": "  CS-GEARV21-011  In  CurveCryptoLPPriceFeed.latestRoundData(),  is  queried  with curvePool.get_virtual_price(),  but  on  the  reference  code  provided  by  Gearbox  Protocol (https://arbiscan.io/address/0x4e828A117Ddc3e4dd919b46c90D4E04678a05504#code#F3#L1)  and notably in the official curve.finance pricefeed template (https://github.com/curvefi/crypto_lp_pricing/blob/b the 6fea6943d5ddf8648f05d442daad284c1757c86/contracts/LPPrice_tricrypto_ethereum.vy#L41),  virtual price is queried from the storage variable with curvePool.virtual_price().  virtual  price   the     function  CurveCryptoLPPriceFeed.latestRoundData  has  been  updated   The  curvePool.virtual_price() instead of curvePool.get_virtual_price().  to  use  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   BlacklistHelper Claimable Balance Is 1 Wei", "body": " off  In CreditFacade._increaseClaimableBalance(), the parameter balanceBefore has 1 wei too many due to _isBlacklisted(). The claimable amount is computed as balance-balanceBefore and will lack 1 wei.  CS-GEARV21-015    The  been  helperBalance - helperBalanceBefore + 1;  claimable   amount   has   updated   to   be   computed   as  Gearbox Protocol - Gearbox V2.1 -   25  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f6.8   UniswapConnectorChecker Missing Sanity Check  The constructor of UniswapConnectorChecker accepts an array of addresses as parameter, but the length of the array is never checked to be <=10. So the checker could be deployed with an array of 25 addresses, only the 10 first will be saved in storage, but numConnectors will be 25. This will also incur unnecessary gas cost when getConnectors() is called.  CS-GEARV21-009    The constructor has been updated to revert if more than 10 addresses are provided.  Gearbox Protocol - Gearbox V2.1 -   26  DesignLowVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Code Duplication", "body": "  The  function  CurveV1StETHPoolGateway.remove_liquidity_imbalance  transfers  token0  and token1 in the function's body, but the dedicated function _transferAllTokensOf can be used.  CS-GEARV21-003  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Code Inconsistencies", "body": "  CS-GEARV21-006  1. For gas optimizations, the system tries to always keep 1 wei in the balances and the standard way in  is  with  balance  <=  1,   however   to  BlacklistHelper.claim() the check is amount < 2.  codebase   across   check   the   it   2. The Lido gateway transfers the full balance instead of balance-1 as everywhere else in the system  (gas optimization).  3. In the adapters, _gearboxAdapterType is sometimes overridden as a constant, and some other times  as  a  function.  For  consistency  across  the  codebase,  one  of  the  two  solutions  should  be chosen.  Code partially corrected:  1. Changed to amount < 1.  2. Not addressed.  3. Not addressed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Gas Optimizations", "body": "  1. In UniswapV2Adapter._parseUniV2Path(), path.length could be loaded from memory to a local variable at the beginning of the function and read from the local variable to save a MLOAD.  CS-GEARV21-007  2. In  UniswapV2Adapter._parseUniV2Path(),   if path.length < 2, path.length > 4, or if one of the hops is not an allowed connector to save some gas.  function   return   could   early   the   3. In   CurveV1AdapterBase,  add/remove_liquidity_one_coin(uint256,uint256,uint256)  do  not  need   functions the  the   the   Gearbox Protocol - Gearbox V2.1 -   27  InformationalVersion1InformationalVersion1CodePartiallyCorrectedInformationalVersion1CodePartiallyCorrected              \fcreditFacadeOnly()  add/remove_liquidity_one_coin(uint256,int128,uint256) have it already.  modifier,   since  Code partially corrected:  1. The length of the array is loaded only once at the beginning of the function and stored in a local  variable.  2. The conditionnal structure has been optimized. However, the function could return early if len > 4  to save some gas in the case of a failure.  3. The   concerned   internal been  _add/remove_liquidity_one_coin(int128) which do not have the creditFacadeOnly() modifier.  functions   updated   have   call   the   to   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Unused Constants", "body": "  Some of the defined constants are still declared and imported, but never used. A non-exhaustive list is:  CS-GEARV21-004   ALL0WANCE_THRESHOLD   EXACT_INPUT   EXACT_OUTPUT  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Wrong Comments", "body": "  Some comments in the code are wrong, here is a non-exhaustive list:  1. WstETHGateway: the @notice comment is wrong, the contract does not allow to convert stETH  into WstETH, it allows to provide liquidity to Gearbox's WstETH in the form of sthETH.  2. ACLNonReentrantTrait:  the  comment  of  the  controllerOnly()  modifier  is  incomplete,  it  only covers the case where externalController is false.  CS-GEARV21-008  3. CreditConfigurator:   in   the   creditManager.upgradeCreditFacade  Connects creditFacade and priceOracle, but only the CreditFacade is connected.  comment   that   has   constructor,  a   the   call   to specifies  4. CurveCryptoLPPriceFeed:  the  @notice  of  the  latestRoundData  function  is  wrong,  the  specified formula is not the one implemented.  5. CreditFacade:   In  _liquidateExpiredCreditAccount   the  comment  \"Checks   if   the  liquidsation . . .\" contains a typo.  6. The  natspec  of  BalancerV2VaultAdapter.batchSwap()  specifies  that  the  assets  must  be ordered.  Nothing  is  enforcing  the  ordering  and  Balancer  V2  does  not  need  to  have  the  assets ordered.  Specifications partially corrected:  Gearbox Protocol - Gearbox V2.1 -   28  InformationalVersion1InformationalVersion1Speci\ufb01cationPartiallyChanged          \f1. Not addressed.  2. The comment has been updated to include the case where externalController is true.  3. Not addressed.  4. The formula in the specification has been updated to match the implementation.  5. The typo has been corrected.  6. The mention of the assets' ordering has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   safeApprove Can Revert", "body": "  CS-GEARV21-005  Theoretically,  IERC20.safeApprove()  can  revert  in  WstETHGateway._checkAllowance()  and WaToken.depositUnderlying()  because  the  safeApprove()  function  requires  either  the  current allowance or the value to be 0.  In WstETHGateway, the allowance for the WstETH token is set to type(uint256).max at contract deployment, and is decreased each time WstETHGateway.addLiquidity() is called. Also, each time  WstETHGateway.addLiquidity()  is  called,  the  allowance  check  is  performed,  so  if  the allowance is strictly smaller than the amount. But the maximum allowance is such a big number that this will never happen in practice.  In  WstETHGateway.removeLiquidity()  and  WaToken.depositUnderlying()  set  the allowance for Gearbox's and Aave's lending pool to the exact amount that should be pulled from the contract. The pools are trusted to pull the exact specified amount and not less to set the allowance back  to  0.  If  one  of  the  pool  was  to  be  updated  and  pulls  less  than  the  specified  amount, WstETHGateway.removeLiquidity() and WaToken.depositUnderlying() would revert.  Gearbox Protocol - Gearbox V2.1 -   29  InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   MetaPool With Underlying", "body": "  Note that there could be a Curve Metapool with a Metabpoolbase which contains an asset which has an underlying. The current CuveV1_Base implementation does not support interaction using the underlying of of one of the assets in the Metapoolbase. Gearbox Protocol stated they do not aim to support this. In practice the two most relevant base pools are 3CRV and crvFRAX, which both don't have underlyings for their assets. If such a metapool was to be added, the swap into an underlying would be supported by the router.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Multicall Reverts When Temporarily", "body": " Exceeding TokenLimit  Adapters  don't  disable  tokenIn  when  uncertain  whether  all  balance  was  spent.  Such  tokens  will  be disabled  at  the  end  of  the  multicall  when  the  full  check  is  executed.  There  is  a  corner  case  where  a sequence of multicalls may revert for one credit account (as the limit would be temporarily exceeded) but not for another (where the limit is not exceeded).  This  may  hinder  the  usage  of  predefined  multicall  sequences.  Note  that  the  problem  can  always  be rectified by adding a call to disableToken in between.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   WrappedAToken: depositUnderlying", "body": " Assumption  It's of uttermost importance that the expected amount of aToken is deposited into the wrapper contract when shares are minted.  As argument assets the user passes the amount of underlying to depositUnderlying(). There is an assumption that when depositing x amount of underlying into Aave, x amount of aTokens is received in exchange. This holds if Aave works correctly as specified.  function depositUnderlying(uint256 assets) external override returns (uint256 shares) {     underlying.safeTransferFrom(msg.sender, address(this), assets);     underlying.safeApprove(address(lendingPool), assets);     lendingPool.deposit(address(underlying), assets, address(this), 0);     shares = _deposit(assets); }  However, this makes the contract vulnerable if Aave doesn't behave as expected.  Gearbox Protocol - Gearbox V2.1 -   30  NoteVersion1NoteVersion1NoteVersion1          \fGearbox Protocol states:  Wrapped aTokens will probably be deployed only for known tokens like WETH or USDC, for which said assumption can be easily validated.  Gearbox Protocol - Gearbox V2.1 -   31  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Performance Updates Can Be Sandwiched", "body": "  The  performance  safeguard  validates  that  the  performance  based  on  a  unit  of  pool  token  does  not deviate  too  much  from  the  old  performance  after  a  swap.  Updating  the  performance  is  permissionless when  a  perfUpdateInterval  (within  0.5  to  1.5  days)  has  elapsed.  If  the  allowed  performance deviation is x%, one can bundle a performance update within two swaps to achieve around 2x% deviation, that  performance  can  at  most  change  x%  within  one which  breaks  perfUpdateInterval.  the  assumption   CS-SLSGP-008  Swaap Labs - SafeguardPool -   12  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedCorrectnessLowVersion1RiskAccepted             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Reentrancy via Vault   -Severity Findings  Incorrect Rounding Directions   Incorrect Target Deviation Computation    Missing Sanity Checks at Pool Initialization   -Severity Findings   Balance Based Penalty Can Be Manipulated    Price Feed Data Validity Checks   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Reentrancy via Vault", "body": "  0  1  3  2  CS-SLSGP-012  The Balancer V2 Vault has a known vulnerability to read-only-reentrancy:  https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345.  The balances during onJoin/onExit are updated after new shares are minted/burned. And before balance update, the Vault performs a call to external address with the remaining ETH.  The following scenario is possible:   A large LP awaits the time when the updatePerformance() can be called.   LP exits in a balanced way(no updatePerformance triggered yet) and triggers the reentrancy from  the Vault.  In the reentrant call the pool.updatePerformance() is executed. The reentrancy guard on Pool won't be triggered, because it is the Vault that makes the reentrant call.   The   performance   but Vault.getPoolTokens() will return not yet updated balances. Thus the performance will be too high.  values.  PT  will   snapshots  wrong   burned,   already   be   This reentrancy is due to the way Vault contract deals with the ETH that is sent along with swap/join/exit call using _handleRemawiningEth function.  As  a  result,  wrong  performances  will  be  saved  for  a  given  performance  update  period.  This  will  cause DoS in case of exit (performances are too high), or disable the performance based checks for the whole period.  This applies to getPoolPerformance function as well.  Swaap Labs - SafeguardPool -   13  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrected           \f  The reentrancy issue has been fixed in the Vault contract, where the update of the balances is now done before the token transfers.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Incorrect Rounding Directions", "body": "  Most computations in SafeguardPool are based on 18 decimals for higher precision. However, rounding errors  are  not  properly  handled  in  some  cases,  where  it  may  round  towards  the  advantage  of  users instead of the pool.  In  calcJoinSwapAmounts(),  the  swapAmountIn  is  computed  using  divDown.  Then  the  rOpt  is computed from this value:  CS-SLSGP-002  uint256 swapAmountIn = num.divDown(denom); uint256 swapAmountOut = swapAmountIn.divDown(quoteAmountInPerOut);  function calcJoinSwapROpt(uint256 excessTokenBalance, uint256 excessTokenAmountIn,     uint256 swapAmountIn ) internal pure returns (uint256) {     uint256 num   = excessTokenAmountIn.sub(swapAmountIn);     uint256 denom = excessTokenBalance.add(swapAmountIn);     return num.divDown(denom); }  However, the num will be computed as excessTokenAmountIn.sub(swapAmountIn), thus it will be effectively rounded up. This might result in minting more shares than intended.  A similar case exits in calcExitSwapAmounts() though it is unclear which rOpt is larger.  In addition, in _exitBPTInForExactTokensOut() the bptAmountOut is rounded down. This lowers the amount of shares the user needs to burn. As a result, the pool tokens can lose value with time due to exit conditions that do not favor remaining pool token holders.  uint256 bptAmountOut = totalSupply().mulDown(rOpt);  In  another  note,  _getOnChainAmountInPerOut()  and  calcBalanceDeviation  round  down  the computations. This may make the fairPricingSafeguard and balance based checks slightly weaker. However, in other places, it is unclear if the computation should round up or down (e.g. computation of currentPerformance in _updatePerformance()).    The  calcJoinSwapROpt()  now  subs  1  wei  from  numerator  and  adds  1  wei  to  denominator.  This effectively  lowers  the  number  of  tokens  minted  during  the  deposit  by  a  small  amount,  that  always guarantees that the balances per PT values won't decrease during balanced join.  The  calcExitSwapROpt()  now  adds  1  wei  to  numerator  and  subs  1  wei  from  denominator.  This effectively increases the number of tokens burned during the withdrawal by a small amount, that always guarantees that the balances per PT values won't decrease during balanced exit.  The  _exitBPTInForExactTokensOut()  has  been  fixed  to  use  mulUp  instead  of  mulDown  to compute the amount of pool tokens burned upon a withdrawal.  Swaap Labs - SafeguardPool -   14  SecurityMediumVersion1CodeCorrected        \fThe  rounding  in  calcBalanceDeviation  can  effectively  be  accounted  by  the  quote  generating front-end.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Incorrect Target Deviation Computation", "body": "  The  balance  safeguard  validates  that  the  HODL  balance  of  the  output  token  after  a  swap  does  not deviate  too  much  from  it  before  the  swap  (target  deviation).  This  is  computed  in  the  wrong  way  in _getPerfAndTargetDev(),  where  the  numerator  should  be  newBalanceOutPerPT  instead  of newBalanceOut. The target deviation should be in %, however, this wrongly computed value represents the amount of pool tokens.  CS-SLSGP-003    The  deviation  newBalancePerPTOut.divDown(hodlBalancePerPTOut).  target   now   is   correctly   computed   as  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Missing Sanity Checks at Pool Initialization", "body": "  There  is  no  sanity  check  on  the  user's  input  token  amounts  amountsIn  as  well  as  the  initial  HODL balance at the pool initialization.  In case a user initializes the pool with 0 amountsIn, the pool becomes useless irreversibly:  CS-SLSGP-004   Anyone can mint any amount of pool tokens by depositing 0 liquidity.   No swap is possible as there is no liquidity.  A user can also disable swaps by initializing the pool with a small amountsIn, where the HODL balance rounds down to 0. Assuming there is a pool of two tokens with 18 decimals, due to the following behavior of the _onInitializePool:   User initializes with amountsIn = [1 wei, 1 wei].   After scaleUp, amountsIn = [1 wei, 1 wei] because the tokens already have 18 decimals.  the HODL balance is computed as 1 * 10^18 / (100 * 10^18), which rounds down to 0.  If both hold balances are 0, the _updatePerformace and _getPerfAndTargetDev will revert due to the division by 0.    A  check  was  added  in  the  _onInitializePool()  function,  that  requires  both  amountsIn[0]  and amountsIn[1]  to  be  at  least  _MIN_INITIAL_BALANCE  =  1e8.  This  way,  issues  due  to  division  by zero will be avoided.  Swaap Labs - SafeguardPool -   15  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                   \f6.5   Balance Based Penalty Can Be Manipulated  In  case  the  current  pool  balance  is  less  than  the  pool  balance  at  the  quote  time,  a  penalty  will  be enforced on the quote price during a swap. However, the balance of the pool can be easily manipulated by Join or Exit.  In case there is a balance based penalty, a user can bypass it by Just In Time (JIT) liquidity provision:  CS-SLSGP-001   Join the pool to push the balance back to quote time.   Swap without balance based penalty.   Exit after the swap.  By having a valid quote and doing join-swap-exit bundle, users can bring the state of the pool balances in a  state,  where  other  \"pending\"  quotes  are  blocked  by  the  balance  based  penalty.  Thus,  using join-swap-exit bundle user can:   Bypass paying the balance based penalty fees   Avoid the maxDeviation check.  However, in join-swap-exit the user will only get fraction of the maxSwapAmount total swap value, due to the need to provide out token as an asset during join.  A swap can also be front-run by a liquidity provider's exit, which aggravates the balance based penalty. This way an exit-swap-join, (swap is sandwiched by malicious LP) can:   Revert the swap   Enforce the higher balance penalties on the swap.  This  can  be  seen  as  a  DoS  attack,  however  it  requires  significant  gas  with  no  clear  benefit  for  the attacker.    Swaap Labs responded:  The new balance based penalty also takes into consideration the balance change per PT as well as the balance change: penalty = max(balanceChange, balanceChangePerPT) * slippage  Since  joins  and  exits  do  not  change  the  balances  per  PT,  this  check  will  not  be  bypassable  by join-swap-exit bundle. Thus, swaps with quoted balances that differ too much from the onchain conditions will not be executable.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Price Feed Data Validity Checks", "body": "  SafeguardPool  uses  chainlink  oracle  to  retrieve  the  price  feed  for  tokens.  However  the  checks  in ChainlinkUtils.getLatestPrice are missing or not strong enough:  CS-SLSGP-005   _ORACLE_TIMEOUT  is  a  constant  of  1.5  days  which  could  be  too  large.  The  heartbeat  of  most datafeeds  smaller: https://docs.chain.link/data-feeds/price-feeds/addresses#Ethereum%20Mainnet. Any  round  that  is  older  than  the  Heartbeat  cannot  be  considered  fresh.  This  might  happen  due  to potential ChainLink failures.  much   is   Swaap Labs - SafeguardPool -   16  DesignLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected              \f ChainLink  getLatestRound  returns  roundId  and  answeredInRound.  However,  they  are  not inspected. In ChainLink OCR pricefeeds the roundId and answeredInRound are always equal. However, older versions of pricefeeds require validation, that the round data was not computed in an old  roundId): https://docs.chain.link/data-feeds/historical-data#getrounddata-return-values.  Please  be  aware  of this and check for each deployed pool what pricefeed version is used.  round(answeredInRound   should   than   less   not   be     Swaap Labs responded:  Each oracle in a pool has its own maximum timeout (=< 1.5 days) which is immutable and defined at deployment time. The roundId and answeredInRound are checked .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Events Indexed Params", "body": "  The quoteIndex in ISignatureSafeguard is not indexed. It functions as a random-order nonce for quote signatures. Querying on-chain information about which quote is exhausted is easier if this field is indexed.  CS-SLSGP-013  event SwapSignatureValidated(bytes32 digest, uint256 quoteIndex); event AllowlistJoinSignatureValidated(bytes32 digest);  Similarly, digest params in both events can be indexed.    quoteIndex as well as digest of both events has been marked as indexed in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Outdated Dependency of Balancer Pool", "body": " Factory  CS-SLSGP-011  One of SafeguardPool's dependency Balancer's BasePoolFactory has been updated in March where create2()  found  here: https://github.com/balancer/balancer-v2-monorepo/pull/2362  instead  of  create().  The   request  can  be   full  merge   is  used     Balancer dependency is updated. CREATE2 opcode with an extra salt parameter is now used to deploy the pools.  Swaap Labs - SafeguardPool -   17  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f6.9   Performance Safeguard Sensitivity  The  HODL  balances  are  set  on  initializing  pool,  and  during  the  updates  they  are  multiplied  by performance.  This  effectively  fixes  during  the  initialization  the  proportion  of  assets  that  are  used  for performance  safeguard.  If  the  price  of  assets  changes  significantly  over  time,  the  difference  between balance0/balance1 and hodlBalance0/hodlBalance1 can cause significant sensitivity to price changes. In addition, this imbalance can be caused intentionally during the initialization.  CS-SLSGP-007  For example:  1. Pool initialized with 1 Eth and 100k USD as assets. The hodlBalanceETH = 1, hodlBalanceUSD = 100k.  Assume  that  BPT  is  always  1.  At  this  time  1  ETH  ==  1000  USD.  TLV  =  101000  USD  == holdTVL  2. Over time, with help of swap the balance of pool becomes: 50 ETH and 1000 USD, with 2000 USD as  ETH  price.  TLV  =  101000  USD.  old  hodlTVL  =  1100  Since  TVL  does  not  change,  the holdBalanes will not change as well.  3. Without any balance changes, if price of ETH becomes 1900 USD == 5% drop: TLV = 96k USD.  hodlTVL = 101900. newTVL/hodlTVL = 0.942 > 5% drop  Thus, due to the initial proportion of hold balances the hodl performance of the pool was affected more than the asset price. Also, note that the balances of tokens itself did not change between 2 and 3. Just the change of the oracle price can be enough to make swaps fail due to the performance safeguard.    Swaap  Labs  have  updated  the  code  that  the  performance  safeguard  will  be  bypassed  if  a  swap  is rebalancing the current pool towards the hodl balance ratio.  if (newBalancePerPTOut < hodlBalancePerPTOut || newBalancePerPTIn > hodlBalancePerPTIn) {    _srequire(          _getPerfFromBalancesPerPT(newBalancePerPTIn,newBalancePerPTOut,             hodlBalancePerPTIn,hodlBalancePerPTOut,onChainAmountInPerOut          ) >= _getMaxPerfDev(packedPoolParams),          SwaapV2Errors.LOW_PERFORMANCE    ); }  Swaap Labs stated:  The idea is to allow the rebalancing of assets even if we do not have good performance in order not to find the pool stuck with undesired asset ratios.  Swaap Labs - SafeguardPool -   18  InformationalVersion1CodeCorrected    \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Imbalanced Join Order", "body": "  User  can  call  _joinExactTokensInForBPTOut()  to  join  the  pool  in  an  imbalanced  way.  There  are two approaches to achieve the same imbalanced join:  1. excess tokens are swapped for limited tokens first, then a balanced join is executed.  2. a balanced join is executed first, then do a swap to achieve the same result.  SafeguardPool  takes  the  first  approach.  However,  as  the  pool  balance  at  swap  time  is  smaller  in approach  1  compared  to  approach  2,  it  could  induce  higher  balance  based  penalty  and  consequently prevent a transition that actually benefits the system.  CS-SLSGP-006  Acknowledged:  Swaap Labs responded:  We  chose  to  keep  this  approach  as  it  is  easier  to  produce  a  quote  for  this  kind  of  operation  &  it\u2019s more gas efficient and easier to check the post trade safeguards. In addition a user can separately swap and then join the pool even if we change the approach.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Invalidation of Quotes", "body": "  The  signed  quotes  remain  valid  until  they  are  either  executed  or  reach  their  deadline.  No  functionality allows  a  specific  quote  to  be  invalidated.  However,  changing  the  signer  will  invalidate  all  previously signed quotes. In case the signer role holder is changed from Alice to Bob and then back to Alice, all the un-expired  quotes  Alice  signed  before  will  become  valid  again.  These  facts  must  be  considered throughout the contract's lifespan.  CS-SLSGP-009  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Management Fees and Swap Safeguards", "body": " Relation  The  _claimManagementFees  is  called  before  any  swap  or  join,  but  not  during  the  swaps.  This  can affect the safeguard that rely on per PT values. E.g. if _claimManagementFees is called after a long period, the hodl balances per pt will drop, due to newly minted PT shares. Then, the safeguards can fail  CS-SLSGP-010  Swaap Labs - SafeguardPool -   19  InformationalVersion1AcknowledgedInformationalVersion1InformationalVersion1            \funtil next snapshot of the hodl balances. Due to the low rate of management yearly fees (5%), this should not be a problem.  Swaap Labs - SafeguardPool -   20  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Consistency of Input Arguments Scale", "body": "  Most of the computations work with values of 18 decimals. Input amounts for tokens that have less than 18 decimals will be first scaled up by a scaling factor to reach 18 decimals. In SafeguardPool, some of the input argument amounts are expected to be already scaled up, while the others (mostly coming from Vault) are not.  Examples of such differences:  In _onInitializePool(), amountsIn in userData needs to be not upscaled.  In _joinExactTokensInForBPTOut(), joinAmounts in userData needs to be already scaled up.  In _exitBPTInForExactTokensOut(), exitAmounts in userData needs to be already scaled up.  onSwap(),   In  quote.maxSwapAmount needs to be upscaled.  SwapRequest.amount   needs   to   be   not   upscaled,   however  Scaling  the  value  off-chain  is  gas-efficient,  but  requires  the  correct  input  data  generation.  If  directly submitting a transaction to the contract, users should be aware of which parameters should be scaled up and which should not.  Swaap Labs - SafeguardPool -   21  NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Missing Event for poolCreator Update", "body": "  The functions that allow an update of the pool creator perform important state change without emitting an event.  Acknowledged:  MYSO  Finance  has  acknowledged  this  issue,  but  has  decided  to  keep  the  functions  as-is  due  to limitations on the code size.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Gas Optimizations", "body": "  1. State  variables  r1,  r2,  liquidityBnd1,  liquidityBnd2,  and  minLoan  are  set  in  the constructor and are read-only afterwards, thus they can be declared as immutable to save gas.  2. In function removeLiquidity, the SLOAD to access totalLiquidity when emitting the event  could be avoided if memory variables are used.  3. In function borrow, the storage field totalLpShares is passed to updateAggregations. Even if  it  is  a  hot  address,  accessing  it  again  costs  100  gas,  a  memory  variable  would  be  more  MYSO Finance - Core Protocol V1 -   12  DesignCorrectnessCriticalHighMediumLowAcknowledgedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedRiskAcceptedRiskAcceptedAcknowledgedAcknowledgedDesignLowVersion3AcknowledgedDesignLowVersion2CodePartiallyCorrectedAcknowledged                        \fefficient as MLOAD costs 3 gas. It is also the case for loanIdx in the borrow function and in the rollOver function.  4. rollOver  function  computes  _sendAmount  -  getLoanCcyTransferFee(_sendAmount)  multiple times. Storing the result in a memory variable will save gas.  5. In  function  updateAggregations,  repaymentUpdate  is  always  computed  but  is  only  needed  when _isRepay is true.  6. In   ,  the  constant  variable  treasury  was  changed  into  a  state  variable  poolCreator  which could be declared as immutable.  7. In   , function borrow performs an unnecessary SLOAD to get the loan index when emitting  the event Borrow.  Code partially corrected:  3. The storage variables totalLpShares and loandIdx are stored in memory variables.  4. The logic has been moved in function checkAndGetSendAmountAfterFees and the result of the  subtraction is cached.  Acknowledged  MYSO Finance replied:  We acknowledge that certain variables could be made immutable and also within functions a few cases where storing a repeatedly used variable as a memory variable would also save gas, but we were running against byte code limits and stack too deep errors, and instead of significantly refactoring, we decided against implementing many of the optimizations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Force Other LPs to Sell Cheap Loans", "body": "  Liquidity providers have the guarantee that they receive a minimum interest (flat rate r2) from the repaid loans.  If  there  is  enough  demand  for  borrowing  from  a  pool,  the  interest  rate  goes  up  which  makes  it more attractive for LPs to provide liquidity into it. However, one can implicitly force LPs to lend tokens at a lower interest rate. To achieve that, an attacker needs to add liquidity into a pool and then borrow.  For example, if the available liquidity in a pool is between liquidityBnd1 and liquidityBnd2, the attacker  adds  enough  liquidity,  so  the  interest  rate  gets  lowered.  Taking  a  loan  immediately  after  this operation, the attacker consumes part of its liquidity and part of other LPs liquidity with a lower interest rate than the market rate. The attacker borrows enough tokens such that the interest rate is back to the one  before  the  attack  started.  This  way,  the  liquidity  added  by  the  attacker  is  not  exposed  to  lower interest rates, while other LPs effectively were forced to sell loans with low interest rates.  Code partially corrected:  MYSO Finance implemented two mitigation measures to reduce the likelihood of such attacks:  1. Smart contracts (or EOA) cannot add liquidity and borrow from the pool in the same transaction (or block), as functions addLiquidity and borrow track tx.origin. This complicates but Instead  of  using does  not  eliminate   the  attack  described  above.   risk  of   the   MYSO Finance - Core Protocol V1 -   13  Version2Version3DesignLowVersion1CodePartiallyCorrectedRiskAccepted          \fone single contract to atomically provide liquidity and borrow, an attacker would need to take the risk of carrying the attack non-atomically, or use flashbots, which require more work.  2. Increase  the  minimum  LP-ing  period  from  30sec  to  120sec  to  increase  the  exposure  of  the  attacker's liquidity to the same attack vector.  Risk accepted:  MYSO Finance is aware that the attack is inherent to the system's architecture and states that the two mitigation measures described above will reduce the likelihood of such attacks but not fully prevent them. Furthermore, the attack does not lower the interest rates below the flat rate of a pool (r2), hence LPs still earn a minimum yield.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Optimizations at the Cost of Added", "body": " Complexity  The  function  updateLpArrays  considers  7  different  cases  when  an  LP  updates  its  position  and optimizes the storage usage by avoiding storing redundant data. This optimization of the storage comes with added complexity in the logic of the function updateLpArrays although the majority of cases (4 out of 7) are expected to happen rarely.  Risk accepted  The  client  accepts  the  risk  associated  with  the  code  complexity  to  optimize  storage  gas  costs  and  will consider refactoring the function in a future version of the codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   Rollover Not Allowed in Certain Situations", "body": "  Function  rollOver  in  BasePool  reverts  if  a  borrower  renews  its  loan  and  the  new  loan  amount  is higher  than  the  repayment  of  the  previous  loan.  This  might  be  the  case  if  the  pool  has  more  available liquidity when rollover happens than when the loan was initially taken. The restriction is enforced in the following check:  if (loanAmount >= loanInfo.repayment) revert InvalidRollOver();  Acknowledged  MYSO Finance has decided to keep the code unchanged as this scenario is expected to happen rarely, and users still have an alternative to perform the same operation, as explained in their response:  For bytecode reasons we refrained from supporting this use case as it would require an additional if-else to distinguish between calling transferFrom (regular case where borrower pays to rollOver) and transfer (rare case where borrower receives a refund). The situation where a rollOver would lead to a refund is expected to occur - if at all - rather rarely, hence not supporting it isn\u2019t deemed a significant loss in functionality. Moreover, if necessary a borrower could also independently emulate a rollOver for this situation by atomically repaying and borrowing using a flashloan.  MYSO Finance - Core Protocol V1 -   14  DesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                \f5.6   Unclaimed Tokens Remain Locked  Liquidity  providers  specify  the  loan  indices  for  their  claims  and  are  allowed  to  skip  loans  that  are  not sufficiently profitable. Once an LP skips a loan, it cannot claim it anymore. Hence, a pool continuously holds loan and collateral tokens amounts that cannot be claimed by LPs and are locked. The only way to recover  loan  token  funds  is  if  all  LPs  remove  their  liquidity  from  a  pool  (totalLpShares  ==  0)  and then  one  adds  liquidity  which  triggers  the  transfer  of  dust  to  the  treasury.  However,  there  is  no  way  to recover collateral amounts left in the pool from skipped claims.  Acknowledged  MYSO  Finance  acknowledges  the  issue  and  does  not  plan  on  adding  a  functionality  to  track  the unclaimed loans as it would increase significantly the gas costs. However, MYSO Finance will simplify the UI for claiming and promote aggregate claims to reduce the number of unclaimed loans.  MYSO Finance - Core Protocol V1 -   15  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  4  10  -Severity Findings  -Severity Findings  -Severity Findings   Mismatch of Implementation With Specification    Missing Loan Owner Sanity Check When Borrowing    Protocol Fee Computation Can Overflow    Total LP Shares Are Capped in Pools   -Severity Findings   Emission of ApprovalUpdate Event Can Be Tricked    Deletion of Timestamps From Mapping    Redundant Events Emitted    Disabled Optimizer   Inaccessible TREASURY Account   Insufficient Check for Minimal Loan Given Total LP Shares   Inverted NewSubPool Event Token Fields    Misleading ApprovalUpdate Event    Missing Precision of Pool Parameters    Non-indexed Events   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Mismatch of Implementation With", "body": " Specification  The specifications of the borrow function state:  In this case the collateral is deducted from the 3rd party ``msg.sender`` address but the ``_onBehalfOf``  address receives the loan and is registered as the loan owner (including the ability to repay and reclaim the pledged collateral).  However,  the  function  takes  the  collateral  from  msg.sender  and  also  sends  the  loan  amount  to msg.sender in violation with the specifications:  IERC20Metadata(collCcyToken).safeTransferFrom(msg.sender, address(this), _sendAmount); ... IERC20Metadata(loanCcyToken).safeTransfer(msg.sender, loanAmount);  MYSO Finance - Core Protocol V1 -   16  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged           \fSpecification changed  The specification in section 'Calling Functions on Behalf' of the gitbook has been revised to reflect the code behavior:  In this case the collateral is deducted from msg.sender and msg.sender also receives the loan but the_onBehalfOf address is registered as the loan owner (including the ability to repay and reclaim the pledged collateral). This allows wrapping and unwrapping of tokens through a peripheral contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Missing Loan Owner Sanity Check When", "body": " Borrowing  A borrower can take a loan on behalf of anyone without restriction and this can result in the loan never being repaid. If a borrower calls borrow with an _onBehalf address they do not control or is aware that it will be the owner of a loan, the loan will default since the borrower is not the loan owner and is probably not allowed to repay it. E.g., borrow is called with _onBehalf=address(0), then the loan will default for sure.  Code corrected  The function borrow has been updated to perform a sanity check that address _onBehalf is not set to addr(0)  by  mistake.  However,  the  caller  is  still  responsible  for  providing  a  correct  address  for _onBehalf which repays the loan if required.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Protocol Fee Computation Can Overflow", "body": "  The  protocol  fee  computation  in  loanTerms  can  overflow  if  the  protocolFee  is  non-zero.  The multiplication in _protocolFee = uint128((_inAmountAfterFees * protocolFee) / BASE) is carried in uint128 and might overflow. Example is with protocolFee = 5 * 10**5 which is also the maximum allowed fee and _inAmountAfterFees=uint128(uint256(2**128) / uint256(5 *10**15))+1=68056473384187692692675  which  may  seem  to  be  a  lot  but  could  be  a  realistic amount for collateral tokens with 18 decimals and low value.  Code corrected  In the second version of the codebase, the variable protocolFee was renamed creatorFee and its type  was  changed  to  uint256  to  avoid  possible  overflows  in  the  computation  highlighted  in  the  issue above.  MYSO Finance - Core Protocol V1 -   17  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \f6.4   Total LP Shares Are Capped in Pools  The  function  _addLiquidity  performs  two  checks  to  guarantee  that  an  LP  will  get  non-zero  token amounts from a small loan, both on repay and default. The checks are implemented as follows:  if (     ((minLoan * BASE) / totalLpShares) * newLpShares == 0 ||     (((10**COLL_TOKEN_DECIMALS * minLoan) / maxLoanPerColl) * BASE) /         totalLpShares == 0 ) revert PotentiallyZeroRoundedFutureClaims();  The  first  condition  evaluates  to  true  whenever  totalLpShares  >  minLoan  *  BASE.  Since  both minLoan and Base are fixed for a pool, the totalLpShares is capped for a pool.  Similarly, the second condition evaluates to true whenever totalLpShares > ((10**COLL_TOKEN_ DECIMALS  *  minLoan)  /  maxLoanPerColl)  *  BASE)  sets  another  restriction  on  the  maximum totalLpShares.  Capping  the  totalLpShares  prevents  adding  liquidity  to  pools  that  are  attractive  to  users  and  have high activity.  Specification changed  The  specifications  have  changed  and  the  checks  described  above  have  been  removed,  hence  the unintended capping on total LP shares is not present anymore.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Emission of ApprovalUpdate Event Can Be", "body": " Tricked  There is no restriction on the parameter _packedApprovals of function setApprovals. One could set the 6th bit to 1 even if no approval is updated and the event will be emitted. Moreover, if bits higher than the 6th are set, they will be shown in the emitted event.    The input parameter _packedApprovals has been sanitized to consider only the 5 least significant bits.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Deletion of Timestamps From Mapping", "body": "  The timestamp stored in lastAddOfTxOrigin are never deleted from the mapping although they are used  only  to  disallow  LPs  from  adding  liquidity  and  borrowing  in  the  same  block.  The  entries  of  this mapping can be deleted, e.g., when LP remove their liquidity, to get gas refunds.    MYSO Finance - Core Protocol V1 -   18  DesignMediumVersion1Speci\ufb01cationChangedDesignLowVersion3CodeCorrectedDesignLowVersion2CodeCorrected                      \fThe entry for an address in the mapping lastAddOfTxOrigin is deleted when liquidity is removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Redundant Events Emitted", "body": "  The function setApproval iterates through all approval types and emits an event independently if an approval  status  is  updated  or  not.  Therefore,  even  if  only  one  approval  type  is  changed  for  an _approvee, five events will be emitted.  Code corrected  Function setApproval has been updated to emit the event when at least one of the approvals changes state.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Disabled Optimizer", "body": "  In  hardhat.config.js  the  optimizer  is  not  explicitly  enabled  and  the  default  value  for  hardhat  is enabled: false. Enabling the optimizer may help to reduce gas cost.  Code corrected  The optimizer has been enabled and the runs are set to 1000.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Inaccessible TREASURY Account", "body": "  TREASURY   The  to declared  0x1234567890000000000000000000000000000001  which  is  not  in  the  control  of  the  developers, hence  all  protocol  fees  collected  by  the  system  will  be  locked  forever.  MYSO  Finance  is  aware  of  this issue and will use a multisig account for the treasury on deployment.  constant   address   and   set   as   is   Code corrected  The constant variable TREASURY is replaced with the state variable poolCreator which is assigned to msg.sender in constructor.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Insufficient Check for Minimal Loan Given", "body": " Total LP Shares  The second condition in the following code is supposed to check that repayment amount for a loan is big enough that all LPs can claim non-zero amounts if the loan is repaid given their share:  MYSO Finance - Core Protocol V1 -   19  DesignLowVersion2CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChanged                                \fif (     ... ||     ((repaymentAmount * BASE) / totalLpShares) == 0 ) revert ErroneousLoanTerms();  The  check  might  not  work  as  intended  for  loan  tokens  with  low  decimals,  e.g.,  USDC  (6  decimals),  as BASE  is  a  constant  with  value  10**18.  For  example,  if  repaymentAmount  is  10**7  (10  USDC)  and totalLpShares is 10**8 (2 LPs with 5 * 10**7 shares each) the check would still pass.  Specification changed  MYSO Finance has changed the specifications and decided to remove the check above as it effectively would increase the minimum loan amount over time as total LP shares increase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Inverted NewSubPool Event Token Fields", "body": "  The  NewSubPool  event  definition  in  IBasePool.sol  specifies  that  the  first  two  fields  are collCcyToken and loanCcyToken, but when the event is emitted in the constructor, the two fields are set to _loanCcyToken and _collCcyToken.  Code corrected  The definition of event NewSubPool in IBasePool is updated and the parameters are in line with the code that emits the event:  event NewSubPool(     address loanCcyToken,     address collCcyToken,     ... );  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Misleading ApprovalUpdate Event", "body": "  The function setApprovals emits an event only when an approval type is set to true, even if it was previously the case, and nothing is emitted when an approval is unset. An example is: current approvals are  10101  and  the  updated  approvals  are  10100.  The  event  is  misleading  in  the  sense  that  it  will  be emitted for indices 0 and 2, which have not been updated, and no ApprovalUpdate event is emitted for the actual update of the index 4.  Code corrected  The event Approval is now emitted for every index with the status true or false and independently if it was changed from the previous state.  MYSO Finance - Core Protocol V1 -   20  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.13   Missing Precision of Pool Parameters  The  documentations  and  inline  specifications  do  not  describe  the  precision  of  the  pool  parameters.  To improve  the  readability  of  the  code  and  avoid  possible  mistakes,  the  decimals  used  for  all  pool parameters such as r1, r2, liquidityBnd1 and liquidityBnd2 should be stated clearly.  Code corrected  Inline  code  comments  were  added  for  the  variables  mentioned  above,  which  specify  the  precision  of expected values:  uint256 r1; // denominated in BASE and w.r.t. tenor (i.e., not annualized) uint256 r2; // denominated in BASE and w.r.t. tenor (i.e., not annualized) uint256 liquidityBnd1; // denominated in loanCcy decimals uint256 liquidityBnd2; // denominated in loanCcy decimals  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Non-indexed Events", "body": "  No  parameters  are  indexed  in  the  events  of  contracts  BasePool.  It  is  recommended  to  index  the relevant event parameters to allow integrators and dApps to quickly search for these and simplify UIs.  Code corrected  MYSO  Finance  has  evaluated  the  events  used  in  BasePool  and  has  indexed  parameters  that  they deem useful for future UI and dashboard integrations.  Several events such as NewSubPool and Approval have non-indexed parameters, however, the client intentionally kept them unchanged.  MYSO Finance - Core Protocol V1 -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   LP Shares Dilute Over Time", "body": "  The shares of an LP dilute over time as more activity happens in a pool by users that borrow and LPs that add more liquidity. Therefore, LPs should monitor their proportion of LP shares to the total LP shares and  remove  their  liquidity  from  a  pool  when  their  share  to  loan  repayments  or  collateral  becomes insignificant.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   LPs Get Slightly Less Token for Their Shares", "body": "  The pool keeps a minimum of loan tokens and it does not allow LPs to fully empty a pool. When removing liquidity, LPs get slightly less tokens than their fair share to maintain the minimum liquidity in the pool. The relevant code is:  uint256 liquidityRemoved = (numShares *     (_totalLiquidity - MIN_LIQUIDITY)) / _totalLpShares;  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   LPs Should Be Careful When Claiming", "body": "  function  claim  or LPs  can  claim  repayments  and  collateral  claimFromAggregated.  It  is  important  to  note  that  LPs  are  responsible  for  claiming  loans  always  in order. Otherwise, any loan skipped during a claim is impossible to be claimed in the future.  their  share  of   tokens  via   Furthermore,  LPs  can  skip  all  loans  during  a  time  window  via  the  function  overrideSharePointer. Similarly,  if  an  LP  calls  this  function,  they  cannot  claim  anymore  the  repayments  and  collateral  for  all loans linked with the skipped shares.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Limitations on Claiming Batch of Loans", "body": "  Both functions claim and claimFromAggregated allow LPs to claim loans in batches over a period during  which  the  LP  has  not  changed  its  shares  in  a  pool.  LPs  should  be  aware  that  modifying  their position in a pool by topping up or removing liquidity, will require them to perform multiple transactions for the claiming which increases gas costs and potentially prevents LPs from using aggregate claims.  MYSO Finance - Core Protocol V1 -   22  NoteVersion2NoteVersion1NoteVersion1NoteVersion1                \f7.5   Locked Tokens  ERC20 tokens could be accidentally/intentionally sent to the pool contracts. In that case the tokens will be  Incidents (https://coincentral.com/erc223-proposed-erc20-upgrade/) in the past showed this is a real issue as there always will be users sending tokens to the token contract.  recover   locked,   them.   with   way   no   to   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Minimum Loan Amount Allowed", "body": "  The constructor of BasePool does not enforce any restriction on the minimum allowed amount for loans. Therefore, the pool deployer should carefully set this value depending on the specific token used as loan token.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Positions in a Pool Are Non Transferrable", "body": "  All positions in pools held by liquidity providers or borrowers are tracked in the contract BasePool and they  are  non-transferable.  Users  can  approve  other  addresses  to  act  on  their  behalf,  but  there  is  no support for transferring ownership of positions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Possible to Overpay Loans", "body": "  Functions  repay  and  rollOver  check  that  the  user  always  pays  at  least  the  due  amount.  However, both  functions  allow  users  to  overpay  their  loans  by  1%  in  case  users  cannot  precisely  calculate  the sending amount for tokens with transfer fees.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.9   Profits of a Pool Are Not Equally Distributed", "body": "  The  profits  of  a  pool  from  loan  repayments  are  not  equally  distributed  among  liquidity  providers.  The system  is  designed  such  that  profits  for  an  LP  depend  on  loans  that  borrow  most  of  their  liquidity.  For example, if a pool starts with an interest i and over time the interest rate goes to 3 x i, initial LPs will earn payments from loans with interest i, while LPs joining later will have higher profits (as the interest rate tripled to 3 x i).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.10   Transfer Fee for Upgradable Tokens", "body": "  function  getLoanCcyTransferFee   The  is hard-coded to return 0 as fee for the loan token, namely USDC. We would like to highlight that the pools would not work as expected if upgradable tokens were to introduce fees in new implementations.  in  contracts  PoolPaxgUsdc  and  PoolWethUsdc   MYSO Finance - Core Protocol V1 -   23  NoteVersion1NoteVersion2NoteVersion1NoteVersion1NoteVersion1NoteVersion1                      \f7.11   if Blocks Without Curly Braces  It  is  generally  good  practice  to  enclose  every  if/else  block  into  curly  braces.  It  increases  code readability  and  lowers  possibilities  for  bugs  like  the  famous  goto  fail;  bug  in  Apple  SSL  code https://blog.codecentric.de/en/2014/02/curly-braces/.  MYSO Finance - Core Protocol V1 -   24  NoteVersion1    \f8   Monitoring  A thorough code audit is just one important part of a comprehensive smart contract security framework.  Next  to  proper  documentation/specification,  extensive  testing  and  auditing  pre-deployment,  security monitoring  of  live  contracts  can  add  an  additional  layer  of  security.  Contracts  can  be  monitored  for suspicious  behaviors  or  system  states  and  trigger  alerts  to  warn  about  potential  ongoing  or  upcoming exploits.  Consider  setting  up  monitoring  of  contracts  post-deployment.  Some  examples  (non-exhaustive)  of common risks worth monitoring are:  1. Assumptions made during protocol design and development.  2. Protocol-specific invariants not addressed/mitigated at the code level.  3. The state of critical variables  4. Known risks that have been identified but are considered acceptable.  5. External  contracts,  including  assets  your  system  supports  or  relies  on,  that  may  change  without  your knowledge.  6. Downstream  and  upstream  risks  -  third-party  contracts  you  have  direct  exposure  to  (e.g.  a  third  party liquidity pool that gets exploited).  7. Privileged functionality that may be able to change a protocol in a significant way (e.g. upgrade the  protocol). This also applies to on-chain governance.  8. Protocols  relying  on  oracles  may  be  exposed  to  risks  associated  with  oracle  manipulation  or  staleness.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Project-specific monitoring opportunities", "body": " We have identified some areas in Core Protocol V1 that would be well suited for security monitoring.  We classify these into two categories: invariants and suspicious changes. If an invariant of the system doesn't  hold  anymore,  there  has  been  unexpected  behavior  requiring  immediate  investigation.  If  a change of a suspicious condition has been observed, something has happened which could change the behavior of the system and requires timely investigation to ensure the continued safety.  The following monitoring opportunities have been identified:  suspicious   Identified  and getLoanCcyTransferFee are hardcoded to return a transfer fee of 0 for tokens that currently do not have  such  fees.  However,  for  upgradable  tokens  such  as  USDC,  this  could  change  in  new implementations, hence this change can be monitored and trigger an alert if fees ever change.  getCollCcyTransferFee   functions   change:   The   Identified suspicious change: All pools have a finite number of cycles for borrowing and adding liquidity until a potential overflow on the total LP shares may happen. Therefore, the value of totalLpShares can be monitored and trigger an alert if it becomes large enough to overflow, e.g., larger than 2**240, so a new pool can be deployed.  MYSO Finance - Core Protocol V1 -   25  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Preferential Withdrawal", "body": "  0  0  1  1  When there are more withdrawal requests than can be serviced, all users receive the same percentage of their withdrawals. A user that wants to make a partial withdrawal could take advantage of this.  Consider an example where withdrawal requests are fulfilled at 50%. A user that wants to withdraw 100 shares could instead request to withdraw 200 shares (given he has enough shares). Their request would be fulfilled by half, giving them 100 shares. Now they can cancel the remaining withdrawal request.  In  this  way,  the  user  was  able  to  circumvent  the  withdrawal  limit  at  no  cost.  Other  users  were  able  to withdraw fewer shares than they would have otherwise.  Risk accepted:  Avantgarde Finance states:  This is the intended behavior. Also note that redeemers who request to redeem more than they actually would like to redeem are risking that their entire requested amount be redeemed in full if the cap is not met, the cap is updated by the manager, or other redeemers cancel their requests.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   BondBuyer: Claims Involving Ether Track", "body": " Wrong Asset  Avantgarde Finance - Sulu Extensions IX -   11  DesignCorrectnessCriticalHighMediumRiskAcceptedLowAcknowledgedDesignMediumVersion1RiskAcceptedCorrectnessLowVersion1Acknowledged                  \fClaiming a position involving Ether will result in the wrong asset being added to the tracked assets of the vault. Note that the vault actually supports receiving Ether (it immediately wraps it as WETH).  Consider the parser of the SolvV2BondBuyerPosition:  else if (_actionId == uint256(ISolvV2BondBuyerPosition.Actions.Claim)) {         (address voucher, uint256 tokenId, ) = __decodeClaimActionArgs(_encodedActionArgs);          ISolvV2BondVoucher voucherContract = ISolvV2BondVoucher(voucher);          uint256 slotId = voucherContract.voucherSlotMapping(tokenId);         ISolvV2BondPool.SlotDetail memory slotDetail = voucherContract.getSlotDetail(slotId);          assetsToReceive_ = new address[](2);         assetsToReceive_[0] = voucherContract.underlying();         assetsToReceive_[1] = slotDetail.fundCurrency;  For arbitrary vouchers, one of the assets may be Ether as Ether is technically supported by the Solv v2 smart contracts.  Solv v2 represents the Ether asset as \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" which in this case will be added to assetsToReceive. Within Enzyme, however, the correct asset to track in this case would be the address of WETH.  This results in an unsupported asset being tracked by a vault which may have severe consequences. For example, it breaks calcGav().  Whether  such  vouchers  actually  exist  depends  on  the  market  configurations  administrated  by  Solv Protocol. These markets may change in the future. Since the external position may interact with any offer on the IVOMarket / any voucher, such an issue may arise.  The InitialVoucherOfferingMarket currently doesn't support to create offers with Ether as underlying since offer()  misses  the  payable  modifier.  Note  that  the  implementation  otherwise  supports  the  case  to handle Ether.  The currency of a voucher may be Ether. Contrary to offer() buy() features the payable modifier and hence such vouchers can be bought successfully. Note that one can't buy such a position in Ether via the external position since it doesn't support providing ERC20 tokens. This however doesn't prevent all  scenarios  where  claim()  may  return  Ether  as  such  an  NFT  may  be  transferred  directly  to  the external position.  Acknowledged:  Avantgarde Finance states:  While ETH can technically be the currency of the offer, Solv\u2019s refund logic depends on it being a stablecoin: https://github.com/solv-finance/solv-v2-ivo/blob/ ac12b7f91a7af67993a0501dc705687801eb3673/vouchers/bond-voucher/ contracts/BondPool.sol#L174  Avantgarde Finance - Sulu Extensions IX -   12    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings  0  0  0  0  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Missing indexed in Event", "body": "  The event initialized emitted in GatedRedemptionQueueSharesWrapperLib.init() contains the address of the VaultProxy. This field is not indexed, hence one can't easily search such events for a certain VaultProxy. Given that the Factory doesn`t implement access control when deploying new shares wrappers it may be helpful to have this field indexed so that one can more easily search the events.    The parameter of the event has been indexed.  Avantgarde Finance - Sulu Extensions IX -   13  CriticalHighMediumLowInformationalVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Number of Assets", "body": "  By design, the external position framework adds all assets specified as incoming assets to the tracked assets of the vault, regardless whether the vault has a non-zero balance at the end of the operation.  Notably ISolvV2BondBuyerPosition.Actions.Claim adds two assets as both may be received. In a corner case scenario, despite actually receiving one asset only, adding two may exceed the position limit and hence the operation fails.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   OpenZeppelin ERC20 Hooks", "body": "  The  GatedRedemptionQueueSharesWrapperLib  overrides  transfer()/transferFrom()  in  order  to validate the transfer (__preProcessTransfer).  The OpenZeppelin ERC20 implementation provides a hook, (_beforeTokenTransfer) which could be used  for  this.  Note  that  this  hook  is  also  executed  upon  minting/burning.  For  more  information  please refer to documentation of OpenZeppelin:   https://docs.openzeppelin.com/contracts/3.x/extending-contracts#using-hooks  Avantgarde Finance - Sulu Extensions IX -   14  InformationalVersion1InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Bond Buyer Requires Trusted Fund Manager", "body": "  Investors need to trust the fund manager to a certain degree.  fund  manager  can  always  drain   A  https://specs.enzyme.finance/topics/known-risks-and-mitigations#opportunistic-managers  through  bad   trades.  This   funds  e.g.   is  documented:  Note that this is amplified when a fund can use the SolvV2BondBuyer External Position: A malicious fund manager  may  create  an  IVO  offer  via  the  Solv  Protocol  with  a  very  high  lowestPrice  set  for  their collateral  asset.  Then  they  can  buy  this  offer  through  the  External  Position  and  never  pay  back  the principal to the Bond. This would leave the fund with a small amount of collateral, while the fund manager could keep all value that was in the fund.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Deployment of", "body": " GatedRedemptionQueueSharesWrapper  Anyone  may  deploy  a  GatedRedemptionQueueSharesWrapper  for  any  fund  through  the  factory.  This includes setting the initial configuration. For example, a deployer can set themselves as manager.  Users and fund owner should be aware and excercise extra caution. The owner of a fund has full control over any such GatedRedemptionQueueSharesWrapper and can reconfigure it.  Multiple SharesWrapper can be deployed for the same fund. Note that they all bear the same name and symbol.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   Kick Ignores Redemption Limit", "body": "  The kick function in the shares wrapper allows an admin to immediately force a user redemption. This ignores the redemption limit.  Note that the limit of other users' withdrawals is not reduced by this, so the maximum redeemed amount in that period can be the redemption limit, plus any kick actions in addition.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Redemption Requests Not Always Possible", "body": "  Note  that  redemption  requests  to  the  shares  wrapper  can  only  be  made  outside  of  the  redemption window.  Avantgarde Finance - Sulu Extensions IX -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fThe comments in the code suggest that window frequency could be chosen every 2 weeks and duration 1 week:      struct RedemptionWindowConfig {     uint64 firstWindowStart; // e.g., Jan 1, 2022; as timestamp     uint32 frequency; // e.g., every 2 weeks; in seconds     uint32 duration; // e.g., 1 week long; in seconds     uint64 relativeSharesCap; // 100% is 1e18; e.g., 50% is 0.5e18 }  With these settings, users would only be able to make redemption requests half of the time. If a user is unlucky,  they  would  need  to  wait  for  an  entire  week  until  they  can  make  a  transaction  that  does  not revert.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   Vault May Track Unsupported Assets", "body": "  The external position framework relies on the parser of the external position to check the assets returned as _assetsToReceive. The code of the external position framework doesn't do any checks itself and simply  adds  any  asset  to  the  tracked  assets  of  the  vault.  Note  that  this  is  also  independent  of  the balance.  VaultLib.__callOnExternalPosition():  function __callOnExternalPosition(     address _externalPosition,     bytes memory _actionData,     address[] memory _assetsToTransfer,     uint256[] memory _amountsToTransfer,     address[] memory _assetsToReceive ) private {     require(         isActiveExternalPosition(_externalPosition),         \"__callOnExternalPosition: Not an active external position\"     );      for (uint256 i; i < _assetsToTransfer.length; i++) {         __withdrawAssetTo(_assetsToTransfer[i], _externalPosition, _amountsToTransfer[i]);     }      IExternalPosition(_externalPosition).receiveCallFromVault(_actionData);      for (uint256 i; i < _assetsToReceive.length; i++) {         __addTrackedAsset(_assetsToReceive[i]);     } }  ...2e42850b7bbc2237618c38fb01e767d14b606e00      function __addTrackedAsset(address _asset) private notShares(_asset) {     if (!isTrackedAsset(_asset)) {         __validatePositionsLimit();          assetToIsTracked[_asset] = true;         trackedAssets.push(_asset);          emit TrackedAssetAdded(_asset);     } }  Avantgarde Finance - Sulu Extensions IX -   16  NoteVersion1    \fThe SolvV2BondBuyerPositionParser doesn't check these assets sufficiently:  else if (_actionId == uint256(ISolvV2BondBuyerPosition.Actions.Claim)) {             (address voucher, uint256 tokenId, ) = __decodeClaimActionArgs(_encodedActionArgs);              ISolvV2BondVoucher voucherContract = ISolvV2BondVoucher(voucher);              uint256 slotId = voucherContract.voucherSlotMapping(tokenId);             ISolvV2BondPool.SlotDetail memory slotDetail = voucherContract.getSlotDetail(slotId);              assetsToReceive_ = new address[](2);             assetsToReceive_[0] = voucherContract.underlying();             assetsToReceive_[1] = slotDetail.fundCurrency;         }  A voucher's underlying and fundCurrency may be any asset the IVO market supports. There is no check that the fundCurrency is an asset supported by Enyzme. If the position was bought through the external position,  it's  likely  that  the  underlying  is  supported  (else  it  couldn't  have  been  bought.)  Note  that  Solv Bond  Voucher  NFT  positions  may  be  transferred  to  an  external  position  and  consequently  one  cannot rely on the underlying to be supported.  Even when no value is returned in the specific asset, the asset is still added as tracked asset.  Similarly this situation may arise in the SolvV2BondIssuerPosition: CreateOffer() only validates that the received currency is not the native token (Ether). There is no further check on this asset which will be incoming to the vault upon reconcile().  It's unclear if Enyzme supports all possible assets by default (e.g. also when new assets are added by Solv).  Unsupported  assets  tracked  by  a  vault  may  have  severe  consequnces  as  they  break  e.g. calcGav().  It's the fund manager's responsibility to be aware and to act appropriately.  Avantgarde Finance - Sulu Extensions IX -   17  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Funds Can Avoid Paying Protocol Fees", "body": "  Consider a fund that has not enabled autoProtocolFeeSharesBuyback and assume that over time the protocol fee reserve has accrued a sizeable amount of shares of this fund.  The fund, through its manager, can avoid paying protocol fees by employing the following vector:  1. Move  all  assets  of   the CompoundDebtPosition  available  as  an  external  position,  this  means  exchanging  all  of  the vaults holdings into a cToken and transferring it to the external position.  to  an  external  position.  Currently,  with  only   the  vault   2. Remove the external position. Note that, at this point, the GAV of the fund is close to 0.  3. Call buyBackProtocolFeeShares which calculates a really low price per share. This means that only a small amount of MLN tokens needs to be burnt to burn the protocol fee shares and, thus, pay back the fee.  4. Reactivate the external position and move the funds back.  Note that a similar vector can be used by the fund manager to avoid minting protocol fees while migrating or reconfiguration the fund.  The opportunistic behavior of the manager against the users of the fund is well documented. However, adversarial actions against the protocol are not mentioned.  Note that the underlying problem, a manipulated lower GAV due to hiding assets of the fund in a removed external position can also be abused by the fund manager to buy shares for a low price.  Acknowledged:  Avantgarde Finance - Enzyme Protocol v4 Sulu -   11  DesignCorrectnessCriticalHighMediumAcknowledgedLowCodePartiallyCorrectedAcknowledgedAcknowledgedDesignMediumVersion1Acknowledged          \fAvantgarde Finance responded:  As  the  audit  team  importantly  noted,  this  issue  only  potentially  affects  the  protocol  fee  amount ultimately burned, and does not impact end users of the protocol. Hence, rather than changing the core contracts for this release to protect against the reported deviant behavior, we have decided to combine the monitoring of blatant protocol fee violations with potential on- and off-chain penalties.  Deviant  behavior  can  monitored  off-chain  by  comparing  each  shares  buyback  event  with  the  last known share price.  If the Council assesses that there is a blatant attempt to evade protocol fees, it would be possible, for example,  to  restrict  buying  back  shares  by  upgrading  the  ProtocolFeeReserveProxy  contract  to disallow particular funds.  We  can  reevaluate  for  subsequent  releases  whether  or  not  to  prevent  this  behavior  at  the  core protocol level.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Untracked WETH", "body": "  A  fund  owner  can  withdraw  the  Ether  that  has  been  deposited  to  the  paymaster  account  by  calling GasRelayPaymasterLib.withdrawBalance. At this point Ether will be transferred to the vault and wrapped into WETH. However, there is no guarantee that WETH is a tracked asset for the fund.  Code Partially Corrected:  When  ComptrollerLib.shutdownGasRelayPaymaster  is  called,  WETH  is  added  to  the  tracked assets.  Avantgarde Finance responded:  It is highly unlikely that a fund using a paymaster would not have WETH as a tracked asset. Still, we have added a call to track WETH as a tracked asset when shutdownGasRelayPaymaster() is called from the ComptrollerProxy. It is more difficult - and best not - to attempt to validate whether WETH is a tracked asset when calling withdrawBalance() directly from the paymaster lib, since it can be called after a fund has migrated to a new release, at which point, the interface of its new VaultLib should not be assumed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   AddressListRegistry Gas Inefficiency", "body": "  AddressListRegistry  stores  ListInfo  using  the  mapping  itemToIsInList.  The  type  of  the mapping is mapping(address => bool). However, it would be more gas efficient to set its type to address => uint256 which omits the masking operation required to handle the boolean values.  Acknowledged:  Avantgarde Finance responded:  We  acknowledge  the  technical  efficiency,  but  in  practice  the  gas  savings  is  insignificant  within  the context of the protocol, and the use of bool is more intuitive.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   12  CorrectnessLowVersion2CodePartiallyCorrectedDesignLowVersion2Acknowledged                  \f5.4   Redundant Check  In FundDeployer.__redeemSharesSetup, the following snippet exists:     } else if (postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance) {         ...         preFeesRedeemerSharesBalance.sub(postFeesRedeemerSharesBalance)     ); }  Note  case  postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance.  redundant   that   use   this   the   sub   of   in   is   since   it   holds:  Acknowledged:  Avantgarde Finance responded:  Currently,  we  generally  use  SafeMath  for  math  operations  rather  than  making  judgements  about where or where not to use it.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   13  DesignLowVersion1Acknowledged        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   redeemSharesForSpecificAssets Fails For Derivatives   -Severity Findings  Incorrect redemptionWindowBuffer Check    Shadowed Constant    Missing Indexes in Events   0  0  1  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   redeemSharesForSpecificAssets Fails For", "body": " Derivatives  In Sulu, users are allowed to redeem specific assets. According to the documentation:  The redeemer specifies one or multiple of the VaultProxy's ERC20 holdings along with the relative values of each to receive (for a total of 100%).  However,  if  an  ERC20  token  which  represents  a  derivative  is  specified  as  a  payout  asset  then  the redemption will fail. The call in __payoutSpecifiedAssetPercentages fails for non primitive assets due  the the  valueInterpreter:  the  calcCanonicalAssetValue  of   require  statement  shown  below   to   in   payoutAmounts_[i] = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(     denominationAssetCopy,     _owedGav.mul(_payoutAssetPercentages[i]).div(ONE_HUNDRED_PERCENT),     _payoutAssets[i] );  function calcCanonicalAssetValue(     ...      require(         isSupportedPrimitiveAsset(_quoteAsset),         \"calcCanonicalAssetValue: Unsupported _quoteAsset\"     );      ...  Note that simply removing the requirement is not enough since the ValueInterpreter can only handle conversions to primitive assets due to the implicit requirement that the quote asset has a Chainlink price feed.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   14  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected         \fCode Corrected:  ValueInterpreter.calcCanonicalAssetValue  now  supports  the  conversion  from  a  primative asset  to  a  derivative  asset.  This  is  done  by  calculating  the  price  of  the  derivative  asset  against  the primative one and the inverting.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Incorrect redemptionWindowBuffer Check", "body": "  Certain  actions  through  adapters  e.g.  exchanging  Synths  through  the  Synthetix  adapter  may  block  the transfer of the asset for a period of time. The GuaranteedRedemptionPolicy ensures that a redemption blocking  adapter  is  not  used  during  the  redemption  window  nor  a  buffer  period  before  the  start  of  the guaranteed redemption window. This ensures redemption is possible during a guaranteed time window every day.  uint256 latestRedemptionWindowStart = calcLatestRedemptionWindowStart(         redemptionWindow.startTimestamp     );  // A fund can't trade during its redemption window, nor in the buffer beforehand. // The lower bound is only relevant when the startTimestamp is in the future, // so we check it last. if (     block.timestamp >= latestRedemptionWindowStart.add(redemptionWindow.duration) ||     block.timestamp <= latestRedemptionWindowStart.sub(redemptionWindowBuffer) ) {     return true; } return false;  The comment describing the code is not entirely accurate. Three cases have to be distinguished  I. A fund can't trade during its redemption window  II.a. A fund can't trade in the buffer before the next redemption window  II.b.  If  startTimestamp  is  in  the  future,  a  fund  can't  trade  in  the  buffer  before  the  first  redemption window  Note  that  calcLatestRedemptionWindowStart()  returns  either  the  start  timestamp  of  the  latest redemption window or, in case startTimestamp is still in the future, the startTimestamp.  The  current  code  checks  condition  (I)  and  (IIb)  but  does  not  check  (IIa).  Hence,  in  case  we  are  past startTimestamp and there exists a latestRedemptionWindowStart timestamp in the past, a trade in the buffer window before the start of the next guaranteed redemption period is not prevented and such a trade may prevent redemption in the guaranteed redemption timeframe.  Code Corrected:  In  the  current  implementation,  the  startTimestamp  is  required  to  be  in  the  past.  Moreover,  the redemptionWindowBuffer  is  now  subtracted  from  the  latestRedemptionWindowStart  with  the addition of one day.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   15  CorrectnessLowVersion2CodeCorrected           \fif (     block.timestamp > latestRedemptionWindowStart.add(redemptionWindow.duration) &&     block.timestamp < latestRedemptionWindowStart.add(ONE_DAY).sub(redemptionWindowBuffer) ) {     return true; }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Shadowed Constant", "body": "  UniswapV2PoolPriceFeed  inherits  UniswapV2PoolTokenValueCalculator.  Both  contracts  define  a constant uint256 private constant POOL_TOKEN_UNIT = 10**18;.  Code Corrected:  The shadowing variable has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Missing Indexes in Events", "body": "  in  ComptrollerLib  could  use  The  PreRedeemSharesHookFailed  event  for address  of the  PreRedeemSharesHookFailed  and  BuyBackMaxProtocolFeeSharesFailed  could  be  indexed since it could facilitate queries for specific errors.  FailureReturnData   redeemer.   Moreover,   indexes   bytes   Code Corrected:  The missing indexes have been added.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   16  DesignLowVersion2CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Overestimation Of Fund's Value Under", "body": " Pending Liquidation  During  the  calculation  of  the  GAV  of  a  fund,  the  value  of  the  collateral  held  by  an  external  position  is taken into consideration. The calculation takes into account the fact that borrowed amount of an external position is to be returned and, thus, this amount is subtracted from the total collateral held. However, the calculation ignores a potential liquidation.  Assume  an  external  position  that  holds  100  cDAI  and  has  borrowed  75  dollars  worth  of  ETH  with  a collateral factor of 75%. Assume now that the value of ETH has increased so that the external owes 80 dollars.  When  the  GAV  is  calculated  the  external  position  will  be  evaluated  as  100  -  80  =  20  dollars. Since  the  position  is  undercollateralized,  a  liquidation  could  be  triggered.  Note  that  during  liquidations, users are incentivized to pay back the borrowed amount with an 8% discount for the collateral. When the liquidation takes place then the real value of the external position will be roughly 100 - 86.4 = 13.6. Users should be aware of that behavior which might lead to fluctuations in the GAV of the fund. Moreover, the front  end  of  Enzyme  should  indicate  potentially  undercollateralized  external  positions  to  users  prior  to investing.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Reverting Relayed Call Paid By The Fund", "body": "  According  to  the  GSN  protocol,  in  case  GasRelayPaymaster.preRelayedCall  fails  then  the execution is aborted. However, there might be the case where the preRelayedCall succeeds but the relayed  transaction  fails.  In  this  case,  the  fund  will  still  pay  for  the  gas.  An  interesting  case  is  the following.  The  preRelayCall  requires  the  original  _relayRequest.request.from  to  be  an authorised entity for the vault i.e., the owner or an asset manager or a migrator. However, some of the authorised calls allowed by the preRelayedCall further restrict the allowed entities. For example, a call to an integration is limited to only the owner and the asset manager. This means that in case the migrator tries  to  execute  this  function,  the  transaction  will  fail  but  paymaster  will  pay  for  the  gas.  We  assume, however, that the migrator is a trusted role who will not act against the system.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Sandwiching Authorized Actions", "body": "  An authorized user for a fund can use GSN to execute authorized actions. Is important to note that due to the fact that the relayer acts as an intermediary, it is easier for them to sandwich these transactions. For example,  a  relayer  can  sandwich  the  buyBackProtocolFeeShares  and  make  a  profit.  Notice  that when  buying  back  shares  the  value  of  the  shares  increases  since  the  shares  which  correspond  to  the protocol fee are burnt.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   17  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Unexpected Staking of Tokens", "body": "  Since  the  spent  assets  are  not  validated  against  the  Balancer  v2  pool's  underlying  assets, lendAndStake() could stake LP tokens from the vault along with the newly generated ones.  Consider the following scenario  1. Vault holds 1 Balancer LP  2. Manager  triggers  lendAndStake  where  the  underlyings  of  the  Balancer  LP's  pool  and  Balancer  LP are specified as spent assets.  3. 1 more Balancer LP is generated.  4. The full balance (2) of Balancer LPs is staked.  In contrast, all unused spent assets during the lending part, are returned to the vault proxy. Hence, the adapter may not behave as expected.  Risk accepted:  Avantgarde Finance replied:  This actually seems like an unintended convenience (batches the staking of held LP tokens with buying + staking new LP tokens). It is going to be the case for many/most adapters that if the manager inputs an incorrect value, there could be unintended consequences or value loss (e.g., slippage). Especially since there is no reported path that leads to value loss here, we will leave as- is.  Avantgarde Finance - Sulu Extensions VII -   11  DesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedLowCorrectnessMediumVersion1RiskAccepted          \f5.2   Unhandled Stake Slashing on Kiln  When computing the managed assets of an external position on Kiln, the system assumes the position holds  validatorCount  *  32  ETH  +  address(this).balance,  thus  not  considering  any  stake slashing that may have occurred. This could lead to an over-evaluation of the position if the stake gets slashed on a validator.  Risk accepted:  Avantgarde Finance replied:  Rewards and slashing are not included in the current position valuation, as this requires external oracle monitoring of the consensus layer. The actual position value will deviate by some percent from the ideal value, which will generally tend to be more and more undervalued if we assume consensus rewards outweigh slashing in most cases. For now, managers will need to be aware of this, and if they require more precision, we can integrate a simple oracle to monitor the delta.  Avantgarde Finance - Sulu Extensions VII -   12  DesignMediumVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  lendAndStake() May Interact With Two Pools and Leave Tokens Behind   -Severity Findings   Event Emitted When Non-Existing Pool Is Removed    Missing Sanitization for _feeBps    Validation for Balancer Staking   0  0  1  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   lendAndStake() May Interact With Two", "body": " Pools and Leave Tokens Behind  lendAndStake() should mint LP tokens for a pool and stake them. However, it is possible that funds are deposited into one pool but another LP token is staked due to a potential mismatch between pool id and the staking token's LP token. Ultimately, the newly minted LP tokens are to be left in the adapter.  Consider the following scenario:  1. The vault holds LP token B.  2. A lend and stake action is started. The pool id is A, the staking token's underlying LP token is pool  with id B. The spent assets are the underlying tokens of pool id A and the LP token B.  3. Through the lending, LP token A is received.  4. If  the  adapter's  balance  of  LP  token  B  (spent  asset)  is  greater  than  its  balance  of  LP  token  A,  staking will be successful.  5. Only the spent assets are pushed back to the vault.  6. The minimum incoming checks can in the integration manager pass if the spent asset amount for  LP token B is greater than the minimum incoming amount.  Ultimately, funds can be lost.    pool   The  __parseAssetsForLendAndStake and __parseAssetsForUnstakeAndRedeem.  validated   against   staking   token's   now   the   is   underlying   BPT   in  Avantgarde Finance - Sulu Extensions VII -   13  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected           \f6.2   Event Emitted When Non-Existing Pool Is Removed  Function  BalancerV2StablePoolPriceFeed.removePool  emits  a  PoolRemoved  event  even  if  a pool  function BalancerV2StablePoolPriceFeed.removePoolFactories  emits  events  only  if  a  previously added factory is removed.  contrast,   added.   never   was   In     The check isSupportedAsset(pool) has been added to only allow the deletion, and emission of the associated event, of an existing pool.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Missing Sanitization for _feeBps", "body": "  input   No  the ArbitraryTokenPhasedSharesWrapperLib.init.  One  could  deploy  with  feeBps  >  MAX_BPS intentionally or by mistake, which would block the redemption because local fees cannot be paid out.  sanitization   _feeBps   function   done   on   in   is     Input sanitization for the feeBps has been added. It must satisfy feeBps < MAX_BPS.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Validation for Balancer Staking", "body": "  Both,  the  Balancer  native  staking  and  the  Aura  staking,  perform  validity  checks  on  the  staking  token when  parsing  the  assets  for  staking  or  unstaking  actions.  The  validation  ensures  that  the  LP  token matches the staking token. That is typically implemented as follows:  __validateBptForStakingToken(stakingToken, __getBptForStakingToken(stakingToken));  However,  __getBptForStakingToken(stakingToken)==__getBptForStakingToken(stakingToken) which is always true. Hence, the validation is redundant and increases gas consumption.  perform   check   that   the   will   that    The redundant checks have been removed. However, no validation of the staking addresses for Balancer native staking tokens has been added.  Avantgarde Finance - Sulu Extensions VII -   14  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Unfair Distribution of Rebasing Tokens in", "body": " Shares Wrapper  In contrast to other system contracts, the shares wrapper for arbitrary deposit tokens does not support rebasing tokens.  For each deposit token wei deposited in the shares wrapper, one shares wrapper wei is minted to the depositor. If the deposit token is a rebasing token, that may lead to losses for early depositors in terms of rebase amounts.  Consider the following scenario:  1. Alice deposits 1 stETH and receives 1 stETH shares wrapper.  2. stETH rebases. The contract holds 2 stETH.  3. Bob deposits 1 stETH and receives 1 stETH shares wrapper.  4. Technically,  Alice  contributed  to  two  thirds  of  the  contracts  holdings  (2  stETH  out  of  3  stETH).  However, Bob and Alice both have claims to 50% of the contract's underlyings.  Ultimately, early-depositors could lose rebase amounts.  Avantgarde Finance - Sulu Extensions VII -   15  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Obsolete Storage Writes During Pool", "body": " Deployment  0  0  2  0  After the intermediate report, the following functions have been added to DMMPool:  function name() public override view returns (string memory) {     IERC20Metadata _token0 = IERC20Metadata(address(token0));     IERC20Metadata _token1 = IERC20Metadata(address(token1));     return string(abi.encodePacked(\"KyberDMM LP \", _token0.symbol(), \"-\", _token1.symbol())); }  function symbol() public override view returns (string memory) {     IERC20Metadata _token0 = IERC20Metadata(address(token0));     IERC20Metadata _token1 = IERC20Metadata(address(token1));     return string(abi.encodePacked(\"DMM-LP \", _token0.symbol(), \"-\", _token1.symbol())); }  The pool storage still contains the old name and symbol variables which are set during execution of the constructor.  Due  to  the  new  functions,  the  new  name  and  symbol  will  be  returned  while  the  storage variables are now obsolete.  constructor() public ERC20Permit(\"KyberDMM LP\", \"DMM-LP\", \"1\") VolumeTrendRecorder(0) {  These unnessesary storage writes makes the deployment of new pools more expensive than necessary. In  particular  100,000  gas  (roughly  20  USD  at  the  time  of  writing)  could  be  saved  during  each  pool deployment.  Kyber.Network - KyberSwap Classic - ChainSecurity  11  SecurityDesignCorrectnessCriticalHighMediumAcknowledgedLowDesignMediumVersion2           \f5.2   Actual Amplification Reduces After Unblanced Contribution  Users may add liquidity to a pool by directly invoking DmmPool.mint().  Normally,  liquidity  is  added  in  balanced  amounts  of  token0  and  token1  according  to  the  pool's inventory  as  the  amount  of  liquidity  tokens  minted  in  return  is  based  on  the  lower  contribution.  The surplus amount of the other token is kept by the pool.  After minting, the values of the virtual reserves are updated as follows:  liquidity = Math.min(     amount0.mul(_totalSupply) / data.reserve0,     amount1.mul(_totalSupply) / data.reserve1 ); uint256 b = liquidity.add(_totalSupply); _data.vReserve0 = Math.max(data.vReserve0.mul(b) / _totalSupply, _data.reserve0); _data.vReserve1 = Math.max(data.vReserve1.mul(b) / _totalSupply, _data.reserve1);  Unbalanced  contributions  reduce  the  factor  between  the  value  of  the  actual  reserve  and  the virtualReserve, hence the pool \"looses amplification\" figuratively speaking. In an extreme scenario of an unbalance contribution, which is rather costly for an attacker and has no clear benefit, the following scenario may arise:  Assume a pool has following state: reserve0 = 1000, reserve1 = 1000, vReserve0 = 2000 and vReserve1 = 2000.  1. A  user  adds  2000  token0  and  1  token1  to  the  pool.  The  values  for  vReserve0  and vReserve1 should now be 2002. However, as the pool received an additional amount of token0 the  value  of  reserve0  (3000)  is  now  higher  than  the  result  of  the  calculation  for  the  new vReserve0 amount, hence the value for vReserve0 is set to _data.reserve0.  2. This  step  may  be  repeated  for  the  other  token:  A  user  adds  3  tokens  to  reserve0  and  2998 tokens to reserve1. Then again the vReserve1 will get the value of reserve1.  3. Now it holds that reserve0 = vReserve0 and reserve1 = vReserve1.  After such a scenario an amplified pool is no longer amplified.  Note  that  a  similar  attack  vector  can  be  implemented  using  burn  for  tokens  that  accrue  rewards  on transfer.  unbalanced   The documentation provided does not describe the expected behavior when liquidity is added in case of an  section paper  Adding  liquidity  in  Ampfliciation  model  on  page  7  the  only  case  described  is  when  the contributions match the expected ratio.  Amplification   contribution.   Model,   the   In   in   Acknowledged:  Kyber is aware of this scenario and states:  Note that liquidity providers get benefits if this scenario happens and the attacker has no economic incentives to do this.  Kyber.Network - KyberSwap Classic - ChainSecurity  12  DesignMediumVersion1Acknowledged        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Conflicting Statements About Contribution Ratio    Sandwich Attack on New Liquidity Providers   -Severity Findings   Outdated Compiler Version    Redundant Modulo Operation    Unused Library    Unused blockTimestampLast    Wrong Inequality    vReserve Wrong Naming   0  0  2  6  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Conflicting Statements About Contribution", "body": " Ratio  The document Dynamic AMM model design and rationals in section 2.3.3 Add Liquidity reads:  When users add liquidity to existing pools, they must add liquidity with the current ratio of token in the pool. The amount of mint token will be the min increase proportion of 2 tokens, the virtual balances will scale out with the mint token to assure that the price range of the pools is only bigger. Special case: the pool has reserve0=1000 and reserve1=1000 and vReserve0=2000 and vReserve1=2000. An user adds 2000 token0 and 1 token1 to the pool. The vReserve0 and vReserve1 should be 2002. But the reserve0 (3000) is higher than vReserve0. Therefore, we must vReserve0 = max(reserve0, vReserve0) to assure the assumption that vReserve0 >= reserve0  The first statement clearly states:  must add liquidity with the current ratio of token in the pool  while the next statement handles a special case where this does not hold - hence the two statements are contradicting.  The actual implementation does not enforce that adding liquidity must be done with the current ratio of the tokens in the pool.  Finally  the  rational  behind  setting  vReserve  to  reserve  in  case  the  new  value  for  vReserve  is  less than  reserve  is  not  clear.  It's  understood  that  vReserve  cannot  be  smaller  than  reserve  as  the  Kyber.Network - KyberSwap Classic - ChainSecurity  13  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged        \famplification factor must be >= 1, however it's questionable and not documented why setting the value equal to reserve is the correct action in this case.  Specification changed:  The specification has been updated and now describes the scenario of an unbalanced contribution more detailed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Sandwich Attack on New Liquidity Providers", "body": "  This attack works against new liquidity providers when they are adding liquidity. The overall idea of the attack  is  that  the  virtual  reserve  values  are  out  of  sync  with  the  reserve  values.  Hence,  the  slippage protection  of  addLiquidity()  can  be  circumvented.  The  reserve  values  are  brought  out  of  sync  by adding unbalanced liquidity. Adding unbalanced liquidity by itself is good for liquidity providers, but in this combination it can be used for an attack.  Prerequisites:   A pool with little liquidity, e.g. new pool   The pool is amplified   The attacker has the ability to perform a sandwich attack  Setup:   The pool has two token T0, T1   T0 is worth 100 USD   T1 is worth 1 USD   The pool is balanced, e.g. 1 T0 and 100 T1  Attacks Steps:  1. Attacker  adds  liquidity  regularly  through  the  router.  Hence,  the  pool  is  still  correctly  balanced.  In  particular the reserves and virtual reserves have the ratio 1:100.  2. The victim looks at the pool and decides to add liquidity   The  victim  uses  the  router  and  allows  for  no  slippage  or  a  tiny  amount  of  slippage  (hence,  following best practices)   The victim sets up amountADesired and amountBDesired in 1:100 ratio, also amountAMin and  amountBMin have 1:100 ratio  4. The attacker detect the victim transaction in the mempool and starts a sandwich attack  5. First attacker transaction:   The attacker swaps all of T0 out of the pool   The attacker adds unbalanced liquidity (as described in our report)   These two steps can be repeated   As a result the reserves are in a 1:100 ratio but the virtual reserves are in a different ratio, e.g.  1:210 in our example  6. The victim transaction is executed, all checks pass, the transaction is successfully completed  Kyber.Network - KyberSwap Classic - ChainSecurity  14  SecurityMediumVersion1CodeCorrected        \f7. Second attacker transaction:   Attacker removes all its liquidity from the pool, now only the victim's liquidity is in the pool   Attacker uses the incorrect ratio of the virtual reserves to execute a swap that is bad for the  victim  Effect and Analysis:   The  \"gifted\"  liquidity  through  unbalanced  minting  here  goes  back  to  the  attacker  as  they  are  the  only/primary liquidity provider  In  our  example  with  an  amplification  factor  of  100,  the  attacker  can  steal  12.69%  of  the  victim's funds. Hence, the more the victim deposits, the more can be stolen.   The attacker's funds can be smaller than the victim's funds. The percentage of stolen funds remains  the same.   This is independent of the price ratios between T0 and T1 (1:100 in this example). Different ratios  lead to the same outcome.   Other amplification factors lead to different results, but there are probably ways to make this attack  more effective  Example Numbers:  Pool after liquidity has been added:  [++] T0: 1.0 [++] T1: 100.0 [++] Value: 200.0 USD [+] Value of 1 LP Share: 20.00 USD [+] Virtual Reserves: 10.00, 1000.00  At this point all seems fine and the victim decides to add liqudity.  Pool after pre-manipulation:  [++] T0: 5.5249 [++] T1: 552.49 [++] Value: 1104.97 USD [+] Value of 1 LP Share: 110.50 USD [+] Virtual Reserves: 6.89, 1452.49  At this point the reserves are still in a 1:100 ratio, but the virtual reserves are not. There ratio is 1:210.  Pool before final swap to exploit incorrect ratios:  [++] T0: 100.0 [++] T1: 10000.0 [++] Value: 20000.0 USD [+] Value of 1 LP Share: 110.50 USD [+] Virtual Reserves: 124.68, 26290.01  At this point only the victim's liquidity is left. The ratio of the virtual reserves is still 1:210.    The router now features a slippage protection on the ratio of the virtual reserves. The function takes two new  arguments  where  users  can  specify  the  lower  and  upper  bound  for  the  ratio  between  the  virtual  Kyber.Network - KyberSwap Classic - ChainSecurity  15   \freserves. This mitigates the attack described above as the attacker can no longer arbitrarily unbalance the  virtual  reserves.  Note  that  the  protection  is  in  the  Router,  hence,  users  interacting  with  the  pool contract directly are not protected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity 0.6.6;  in  Known  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1378  version   bugs   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "0.6.6 ", "body": "  are:  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At  the  time  of  writing  the  most  recent  Solidity  release  is  version  0.6.12.  For  version  0.6.x  the  most recent release is 0.6.12 which contains some bugfixes but no breaking changes.    After the intermediate report the compiler version has been updated to 0.6.12.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Redundant Modulo Operation", "body": "  DMMPool._update   In  operation uint32 blockTimestamp = uint32(block.timestamp % 2**32);. With optimizations enabled, for the  uint32(uint256(block.timestamp)) and uint32(uint256(block.timestamp)%2**32);.  redundant   generates   bytecode   compiler   identical   modulo   version   solidity   almost   there   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "0.6.6 ", "body": "  are:  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At  the  time  of  writing  the  most  recent  Solidity  release  is  version  0.6.12.  For  version  0.6.x  the  most recent release is 0.6.12 which contains some bugfixes but no breaking changes.    After the intermediate report the compiler version has been updated to 0.6.12.  6.4   Redundant Modulo Operation  DMMPool._update   In  operation uint32 blockTimestamp = uint32(block.timestamp % 2**32);. With optimizations enabled, for the  uint32(uint256(block.timestamp)) and uint32(uint256(block.timestamp)%2**32);.  redundant   generates   bytecode   compiler   identical   modulo   version   solidity   almost   there   0.6.6   use   of   is   a   This code no longer exists in the updated implementation.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Unused Library", "body": "  Library UQ112x112 is present in the repository but never used.    The unused library has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Unused blockTimestampLast", "body": "  Kyber.Network - KyberSwap Classic - ChainSecurity  16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                \fVariable blockTimestampLast in DMMPool is regularly updated but never used. The purpose of the variable is not documented.    The unused variable has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Wrong Inequality", "body": "  DMMLibrary.getAmount  ensures  reserveOut  >=  amountOut.  However,  if  the  equality  holds  the transaction  requires amount0Out < data.reserve0 && amount1Out < data.reserve1.  swap   since   later   later   call   will   fail   in   a     The equality check has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   vReserve Wrong Naming", "body": "  In  DMMLibrary.getReserves(),  the  return  values  of  DMMPool.getReserves  are  assigned  to vReserve variables while the values returned by the function correspond to the unamplified reserves.  (uint256 vReserve0, uint256 vReserve1, ) = IDMMPool(pool).getReserves();  IDMMPool(pool).getReserves() :  function getReserves()         external         override         view         returns (         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast         ) {         _reserve0 = reserve0;         _reserve1 = reserve1;         _blockTimestampLast = blockTimestampLast; }    The naming of the variables in the code has been corrected.  Kyber.Network - KyberSwap Classic - ChainSecurity  17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Amplification Increases Risk for Liquidity", "body": " Providers  A higher amplification coefficient increases the risk for the liquidity providers. Due to a large amplification factor,  larger  trade  volumes  are  required  in  order  for  the  current  price  to  be  reached.  Moreover,  the smaller spread may be exploited by arbitrage bots balancing liquidity accross markets.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Tokens With Multiple Entrypoints", "body": "  This is more a theoretical issue but has applied to tokens in the past. Nowadays this is a less common issue.  Some  (very  few)  tokens  have  multiple  addresses  as  entry  points,  e.g.  a  proxy  not  using delegatecall and the actual implementation contract. TrueUSD is such an example.  In the DMM system, this may has following consequences.   The check in DMMFactory.create() to prevent the creation of a pool where tokenA and tokenB  are equal can be bypassed.   A second unamplified pool may exist for the same token pair.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Volume Increase", "body": "  By swapping large amounts of funds of a pool with the receiver being the pool itself anyone may execute a trade with a large volume. The requirement is that some additional tokens are transferred to the pool during the callback in order to cover the fees so that the transaction can succeed.  As any swap, such a trade gets recorded in the VolumeTrendRecorder. The volume observed by the VolumeTrendRecorder may be increased by anyone willing to spend the fee in order to do so.  Kyber.Network - KyberSwap Classic - ChainSecurity  18  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Calls That Sweep All ETH in EVC Can Fail", "body": " Silently  Calls and batch items in the EthereumVaultConnector can transfer the whole balance of the EVC by setting  the  value  to  type(uint256).max.  This  can  carry  unintended  consequences  when  calls  are nested, even in the presence of trusted systems only:  Let's consider the following setup, where the user performs a batch call with three actions: A, B, and C.  EULEVC-001   A withdraws some ether into the EVC   B performs some arbitrary operation on trusted vaults   C deposits the ether somewhere, using type(uint256).max as the value.  If B is to perform some action on the EVC that uses its ether balance, then C would fail to deposits the whole amount received in A, but the failure will in general not result in a revert.  This can be of course problematic if B triggers malicious code (the EVC documentation addresses this in the security paragraph), but it can also fail when the action performed by B is correct but also performs an EVC calls with type(uint256).max value. In the latter case, the nested EVC call performed in B would unintentionally use the whole ether amount from A.  The problem is not present when using a specified ETH value in C, because the C action would cause a revert.  The  use  of  type(uint256).max  as  value  is  therefore  safe  only  when  no  intermediate  action exists that transfers ETH to the EVC.  Risk accepted:  Euler - Ethereum Vault Connector -   12  SecurityCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedRiskAcceptedCorrectnessLowVersion1RiskAccepted          \fEuler accepts the risk with the following statement:  We  acknowledge  this  issue.  Considering  that  oftentimes  users  might  not  know  exactly  how  much value the EVC has received as a result of an operation, the EVC provides users with a convenient method  to  sweep  all  the  available  value  by  passing  a  special  parameter  of  type(uint256).max.  We consider this feature to outweigh potential risks associated.  As per \u201cEVC Contract Privileges\u201d section of the EVC white paper, it is not advisable for the EVC to hold  any  native  currency.  The  documentation  emphasizes  potential  risks  regarding  untrusted  code execution, but we agree it does not mention any side effects that may arise from multiple operations using special type(uint256).max and an input parameter for the EVC. The EVC white paper has been refined to sufficiently describe this behavior.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Execution of Arbitrary Code Can Cause Denial", "body": " of Service  The execution of arbitrary code when checks are deferred can be exploited to cause denial of service of the  EVC.  If  a  user  initiates  a  call  through  the  EVC  which  triggers  the  execution  of  malicious  code,  the whole EVC execution can be forced to revert by introducing an account or vault status checks that fails.  Arbitrary non malicious code can also introduce EVC failures by including a number of vault or account status checks that exceeds the maximum of 10 (SET_MAX_ELEMENTS).  EULEVC-003  Risk Accepted:  Euler accepts the risk with the following statement:  We acknowledge this issue. The EVC has been designed to function as a glorified multi-call contract allowing the user to execute calls into any other addresses, including contracts containing malicious code.  As  with  any  other  system  of  such  a  type,  it  is  the  user's  responsibility  to  carefully  select contracts  they  interact  with.  If  not  careful,  it  is  true  that  malicious  contracts  can  cause  denial  of service attacks. However, such attacks should never pose a greater security threat to the system as a whole and with user\u2019s care, can easily be avoided. The white paper has been refined to sufficiently describe this behavior.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Simulations Can Be Tricked by Malicious", "body": " Systems  A  user  can  simulate  the  effects  of  a  batch  by  using  batchSimulation()  or  batchRevert(). However, during a simulated batch, the execution context of the EVC is updated to indicate that it is in simulation mode, by setting the SimulationInProgress flag. This flag can be checked by any vault or external system that the EVC interacts with. Therefore, malicious vaults or external systems could use this information to act differently during simulation mode, in order to trick the user into thinking that the vault/external  system  is  not  malicious.  Simulations  should  not  be  used  as  a  security  measure  to determine the effects of a batch if the systems with which the batch interacts are untrusted.  EULEVC-004  Euler - Ethereum Vault Connector -   13  SecurityLowVersion1RiskAcceptedSecurityLowVersion1RiskAccepted                \fRisk Accepted:  Euler accepts the risk with the following statement:  this   The   issue.   acknowledge   We  as operatorAuthenticated  flag,  has  been  introduced  in  the  system  on  purpose.  None  of  them  is used  internally  by  the  EVC,  they  both  have  been  introduced  so  that  they  can  be  observed  by  the external smart contracts the user interacts with through the EVC. Although, as noticed in the issue description,  those  flags  allow  the  contracts  called  to  modify  the  behavior  and  execution  path,  their existence  may  increase  the  UX  and  hence  we  consider  this  feature  to  outweigh  potential  risks associated.  simulationInProgress   same   flag,   For example, the simulationInProgress flag can be used by a vault so that the user is able to determine the outcome of the operation even if they do not currently hold tokens required to carry out such an operation, i.e. deposit into a vault.  As  with  any  other  EVC  feature,  users  should  only  use  the  EVC  simulation  with  trusted  and recognized smart contracts that do not aim to trick or harm them in any way. Considering the EVC simulation features are mostly meant to be used by the UI applications, we believe this is the natural place where user protection should be applied. If the user aims to faithfully evaluate the outcome of the simulation to assess the security of the to be executed transaction, they should resort to other methods  and  available  commercial  solutions.  The  white  paper  has  been  refined  to  sufficiently describe this behavior.  Euler - Ethereum Vault Connector -   14    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings  Informational Findings   Gas Optimizations    setAccountOwnerInternal() Naming Is Not Accurate    Unused Variable   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Gas Optimizations", "body": "  0  0  0  0  3  EULEVC-005  the  EthereumVaultConnector  contract,  public   functions  requireAccountStatusCheck, In  requireVaultStatusCheck, and requireAccountAndVaultStatusCheck are decorated with the nonReentrantChecks modifier. However, the functions perform different actions depending if checks are  deferred  or  not.  Since  areChecksDeferred()  and  areChecksInProgress()  are  mutually exclusive (except transiently in the body of these functions), the reentrancy check can be moved to the internal version of the functions which is called if checks are not deferred. This saves 3 storage accesses every time one of these functions is called.  Several  gas  optimizations  can  be  implemented  in  the  Set  library,  all  pertaining  to  writing  values  into structs that share a storage slot. If a and b share a storage slot, writing a new value into a requires first loading b from storage, so that the new [a,b] value can be then written in storage. If a and b are written together, the SLOAD is prevented. The gas optimizations in question are:   At   the   end   94 (setStorage.numElements = uint8(numElements + 1)), a storage load can be prevented by also setting setStorage.firstElement, which is known, and setStorage.stamp, which is always DUMMY_STAMP in the setStorage struct.  function   insert,   around   line   of   In  function  insert  when  inserting  at  the  end  of  the  array,  line  91,  the  stamp  value  can  also  be written,  therefore  saving  a  storage  read.  To  know  which  value  to  set  for  stamp,  the element-searching  loop  that  is  performed  just  before  (lines  85-87)  can  also  be  used  to  query  the stamp values of the array. They will either all be set (for transient sets), or all unset (for persistent sets), so when setting stamp at index i, the value of stamp at index i - 1 can be used (i >= 1). If the second element is being inserted (i == 0), then the extra SLOAD can't be avoided, since the old value of stamp must be retrieved.  In  function  remove,  when  replacing  the  removed  element  with  the  last  element,  at  line  143,  the stamp value can also be written to prevent an SLOAD. The stamp value to write can be known at no extra storage load costs.  Euler - Ethereum Vault Connector -   15  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedInformationalVersion1CodeCorrected        \fIn  function  reorder,  if  index1  ==  0,  setStorage.numElements  and  setStorage.stamp can be set to their known values to prevent an extra SLOAD.  functions  forEachAndClear  and  forEachAndClearWithResult,  when  clearing In  setStorage.numElements and setStorage.firstElement, setStorage.stamp can be set to DUMMY_STAMP to prevent an extra SLOAD.  Because some functions are only used on transient sets (forEachandClear), and some others only on persistent sets (reorder), extra optimizations are available if we accept tighter coupling between the Set implementation and the EthereumVaultConnector:  can    When  clearing  the  array  elements  in  forEachandClear  (and  forEachAndClearWithResult), we  since forEachAndClear() is only used on transient sets which are known to have every stamp set to DUMMY_STAMP.  also  write  setStorage.elements[i].stamp  =  DUMMY_STAMP,    reorder()  is  only  used  on  persistent  sets  of  accountCollaterals,  which  are  known  to  have stamp value 0 for entries of the elements array. Therefore, the stamp value can be set to 0 when writing the value of entries, saving extra SLOADs    After evaluation by Euler, some of the optimizations were implemented while others were considered to slightly complicate the logic of the contract or increase the gas consumption.  The following optimizations were implemented:  two  additional  internal  functions,  requireAccountStatusCheckInternalNonReentrant  and requireVaultStatusCheckInternalNonReentrant,  wrap requireVaultStatusCheckInternal requireAccountStatusCheckInternal  in accordingly,  have  been  added  requireAccountStatusCheck,  and requireAccountAndVaultStatusCheck functions.  the  EthereumVaultConnector  and  used   requireVaultStatusCheck   that   and   to   forEachAndClear and forEachAndClearWithResult have been modified.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Unused Variable", "body": "  The variable STAMP_MASK of ExecutionContext is currently unused.  EULEVC-008    This variable has been removed  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   setAccountOwnerInternal() Naming Is Not", "body": " Accurate  EULEVC-009  Euler - Ethereum Vault Connector -   16  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                \fsetAccountOwnerInternal() seems to indicate that the function is setting the account owner for a single  account.  However,  the  function  is  setting  the  owner  of  all  256  accounts  (for  the  whole  address prefix), and not just a single account.    This function has been inlined and removed.  Euler - Ethereum Vault Connector -   17  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Account Check Can Fail When Enabling", "body": " Collateral  enableCollateral() will always requireAccountStatusCheck(). This can be problematic in the case  a  position  is  below  the  LTV  and  above  the  liquidation  threshold.  In  this  case,  it  will  prevent  the account from improving the position by enabling a new collateral if the amount of enabled collateral is too small to improve the position above the LTV. The same issue can arise in reorderCollateral().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Differences Between Call to Collateral and ", "body": " controlCollateral  EULEVC-002  controlCollateral()  enables  the  controller  of  an  account  to  act  on  the  account's  collateral  while impersonating  the  account.  This  is  expected  to  be  used  for  example  in  liquidations,  and  the  controller should be able to use the collateral at their discretion. However, since controlCollateral() sets the setControlCollateralInProgress flag, a controller has more restrictions when interacting with a collateral than the owner, because the EVC can't be re-entered.  The  implementation  of  complex  collateral  vaults  is  therefore  restricted  to  not  interact  with  other  EVC vaults  in  methods  used  in  liquidations,  and  controller  vaults  are  restricted  to  use  methods  of  collateral vaults that are known not to interact with the EVC. This imposes design restrictions on how the liquidating vault (controller) interacts with the collateral. When asked about it, Euler stated that operations performed as part of the liquidation flow will most likely involve share transfers or asset withdrawals, and should not contain any complex logic requiring them to perform additional EVC calls.  If a vault implementation performs EVC calls when transferring shares (callThroughEVC), in case the liquidation flow includes asset withdrawal from a vault, the withdrawn asset cannot be a share token of another  vault  (vaults  nesting).  This  restriction  is  however  unlikely  to  cause  problems  because  nested vaults make a poor choice of collateral from a risk management perspective.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Inefficient ETH Transfer in ", "body": " callThroughEVC()  In callThroughEVC() a substantial amount of gas is spent if the message value is positive because the ether is sent to the EVC and back to the Vault resulting in the ether being moved three times instead of  once.  Every  call  that  transfers  ether  costs  at  least  6800  gas,  so  at  least  an  additional  13600  gas  is spent.  Euler - Ethereum Vault Connector -   18  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Inter-dependencies in Checks  Checks  on  accounts  and  vaults  are  performed  in  the  order  they  were  added  to  the  set.  These  checks might read and modify the state of third-party smart contracts such that subsequent checks will behave differently due to the modified state. Therefore, the order in which the checks are performed can matter.  While this is not a problem for the EVC itself, it should be considered by any vault implementation that relies  on  the  EVC.  Vault  should  not  depend  on  the  order  of  checks  execution  as  it  is  not  guaranteed, since different call nesting can influence it.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Nonces Are Shared by Addresses With", "body": " Colliding Prefix  While extremely unlikely, two different addresses may share the same address prefix. In this case, the first address to be authenticated with the EVC will be the owner of the address prefix preventing the other address from authenticating on behalf of the address prefix. However, the second address can still sign permit  messages  using  nonces  for  the  address  prefix.  Therefore,  the  second  address  can  invalidate nonces used by the owner's address by signing a permit message with the same nonce and front running the call to permit by the owner's address.  EULEVC-007  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Vault Composability Is Limited by the", "body": " Maximum Amount of Deferred Checks  The amount of vaults and accounts that can be checked during the check phase is limited by the size of the  respective  sets.  Therefore,  any  nested  operation  that  results  in  more  than  10  deferred  vault  or account checks will fail.  Therefore, vaults containing other vaults could stop working with the EVC if the contained vaults change their  behavior  by  requesting  additional  checks,  which  would  lead  to  the  above-mentioned  limit  being exceeded. This is a limitation of the EVC that vault developers should be aware of.  Euler - Ethereum Vault Connector -   19  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Sandwich Attack on updateState", "body": "  StructuredAssetVault.updateState() allows the manager to add interest payments to the vault or  default  loans  on-chain.  The  frequency  of  such  updates  is  entirely  up  to  the  manager.  Thus,  it  is possible that such updates occur rarely and add a large amount of interest at once.  If  deposits  are  allowed  during  the  Live  state  of  the  vault,  this  is  problematic  as  users  depositing  right before an update receive the same amount of interest as users that deposited earlier.  If  withdrawals  are  also  allowed  during  the  Live  state  of  the  vault,  this  behavior  becomes  exploitable. Consider the following example:  CS-TFFlourine-001   A given vault accrues 0% fees.   Each tranche accrues 0% interest (for demonstration purposes).   Each tranche holds a value of 100 tokens.   The manager disburses 150 tokens, setting outstandingAssets to 150.   After 1 year, the manager updates the outstandingAssets to 200.   An attacker frontruns the call to updateState() with a deposit of 100 tokens to the equity tranche.   After the updateState() call has been processed, the attacker can withdraw their received shares  for an instant profit of 25 tokens.  Risk accepted:  The client accepts the risk with the following statement:  Manager  should  disable  withdrawal  and  deposits  if  there  will  be  a  big  change  of  value  in  update state.  TrueFi - Fluorine -   12  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowSecurityMediumVersion1RiskAccepted           \fTrueFi - Fluorine -   13    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Wrong Distribution of Unpaid Fees in Repay()   -Severity Findings   Disburse to 0-Address   0  0  1  1  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Wrong Distribution of Unpaid Fees in Repay()", "body": "  StructuredAssetVault._calculateWaterfall()  first  calculates  the  waterfall  without  fees,  then subtracts the fees from each waterfall value:  CS-TFFlourine-003  uint256[] memory waterfall = _calculateWaterfallWithoutFees(assetsLeft); uint256[] memory fees = new uint256[](tranches.length); for (uint256 i = 0; i < waterfall.length; i++) {     uint256 waterfallValue = waterfall[i];     uint256 pendingFees = tranches[i].totalPendingFeesForAssets(waterfallValue);     waterfall[i] = _saturatingSub(waterfallValue, pendingFees);     fees[i] = pendingFees; }  If all value of a vault has been disbursed before and there are unpaid fees in the tranches, a repay() will repay the unpaid fees of the tranches first and then start to add value to the senior tranche. However, due  to  the  aforementioned  calculation  of  the  waterfall,  the  unpaid  fees  of  the  lower  tranches  are  not removed from the value that is added to the senior tranche's checkpoint.totalAssets. Consider the following example:   Each tranche has 0 value, 5 tokens in unpaid fees and a deficit of 95 tokens.   A repayment of 20 tokens occurs.   Each tranche now has 0 tokens in unpaid fees.   The senior tranche now has a value of 15 tokens in its checkpoint and a deficit of 85 tokens.  Since  only  5  tokens  are  in  the  end  kept  in  the  vault's  virtualTokenBalance,  another  call  to updateCheckpoints()  updates  the  senior  tranches  checkpoint  to  just  5  tokens  and  a  deficit  of  95 tokens.  However,  since  TrancheVault.deposit()  does  not  update  its  own  deficit  before  processing  a deposit,  any  deposit  (e.g.,  1  wei)  can  cause  this  wrong  deficit  to  become  persistent  because  the checkpoint  is  updated  with  the  actual  waterfall  value  (going  from  15  tokens  to  5  tokens  +  1  wei)  and  TrueFi - Fluorine -   14  CriticalHighMediumCodeCorrectedLowCodeCorrectedCorrectnessMediumVersion1CodeCorrected        \fsubsequent  calls  to  updateCheckpoints()  can  only  calculate  the  deficit  with  the  currently  stored values.    Deficits are now stored in the TrancheVault checkpoints instead of StructuredAssetVault and are calculated  on  every  checkpoint  update  in  the  tranches.  Additionally,  TrancheVault._payFee  now limits the fees to the waterfall value of the tranche so that unpaid fees in empty tranches are no longer paid out.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Disburse to 0-Address", "body": "  StructuredAssetVault.disburse() allows the transfer of tokens to the 0-address. This could be problematic, for example, if a bug in the frontend the manager uses passes an uninitialized parameter to the function call.  CS-TFFlourine-004    Disbursals to the 0-address are no longer possible.  TrueFi - Fluorine -   15  DesignLowVersion1CodeCorrected        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Event Emitted When Nothing Has Changed", "body": "  CS-TFFlourine-002  StructuredAssetVaultFactory.setAllowedBorrower()  event AllowedBorrowersChanged every time a borrower is added or removed. If a borrower is added that has  already  been  added  or  if  a  borrower  is  removed  that  has  already  been  removed,  the  event  is  still emitted because the return values of the EnumerableSet (the type of the _allowedBorrowers state variable) functions add() and remove() are never checked.  emits   the   TrueFi - Fluorine -   16  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Asset Report Identifiers Not Unique", "body": "  Each time the manager changes the state of the vault (regarding loans) a string identifier is added to the contract that is linked to a JSON report. However, there is no guarantee, that the manager reuses a string they have used before (except if the same string was used in the last call).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Relevant Concerns of TrueFi Carbon Smart", "body": " Contract Audit Report  This audit report covers Fluorine which is dependent on some logic of another product of TrueFi: Carbon. Since both projects share similarities, the following points, which have been covered in the Carbon audit report, are also valid for Fluorine.  The report can be found at https://chainsecurity.com/wp-content/uploads/2023/07/TrueFi_Carbon_-Smar t-Contract-Audit-_-ChainSecurity.pdf (snapshot).   5.2 DoS for Start   5.3 Loan Default Frontrunning   5.4 Fee Transfer DoS   7.1 Ambiguous Deficit Data in Closed State   7.2 Compounding Interest Computed in Arbitrary Intervals   7.3 Fee Accrual in Closed State   7.4 Fee Accrual on Yield   7.5 Manager Fee Accrual   7.7 Skewed Interest Distribution   7.8 Use of Non-standard ERC20 Tokens  Please  note,  StructuredPortfolio.  that   the  Carbon   equivalent   to   StructuredAssetVault   is   called  Please  also  note,  that  a  \"loan  default\"  in  some  of  these  issues  is  equivalent  to  a  call  to StructuredAssetVault.updateState() with a value that decreases the outstanding assets of the vault.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   updateState in Closed State", "body": "  TrueFi - Fluorine -   17  NoteVersion1NoteVersion1NoteVersion1          \fThe  manager  is  able  to  call  updateState()  in  Closed  state.  Users  should  be  aware  that  it  is  still possible to receive interest payments that were not accounted for when the vault has been closed.  TrueFi - Fluorine -   18  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   DssProxy Constructor Does Not Emit", "body": " SetOwner Event  The constructor of DssProxy does not emit a SetOwner event. Consider emitting an event here to reflect this important storage change.  constructor(address owner_) {     owner = owner_; }    The constructor now emits the setOwner event.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Optimization of delegatecall Success", "body": " Check  The success check in the execute function of the DssProxy contract is as follows:  assembly {     let succeeded := delegatecall(/*...*/)     /*...*/     switch iszero(succeeded)  MakerDAO - Dss Proxy -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f    case 1 {         revert(add(response, 0x20), size)     } }  However, as delegatecall can only return 0 or 1, the iszero is unnecessary. Instead, one can simply check for case 0. With optimization enabled, this change saves 9 gas and 4 bytes of bytecode.    The optimization has been implemented.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Possible Failure of create2", "body": "  It is possible for the create2 operation to fail, in which case the returned address will be 0. This failure is not checked, which would result in isProxy[0] being set to 1. Additionally, the owner's seed would be incremented despite not having deployed a contract.  assembly {     proxy := create2(/*...*/) } proxies[owner_] = proxy; isProxy[proxy] = 1;    The code now ensures that the DssProxy has been successfully created:  require(proxy != address(0), \"DssProxyRegistry/creation-failed\");  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Possible Optimization in Proxy Check of", "body": " Registry  In the claim function of the DssProxyRegistry, the following check is made:  require(isProxy[proxy] == 1, \"DssProxyRegistry/not-proxy-from-this-registry\");  The  isProxy  mapping  only  contains  the  values  0  or  1.  Hence,  checking  the  condition  ==  1  is functionally  equivalent  to  checking  the  condition  !=  0.  The  latter  check  is  more  efficiently  compiled,  it saves 6 gas and reduces bytecode by 3 bytes.    MakerDAO - Dss Proxy -   11  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fThe optimization has been implemented.  MakerDAO - Dss Proxy -   12  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   No Event on execute", "body": "  Integrations must be aware that compared to the DSProxy it replaces, DssProxy no longer emits a event on execute().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   isProxy Might Point to Addresses Without", "body": " Code  When creating a proxy with the build function, an entry is created in isProxy, which maps the address of the new proxy to 1 :  function build(address owner_) external returns (address payable proxy) {     /*...*/     isProxy[proxy] = 1; }  This  entry  cannot  be  modified.  Hence,  a  proxy  that  has  been  selfdestructed  would  still  appear  in isProxy like a valid proxy.  A selfdestructed proxy in the isProxy mapping would have prevented creation of a new proxy for the owner  using  DssProxyRegistry.build():  Retrieving  the  owner  would  have  reverted.  The implementation of DssProxyRegistry.build() has been changed to handle this case.  MakerDAO - Dss Proxy -   13  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Double Counting During Maple Migration", "body": "  During the migration of Maple positions, double counting of Maple LP tokens is possible as there are no restrictions enforced on lend().  Consider the following scenario:  1. The position holds 10 v1 LP tokens.  2. The snapshot is taken and snapshots are frozen.  3. The  airdrop  of  v2  LP  tokens  happens  and  the  position  receives  10  v2  LP  tokens.  Note  that getManagedAssets() does not consider v2 LP tokens since the v2 pool is not tracked. Hence, the valuation is 10 v1 LP tokens.  4. The  manager   tokens.  Now, getManagedAssets() considers both v1 and v2 LP tokens since lending will start tracking the v2 pool. Hence, the valuation is 10 v1 LP tokens and 20 v2 LP tokens.  to  Maple  v2  and  creates  10  v2  LP   tokens   lends   Thus, funds could be overvalued between airdop and migration execution.    Lending is now only allowed if the position has been migrated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Incorrect Comment", "body": "  On  AddOnlyAddressListOwnerConsumerMixin there is the following comment:  __validateAndAddListItemIfUnregistered   the   function   of  Avantgarde Finance - Sulu Extensions VIII -   13  CriticalHighCodeCorrectedMediumLowSpeci\ufb01cationChangedCodeCorrectedCorrectnessHighVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                 \f/// @dev Helper to lookup an item's existence and then attempt to add it. /// AddOnlyAddressListOwnerBase.addToList() performs validation on the item.  The  addToList  function  does  not  actually  perform  the  validation.  The  __validateItems  function does.  Specification changed:  The comment now specifies that the function addValidatedItemsToList() is used.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Unused Import", "body": "  MapleV1ToV2PoolMapper  which is unused.  imports  \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"    The import has been removed.  Avantgarde Finance - Sulu Extensions VIII -   14  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Lido Rebasing", "body": "  Lido  has  epochs  for  rebasing.  It  could  be  possible  to  sandwich  oracle  updates  with  buying  and  selling shares.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Maple V2 Migrations Can Start Before", "body": " Snapshots  allowMigration() is a governance function that should be called after all snapshots. Note that there is no sanity check that all snapshots have been made. Governance should not call this function too early.  Further,  note  that  the  function  should  only  be  called  after  snapshots  have  been  disallowed  with freezeSnapshots().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Pool Address", "body": "  Note  that  for  the  Aave  v2  and  Aave  v3  adapters,  the  lending  pool's  address  is  stored  and  not  queried from Aave's registry. Managers should be aware that the (lending) pool address used could be outdated.  Avantgarde  Finance  plans  to  upgrade  the  library  contract  in  the  case  that  the  lending  pool  address changes.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Potential Maple V2 Rollback", "body": "  Note  that  Maple  V2  could  rollback  their  migration  process.  Avantgarde  Finance  should  be  aware  and quick to react.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Redeemable Amount", "body": "  The action RedeemV2 tries to redeem the input amount poolTokenAmount. However, note that Maple's WithdrawalManager contains the following code  Avantgarde Finance - Sulu Extensions VIII -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \frequire(requestedShares_ == lockedShares_, \"WM:PE:INVALID_SHARES\");  Hence, managers should be aware that RedeemV2 will only succeed if poolTokenAmount is equal to its locked shares.  Avantgarde Finance prefers this in case future implementations of Maple change this logic.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Reverts on Batching Maple Migration", "body": "  The Maple mapper contract implements a batched function for migrating to v2. If a position has already been migrated, the batched function may revert.  Avantgarde Finance replied:  Pretty unlikely to occur and nicer to be able to easily preview a tx failure by not skipping reverting items.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Theoretical Out-Of-Gas During Maple V2", "body": " Migrations  snapshotPoolTokenV1BalanceValues()  and  migratePoolsV1ToV2()  load  all  used  pools  from storage.  Theoretically,  these  functions  could  result  in  an  out-of-gas  problem  that  cannot  be  resolved without a contract upgrade.  In contrast, if too many pools are added for getManagedAssets(), this can be resolved by a manager.  Avantgarde Finance - Sulu Extensions VIII -   16  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Floating Pragma", "body": "  The  contract  HTX  uses  the  floating  pragma  ^0.8.0.  Although  this  contract  has  been  compiled  with Tron's  Solidity  version  0.8.20  and  is  already  deployed,  we  would  like  to  note  that  contracts  should always  be  deployed  with  the  compiler  version  and  flags  that  were  used  during  testing  and  auditing. Locking  the  pragma  helps  to  ensure  that  contracts  are  not  accidentally  deployed  using  a  different compiler version and help ensure a reproducible deployment.  CS-HTX-001  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Optimizations", "body": "  CS-HTX-002  The codebase could be more efficient in terms of energy usage. Reducing the energy costs may improve user experience. Below is a list of potential inefficiencies:  1. The  contract  HTX  uses  Solidity  version  0.8.x  which,  by  default,  implements  overflow  and  underflow checks. Therefore, the use of library SafeMath is redundant and could be avoided.  2. Furthermore, the functions mul(), div() and mod() of the library SafeMath remain unused.  3. The internal functions _burn() and _burnFrom() are unused in the codebase.  4. The storage variable _decimals could be immutable as it is only set in the constructor. This would  reduce the number of storage operations made when decimals() gets called.  5. The  functions  increaseAllowance()  and  decreaseAllowance()  perform  a  redundant  SLOAD operation when emitting the Approval event.  HTX DAO - HTX -   10  InformationalVersion1InformationalVersion1      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Locked Assets", "body": "  Tokens (TRX, TRC-20 or similar) could be accidentally/intentionally sent to the HTX contract. In that case the tokens will be locked, with no way to recover them. Incidents in the past showed this is a real issue as there always will be users sending tokens to the token contract.  Note that TRX and tokens can be forced into any contract and get locked if there is no \"recover\" function.  HTX DAO - HTX -   11  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Mismatches With Documentation and Lack", "body": " Thereof  Documentation  plays  a  crucial  part  for  understanding  a  codebase  and  integrating  it  into  a  live  system. However,  the  code  lacks  project  specific  documentation  and  is  only  described  in  a  generic  way  in  the MakerDAO Oracle documentation.  Moreover, the interfaces of the CurveLPOracle mismatch the interface specified:   The  documentation  specifies  step()  to  take  a  uint16  as  an  input  parameter  while  the  code defines  step(uint256)  which  checks  that  a  provided  argument  does  not  exceed  the  maximum uint16.   Documented  function  change()  is  missing.  However,  link()  is  undocumented  but  implements  the specified functionality of change().   According to documentation, stop() should only set the stopped flag while void() should set the flag but also reset nxt, cur and zph. In contrast, void() is missing while stop() implements the semantics of void().  Similarly StETHPrice deviates from the MakerDAO medianizer documentation.  Acknowledged:  MakerDAO acknowledges this.  MakerDAO - Curve LP & stETH oracle -   10  DesignCorrectnessCriticalHighMediumLowAcknowledgedCorrectnessLowVersion1Acknowledged            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Curve Registry    Outdated Compiler Version    Potential Inconsistency   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Curve Registry", "body": "  0  0  0  3  According to the Curve Documentation of their registry contracts, the central source of truth in the Curve system  is  the  address  provider.  That  contract  allows  changing  the  registry  through  set_address() when the id parameter is set to zero. Currently, the oracle stores the registry as an immutable. Hence, in case the registry changes, the oracle will utilize a wrong registry.    The registry is now queried from the address provider.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Outdated Compiler Version", "body": "  The  solc  version  is  fixed  to  version  0.8.9.  The  introduced  changes  in  versions  0.8.10  and  0.8.11 could reduce gas consumption of the inline-assembly code of poke().    Compiler version 0.8.11 was chosen.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Potential Inconsistency", "body": "  step() sets a new value to hop which specifies the minimum time between calls to poke(). Function zzz() should return the time of the last poke().  MakerDAO - Curve LP & stETH oracle -   11  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fConsider now the following scenario where hop is 1 hour and the zph is set to the current time + 1 hour. Assume that a call to step() sets hop to 10 minutes. Now, zzz() returns current time + 50 minutes which is in the future. Moreover, the next poke requires waiting for one hour instead of only 10 minutes.  Ultimately, that could lead to temporary inconsistencies.    zph (Time of last price update plus hop, the minimum time between price updates) is now updated on step() using the new value of hop. The update of zph is skipped when it hasn't been set yet but hop is updated.  MakerDAO - Curve LP & stETH oracle -   12  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   zkAllocation May Not Behave as Expected", "body": "  CS-STUAGG-004  The  zkAllocation  function  is  assumed  to  only  be  called  with  a  lender  allocation  that  increases  the total APR of the aggregator.  However, the possible allocations depend on the state of the blockchain at execution time, which is likely impossible  to  know  at  proof  generation  time.  In  particular,  the  aggregator.update_debt  function gives no guarantees on how much it will withdraw or deposit when it is called with a certain target debt. It may deposit/withdraw more or less than expected, depending on the current state.  In general, the aggregator will try to get \"as close as possible\" to the target debt, but will not revert even if far away from the target. For example, a call that tries to reduce debt by 100, but due to tokens being locked in the strategy, only reduces debt by 1, will not revert. However, there will be a revert if there is a call that would deposit or withdraw a zero amount.  Consider the following illustrative example:  1. There  are  two  lenders,  A  and  B.  Both  have  a  debt  of  100.  The  minimum_total_idle  of  the  aggregator is set to 10. There are 210 tokens in the aggregator in total.  2. The interest rates change such that A now has a slightly lower interest rate than B.  3. A zk proof is generated, that claims that a better allocation of tokens would be 90 tokens in A, and  110 tokens in B. This is true at proof generation time.  4. Someone withdraws 5 tokens from the aggregator.  5. The zkVerifier verifies the proof, and calls zkAllocation().  6. update_debt(A,90)  is  called.  It  was  expected  at  proof  generation  time  that  this  withdraws  10 tokens. However, since then, assume the internal balances of A have changed, and only 7 tokens are withdrawable. 7 tokens are added to the total_ idle.  Sturdy - Sturdy Aggregator -   9  DesignCorrectnessCriticalHighMediumRiskAcceptedLowAcknowledgedDesignMediumVersion1RiskAccepted          \f7. update_debt(B,110)  is  called.  It  was  expected  at  proof  generation  time  that  this  deposits  10 tokens. However, now the total_idle of the aggregator is only 12 and the minimum is 10, so only 2 tokens are deposited to B.  8. zkAllocation()  successfully  returns.  Now  the  balances  are  A:  93  and  B:  102.  This  has  a lower APR than if there had been no change and the balances had stayed A: 100 and B: 100.  There  can  be  many  lender-specific  conditions  that  limit  how  much  can  be  added/withdrawn.  These conditions  can  be  dependent  on  the  current  state  of  the  blockchain,  with  no  way  to  know  the  limits  in advance.  As  the  allocation  zk  proofs  must  be  generated  ahead  of  execution  time,  it  does  not  seem possible  that  they  can  take  all  of  these  limits  into  account.  This  may  lead  to  cases  where  a  zk  proof verifies,  but  the  resulting  APR  is  lower.  A  malicious  actor  may  even  be  able  to  frontrun  the zkAllocation call to change the state such that the allocation becomes worse.  Zk  proof  generation  should  also  consider  the  effects  of  process_report,  which  can  change current_debt,  otherwise  update_debt  may  lead  to  more  tokens  deposited  to  that  lender  than expected.  The severity of this issue depends on what exactly is proven in the zk proofs, which is out of the scope of this audit and is treated as a black box.  Risk accepted:  Sturdy understands and accepts the risk.  Sturdy responded:  The time period between proof generation and execution time will be quite small, so changes are unlikely. Given that there is no risk of lost funds (only suboptimal yield), we're accepting this risk for the time being and will consider lender-specific limits in the future.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   borrowAsset() Slippage Protection", "body": "  Silo.borrowAsset()  returns  the  amount  of  shares  debited  when  borrowing.  However,  this  value  is ignored  by  SiloGateway.borrowAsset().  The  received  amount  of  shares  may  be  smaller  than expected.  CS-STUAGG-010  Acknowledged:  Sturdy acknowledges and understands the issue. Sturdy states:  The value to be compared depends on the external silo's logic (ex: Fraxlend, Aave V3, Compound V3). Slippage protection will be added where needed.  Sturdy - Sturdy Aggregator -   10  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Sorting of the Lenders Is Incorrect   Idle Assets Not Used for requestLiquidity    Utilization Limit Does Not Take Into Account JIT Liquidity    Utilization Limit Only Enforced on Requesting Lender    utilizationLimit Is Not Always Enforced   -Severity Findings  Incorrect Code Comment    Reentrancy Guards Applied Inconsistently   Informational Findings   Gas Optimizations    Missing Input Sanitization    Misleading Error Names   0  0  5  2  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Sorting of the Lenders Is Incorrect", "body": "  The sortLenderWithAPR function was updated in   .  The  algorithm  that  sorts  the  lenders  by  APR  only  swaps  the  lenders'  addresses  in  the  array,  but  the positions in the new APRs array are not swapped. This leads to the list of APRs being out of sync with the list of lenders, which leads to incorrect sorting comparisons.  CS-STUAGG-013  Example result of the implemented algorithm:  lenders = [A, B, C, D]   aprs = [0, 1, 0, 0]   result of the sorting: [A, D, B, C]   correct result should have B at the end of the array    Sturdy - Sturdy Aggregator -   11  CriticalHighMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion2CodeCorrectedVersion2           \fThe  codebase  has  been  updated  so  that  the  array  of  APRs  is  also  updated  along  with  the  array  of lenders, fixing the issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Idle Assets Not Used for requestLiquidity", "body": "  CS-STUAGG-001  In DebtManager, requestLiquidity() has the following check:  if (requiredAmount > totalIdle) {         unchecked {             requiredAmount -= totalIdle;         }     }  This will use idle liquidity to partially fulfill a request, but only if the requiredAmount is more than the idle amount.  If there are enough idle assets to cover the entire requiredAmount, they will not be used at all.    The  code  has  been  updated  such  that  if  the  totalIdle  amount  is  greater  or  equal  to  the requiredAmount, the idle assets will be used and nothing will be pulled from other lenders.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Utilization Limit Does Not Take Into Account", "body": " JIT Liquidity  When borrowing from a silo, even if JIT liquidity can be performed, there is a limit on the utilization of the silo before the liquidity transfer. The utilization of the silo, before JIT liquidity is taken into account, cannot exceed 100%.  CS-STUAGG-002  Example:  1. Silo A has 100k, silo B has 900k.  2. A user wants to borrow 300k from silo A, but this will revert since the computed utilization rate will  be 3 * PREC_UTIL (300%).    The utilization limit check before JIT liquidity is taken into account has been removed.  Sturdy - Sturdy Aggregator -   12  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \f6.4   Utilization Limit Only Enforced on Requesting Lender  When calling borrowAsset(), the utilization limit is only enforced on the requesting silo, but not on the other lenders, which can be fully utilized if JIT liquidity is used.  There could be situations where all the silos are fully utilized but one.  CS-STUAGG-014    The utilization limit can now be set per lender in DebtManager and is enforced in borrowAsset in the requesting lender, but also in the lenders from which the liquidity is being pulled.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   utilizationLimit Is Not Always Enforced", "body": "  In borrowAsset(), requestLiquidity() is called with the _amount that should be deposited to the Silo such that the utilizationLimit is respected. However, requestLiquidity() can deposit a smaller amount than what is expected.  The amounts that are withdrawn from other lenders by the aggregator are calculated as follows:  CS-STUAGG-003  newDebt = aggregator.update_debt(lenders[i], newDebt);         unchecked {             withdrawAmount = lenderData.current_debt - newDebt;         }  This does not always correctly calculate the withdrawAmount. When withdrawing from a lender, there can be an unexpected loss. In this case, the withdrawn amount will be smaller than the change in debt.  Consider the following excerpt from VaultV3, which is the implementation of aggregator:  # making sure we are changing idle according to the real result no matter what. # We pull funds with {redeem} so there can be losses or rounding differences. withdrawn: uint256 = min(post_balance - pre_balance, current_debt)  # If we got too much make sure not to increase PPS. if withdrawn > assets_to_withdraw:     assets_to_withdraw = withdrawn  # Update storage. self.total_idle += withdrawn # actual amount we got. # Amount we tried to withdraw in case of losses self.total_debt -= assets_to_withdraw  new_debt = current_debt - assets_to_withdraw  The  withdrawAmount  value  that  should  be  calculated  in  requestLiquidity()  is  actually withdrawn, the change in total_idle.  Sturdy - Sturdy Aggregator -   13  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected              \fIf there is a loss while withdrawing from the lender, an insufficient amount of totalIdle will be available when  depositing  than utilizationLimit, but in cases where losses are large or utilizationLimit is configured to be close  to  100%,  the  Silo.borrowAsset()  call  at  the  end  of  SiloGateway.borrowAsset()  will revert, as there will not be enough funds in the Silo.  to  a  higher  utilization   In  most  cases   the  Silo.   this  will   lead   to   :  The  code  now  uses  an  accurate  amount  of  tokens  to  reduce  requiredAmount.  However,  two conditions have been added in the DebtManager.requestLiquidity() logic.  One early-return check in the for loop:  if (requiredAmount < minIdle) break;  And one require check after the for loop:  require(requiredAmount <= minIdle, Errors.AG_INSUFFICIENT_ASSETS);  Recall that requiredAmount = amount + minIdle. If requiredAmount is greater than 0, it means that  the  current  idle  amount  is  smaller  than  amount  +  minIdle.  When  updating  the  debt  of  the requesting  lender,  the  aggregator  will  still  keep  minIdle  and  the  amount  sent  to  the  lender  can  be smaller than amount. This would lead to the requesting lender exceeding its utilizationLimit.    The  codebase  has  been  updated  so  that  DebtManager.requestLiquidity()  compares  the aggregator's totalIdle before and after the call to update_debt() to know exactly how many tokens have been withdrawn from the lender.  The early-return check has been removed and the require check corrected to  require(requiredAmount == 0, Errors.AG_INSUFFICIENT_ASSETS);  which ensures that enough assets have been retrieved.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Incorrect Code Comment", "body": "  On the manualAllocation function, there is the following comment:  CS-STUAGG-005  @dev Manual update the allocations. Calculate the newAPR, curAPR and if newAPR < curAPR then it would be failed.  However, there is no check in the code that makes the call fail if newAPR < curAPR. The admin could input any manual allocation, no matter the resulting APR.  Spec changed:  The comment has been removed.  Sturdy - Sturdy Aggregator -   14  Version2CorrectnessLowVersion1Speci\ufb01cationChanged          \f6.7   Reentrancy Guards Applied Inconsistently  The SiloGateway has a reentrancy guard on its borrowAsset function, but DebtManager does not have a reentrancy guard on requestLiquidity().  Note  that  there  can  be  multiple  SiloGateway  for  each  DebtManager,  so  it  could  technically  be possible to reenter requestLiquidity().  CS-STUAGG-012    A reentrancy guard has been added to requestLiquidity() in DebtManager.  It  has  also  been  clarified  that  the  system  is  not  intended  to  be  used  with  reentrant  tokens  such  as ERC-777.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Gas Optimizations", "body": "  CS-STUAGG-006  1. The  functions  DebtManager.removeLender  and  SiloGateway.borrowAsset  could  be  payable to save gas.  2. In the function DebtManager.requestLiquidity the condition for continue could be moved  at the beginning of the for loop. This avoids unnecessarily loading from storage.  3. The function DebtManager.requestLiquidity could avoid the big for loop if the totalIdle  amount is enough to cover requiredAmount.  4. The  function  DebtManager.sortLendersWithAPR  makes  a  lot  of  calls  to  the  APR  oracle.  These calls could be cached to avoid querying the same value multiple times.    1. No change. Sturdy states:  Since anyone can call DebtManager.removeLender and SiloGateway.borrowAsset, they should not be payable in order to prevent the user from potentially sending ether and losing funds.  2. The condition has been moved at the beginning of the loop.  3. If the total idle assets are enough to cover the required amount, the loop is completely skipped.  4. The APR is queried once for every lender in an independent loop before sorting.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Misleading Error Names", "body": "   The  error  returned  by  DebtManager._manualAllocation()  when  the  new  debt  exceeds  the  lender's max debt should be AG_HIGHER_DEBT  CS-STUAGG-007  Sturdy - Sturdy Aggregator -   15  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                  \f The error returned by DebtManager.requestLiquidity() when the requiredAmount is not  equal to zero should be AG_INSUFFICIENT_ASSET   The errors returned when the lender's address is not active should be AG_INVALID_LENDER    The error names have been changed to more accurately reflect the error.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Missing Input Sanitization", "body": "  The  SiloGateway  utilizationLimit_. It could accidentally be set to more than 100%.  constructor  and  setUtilizationLimit   CS-STUAGG-008  function  do  not   sanitize    The logic related to the utilization limits has been moved to the DebtManager, where input sanitization is properly done. The limits are enforced to be strictly smaller than UTIL_PREC.  Sturdy - Sturdy Aggregator -   16  InformationalVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   manualAllocation Can Ignore Unrealized", "body": " Losses  In manualAllocation(), there is the following check:  if (lenderData.current_debt == position.debt) continue;  CS-STUAGG-011  This is intended to skip a lender if there should be no change to its debt.  the  current_debt  However,  assess_share_of_unrealised_losses().  value  may  be  outdated,  as   there   is  no   call   to  As a result, the debt of the position when including unrealized losses may be different than expected.  Acknowledged:  Sturdy responded:  Unrealised losses will be very rare; in the event they do occur, process_report() will be called before manualAllocation() to prevent a discrepancy.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   zkAllocation Could Contain Duplicates", "body": "  In  _manualAllocation(),  there  is  no  check  that  unique  lenders  are  included  in  the  input. zkAllocation() has a length check on the new positions array, but there may be duplicate entries.  The admin may call _manualAllocation() with any values.  Additionally,  the  existence  check  for  positions  happens  after  continue.  As  a  result,  a  non-existent position could be included in the array if the new position.debt is 0.  CS-STUAGG-009  Acknowledged:  Sturdy responded:  To reduce gas costs, we don't check duplicate entries. This is a permissioned function, so the admin and zkVerifier will avoid duplicated lenders.  Sturdy - Sturdy Aggregator -   17  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged          \fAdditionally,  the  existence  check  for  positions  has  been  moved  to  before  the  continue  in  the _manualAllocation loop.  Sturdy - Sturdy Aggregator -   18  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Exchange Rate Rounding Errors", "body": "  BaseConicPool.deposit() allows users to add funds to the protocol while no shares are minted. On a  new  pool,  a  user  can  donate  some  tokens  to  the  contract  before  calling  deposit()  with  an underlyingAmount of 0. The donated tokens are then added to the contract holdings while no shares are minted for the user. After that, the user can deposit 1 wei of tokens, minting them exactly 1 wei of shares.  CS-CCP-006  The exchange rate is skewed:  totalUnderlying_.divDown(lpSupply);  Since the amount of deposited tokens by other users is divided by this exchange rate to determine the amount  of  minted  shares,  the  results  can  include  large  rounding  errors.  Users  that  are  not  depositing multiples of the initially deposited amount will incur slippage (up to 100%) which results in either Denial of Service or, if they choose a loose slippage parameter, loss of funds.  For  example,  a  donation  of  10,000  USDC  and  a  subsequent  deposit  of  another  user  of  15,000  USDC would result in the second user getting only 1 wei of LP tokens, thus losing 2,500 USDC to the first user.  It is also possible to burn LP tokens without decreasing the underlying in withdraw().  Conic - Conic Protocol -   15  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedLowRiskAcceptedCodePartiallyCorrectedRiskAcceptedRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAccepted              \fRisk accepted:  Conic accepts the risk claiming that all pools will be atomically seeded by the team on deployment. In that case, the mentioned attack is not possible.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   No Governance Default Delay", "body": "  Conic governance decisions are computed off-chain. Based on the results, a multi-sig address with the GOVERNANCE_ROLE  on  the  GovernanceProxy  can  then  request  changes  and  execute  them. Depending  on  the  function  signatures  these  changes  are  going  to  call,  a  delay  is  invoked  so  that  a separate multi-sig address (VETO_ROLE) that belong to different entities can veto the change.  However,  no  default  delay  is  enforced  which  means  that  the  GOVERNANCE_ROLE  can  perform  any actions that have not explicitly been marked directly, evading any possible vetos.  CS-CCP-008  Risk accepted:  Conic accepts the risk with the following statement:  We do not want a delay for all the functions. The community and veto multisig can easily check which functions have a delay and which does not.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Instant Rewards", "body": "  RewardManager performs reward calculations and actual reward claiming in separate steps. Only when certain conditions are met, rewards are actually claimed. This approach is, however, flawed for Convex' extra rewards as the reward calculation is only performed during the claim step here. If claiming has not occurred for a longer period, the accrued extra rewards are added to the earned rewards of all users in bulk the next time they are claimed.  CS-CCP-018  that   User  call RewardManager.claimPoolEarningsAndSellRewardTokens() directly after staking and instantly receive some CNC rewards in this case.  LpTokenStaker   deposited   tokens   have   can   the   LP   to   Risk accepted:  Conic accepts the risk with the following statement:  Very  few  pools  have  extra  rewards  (not  any  that  we  currently  support)  and  the  chances  of  these rewards becoming an important part of the APR is low enough for us to accept this risk.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Missing Checks", "body": "  The protocol is missing some checks that could potentially lead to a problematic state:  CS-CCP-021  Conic - Conic Protocol -   16  SecurityMediumVersion1RiskAcceptedDesignLowVersion1RiskAcceptedCorrectnessLowVersion1CodePartiallyCorrectedRiskAccepted                          \f RewardManager.addExtraReward() checks that the added reward token is not an LP token of one of the Curve pools of the associated LP tokens. If, however, a Curve pool is added to the Conic pool at a later stage, its LP token might have already been added.   RewardManager.addExtraReward()  does  not  check  whether  there  is  a  valid  SushiSwap  or  Curve pool for a given reward token.   Neither   nor _swapRewardTokenForWeth() check whether a given Curve pool actually holds the asset that is going to be swapped on it.  RewardManager.setExtraRewardsCurvePool()    RewardManager.removeExtaReward()  does  not  check   that   the  specified  argument   is  successfully removed from the extra rewards list.   Bonding.startBonding()  does  not  check  whether  an  epochPriceIncreaseFactor  is  set.  Since there exists a minimum for the factor, it should be set before starting the bonding period.  Code partially corrected:  Bonding.startBonding() now checks if the epochPriceIncreaseFactor has already been set.  Risk accepted:  Conic accepts the risk for all other missing checks with the following statement:  We accept the risk for the extra rewards.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   No Reward Checkpoint When Unstaking", "body": "  LpTokenStaker.unstakeFor() does not call RewardManager.accountCheckpoint() when the staker is shut down. Users unstaking on such a shut down staking contract will lose their rewards since the last checkpoint but users that call accountCheckpoint() before unstaking will keep their rewards.  CS-CCP-022  Risk accpted:  Conic accepts the risk with the following statement:  This is an extremely rare event, in which case we will inform our users beforehand so that they claim their rewards.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.6   Stale Oracle Price Means Token Is Not", "body": " Supported  ChainlinkOracle.isTokenSupported()  calls  getUSDPrice()  to  determine  whether  a  token  is supported by the oracle. If the price is stale (older than the heartbeat), the function erroneously returns false.  CS-CCP-024  Conic - Conic Protocol -   17  DesignLowVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                \fRisk accepted:  Conic accepts the risk with the following statement:  We only use isTokenSupported in two places:  1. When adding a new curve pool to the registry. If it fails here, we can retry later.  2. When  claiming  extra  token  rewards.  In  the  unlikely  event  that  it  fails  here,  we  accept  the  slippage risk when swapping extra rewards.  Conic - Conic Protocol -   18    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Endless Rebalancing    Execution of Wrong Governance Change   -Severity Findings   Depeg Due to Oracle Manipulation    Wrong Accounting in Bonding   -Severity Findings   Bonding lastCncPrice Manipulation With Leftover Dust    Extra Reward Tokens Not Sent to RewardManager    Higher Imbalance Tolerance in Metapools   Incomplete Pool Balance Check    Oracle Price Manipulation    Reward Double Counting    Slippage Losses Are Socialized    Weight Update Rounding Errors    Wrong Denomination of Deviation Delta   -Severity Findings   Possible Zeroed Pool Weight Increase    Reward Factor Override    Boost After Shutdown    CNCLockerV3 Lock Squatting    Claimable Rewards Potentially Wrong    Enabled Fee Not Reset    Endless Loop    Lock Spam DoS    Minimum Tainted Transfer Amount Can Be Circumvented    Rebalancing Reward After Depeg    Unreachable Imbalance Buffers    Wrong TVL Factor    Wrong Time to Full Boost   Informational Findings  Conic - Conic Protocol -   2  2  9  13  9  19  CriticalCodeCorrectedCodeCorrectedHighCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected \f removeDuplicates Not Working With 0 Elements    Fees Without Locked CNC    Exchange Rate Race Condition   Interface Differences    Ambiguous Naming    Typographical Errors    Rebalancing Reward Formula Mismatch    Missing Events    Shadowed Variables   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Endless Rebalancing", "body": "  CS-CCP-001  As detailed in Depeg due to oracle manipulation, Curve pools can be depegged wilfully at any time. On new Conic pools, or pools with very low TVL, this is even more problematic because an infinite amount of rebalancing rewards can be claimed.  This is possible by donation of Curve LP tokens to the Conic pool. When the attacker is the only liquidity provider on a Conic pool, or if they hold most of the LP tokens, all donated value is given straight back to them. Therefore, the donations are free (or almost free), enabling this attack:  1. The attacker deposits to an empty Conic pool.  2. The attacker depegs one of the underlying Curve pools, enabling rebalancing rewards.  3. The  attacker  rebalances  the  Conic  pool  to  almost  the  maxDeviation  threshold,  so  that  the  rebalancing rewards are still active.  4. The attacker adds liquidity directly to the Curve pool, sends these tokens to the Conic pool.  5. The attacker repeats step 3 and step 4 as often as possible.  6. The attacker withdraws their LP tokens from the Conic pool (in the next block).  As long as the attacker gains more CNC rewards per iteration than they lose to other Conic LPs (only relevant if they are not the only LP), the attack is profitable and can be performed indefinitely, allowing them  to  mint  CNC  up  to  the  _MAX_REBALANCING_REWARDS.  The  only  cost  is  the  amount  of  tokens needed to increase the LP token price of a given Curve pool by the depeg threshold. Therefore, small Curve pools are more vulnerable.    A  new  (off-chain)  threshold  for  a  pool's  TVL  is  introduced  which  has  to  be  passed  before  rebalancing rewards  are  activated.  In  practice,  this  is  done  via  governance  change  that  calls  the  function BaseConicPool.setRebalancingRewardsEnabled(). Additionally, rebalancing rewards now start from  0  after  a  pool  has  been  marked  as  depegged.  This  ensures  that  the  attack  does  not  become instantly  profitable.  With  a  reward  factor  of  10,  the  attacker  has  to  wait  1.4  days  to  achieve  the  same result as before.  Conic - Conic Protocol -   20  CodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedDesignCriticalVersion1CodeCorrected           \f6.2   Execution of Wrong Governance Change  GovernanceProxy.executeChange() gets a storage pointer to the change corresponding to a given ID, deletes the change from storage and then tries to execute the change.  The change is deleted in the following way:  CS-CCP-002  pendingChanges[index] = pendingChanges[pendingChanges.length - 1]; pendingChanges.pop();  If the change is the last one in the pendingChanges array, then nothing is executed at all. If the change is any other change, the last change in pendingChanges will be executed instead of the correct one.    A given pending change is now deleted after all calls have been performed. To ensure that the change cannot re-execute itself, a new state Executing has been introduced that is set over the duration of the calls. Only Pending changes can be executed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Depeg Due to Oracle Manipulation", "body": "  CS-CCP-003  Deposit and withdraw functions of ETH pools are protected against reentrancy from Curve pools which disables the ability of attackers to manipulate the totalSupply() function of Curve and therefore the manipulation  of  the  CurveLPOracle.  Furthermore,  the  oracle  checks  that  a  given  Curve  pool  is balanced by comparing the Chainlink oracle prices of the underlying tokens with the actual price of the tokens on the Curve pool (using get_dy()). This ensures that an attacker cannot perform large trades on the pool before calling Conic, which would also skew the LP token price.  There  exists,  however,  another  possibility:  Fee  accrual  on  the  Curve  pool  that  results  in  the  LP  token price  becoming  (permanently)  inflated.  While  this  is  not  a  problem  for  deposits  and  withdrawals,  the mechanism can be used to call BaseConicPool.handleDepeggedCurvePool() and set the weight of the pool to 0. This automatically enables rebalancing rewards. An attacker can then rebalance the pool and gain the rebalancing rewards. The fees can be accrued with a single, large, bi-directional trade.  Since handleDepeggedCurvePool() does not set the timestamp for pool weight updates, the reward for  rebalancing  is  instantly  available.  If  a  pool  is  depegged  right  before  a  weight  update  (which  is estimated  to  happen  around  every  14  days),  the  reward  can  be  as  high  as  280  CNC  per  10.000  USD value rebalanced.  Consider the following example:  1. A Conic pool exists that contains two Curve pools with 3 assets holding 100k tokens each. Weights  are [0.5, 0.5].  2. An attacker (iteratively) adds 900k tokens liquidity per asset to the first Curve pool (by adding the Conic pool's underlying via Conic and the rest via Curve). The attacker also has to add liquidity to the  other  Curve  pool  to  ensure  that  everything  keeps  balanced.  These  tokens  can  be  withdrawn again later.  3. The first Curve pool's value is now roughly 3M. With the aforementioned fee donation attack, the  attacker increases the value of the pool to 3.09M.  Conic - Conic Protocol -   21  CorrectnessCriticalVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected              \f4. The  attacker  now  depegs  the  first  Curve  pool  and  rebalances  900k  on  Conic,  netting  them  ~25k  CNC tokens.  5. The  attacker  withdraws  liquidity  from  Conic  and  Curve.  They  get  back  up  to  90%  of  the  donated 90k fees to Curve (depending on the Curve pool setup) as they hold 90% of the liquidity of the pool.  6. Depending on the amount of fees the attacker gets back, and the current market value of CNC, this  attack becomes profitable.  The  attack  can  be  scaled  infinitely  with  sufficient  holdings  and  also  becomes  more  profitable. Rebalancing and liquidity provision to Curve can be done with flash loans while the liquidity provision to Conic requires capital as a deposit cannot be withdrawn in the same block.    Depegs are now identified by comparing Chainlink prices of all underlying tokens to their cached price. As there are no longer any LP token prices involved, there is no possibility for manipulation (except broad market manipulation).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Wrong Accounting in Bonding", "body": "  Bonding._checkpointAccount()  calculates  the  already  accrued  stream  of  LP  tokens  that  can  be unstaked by multiplying the user's rewards boost with the difference of the total integral and the user's integral since the last checkpoint:  CS-CCP-004  uint256 accountBoostedBalance = cncLocker.totalRewardsBoost(account); perAccountStreamAccrued[account] += accountBoostedBalance.mulDown(     streamIntegral - perAccountStreamIntegral[account] ); perAccountStreamIntegral[account] = streamIntegral;  The streamIntegral is computed with CNCLockerV3.totalBoosted() amount which is the total of the  locked  CNC  times  the  boosts  of  each  user.  The  accrued  stream  of  users  is  computed  with totalRewardsBoost() which also contains balances of the old CNCLockerV2 contract and does not contain CNC of locks that have already expired:  function totalRewardsBoost(address account) public view override returns (uint256) {     return         lockedBoosted[account] -         unlockableBalanceBoosted(account) +         ICNCVoteLocker(V2_LOCKER).balanceOf(account); }  Since totalBoosted() is smaller than the sum of totalRewardsBoost() for all users, there can be more claims than could be satisfied. Consider the following scenario:  1. User 1 has a totalRewardsBoost() of 1000 tokens.  2. User 2 has a totalRewardsBoost() of 0.  3. totalBoosted() is 0.  4. User 2 calls bondCncCrvUsd() with an amount of 1000 LP tokens and gets a bonding price of 1.  Conic - Conic Protocol -   22  CorrectnessHighVersion1CodeCorrected        \f5. After 2 epochs, user 1 calls checkpointAccount(). streamIntegral is set to 1. Since user 1 has a balance of 1000 tokens in totalRewardsBoost() but their account integral has not been set yet, perAccountStreamAccrued for user 1 is updated to 1000 tokens.  6. User 1 calls claimStreamed() and receives 1000 LP tokens.  7. User  2  can  still  accrue  1000   in  perAccountStreamAccrued  by  calling checkpointAccount().  But  they  cannot  claim  the  stream  anymore,  since  the  1000  LP  tokens have already been unstaked.  tokens   Additionally,  it  is  problematic  that  the  integral  calculation  with  totalBoosted()  does  not  consider unlockable CNC as the calculation might result in an integral smaller than it should be.    now   Bonding  of totalRewardsBooost() to calculate the integral of individual accounts. This function only returns the locked boost of a user which matches the calculation for the total integral.  CNCLockerV3.totalStreamBoost()   function   instead   uses   the   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Bonding lastCncPrice Manipulation With", "body": " Leftover Dust  During every bonding epoch, there will likely be some CNC dust left-over since it is hard to estimate the exact amount of LP tokens to bond in order to acquire all the CNC up to the last decimal. Some of this CNC  dust  can  however  be  acquired  just  before  the  epoch  ends  for  the  purpose  of  manipulating lastCncPrice to be MIN_CNC_START_PRICE, even if the actual bonding happened at a much higher price.  CS-CCP-005    A minBondingAmount has been added that can be set to up to 1,000 LP tokens. This ensures (if set to a sensible value) that leftover dust cannot be acquired.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Extra Reward Tokens Not Sent to", "body": " RewardManager  RewardManager._swapRewardTokenForWeth() assumes the extra rewards reside on the contract. This  is  not  true  as  all  tokens  are  sent  to  the  corresponding  Conic  pool  and  are  never  sent  to  the RewardManager. No approvals from Conic pools to their reward managers exist for these extra tokens.  CS-CCP-007    BaseConicPool  now  has  a  function  updateRewardSpendingApproval()  that  allows  to  set approvals of arbitrary tokens to the RewardManager. It is called each time a new reward token is added.  Conic - Conic Protocol -   23  SecurityMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f_sellRewardTokens() now transfers tokens from the respective Conic pool to the RewardManager before they are swapped.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Higher Imbalance Tolerance in Metapools", "body": "  In CurveLPOracle.getUSDPrice(), the pool balancing for Metapools is checked twice, once for the wrapping  Metapool,  and  once  for  the  base  pool.  This  allows  both  pools  to  be  unbalanced  up  to  the maximum threshold, which is twice the imbalance threshold that would apply to a single pool.  CS-CCP-044    A  new  customInternalImbalanceBuffers  storage  mapping  has  been  added  that  allows  to  set custom imbalance buffers for LP tokens of a base pool. If these parameters are set in the right way, the threat can be mitigated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Incomplete Pool Balance Check", "body": "  CurvePoolUtils.ensurePoolBalanced()  compares  Chainlink  prices  to  the  prices  returned  by  a Curve  pool's  get_dy()  function.  The  checks  are  always  performed  from  the  first  asset  to  all  other assets. In pools with more than 2 assets, this can become problematic.  CS-CCP-045  Consider the following scenario:  1. A Curve pool with 3 assets holds exactly 1000 tokens per asset (perfectly balanced).  2. The Curve pool accrues 0 fees (for simplicity) and has an A parameter of 2000.  3. An attacker trades 900 tokens from asset 1 to asset 2.  4. The attacker also trades 800 tokens from asset 1 to asset 0.  5. get_dy(0, 1) returns ~1.04.  6. get_dy(0, 2) returns ~0.96.  7. get_dy(1, 2) returns ~0.92.  With an imbalance buffer of 4% (simply for demonstration purposes, in production this would be smaller), the pool would still be considered balanced while there is an imbalance of 8% between asset 1 and 2.    The function now checks all combinations of tokens in a given pool.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Oracle Price Manipulation", "body": "  Conic - Conic Protocol -   24  CS-CCP-009  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                        \fDeposit and withdraw functions in Conic ETH pools are protected against reentrancy from a Curve pool that can potentially manipulate LP token prices. This is, however, not true for some other functions.  InflationManager.updatePoolWeights() can be called by reentering from a Curve pool resulting in  skewed  pool  weights  as  the  calculation  relies  on  prices  of  the  CurveLpOracle  which  can  be manipulated by removing liquidity from a Curve pool that holds ETH and then reentering to the function in the callback.  BaseConicPool.handleInvalidConvexPid()  the totalDeviationAfterWeightUpdate storage variable which is, however, not used anywhere in the code.  manipulate   allows   to   Furthermore,  onlyOwner  functions  that  are  called  from  the  GovernanceProxy  (if  they  have  a  delay) are  also  principally  open  to  this  manipulation  as  the  changes  can  be  executed  by  any  user. Controller.updateWeights()  and  updateAllWeights()  can  be  tricked  into  writing  wrong  LP token prices into the _cachedPrices of BaseConicPool, which can then be used to set the weight of a Curve pool to 0 with handleDepeggedCurvePool().    All  mentioned  functions  are  now  executing  reentrancy  checks  similarly  to  the  deposit  and  withdraw functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Reward Double Counting", "body": "  RewardManager.poolCheckpoint()  accrues  rewards  by  storing  a  total  integral  and  holdings  since the last checkpoint per reward token:  CS-CCP-010  function _updateEarned(     bytes32 key,     uint256 holdings,     uint256 earned,     uint256 _totalSupply ) internal {     _rewardsMeta[key].earnedIntegral += earned.divDown(_totalSupply);     _rewardsMeta[key].lastHoldings = holdings; }  After  claiming  the  regular  rewards,  _claimPoolEarningsAndSellRewardTokens()  claims  extra rewards on Convex and swaps them for CNC. These additional CNC rewards are then added to the total integral. The last holdings, however, are not updated accordingly.  if (_totalStaked > 0)     _rewardsMeta[_CNC_KEY].earnedIntegral += receivedCnc_.divDown(_totalStaked);  As the CNC holdings of the contract increase, but the last holdings do not, the next checkpoint will count these tokens as new rewards again and add them to the integral again:  cncHoldings = CNC.balanceOf(conicPool); ... uint256 cncEarned = cncHoldings - _rewardsMeta[_CNC_KEY].lastHoldings;  Conic - Conic Protocol -   25  CorrectnessMediumVersion1CodeCorrected        \f... _updateEarned(_CNC_KEY, cncHoldings, cncEarned, _totalStaked);    _claimPoolEarningsAndSellRewardTokens()  now  correctly  sets  the  lastHoldings  for  CNC after  selling  reward  tokens.  Additionally,  if  rewards  have  to  be  claimed  in  claimEarnings(),  the account  share  of  the  calling  user  is  updated  again  after  the  rewards  tokens  have  been  swapped  to ensure that the user receives the extra reward in the same call.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Slippage Losses Are Socialized", "body": "  BaseConicPool.depositFor()  calculates  the  amount  of  LP  tokens  a  user  receives  based  on  the value  of  the  whole  pool.  When  slippage  is  incurred,  this  is  problematic  as  the  depositor  might  receive more LP tokens than they should, resulting in a loss for all other liquidity providers. Consider the following example with simplified numbers:  1. A Conic pool contains one Curve pool with two tokens, 1000/1000 liquidity, 2000 LP total supply,  token prices of 1 and an LP price of 1.  2. The Conic pool holds 1000 of the LP tokens and the Conic LP token has a total supply of 1000.  CS-CCP-040  3. A user deposits 1000 token 0 to Conic.  4. Conic receives 900 LP tokens from Curve (slippage of 10%).  5. The Curve pool now holds 3000 USD value and has 2900 LP tokens total supply. Conic owns 1900  of these LP tokens.  6. Due to the slippage, the LP price of the Curve pool according to Conic now increased to 1.0345.  7. underlyingBalanceAfter therefore is now 1965, so the delta is 965.  8. The user now receives 965 Conic LP tokens for their deposit of 1000 tokens.  9. The Conic pool holds a total of 1900 Curve LP tokens which means the user's share of the Curve LP  tokens  now  is  933  while  the  Conic  pool  only  received  900  Curve  LP  tokens  for  the  user's deposit.    If the price of a Curve pool's LP token increases during a deposit, the price before the deposit is used to calculate the amount of LP tokens the user receives.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Weight Update Rounding Errors", "body": "  BaseConicPool._setWeightToZero() sets the weight of a given pool to 0 and scales the weights of all other pools accordingly to reach at a total weight of 1. This is done by computing a scale factor which involves  a  division.  This  division  can  result  in  rounding  errors  which  will  be  passed  to  the  upscaled  CS-CCP-011  Conic - Conic Protocol -   26  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \fweights.  Therefore,  it  is  possible  that  the  total  weight  after  the  operation  is  slightly  smaller  than  1, breaking the invariant that the sum of all weights must equal exactly 1.  In turn, this can become problematic when rebalancing rewards are active (which is the case after the function has been called) as deposit / withdrawal maximums are now calculated without maxDeviation gaps.  Consider the following example:  1. A   Conic   pool   has   two   Curve   pools   with   weights  [666666666666666667, 333333333333333333].  2. The first pool is depegged, resulting in the following weights: [999999999999999999].  3. A user deposits 101 tokens with 18 decimals. _getDepositPool() returns a maximum amount of  100.999999999999999899  tokens  that  can  be  deposited  to  the  Curve  pool.  Including  the  1e2 constant in _depositToCurve(), the user's deposit can not completely be satisfied and the call results in a revert after a second iteration of getDepositPool().    _setWeightToZero() now adds the remaining weight to the last element that is not equal to the pool being set to 0-weight instead of multiplying its weight with the scaling factor. This ensures that all weights , if the last pool had already 0-weight, it will incorrectly receive always sum up to 1. However, in  the remaining weight, setting the pool weight to a non-zero value as explained in Possible zeroed pool weight increase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Wrong Denomination of Deviation Delta", "body": "  CNCMintingRebalancingRewardsHandler.computeRebalancingRewards()  rebalancing rewards with the following formula:  CS-CCP-012  computes  (elapsedSinceUpdate * cncRebalancingRewardPerDollarPerSecond).mulDown(     deviationDelta.convertScale(decimals, 18) );  The cncRebalancingRewardPerDollarPerSecond factor is per Dollar. It is therefore assumed that deviationDelta  should  be  in  USD  denomination.  This  is,  however,  not  the  case  as  the  value  is  in underlying.  For example, rebalanced deviation of 10.000 USDC would net ~0.833 CNC per hour, while a rebalanced deviation if 5 ETH (roughly the same value as the 10.000 USDC) would only net ~0.0004166 CNC.    The formula has been corrected by multiplying the amount with the current price of the underlying token.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Possible Zeroed Pool Weight Increase", "body": "  Conic - Conic Protocol -   27  CS-CCP-041  Version2CorrectnessMediumVersion1CodeCorrectedCorrectnessLowVersion2CodeCorrected                \fBaseConicPool._setWeightToZero()  sets  the  weight  of  the  last  pool  that  is  not  the  pool  whose weight is set to 0 to the leftover weight so that the total weights equal to exactly 1.  If this pool has already been set to 0 weight previously, the weight might increase again by some dust.    The function now filters out all pools with 0 weight before performing the scaling.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   Reward Factor Override", "body": "  In  BaseConicPool.handleDepeggedCurvePool,  the  rebalancingRewardsFactor  is  set  even when rebalancing rewards are not activated. If rebalancing rewards have been activated before due to a weight update and the function is called on an empty pool, the reward factor is set regardless.  CS-CCP-042    The reward factor is now only set when rebalancing rewards are activated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Boost After Shutdown", "body": "  LpTokenStaker.unstakeFrom()  calculates  _stakerCheckpoint()  even  after  the  contract  has been shut down, further increasing the boost of the users.  CS-CCP-013    unstakeFrom()  now  if  _stakerCheckpoint() (and RewardManager.accountCheckpoint()).  contract  has  been   checks   the   shut  down  before   calling  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   CNCLockerV3 Lock Squatting", "body": "  Similarly to issue Lock spam DoS, a user who wants to avoid having its lock ever kicked (for example to use an airdropped boost indefinitely) can create a very big amount of 1 wei locks before and after the lock they wish to protect. Unlocking those locks will be very gas expensive for other users, and the cost will surpass  the  gas  cost  of  running _getLockIndexById() will exceed the block gas limit.  the  kicking  reward.  Kicking  will  not  be  possible  since   CS-CCP-014    Conic - Conic Protocol -   28  CorrectnessLowVersion2CodeCorrectedCorrectnessLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                        \fA _MIN_LOCK_AMOUNT of 10 CNC has been introduced. Additionally, _MAX_LOCKS restricts the amount of locks a single account can hold to 10. It is now impossible to create enough locks for an account to be able to squat a certain lock.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.18   Claimable Rewards Potentially Wrong", "body": "  RewardManager.claimableRewards()  returns  0  if  the  balance  of  a  Conic  pool  is  0  in  the LpTokenStaker. This is not correct if the pool already accrued some rewards and later all tokens are unstaked (for example after shutdown).  CS-CCP-015    claimableRewards() now does not return early if the balance of a Conic pool is 0 and instead returns the correct value.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   Enabled Fee Not Reset", "body": "  RewardManager.setFeePercentage() does not reset feesEnabled to false when the fee is set back to 0.  CS-CCP-016    feesEnabled is now set to false when the fee is set to 0.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   Endless Loop", "body": "  RewardManager.poolCheckpoint()  claims  rewards  from  Convex  and  the  LpTokenStaker  if certain  conditions  are  met  (either  if  there  are  not  enough  funds  to  cover  fees  or  if  the  Convex  cliff  is approaching). If one of the conditions is met, and additionally the current _INFLATION_RATE_PERIOD has  ended  in  the  InflationManager,  then  the  function  executes  an  endless  loop  that  calls  back  to itself (because the conditions are still met at the time of the callback) until the transaction runs out of gas. The callpath is as follows:  CS-CCP-017  1. RewardManager.poolCheckpoint().  2. RewardManager._claimPoolEarningsForCliff() (optional).  3. RewardManager._claimPoolEarningsAndSellRewardTokens().  4. RewardManager._claimPoolEarnings().  5. LpTokenStaker.claimCNCRewardsForPool().  6. LpTokenStaker._claimCNCRewardsForPool().  7. InflationManager.executeInflationRateUpdate().  Conic - Conic Protocol -   29  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f8. InflationManager._executeInflationRateUpdate().  9. InflationManager.updatePoolWeights().  10. RewardManager.poolCheckpoint().  It  is  also  worth  to  note  that  the  subsequent  calls  of  LpTokenStaker.claimCNCRewardsForPool() increase  the  amount  of  CNC  minted  every  time  since  the  poolShares  are  only  reset  after  the  call  to InflationManager.executeInflationRateUpdate() while the shares are minted before. A fix of the issue should take this into consideration.    LpTokenStaker._claimCNCRewardsForPool()  InflationManager.executeInflationRateUpdate() so there is no loop anymore.  longer   no   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.21   Lock Spam DoS", "body": "  calls  CS-CCP-019  CNCLockerV3.lockFor() allows anyone to create a lock for a given account. An attacker can create a big amount of 1 wei locks on a victim account, such that if a legitimate lock is then created unlocking it becomes impossible as the cost of running _getLockIndexById() exceeds the block gas limit.  This  attack  allows  an  actor  to  effectively  freeze  any  CNC  that  is  to  be  locked  by  a  specific  user.  It  is extremely costly though (Around $27k in gas fees at gas price 45 Gwei and ETH value $2000).    A _MIN_LOCK_AMOUNT of 10 CNC has been introduced. Additionally, _MAX_LOCKS restricts the amount of locks a single account can hold to 10. It is now impossible to create enough locks for an account to be able DoS it. However, as described in note Locking in CNCLockerV3 can potentially fail if too many locks exist , some annoyance could be caused by an attacker willing to spend 100 CNC to create 10 locks for another user.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.22   Minimum Tainted Transfer Amount Can Be", "body": " Circumvented  LpToken  sets  a  flag  on  accounts  that  mint()  or  burn()  that  disables  them  from  minting  or  burning again in the same block. Since LP tokens can be transferred, the flag also has to be set on all addresses that the tokens are sent to.  To  prevent  cheap  DoS  attacks  on  arbitrary  accounts  that  deposit  or  withdraw  on  a  Conic  pool,  there exists a minimum threshold. Minting / burning of less than this amount will not set the flag.  The  tainting  mechanism  is  not  in  use  when  users  stake  their  minted  tokens  directly  in  the LpTokenStaker.  Only  when  the  tokens  are  withdrawn  again,  the  flag  is  set.  This  can  be  abused  to circumvent the minimum tainted transfer amount in the following way:  CS-CCP-020  Conic - Conic Protocol -   30  DesignLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                \f1. Call BaseConicPool.deposit() with at least the minimum tainted transfer amount to a Conic  Pool and set the stake argument to true.  2. Call lpTokenStaker.unstakeFor() with an amount of 1 wei and the address you want to DoS.  3. In the next block, withdraw the rest if the deposited amount.    transferred  amount   function  called  by The  lpTokenStaker.unstakeFor()  to  taint  a  transfer)  and  the  function  checks  for  the  minimum  taint amount.  to  LpToken.taint()   is  now  passed   the   (   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.23   Rebalancing Reward After Depeg", "body": "  CS-CCP-023  BaseConicPool.handleDepeggedCurvePool() automatically enables rebalancing rewards. This is, however,  not  necessary  the _MAX_USD_VALUE_FOR_REMOVING_POOL threshold.  is  already  below   the  allocation  of   the  given  pool   if     handleDepeggedCurvePool()  now  checks  if  the  value  of  a  Curve  pool  is  below  the  threshold  and does not start rebalancing rewards in that case.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.24   Unreachable Imbalance Buffers", "body": "  CS-CCP-025  CurvePoolUtils.ensurePoolBalanced()  compares  prices  of  token  pairs  on  Curve  with  their respective  Chainlink  prices  using  an  imbalance  buffer  as  threshold.  The  imbalance  buffers  are  set  for individual tokens. A pair of two tokens will only ever be compared to the imbalance buffer of input token. Depending  on  the  Curve  pool  configuration,  this  can  result  in  the  inability  to  set  a  buffer  for  a  certain token.  For example, in an ETH/rETH Curve pool that contains WETH as the 0-token, it is not possible to use the imbalance buffer of rETH:  for (uint256 i = 0; i < poolMeta.numberOfCoins - 1; i++) {     ...     for (uint256 j = i + 1; j < poolMeta.numberOfCoins; j++) {         ...         toActual = ICurvePoolV2(poolMeta.pool).get_dy(i, j, fromBalance);         ...         require(             _isWithinThreshold(toExpected, toActual, poolFee, poolMeta.imbalanceBuffers[i]),             \"pool is not balanced\"         );     } }  Conic - Conic Protocol -   31  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  The function now uses the minumum of the imbalance buffers of each token pair.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.25   Wrong TVL Factor", "body": "  Conic stated that the TVL_FACTOR in LpTokenStaker is supposed to work in a way that gives the full boost to a user that holds 20% of the total staked amount using the following calculation:  CS-CCP-027  uint256 stakeBoost = ScaledMath.ONE +     userStakedUSD.divDown(totalStakedUSD).mulDown(TVL_FACTOR);  With  the  given  TVL_FACTOR  of  50,  the  full  boost  of  10  is  already  achieved  with  a  share  of  18%.  The correct TVL_FACTOR for 20% would be 45.    The TVL_FACTOR has been changed to 45.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.26   Wrong Time to Full Boost", "body": "  LpTokenStaker.getTimeToFullBoost()  returns  the  time  for  a  given  user  until  their  full  boost  is active:  CS-CCP-028  function getTimeToFullBoost(address user) external view returns (uint256) {     uint256 fullBoostAt_ = boosts[user].lastUpdated + INCREASE_PERIOD;     if (fullBoostAt_ <= block.timestamp) return 0;     return fullBoostAt_ - block.timestamp; }  This calculation is not correct. For example, the function returns the full INCREASE_PERIOD for a user that just reached their full boost amount in the current block, while it should return 0. lastUpdated is the point in time when a user's boost has been updated the last time. The function is therefore only correct for users that have just created a new position.    The function getTimeToFullBoost() has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.27   Ambiguous Naming", "body": "  Conic - Conic Protocol -   32  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                      \fThe following code parts contain symbols that are not precise and could be misunderstood:   ChainlinkOracle._getPrice() defines a boolean argument shouldRevert. Contrary to the  name of the argument, the function can still revert when it is set to true.   InflationManager.hasPoolRebalancingRewardHandlers()  allows  handler address while the function name contains the word \"handlers\" in plural.  to  check  a  single   LpTokenStaker.unstakeFor() allows a user to unstake their own tokens to a specific address.  It does not, as opposed to the naming, allow a user to unstake for another address.  CS-CCP-029    All aforementioned function names have been changed except for the function unstakeFor() because it is a public interface that has already been in use before.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.28   Exchange Rate Race Condition", "body": "  BaseConicPool.deposit() allows to instantly stake the freshly minted LP tokens with the following flow:  CS-CCP-032  1. Mint tokens.  2. Stake tokens on the LpTokenStaker.  3. Update the _cachedTotalUnderlying.  LpTokenStaker.stakeFor()  calls  BaseConicPool.usdExchangeRate()  implemented in the following way:  in  step  2.   It   is  function usdExchangeRate() external view virtual override returns (uint256) {     uint256 underlyingPrice = controller.priceOracle().getUSDPrice(address(underlying));     return _exchangeRate(cachedTotalUnderlying()).mulDown(underlyingPrice); }  function _exchangeRate(uint256 totalUnderlying_) internal view returns (uint256) {     uint256 lpSupply = lpToken.totalSupply();     if (lpSupply == 0 || totalUnderlying_ == 0) return ScaledMath.ONE;      return totalUnderlying_.divDown(lpSupply); }  As can be seen, the exchange rate is calculated by dividing the cached total underlying (which is not yet updated  in  the  call)  by  the  total  supply  of  the  LP  token  (which  has  already  been  increased  due  to  the minting in step 1). The exchange rate is therefore erroneously deflated.  However, this exchange rate is used in a way that completely factors it out in this call which makes this call safe after all.    _cachedTotalUnderlying  LpTokenStaker.stakeFor().  is  now  updated  before   the  calls   to  LpToken.mint()  and  Conic - Conic Protocol -   33  InformationalVersion1CodeCorrected      \f6.29   Fees Without Locked CNC  CS-CCP-033  RewardManager.setFeePercentage()  the CNCLockerV3.totalBoosted() > 0. Once the fee is set, fees are however still accrued even if the amount of locked CNC goes down back to 0.  allows   only   fee   set   to   a   if   Specifiaction changed:  setFeePercentage() now no longer requires CNCLockerV3.totalBoosted() > 0.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.30   Interface Differences", "body": "  The following parts of the code have non-uniform interfaces:   BaseConicPool.depositFor() allows the minted LP tokens to be instantly staked by setting a boolean  parameter.  withdraw()  does  not  expose  such  a  boolean  parameter  for  unstaking  LP tokens.  Instead,  a  separate  function  unstakeAndWithdraw()  must  be  used.  This  interface  is non-uniform.   RewardManager contains a function accountCheckpoint() while Bonding contains a function  checkpointAccount().  CS-CCP-035    Bonding.checkpointAccount()  has  been  renamed  to  Bonding.accountCheckpoint().  The withdraw function names are kept as-is for backwards compatibility.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.31   Missing Events", "body": "  The following state-changing functions are not emitting events (the list is non-exhaustive):  CS-CCP-036   RewardManager.poolCheckpoint().   All functions in SimpleAccessControl.   ChainlinkOracle.setHeartbeat().    Events have been added to most functions where it makes sense.  Conic - Conic Protocol -   34  InformationalVersion1Speci\ufb01cationChangedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                    \f6.32   Rebalancing Reward Formula Mismatch  The  CNCMintingRebalancingRewardsHandler.computeRebalancingRewards()  following formula:  comments   doc   CS-CCP-037  describe   of the  CNC = t * CNC/s * (1 - (Ddeviation / initialDeviation))  This is different to the actual implementation:  (elapsedSinceUpdate * cncRebalancingRewardPerDollarPerSecond).mulDown(     deviationDelta.convertScale(decimals, 18) );  The formula in the comments is also likely wrong as it would imply lower rewards the higher the deviation delta is.  Specification changed:  The formula has been updated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.33   Shadowed Variables", "body": "  The  LpToken  constructor's  arguments  name  and  symbol  shadow  the  storage  variables  of  the  ERC20 contract.  CS-CCP-038    The variable names have been changed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.34   Typographical Errors", "body": "  CS-CCP-039  Typographical errors have been identified in the following parts of the code:  1. BaseConicPool.depositFor()  and  shutdownPool()  define  an  error  message  that  contain  the word \"shutdown\" as a verb.  2. Doc comments of BaseConicPool.handleInvalidConvexPid() contain the word \"shutdown\"  as a verb.  3. Doc comments of BaseConicPool.handleInvalidConvexPid() contain the word \"outcomu\".  4. Doc comments of BaseConicPool.handleInvalidConvexPid() contain the word \"unilkely\".  5. Doc comments of ETH_FACTORY_POOL_CODE_HASH_1 in CurveHandler contain the phrase \"a  optimization\".  Conic - Conic Protocol -   35  InformationalVersion1Speci\ufb01cationChangedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                \f6. Error   pool  BaseConicPool.handleInvalidConvexPid() is inconsistent with the check performed.  shutdown\"   \"convex   string   pid   is   in    All errors have been fixed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.35   removeDuplicates Not Working With 0", "body": " Elements  ArrayExtensions.removeDuplicates() does not work correctly if the array passed as arguments contains the 0-address. It will be filtered out.  CS-CCP-043    The function now correctly checks for 0 elements.  Conic - Conic Protocol -   36  InformationalVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Code Copies", "body": "  The  project  contains  multiple  functions  that  share  a  similar  or  even  identical  codebase.  The  common functionality should be refactored into separate functions to minimize the risks of future changes resulting in different functions behaving differently when they should behave the same way.  CS-CCP-030  Examples are:   BaseConicPool._withdrawFromCurve() and _depositToCurve().   LpTokenStaker.poolCheckpoint() and claimableCnc().   Multiple functions in CNCLockerV3.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Events Emitted on No Change", "body": "  Some functions emit events even when no change in storage has occurred. Here are some examples:  CS-CCP-031  1. BaseConicPool.updateDepegThreshold().  2. Controller.setCurveHandler().  3. RewardManager.addExtraReward().  4. RewardManager.removeExtraReward().    Most of the functions have been corrected to only emit events when the state changes.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Gas Optimizations", "body": "  Some code parts can be optimized for better gas efficiency.  1. Redundant calls. For example:  CS-CCP-034   BaseConicPool.depositFor()  calls  the  price  oracle  for  the  underlying  price.  The  same  call is then performed in _exchangeRate() and potentially _isBalanced().  CurveHandler._version_0_remove_liquidity_one_coin(),   In  CurveRegistryCache.coins() is executed in each loop iteration.  the   call  Conic - Conic Protocol -   37  InformationalVersion1InformationalVersion1CodePartiallyCorrectedInformationalVersion1             \f RewardManager.poolCheckpoint()  could  send  fees  directly  from  a  Conic  pool  to  the  CNCLockerV3.   CurveAdapter._stakedCurveLpBalance()   calls IConvexHandler(controller.convexHandler()).getRewardPool()  which  in  turn calls CurveRegistryCache.getRewardPool(). This function could be called directly.   The  call  to  CurveRegistryCache.nCoins()  in  CurveLpOracle.getUSDPrice()  can  be omitted as the number of coins is already available.   GenericOracle.getUSDPrice()   calls   which  ChainlinkOracle.getUSDPrice().  calls   ChainlinkOracle.getUsdPrice().   ChainlinkOracle.isTokenSupported() call  proceeds   then   to   It   2. Redundant storage reads. For example:   BaseConicPool._getDepositPool()  loads  all  pools  and  weights  in  each  iteration  of  _depositToCurve().   BaseConicPool._depositToCurve() loads the pool address from storage when it could  have just been passed back by _getDepositPool().   CNCLockerV3._feeCheckpoint()   loads   accruedFeesIntegralCrv   and  accruedFeesIntegralCvx multiple times from storage.   LpTokenStaker._claimCNCRewardsForPool() loads poolShares from storage instead  of using the return value of checkpoint().  3. Redundant storage writes. For example:   GovernanceProxy._endChange()  writes  data  to  the  pending  change  in  storage  before  deleting it from storage.  4. Unnecessary computation. For example:   The  loop  in  BaseConicPool._getDepositPool()  does  not  continue  if  the  weight  of  a  given pool is 0.   The  computation  of  _isEthIndexFirst()  in  CurveHandler.isReentrantCall()  is  irrelevant.   RewardManager.poolCheckpoint()  does  not  set  the  rewardsClaimed  flag  when rewards  are  claimed  due  to  being  within  the  threshold  of  the  Convex  cliff.  This  results  in claimPoolEarningsAndSellRewardTokens()  potentially  executing  the  claiming functionality two times.   RewardManager.poolCheckpoint() does not return early if no rewards have accrued.  5. Unoptimized structs in storage. For example:   The size of the endedAt field in the Change struct of IGovernanceProxy could be reduced  to fit the Status enum into the same word.   The Boost struct in LpTokenStaker could be optimized to only occupy 1 word.  6. _chainlinkOracle and _curveLpOracle in GenericOracle can be immutable.  Conic - Conic Protocol -   38  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Extra Rewards Might Have 100% Slippage", "body": "  RewardManager swaps all extra rewards of a Convex pool to CNC on either SushiSwap or Curve. If the respective token is not supported by the GenericOracle, no slippage protection is set for these swaps. It is likely that these swaps will be arbitraged by bots.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Locking in CNCLockerV3 Can Potentially Fail", "body": " if Too Many Locks Exist  No more than _MAX_LOCKS can exist in CNCLockerV3 for every user. If a user has created more, or if an attacker targets a user, they could be prevented from creating new locks according to their intentions. New locks can always be created by using the relock option of lockFor(), however that requires the duration to be longer than any of the existing locks.  If it is not possible to create new locks for an address, an alternative address will have to be used. If an airdrop  cannot  be  used  because  of  having  reached  _MAX_LOCKS,  the  airdrop  can  still  be  used  on another address through lockFor().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   RewardManager Can Become Temporarily", "body": " Insolvent  RewardManager  handles  CVX  rewards  by  calculating  the  current  amount  of  earnings  for  the  current Convex cliff period. If the end of the cliff period approaches, earnings are finally claimed. It is, however, possible that there are no interactions with the contract for a longer period which would result in this claim being missed before the period ends. In that case, the amount of CVX rewards in the contract are inflated as the actual claimable reward is lower than the reward that has been calculated before. It is therefore possible  that  not  all  claims  can  be  served  until  the  new  incoming  CVX  reward  reach  the  previously calculated amount of CVX rewards that should be in the contract.  Users that stake after this incident also do not accrue CVX rewards in favor of older stakers.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Rewards of Rebalance Function", "body": "  CNCMintingRebalancingRewardsHandler.rebalance() allows users to easily rebalance a Conic pool and earn rewards. This includes rewards for withdraw() which are not granted if the function is called directly.  Conic - Conic Protocol -   39  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fThe  setup  allows  for  additional  reward  handlers  to  be  added  to  a  Conic  Pool.  These  reward  handlers, however, will only grant rewards for deposits even when the rebalance() function is used.  Conic - Conic Protocol -   40  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Ineffective Try Catch Statement", "body": "  Try  catch  statements  should  handle  critical  code  parts  that  might  fail  and  their  respective  exertions correctly.  The  used  try  catch  statement  in  authorizationDecrease  simple  fails  silently  if  not successful. Resulting in potential incorrect authorization decrease.  Risk accepted :  Network   Threshold  event AuthorizationInvoluntaryDecreased has been added to track involuntary decreases, it contains a field to indicate whether the call to the application succeeded or not.  decrease   accepts   silently.   fails   The   that   a   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Missing Sanity Checks", "body": "  For  security  reasons  stakers  use  different  roles  to  manage  the  stake.  If  different  roles  exist,  it  seems consistent  to  enforce  the  use  of  different  keys.  stake  and  stakeNu  do  not  check  if  the  addresses (operator,  beneficiary,  owner,  authorizer)  are  the  same.  In  a  more  limited  way  this  is  also  the  case  for stakeKeep.  Acknowledged :  Threshold  Network  does  not  consider  that  roles  having  different  addresses  must  be  enforced.  In  their modelling, they always assumed that some stakers will reuse addresses for different roles.  Threshold Network - Threshold Network -   9  DesignCriticalHighMediumRiskAcceptedLowAcknowledgedRiskAcceptedDesignMediumVersion1RiskAcceptedDesignLowVersion1Acknowledged                    \f5.3   Possibly Uninitialized Penalties  function   initializes   The  constructor  the  staking  contract.  However, important  variables  takeDiscrepancyPenalty  and  stakeDiscrepancyRewardMultiplier  are  not  initialized  and need  to  be  set  separately  in  setStakeDiscrepancyPenalty.  The  onlyGovernance  modifier ensures  that  only  the  community  controlled  governance  contract  can  call  this  function.  Calls  from community  driven  governance  contracts  usually  have  a  long  reaction  time  due  to  voting  and  other collective decisions that need to be taken before. Hence, the variables might be uninitialized and result in no penalties for misbehaving.  for   Risk accepted :  These parameters need to be set by governance, Threshold Network believes that in the interim, zero penalty is an acceptable behavior.  Threshold Network - Threshold Network -   10  DesignLowVersion1RiskAccepted        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Unauthorized Top Ups   -Severity Findings   Compiler Version Not Fixed and Outdated   Inefficient Struct Packing   Inefficient processSlashing Loop   Interface File Name Convention    Misleading Variable count    Specifications Mismatch   0  0  1  6  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Unauthorized Top Ups", "body": "  With the current design, anybody can call topUp on any operator (in Kepp, Nu and T). This could lead to KEEP  or  NU  staked  in  legacy  contract,  that  the  owner  may  not  want  to  be  staked  on  the  new  staking contract, ending staked on the new contract.  On Nu this might lead to trolling by calling topUpNu after a user send an unstakeNu transaction and blocking the Nu withdraw through:  1. X calls unstakeNu  2. Y calls topUpNu on X  3. X tries to withdraw from NU legacy staking contract, but it fails because there is still an amount  of NU accounted in the new staking contract  With Keep the issue is more severe as non-malicious behavior could be slashed with a sandwich attack like follows:  1. Someone wants to unstake keep and calls \"unstakeKeep\"  2. The user sends the tx for the Keep legacy contract to \"undelegate\"  3. This tx lands in the men pool and someone front runs it by calling \"topUpKeep\"  4. The undelegate is mined after the top up  5. The attacker calls the notify keep discrepancy function to slash  Threshold Network - Threshold Network -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedDesignMediumVersion1CodeCorrected           \fCode corrected :  A modifier has been added to all three top up functions to restrict the access only to owner and operator.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Compiler Version Not Fixed and Outdated", "body": "  The  solidity  compiler  is  not  fixed  in  the  Checkpoints.sol.  The  version,  however,  is  defined  in  the hardhat.config.js to be 0.8.4.  In the code the following pragma directives are used:  pragma solidity ^0.8.0;  Known bugs in version 0.8.4 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1562  More information about these bugs can be found here:  https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.9 which contains some bugfixes.  Code corrected :  Compiler version is now 0.8.9 and fixed all files.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Inefficient Struct Packing", "body": "  The variable order inside structs is not optimized by the compiler. Hence, tight variable packing needs to be done manually. The struct OperatorInfo could be packed differently, to save two storage slots.  Code corrected :  Struct has been optimized.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Inefficient processSlashing Loop", "body": "  State operations are expensive. Additionally, Threshold Network told that the processSlashing is gas critical.  The  function  processSlashing  reads  and  writes  the  state  variable  slashingQueueIndex multiple times. The loop even does operations in each iteration.  Additionally,  a  sanity  check  for  count  parameter  in  processSlashing  instead  of  a  check  at  every iteration of the for loop could save gas.  Code corrected :  Threshold Network - Threshold Network -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fslashingQueueIndex is now updated only once after the for loop with an internal counter in memory.  The  stopping  condition  of  the  for  loop  has  been  optimized,  maxIndex  is  now  capped  at  max  queue's length and an event is emitted with the effective number of slashes.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Interface File Name Convention", "body": "  The file StakingProviders.sol is an interface definition. To be consistent with the naming, the file should be renamed with a leading I.  Code corrected :  Filename updated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Misleading Variable count", "body": "  One of the stop conditions of the for loop in processSlashing allows the function to process one more intended.  slashingQueueIndex  <=  maxIndex  should  be pending  slash  slashingQueueIndex  <  maxIndex  if  it  should  match  the  passed  in  count  argument.  One  more unintended iteration also would cost the processor more gas than they may have wanted to spend in the first place.  initially   than   Code corrected :  Loop's stopping condition has been updated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Specifications Mismatch", "body": "  Specs  of  processSlashing  say  that  processor  can  get  either  4%  or  5%  of  the  slashed  amount, depending on the type of call the application did, but in practice processor always gets 5%, no matter the application called seize or slash.   getStartTStakingTimestamp specs say that result is zero when operator has no stake or  when they was topped-up, but top up functions do not update the staking timestamp  Specification partially changed :  For both mentioned issues the specifications were updated accordingly.  Threshold Network - Threshold Network -   13  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedVersion3                        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Applications Share the Same Stake", "body": "  Threshold Network informed that the same stake can be used in different applications. Sharing the same stake  practically  means  that  if  one  application  slashes  or  seizes  all  stake,  all  other  applications  that shared the stake will have no stake left to seize or slash.  Threshold Network - Threshold Network -   14  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Inconsistent Decimals of LP Token", "body": "  The  function  ERC20RootVault.deposit  performs  the  following  checks  when  new  LP  tokens  are minted to a user:  require(lpAmount + balanceOf[msg.sender] <= params.tokenLimitPerAddress, ExceptionsLibrary.LIMIT_OVERFLOW); require(lpAmount + totalSupply <= params.tokenLimit, ExceptionsLibrary.LIMIT_OVERFLOW);  The LP tokens distributed by root vaults do not have pre-defined number of decimals but depend on the token amounts of the first deposit, hence making difficult to set the params tokenLimitPerAddress and tokenLimit in advance.  Acknowledged:  Mellow Finance - Mellow Vaults -   13  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedCorrectnessLowVersion5Acknowledged            \fMellow Finance acknowledges the issue and will take care to set the proper limits after initial LP shares are minted and the respective decimals are known:  We don\u2019t intend to stand limits in advance of the launch of the system, we rather want to stand them as MaxUint256 initially and then have a possibility to set meaningful values based on the supply of lp tokens during the work of the system.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Performance Fee in Specific Setups", "body": "  The  performance  fee  is  charged  in  ERC20RootVault  only  if  the  price  of  LP  tokens  has  increased  in value, which is calculated in the statement:  uint256 lpPriceD18 = FullMath.mulDiv(tvlToken0, CommonLibrary.D18, baseSupply);  However, in specific setups where the token0 is of high value but has low decimals, while the token1 is of low value but with many decimals, the variable baseSupply would inherit the decimals of token1. Therefore, in such setups it is possible that the statement above returns lpPriceD18 equal to zero.  Acknowledged:  Mellow  Finance  has  decided  to  keep  the  code  unchanged  as  they  only  will  use  only  verified  token combinations that this issue does not occur. The response:  We decided that this situation would not be possible when calculating the performance fee, since we agreed to use only verified tokens, for which the difference between decimals would be less than 18.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Possible Optimization in AggregateVault", "body": "  The function AggregateVault._push performs the following actions:  1. Approves allowance with safeIncreaseAllowance for each token to destVault.  2. Calls destVault.transferAndPush, which transfers tokenAmounts to the ERC20Vault.  3. Resets approval to destVault for all tokens to 0.  Given that the _push function moves tokens to the ERC20Vault and allowance in the end should be 0, the  function  can  be  revised  to  be  more  efficient.  For  instance,  safeIncreaseAllowance  performs additional  operations  and  is  useful  when  the  existing  allowance  is  not  zero  and  should  be  considered. Also,  the  function  consumes  in  step  2  the  allowance  given  earlier,  hence  the  last  for-loop  might  be omitted.  Code partially correct:  The  function  AggregateVault._push  is  made  more  efficient  by  performing  the  external  calls safeIncreaseAllowance  and  safeApprove  only  for  tokens  that  non-zero  amounts  are  being  Mellow Finance - Mellow Vaults -   14  DesignLowVersion5AcknowledgedDesignLowVersion5CodePartiallyCorrected                \ftransferred (tokenAmounts[i] > 0). However, for the other tokens two external calls are performed for updating the allowance.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Possible Optimization on Deposits and", "body": " Withdrawals  The function ERC20RootVault.deposit can be optimized to be more gas efficient by transferring the tokens directly from the user to the ERC20Vault. Currently, the tokens are first transferred from the user to the root vault:  for (uint256 i = 0; i < tokens.length; ++i) {     ...     IERC20(tokens[i]).safeTransferFrom(msg.sender, address(this), normalizedAmounts[i]); }  and then, in AggregateVault._push tokens are transferred again:  for (uint256 i = 0; i < _vaultTokens.length; i++) {     IERC20(_vaultTokens[i]).safeIncreaseAllowance(address(destVault), tokenAmounts[i]); }  Similarly,  the  function  ERC20RootVault.withdraw  can  be  made  more  efficient  if  the  tokens  are transferred directly from the sub-vaults to the user instead of transferring to the root vault first and then to the user.  Acknowledged:  Client acknowledges the optimization possibility but prefers to keep the code unchanged:  The main idea behind this behavior is for the root vault to be responsible for pushing tokens onto different vaults. We consider the current design to be clearer with pushing with the ```AggregateVault._push``` method.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   Redundant Calculation of LP Amounts", "body": "  The  function  ERC20RootVault.deposit  calculates  the  LP  amount  that  is  rewarded  to  the  user  two times:  {     ...     (preLpAmount, isSignificantTvl) = _getLpAmount(maxTvl, tokenAmounts, supply);     for (uint256 i = 0; i < tokens.length; ++i) {         normalizedAmounts[i] = _getNormalizedAmount(...);         ...     } } actualTokenAmounts = _push(normalizedAmounts, vaultOptions); (uint256 lpAmount, ) = _getLpAmount(maxTvl, actualTokenAmounts, supply);  Mellow Finance - Mellow Vaults -   15  DesignLowVersion5AcknowledgedDesignLowVersion5Acknowledged                \fInitially,  preLpAmount  is  calculated  based  on  the  tokenAmounts,  then  normalizedAmounts  are returned computed.  Considering  actualTokenAmounts  is redundant.  to  normalizedAmounts.  Hence,  recomputing  lpAmount   that  _push  moves   the  ERC20Vault,   is  equal   tokens   the   to   Acknowledged:  Client acknowledges the redundant calculation of LP amount but prefers to keep the code unchanged as in the future the behavior of ERC20Vault might change, i.e., the returned actualTokenAmounts might not be equal to normalizedAmounts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.6   Broad Access Control for Functions", "body": "  functions  addDepositorsToAllowlist  and  removeDepositorsFromAllowlist   in The  ERC20RootVault  restrict  the  access  control  with  function  _requireAtLeastStrategy.  However, neither MStrategy nor LStrategy call these functions. Similarly, multiple functions in VaultGovernance use the same access control, although they are not called by the strategies.  Acknowledged:  Mellow  Finance  is  aware  that  these  functions  are  not  called  by  smart  contracts  implementing  the strategies, but they can be called by an EOA in case it manages the vault system. Client replied:  The vault system can be managed not by strategy, but by some account. In such a case this account should have the possibility to edit `depositorsAllowList`. These 2 functions exist for this reason.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.7   Redundant Check for baseSupply", "body": "  The  function  ERC20RootVault._chargePerformanceFees  performs  a  check  of  baseSupply  is equal to 0, and returns if this is the case:  if ((performanceFee == 0) || (baseSupply == 0)) {     return; }  However, this check is redundant because _chargeFees performs the same check and returns before calling _chargePerformanceFees.  Acknowledged:  Client acknowledged the redundant check but has decided to keep it as it enhances the readability of the code.  Mellow Finance - Mellow Vaults -   16  DesignLowVersion4AcknowledgedDesignLowVersion4Acknowledged                  \f5.8   Redundant Check for deltaSupply  The function _getBaseParamsForFees performs the following check on withdrawals:  baseSupply = 0; if (supply > deltaSupply) {     baseSupply = supply - deltaSupply; }  The deltaSupply corresponds to the LP shares that a user is burning, which is less than or equal to the balance of that user. Hence, it is always less or equal to the totalSupply.  Acknowledged:  Client acknowledged the redundant check but has decided to keep it as it enhances the readability of the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.9   Redundant Checks on Push Function", "body": "  The  function  IntegrationVault.push  performs  the  following  checks  that  are  always  true  when  a vault is linked to a root vault:  uint256 nft_ = _nft; require(nft_ != 0, ExceptionsLibrary.INIT); IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry; IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_)); // Also checks that the token exists uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault)); require(ownerNft != 0, ExceptionsLibrary.NOT_FOUND);  Acknowledged:  Mellow  Finance  has  decided  to  keep  the  checks  to  prevent  from  pushing  and  pulling  on  uninitialized vaults.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.10   State Updates After Reentrancy Possibility", "body": "  When creating a vault, _mint is called to mint the NFT. This calls the receiver and gives an opportunity to reenter the system.  _safeMint(owner, nft); _vaultIndex[nft] = vault; _nftIndex[vault] = nft; _vaults.push(vault); _topNft += 1; emit VaultRegistered(tx.origin, msg.sender, nft, vault, owner);  Mellow Finance - Mellow Vaults -   17  DesignLowVersion4AcknowledgedDesignLowVersion4AcknowledgedDesignLowVersion4CodePartiallyCorrected                      \fState  updates  and  events  are  emitted  after  the  possible  reentrancy  in  this  function  and  the  calling functions. Coding guidelines suggest following the check-effects-interaction pattern to mitigate reentrancy vulnerabilities.  Code partially corrected:  The  minting  statement  _safeMint  has  been  moved  to  the  end  of  the  function  registerVault. However, state is still updated afterwards in functions createVault of vault governance contracts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.11   Missing Slippage Protection in _mintNewNft", "body": "  The function _mintNewNft in LStrategy sets the parameters amount0Min and amount1Min of the MintParams to zero, hence disabling any slippage protection. However, the risk exposure in this case is limited as a new position in Uniswap should be open with small amounts minTokenXForOpening. The exact amount depends on admin who sets the otherParams.  Acknowledged:   to check if the variables minTokenXForOpening are smaller Sanity checks were introduced in  than 10**9. This adds another layer of protection to ensure that the number of tokens is relatively low. Still, the number of tokens does not guarantee that the value is small.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.12   UniV3Vault Pulls More Tokens Than", "body": " Requested  UniV3Vault._pullUniV3Nft first calculates the amount of tokens to pull, then decreases the liquidity inside  the  Uniswap  position  and  then  collects  the  tokens.  When  the  earnings  have  not  been  collected before, the last step additionally collects the earnings, returning more tokens than intended.  The function should take the tokens owed into consideration when calculating the amount to pull.  Acknowledged  Mellow  Finance  acknowledged  the  issue  and  replied  that  the  strategy  maintainer  can  call  the collectEarnings function to collect all the fees.  Mellow Finance - Mellow Vaults -   18  SecurityLowVersion1AcknowledgedVersion3CorrectnessLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  5  14  17  -Severity Findings   Mismatch of Specification With Uniswap V3 Oracle    Chainlink Oracle Returns Empty Prices   Incorrect LP Token Calculation in ERC20RootVault    Missing Access Control in UniV3Oracle    UniV3Oracle Returns Reverse Prices for Token Pairs   -Severity Findings  Incorrect TVL Conversion    Adding up Total Value Locked on Different Tokens    Calling _liquidityDelta Incorrectly    Calling _liquidityDelta With Incorrect Inputs   Incorrect Observation Index in _getAverageTick   Incorrect Parameters on externalCall   Insufficient Testing    Opposite Vaults Are Swapped    Possibility to Exit Positions of Any Address    Possible DOS From First Depositor    Setting Wrong State Variable    Wrong Formula in _rebalanceUniV3Liquidity    Wrong TVL Calculation in ERC20RootVault   liquidity Gets Overwritten in the Loop   -Severity Findings   Wrong State Variable Updated   Inconsistent Access Control for Rebalance in LStrategy   Inconsistent Sanity Check on First Deposit's Amounts    Safety Level of Returned Prices Can Silently Downgrade    Unfair Distribution of LP Shares in ERC20RootVault    Conflicting Specifications for MStrategy   Implementation Differs From Specification on _targetTokenRatioD   Incorrect Access of Addresses in EnumerableSet    Missing Checks for Dust Amounts When Rebalancing Pools    Missing Delay Restriction in BaseValidator   Mellow Finance - Mellow Vaults -   19  CriticalCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedHighCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected          \f Missing Sanity Checks in signOrder    No Slippage Protection in Multiple Contracts    Possible Underflow in UniV3Oracle.price    Rebalance in LStrategy Can Leave Tokens in the Vault to Be Closed    Subvault Tokens Are Not Checked in AggregateVault    Transferring Tokens Only to lowerVault    Use of Libraries   -Severity Findings   Missing Sanity Checks for intervalWidthInTicks    Possible Attack by First Depositor    Possible Optimization on _chargePerformanceFees    Possible Violation of the Minimum Token Amounts After the First Deposit    Misleading Function Name and Natspec    Mismatch of Specifications for StrategyParams    Missing Sanity Check for maxSlippageD in MStrategy   41   Missing Sanity Checks for oracleSafetyMask    Possible Struct Optimization in Strategies    Redundant Comparisons    Redundant Storage Read in ERC20Vault._pull    Variables Can Be Declared as Constant   Incorrect Specification for reclaimTokens    Missing Natspec Description for minDeviation    Casting of maxTickDeviation    Check Requirements First    Duplicate Code _permissionIdsToMask    Duplicate Storage Read in Deposit   Inconsistent Specifications   Inefficient Array Shrinking   Inefficient State Variable Packing    Misleading Naming of Variables in UniV3Oracle    Missing Sanity Check in MStrategy.createStrategy    Missing Sanity Checks for Params    Misspelled Variable Names    Possible Struct Optimization    Rebalance in MStrategy Is Inconsistent    Specification for minDeviation Not Enforced    Storing Redundant Data in Storage    Unnecessary Approval to Vault Registry   Mellow Finance - Mellow Vaults -   20  CodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected    \f Unused Constant in ERC20Validator    Unused Event DeployedVault    Unused Function LStrategy._priceX96FromTick    Unused Imports    Wrong Check of Minimum Token Amounts in ERC20RootVault.withdraw    Wrong Specification for YearnVault.tvl    ContractRegistry DOS    ERC20Vault._pull Forces Push of Wrong Amount of Tokens   IntegrationVault._root Does Not Check the NFT of the Root Vault    VaultGovernance.commitInternalParams Does Not Delete Staged Parameters    registry.ownerOf Is Called Twice in IntegrationVault.pull   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Mismatch of Specification With Uniswap V3", "body": " Oracle  The specifications of the function price for oracles are in the interface IOracle as following:  /// @dev The price is token1 / token0 i.e. how many weis of token1 /// required for 1 wei of token0.  function price(     address token0,     address token1,     uint256 safetyIndicesSet ) external view returns (uint256[] memory, uint256[] memory);  According  to  the  specification,  priceA_B  =  price(tokenA,  tokenB)  should  be  the  inverse  of priceB_A  =  price(tokenB,  tokenA),  meaning  relation  should  hold: priceA_B = 1 / priceB_A.  following   the   The  function  UniV3Oracle.price  in    returns  the  same  price  for  a  pair  of  tokens  without differentiating in which denomination token the price should be. Namely, the function returns the same prices  when  calling  price(tokenA,  tokenB)  or  price(tokenB,  tokenA).  This  behavior  is enforced in the first if statement of the function:  if (token0 > token1) {     (token0, token1) = (token1, token0); }    The  Uniswap  V3  Oracle  has  been  revised,  the  Uniswap's  OracleLibrary  is  now  used  and  a  flag isSwapped is added to track the correct denomination of the returned price.  Mellow Finance - Mellow Vaults -   21  CodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessCriticalVersion2CodeCorrectedVersion2           \f6.2   Chainlink Oracle Returns Empty Prices  ChainlinkOracle maintains the mapping oraclesIndex which stores addresses of chainlink oracles for each token. The mapping is populated by the admin through the function _addChainlinkOracles:  function _addChainlinkOracles(address[] memory tokens, address[] memory oracles) internal {     ...     oraclesIndex[token] = oracle;     ... }  The  function  price(token0,token1,safetyIndicesSet)  checks  if  the  mapping  oraclesIndex has the addresses for the respective Chainlink oracles:  if ((address(chainlinkOracle0) != address(0)) || (address(chainlinkOracle1) != address(0))) {         return (pricesX96, safetyIndices); // returns empty values }  The condition above is incorrect as it returns empty values if the Chainlink oracles exist in the mapping. This  makes  the  Chainlink  oracle  -  assumed  to  be  the  safest  by  the  specifications  and  the  code  - unusable.    The above check in function price has been revised to return empty prices only if there is no entry for at least one of the tokens in mapping oraclesIndex:   if ((address(chainlinkOracle0) == address(0)) || (address(chainlinkOracle1) == address(0))) {     return (pricesX96, safetyIndices); }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Incorrect LP Token Calculation in ", "body": " ERC20RootVault  ERC20RootVault._getLpAmount  incorrectly  calculates  the  minimum  of  given  token  amounts.  An attacker can issue more LP tokens than he is entitled to and can then exchange them back for additional tokens.  The following code incorrectly resets the MIN calculation for as many iterations as tokenLpAmount is equal to 0:  for (uint256 i = 0; i < tvlsLength; ++i) {    if ((amounts[i] == 0) || (tvl_[i] == 0)) {       continue;    }     uint256 tokenLpAmount = FullMath.mulDiv(amounts[i], supply, tvl_[i]);    if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {       lpAmount = tokenLpAmount;  Mellow Finance - Mellow Vaults -   22  CorrectnessCriticalVersion1CodeCorrectedCorrectnessCriticalVersion1CodeCorrected              \f   } }  If tokenLpAmount == 0 in the first iteration, lpAmount will be set to 0. If tokenLpAmount > 0 in the next iteration, lpAmount will be set to tokenLpAmount although it is larger than the already set value.  In a later step, ERC20RootVault._getNormalizedAmount normalizes the sent token amounts to the calculated lpAmount. This function however does not increase the normalized amount to a value greater than the sent one. An attacker can therefore exploit this by calling deposit with all token amounts but the last one being set to 0 and then calling withdraw with the LP tokens that have just been minted to obtain his initial investment plus an amount of all other tokens in the Vault equal to the current ratio of tokens.    The  function  _getLpAmount  has  been  refactored  to  set  the  lpAmount  to  the  minimum  of tokenLpAmount calculated on each iteration of the for loop. The flag isLpAmountUpdated is set to true on the first iteration that a non-zero value is assigned to lpAmount.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Missing Access Control in UniV3Oracle", "body": "  The function addUniV3Pools populates the mapping poolsIndex with the address of a Uniswap pool for  a  pair  of  tokens.  The  function  should  be  accessible  only  to  trusted  accounts,  however,  it  does  not implement  any  access  restriction.  As  the  function  is  external  anyone  can  set  arbitrary  addresses  as Uniswap pools, hence freely manipulate the oracle prices.    The updated code resolves the issue by restricting the access to the function addUniV3Pools only to the admin, hence preventing malicious users from setting arbitrary addresses as Uniswap pools:  function addUniV3Pools(IUniswapV3Pool[] memory pools) external {     _requireAdmin();     _addUniV3Pools(pools); }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   UniV3Oracle Returns Reverse Prices for", "body": " Token Pairs  The UniV3Oracle computes the price for two tokens using the Uniswap V3 observations. As the tokens in  Uniswap  are  always  sorted  by  their  address  (Token0  <  Token1),  the  function  price  uses  a  flag revTokens to distinguish if the price from Uniswap corresponds to the order of function parameters, or if it should be reversed. The respective code is:  Mellow Finance - Mellow Vaults -   23  SecurityCriticalVersion1CodeCorrectedCorrectnessCriticalVersion1CodeCorrected                \ffunction price(address token0,address token1,uint256 safetyIndicesSet)     external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices) {    ...     bool revTokens = token1 > token0;      for (uint256 i = 0; i < len; i++) {         if (revTokens) {             pricesX96[i] = FullMath.mulDiv(CommonLibrary.Q96, CommonLibrary.Q96, pricesX96[i]);         }         pricesX96[i] = FullMath.mulDiv(pricesX96[i], pricesX96[i], CommonLibrary.Q96);     } }  The flag revToken is set to true if the tokens in the function parameters are ordered as in Uniswap, hence incorrectly reverses the computed price.    The  contract  UniV3Oracle  has  been  refactored  due  to  the  bug  presented  above  and  other  issues reported for this contract. The code above that mistakenly reversed the prices is not present anymore in  , however, another issue has been introduced on the fix.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Incorrect TVL Conversion", "body": "  The function _getTvlToken0 incorrectly converts the TVL amount of a given token i into token 0. The oracle returns a price in x96 format. This price is directly used as if it would be a correctly formatted price to  convert  the  amounts.  As  the  TVL  in  most  cases  will  be  lower  than  the  price  in  x96  format  the calculation will return 0.  tvl0 = tvls[0]; for (uint256 i = 1; i < tvls.length; i++) {     (uint256[] memory prices, ) = oracle.price(tokens[0], tokens[i], 0x28);     require(prices.length > 0, ExceptionsLibrary.VALUE_ZERO);     uint256 price = 0;     for (uint256 j = 0; j < prices.length; j++) {         price += prices[j];     }     price /= prices.length;     tvl0 += tvls[i] / price;  Additionally,  the  calculation  would  be  more  precise  if  the  price  would  be  multiplied  to  convert  the amounts.    The  issue  about  the  conversion  of  TVLs  in  function  _getTvlToken0  has  been  addressed.  The  last statement of the for-loop has been changed:  tvl0 += FullMath.mulDiv(tvls[i], CommonLibrary.Q96, priceX96);  Mellow Finance - Mellow Vaults -   24  Version2CorrectnessHighVersion3CodeCorrected          \f6.7   Adding up Total Value Locked on Different Tokens  function  postPreOrder  calls   The  tvl[0] + tvl[1] (see the issue reported in Calling _liquidityDelta incorrectly).  the   function  _liquidityDelta  with  tvl[0]  and  Additionally, the calculations are performed on tvl with different underlying tokens. Namely, tvl[0] is in the denomination of token0, while tvl[1] in the denomination of token1.    , the first argument tvl[0] is converted into the domination The issue is resolved in code base  of  token1  before  passed  to  _liquidityDelta,  while  the  second  parameter  tvl[1]  remains  in  the denomination of token1.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Calling _liquidityDelta Incorrectly", "body": "  The function postPreOrder in Lstrategy calls _liquidityDelta as follows:  (uint256 tokenDelta, bool isNegative) = _liquidityDelta(     tvl[0],     tvl[0] + tvl[1],     ratioParams.erc20TokenRatioD,     ratioParams.minErc20TokenRatioDeviationD );  As  already  pointed  out  in  the  issue  Calling  _liquidityDelta  with  incorrect  inputs,  the  function _liquidityDelta also performs the addition, hence computing incorrectly the result.    The parameters passed to the function _liquidityDelta have been corrected, namely the addition of tvl[0] + tvl[1] is removed and only tvl[1] is passed as the second argument of the function call.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Calling _liquidityDelta With Incorrect", "body": " Inputs  The function rebalanceERC20UniV3Vaults in LStrategy calls _liquidityDelta as follows:  (capitalDelta, isNegativeCapitalDelta) = _liquidityDelta(     erc20VaultCapital,     erc20VaultCapital + lowerVaultCapital + upperVaultCapital,     ratioParams.erc20UniV3CapitalRatioD,  Mellow Finance - Mellow Vaults -   25  CorrectnessHighVersion1CodeCorrectedVersion2CorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                      \f    ratioParams.minErc20UniV3CapitalRatioDeviationD );  Note  that,  the  first  parameter  is  included  in  the  sum  used  as  the  second  parameter.  However,  the function  _liquidityDelta  also  performs  the  addition  on  the  code  below,  hence  computing targetLowerLiquidity incorrectly:  uint256 targetLowerLiquidity = FullMath.mulDiv(     targetLiquidityRatioD,     lowerLiquidity + upperLiquidity,     DENOMINATOR );    In rebalanceERC20UniV3Vaults the calculation does not add erc20VaultCapital anymore.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Incorrect Observation Index in ", "body": " _getAverageTick  Function _getAverageTick computes the averageTick and the tickDeviation based on the most recent observation and a previous observation referred as observationIndexLast. The latter index is computed as follows:  uint16 observationIndexLast = observationIndex >= oracleObservationDelta     ? observationIndex - oracleObservationDelta     : observationIndex + (type(uint16).max - oracleObservationDelta + 1);  If oracleObservationDelta is larger than observationIndex (e.g., by 1), the code above returns a  value  that  is  close  (or  equal)  to  type(uint16).max.  It  is  very  likely  that  the  Uniswap  pool  has  a smaller  cardinality  of  observations  than  the  computed  observationIndexLast,  hence  0s  would  be returned for this observation.    formula   The  when oracleObservationDelta  >  observationIndex  has  been  revised,  type(uint16).max  has been replaced with observationCardinality.  observationIndexLast   compute   to   obsIdx = 20 delta = 30 card = 50 --- 20 + 50 -30 = 40  obsIdx = 30 delta = 30 card = 50 --- 0  obsIdx = 30 delta = 31 card = 50 --- 30 + 50 -31 = 49  obsIdx = 30 delta = 49 card = 50 --- 30 + 50 - 49 = 31  generalized: obsIdx + card - delta % card  Mellow Finance - Mellow Vaults -   26  CorrectnessHighVersion1CodeCorrected          \f6.11   Incorrect Parameters on externalCall  The function signOrder in LStrategy performs few externalCall s, and for one of them sets the wrong parameters as input:  bytes memory setPresignatureData = abi.encode(SET_PRESIGNATURE_SELECTOR, uuid, signed); erc20Vault.externalCall(cowswap, SET_PRESIGNATURE_SELECTOR, setPresignatureData);  Note  that  the  function  selector  is  part  of  the  abi.encode  and  then  is  set  as  the  second  parameter  in externalCall, which also appends the selector when executing the call, hence causing the external function to always fail:  (bool res, bytes memory returndata) = to.call{value: msg.value}(abi.encodePacked(selector, data));    The  external  call  in  LStrategy.signOrder  does  not  encode  the  SET_PRESIGNATURE_SELECTOR twice anymore.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Insufficient Testing", "body": "  We found an unusual high number of issues that would have been easily detected with proper tests. The current unit and integration tests are insufficient.    The tests have been extended significantly on the latest iterations of the review process to cover more functions and call paths.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Opposite Vaults Are Swapped", "body": "  The  function  _swapVaults  in  LStrategy  should  close  the  position  with  no  liquidity  and  open  a  new one given the price move in positiveTickGrowth. The decision on which vault to close is done in the following if condition:  /// @param positiveTickGrowth `true` if price tick increased ... if (!positiveTickGrowth) {     (fromVault, toVault) = (lowerVault, upperVault); } else {     (fromVault, toVault) = (upperVault, lowerVault); }  The  function  closes  the  fromVault  and  creates  the  new  vault  according  to  the  current  position  of toVault.  However,  the  code  above  assigns  fromVault  wrongly  to  lowerVault  if  the  tick  is  Mellow Finance - Mellow Vaults -   27  CorrectnessHighVersion1CodeCorrectedSecurityHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                      \fdecreasing,  and  vice-versa  if  the  tick  is  increasing.  Given  this  error  and  the  following  requirement,  the function would fail always (as fromVault has all liquidity):  require(fromLiquidity == 0, ExceptionsLibrary.INVARIANT);    The vaults were switched like:  if (!positiveTickGrowth) {         (fromVault, toVault) = (upperVault, lowerVault);     } else {         (fromVault, toVault) = (lowerVault, upperVault);     }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Possibility to Exit Positions of Any Address", "body": "  In  ERC20RootVault.withdraw,  LP  tokens  are  burned  in  a  call  to  _burn  from  the  address  that  is specified  in  the  to  parameter.  Neither  _burn  nor  any  other  statement  in  withdraw  performs  access control checks to verify if the msg.sender is allowed to burn the tokens of the given address. Thus, any user can burn LP tokens of a given address and transfer the underlying tokens to that address.  Finally, an incorrect event is emitted with msg.sender.    . The function withdraw now burns only The issues have been resolved in the updated code  the LP tokens of the msg.sender, while transfers the underlying tokens to the address to specified by the caller.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   Possible DOS From First Depositor", "body": "  The first user that calls deposit in ERC20RootVault can choose freely any amount (including zero) for each  vault  token,  while  the  LP  shares  are  set  to  the  largest  amount  by  the  following  loop  in _getLpAmount:  for (uint256 i = 0; i < tvl_.length; ++i) {     if (amounts[i] > lpAmount) {         lpAmount = amounts[i];     } }  However, if the first user (on initialization or whenever totalSupply is zero) chooses to deposit only one token (e.g., token[0]) it makes impossible for other users to deposit other tokens (e.g., token[1]) as the totalSupply is not zero anymore, and _getNormalizedAmount considers the existing TVL:  Mellow Finance - Mellow Vaults -   28  SecurityHighVersion1CodeCorrectedVersion2SecurityHighVersion1CodeCorrected                \f// normalize amount uint256 res = FullMath.mulDiv(tvl_, lpAmount, supply); // if tvl_ == 0, res = 0  The intended use of the function might be that the first deposit is done by a trusted account, but this is not enforced.    A new constant FIRST_DEPOSIT_LIMIT is introduced and a require checks that each token amount is above this limit with tokenAmounts[i] > FIRST_DEPOSIT_LIMIT.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Setting Wrong State Variable", "body": "  The function _setOperatorParams in VaultGovernance, as the name suggests, should update the state variable _operatorParams, instead it overwrites the variable _protocolParams:  function _setOperatorParams(bytes memory params) internal {     _requireAtLeastOperator();     _protocolParams = params; }  This mistake has severe consequences: operator gets admin privileges to set _protocolParams or can set  a  vault  state  to  incorrect  parameters.  Finally,  the  functionality  to  initialize  or  update  the _operatorParams is missing.    The  issue  is  resolved  and  now  the  function  _setOperatorParams  sets  the  operator  params  as intended. The natspec description has been updated accordingly also.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   Wrong Formula in ", "body": " _rebalanceUniV3Liquidity  The  function  _rebalanceUniV3Liquidity  in  LStrategy  updates  the  value  of  liquidity  as follows:  liquidity = uint128(     FullMath.mulDiv(         availableBalances[i],         shouldDepositTokenAmountsD[i] - shouldWithdrawTokenAmountsD[i],         DENOMINATOR     ) );  The  formula  above  is  wrong,  it  multiplies  two  amounts  in  token[i],  then  divides  the  result  with DENOMINATOR.  Mellow Finance - Mellow Vaults -   29  CorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                \f  The formula now multiplies with DENOMINATOR and divides by the token amount.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.18   Wrong TVL Calculation in ERC20RootVault", "body": "  ERC20RootVault._getTvlToken0  calculates  the  TVL  of  the  Vault  denominated  in  the  token  at position 0 of an array of tokens. It iterates over all the tokens in the array, but only ever compares token with index 0 to token with index 1. It should, however, compare token with index 0 to the token with the current iteration's index. The function is only used in _calculatePerformanceFees.  for (uint256 i = 1; i < tvls.length; i++) {         (uint256[] memory prices, ) = oracle.price(tokens[0], tokens[1], 0x28);    The issue has been resolved as the correct index is now used when querying the price of tokens inside the loop.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   liquidity Gets Overwritten in the Loop", "body": "  The following loop in LStrategy._rebalanceUniV3Liquidity updates the liquidity for vault tokens in a loop:  for (uint256 i = 0; i < 2; i++) {     ...     liquidity = uint128(         FullMath.mulDiv(             availableBalances[i],             shouldDepositTokenAmountsD[i] - shouldWithdrawTokenAmountsD[i],             DENOMINATOR         )     ); }  The  final  value  of  liquidity  after  the  loop  exists  should  be  the  minimum  value  calculated  in  each iteration, however, the loop above overwrites the liquidity on each iteration without performing any check.    In  with liquidity, hence liquidity can only decrease in the loop:    the  potentialLiquidity  is  computed  on  each  iteration  of  the  loop  and  it  is  compared  Mellow Finance - Mellow Vaults -   30  CorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrectedVersion2                \fliquidity = potentialLiquidity < liquidity ? potentialLiquidity : liquidity;  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   Wrong State Variable Updated", "body": "  The function LStrategy.rebalanceUniV3Vaults updates the wrong state variable when storing the timestamp of the ongoing rebalance:  require(     block.timestamp >= lastRebalanceUniV3VaultsTimestamp + otherParams.secondsBetweenRebalances,     ExceptionsLibrary.TIMESTAMP ); lastRebalanceERC20UniV3VaultsTimestamp = block.timestamp;  Due to this error the throttling mechanism does not work as expected for the function rebalancing the two function uniswap  vaults.  Furthermore,  rebalanceERC20UniV3Vaults.  throttling  mechanism  of   this  also  affects   the   the     The issue has been fixed and the correct state variable is updated in rebalanceUniV3Vaults:  lastRebalanceUniV3VaultsTimestamp = block.timestamp;  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.21   Inconsistent Access Control for Rebalance in", "body": " LStrategy  The  function  LStrategy.rebalanceERC20UniV3Vaults  restricts  the  access  to  only  accounts  with operator or admin roles. However, functions deposit and withdraw in the ERC20RootVault do not have  any  access  restriction  (unless  the  vault  is  private).  The  root  vault  has  the  operator  role  in LStrategy  and  for  any  deposit  or  withdraw  operation,  the  vault  triggers  the  rebalance  function  in LStrategy, hence circumventing the access control of the rebalance function.  Specification changed:  Mellow Finance has decided to remove the callback feature that triggered the rebalance in LStrategy. Now, the rebalance functions rebalanceERC20UniV3Vaults and rebalanceUniV3Vaults can be called only by whitelisted addresses with either admin or operator role. Note that, the callback feature is still present in ERC20RootVault in case future strategies will support the callback feature.  Mellow Finance - Mellow Vaults -   31  DesignMediumVersion8CodeCorrectedDesignMediumVersion4Speci\ufb01cationChanged                  \f6.22   Inconsistent Sanity Check on First Deposit's Amounts  The  function  ERC20RootVault.deposit  runs  the  following  loop  for  the  first  deposit  (whenever totalSupply  is  0)  to  check  that  all  amounts  are  above  a  threshold  FIRST_DEPOSIT_LIMIT (hard-coded to 10000):  if (totalSupply == 0) {     for (uint256 i = 0; i < tokens.length; ++i) {         require(tokenAmounts[i] > FIRST_DEPOSIT_LIMIT, ExceptionsLibrary.LIMIT_UNDERFLOW);     } }  The  contract  uses  another  set  of  thresholds  per  token  _pullExistentials  which  are  initialized  as: 10**(token.decimals() / 2). Hence for tokens with more than 8 decimals, there is a gap between the two thresholds FIRST_DEPOSIT_LIMIT and _pullExistentials. If the first deposit includes an amount for a token in this gap, the contract does not allow new deposits for the token from other users as the respective TVL will be always below the threshold _pullExistentials. This behavior is enforced in _getLpAmount:  for (uint256 i = 0; i < tvlsLength; ++i) {     if (tvl_[i] < pullExistentials[i]) {         continue;     }     ... }  and in the function _getNormalizedAmount:  if (tvl_ < existentialsAmount) {     // use zero-normalization when all tvls are dust-like     return 0; }    Mellow Finance now requires that the amount in the first deposit is 10 times the _pullExistentials.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.23   Safety Level of Returned Prices Can Silently", "body": " Downgrade  The  function  UniV3Oracle.price  returns  more  than  one  price  depending  on  the  value  of safetyIndicesSet. UniV3Oracle supports 4 safety levels:   Safety level 1: spot price.   Safety level 2: average price based on observations from last 2.5 minutes.  Mellow Finance - Mellow Vaults -   32  DesignMediumVersion4CodeCorrectedSecurityMediumVersion4Speci\ufb01cationChanged              \f Safety level 3: average price based on observations from last 7.5 minutes.   Safety level 4: average price based on observations from last 30 minutes.  If  a  Uniswap  pool  does  not  have  enough  observations  required  for  a  safety  level,  the  oracle  skips  the prices for such safety levels and returns only prices with lower safety levels. The respective code:  for (uint256 i = 2; i < 5; i++) {     ...     (int24 tickAverage, , bool withFail) = OracleLibrary.consult(address(pool), observationTimeDelta);     if (withFail) {         break;     }     ... }  Specifications changed:  The  natspec  description  of  IOracle.priceX96  has  been  updated  to  be  more  explicit  about  this behavior:  /// @notice It is possible that not all indices will have their respective prices returned.  Also, more detailed description has been added in UniV3Oracle.priceX96:  /// If there is no initialized pool for the passed tokens, empty arrays will be     returned. /// Depending on safetyIndicesSet if the 1st bit in safetyIndicesSet is non-zero, then     the response will contain the spot price. /// If there is a non-zero 2nd bit in the safetyIndicesSet and the corresponding     position in the pool was created no later than |l|_OBS_DELTA seconds ago, /// then the average price for the last |l|_OBS_DELTA seconds will be returned. The     same logic exists for the 3rd and MID_OBS_DELTA, and 4th index and |hl|_OBS_DELTA.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.24   Unfair Distribution of LP Shares in", "body": " ERC20RootVault  The  ERC20RootVault  charges  the  management,  protocol  and  performance  fees  by  minting  new  LP shares, hence inflating the total supply. The function _chargeFees is triggered on every deposit (and withdraw) action, hence the total supply of LP shares after a deposit increases more than the amount of LP shares awarded to the depositor. In this way, a second deposit of the same token amounts after the fees have been charged, receives more LP shares than the first one.  For  example,  assume  that  the  ERC20RootVault  has  been  initialized  and  a  first  user  deposits  10 TokenA and 10 TokenB (assuming 0 decimals for simplicity) and receives 10 LP shares. As the fees will be charged on deposit, let's suppose another 1 LP share will be minted, hence in total there are 11 LP shares  minted  after  the  deposit.  If  a  second  user  deposits  the  same  amounts  10  TokenA  and  10 TokenB, the function _getLpAmount will award 11 LP shares to the user although the same amounts were deposited.    Mellow Finance - Mellow Vaults -   33  DesignMediumVersion3CodeCorrected        \fThe  issue  has  been  addressed  by  modifying  the  functions  deposit  to  charge  fees  first  and  then compute the LP shares awarded to the user according to the new LP supply.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.25   Conflicting Specifications for MStrategy", "body": "  The specifications of MStrategy have conflicting instructions. The section \"TickMin and TickMax update\" states:  tickMin and tickMax are initially set to some ad-hoc params. As soon as the current price \u2014 tick is greater than tickMax - tickNeiborhood or less than tickMin + tickNeiborhood  the boundaries of the interval is expanded by tickIncrease amount.  In the rebalance steps, tickNeiborhood is used instead of tickIncrease:  - tick is greater than tickMax - tickNeiborhood then new     boundaries are [tickMin, tickMax + tickNeiborhood]  - tick is less than tickMin + tickNeiborhood then new     boundaries are [tickMin - tickNeiborhood, tickMax]  Specification changed:  The specification was changed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.26   Implementation Differs From Specification", "body": " on _targetTokenRatioD  The specifications use the following formula to compute the portions of tokens in a Uniswap v3 pool: | wx = tick \u2212 tickMax tickMin \u2212 tickMax  However, the implementation uses the following code:  return (uint256(uint24(tick - tickMin)) * DENOMINATOR) / uint256(uint24(tickMax - tickMin));  which corresponds to the following formula: |  wx = tick \u2212 tickMin  tickMax \u2212 tickMin    The  implementation  of  MStrategy._targetTokenRatioD  has  been  updated  to  comply  to  the specification.  Mellow Finance - Mellow Vaults -   34  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                    \f6.27   Incorrect Access of Addresses in  EnumerableSet  Function  commitAllValidatorsSurpassedDelay  in  the  protocol  governance  contract  has  a  for loop that iterates through _stagedValidatorsAddresses and commits the ones for which the delay period has passed. The respective code is:  for (uint256 i; i != length; i++) {     address stagedAddress = _stagedValidatorsAddresses.at(0);     if (block.timestamp >= stagedValidatorsTimestamps[stagedAddress]) {         ...     } }  The variable stagedAddress inside the loop points always to the hard-coded index 0, hence if there is at least one address in staged validators for which the deadline has not passed, the loop will just run until it reaches i==length.    The 0 was replaced by the index variable i. The loop exit conditions were changed to:  uint256 length = _stagedValidatorsAddresses.length(); ... uint256 addressesCommittedLength; for (uint256 i; i != length;) {         address stagedAddress = _stagedValidatorsAddresses.at(i);             ...             addressesCommitted[addressesCommittedLength] = stagedAddress;             ++addressesCommittedLength;             --length;             ...         } else {             ++i;         }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.28   Missing Checks for Dust Amounts When", "body": " Rebalancing Pools  The  function  _rebalancePools  in  MStrategy  rebalances  the  erc20Vault  and  moneyVault  to comply  to  the  specified  ratio  erc20MoneyRatioD.  The  rebalancing  is  performed  always  when  a non-zero amount should be moved from one vault to the other, i.e., even for dust amounts. Considering that pull is relatively costly, the strategy would be more efficient if it performs the rebalancing of the two pools only if a minimum threshold of tokens should be moved.  Mellow Finance - Mellow Vaults -   35  CorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  The updated code does not perform the token transfers if only dust amounts should be moved:  if ((absoluteTokenAmounts[0] < minDeviation) && (absoluteTokenAmounts[1] < minDeviation)) {     return tokenAmounts; }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.29   Missing Delay Restriction in BaseValidator", "body": "  Setting the new params in BaseValidator follows the pattern stage-wait-commit. On staging the new parameters, the respective timestamp is updated:  _stagedValidatorParamsTimestamp = block.timestamp + governance.governanceDelay;  However,  the  admin  of  the  governance  can  commit  the  staged  parameters  at  any  time,  e.g., immediately after staging them, by calling commitValidatorParams as the function does not check if the delay period has passed.    The  block.timestamp >= _stagedValidatorParamsTimestamp.  function   checks   delay   now   the   with   a   require   validating  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.30   Missing Sanity Checks in signOrder", "body": "  The function signOrder in LStrategy performs some sanity checks if the submitted order is in line with the values of the posted preOrder. However, the check for order.receiver is missing, therefore the caller can set any arbitrary address and receive the buyToken.    The  code  doing  the  sanity  checks  for  order  in  signOrder  has  been  moved  to  the  separate  function LStrategyOrderHelper.checkOrder  which  the erc20Vault.  the  receiver   the  check   includes   that   is   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.31   No Slippage Protection in Multiple Contracts", "body": "  push and pull functions in UniV3Vault take options arguments that contain the minimum amount of tokens for slippage protection.  Mellow Finance - Mellow Vaults -   36  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                        \fpush and pull functions in MellowVault take an options argument that contains the minimum amount of LP tokens for slippage protection.  In the following cases, these options are not used:  call    ERC20RootVault.deposit calls AggregateVault._push without options, which could result in described a  of  Vault``s  without  slippage  protection  if  the  first  ``subVault  of  the ERC20RootVault  is  one  of  the  described  Vault  s.  With  the  current  contract  setup,  this  is  not possible though.  _push   one   the   to   of    ERC20RootVault.withdraw calls AggregateVault._pull without options, which could result  in a call to _pull of one of the described ``Vault``s without slippage protection.   MStrategy.manualPull calls pull of an arbitrary Vault without options, which could result in a  call to _pull of one of the described ``Vault``s without slippage protection.   MStrategy._rebalancePools  calls  pull  of  an  arbitrary  Vault  without  options,  which  could  result in a call to _pull of one of the described ``Vault``s without slippage protection.   MStrategy._swapToTarget calls pull of an arbitrary Vault without options, which could result  in a call to _pull of one of the described ``Vault``s without slippage protection.    A new parameter with option for slippage protection was introduced.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.32   Possible Underflow in UniV3Oracle.price", "body": "  The UniV3Oracle computes the price of two tokens based on two observations obs1 and obs0 from the Uniswap. The respective code is:  uint256 obs1 = (uint256(observationIndex) + uint256(observationCardinality) - 1) %                 uint256(observationCardinality); uint256 obs0 = (uint256(observationIndex) + uint256(observationCardinality) - bfAvg) %                 uint256(observationCardinality); int256 tickAverage; {     (uint32 timestamp0, int56 tick0, , ) = IUniswapV3Pool(pool).observations(obs0);     (uint32 timestamp1, int56 tick1, , ) = IUniswapV3Pool(pool).observations(obs1);     uint256 timespan = timestamp1 - timestamp0; // reverts     ... }  The  obj1  points  to  the  previous  observation  (the  one  before  the  most  recent  observation),  while  the obj0 should point to bfAvg observations before obj1. However, in case:  bfAvg == observationCardinality  obj0 would point to the most recent observation, which would have a more recent timestamp than obj1, hence the statement to compute timespan would cause an underflow which reverts.    Mellow Finance - Mellow Vaults -   37  CorrectnessMediumVersion1CodeCorrected        \fThe  possibility  of  the  underflow  as  described  above  has  been  mitigated  in  the  updated  code  as  the bfAvg cannot be equal to obersvationCardinality:  if (observationCardinality <= bfAvg) {     continue; }  Note  that,  the  oracle  does  not  return  a  price  if  for  some  pool  bfAvg  is  equal  to  the  observations cardinality.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.33   Rebalance in LStrategy Can Leave Tokens in", "body": " the Vault to Be Closed  The  internal  function  _rebalanceUniV3Liquidity  should  move  the  desiredLiquidity  from  one vault to the other depending on the price trend. If the price moves outside the range covered by a vault, all liquidity should be moved to the other vault and a new position should be open. However, given that lowerVault and upperVault operate on different price ranges, it means that they have different token ratios.  Hence,  when  moving  tokens  from  one  vault  to  the  other,  the  function  caps  the  liquidity  being transferred to the available balance in the cash position that can fill the token difference of two positions (the relevant code is shown below). However, if the cash position has insufficient balance to cover the difference for the whole liquidity being transferred, fromVault will have some remaining liquidity, hence it cannot be closed. As a consequence, a new Uniswap position cannot be created to cover the price as intended.  uint128 potentialLiquidity = uint128(     FullMath.mulDiv(         availableBalances[i],         DENOMINATOR,         shouldDepositTokenAmountsD[i] - shouldWithdrawTokenAmountsD[i]     ) ); liquidity = potentialLiquidity < liquidity ? potentialLiquidity : liquidity;    The  function  LStrategy._rebalanceUniV3Liquidity  has  been  modified  in    to  withdraw everything from a vault when desiredLiquidity is set to maximum value of uint128, which is the case when a vault is to be closed. The relevant code is:  uint256[] memory withdrawTokenAmounts = fromVault.liquidityToTokenAmounts(     desiredLiquidity == type(uint128).max ? desiredLiquidity : liquidity ); pulledAmounts = fromVault.pull(     address(erc20Vault),     tokens,     withdrawTokenAmounts,     _makeUniswapVaultOptions(minWithdrawTokens, deadline) );  Mellow Finance - Mellow Vaults -   38  DesignMediumVersion1CodeCorrectedVersion3        \fThe array withdrawTokenAmounts will have huge amounts when the desiredLiquidity is set to max uint128, but the pull operation is capped to the existing balance of the fromVault.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.34   Subvault Tokens Are Not Checked in ", "body": " AggregateVault  AggregateVault  requires  the  _vaultTokens  state  array  to  be  initialized  with  the  same  tokens  and the  same  ordering  all  the  subvaults  have  been  initialized  with.  However,  this  is  not  enforced  upon initialization.    When initializing, the vault of the nft is queried in AggregateVault.initialize. The vault's tokens are  queried  afterwards  with  the  call  IIntegrationVault(vault).vaultTokens().  A  loop  checks for each token in the vault if it matches the tokens from the initialization arguments.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.35   Transferring Tokens Only to lowerVault", "body": "  The  following  code  should  transfer  tokens  from  erc20Vault  to  the  two  Uniswap  vaults  with  the respective amounts:  if (!isNegativeCapitalDelta) {     totalPulledAmounts = erc20Vault.pull(         address(lowerVault),         tokens,         lowerTokenAmounts,         _makeUniswapVaultOptions(minLowerVaultTokens, deadline)     );     pulledAmounts = erc20Vault.pull(         address(lowerVault),         tokens,         upperTokenAmounts,         _makeUniswapVaultOptions(minUpperVaultTokens, deadline)     );     for (uint256 i = 0; i < 2; i++) {         totalPulledAmounts[i] += pulledAmounts[i];     } }  Both transfers above are from the erc20Vault to the lowerVault, hence no tokens are transferred to the upperVault.    The  bug  has  been  fixed,  the  code  now  transfers  the  respective  amounts  to  the  lowerVault  and upperVault.  Mellow Finance - Mellow Vaults -   39  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f6.36   Use of Libraries  Mellow Finance often uses own custom code for which battle proof libraries exist. We highly recommend using libraries instead of custom implementations. Especially, when dealing with complex DeFi projects like Uniswap V3.  Code Corrected:  The  code  part  were  most  issues  were  found  was  the  Uniswap  oracle.  In  switched to the libraries provided by uniswap to interact with the oracle.    Mellow  Finance  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.37   Missing Sanity Checks for ", "body": " intervalWidthInTicks  function  LStrategy.updateOtherParams  does  not  perform  any  sanity  check  on  The  the intervalWidthInTicks. However, this parameter should be carefully updated as it affects directly the tick ranges covered by the two Uniswap vaults. For example, if the new width in ticks is the half of the existing one, the range of the new position would be fully covered by the existing vault (created with old width).    In  the  updated  version  of  the  codebase,  the  parameter  intervalWidthInTicks  is  declared  as  an immutable state variable, hence it set in the constructor and cannot be updated later.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.38   Possible Attack by First Depositor", "body": "  The decimals of the LP shares distributed by root vaults are implicitly determined by the token amounts deposited  by  the  first  user.  If  the  totalSupply  ever  goes  to  zero,  or  all  TVLs  are  not  significant,  the next  user  that  performs  a  deposit  would  affect  the  decimals  of  LP  shares.  This  setup  allows  the  first depositor  to  front-run  and  potentially  exploit  the  next  user  depositing  into  the  root  vault.  Consider  the following example.  1. First  Depositors  deposits  10  WBTC  (8  decimals,  so  10**9  wei)  and  10**-9  DAI  (18  decimals,  so  10**9 wei)   Receives 10**9 LP Tokens (= max(10**9, 10**9))  2. Second Depositor also sends a transaction to deposit 10 WBTC and 10**-9 DAI   Expects to receive also 10**9 LP Tokens, hence sets minLpTokens = 10**9  3. First depositor front-runs the transaction and performs these actions:  Mellow Finance - Mellow Vaults -   40  DesignMediumVersion1CodeCorrectedVersion3DesignLowVersion5CodeCorrectedSecurityLowVersion5Speci\ufb01cationChanged                        \f withdraw() => withdraws everything, no fees charged   deposit() => deposit 10**5 WBTC wei and 10**10 DAI wei => Receives 10**10 LP tokens   withdraw() => withdraws ~ 9 * 10**9 LP => TVLs = [10**4 - 1 WBTC wei, 10**9 - 1 USDC  wei]   First depositor still has ~ 10**9 LP  4. Transaction of second depositor is executed   _getLpAmount -> isSignificantTvl == False   Receives 10**9 LP tokens => slippage protection passes   Deposits 10 WBTC and 10**-9 DAI  5. First  depositor  withdraws  their  ~  10**9  LP  and  receives  ~  5  WBTC  (after  depositing  only  0.0001  WBTC)  Specifications changed:  The updated code mitigates the attack presented above by enforcing the first deposit into a root vault to mint  LP  shares  to  address(0).  To  prevent  from  accidentally  depositing  large  amounts  in  the  first deposit  (and  effectively  burning  LP  shares),  the  function  checks  that  all  amounts  being  deposited  are between 10 * _pullExistentials[i] and a full token. Nevertheless, one full token might still have significant value for some tokens, e.g., WBTC or ETH.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.39   Possible Optimization on", "body": " _chargePerformanceFees  The  function  _chargePerformanceFees  in  ERC20RootVault  mints  LP  tokens  to  the  treasury address as follows:  uint256 toMint; if (hwmsD18 > 0) {     toMint = FullMath.mulDiv(baseSupply, lpPriceD18 - hwmsD18, hwmsD18);     toMint = FullMath.mulDiv(toMint, performanceFee, CommonLibrary.DENOMINATOR); } lpPriceHighWaterMarkD18 = lpPriceD18; _mint(treasury, toMint);  The function would be more gas efficient if the minting is executed only for non-zero values, hence only minting when the if-condition is satisfied.    In  the  updated  code,  the  statement  _mint(...)  is  moved  inside  the  if-block,  hence  minting  only non-zero amounts.  Mellow Finance - Mellow Vaults -   41  DesignLowVersion5CodeCorrected          \f6.40   Possible Violation of the Minimum Token Amounts After the First Deposit  The function ERC20RootVault.deposit checks on the first deposit that all token amounts are larger than  a  minimum  value  10  *  _pullExistentials[i].  If  the  TVL  for  a  token  goes  below  the threshold,  users  cannot  make  deposits  for  that  token.  However,  the  first  depositor  can  circumvent  the restriction for the minimum token amounts by performing an withdrawal after the deposit.    The issue presented above is not present anymore in the updated code base as the first deposit always mints LP shares to address(0).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.41   Misleading Function Name and Natspec", "body": "  The function LStrategy.targetPrice returns the price in x96 format. Neither the function name, nor the natspec description clarify the format of the return value. We have reported another issue in a calling function which assumed the price to be returned in a different format.    The codebase has been updated to make more explicit in the function name and natspec description of getTargetPriceX96 that the returned price is in x96 format. Similarly, other functions that return the price in x96 format are renamed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.42   Mismatch of Specifications for", "body": " StrategyParams  The natspec description for the struct StrategyParams states that the params are changed with a delay:  /// @notice Params that could be changed by Strategy or Protocol Governance     with Protocol Governance delay.  while  the  natspec  description  of  the  function  setStrategyParams  states  that  they  are  changed immediately, which is in line with the implementation:  // @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.  Core corrected  The natspec was corrected and does not mention the governance delay.  Mellow Finance - Mellow Vaults -   42  DesignLowVersion5CodeCorrectedCorrectnessLowVersion4CodeCorrectedCorrectnessLowVersion4CodeCorrected                      \f6.43   Missing Sanity Check for maxSlippageD in MStrategy  The function MStrategy.setOracleParams does not check that maxSlippageD is greater than zero, but if it is accidentally set to zero, the following code will revert always: .. code::solidity  require(absoluteDeviation < oracleParams.maxTickDeviation, ExceptionsLibrary.INVARIANT);    The function setOracleParams is updated to include a check that the new maxSlippageD parameter is not zero:  require((params.maxSlippageD > 0) && (params.maxSlippageD <= DENOMINATOR), ExceptionsLibrary.INVARIANT);  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.44   Missing Sanity Checks for oracleSafetyMask", "body": "  The  function  LStrategy.updateTradingParams  performs  sanity  checks  on  the  maxSlippageD, orderDeadline and oracle, but no checks are performed for oracleSafetyMask. This parameter should be non-zero for functions that query the oracle to work properly. Additionally, the function could check that at least one oracle with high safety index is included always.    An  additional  check  is  added  when  new  trading  params  are  set  by  the  admin.  The  check  fort  the  new oracle safety mask is: newTradingParams.oracleSafetyMask > 3.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.45   Possible Struct Optimization in Strategies", "body": "  Mellow Finance might want to consider to optimize some structs in the code base. E.g., in:  struct TradingParams {     uint32 maxSlippageD;     uint32 orderDeadline;     uint256 oracleSafetyMask;     IOracle oracle;     ...  struct PreOrder {     address tokenIn;     address tokenOut;     uint256 amountIn;  Mellow Finance - Mellow Vaults -   43  DesignLowVersion4CodeCorrectedDesignLowVersion4CodeCorrectedDesignLowVersion4CodeCorrected                        \f    uint256 minAmountOut;     uint256 deadline; }  struct RatioParams {     int24 tickMin;     int24 tickMax;     uint256 erc20MoneyRatioD;     int24 minTickRebalanceThreshold;     int24 tickNeighborhood;     int24 tickIncrease;     uint256 minErc20MoneyRatioDeviation0D;     uint256 minErc20MoneyRatioDeviation1D; }  Some  of  the  variables  will  not  take  up  a  whole  word  and  could  be  reordered  to  be  packed  tightly  if needed.    The variables in the structs listed above are reordered to be more efficient when stored in storage in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.46   Redundant Comparisons", "body": "  The function Univ3Vault._getMinMaxPrice implements the following code:  minPriceX96 = prices[0]; maxPriceX96 = prices[0]; for (uint32 i = 0; i < prices.length; ++i) {     if (prices[i] < minPriceX96) {         ...  Note that minPriceX96 and maxPriceX96 are assigned to prices[0] before the for-loop, so the first iteration of the loop is redundant.    The for-loop has been updated to start from i = 1 which avoids the redundant checks.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.47   Redundant Storage Read in ", "body": " ERC20Vault._pull  _vaultTokens  is  a  state  variable  that  is  read  multiple  times  in  the  _pull  function  even  though  it  is stored in memory at the beginning of the function in tokens.  Mellow Finance - Mellow Vaults -   44  DesignLowVersion4CodeCorrectedDesignLowVersion4CodeCorrected                \f  The  function  has  been  revised  to  avoid  storage  reads  for  _vaultTokens,  instead  the  value  stored  in memory tokens is now used.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.48   Variables Can Be Declared as Constant", "body": "  The variable MAX_ESTIMATED_AAVE_APY in AaveVaultGovernance is declared as immutable and assigned  to  a  constant  in  constructor.  Similarly,  MAX_PROTOCOL_FEE,  MAX_MANAGEMENT_FEE  and MAX_PERFORMANCE_FEE in ERC20RootVaultGovernance can be declared as constants.    All immutable variables listed above are converted to constants.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.49   Incorrect Specification for reclaimTokens", "body": "  The following statement in IntegrationVault regarding the function reclaimTokens is incorrect:  /// `reclaimTokens` for mistakenly transfered tokens (not included into vaultTokens) /// additionally can be withdrawn by the protocol admin  Specification changed:  The statement in IntegrationVault has been changed as:  /// `reclaimTokens` for claiming rewards given by an underlying protocol to erc20Vault      in order to sell them there  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.50   Missing Natspec Description for ", "body": " minDeviation  The  parameter  minDeviation  in  the  function  LStrategy._liquidityDelta  has  no  natspec description.  Code Corrected:  The description for minDeviation was added.  Mellow Finance - Mellow Vaults -   45  DesignLowVersion4CodeCorrectedCorrectnessLowVersion3Speci\ufb01cationChangedCorrectnessLowVersion2CodeCorrected                        \f6.51   Casting of maxTickDeviation  maxTickDeviation  _getAverageTickChecked, the variable is casted as int24:  is  declared  as  uint24   in   the  struct  OracleParams.   In   function  int24 maxDeviation = int24(oracleParams.maxTickDeviation);  For large values of maxTickDeviation, an overflow can happen when casting as int24.    The  deviation  is  now  converted  to  an  absolute  value  and  directly  compared  to  the  maxDeviation without casting it to an int24.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.52   Check Requirements First", "body": "  Multiple functions can be more efficient by checking all requirements first (fail early), before performing expensive operations, such as external calls. We list below some examples (not an exhaustive list):   UniV2Validator: in validate both branches of the if condition require the msg.sender to be the  address  to.  The  function  can  be  optimized  by  checking  the  requirement  first,  and  then performing the call to _verifyPath function.   UniV2Validator:  the  function  _verifyPath  can  be  optimized  by  checking  the  following  requirement first, before making external calls in the loop:  require(vault.isVaultToken(path[path.length - 1]), ExceptionsLibrary.INVALID_TOKEN);   UniV3Validator:  the  function  _verifyMultiCall  can  be  optimized  by  checking  the  following  requirement first, before iterating through path and making external calls:  require(recipient == address(vault), ExceptionsLibrary.INVALID_TARGET);    The  updated  code  expensive for the cases listed above.    performs  the  checks  first  before  executing  other  operations  that  might  be  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.53   Duplicate Code _permissionIdsToMask", "body": "  The  function  revokePermissions  in  the  ProtocolGovernance  contract  implements  the  following loop:  Mellow Finance - Mellow Vaults -   46  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion3DesignLowVersion1CodeCorrected                        \fuint256 diff; for (uint256 i = 0; i < permissionIds.length; ++i) {         diff |= 1 << permissionIds[i]; }  which is a duplicate of the _permissionIdsToMask function.    The code part was replaced by a call to the _permissionIdsToMask function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.54   Duplicate Storage Read in Deposit", "body": "  In ERC20RootVault.deposit the variable totalSupply is read for the check if it is 0 and later again to be loaded into memory.    The redundant storage read is eliminated in the updated code and the value stored in memory supply is used instead.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.55   Inconsistent Specifications", "body": "  In the specifications of struct IProtocolGovernance.Params:   permissionless is described but it's not a member of the struct.   maxTokensPerVault  has  the  description  that  it  stores  the  maximum  tokens  managed  by  the  protocol, not a vault as the name suggests.   protocolTreasury is not described.  In the specifications of unitPrices, the comment staged for commit is wrong.  Specifications changed:  The specifications have been updated in    to address the issues reported above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.56   Inefficient Array Shrinking", "body": "  ProtocolGovernance.addressesByPermission  and ProtocolGovernance.commitAllPermissionGrantsSurpassedDelay  arrays  with extended length and copy the values to a newly generated array with the correct size. This can be more efficiently done with mstore assembly, which is also used in various other places in the code.  create   Mellow Finance - Mellow Vaults -   47  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedVersion2DesignLowVersion1CodeCorrected                        \f  The array is now cut to length via mstore as in other parts of the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.57   Inefficient State Variable Packing", "body": "  lastFeeCharge  and  totalWithdrawnAmountsTimestamp  in  ERC20RootVault  are  declared  as uint256.  Both  are  timestamps;  hence,  it  might  be  more  efficient  to  pack  them  as  uint64.  This  only makes sense if they are used and loaded together, which would be possible in the current code base. Similarly, other structs in other contracts can be more storage-efficient by packing variables together.    Both  variables  lastFeeCharge  and  totalWithdrawnAmountsTimestamp  have  been  declared  as uint64 in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.58   Misleading Naming of Variables in ", "body": " UniV3Oracle  The  function  price  uses  variable  names  that  are  inconsistent  with  the  variable  names  of  Uniswap. Namely,  the  variables  tick0  and  tick1  refer  to  tickCumulative  variables  of  Uniswap  and  not normal ticks.  Similarly,  the  array  pricesX96  temporarily  stores  prices  in  square  root  format  which  are  typically referred to as sqrtPriceX96. These inconsistencies make the reading of the code harder.  Code Corrected:  The variables were renamed accordingly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.59   Missing Sanity Check in ", "body": " MStrategy.createStrategy  In MStrategy.createStrategy any token array could be passed in, but the strategy can only handle two tokens. There is no sanity check to limit the number of tokens. The fee parameter is also not checked even though it could only take a limited range of values.    Mellow Finance - Mellow Vaults -   48  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe sanity check on the tokens array is added in the initialize function which is called when a new strategy  is  created.  The  sanity  check  for  the  fee  parameter  is  performed  when  the  pool  address  is queried:  pool = IUniswapV3Pool(factory.getPool(tokens[0], tokens[1], fee_)); require(address(pool) != address(0), ExceptionsLibrary.ADDRESS_ZERO);  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.60   Missing Sanity Checks for Params", "body": "  LStrategy.updateRatioParams  and  LStrategy.updateOtherParams  do  not  perform  sanity checks on all the params.  Code Corrected:  Both functions now perform basic sanity checks for the arguments.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.61   Misspelled Variable Names", "body": "  Function  deposit  delayedStaretgyParams.  in  ERC20RootVault  declares  a   variable  with  misspelled  name:  Struct ratioParams in MStrategy declares a variable with misspelled name: tickNeiborhood.    Both variable names have been corrected in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.62   Possible Struct Optimization", "body": "  Mellow Finance might want to consider to optimize some structs in the code base. E.g., in:  struct TradingParams {     uint256 maxSlippageD;     uint256 minRebalanceWaitTime;      ...  struct RatioParams {     uint256 erc20UniV3CapitalRatioD;     uint256 erc20TokenRatioD;     uint256 minErc20UniV3CapitalRatioDeviationD;     uint256 minErc20TokenRatioDeviationD;     uint256 minUniV3LiquidityRatioDeviationD  Mellow Finance - Mellow Vaults -   49  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fSome of the variables will not take up a whole word and could be packed if needed.    The examples above and some other structs were changed. We assume that Mellow Finance evaluated all structs if an optimization is suitable and shall be applied.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.63   Rebalance in MStrategy Is Inconsistent", "body": "  MStrategy provides only one function for rebalancing (rebalance) which calls _rebalancePools to enforce  the  predetermined  ratio  for  the  pools  (erc20Vault  and  moneyVault)  and  then  calls _rebalanceTokens to enforce the token ratio for the erc20Vault. The latter calls _swapToTarget which, in specific cases, pulls tokens from the moneyVault to the erc20Vault:  if (amountIn > erc20Tvl[tokenInIndex]) {     ...     moneyVault_.pull(address(erc20Vault_), tokens_, tokenAmounts, \"\");     ... }  This  transfer  of  tokens  from  moneyVault  to  the  erc20Vault  would  break  the  balance  set  in  the function _rebalancePools called in the beginning of the rebalance process.    The function rebalance has been updated to perform first the rebalance of tokens in the erc20Vault, which includes any potential swap. Afterwards, the function calls _rebalancePools which enforces the predetermined ratio of TVLs for the erc20Vault and moneyVault.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.64   Specification for minDeviation Not", "body": " Enforced  The function rebalanceERC20UniV3Vaults in LStrategy calls the function _liquidityDelta and provides the minimum required deviation for a rebalance to be performed. _liquidityDelta checks the  current  deviation  and  if  it  is  lower  than  the  required  minimum,  it  returns  0.  However,  the  calling function  does  not  check  the  return  value,  hence  continues  the  execution  of  the  function  although  no tokens will be moved.    The  check  below  for  the  return  value  of  the  function  _liquidityDelta  has  been  added.  Now  the function returns immediately if capitalDelta is equal to 0 due to current deviation being smaller than the minimum required deviation:  Mellow Finance - Mellow Vaults -   50  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f(capitalDelta, isNegativeCapitalDelta) = _liquidityDelta(...); if (capitalDelta == 0) {     return (pulledAmounts, false); }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.65   Storing Redundant Data in Storage", "body": "  The function _addUniV3Pools stores two entities in the mapping for each pair of tokens:  poolsIndex[token0][token1] = pool; poolsIndex[token1][token0] = pool;  Given that there is only one Uniswap pool for a pair of tokens and a fee, the tokens can be sorted and stored only once in the mapping: tokenA -> tokenB -> pool, assuming tokenA < tokenB.    The  mapping  poolsIndex  token0 -> token1 -> pool.  now   stores   only   one   entry   for   a   pair   of   tokens  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.66   Unnecessary Approval to Vault Registry", "body": "  Function _initialize in Vault has the following line which gives approval to the vault registry, but it is unnecessary as VaultRegistry is the implementation contract of the NFT token:  registry.setApprovalForAll(address(registry), true);    The statement giving the approval has been removed from the function in   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.67   Unused Constant in ERC20Validator", "body": "  ERC20Validator declares the following constant, but it is not used:  bytes4 public constant EXCHANGE_SELECTOR = 0x3df02124;    Mellow Finance - Mellow Vaults -   51  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrected                        \fThe constant was removed from the contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.68   Unused Event DeployedVault", "body": "  The  contract  VaultGovernance  defines  the  event  DeployedVault  but  it  is  not  used  in  the  current code base.    The updated code emits the event DeployedVault when a new vault is created.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.69   Unused Function ", "body": " LStrategy._priceX96FromTick  The internal function LStrategy._priceX96FromTick is not used in the LStrategy.    The function was removed from the L Strategy.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.70   Unused Imports", "body": "  Throughout the code base we found many unused imports. Due to the number of unused imports, the following list is non-exhaustive and list only examples:  -MellowOracle  import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"  import \"../libraries/CommonLibrary.sol\";   UniV2Oracle  import \"../libraries/ExceptionsLibrary.sol\"   UniV3Oracle  import \"../libraries/ExceptionsLibrary.sol\"   LStrategy  import \"../interfaces/IVaultRegistry.sol\"  import \"../interfaces/utils/IContractMeta.sol\"   MStrategy  import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";   CowswapValidator  Mellow Finance - Mellow Vaults -   52  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fimport \"../libraries/CommonLibrary.sol\"  import \"../libraries/PermissionIdsLibrary.sol\"   CurveValidator  import \"../libraries/CommonLibrary.sol\"  import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"  import \"../interfaces/validators/IValidator.sol\";   ERC20Validator  import \"../libraries/CommonLibrary.sol\"   UniV2Validator and UniV3Validator  import \"../interfaces/validators/IValidator.sol\";  import \"../libraries/CommonLibrary.sol\"  import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"   AaveVault  import \"../interfaces/vaults/IVault.sol\"   AggregateVault  import \"../interfaces/vaults/IAggregateVault.sol\";  import \"../libraries/PermissionIdsLibrary.sol\"   ERC20RootVault  import \"../interfaces/utils/IContractMeta.sol\"  Code partially corrected:  The  unused  imports  have  been  removed  from  the  respective  contracts  for  all  examples  listed  above, except for the SafeERC20 import in the MStrategy.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.71   Wrong Check of Minimum Token Amounts in ", "body": " ERC20RootVault.withdraw  ERC20RootVault.withdraw  compares  the  token  amounts  a  user  wants  to  receive  at  minimum  with the  calculated  token  amounts,  but  not  the  token  amounts  that  are  actually  returned  after  pulling  from underlying Vault s. This could potentially result in the user receiving less tokens than anticipated.    The actual token amounts pulled from vaults are now validated against the minimum amounts provided by the user: `` require(actualTokenAmounts[i] >= minTokenAmounts[i],...);``  Mellow Finance - Mellow Vaults -   53  CorrectnessLowVersion1CodeCorrected          \f6.72   Wrong Specification for YearnVault.tvl  The specification in YearnVault mentions that YearnVault.tvl returns a cached value when in fact it does not.  Specification changed:  The  specification  has  been  updated  in  removed.    and  the  statement  about  the  cached  value  has  been  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.73   ContractRegistry DOS", "body": "  ContractRegistry.registerContract  checks  that  the  version  of  a  registered  contract  is  always increasing in:  require(newContractVersion > _latestVersion(newContractName), ExceptionsLibrary.INVARIANT);  If a contract is deployed with a version set to max uint, this would be the last contract possible to add to the system. No contracts could be added afterwards.    Mellow  Finance  introduced  major  and  minor  contract  version.  The  16  right  most  bytes  are  the  minor version and the remaining bytes to the right the major version. A require ensures that with each call to registerContract  with newContractVersionMajor - latestContractVersionMajor <= 1.  increase   version   major   only   can   the   by   1   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.74   ERC20Vault._pull Forces Push of Wrong", "body": " Amount of Tokens  In ERC20Vault._pull, if tokens are not pulled to the ERC20RootVault, the receiving Vault is forced to push the received tokens. The token amounts to be pushed are set in actualTokenAmounts, but this variable is never used. Instead tokenAmounts is used.    The  code  has  been  corrected  to  push  into  the  integration  vault  the  amounts  as  stored  in actualTokenAmounts.  Mellow Finance - Mellow Vaults -   54  CorrectnessLowVersion1Speci\ufb01cationChangedVersion3SecurityLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.75   IntegrationVault._root Does Not Check the NFT of the Root Vault  IntegrationVault._root  tries  to  verify  the  initialization  of  a  given  Vault  and  its  corresponding ERC20RootVault with the following code:  require(thisNft + thisOwnerNft != 0, ExceptionsLibrary.INIT);  If thisNft is set (greater than 0) and thisOwnerNft equals 0, no revert will happen. _root is called in pull  only.  pull  already  checks  that  the  argument  thisNft  given  to  _root  is  not  equal  to  0  which renders the require useless.    The  statement  was  changed  and  checks  each  variable  separately  (thisNft != 0) && (thisOwnerNft != 0).  if   it   is  zero   in  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.76   VaultGovernance.commitInternalParams", "body": "  Does Not Delete Staged Parameters  VaultGovernance.commitInternalParams  does  not  delete  the  _stagedInternalParams  state variable.    The state variable _stagedInternalParams is now deleted after it is applied.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.77   registry.ownerOf Is Called Twice in", "body": " IntegrationVault.pull  registry.ownerOf  is  called  twice  with  the  same  value  in  IntegrationVault.pull,  inducing unnecessary additional gas costs.    The obvious redundant call to registry.ownerOf was removed. Still, there would be another call in _isApprovedOrOwner.  Mellow Finance - Mellow Vaults -   55  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Approximated TVL for Aave Vaults", "body": "  The function AaveVault.tvl() computes an approximate total value locked (TVL) based on the time passed  since  the  parameter the  estimatedAaveAPY:  function  updateTvls  was  called  and   time   last   the   uint256 apy = IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().estimatedAaveAPY; factor = CommonLibrary.DENOMINATOR + FullMath.mulDiv(apy, timeElapsed, CommonLibrary.YEAR);  Note  that  the  parameter  estimatedAaveAPY  is  set  by  the  protocol  admin  for  all  tokens  of  the  vault, hence the function tvl might return incorrect values if updateTvls is not called frequently.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Balances Are Drained Faster in Vaults With", "body": " Lower Index  AggregateVault._pull pulls funds out of the underlying Vault's by pulling the maximum amount out of  each  Vault  sequentially.  This  drains  funds  faster  from  Vault's  depending  on  their  index  in  the _subvaultNfts state variable.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Deposits Can Be Blocked by Updating", "body": " StrategyParams  The function ERC20RootVaultGovernance.setStrategyParams does not perform any sanity check for the new parameters being set, hence if tokenLimitPerAddress or tokenLimit is set to zero, the functionality to deposit is blocked. The sanity checks are not enforced intentionally as the admin might use these parameters to block deposits into a root vault by updating these parameters.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Deprecated Function _setupRole", "body": "  DefaultAccessControl  and  DefaultAccessControlLateInit  use  the  function  _setupRole, which according to its specification is deprecated:  /**  * NOTE: This function is deprecated in favor of {_grantRole}.  */  Mellow Finance - Mellow Vaults -   56  NoteVersion4NoteVersion1NoteVersion1NoteVersion1              \f7.5   Duplicate Declaration of DENOMINATOR  Both MStrategy and LStrategy import CommonLibrary which declares the constant DENOMINATOR, however, they also declare the constant as well.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Dust LP Shares Are Burned", "body": "  If a user decides to redeem its LP shares in a root vault by calling the function withdraw, and if at the time of this action the amount of remaining LP shares represents less than the threshold existentials in underlying tokens, the whole user's LP balance is burned. Put shortly, the function prevents users from leaving dust amounts in LP shares when withdrawing.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   External Functions in ContractMeta", "body": "  ContractMeta  implements  external  pure  functions,  and  currently  they  are  called  only  by registerContract  in  ContractRegistry.  The  calls  are  performed  as  three  external  calls,  which increase gas costs, as there is no function in ContractMeta returning all values in a single external call.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   LP Tokens of the First Deposit Are Burned", "body": "  In  to address(0), practically burning them.   of the code base, the LP tokens of the first user depositing into a root vault are always send  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.9   Locked Token or ETH", "body": "  ERC20 tokens could be accidentally/intentionally sent to any contract. In such cases the tokens will be locked. Only externalCall for intergration vaults offers some functionality to recover funds.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.10   No Checks for Address to on ERC20Token", "body": " Transfer  The functions transfer and transferFrom in ERC20Token do not perform any sanity check for the address to, hence making it possible to burn tokens by sending them to address 0x0.  Mellow Finance - Mellow Vaults -   57  NoteVersion1NoteVersion6NoteVersion1NoteVersion6Version6NoteVersion1NoteVersion1                          \f7.11   Non Canonical Signatures  function   IntegrationVault.isValidSignature   The  function CommonLibrary.recoverSigner to validate signatures if the strategy is an externally owned account. Note  that,  the  function  recoverSigner  does  not  perform  any  sanity  check  on  values  r,  s  and  v  to ensure  that  only  unique  signatures  validate  successfully.  Therefore,  callers  of  this  function  should  be aware of possible attacks (https://swcregistry.io/docs/SWC-117).  library   uses   the   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.12   Non-indexed Event Topics", "body": "  Some  events  have  already  hit  in UnitPricesGovernance have not and do not index the token address. Given that the unit price update could be important to users, making the token address indexed, makes it easier to filter the events for specific tokens.  topics.  But   the  events   limit  of   indexed   three   the   There are some other events like DeployedVault in VaultGovernance, ReclaimTokens and Pull in  IntegrationVault  and  RebalancedUniV3  in  LStrategy  where  one  more  index  could  be  set. Additionally,  some  events  could  emit  the  nft  which  might  be  worth  indexing  (it  e.g.,  is  done  in SetStrategyParams). This is just noted and up to Mellow Finance to decide.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.13   OracleParams in MStrategy", "body": "  Te  admin  of  MStrategy  should  carefully  set  the  OracleParams.  The  admin  should  ensure  that  the Uniswap used for the oracle has enough observations to cover oracleObservationDelta, otherwise the  function  _getAverageTickChecked  called  in  _rebalanceTokens  will  only  use  the  spot  price, hence  making  the  rebalance  function  vulnerable  to  sandwich  attacks.  Additionally,  the  parameter maxTickDeviation should be carefully chosen to enforce proper slippage protection for the rebalance.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.14   Performance Fee Capped", "body": "  ERC20RootVault._chargePerformanceFees only charges performance fees for the strategy if the price of LP tokens has reached a new high score. When prices have fallen, the fees are still not charged even when prices climb again until this all-time high has been reached again.  Additionally, if all liquidity providers withdraw their funds and the totalSupply is zero, or all token TVLs are  less  than  _pullExistentials,  the  previous  high  score  lpPriceHighWaterMarkD18  is  not reset, hence performance fees might not be collected as expected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.15   Rebalance of Uniswap Vaults in LStrategy", "body": "  The  function  rebalanceUniV3Vaults  maintains  a  ratio  of  tokens  in  the  two  Uniswap  positions depending  on  the  move  of  the  current  price.  If  the  price  goes  up,  more  tokens  are  transferred  into  the upperVault from the lowerVault, and vice-versa. The function is designed in a way that it tries to add  Mellow Finance - Mellow Vaults -   58  NoteVersion4NoteVersion1NoteVersion5NoteVersion5NoteVersion4                  \fthe same liquidity amount into the destination vault that is removed from the other vault. However, since the two vaults operate in different price ranges, the same liquidity amount translates into different token amounts.  The  token  in  the  cash  position  (erc20Vault)  are  used  to  cover  for  the  difference. Consequently  the  ratio  between  the  cash  position  (erc20Vault)  and  the  money  vaults  (lowerVault and upperVault) is affected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.16   Rollback Individual Validators Not Possible", "body": "  ProtocolGovernance  implements  a  function  to  rollback  all  staged  validators,  but  there  is  no functionality to rollback individual staged validators.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.17   Special Behavior in ERC20Token", "body": "  The function transferFrom has a special behavior when allowance==type(uint256).max, as the allowance  is  never  reduced  when  these  transfers  occur.  This  special  behavior  should  be  properly documented as users should be aware of it.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.18   Trust Setup", "body": "  The  system  has  multiple  trusted  roles  and  heavily  relies  on  admin  operations  to  work.  E.g.,  setting oracles and the admin needs to maintain enough funds to open new Uniswap positions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.19   Uneven Gas Distribution on deposit and", "body": " withdraw  Fees are not calculated on every transaction. Therefore, some users are burdened with more gas costs than others depending on the time they are performing their withdraw and deposit actions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.20   Unit Prices Amounts", "body": "  The admin in UnitPricesGovernance can set the amounts of a given token that match the value of 1 USD. The prices are set with a delay of 14 days, hence the prices are not supposed to reflect the market price. Note that, for valuable tokens with few decimals, it might be impossible to store the correct token amount that matches 1 USD.  Mellow Finance - Mellow Vaults -   59  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion5                      \f7.21   Unnecessary Creation of Pair  In  UniV3Vault._push  and  UniV3Vault._pullUniV3Nft,  a  Pair  is  created  and  not  used  as  a Pair afterwards. Instead, the particular values are extracted from the Pair, rendering the creation of the Pair useless.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.22   ContractRegistry Functions Truncate", "body": " name  Functions  versions,  versionAddress  and  latestVersion  in  ContractRegistry  truncate  the input parameter name_ to 32 bytes:  bytes32 name = bytes32(bytes(name_));  If these functions are called with name_ longer than 32 bytes, the return value would be based on the truncated input parameter name_, which is inconsistent behavior.  Furthermore,  the  function  latestVersion  parses  the  input  parameter  name_  differently  from  other functions:  bytes32 name = bytes32(abi.encodePacked(name_));  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.23   LStrategy Needs Tokens to Create Uniswap", "body": " Positions  The  function  _mintNewNft  assumes  that  the  strategy  contract  has  enough  balance  to  open  new Uniswap positions as needed, otherwise new Uniswap NFTs cannot be minted:  IERC20(tokens[0]).safeApprove(address(positionManager), minToken0ForOpening); IERC20(tokens[1]).safeApprove(address(positionManager), minToken1ForOpening); (newNft, , , ) = positionManager.mint(     INonfungiblePositionManager.MintParams({         token0: tokens[0],         token1: tokens[1],         fee: poolFee,         tickLower: lowerTick,         tickUpper: upperTick,         amount0Desired: minToken0ForOpening, // required balance         amount1Desired: minToken1ForOpening, // required balance         amount0Min: 0,         amount1Min: 0,         recipient: address(this),         deadline: deadline     }) );  Mellow Finance - Mellow Vaults -   60  NoteVersion1NoteVersion1NoteVersion1          \fMellow  Finance  is  aware  of  this  requirement  and  states  they  will  take  care  that  enough  funds  are available at any point in time. Additionally, a check was added to ensure that the amount of token needed in the contract is very low (less than 10**9) to mitigate that money is lost because of the deactivated slippage protection in the function above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.24   _pullExistentials Are Unevenly", "body": " Distributed in Terms of Value  _pullExistentials  in  AggregateVault  are  set  to  10**(token.decimals()  /  2)  for  each token. This is an uneven distribution considering that tokens may have different value. The existential for USDT for example has a much lower value than the existential for WBTC.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.25   addressesByPermission Does Not", "body": " Consider Forced Permissions  The  function  addressesByPermission  in  the  protocol  governance  contract  returns  only  addresses that  explicitly  have  the  permissionId  in  the  mapping  permissionMasks.  However,  if  the permissionId  is  enforced  by  forceAllowMask,  then  all  addresses  are  assumed  to  have  the permission.  Mellow Finance - Mellow Vaults -   61  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Effects of Snapshotting at Every Block", "body": "  The HoprToken performs a state snapshot at every block. That has the following effects:  1. Significant extra gas costs for a token transfer compared to regular token implementations. Even if none  of  the  callbacks  are  executed,  there  is  an  expected  overhead  of  69,400  gas  compared  to  a regular ERC-20 token and 62,600 compared to a regular ERC-777 token.  Some addresses, e.g. HoprDistributor or exchange addresses will amass a considerable number of snapshots. This has two additional effects:  2. The overall contracts state size will be rather big. In case that ETH2.0 transitions to stateless clients,  state proofs will be relatively large for all Hopr balances.  3. The  gas  cost  of  calling  balanceOfAt  for  these  contracts  with  many  snapshots  will  continue  to grow.  However,  as  it  only  grows  logarithmically  it  will  foreseeably  not  reach  a  critical  level.  The impact  of  this  is  also  determined  by  whether  balanceOfAt  is  primarily  intended  for  on-chain  or off-chain use.  Risk accepted:  Hoprnet replied:  Due to our approach with our upcoming DAO contract, we require a snapshot on every block.  Hoprnet - Hoprnet Token -   7  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedDesignLowVersion1RiskAccepted             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Burn Function of HoprToken Can Cause Inconsistent Snapshot    Wrong Check in the HoprDistributor claim Function   -Severity Findings   Miners Can Claim With Schedule Violation   -Severity Findings   Multiple Storage Writes    Redundant Condition Check in _valueAt    Snapshot Inefficiency    Superfluous Call to _beforeTokenTransfer    Timestamp Conversion Has Redundant Operation   0  2  1  5  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Burn Function of HoprToken Can Cause", "body": " Inconsistent Snapshot  interface   The  ERC777  has  a  _beforeTokenTransfer  hook  that  is  called  in  the  burn,  transfer  and  mint functions. Also it introduced _callTokensToSend and _callTokensReceived functions that can call the  registry.  ERC777Snapshot  utilizes _beforeTokenTransfer  to  track  the  snapshots  after  each  balance  change.  Due  to  the  order  of _beforeTokenTransfer  and  _callTokensReceived  functions  in  the  _burn  function,  there  is  a possibility of reentrancy, that can cause the snapshots to be in an inconsistent state.  implementations   in  ERC1820   registered   function _burn(     address from,     uint256 amount,     bytes memory data,     bytes memory operatorData )     internal virtual {     require(from != address(0), \"ERC777: burn from the zero address\");      address operator = _msgSender();      _beforeTokenTransfer(operator, from, address(0), amount);  Hoprnet - Hoprnet Token -   8  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected        \f    _callTokensToSend(operator, from, address(0), amount, data, operatorData);      // Update state variables     _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");     _totalSupply = _totalSupply.sub(amount);      emit Burned(operator, from, amount, data, operatorData);     emit Transfer(from, address(0), amount); }  function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual override {     super._beforeTokenTransfer(operator, from, to, amount);      if (from == address(0)) {         // mint         updateValueAtNow(accountSnapshots[to], balanceOf(to).add(amount));         updateValueAtNow(totalSupplySnapshots, totalSupply().add(amount));     } else if (to == address(0)) {         // burn         updateValueAtNow(accountSnapshots[from], balanceOf(from).sub(amount));         updateValueAtNow(totalSupplySnapshots, totalSupply().sub(amount));     } else if (from != to) {         // transfer         updateValueAtNow(accountSnapshots[from], balanceOf(from).sub(amount));         updateValueAtNow(accountSnapshots[to], balanceOf(to).add(amount));     } }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1.1   Attack scenario", "body": " Attacker  can  register  a  IERC777Sender  smart  contract  in  the  ERC1820  registry  that  will  transfer  Hopr Tokens  to  the  attacker.  When  this  transfer  happens  in  the  _callTokensToSend  from  ERC1820 registered implementation, the snapshot will be overwritten again, using balanceOf value, that has not been yet updated.  In a trace example above, with green color marked balance updates and with yellow - snapshot updates. Due to dependency of snapshot updates depend on balance updates, the reentrancy issue arise. In the other  ERC777  functions,  such  as  the  transfer  function,  where  the  _callTokensToSend  goes  before any state updates, such a problem does not arise. To avoid the issue, the newly released OpenZeppelin contracts should be used.    Hoprnet - Hoprnet Token -   9  \fThe  HoprToken  now  uses  an  OpenZeppelin  ERC777  implementation  that  does  not  have  a  reentrancy vulnerability in its burn function. The snapshot is now updated after the external call.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Wrong Check in the HoprDistributor claim", "body": " Function  The  claim  function  of  the  HoprDistributor  calls  internal  _claim  function  that  contains  following code:  uint128 newClaimed = _addUint128(allocation.claimed, claimable); // Trying to claim more than allocated assert(claimable <= newClaimed);  This  assertion  can  only  be  violated  if  the  _addUint128  operation  overflows.  But  check  of  overflow  is already  present  the newClaimed  <=  allocation.amount.  The  comment  above  the  assertion  also  describes  the intention.  the  _addUint128.   there  are  no   In  addition,   checks   for   in     The assertion was rewritten. The new assertion checks that the value of newClaimed does not exceed the total allocated amount.  assert(newClaimed <= allocation.amount);  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Miners Can Claim With Schedule Violation", "body": "  The  claim  function  calls  the  _getClaimable  function  to  determine  the  amount  users  can  claim depending on the elapsed periods.  for (uint256 i = 0; i < schedule.durations.length; i++) {     uint128 scheduleDeadline = _addUint128(startTime, schedule.durations[i]);      // schedule deadline not passed, exiting     if (scheduleDeadline > _currentBlockTimestamp()) break;     // already claimed during this period, skipping     if (allocation.lastClaim > scheduleDeadline) continue;      claimable = _addUint128(claimable, _divUint128(_mulUint128(allocation.amount, schedule.percents[i]), MULTIPLIER)); }  At the end of claim execution, the allocation.lastClaim is reassigned, to disable repetitive claims for the same period of the schedule.  allocation.lastClaim = _currentBlockTimestamp();  But  if  multiple  claims  will  be  send  with  block.timestamp  equal  to  scheduleDeadline  of  some schedule  period,  multiple  repetitive  claims  of  this  blocks  will  be  possible.  This  will  effectively  allow  the hackers to ignore the schedule. While this operation is hard to time right using regular transaction, miners can craft such transactions.  Hoprnet - Hoprnet Token -   10  SecurityHighVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                \fCombined with nonexistent allocation.amount <= newClaimed check in claim function, this bug also allows to claim more than the allocated amount.    The condition in the loop was rewritten. Now the equality case will be skipped and repetitive claims for the same periods of the schedule are not possible.  if (allocation.lastClaim >= scheduleDeadline) continue;  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Multiple Storage Writes", "body": "  The  addAllocations  function  repeatedly  writes  to  and  reads  from  the  totalToBeMinted  storage variable. This incurs additional gas costs. Note, however, that the additional gas costs will be significantly lowered by the upcoming EIP-2929.    A new variable _totalToBeMinted was introduced. All repetitive operations are performed on it. Thus, gas is saved.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Redundant Condition Check in _valueAt", "body": "  The  functions  balanceOfAt  and  totalSupplyAt  of  the  HoprToken  have  following  branching conditions:  if (     (accountSnapshots[_owner].length == 0) ||     (accountSnapshots[_owner][0].fromBlock > _blockNumber) ) {  if (     (totalSupplySnapshots.length == 0) ||     (totalSupplySnapshots[0].fromBlock > _blockNumber) ) {  In addition, both of these public functions rely on internal _valueAt function. Meanwhile the _valueAt has following branching conditions:  if (snapshots.length == 0) return 0;  if (_block < snapshots[0].fromBlock) {  Those conditions are redundant and will never be triggered.  Hoprnet - Hoprnet Token -   11  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  The checks are now performed only inside the _valueAt function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Snapshot Inefficiency", "body": "  Hoprnet implemented the following binary search:  // Binary search of the value in the array     uint256 min = 0;     uint256 max = snapshots.length - 1;     while (max > min) {         uint256 mid = (max + min + 1) / 2;         if (snapshots[mid].fromBlock <= _block) {             min = mid;         } else {             max = mid - 1;         }     }     return snapshots[min].value;  In  case  the  _block  number  matches  the  block  number  of  one  of  the  snapshots,  the  implementation could be optimized. The equality case:  snapshots[mid].fromBlock == _block  is not handled explicitly. Given that in this case, the result has already been found, there is no need for further unnecessary iterations.  Code Corrected:  The code was adjusted and now explicitly checks for equality:  uint256 midSnapshotFrom = snapshots[mid].fromBlock; if (midSnapshotFrom == _block) {     return snapshots[mid].value;  Hence, the inefficiency is gone.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Superfluous Call to _beforeTokenTransfer", "body": "  When  overriding  the  empty  parent  function  _beforeTokenTransfer  from  the  ERC777  template, super._beforeTokenTransfer  gets  called.  This  call  has  no  effect  as  the  parent  is  empty.  Due  to current  state  of  Solidity  compiler,  this  call  will  create  unnecessary  operations  with  no  effects.  Small amount of gas (+-30) will be wasted.    Hoprnet - Hoprnet Token -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fThe superfluous call to the super class was removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Timestamp Conversion Has Redundant", "body": " Operation  Function  _currentBlockTimestamp  has  a  modulo  operation  that  can  be  dropped.  The  default behavior of solidity uint128(X) conversion achieves the same result and uses less gas.  function _currentBlockTimestamp() internal view returns (uint128) {     // solhint-disable-next-line     return uint128(block.timestamp % 2 ** 128); }    The superfluous modulo operation was removed.  Hoprnet - Hoprnet Token -   13  DesignLowVersion1CodeCorrected        \f7   Notes  We leverage this section to highlight potential pitfalls which are fairly common when working Distributed Ledger Technologies. As such technologies are still rather novel not all developers might yet be aware of these  pitfalls.  Hence,  the  mentioned  topics  serve  to  clarify  or  support  the  report,  but  do  not  require  a modification  inside  the  project.  Instead,  they  should  raise  awareness  in  order  to  improve  the  overall understanding for users and developers.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   ERC-20 Approve Race Condition", "body": "  The ERC-20 standard has a well-known race condition for the approve function if both the new and the implementations  add  increaseApproval  and old  approval  are  non-zero.  Hence,  a  decreaseApproval  functions  which  do  not  have  this  issue.  The  Hopr  Token  does  not  have  such functions. Hence, it is up to users and using smart contracts to avoid the issue.  lot   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Floating Pragma", "body": "  The solc version is fixed in the hardhat configuration to version 0.6.6. However, the files have a floating pragma.  Furthermore, please note the chosen compiler version 0.6.6 has five known bugs.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Ownership Cannot Be Atomically Transferred", "body": "  The specification says:  allow admin to transfer or revoke their ownership  There is no classical role transfer function inside the contract. The admin can add a new admin and later revoke itself, but not perform an atomic role transfer.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Schedules Are Specified Using UTF-8 Strings", "body": "  The distribution schedules are addressed using UTF-8 strings. UTF-8 strings have well-known security implications, such as characters that look identical to humans, but have a different byte representation or inverse character order. Hence, calls like addAllocations could theoretically be referencing a different schedule than expected.  However, as all of the functions setting up allocations can only be executed by the administrators, there is fairly low risk.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Theoretical Overflow in Binary Search", "body": "  Hoprnet - Hoprnet Token -   14  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \fIn theory the binary search can overflow. This would affect the following computation:  uint mid = (max + min + 1) / 2;  This  could  occur  as  soon  as  snapshots.length  would  be  larger  than  2**255.  As  this  implies  that 2**255 snapshots have been taken, which implies that 2**255 blocks have passed, it is irrelevant in practice.  Hoprnet - Hoprnet Token -   15  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Redundant While-loop", "body": "  curveLiquidityAdapter.__parseSpendAssetsForLendingCalls  aims  to  detect  the  spent assets  and  the  amounts  of  them  so  that  they  can  be  post-processed  by  the  Integration  Manager.  It includes the following while-loop which should always terminate after one iteration.  while (spendAssetsIndex < spendAssetsCount) {     for (uint256 i; i < _orderedOutgoingAssetAmounts.length; i++) {         if (_orderedOutgoingAssetAmounts[i] > 0) {             spendAssets_[spendAssetsIndex] = __castWrappedIfNativeAsset(                 canonicalPoolAssets[i]             );             spendAssetAmounts_[spendAssetsIndex] = _orderedOutgoingAssetAmounts[i];             spendAssetsIndex++;         }     } }  Notice  that  spendAssetsIndex  increases  to  the  maximum  value  of  spendAssetCount  inside  the for-loop.    The  while-loop  been  spendAssetsIndex == spendAssetsCount was added.  removed  while   has   an   early   exit   of   the   for-loop  when  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Unstaking sOHM Leaves Dust", "body": "  Avantgarde Finance - Sulu Extensions -   11  CriticalHighMediumLowCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fsOHM is a rebasing token, meaning that the number of tokens a vault has increases after each epoch. Sulu currently allows managers to define the number of sOHM tokens they want to unstake. Consider the following case:   A fund manager M wants to unstake all the sOHM the fund holds   The fund manager submits a transaction where they unstake the total amount of the tokens   A rebase happens and the number of sOHM increases   The transaction is mined.  This will lead to the fund holding a dusty amount of sOHM together with the unstaked OHM tokens.    The code has been adapted to support unstaking the maximum amount when uint.max is specified as the unstake amount.  Avantgarde Finance - Sulu Extensions -   12  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Rewards in Different Gauge Version", "body": "  CurveLiquidityAdapter is implemented in such a way so that it is compatible with version 2, 3 and 4 of  the  gauge  tokens.  When  claim_rewards  for  the  gauge  tokens  v2  and  v3,  rewards  are  accrued. However,  this  is  not  true  for  v4  where  users  should  pass  a  specific  argument  for  the  rewards  to  be accrued.  Avantgarde Finance - Sulu Extensions -   13  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Compound Rate normalizeAmount", "body": "  The normalizeAmount returns values that are greater or equal to target * decimals / rate, but still denormalizes to the same target value. For example, target 3, rate 123 and decimals 1000 yields 25. The true value, if computed in the domain of real numbers, would be 24.39. Thus, it can be expressed, for  some  cases.  Also, that  normalizeAmount(300)  deposits  of normalizeAmount(3)  ==  25.  This  has  that  depend  on CoumpoundRateKeeper.  is  few  effects  on   the  normalizeAmount  performs   than  the  systems,   rounding  up  of   the  smaller   2440  which   result   100   ==    Saving  _checkBalance  function  calls  can  fail  and  system  will  be  rendered  unusable.  This  can happen during the normal operation of the system. Saving contract users won't be able to deposit and withdraw funds from the contract. The rounding can effectively cause Denial of Service failure on this contract.   QVault _checkBalanceInvariant can fail for the same reason and render contract DoSed.   Saving contract can have not enough tokens to cover the deposits. Since all deposits are stored as normalized values and rounded up, all users get more tokens than they can claim from the system.   Saving contract rewards users with smaller deposits   BorrowingCore penalized the users, by rounding up their debt.   The BorrowingCore will collect more fees but users also will get less liquidation coins if fee is high  enough to cover both.  In addition, the update is done via a loop, that is not executed more than once, while according to fuzzing tests it never runs more than once for the domain of numbers that contract should work with.  Code partially corrected:  Q Blockchain - System contracts -   10  SecurityDesignCorrectnessTrustCriticalHighMediumLowCodePartiallyCorrectedDesignLowVersion1CodePartiallyCorrected            \fThe  ineffective  loop  was  removed  in  favor  of  simple  if  condition.  On  repetitive  deposit  to  the  same address  on  the  QVault  the  user  balance  loses  some  small  values  due  to  division  with  truncation  in denormalization  function.  This  loss  should  in  most  cases  compensate  the  gain  from  the  rounding  up. Overall all mentioned problems can be mitigated by some extra funds deposits. BorrowingCore behavior also while penalizing certain parties by tiny amounts, rewards the system health.  Q Blockchain - System contracts -   11    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  3  6  16  -Severity Findings  -Severity Findings  Inconsistent extendLocking Allows Multiple Votes    Multiple Votes by Delegation    Owner Not Initialized   -Severity Findings   Expired Slashing Proposals Are Not Purged    FxPriceFeed setExchangeRate Timestamp    Gas Heavy Operation on Foreign Chain   Inconsistent Liquidation Full Debt Due to Payback    Price Decimals and Token Decimals May Differ    ValidationRewardPools _updateCompoundRate   -Severity Findings   ASlashingEscrow Decision Reordering    Compiler Version Not Fixed and Outdated    ContractRegistry Erasing Key    Corruptible AddressStorageStakesSorted    FxPriceFeed Can Have No Maintainers    GSN Version String   Inconsistent Liquidation Full Debt Due to Outdated Debt   Inconsistent System Debt Auction Start Condition   Inefficient Code    Long pendingSlashingProposals Attack    QVault updateCompoundRate Precision Loss    Solc Pragma    Specification Mismatch    SystemSurplusAuction Bid Reentrancy    ValidationRewardProxy Allocate Potential Overflow    Validators Can Alter Delegator Share   Q Blockchain - System contracts -   12  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected       \f6.1   Inconsistent extendLocking Allows Multiple Votes  VotingWeightProxy.extendLocking only assigns _lockNeededUntil to lockedUntil[_who]. To  be  consistent,  it  should  be  the  max  between  the  new  and  the  old  value.  Otherwise  the  user  can manipulate the unlock times by voting on a proposal with smaller end time. In addition, the manipulation with unlock times enables user to transfer out the funds earlier and perform the attacks similar to on in Multiple Votes by Delegation, where users tokens can be reused to contribute to the same vote multiple times.    VotingWeightProxy.extendLocking now yields the max value between _lockNeededUntil and lockedUntil[_who].  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Multiple Votes by Delegation", "body": "  Upon  VotingWeightproxy.announceUnlock  and  VotingWeightproxy.unlock,  no  check  is done to verify that the voting agent is not currently locking the delegated amount. This enables an attack where it is possible to vote multiple times with the same Q.  Here is the attack scenario: A    and V   i  i   are accounts controlled by attacker.   : QVault.lock(X)  1. A  i 2. A   3. V  i 4. A   (no lock)    :  VWP.announceNewVotingAgent(V1)  and  VWP.setNewVotingAgent,  can  do  it  in  one  go i  because getLockeduntil will return 0 since A    did not vote  i   : vote on proposal, gets a lock on its own lockInfo   : QVault.announceUnlock(X) and QVault.unlock(X), can do it in one go since A  i   did not vote  i  5. A  i   : Qvault.transfer(A   , X)  i+1  6. goto 1. with i = i+1  Code corrected :  Lock time is now tracked only once per user, previously it was once per locking contract and per user. Now both announceUnlock and unlock now take into account the max time between user's own time lock and its voting agent's time lock, this mitigates the attack described above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Owner Not Initialized", "body": "  Some  contracts  inherit  Ownable  and  Initializable,  but  do  not  assign  the  owner  in  the  initialize function. If such contracts are deployed as a proxy, the owner field will be uninitialized (stays address 0) and owner functionality would be unusable.  Q Blockchain - System contracts -   13  CorrectnessHighVersion2CodeCorrectedDesignHighVersion1CodeCorrectedDesignHighVersion1CodeCorrected                      \f GSNPaymaster  inherits  Initializable  and  BasePaymaster.  BasePaymaster  inherits  Ownable. Function initialize of the GSNPaymaster only assigns value to stc field. The relayHub field can only be set by owner.   ForeignChainTokenBridgeAdminProxy does not set owner in initialize.   TokenBridgeAdminProxy  is  Initializable  and  Ownable.  Owner  is  not  initialized.  Also,  the  Ownable  functionality is not used anywhere.   ExpertsMembership does not initialize owner. Also, the Ownable functionality is not used anywhere.    Q Blockchain has done following fixes for the issues:   Function  initialize  was  removed  from  GSNPaymaster.  The  logic  from  it  was  moved  to  the  constructor.   Now the contract extends OwnableUpgradeable contract of openzeppelin library. The initialize  functions calls _Ownable_init, that sets the owner.   Now the contract extends OwnableUpgradeable contract of openzeppelin library. The initialize  functions calls _Ownable_init, that sets the owner.   Now the contract extends OwnableUpgradeable contract of openzeppelin library. The initialize  functions calls _Ownable_init, that sets the owner.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Expired Slashing Proposals Are Not Purged", "body": "  When  purgePendingSlashings  is  called  (Validators  and  Roots),  only  proposals  with  state REJECTED  or  EXECUTED  are  deleted.  The  proposals  with  state  EXPIRED  are  kept  the pendingSlashingProposals  list  and  their  slashing  amount  is  always  kept  into  account  when calculating the pending slashing amount. Thus, preventing the Roots and Validators to withdraw this amount that they should be able to withdraw, locking it forever.  in   Code corrected :  RootNodesSlashingVoting  and  ValidatorsSlashingVoting  now  define  slashingAffectsWithdrawal functions. The slashingAffectsWithdrawal function includes a check that slashing proposal is not in EXPIRED state.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   FxPriceFeed setExchangeRate Timestamp", "body": "  The  exchange  rate  on  FxPriceFeed  is  set  by  setExchangeRate  function  and  recorded  timestamp  is taken from the block. Since the transactions can be delayed and reordered or put to the chain earlier than needed,  the  rate  can  be  outdated  by  the  time  the  block  is  mined.  The  recorded  timestamp  can  give unreliable information about the rate status. Some approaches, like Maker price oracles, ensure that new price  values  propagated  from  the  Oracles  are  not  taken  up  by  the  system  until  a  specified  delay  has passed.  Q Blockchain - System contracts -   14  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  Field pricingTime was added to the FxPriceFeed contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Gas Heavy Operation on Foreign Chain", "body": "  ForeignChainTokenBridgeAdminProxy is supposed to be deployed on the Ethereum mainnet, thus its  gas  consumption  is  critical.  The  current  complexity  of  the  updateTokenbridgeValidators  is actually O(m*n), where m is length of old list and n is length of new list. Complexity can be reduced to O(m+n)  if  all  old  values  in  list  were  replaced  by  new  list  values.  Also,  the  number  of  calls  to  other contracts should be minimized. Currently, a lot of calls to bridgeValidators contract are done.  Specification corrected:  Q  Blockchain  wants  to  use  IBridgeValidators  interface  implementation  as  it  is  without  any modifications,  since  it  allows  them  easier  integration  with  existing  tokenbridge  code.  With  this requirement, current solution is sufficient. In addition, the O(m*n) complexity loop is done to lower the number  of  calls  between  ForeignChainTokenBridgeAdminProxy  and  IBridgeValidators contracts. According to Q Blockchain tests, this lowers the overall gas consumption.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Inconsistent Liquidation Full Debt Due to", "body": " Payback  Owner  of  the  Vault  that  is  being  liquidated  can  call  payBackStc  and  repay  STC  after  the  liquidation process has started. This can lead to potential problematic scenario:  Collateralization ratio = 150% Liquidation ratio = 125% Liquidation fee = 2%  1. Vault owner has for 150 worth of collateral and 100 worth of STC.  2. Collateral value drops to 120, liquidation is opened with liquidationFullDebt = 100. At that  point the fee should be 2. Highest bid is 105.  3. Vault  owner  pays  back  some  its  debt  over  liquidation  ratio,  so  now  the  vault  has  for  120  worth  of collateral  and  88  worth  of  STC.  Vault  owner  cannot  call  liquidate  because  the  liquidation  ratio does not allow this.  4. Liquidation  is  executed,  liquidationFullDebt  is  still  100  but  should  be  88  by  now.  After liquidation, liquidator got his 120 worth of collateral token, system had its fee of 2 and user only got 105 - (100 + 2) = 3. So, in the end vault owner has lost more STC than what he should have with the liquidation.  System  would  also  burn  more  STC  the liquidationFullDebt that should have changed due to payback.  than  needed,  compensating   token   Code corrected :  A modifier has been added to prohibit debt payback when vault is being liquidated.  Q Blockchain - System contracts -   15  DesignMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                  \f6.8   Price Decimals and Token Decimals May Differ  When computing the collateralization ratio in BorrowingCore the formula uses the price from the oracle along with the decimals of the collateral. It is an issue because there is no guarantee that the oracle price will  have  the  same  decimals  as  the  associated  collateral.  The  decimalPlaces  of  the  FxPriceFeed should be used instead.    Instead  of  using  getDecimals,  Q  Blockchain  uses  decimalPlaces  in  BorrowingCore  in  functions _getColRatio and getVaultStats.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   ValidationRewardPools ", "body": " _updateCompoundRate  In attempt to improve the precision, the _updateCompoundRate tries to update the compound rate of rate  keeper  with  balance  -  reservedForClaim  -  1  tokens.  Then, the  validator  denormalize(newRate,  stake)  -  denormalize(oldRate,  stake)  +  1  tokens  are  be  used to increase the reservedForClaim variable.  Assume  following  starting  point  of  the  system:  oldRate  ==  1  stake  ==  200  balance  ==  400 reservedForClaim == 0  to   integer  division   The  _updateCompoundRate  will  update  the  compound  rate  keeper  with  400-0-1  ==  399  amount. Due  for reservedForClaim will be 400-200+1==201. But the stakers would be able to get only 200 tokens out from this update. This 1 token difference will not be claimable by anyone and such discrepancies will be slowly accumulating the ValidationRewardPools system.  the  newRate  will  be  2.  New  value   truncation  of   the  result,   If compound rate was updated with balance - reservedForClaim == 400 tokens, newRate would be  3  and  denormalize(newRate,  stake)  -  denormalize(oldRate,  stake)==400  could have been distributed. reservedForClaim would have become 400 too.  If balance where == 200, the balance - reservedForClaim - 1 would be 199, that is not enough to increase the rate. Meanwhile the solution without the -1 would have increased the rate by 1.  To  conclude,  the  balance  -  reservedForClaim  -  1  _updateCompoundRate  algorithm  slowly accumulates  the  errors  and  delays  in  some  cases  the  distribution  of  the  tokens.  With  time  the accumulated errors can drive the denormalized stake and reservedForClaim values more apart and can prevent the payout of the rewards, since the reservedForClaim values will be greater than they should have been, if computation were done in the domain of real numbers.    sub(1)   add(1)   method The  reserveAdditionalFunds(address  _validator)  that  increases  the  validators  balance  and reservedForClaims  fields  by  the  transferred  value  was  added.  It  allows  to  compensate  for  rounding  up errors if they occur. Since the accumulation error speed is not higher then number of delegators * number of updates 1 extra Q token with 18 decimals should compensate error for quite awhile.  approach   dropped.   Payable   was   Q Blockchain - System contracts -   16  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected              \f6.10   ASlashingEscrow Decision Reordering  The  proposeDecision  and  recallProposedDecision  can  be  called  numerous  times  on ASlashingEscrow.  Roots  that  want  to  confirmDecision  cannot  be  sure  what  decision  they  are confirming  and condition  recallProposedDecision/proposeDecision.  Since  the  order  of  those  transactions  can  vary, pending decision might be changed by the time confirmation arrives.  confirmDecision   between   race   due   the   to     The  confirmDecision  function  takes  extra  decision  hash  argument,  that  solves  the  problem  with reordering.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Compiler Version Not Fixed and Outdated", "body": "  The  solidity  compiler  truffle-config.js to be 0.7.6.  is  not   fixed   in   the  code.  The  version,  however,   is  defined   in   the  In the code the following pragma directives are used:  pragma solidity ^0.7.0;  Known bugs in version 0.7.6 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1509  More information about these bugs can be found here:  https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.7 which contains some bugfixes.  Code correct :  Solidity compiler version has been fixed to 0.7.6 in every file, this this the last version before breaking changes of version 0.8.0.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   ContractRegistry Erasing Key", "body": "  Any given string key for address cannot be purged from ContractRegistry. Function contains always checks that address != 0. But _setAddress function does not allow address to be 0. Thus, unused key address  will  always  be  contained  by  this  contract.  There  is  no  dedicated  function  for  purging  the addresses. In addition, keys are pushed to the storage keys array, but never can be deleted.    Q Blockchain - System contracts -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fFunctions removeKey and removeKeys were added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Corruptible AddressStorageStakesSorted", "body": "  AddressStorageStakesSorted contract uses linked list to manage the sorted stakes of addresses. Linked list implementation relies on HEAD==address(0) and TAIL==address(1) constants It is possible to inject  HEAD  or  TAIL  wherever  in  the  linked  list,  allowing  the  owner  to  manipulate  the  order  of  the elements.  The  issue  severity  is  limited,  because  only  the  Validators.sol  contract  is  using  the AddressStorageStakesSorted and only message senders can add themselves to this list. However, if the contract is used in another way than the Validators.sol contract does, the corruption of the sorted linked list could lead to severe issues.  Code correct :  A check that prohibits HEAD or TAIL to be added in the list has been added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   FxPriceFeed Can Have No Maintainers", "body": "  Function  leaveMaintainers  in  FxPriceFeed  contract  does  not  check  that  there  are  left  maintainers after the execution of this function. ContractRegistry performs such check in the same function.    Check was added similar to ContractRegistry, that prevents the last maintainer from leaving.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   GSN Version String", "body": "  Versions  of  contracts  that  enable  the  GSN  functionality  should  reference  the  GSN  version  used  2.2.2. Currently  the  returned  version  strings  are  not  correct.  While  there  are  no  consequences  on  smart contract level (versions are not checked), the font end libs can have problems with compatibility.   StableCoin.versionRecipient returns \"0.0.1\"   GSNPaymaster.versionPaymaster returns \"0.0.1\"  Code corrected :  The  GSNPaymaster.versionPaymaster is 2.2.0 now.  returned   version   by   StableCoin.versionRecipient   and  Q Blockchain - System contracts -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                          \f6.16   Inconsistent Liquidation Full Debt Due to Outdated Debt  BorrowingCore vault liquidationFullDebt value is updated every time the liquidated function is called.  This  function  can  be  called  by  anyone  and  LiquidationAuction  calls  is  once  during  the startAuction. Nothing prevents the liquidated, as long as the vault is still undercollateralized. But there  is  no  incentive  to  do  so  for  anyone.  In  addition,  the  liquidationFullDebt  saved  in  the beginning of the liquidation will be smaller than the up-to-date value of debt. The collateral interest rate grows  constantly  and  actual  debt  at  than liquidationFullDebt. The difference depends on duration of liquidation auction and interest rate on collateral. All values that depend on liquidationFullDebt will be affected by this discrepancy. For example, the liquidation fee that is defined as a percent of liquidationFullDebt will be smaller than needed and thus, the generated surplus of the system will be smaller than defined %.  the  end  of  Auction  execution  will  be  higher     The liquidate function cannot be called when liquidated. Thus, the liquidationFullDebt cannot be  updated,  once  it  is  set.  The  collateral  interest  rate  growth  won't  affect  the  debt  and  according  to  Q Blockchain, it is intended behavior.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   Inconsistent System Debt Auction Start", "body": " Condition  From SystemBalance.getBalanceDetails, auction can begin if  systemBalance.getDebt() >= _params.getUint(stc.debtThreshold())  In SystemDebtAuction.startAuction, auction can begin if  _systemBalance.getDebt() > _params.getUint(stc.debtThreshold())  Note >= vs > difference.  Code corrected :  Both conditions are now strict inequality >.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.18   Inefficient Code", "body": "  Some code has no effect, is redundant, or simply inefficient. Removing or changing it can increase code readability and save some gas as well.  Examples  Q Blockchain - System contracts -   19  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f AddressStorage.mustRemove/mustAdd  :AddressStorage.remove/add  already  has  the  onlyOwner modifier   AddressStorage.size()  :  array.length  has  already  type  uint256,  further  casting  to  uint256 has no effect   AddressStorageStakesStore.updateStake(): addrStake[_addr] = _stake; should be moved after the if(_stake==0){} block, otherwise on a 0 stake contract will write 0 in the slot, then delete the entry.   EmergencyUpdateVoting._vote() : the first two require statements check the same property  and have different error messages   QVault.withdrawTo() : the check for user balance is already done in _subFromBalance   QVault._subFromBalance() : upon _targetBalance computation, the SafeMath library not  needed, the check for _amount <= balanceOf(_owner) has already been done   QVault._subFromBalance() : balanceOf is called 3 times, while the result can be queried only  once and later stored in memory variable.   ValidationRewardProxy.PayInformation : this struct contains bool ok, which is assigned  once but never used or returned   ASlashingEscrow.Decision,   SystemSurplusAuction.AuctionInfo,  SystemBalance.SystemBalanceDetails : those structs can be optimized for tight packing   Validators   if   currentWithdrawal.amount   is   0,   the   entry  validatorsInfos[msg.sender].withdrawal is first deleted and then reinitialized again.   RootsVoting._equals() : function is never used   SystemSurplus.bid()   :   _auction   is   already   in   storage,   rewriting   it   to  auctions[_auctionId] is not needed and gas heavy   SystemBalance.getBalanceDetails()  :  a  condition  evaluation  can  be  saved  on  average  by  writing this block in a if - else if - else style, with the most validated condition first   SystemDebtAuction.execute() : call to _checkBalances has no effect since auction status is  now CLOSED   TokenBridgeAdminProxy : is Ownable but the functionality is never used   VotingWeightProxy.extendLocking()  :  the  loop  may  update  lockInfo.lockedUntil  for each  tokenLockSource  every  time  it  is  called.  So,  every  source  will  have  the  same  value  for  their lockInfo.lockedUntil, a unique lockedUntil per user would be more gas efficient   FxPriceFeed can have fields defined as immutable.   CompoundRateKeeperFactory and AddressStorageFactory can deploy minimal proxies for  implementations and not the complete contract.     The redundant check is removed from AddressStorage.mustRemove/mustAdd   Redundant casting removed   The _stake == 0 is handled properly now.   The redundant check was removed.   The redundant check was removed.   The redundant calls were removed.   The ok field was removed from struct.  Q Blockchain - System contracts -   20  \f The field definitions were rearranged, to profit from tight packing.   The deletion was removed.   RootsVoting._equals() is removed.   The redundant rewrite was removed.   The conditions were rewritten in more optimal way.   _checkBalances was moved to the beginning of SystemDebtAuction.execute() function.   _checkBalances was moved to the beginning of SystemDebtAuction.execute() function.   fallback function is onlyOwner now.   The loop was removed.   State variables that could be immutable are now immutable   Proxies are used for the implementations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   Long pendingSlashingProposals Attack", "body": "  Malicious root can create numerous proposals on ValidatorsSlashingVoting or RootNodesSlashingVoting and  make  pendingSlashingProposals  entries  on  Validators  or  Roots  too  long  for  gas  limit  to  be executed. This will brake withdrawal functionality on those contracts for a given Root/Validator. Since the root is trusted role, the chance of such attack is considered low.  Code corrected :  Check  RootNodesSlashingVoting and ValidatorsSlashingVoting upon createProposal.  for  already  pending  slashing  proposal  pair   (victim,  proposer)  has  been  added   in  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   QVault updateCompoundRate Precision", "body": " Loss  Following computations are performed in the updateCompoundRate function of the QVault:  uint256 _accruedReward = aggregatedNormalizedBalance.mul(_newRate.sub(_oldRate)).div(getDecimal()); IQHolderRewardPool(registry.mustGetAddress(\"tokeneconomics.qHolderRewardPool\")).requestRewardTransfer(     _accruedReward );  The resulted _accruedReward variable will have more error, then the difference of two denormalized values, calculated with different rates. The requested reward will be smaller due to the integer division truncation  error.  With  time,  the  error  can  accumulate  and  break  invariant  of  the  contract.  In  addition, _checkBalanceInvariant is not performed after the updateCompoundRate.  Code corrected :  The Q Blockchain provided following fixes:   call _checkBalanceInvariant at the end of updateCompoundRate  Q Blockchain - System contracts -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f change calculation of _accruedReward to our standard pattern:   denormalize aggregated balance with old rate   update compound rate   denormalize aggregated balance with new rate   _accruedReward must be the diff between the two  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.21   Solc Pragma", "body": "  pragma   contract   Current  compiler: pragma solidity ^0.7.0; Contracts should be deployed with the same compiler version and flags that  they  have  been  tested  the  most  with.  Locking  the  pragma  helps  ensure  that  contracts  do  not accidentally  get  deployed  using,  for  example,  the  latest  compiler  which  may  have  higher  risks  of undiscovered bugs.  quite  many   directive   versions   permits   the   of     Solidity  pragma  is  set  to  fixed  0.7.6  for  all  Smart  Contracts.  This  is  the  latest  version  of  Solidity  0.7 major version compiler.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.22   Specification Mismatch", "body": "  Code does not match with the specification.  Examples:  1. AddressStorageStakes.add()  address  _addr   :  stake   spec  be   @param  @param _stake amount of decreasing but it should be increase instead of decrease  decreased   whose   will   says and  2. AddressStorageStakes.sub()  :  data.stake  >=  _stake  check  does  not  match  with  the  error message  3. FxPriceFeed : @title Root nodes voting is wrong  4. BorrowingCore.withdrawCol()   : userVaults[msg.sender][_vaultId].colAsset > _amount check does not match with the error message  5. QHolderRewardPool.requestRewardTransfer() : return specs to not match with code, there is no _unsatisfyableClaims and if the amount is too big, call just reverts and does not return 0.  6. SystemBalance.increaseDebt() : PDF documentation says only liquidation auction and saving should  be  allowed  to  increase  debt.  Eligible  contracts  are  not  fixed,  could  be  more  contracts  than those two  7. ConstitutionVoting.shouldExist()   says @dev  Internally  counts  the  vetos  percentage  but  modifier  only  checks  for  proposal existence  spec   :   8. VotingWeightProxy.announceUnlock()  :  spec  says  function  should  throw  error  028002  if  _amount = 0 but no check is done  Q Blockchain - System contracts -   22  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f9. VotingWeightProxy.unlock()  :  spec  says  we  can  only  unlock  previously  announced  amount  via announceUnlock, but it is possible to unlock more than announced  Code corrected :  1. specs updated  2. error message updated  3. specs updated  4. error message updated  5. specs updated  6. new modifier has been added to check for LiquidationAuction and Saving  7. specs updated  8. specs updated  9. specs updated  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.23   SystemSurplusAuction Bid Reentrancy", "body": "  Function  bid  in  SystemSurplusAuction  calls  PushPaymaster.safeTransferTo  to  bidder  address. After  the  call  some  _auction  storage  variable  is  reassigned.  While  PushPaymaster  call  has  a  limited 30000 gas, this can be still enough for reentrancy. Reordering of call and storage assignments can close this potential vulnerability.    The  order  of  operations  was  PushPaymaster.safeTransferTo call.  changed.  No   storage   reads/writes  happen  after   the  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.24   ValidationRewardProxy Allocate Potential", "body": " Overflow  The allocate function has following computations:  p.delegatorReward = p.balance.mul(shortList[i].amount).mul(p.qsv).div(p.totalStake).div(decimal); p.validatorReward = p.balance.mul(shortList[i].amount).mul(decimal.sub(p.qsv)).div(p.totalStake).div(decimal);  The max value for uint256 is close to 10^77. Balance has 18 decimals, amount 18 decimals as well. The qsv or decimal-qsv is a value of 10^27 magnitude. Overall it makes 10^63 just for decimals calculations. Keeping in mind the potential big values for shortList amounts and distributed p.balance, the overflow can occur and block all Validator reward payouts from execution.  Code corrected :  Q Blockchain - System contracts -   23  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fComputation that are prone to intermediate overflows are now done using the function mulDiv of library FullMath from Uniswap V3.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.25   Validators Can Alter Delegator Share", "body": "  The setDelegatorsShare function of ValidationRewardPools allows validators to set a percent, that will go to delegators from the rewards that validator can get. This action can be done without any time constraints and prior announcement. Validator can even sandwich the call to rewards distribution function between  two  setDelegatorsShare  calls  that  will  result  in  harder  to  notice  of  lowering  the  profits  of delegators.  Code corrected :  Q Blockchain added event DelegatorsShareChanged that allows users to easily identify misbehaving validators. The own stake of validator is much higher than the potential profit from reward distribution and since the own stake can be slashed for misbehavior, the issue is considered as resolved.  Q Blockchain - System contracts -   24  TrustLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Constructor and Initializer", "body": "  Some  contracts,  e.g.  AddressStorage  defines  both  constructor  and  function  initialize.  Quite  often developers  duplicate  the  logics  of  initialize  inside  constructor  and  define  constructor  itself  with initializer  modifier.  In  your  case  you  don't  do  it,  but  the  creation  and  initialization  of  such  contracts  is consistent and done in a safe way. We wanted to let you know that the current pattern can easily lead to issues, if contract will be used directly without proxy and without proper initialization. The contracts that will serve as implementations for Factories also should be properly initialized, to prevent the undesired state modifications on it.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   DefaultAllocationProxy Allocate", "body": "  The design of allocate function in DefaultAllocationProxy contract has aspect that is worth mentioning: The  failure  of  any  beneficiary  fallback  logic  will  force  the  entire  allocation  procedure  to  fail.  In  current implementation version only the QHolderRewardProxy has any logic in its receive function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Plain Strings as Keys", "body": "  The use of plain strings as access keys for the registry across the code base is error prone. It could lead to mistyping one of the keys, can make a contract unusable. A less error prone solution would be to store those string keys as globally available constants.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Proxy Tests", "body": "  The  truffle  tests  concerning  proxies  should  be  extended.  In  the  current  state,  the  proxies  are  just deployed,  but  never  used.  Tests  should  be  done  with  real  proxies,  issues  like  the  one  concerning  the ownership could have been detected then.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Roots Function _addStake Check", "body": "  The check needs to check the _amount value. In current implementation this causes no problems, but can lead to bug if functionality changes.  require(msg.value > 0, \"[QEC-002012]-Additional stake must not be zero.\");  Q Blockchain - System contracts -   25  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \f7.6   SlashingEscrow PENDING After appealEndTime  The  ASlashingEscrow's  state  machine  can  stays  PENDING  on  an  arbitration  decision  if  not  enough RootNodes  confirm  the  decision.  If  a  decision  on  a  casted  objection  does  not  receive  enough confirmations,  it  stays  on  PENDING  state,  event  after  the  appealEndTime.  So  as  long  as  not  enough RootNodes have confirmed the decision, the slashed amount is kept in the slashing escrow, that could mean pure loss for the validator, the slashing proposer and the system reserve if the arbitration is never decided.  The  Q  Blockchain  team  confirmed,  that  root  nodes  are  incentivized  to  vote.  Thus  every  vote  on SlashingEscrow should eventually be decided.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   System Compatibility With External Tokens", "body": "  While  systems  contracts  operate  properly  with  good  behaving  ERC20  tokens,  some  odd  tokens  can cause  potential  problems  in  the  system.  For  example,  the  BorrowingCore  getting  collateral  with collateral.transferFrom(msg.sender,  address(this),  _amount)  and  _amount  is retained  for  accounting.  This  behavior  does  not  tolerate  tokens  with  fees.  If  a  collateral  is  a  token  that allows fees upon transfer, the real amount received by the BorrowingCore will be less than _amount and the system could end up undercollateralized without noticing it. Similarly, the rounding errors in QVault transfers can lead to smaller received values on the BorrowingCore side. Thus, QVault cannot be used as  a  collateral  inside  BorrowingCore  without  code  adjustments.  In  addition,  on  Ethereum  some  tokens don't always return values on transfer/transferFrom or approvals. Some tokens have unusual number of decimals  (too  big  or  too  small).  Allowing  the  system  to  manipulate  any  external  token  should  be  done with a great care.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Total Q Supply Assumption Source", "body": "  the   amount, Upon  (block.number.mul(15)).add(10000000000).mul(1  ether)  is  copy-pasted  as-is  four  times. Having  system  parameters  defined  in  different  sources  is  error  prone  and  can  complicate  the upgradability of the system contracts.  computation   circulating   total   of   Q   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.9   Unchecked Function Return Values", "body": "  Some of the calls to known functions are not checked, mainly calls to AddressStorage.  Examples :   QVault.delegateStake : return value of _newDelegations.add(_delegationAddr); is not  checked  Q Blockchain - System contracts -   26  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f AExertsMembership.add/remove/swapMember : return values of the interactions with the list  of experts are not checked   QVault _addToBalance and _subFromBalance functions return bool that are never used  While this might be intended, this uses more gas.  Q Blockchain - System contracts -   27  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Conversion Errors When Computing", "body": " Underlying Graph Token Value  Each delegation contains two values relevant for the totally managed assets per indexer: the delegated amount denominated in shares and the locked amount denominated in The Graph tokens. To compute the  value  in  The  Graph  tokens  assigned  currently  to  an  indexer  pool,  getDelegationGrtValue() implements the following logic:  (uint256 delegationShares, uint256 tokensLocked, ) = GRAPH_STAKING_CONTRACT.getDelegation(     _indexer,     address(this) ); (, , , , uint256 poolShares, uint256 poolTokens) = GRAPH_STAKING_CONTRACT.delegationPools(     _indexer ); if (delegationShares > 0) {     return delegationShares.mul(poolTokens).div(poolShares).add(tokensLocked); } return tokensLocked;  Note, however, that the view function delegationPools returns the following struct:  struct DelegationPool {     uint32 cooldownBlocks; // Blocks to wait before updating parameters     uint32 indexingRewardCut; // in PPM     uint32 queryFeeCut; // in PPM  Avantgarde Finance - Sulu Extensions IV -   15  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected         \f    uint256 updatedAtBlock; // Block when the pool was last updated     uint256 tokens; // Total tokens as pool reserves     uint256 shares; // Total shares minted in the pool     mapping(address => Delegation) delegators; // Mapping of delegator => Delegation }  The poolShares return value corresponds to the tokens value in the struct (similar for poolTokens). Hence, the return values are not used correctly when delegationShares > 0 holds since the shares' value in GRT will be computed with the inverse of the actual exchange rate.  The  tests  leave  this  issue  undiscovered  since  for  the  delegation  pool  used  in  the  test  case  tokens equals shares which hides the issue.  Ultimately, getManagedAssets() will incorrectly estimate the position.    The  poolTokens  and  poolShares  values  are  now  delegationPools.  retrieved   in   the  correct  order   from  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Incorrect Argument Order for lowerHint and", "body": " upperHint  In  LiquityDebtPositionLib.sol,  the  order  in  which  the  lowerHint  and  upperHint  arguments are passed is incorrect in several locations.  This includes private calls (from receiveCallFromVault to the action in question), external calls (from the action to ILiquityBorrowerOperations). Furthermore, there are mix-ups in the tests as well.  Passing the hints in the wrong order generally does not result in the call to Liquity to fail. However, as the hint is unusable, the execution spends more gas to find the right location.  Below  is  a  summary  of  whether  these  function  calls  are  made  with  a  correct  argument  order  for  each action within the smart contract:   __openTrove:   Private call: Incorrect   External call: Incorrect   __addCollateral:   Private call: Correct   External call: Incorrect   __removeCollateral:   Private call: Correct   External call: Incorrect   __borrow:   Private call: Incorrect   External call: Correct  Avantgarde Finance - Sulu Extensions IV -   16  CorrectnessMediumVersion1CodeCorrected        \f __repayBorrow:   Private call: Incorrect   External call: Correct  The  convention  that  Liquity  seems  to  follow  is  to  pass  upperHint  before  lowerHint.  In  Liquity's SortedTroves.sol, a different naming (_prevId and __nextID) is used. Since troves are sorted in descending order, _prevId actually corresponds to upperHint. This is inconsistent with how hints are interpreted/named  in  LiquityDebtPosition.test.ts.  In  some  test  cases  hints  are  in  switched  as well.  One example is the implementation and the test case for repayBorrow: The arguments are switched in the smart contract code and in the corresponding test. Two wrongs make a right and the hints are passed correctly.  When an uneven number of such mistakes are made, the hints are useless and the gas consumption of the call increases.  After  switching  all  the  hints  arguments  in  the  tests,  the  gas  consumption  of  the  above  actions  is  as follows:   __openTrove: Higher (761598 vs. 748240)   __addCollateral: Higher (516155 vs. 417178)   __removeCollateral: Lower (549037 vs. 562395)   __borrow: Lower (1181526 vs. 1194884)   __repayBorrow: Higher (490531 vs. 391554)  Overall, the arguments upperHint and lowerHint should be rechecked and corrected everywhere to ensure useful hints are passed to Liquity and gas used is minimized.    Hints  are  now  always  passed  in  the  same  order,  i.e.,  upperHint,  lowerHint.  The  code  was  also improved to more explicitly identify these two arguments. Furthermore, the tests were updated to use a collateralization  ratio  that  will  avoid  placing  the  trove  at  an  extremity  of  the  sorted  list  to  validate  the correct passing of hints.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Liquity: Lack of Support for ", "body": " claimCollateral()  The technical documentation of Liquity writes the following:  claimCollateral(address _user): when a borrower\u2019s Trove has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio above 110%, this function allows the borrower to claim their ETH collateral surplus that remains in the system (collateral - debt upon redemption; collateral - 110% of the debt upon liquidation).  However,  the  Liquity  position  library  does  not  support  such  an  action.  Hence,  it  could  be  possible  that funds could become stuck in some situations (e.g. liquidations in recovery mode).  Avantgarde Finance - Sulu Extensions IV -   17  DesignMediumVersion1CodeCorrected        \f  The  issue  has  been  resolved  by  adding  a  ClaimCollateral  action  and  including  the  unclaimed collateral in the valuation.  Note:  Note that this issue has been inadvertently included in another report previously.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Lending Pools Array Read Twice From", "body": " Storage in getManagedAssets  In  MapleLiquidityPositionLib.getManagedAssets()  the  length  of  the  used  lending  pools  is queried by copying the full array from storage into memory. Next, the for loop iterates over the array and reads  the  elements  from  storage.  Hence,  gas  consumption  could  be  reduced  by  caching  the  array  in memory.    The pools are now cached into memory and no longer read from storage repeatedly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Pool Owner Could Change", "body": "  To  prevent  the  manipulation  of  a  pool,  reentrancy  is  checked  through  the  withdraw_admin_fees function of the pool owner contract. However, the pool owner address could change and hence such calls on the pool could fail not due to reentrancy but due to access control. The price feed stores the address as  an  immutable  and,  thus,  could  become  unusable  in  the  aforementioned  scenario  of  changing ownerships.    The pool owner address is not immutable anymore. Now, it can be changed by governance.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   LendAndStake Stakes the Full Balance", "body": "  LendAndStake  is  an  action  wrapping  the  lending  and  the  staking  action.  First,  it  lends  an  amount  of liquidity  assets  to  the  Maple  pool.  Next,  it  stakes  LP  tokens  to  the  rewards  contract  to  get  some  extra rewards:  function __lendAndStakeAction(bytes memory _actionArgs) private {     (         address pool,         address rewardsContract,         uint256 liquidityAssetAmount     ) = __decodeLendAndStakeActionArgs(_actionArgs);  Avantgarde Finance - Sulu Extensions IV -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f    __lend(IMaplePool(pool).liquidityAsset(), pool, liquidityAssetAmount);     __stake(rewardsContract, pool, ERC20(pool).balanceOf(address(this))); }  The argument passed to the internal __stake function is the full balance of the pool token. Note that it is also possible to lend the underlying without staking. Consider now the following scenario:  1. 100 tokens are lent into the pool. 100 LP tokens are received.  2. Later, lend and stake is used with 100 underlying tokens.  3. The full balance, namely 200 LP tokens, will be staked.  Such behavior could be unexpected for fund managers.    The code of __lendAndStakeAction() has been changed and now only stakes the amount of tokens received.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   __curveGaugeV2GetRewardsTokensWithCrv", "body": "  Is Unused  The internal function __curveGaugeV2GetRewardsTokensWithCrv is unused and could be removed to reduce deployment cost.    The function has been removed.  Avantgarde Finance - Sulu Extensions IV -   19  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Derived Contracts Could By-Pass the", "body": " Invariant on the Sum of Shares  The  TreasurySplitterMixin  is  an  abstract  contract  that  allows  splitting  funds  at  constant  ratios  (which should  sum  up  to  100%)  among  users.  The  only  possibility  to  modify  the  split  ratio  in  a  more  derived contract is through the internal function __setSplitRatio.  function __setSplitRatio(address[] memory _users, uint256[] memory _splitPercentages)     internal {     uint256 totalSplitPercentage;     for (uint256 i; i < _users.length; i++) {         // ... duplicate and non-zero validation         userToSplitPercentage[_users[i]] = _splitPercentages[i];         totalSplitPercentage = totalSplitPercentage.add(_splitPercentages[i]);         emit SplitPercentageSet(_users[i], _splitPercentages[i]);     }     require(totalSplitPercentage == ONE_HUNDRED_PERCENT, \"__setSplitRatio: Split not 100%\"); }  This function is agnostic to the current storage of the contract. Hence, the following scenario could occur:  1. A  more  derived  contract  sets  the  split  ratio  with  __setSplitRatio  to  100%  for  user  A.  Hence,  userToSplitPercentage for A will be 100% while no invariants are violated.  2. In another step, the more derived contract tries to add user B to the sharing mechanism. It passes  only user B and 50% to the function.  3. Now, the userToSplitPercentage is set to 50% for B.  4. The sum of all user split percentages is 150% which violates the invariant.  Hence, the current implementation is only suited for one-time setting of split ratios.  With the current usage, this is not an issue as the shares splitter contract will set the ratio only once upon creation.  However,  future  contracts  inheriting  from  the  TreasurySplitterMixin  could  require  some additional logic to prevent the invariant violations described above.  Avantgarde Finance - Sulu Extensions IV -   20  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Incorrect Description of Dog.bark()", "body": "  After  the  intermediate  report  the  main  functions  of  Liquidations  2.0  have  been  annotated  with  their expected behavior taken from MIP45.  The description above Dog.bark() as well as the corresponding part in MIP45 are outdated: In order to address an other issue (Liquidation of Dusty Vaults), the behavior has been slightly altered.  Notably, the statement  // There is a precondition about `room` that needs // to be satisfied in order to create an auction: // room > 0 && room >= ilk.dust // otherwise the transaction fails  no longer applies in the updated code.  Specification changed:  The  code  comments  have  been  changed  and  now  explain  the  new  liquidation  behaviour  including  the preconditions.  Maker Foundation - Liquidations 2.0 - ChainSecurity  12  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion2Speci\ufb01cationChanged           \f7.2   Dirt Remains After Bad Auction  As  described  in  MIP45c4,  the  Hole/  ilk.hole  values  define  a  global  /  per-collateral  limit  of  the  total amount  of  DAI  needed  to  cover  the  summed  debt  and  liquidation  penalty  associated  with  all  active auctions.  The current debt is tracked by the global Dirt and the per collateral ilk.dirt variables.  Upon  auction  initiation,  the  tab,  the  new  debt  of  the  system  is  added  to  the  corresponding  variables. Upon  buying  from  an  auction,  the  owe  amount,  the  amount  of  debt  paid,  is  removed  from  the corresponding variables.  The expected behavior is only loosely covered in MIP45c8:  Lastly, various values are updated to record the changed state of the auction: the DAI needed to cover debt and fees for outstanding auctions, and outstanding auctions of the given collateral type, are reduced (via a callback to the liquidator contract) is reduced by owe, and the tab (DAI collection target) and lot (collateral for sale) of the auction are adjusted as well. If all collateral has been drained from an auction, all its data is cleared and it is removed from the active auctions list. If collateral remains, but the DAI collection target has been reached, the same is done and excess collateral is returned to the liquidated Vault.  As described in the specification above, the code only removes the received amount of DAI (owe) from the debt. This works as expected when the auction managed to cover the tab. In this case all debt added to the dirt during liquidation is removed. During exceptional circumstances however, the situation that an auction is unable to collect enough DAI to cover the tab despite selling all collateral may arise. In this scenario the auction terminates but the unrecovered debt amount remains in the dirt variables.  The expected behaviour in this scenario should be documented.  After such an auction, the value of Dirt will exceed the summed debt of all active auctions and it is no longer possible for the summed debt of all auctions to reach the limit defined by Hole.  If  this  happens  repeatedly,  e.g.  during  a  rapid  market  crash  the  accumulated  unaccounted  dirt  may severely  restricts  the  amount  of  active  auctions  possible.  Most  notably  this  will  impact  less  liquid collateral types with a comparatively low amount set for ilk.hole.    The code has been updated and now handles this case correctly: When an auction has sold all collateral (lot reduced to 0) the remaining tab is removed in addition to owe which is the aumount of DAI just collected:  // Removes Dai out for liquidation from accumulator dog_.digs(ilk, lot == 0 ? tab + owe : owe);  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Potential Reentrancy During Emergency", "body": " Shutdown  Maker Foundation - Liquidations 2.0 - ChainSecurity  13  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected              \fOnce the emergency shutdown mode has been entered, a reentrancy attack is possible. The reentrancy attack works as follows:  1. The attacker identifies an open auction to attack and the corresponding ilk. Note that this attack  can be repeated for different auctions.  2. The attacker ensures that the ilk has been caged inside the End contract. If not, the attacker can  enforce this by calling the cage function for the ilk in question.  3. The attacker calls take on the corresponding Clipper for the identified auction so that the auction  will be closed at the end.  4. The attacker specifies its contract as who for the callback.  5. The take function sends collateral to who.  6. As part of the callback the attacker calls the snip function of the End contract, which will call the  yank function of the Clipper.  7. The  snip  function  returns  the  collateral  and  the  debt  to  the  corresponding  vault  .  Hence,  the  collateral has been sent away twice at this point.  8. The  yank  function  signals  to  the  dog  that  the  auction  is  closed.  The  yank  function  deletes  the  auction and removes it from the active list.  9. After the return of the callback, the take function also signals to the dog that the auction is closed, also  deletes  it  and  finally  tries  to  remove  it  from  the  active  list.  At  this  point  it  removes  another auction from the active list.  The consequences are:   There are more active auctions than listed inside the active array.   Not  all  remaining  auctions  can  be  closed.  The  _remove  function  will  eventually  revert  once  the  active array is empty.   The  Dirt  values  of  the  Dog  is  incorrect.  Hence,  even  auctions  for  other  collaterals  could  revert  during yank or take as the corresponding calls to dog.digs will revert.   The Clipper does not hold sufficient collateral to serve all ongoing auctions.  Note that the exact consequences increase if the attack is performed multiple times.    The issue was addressed by adding the lock modifier to yank which prevents the reentrancy.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Specification Mismatches", "body": "  There are multiple errors of different severity in the MIP45 specification. For each item we list the relevant part of the specification and the explanation of the error:   c7:  \"all  liquidations  disabled(2):  This  means  no  new  liquidations  (Clipper.kick),  no  takes  (Clipper.take), and no redos (Clipper.redo)\"  Reason:  While  this  is  correctly  implemented,  the  code  comment  is  a  bit  unclear  as  it  does  not specify that no kick invocations are allowed on level 2:  // Levels for circuit breaker // 0: no breaker // 1: no new kick()  Maker Foundation - Liquidations 2.0 - ChainSecurity  14  CorrectnessMediumVersion1Speci\ufb01cationChanged        \f// 2: no new redo() or take()   c8: \"If the auction reached the tail value, ... then the Clipper.take would revert if called\"  Reason:  This  description  of  the  tail  value  mismatches  with  its  description  in  c1:  \"Time  elapsed before auction reset\". Note that the source code follows c1:  function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {     price = calc.price(top, sub(block.timestamp, tic));     done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp); }   c8: \"If the auction ... fell by cusp percent of top, then Clipper.take would revert if called, ...\"  Reason:  Discrepancy  with  c1  \"cusp  =  0.6  *  RAY  (60%  of  the  starting  price),  then  the  auction  will need to be reset when reaching just below the price of 720.\" c1 implies that the auction needs to be restarted once it falls by at least cusp percent, while c8 implies that it needs to be restarted when it falls by more than cusp percent.   c8: \"If the caller provided a bytestring with greater than zero length, an external call is made to the who  address,  assuming  it  exposes  a  function,  follow  Solidity  conventions,  with  the  following signature.\"  Reason: This is not entirely correct, as no call will be made if who is the Dog contract or the Vat contract.   c13: \"treats price at the current time as a function of the initial price of an auction and the time at  which it was initiated\".  Reason: The price is a function of the initial price and the duration since last redo.   c14: \"This process will repeat until all collateral has been sold or the whole debt has been collected\"  Reason: This is not true as the auction might also be completed through a call to the snip function.   c15:  \"The  Clipper.take  call  can  send  any  remaining  collateral  or  DAI  beyond  owe  to  a  cold  wallet  address inaccessible to the keeper.\"  Reason: This statement is slightly imprecise as the remaining collateral or DAI would be moved by the clipperCallee.   c16:  \"A  mutex  check  to  ensure  the  Clipper.take  function  is  not  already  being  invoked  from  clipperCallee.\"  Reason:.  The  mutex  check  prevents  reentrancy  into  Clipper.take/redo()  irregardless  of  the clipperCallee.   c17: \"calls dog.digs in order to increment its Hole and ilk.hole values by the remaining auction tab.\"  Reason: It is not Hole/hole that are modified but Dirt/dirt.   c18: \"function file(bytes32 what, uint256 data) external\"  Reason: data should be of the type address.   c18: function active() external view returns (uint256[]);  Reason: The automatically created getter active will requires numeric index as a parameter and returns a single uint256.   c26: \"urn.art * ilk.rate * ilk.chop ||\"  Reason: Missing operator for comparison.   c26:   In  equations   into  account  e.g., urn.art * ilk.rate * ilk.chop > room. However, this choice is not explicitly stated which creates mismatch with the implementation.  the  units  are  not   it  seems   taken   that   Maker Foundation - Liquidations 2.0 - ChainSecurity  15  \f c26: \"vault.art * ilk.rate <= room\"  Reason: Missing chop.   c27: \"if amt < lot && tab - (amt * abacus.price) < ilk.dust\"  Reason: Mismatch with code. The code says amt < lot && owe < tab.  Specification corrected:  The  specification  has  been  corrected  and  matches  the  code  behavior  apart  from  minor  diversions  that are irrelevant to general usage, e.g., internal restrictions on callback targets.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Specification Mismatches Due to Final", "body": " Changes  The documentation still lists the function getId inside the Clipper contract. However this function was  of the code. Note that no functionality was removed as the active function can be removed in  used instead.  The  updust  function  was  newly  added  to  the  code  in    to  allow  a  caching  of  the  dust  value inside  the  Clipper,  see  Dust  Retrieval  Is  Relatively  Expensive  for  more  information.  The  updust function is not yet documented.  Specification changed:  The specification was adjusted accordingly to reflect the removal of the getId function and the addition of the updust function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Dust Retrieval Is Relatively Expensive", "body": "  Multiple clever gas optimizations have been performed by the developers. However, we note that a rather trivial looking line still contains major gas costs:  (,,,, uint256 dust) = vat.ilks(ilk);  This line retrieves the dust amount for the specific ilk. It occurs inside the Clipper functions take and redo. Inside the vat the following struct will be loaded:  struct Ilk {     uint256 Art;   // Total Normalised Debt     [wad]     uint256 rate;  // Accumulated Rates         [ray]     uint256 spot;  // Price with Safety Margin  [ray]     uint256 line;  // Debt Ceiling              [rad]     uint256 dust;  // Urn Debt Floor            [rad] }  Maker Foundation - Liquidations 2.0 - ChainSecurity  16  CorrectnessLowVersion3Speci\ufb01cationChangedVersion3Version3DesignLowVersion2CodeCorrected                \fHence, 5 SLOAD operations are necessary. After the activation of the upcoming Berlin hardfork this will cost 5 * 2,100 = 10,500 gas. However, in the current architecture there is no way to retrieve the dust value separately. Mirroring it inside the Clipper contract would reduce the costs significantly, but would introduce potential inconsistencies between the two values.    The code has been corrected. The dust value is cached inside the Clipper and can be kept consistent through a permissionless call to updust.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Duplicate Functions in Clipper", "body": "  The  two  functions  getId  and  the  active  inside  the  Clipper  have  the  same  functionality.  Both functions take a list index as input and return the element of the active list at that index.  function getId(uint256 id) external view returns (uint256) {     return active[id];  Hence, it seems that the code size is unnecessarily increased.    The getId function was removed from the Clipper contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Gas Inefficiency During Auction Removal", "body": "  When an auction is being removed from the Clipper, because it is finished or has been yanked, then the auction id will be removed from the active list. As part of this removal, the auction id is exchanged with the last auction id in the active list and the appropriate changes are made:  function _remove(uint256 id) internal {     uint256 _index   = sales[id].pos;     uint256 _move    = active[active.length - 1];     active[_index]   = _move;     sales[_move].pos = _index;  In case that the removed auction was already last in the list, which is not unlikely given that there is such a list for each collateral, two SSTORE and one SLOAD operation could have been skipped.  Code Corrected:  The code has been changed as follows:  function _remove(uint256 id) internal {     uint256 _move    = active[active.length - 1];     if (id != _move) {  Maker Foundation - Liquidations 2.0 - ChainSecurity  17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f        uint256 _index   = sales[id].pos;         active[_index]   = _move;         sales[_move].pos = _index;     }     active.pop();     delete sales[id]; }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.9   Liquidation of Dusty Vaults", "body": "  According to the protocol, the initiation of an auction will be reverted if the available room is less than the dust for the corresponding ilk. However, there might be the corner case where a dusty vault exists, e.g., after the dust amount for a particular ilk has been increased.  Dusty vaults can be blocked from liquidation even though there would be room for them. This is because of following check:  require(room > 0 && room >= dust, \"Dog/liquidation-limit-hit\");  Even  though  there  wouldn't  be  enough  room  for  dust,  there  would  still  be  enough  room  for  a  dusty auction. This state is temporary. Later, once even more room becomes available again, the dusty vault can be liquidated again.    Dusty vaults can now be liquidated. If there is room to liquidate the total art of the vault there are no further restrictions related to the dust to start the auction.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.10   room > 0 Check Can Be Omitted", "body": "  In dog.bark there is a check on whether the available room is positive. This check takes place in the following require statement:  require(room > 0 && room >= dust, \"Dog/liquidation-limit-hit\");  This check is only useful in the case where dust == 0 and room == 0, otherwise it holds trivially. In the  previously  mentioned  case,  however,  dart  ==  0  (since  dart  =  min(art,  0))  and (art - dart)*rate >= dust (since dust == 0).  Hence, dink = mul(ink, dart)/art == 0 and the following require statement reverts:  require(dink > 0, \"Dog/null-auction\");  Hence, the room > 0 sub-condition can be safely removed, which saves a small amount of gas during every execution.  Maker Foundation - Liquidations 2.0 - ChainSecurity  18  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fCode Corrected:  In  the  updated  implementation  the  logic  determining  whether  a  full  or  partial  liquidation  happens  has been changed in order to address another issue. The require statement listed above no longer exists and neither does an unnecessary > 0 check. Hence the issue has been resolved.  Maker Foundation - Liquidations 2.0 - ChainSecurity  19  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  contracts  in scope for this review are part of the Maker system which consists of many interacting contracts. Hence, the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead, they should raise awareness in order to improve the overall understanding for users and developers.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Blocked Calls From Clipper", "body": "  During the take function of the Clipper, an external call is executed. Certain call targets are blocked:  if (data.length > 0 && who != address(vat) && who != address(dog_)) {     ClipperCallee(who).clipperCall(msg.sender, owe, slice, data); }  As the Clipper has special privileges inside the vat and dog_ contracts, these contracts are blocked. However, additionally targets need to be blocked where the funds controlled by the Clipper could be moved  in  an  unauthorized  way.  A  good  example  is  the  GemJoin.exit  function.  This  function  could remove the stored collateral from the Clipper and send it to an attacker. Please note that this attack currently does not work as there is no collision between the signature hashes of   clipperCall(address,uint256,uint256,bytes) and   exit(address,uint256).  However, we note that for all future contracts added to the system it needs to be ensured that no such collisions exist or the call targets need to be blocked.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Creation of Many Small Auctions", "body": "  As  discussed  in  the  MIP45,  incentive  farming  needs  to  be  avoided.  Besides  the  scenarios  that  are already described in the MIP45, another scenario is possible. This scenario comes into effect if either the capacity  for  one  collateral  or  the  overall  capacity  has  almost  reached  its  limit.  In  technical  terms  this means that the dirt is almost as large as the hole.  If, in this scenario, a large vault becomes unsafe, an attacker could create many small auctions out of it. The attacker would perform the following steps within a single transaction:  1. Create a small auction that fills up the capacity limit and receive the keeper incentive  2. Take a small amount (ideally dust) from another auction (note that given that the limit is reached,  there is likely a good auction available)  The  only  downside  for  the  attacker  compared  to  creating  a  big  auction  are  higher  gas  costs.  Note, however, that after EIP-2929 (in combination with EIP-2200) will come into effect the additional costs of performing step 2 multiple times will be significantly reduced, while the costs of repeated executions of step 1 will also be reduced.  Maker Foundation - Liquidations 2.0 - ChainSecurity  20  NoteVersion2NoteVersion1        \f8.3   Debt Queue Not Updated Automatically  The Vow contract manages a system debt queue called sin, not to be confused with the sin mapping inside the Vat contract. It is noteworthy that the debt queue is fully not synchronized with the liquidation system. In particular, the liquidation system makes new entries, but never resolves them.  This can have two possible effects:  1. The debt inside the system debt queue is released too quickly. In particular that means that auctions might still be ongoing for the released debt and hence some of the debt might still get covered. This can  occur  if  the  wait  value  inside  the  Vow  is  too  low  in  comparison  to  auction  durations.  As  a consequence it might be possible to trigger a debt auction even though there is no need for it.  2. The debt inside the system debt queue is released too slowly. In particular that means that auctions might have long finished and that the debt has already been repaid. This can occur if the wait value inside the Vow is too large in comparison with auction durations. As a consequence surplus auctions could be unnecessarily delayed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Ethereum Is a Dark Forest", "body": "  Ethereum  is  a  Dark  Forest  describes  the  phenomena  of  bots  inspecting  the  pool  of  unmined transactions  and  front-running  profitable  transactions  with  their  own.  Although  the  exact  capabilities  of these bots are unknown, these bots are sophisticated.  Liquidations 2.0 relies on keepers to initiate liquidations of undercollateralized vaults. There is a certain cost overhead (e.g. running a software monitoring the blockchain) for keepers to detect undercollaterlized vaults.  Only  after  undercollateralized  vaults  have  been  identified,  they  can  be  liquidated  by  calling Dog.bark(). For their efforts, keepers are rewarded on-chain if tip and/or chip are set to non-zero values.  While  it  doesn't  matter  for  the  liquidation  system  when  bots  copy  and  front-run  these  transactions,  the honest  keepers  will  not  only  lose  their  anticipated  reward  for  the  liquidation,  but  also  lose  the  gas  fee paid. If this happens repeatedly, keepers may stop to identify & liquidate undercollateralize vaults as they can't make a profit. Once no keeper identifies and crafts transactions to liquidate vaults bots can't copy these transactions anymore - and hence in an extreme scenario no more liquidations happen.  Clipper.redo() is affected in a similar way, Clipper.take() may be affected partially, e.g. when there are flash-loans involved.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   Incentive Farming Might Be Possible Due to", "body": " Misconfiguration  As  mentioned  in  MIP45c19,  Incentive  Farming  is  a  risk  in  the  system.  However,  it  could  also  occur without  a  change  in  the  dust  value.  Note  that  there  is  no  mechanism  inside  the  smart  contracts  that prevents that a keeper's reward for kicking off an auction is bigger than the liquidation penalty which the system achieves. Hence, the governance needs to chose the corresponding parameters: chip, tip and chop very carefully as a misconfiguration allows a way to drain the system.  Maker Foundation - Liquidations 2.0 - ChainSecurity  21  NoteVersion1NoteVersion1NoteVersion1            \f8.6   Initialization and Deployment Requires Extra Care  As  with  any  smart  contract  care  needs  to  be  taken  during  deployment  and  initialization.  However,  for these contracts it is especially important as they:   will be integrated into an existing system   are not fully initialized during deployment  In particular the following steps need to be performed correctly:   Authorizations between the contracts need to be granted   All parameters need to be chosen. Not that some functionality will already be available with partially initialized  contracts,  e.g.  the  Clipper  contract  will  be  fully  functional  if  no  Vow  contract  has  been registered. However, all collected DAI will flow to the Zero address.  Initially given deployment authorizations need to be revoked   Authorizations for replaced contracts need to be revoked  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.7   Monotonicity of Price Functions", "body": "  The auction system is designed as \"Dutch style auction system, where auction prices generally start high and  drop  over  time\".  Note,  however  that  there  is  no  guarantee  in  the  system  that  prices  will  be monotonically decreasing. Apart from a redo which can trigger a price increase, the prices can also rise due to changed parameters of the corresponding Abacus contract.  As  an  example,  if  the  variable  tau  which  contains  the  \"Seconds  after  auction  start  when  the  price reaches zero\" is increased, ongoing auctions will see a price increase. Note, that users of the system can protect  themselves.  Auction  takers  can  specify  a  max  price  which  they  are  willing  to  pay  for  collateral. Then, they only stand to lose gas costs.  We  aim  to  educate  users  to  properly  use  the  max  value  even  though  there  is  a  seemingly  decreasing price.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.8   No Stability Fee During Auctions", "body": "  As  debt  accumulates  no  stability  fee  during  auctions,  it  needs  to  be  ensured  that  debt  doesn't  reside inside an auction for too long. In case the stability fee would be very high, the liquidation penalty would be  really  low,  and  the  auction  would  be  running  for  a  very  long  time,  the  stability  fee  lost  during  the auction time would exceed the liquidation penalty earned. In this hypothetical scenario a liquidation would be \"beneficial\" for a vault owner.  Note, however, that we deem this as highly unlikely as there is a general incentive to keep auctions short, which is also discussed in the MIP45. Even for the collateral with the currently highest stability fee (50%), the auction would have to take roughly 110 days to offset a regular liquidation penalty of 13%.  Maker Foundation - Liquidations 2.0 - ChainSecurity  22  NoteVersion1NoteVersion1NoteVersion1             \f8.9   Vat Debt Tracking Not Automatically Synchronized  At the beginning of an auction dog.bark() calls vat.grab() to reassign the collateral to the auction contract  and  the  debt  from  the  vault  to  the  system.  Hence,  both  vat.sin[vow]  and  vat.vice  are increased by dart times the collateral's rate. The sin mapping and vice are used to track the bad debt of the system inside the Vat contract.  However, these values are not updated after a successful auction. This is due to how the Maker system works: After a purchase in an auction, the DAI amount received is transferred to the vow. When the vow contract  has  a  surplus  amount  of  DAI,  anyone  may  call  vow.heal()  to  settle  the  debt  accrued  in vat.sin[vow]. Further functionality allows to handle debt or surplus auctions. Please note that the Vow and Vat contracts are not in scope of this review and are expected to work correctly.  Maker Foundation - Liquidations 2.0 - ChainSecurity  23  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   No Sanity Check on _start_time", "body": "  There is no sanity check on _start_time in FeeDistributor.__init__.  Acknowledged  StakeDAO acknowledged the issue.  StakeDAO - StakeDAO-Frax-veSDT -   14  DesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCodePartiallyCorrectedCodePartiallyCorrectedAcknowledgedAcknowledgedCodePartiallyCorrectedCodePartiallyCorrectedAcknowledgedAcknowledgedAcknowledgedDesignLowVersion4Acknowledged              \f5.2   Broad Function Visibility: approveWallet  The visibility of the function SmartWalletWhitelist.approveWallet is public, however it is not called  internally.  For  functions  that  are  expected  to  be  called  from  other  contracts  only,  the  function visibility can be restricted to external instead of public. This allows to save gas costs, as public functions copy array function arguments to memory which can be expensive.  Acknowledged  StakeDAO acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Inconsistent Checks When Depositing in ", "body": " veSDT  The function increase_amount requires that the msg.sender is either an externally owned contract or a whitelisted contract:  self.assert_not_contract(msg.sender)  However, the function deposit_for performs the same operation if addr is msg.sender and does not have the above restriction.  Acknowledged  StakeDAO acknowledged the issue. It is connected to a vyper bug which also affects another issue. The bug was resolved in version 0.3.1. More information: Fix allocation of unused storage slots  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Inconsistent Procedure for Updating admin", "body": "  Multiple  contracts  have  an  admin  role  that  is  privileged  and  can  call  sensitive  functions.  However,  the procedure  to  update  such  privileged  roles  is  not  consistent  among  different  contracts.  Namely, SmartWalletWhiteList  uses  commit/apply  approach,  meaning  the  current  admin  initially  calls commitAdmin and then should call applyAdmin to set the new admin. While, LiquidityGaugeV4, FeeDistributor,  veBoostProxy  use  commit/accept  approach.  Differently  from  the  previous contracts, veSDT provides both procedures commit/accept and commit/apply to update the admin.  Acknowledged  StakeDAO acknowledged the issue.  StakeDAO - StakeDAO-Frax-veSDT -   15  DesignLowVersion3AcknowledgedCorrectnessLowVersion3AcknowledgedDesignLowVersion3Acknowledged                        \f5.5   Mismatch of Specification With the Function Modifier in AngleLocker  The  specification  of  the  AngleLocker's  function  createLock  states  that  it  can  only  be  called  by governance or proxy, however, the modifier onlyGovernance is used and the mentioned proxy is not declared anywhere.  Acknowledged  StakeDAO acknowledged the issue and replied:  The specification comment is wrong because it mentioned a proxy where it is not declared at the end.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.6   Missing Documentation for Parameter", "body": "  The function GaugeController.__init__ has no NatSpec description for the parameter admin.  Acknowledged  The NatSpec has not been updated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.7   Missing Events for Sensitive Operations", "body": "  Multiple  contracts  do  not  emit  events  when  sensitive  operations  are  performed,  e.g.,  the  update  of  the admin for a contract.  We provide below some examples:   SmartWalletWhitelist.sol: applyAdmin and applySetChecker.   ClaimRewards.sol: setGovernance.   SdtDistributor.sol: initializeMasterchef, setDistribution and setTimePeriod.   LiquidityGaugeV4.vy: add_reward, set_reward_distributor and set_claimer.  Code partially corrected  StakeDAO added a new event for the function setGovernance of ClaimRewards.sol.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.8   Missing Sanity Checks", "body": "  Several setter functions in multiple contracts do not perform sanity checks for the new values that are set. We provide examples of such cases below:  StakeDAO - StakeDAO-Frax-veSDT -   16  CorrectnessLowVersion3AcknowledgedDesignLowVersion3AcknowledgedDesignLowVersion3CodePartiallyCorrectedDesignLowVersion3CodePartiallyCorrected                              \f SdtDistributor.sol:  _masterchef  parameter   in  initialize  and  _delegateGauge   in  setDelegateGauge.   LiquidityGaugeV4.vy: _distributor in add_reward.   veSDT.vy: token_addr in initialize and addr in commit_smart_wallet_checker.   FeeDistributor.vy: _start_time in the constructor.  Code partially corrected  StakeDAO added some checks but the following values still lack sanity checks:   SdtDistributor.sol: _delegateGauge in setDelegateGauge.   LiquidityGaugeV4.vy: _distributor in add_reward.   veSDT.vy: addr in commit_smart_wallet_checker.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.9   Missing Sanity Checks: AngleLocker", "body": "  The  setter  functions  take  an  address  as  a  parameter  and  assign  it  to  a  state  variable.  Given  the sensitivity  of  such  functions,  basic  sanity  checks  on  the  input  parameter  help  to  eliminate  the  risk  of setting address(0) to the state variable of the contract by accident (e.g. UI bugs).  Acknowledged  StakeDAO  decided  to  keep  the  function  as  it  is  and  explained  that  its  parameters  will  be  reviewed carefully and that it won't be managed through a user interface.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.10   Non-indexed Events", "body": "  Events  can  be  indexed  to  easily  filter  and  search  for  the  indexed  arguments.  This  is  used  in  most contracts.  Without  full  specification  about  what  needs  indexing  we  simply  highlight  that  the  following occasions are not indexed and the need of indexing should be revised by StakeDAO.   Completely no indexed events in BaseAccumulator   Completely no indexed events in ClaimRewards   Completely no indexed events in GaugeController   Multiple not indexed events in LiquidityGaugeV4   Multiple not indexed events in veBoostProxy   No indexed events in CommitAdmin and ApplyAdmin in FeeDistributor  Acknowledged  StakeDAO replied:  StakeDAO - StakeDAO-Frax-veSDT -   17  DesignLowVersion3AcknowledgedDesignLowVersion3Acknowledged                \fWe decided to not include indexed parameters within the events definition because they will increase the gas a little bit and also, we could fetch externally the same info using theGraph.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.11   Possible Gas Optimization in Mappings", "body": "  Multiple contracts of the system use mappings in the format: mapping(key_type => bool). Solidity uses a word (256 bits) for each stored value and performs some additional operations when operating bool values (due to masking). Therefore, using uint256 instead of bool is slightly more efficient.  We provide below the list of mappings that can be optimized:   SmartWalletWhitelist.sol: wallets.   ClaimRewards.sol: gauges.   SdtDistributor.sol: killedGauges, isInterfaceKnown and isGaugePaid.  Code partially corrected  StakeDAO changed the mapping gauges in ClaimRewards.sol from mapping(key_type => bool) to mapping(key_type => uint256) and modified all the functions using it accordingly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.12   Unused Events", "body": "  Several contracts declare events that remain unused in the existing code base. The StakeDAO should assess if such events should be removed or emit them accordingly. We provide a list of unused events:   ClaimRewards.sol:   DepositorDisabled,   RewardClaimedAndLocked   and  RewardClaimedAndSent.   SdtDistributorEvents.sol:   UpdateMiningParameters.   GaugeController.vy: KilledGauge.  DistributionsToggled,   RateUpdated,  Code partially corrected  StakeDAO  deleted  the  unused  events  in  ClaimRewards  but  not  in  SdtDitributorEvents  and GaugeController as they were already deployed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.13   Missing Sanity Checks: FraxLocker", "body": "  The  setter  functions  take  an  address  as  a  parameter  and  assign  it  to  a  state  variable.  Given  the sensitivity  of  such  functions,  basic  sanity  checks  on  the  input  parameter  help  to  eliminate  the  risk  of setting address(0) to the state variable of the contract by accident (e.g. UI bugs).  Acknowledged  StakeDAO - StakeDAO-Frax-veSDT -   18  DesignLowVersion3CodePartiallyCorrectedDesignLowVersion3CodePartiallyCorrectedDesignLowVersion1Acknowledged                        \fDue to efficiency reasons, StakeDAO decided to keep the function as it is.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.14   Missing Sanity Checks: FxsDepositor", "body": "  The  setter  functions  that  take  an  address  as  a  parameter  and  assign  it  to  a  state  variable  lack  basic sanity  checks  on  the  input  parameter.  Such  checks  would  help  to  eliminate  the  risk  of  setting address(0) to the state variable of the contract by accident (e.g. UI bugs).  Acknowledged  Due to efficiency reasons, StakeDAO decided to keep the function as it is.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.15   Missing Sanity Checks: sdFXSToken", "body": "  The  function  setOperator  takes  an  address  as  a  parameter  and  assigns  it  to  the  state  variable operator. Given the sensitivity of this function, basic sanity checks on the parameter _operator help to eliminate the risk of setting address(0) as the operator of the contract by accident (e.g. UI bugs).  Acknowledged  Due to efficiency reasons, StakeDAO decided to keep the function as it is.  StakeDAO - StakeDAO-Frax-veSDT -   19  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  3  12  -Severity Findings  -Severity Findings  Incorrect Index Used to Access depositorsIndex   -Severity Findings   Possible to Lock Users' Funds Into veSDT   Inconsistent Access Control    Update of unlockTime   -Severity Findings  Inconsistent Specification: deposit_for_from   Inconsistent Specification: initialize    Possible to Optimize the Check on Distributor of tokenReward    Broad Function Visibility    Commented Code    Mismatch of Specification With the Function Modifier    Revert Message on Modifier    Unused Event Voted    Unused Imports: FxsDepositor    Unused Imports: FxsLocker    Unused Imports: sdFXSToken    createLock Access Control   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Incorrect Index Used to Access ", "body": " depositorsIndex  In  the  function  addDepositor  of  ClaimRewards  ,  values  of  depositorsIndex  are  set  using depositor addresses as indexes.  depositorsIndex[_depositor] = depositorsCount;  In claimAndLock this array is accessed twice using token addresses as indexes.  if (depositor != address(0) && lockStatus.locked[depositorsIndex[token]]) {         IERC20(token).approve(depositor, balance);  StakeDAO - StakeDAO-Frax-veSDT -   20  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion3CodeCorrected            \f        if (lockStatus.staked[depositorsIndex[token]]) {                 IDepositor(depositor).deposit(balance, false, true, msg.sender);         } else {                 IDepositor(depositor).deposit(balance, false, false, msg.sender); }  Given  that  there  are  no  contract  defining  both  a  token  and  a  depositor  in  the  codebase,  it  would  most likely  lead  depositorsIndex[token]  to  always  evaluate  to  0  and  hence  use  the  first  element  of lockStatus.staked and lockStatus.locked as decisions for each token.  Code corrected  The variable depositor is now used to address depositorsIndex in claimAndLock.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Possible to Lock Users' Funds Into veSDT", "body": "  Users that lock their tokens into the voting escrow contract need to approve an allowance to veSDT and then call deposit_for or deposit_for_from to transfer the tokens. However, if a user approves to the veSDT an amount that is larger than the intended amount of tokens to be locked, or max uint for simplicity, the user's tokens are exposed to arbitrary locking. In such cases the function deposit_for allows anyone to lock more of user's tokens into the contract without their clear consent. This is possible because  the  function  deposit_for  calls  the  internal  function  _deposit_for  without  passing  the msg.sender as a parameter:  def deposit_for(_addr: address, _value: uint256):     ...     self._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)  The internal function transfers the tokens from _addr if enough allowance exists, while the caller only pays the gas costs:  def _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):     ...     if _value != 0:         assert ERC20(self.token).transferFrom(_addr, self, _value)  Code corrected  StakeDAO  corrected  the  issue  by  adding  the  new  parameter  _from  to  _deposit_from  and  using  it instead of _addr for the ERC20 transfer. Whenever _deposit_from is called, msg.sender is passed as  an  argument  so  that  _from  is  always  equal  to  it.  Anyone  is  still  able  to  call  deposit_for  or deposit_for_from for someone else, but it is now the caller's tokens that are deposited.  def _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128, _from: address):     ...     if _value != 0:         assert ERC20(self.token).transferFrom(_from, self, _value)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Inconsistent Access Control", "body": "  StakeDAO - StakeDAO-Frax-veSDT -   21  DesignMediumVersion3CodeCorrectedDesignMediumVersion1CodeCorrected                \fto   allows   The  access  control  for  FraxLocker.execute  is  onlyGovernanceOrDepositor.  The  function basically  function FraxLocker.claimFXSRewards  has  the  following  access  control  onlyGovernanceOrAcc.  As execute can replicate the behavior of claimFXSRewards the access control is inconsistent because claimFXSRewards can be replicated by execute. Ultimately, giving the Depositor the same power as Acc in this case.  function.   arbitrary   contract   The   and   any   call   This is only a theoretical problem in the current implementation due to another issue.  Code corrected  The  updated  code  protects  the  function  execute  with  the  modifier  onlyGovernance,  which  restricts the access to only the governance address.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Update of unlockTime", "body": "  We  do  not  have  sufficient  specification  about  the  intended  behavior,  but  the  following  seems  to  be  an issue. The internal function _lockFXS updates the unlockTime if the following condition is satisfied:  if (unlockInWeeks.sub(unlockTime) > 1) {         ILocker(locker).increaseUnlockTime(unlockAt);         unlockTime = unlockInWeeks; }  Given that both unlockInWeeks and unlockTime store the number of seconds passed until a given week, the comparison with 2 (sec) seems incorrect.  Specification changed  The  current  code  will  always  evaluate  the  if  condition  as  true  if  the  comparison  is  bigger  than  1. StakeDAO changed the specification from two weeks to one week. Additionally, the 2 was changed to 1 (which has no effect but makes it more explicit). The code works but we need to highlight, that this only works for one week check.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Inconsistent Specification: ", "body": " deposit_for_from  The functions deposit_for and deposit_for_from have a similar behavior, however their NatSpec specification is inconsistent. The comment for deposit_for:  @dev Anyone (even a smart contract) can deposit for someone else, but      cannot extend their locktime and deposit for a brand new user  while the respective description for deposit_for_from is:  @dev Anyone (even a smart contract) can deposit for someone else from their account  StakeDAO - StakeDAO-Frax-veSDT -   22  DesignMediumVersion1Speci\ufb01cationChangedCorrectnessLowVersion3CodeCorrected                \fCode corrected  The NatSpec specification of deposit_for_from has been modified to reflect the function's behavior.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Inconsistent Specification: initialize", "body": "  The NatSpec description of veSDT's initialize function describe token_addr as being the address of the ERC20ANGLE contract while the contract is a voting escrow for the SDT token.  Code corrected  StakeDAO corrected the NatSpec description by replacing ERC20ANGLE by ERC20SDT.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Possible to Optimize the Check on Distributor", "body": " of tokenReward  The  function  BaseAccumulator._notifyReward  checks  if  the  distributor  of  _tokenReward  is  not address(0), then it performs the two external calls as shown below:  if (ILiquidityGauge(gauge).reward_data(_tokenReward).distributor != address(0)) {                     IERC20(_tokenReward).approve(gauge, _amount);                     ILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);         ...             }  The  function  call  deposit_reward_token  succeeds  only  if  the  accumulator  is  the  distributor  for  the _tokenReward, otherwise it reverts. Hence, the function could be optimized by directly checking if the distributor of the _tokenReward is the accumulator.  Code corrected  The condition checks immediately if the address is the accumulator.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Broad Function Visibility", "body": "  The  function  depositFor  in  FxsDepositor  is  declared  as  public  but  it  is  never  called  internally. Following  the  best  practices,  functions  expected  to  be  called  only  externally  should  be  declared  as external.  Code corrected  StakeDAO - StakeDAO-Frax-veSDT -   23  CorrectnessLowVersion3CodeCorrectedDesignLowVersion3CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe function depositFor has been removed from the contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}]