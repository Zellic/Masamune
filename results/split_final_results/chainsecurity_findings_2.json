[{"title": "6.1   Event Parameters Not Indexed", "body": "  The event ReferredBalanceIncreased emits the address of partnerId, vault and depositer. All three information might be relevant to later query specific deposits. Hence, it might be useful to index these parameters.    The updated event now indexes the parameters: partnerId, vault and depositer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-partner-tracker/"}, {"title": "6.2   Missing Code Comments and Function", "body": " Descriptions  Even though the code base is simple and well structured, code comments as well as function description with parameter descriptions are part of good coding practice to help understanding the code. The current implementation lacks documentation and code comments.    The updated code contains specifications that describe the functions and their parameters.  Yearn Finance - Partner Tracker -   9  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.3   Missing Return Values  Both  external  functions  deposit  declare  a  return  value  of  type  uint256,  but  the  return  statement  is missing.    The  internal  function  _internalDeposit  is  modified  to  return  receivedShares,  which  is  then returned by both external functions deposit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-partner-tracker/"}, {"title": "6.4   Unused Constant registry", "body": "  The constant registry is defined but not used in the current code base.    The unused constant has been removed from the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-partner-tracker/"}, {"title": "6.5   Unused Imports", "body": "  The Math and Address libraries and the registry interface are imported but not used.  import \"@openzeppelin/contracts/math/Math.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\"; import \"../interfaces/IYearnRegistry.sol\";    The unused imports have been removed from the updated code.  Yearn Finance - Partner Tracker -   10  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-partner-tracker/"}, {"title": "7.1   Contract Tracks Also Malicious Vaults and", "body": " Tokens  The input arguments for the vault to be deposited in and the token are provided by the user. Both can be malicious  contracts.  We  could  not  see  a  way  to  exploit  the  contract,  but  the  mapping  will  record everything  including  the  invalid/malicious  vaults.  Hence,  when  reading  the  mapping  the  correct  vaults needs to be carefully selected and invalid records neglected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-partner-tracker/"}, {"title": "7.2   Outdated Compiler Version", "body": "  The compiler version is outdated (https://swcregistry.io/docs/SWC-102) and implicitly fixed in the brownie config file to version: 0.6.12. The contract has a floating pragma for the compiler version, although practically  there  is  no  newer  version  without  breaking  changes  (https://swcregistry.io/docs/SWC-103). This version has the following known bugs: https://docs.soliditylang.org/en/v0.6.12/bugs.html  This is just a note as we do not see any severe issue using this compiler with the current code.  Yearn Finance - Partner Tracker -   11  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-partner-tracker/"}, {"title": "5.1   Gas Inefficiencies", "body": "  0  0  0  9  We have found some gas inefficiencies that could be optimized:   Lido saves several contract addresses (e.g., the ETH deposit contract) in the storage. Since Lido is upgradeable, the mentioned variables could be exchanged with constants or immutables that can be updated with a Proxy upgrade to save storage reads on various interactions.   Lido.handleOracleReport  updates  the  BEACON_VALIDATORS_POSITION  even  when  the  amount of validators has not changed.   StakeLimitUtils.calculateCurrentStakeLimit  performs  stake  limit  calculations  even just  return  the  prevStakeBlockNumber   the  current  block  number.   It  could   is   when  prevStakeLimit in that case.   NodeOperatorsRegistry.removeSigningKeys  and  removeSigningKeysOperatorBH  are inefficient if 0 < (totalSigningKeys - 1) - _index < (_amount - 1) as more swaps from the last to the current position are performed than necessary.   NodeOperatorsRegistry._removeSigningKey  assigns  the  new  totalSigningKeys  value to a value that is loaded from storage, while the same value has already been loaded from storage before (lastIndex).  Lido - Lido -   11  DesignTrustCriticalHighMediumLowAcknowledgedRiskAcceptedAcknowledgedRiskAcceptedRiskAcceptedAcknowledgedAcknowledgedAcknowledgedRiskAcceptedDesignLowVersion1Acknowledged           \f NodeOperatorsRegistry.assignNextSigningKeys   calculates stake  +  1  >  entry.stakingLimit  while  stake  >=  entry.stakingLimit  would  be sufficient.   NodeOperatorsRegistry.assignNextSigningKeys finds the operator with the smallest stake with  the  statement  bestOperatorIdx  ==  cache.length  ||  stake  <  smallestStake. This  can  be  simplified  to  stake  <  smallestStake  by  initially  setting  smallestStake  to  the maximum value of uint256.   NodeOperatorsRegistry._storeSigningKey  and  _loadSigningKey  load  signatures  by iterating  over  the  words  of  the  signature  and  loading  them  from  the  memory  location  at add(_signature, add(0x20, i)) on every iteration. This can be simplified to i by setting the 32  +  loop  to to  i <= signature + SIGNATURE_LENGTH.  signature   execution   condition   variable   and   the    LidoOracle  pushes  reports  to  the  CompositePostRebaseBeaconReceiver  which  pushes reports to the SelfOwnedStETHBurner. Since the SelfOwnedStETHBurner is currently the only receiver, this indirect route is not necessary.   SelfOwnedStETHBurner._requestBurnMyStETH  uses  Lido.transfer  and  calculates  the share  amount  by  calling  Lido.getSharesByPooledEth.  This  second  call  could  be  avoided  by using the transferShares function.  Acknowledged:  Lido states:  Thank you for the suggestions, we will take them into consideration for the next protocol upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.2   Inconsistent Event Order", "body": "  The  order  in  which  the  Transfer  and  TransferShares  events  are  emitted  is  inconsistent.  In  the transferShares  function  in  StETH,  the  TransferShares  event  is  emitted  first.  In  all  other  cases, Transfer is emitted first.  Note also that these events are always emitted after calling the _transferShares function. To avoid the duplication of emitted events and reduce code size, it would also be possible to emit the events within the _transferShares function itself.  Risk accepted:  This change is scheduled for the next update.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.3   LidoOracle Initialized With Wrong Epoch", "body": "  In the initialize function of the LidoOracle, the expectedEpoch is set as follows:  uint256 expectedEpoch = _getFrameFirstEpochId(0, beaconSpec) + beaconSpec.epochsPerFrame;  Lido - Lido -   12  DesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                \fHowever,  _getFrameFirstEpochId  will  always  return  0  here.  So  the  first  expected  epoch  is  set  to beaconSpec.epochsPerFrame. However, it would make little sense for a member to report an epoch before the contract was deployed. Instead, the expectedEpoch could be set to an epoch which occurs after the contract is deployed, for example using _getCurrentEpochId.  Acknowledged:  The  initialize  function  can't  be  called  again  on  the  Lido  contract,  which  is  already  deployed. Therefore this is only an issue if a redeployment becomes necessary.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.4   Malicious Node Operators", "body": "  Node operators are trusted entities in the Lido ecosystem. They are responsible for correctly running the validators as well as distributing MEV rewards to the contract. They can only be incentivized to behave decently  so  it  is  possible  that  certain  economic  opportunities  could  incentivize  them  to  behave maliciously.  For example, it can be hard to verify the amount of MEV rewards node operators generate with the nodes they  are  running.  Malicious  node  operators  could  choose  to  not  distribute  these  rewards  but  instead pocket them themselves.  Furthermore, and most importantly, node operators have no ownership of the ETH that are locked in their validators. This means that whatever incentive they have to run the nodes benevolently could be offset by a more financially lucrative incentive. One example could be a short position in stETH that becomes profitable. As the staked ETH are not owned by the operators, this is very much possible due to slashing as can be seen in the following example (assuming the Merge has already happened and according to current spec):   A  malicious  node  operator  executes  2  attestations  to  the  same  target  on  all  of  their  controlled validator nodes. At the time of this writing, single validators run up to ~8,000 nodes of the ~400,000 nodes currently on the Beacon Chain).   Each node gets slashed by 1 ETH, reducing the amount of ETH in the protocol by ~8,000 or ~0.1%  of Lido's total supply.   After 18 days, the validators get slashed again based on the amount of validators that have been  slashed in the previous 16 days: Each validator loses ~1.8 ETH.  In total, the supply of Lido drops by ~0.5%.  If 2 node operators collude, the total supply drops by ~1.7%. If 3 operators collude, it drops by ~3.6%.  Depending  on  the  market  reaction,  the  value  of  stETH  could  decrease  dramatically  following  these events, making a decently sized short position in stETH (or more likely wstETH) profitable.  Risk accepted:  Lido states:  The  risk  is  mitigated  by  maintaining  healthy  validators  set  with  monitoring  and  DAO  governance processes. There is a set of policies and management actions:   onboarding new NOs to decentralize further;  limiting the stake amount per single NO;  Lido - Lido -   13  TrustLowVersion1RiskAccepted          \f developing  dashboards  and   tools   to  monitor  network  pasticipation  performance  (now  open-sourced https://github.com/lidofinance/ethereum-validators-monitoring)   developing  dashboards  and  tools  to  monitor  MEV  and  priority  fee  distribution  (approaching  testing stage for the upcoming Merge)  Despite  the  fact  that  Ethereum  staking  is  not  delegation-friendly,  Lido  DAO  already  has  on-chain levers  to  address  malicious  NO  behavior:  excluding  them  from  the  new  stake,  disabling  fee distribution, excluding them from the set, considering penalties on other chains if applicable, and so on.  Once  and  if  withdrawal-credentials  initiated  exits  are  implemented,  there  will  appear  additional on-chain enforcement mechanics which would allow building more permissionless schemes for the validators set.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.5   No Events on Important State Changes", "body": "  The DepositSecurityModule does not emit events on the following important state changes:  1. When the owner calls setLastDepositBlock.  2. When depositBufferedEther is called.  Risk accepted:  Lido states:   setLastDepositBlock will be used only if re-deploy is needed, so we may add the event for  future versions.   depositBufferedEther emits the Unbuffered event in the Lido contract which is still enough  for indexers, though, will consider the change if an upgrade is needed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.6   Typing Errors", "body": "   NodeOperatorsRegistry._loadOperatorCache returns an error message with a typing error:  INCOSISTENT_ACTIVE_COUNT.   Lido._setProtocolContracts emits the event ProtocolContactsSet.  Acknowledged:  This will be fixed in the next major protocol upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.7   Unused Imports", "body": "  Lido imports SafeMath64.sol which is not used in the contract.  Lido - Lido -   14  DesignLowVersion1RiskAcceptedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                        \fAcknowledged:  This will be fixed in the next major protocol upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.8   memcpy Optimizations", "body": "  The memcpy function in the MemUtils library is quite critical for gas costs. It is called by copyBytes, which  in NodeOperatorsRegistry.assignNextSigningKeys. The function itself also contains a loop, for a total of three nested loops.  nested   called   within   loops   from   turn   in   is   While it is already written in assembly, it can be optimized further. First, let's take a look at the loop.  for { } gt(_len, 31) { } {     mstore(_dst, mload(_src))     _src := add(_src, 32)     _dst := add(_dst, 32)     _len := sub(_len, 32) }  As  it  stands,  there  are  three  variables  which  are  modified  per  loop  iteration.  Ideally,  one  would  only change one variable per iteration, and use a loop bound based on this variable. However, this change would add additional overhead outside the loop, which may not pay off in general. Currently, the loop is only executed 1-3 times per call, as the _len parameter is only ever 48 or 96. One may also consider creating functions specifically for copying byte arrays of length 48 and 96, as this would allow a complete unrolling of the loop.  After the loop, the following code is executed:  if gt(_len, 0) {     let mask := sub(shl(1, mul(8, sub(32, _len))), 1) // 2 ** (8 * (32 - _len)) - 1     let srcMasked := and(mload(_src), not(mask))     let dstMasked := and(mload(_dst), mask)     mstore(_dst, or(dstMasked, srcMasked)) }   As _len is a uint256, it is more efficient to just check the condition if _len {.   The  mask   could   also   be  written   as  shr(0xff..ff,  shl(3,  _len))   or  shr(not(0), shl(3, _len)).  Acknowledged:  Lido states:  We decided to leave the assembly code as is to prevent possible peculiarities.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.9   sharesAmount Can Be Zero", "body": "  Lido - Lido -   15  DesignLowVersion1AcknowledgedDesignLowVersion1RiskAccepted                \fDue  to  rounding  errors,  the  value  returned  by  getSharesByPooledEth  can  be  zero.  In  the  function _submit in Lido, the check sharesAmount == 0 is made. This is assumed to hold either on the first deposit,  or  in  the  case  of  a  complete  slashing.  However,  this  can  also  occur  if  rounding  errors  lead  to getSharesByPooledEth returning 0. Thus, a user would receive a disproportionate amount of shares, as they would get a 1:1 rate of ETH to StETH, despite the share value being lower. Note that with the current state of the live contracts, this can only occur if msg.value == 1.  Risk accepted:  Lido is aware of rounding errors, however chooses not to fix them as they are difficult to correct without sacrificing gas efficiency or backwards compatibility.  Lido - Lido -   16  \f6   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "6.1   Deposits Can Be Blocked by Node Operators", "body": "  DepositSecurityModule  requires  the  keysOpIndex  to  not  change  between  creation  of  a depositBufferedEther transaction and its execution:  uint256 onchainKeysOpIndex = INodeOperatorsRegistry(nodeOperatorsRegistry).getKeysOpIndex(); require(keysOpIndex == onchainKeysOpIndex, \"keys op index changed\");  Since the keysOpIndex can be changed by node operators using addSigningKeysOperatorBH or removeSigningKeysOperatorBH, malicious node operators can delay depositing even when they are not  activated.  The  only  way  to  counter  this  problem  is  to  change  the  rewardAddress  of  such  node operators.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "6.2   No Quorum Sanity Checks", "body": "  LidoOracle and DepositSecurityModule allow the addition of members / guardians and the setting of  a  quorum  that  has  to  be  reached  by  these  entities.  The  quorum  can  however  be  set  to  any  value (except for 0 in the case of LidoOracle) independently of the number of members / guardians.  Lido - Lido -   17  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido/"}, {"title": "5.1   Ineffective Try Catch Statement", "body": "  Try  catch  statements  should  handle  critical  code  parts  that  might  fail  and  their  respective  exertions correctly.  The  used  try  catch  statement  in  authorizationDecrease  simple  fails  silently  if  not successful. Resulting in potential incorrect authorization decrease.  Risk accepted :  Network   Threshold  event AuthorizationInvoluntaryDecreased has been added to track involuntary decreases, it contains a field to indicate whether the call to the application succeeded or not.  decrease   accepts   silently.   fails   The   that   a   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "5.2   Missing Sanity Checks", "body": "  For  security  reasons  stakers  use  different  roles  to  manage  the  stake.  If  different  roles  exist,  it  seems consistent  to  enforce  the  use  of  different  keys.  stake  and  stakeNu  do  not  check  if  the  addresses (operator,  beneficiary,  owner,  authorizer)  are  the  same.  In  a  more  limited  way  this  is  also  the  case  for stakeKeep.  Acknowledged :  Threshold  Network  does  not  consider  that  roles  having  different  addresses  must  be  enforced.  In  their modelling, they always assumed that some stakers will reuse addresses for different roles.  Threshold Network - Threshold Network -   9  DesignCriticalHighMediumRiskAcceptedLowAcknowledgedRiskAcceptedDesignMediumVersion1RiskAcceptedDesignLowVersion1Acknowledged                    \f5.3   Possibly Uninitialized Penalties  function   initializes   The  constructor  the  staking  contract.  However, important  variables  takeDiscrepancyPenalty  and  stakeDiscrepancyRewardMultiplier  are  not  initialized  and need  to  be  set  separately  in  setStakeDiscrepancyPenalty.  The  onlyGovernance  modifier ensures  that  only  the  community  controlled  governance  contract  can  call  this  function.  Calls  from community  driven  governance  contracts  usually  have  a  long  reaction  time  due  to  voting  and  other collective decisions that need to be taken before. Hence, the variables might be uninitialized and result in no penalties for misbehaving.  for   Risk accepted :  These parameters need to be set by governance, Threshold Network believes that in the interim, zero penalty is an acceptable behavior.  Threshold Network - Threshold Network -   10  DesignLowVersion1RiskAccepted        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Unauthorized Top Ups   -Severity Findings   Compiler Version Not Fixed and Outdated   Inefficient Struct Packing   Inefficient processSlashing Loop   Interface File Name Convention    Misleading Variable count    Specifications Mismatch   0  0  1  6  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.1   Unauthorized Top Ups", "body": "  With the current design, anybody can call topUp on any operator (in Kepp, Nu and T). This could lead to KEEP  or  NU  staked  in  legacy  contract,  that  the  owner  may  not  want  to  be  staked  on  the  new  staking contract, ending staked on the new contract.  On Nu this might lead to trolling by calling topUpNu after a user send an unstakeNu transaction and blocking the Nu withdraw through:  1. X calls unstakeNu  2. Y calls topUpNu on X  3. X tries to withdraw from NU legacy staking contract, but it fails because there is still an amount  of NU accounted in the new staking contract  With Keep the issue is more severe as non-malicious behavior could be slashed with a sandwich attack like follows:  1. Someone wants to unstake keep and calls \"unstakeKeep\"  2. The user sends the tx for the Keep legacy contract to \"undelegate\"  3. This tx lands in the men pool and someone front runs it by calling \"topUpKeep\"  4. The undelegate is mined after the top up  5. The attacker calls the notify keep discrepancy function to slash  Threshold Network - Threshold Network -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedDesignMediumVersion1CodeCorrected           \fCode corrected :  A modifier has been added to all three top up functions to restrict the access only to owner and operator.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.2   Compiler Version Not Fixed and Outdated", "body": "  The  solidity  compiler  is  not  fixed  in  the  Checkpoints.sol.  The  version,  however,  is  defined  in  the hardhat.config.js to be 0.8.4.  In the code the following pragma directives are used:  pragma solidity ^0.8.0;  Known bugs in version 0.8.4 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1562  More information about these bugs can be found here:  https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.9 which contains some bugfixes.  Code corrected :  Compiler version is now 0.8.9 and fixed all files.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.3   Inefficient Struct Packing", "body": "  The variable order inside structs is not optimized by the compiler. Hence, tight variable packing needs to be done manually. The struct OperatorInfo could be packed differently, to save two storage slots.  Code corrected :  Struct has been optimized.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.4   Inefficient processSlashing Loop", "body": "  State operations are expensive. Additionally, Threshold Network told that the processSlashing is gas critical.  The  function  processSlashing  reads  and  writes  the  state  variable  slashingQueueIndex multiple times. The loop even does operations in each iteration.  Additionally,  a  sanity  check  for  count  parameter  in  processSlashing  instead  of  a  check  at  every iteration of the for loop could save gas.  Code corrected :  Threshold Network - Threshold Network -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fslashingQueueIndex is now updated only once after the for loop with an internal counter in memory.  The  stopping  condition  of  the  for  loop  has  been  optimized,  maxIndex  is  now  capped  at  max  queue's length and an event is emitted with the effective number of slashes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.5   Interface File Name Convention", "body": "  The file StakingProviders.sol is an interface definition. To be consistent with the naming, the file should be renamed with a leading I.  Code corrected :  Filename updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.6   Misleading Variable count", "body": "  One of the stop conditions of the for loop in processSlashing allows the function to process one more intended.  slashingQueueIndex  <=  maxIndex  should  be pending  slash  slashingQueueIndex  <  maxIndex  if  it  should  match  the  passed  in  count  argument.  One  more unintended iteration also would cost the processor more gas than they may have wanted to spend in the first place.  initially   than   Code corrected :  Loop's stopping condition has been updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "6.7   Specifications Mismatch", "body": "  Specs  of  processSlashing  say  that  processor  can  get  either  4%  or  5%  of  the  slashed  amount, depending on the type of call the application did, but in practice processor always gets 5%, no matter the application called seize or slash.   getStartTStakingTimestamp specs say that result is zero when operator has no stake or  when they was topped-up, but top up functions do not update the staking timestamp  Specification partially changed :  For both mentioned issues the specifications were updated accordingly.  Threshold Network - Threshold Network -   13  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedVersion3                        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "7.1   Applications Share the Same Stake", "body": "  Threshold Network informed that the same stake can be used in different applications. Sharing the same stake  practically  means  that  if  one  application  slashes  or  seizes  all  stake,  all  other  applications  that shared the stake will have no stake left to seize or slash.  Threshold Network - Threshold Network -   14  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/threshold-network/"}, {"title": "5.1   Floating Dependencies Versions", "body": "  The versions of the contract libraries imported as git submodules by the foundry are not fixed. With new versions  being  pushed  to  the  dependency  repositories,  the  imported  code  can  change  (e.g.,  via forge update) and lead to unexpected behavior by the smart contracts of the project.  The version of the foundry dependency can be specified as described here.  Acknowledged:  Circle acknowledged this issue and decided to keep the code unchanged due to the following reason:  The dependencies in repository are pinned git submodules, which won't be changed without explicitly committing a new version to master, so no change is needed.  We would like to highlight that the pinned version of OpenZeppelin dependency is 4.3.1 which includes a vulnerability in signature handling, however the reviewed code is not affected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "5.2   Gas Optimizations", "body": "  Circle - Circle EVM Bridge -   13  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedCodePartiallyCorrectedCodePartiallyCorrectedAcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                    \f1. The  MessageTransmitter  contract  uses  a  mapping  of  boolean  values  to  keep  track  of  used nonces,  which  is  inefficient,  due  to  the  Solidity  compiler  automatically  padding  bool  values  with zeroes  when  writing  them  to  storage.  It  is  more  efficient  to  use  a  mapping  of  a  type  such  as uint256 that takes up an entire storage slot as the bool values anyway cannot be packed in this case.  2. Functions sendMessage and sendMessageWithCaller declare a return variable _nonce but it  remains unused as the variable _nonceReserved is returned in both cases.  3. Attestable  contract  has  a  constant  value  of  65  assigned   to   immutable  variable  signatureLength. Changing its type to constant reduces slightly the gas consumption.  4. At the sending end, MessageTransmitter keeps track of available nonces for each destination domain.  The  contract  could  be  made  more  efficient  in  terms  of  storage  used  if  a  single  global nonce is used for all remote domains.  5. Function  _recoverAttesterSignature  computes  a  hash  of  _message  and  then  calls recover from ECDSA library to get the address of the signer. This function is only called inside the for-loop  redundant computation of the hash for the same message.  function  _verifyAttestationSignatures,   therefore  causing   in   6. The  function  disableAttester  performs  two  calls  to  getNumEnabledAttesters  which performs  an  SLOAD  operation.  Although  the  second  SLOAD  costs  less  (100  gas)  due  to  storage being warm at that point, the function could be optimized by storing the value in memory.  7. Similarly,  the  function  addLocalTokenMessenger  performs  an  unnecessary  SLOAD  when  emitting the event.  8. The location of the following arguments can be changed from memory to calldata to make them and  MessageTransmitter.sendMessage;   messageBody  more  newMessageBody in MessageTransmitter.replaceMessage.  gas-efficient:   in   9. The function encodeHex in the library TypedMemView always checks if the iterator is not on the  16th byte:  for (uint8 i = 31; i > 15; i -= 1) {     uint8 _byte = uint8(_b >> (i * 8));     first |= byteHex(_byte);     if (i != 16) {         first <<= 16;     } }  As an improvement, the loop can iterate in the range i > 16 so the if statement inside the loop can be removed. The same optimization is possible for the next loop which iterates over the lower 16 bytes. By doing so, gas consumption would be decreased.  Acknowledged:  Circle has applied most of the optimizations listed above. More specifically, optimizations 1-6 and 8 were implemented in the updated codebase. Optimizations 7 and 9 were acknowledged but not addressed in code. We detail the fixes:  1. usedNonces is changed to be a mapping of bytes32 to uint256.  2. Circle has corrected both sendMessage and sendMessageWithCaller.  3. signatureLength is changed to be a constant.  4. MessageTransmitter  keeps  track  of  the  next  available  nonce  via  keeping  a  scalar  variable,  namely nextAvailableNonce.  Circle - Circle EVM Bridge -   14  \f5. In  _verifyAttestationSignatures  the  digest  of  the  message  is  firstly  calculated  and  sent  down to each call of _recoverAttesterSignature.  6. disableAttester  fetches  length  of  the  enabledAttesters  and  stores  it  in  a  memory  variable,  instead of accessing the storage twice.  7. Circle  has  acknowledged  this  optimization  but  has  decided  to  keep  the  code  unchanged  as  the  function addLocalTokenMessenger is not expected to be called often.  8. messageBody   originalMessage  MessageTransmitter.sendMessage,  newMessageBody in MessageTransmitter.replaceMessage are changed to calldata.  in   and  9. Circle has decided to keep the TypedMemView library as-is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "5.3   Inconsistent Natspec Descriptions", "body": "  The natspec description of the following functions is not consistent with the implementation:  1. _sendMessage: @dev Increment nonce, ... is not aligned with the implementation.  2. _getLocalToken:  @dev  Reverts  if  unable  to  find  an  enabled  local  token...,  but the implementation does not revert.  3. onlyWithinBurnLimit: ... burn limit per-transaction for given 'burnToken'. The modifier only checks that the limit is not exceeded in a single function call, however, if multiple calls are executed within a transaction, the limit per-transaction is not enforced.  4. BurnMessage library: version field is declared as 4 bytes, but the type is set to uint8 instead of  uint32.  5. To fetch the 12 bytes containing loc, a variable of TypedMemView should be shifted 120 bits (3 empty + 12 len = 15 bytes) to the right and be masked. The comment inside the assembly block has wrongly stated 12 bytes of the loc instead of len.  Code partially corrected:  The reported inconsistencies 1-4 have been fixed in the updated codebase, while the last one remains unchanged.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "5.4   Missing Sanity Checks", "body": "  The following functions set important state variables or parameters, but do not perform any sanity check on input parameters:  1. MessageTransmitter.constructor.  2. TokenMessenger.constructor.  3. MessageTransmitter.setMaxMessageBodySize.  4. newMintRecipient in TokenMessenger.replaceDepositForBurn.  Code partially corrected:  Circle - Circle EVM Bridge -   15  CorrectnessLowVersion1CodePartiallyCorrectedDesignLowVersion1CodePartiallyCorrected                \fchecks   Sanity  and in  TokenMessenger.replaceDepositForBurn listed above, however no sanity checks were added for points 1 and 3.  TokenMessenger.constructor   added   were   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "5.5   Potential Event Reordering Due to Reentrancy", "body": " in MessageTransmitter  The function sendMessage does not have any access restriction, and the caller can pass any arbitrary value for recipient. On the other side of the bridge, the function receiveMessage gives execution to recipient and emits an event afterward. Therefore, a malicious recipient could reenter the contract causing events to be emitted in an inconsistent order:  require(     IMessageHandler(_m._recipientAddress()).handleReceiveMessage(         _sourceDomain,         _sender,         _messageBody     ),     \"handleReceiveMessage() failed\" );  // Emit MessageReceived event emit MessageReceived(     msg.sender,     _sourceDomain,     _nonce,     _sender,     _messageBody );  Acknowledged:  Circle acknowledged the issue but has decided to keep the code unchanged.  Circle - Circle EVM Bridge -   16  SecurityLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Default Optimizer Configuration   Inconsistent Type Used for Nonce    Missing Event in Ownable   0  0  0  6   Unchecked Return Value for Functions From TypedMemView    Unrelevant Indexed Event Fields    Wrong Values Emitted in Event   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.1   Default Optimizer Configuration", "body": "  The compiler optimizer is not enabled explicitly by the foundry configuration, hence the default optimizer enabled by the foundry with 200 runs is used:  [profile.default] src = 'src' out = 'out' libs = ['lib']  The  optimizer  uses  the  specified  number  of  runs  to  perform  a  trade-off  between  deployment  cost (bytecode  size)  versus  execution  costs.  A  high  number  of  runs  indicates  to  the  optimizer  that  the reduction of execution costs has a higher priority than deployment costs.    The configuration file foundry.toml has been updated to enable the optimizer with 10_000 runs.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.2   Inconsistent Type Used for Nonce", "body": "  The  contract  MessageTransmitter  uses  type  uint64  for  storing  nonces,  however,  the  internal function _hashSourceAndNonce uses uint256 for the argument _nonce.  Circle - Circle EVM Bridge -   17  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                 \f  Type  of  _nonce  in  _hashSourceAndNonce  is  changed  to  uint64  and  is  consistent  throughout  the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.3   Missing Event in Ownable", "body": "  The constructor of Ownable sets the deployer of the contract as owner, however, the respective event is not emitted.    The constructor of Ownable now calls the internal function _transferOwnership which sets the new _owner and emits the respective event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.4   Unchecked Return Value for Functions From", "body": " TypedMemView  The  functions  ref  and  slice  of  the  library  TypedMemView  return  a  memory  view  of  type  bytes29. However,  both  functions  can  return  NULL  which  represents  an  invalid  type  (ff_ffff_ffff)  if  the memory  is  malformed.  The  calling  functions  in  MessageTransmitter,  TokenMessenger  and Message do not check for the invalid type.    libraries   functions The  _validateMessageFormat and _validateBurnMessageFormat. These functions are now used to validate the return values from functions ref and slice from the library TypedMemView.  extended  with   BurnMessage   Message   been   have   and   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.5   Unrelevant Indexed Event Fields", "body": "  Only relevant fields of the events should be indexed, the ones which it makes sense to search for. The following events index also uint values:  1. amount in TokenMessenger.DepositForBurn  2. amount in TokenMessenger.MintAndWithdraw  3. oldSignatureThreshold   and   newSignatureThreshold   in  Attestable.SignatureThresholdUpdated  4. burnLimitPerTransaction in TokenController.SetBurnLimitPerTransaction  5. newMaxMessageBodySize in MessageTransmitter.MaxMessageBodySizeUpdated  Circle - Circle EVM Bridge -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fOn the other hand, the event OwnershipTransferred does not index its argument. EVM opcodes for logging  events  with  more  indexed  arguments  consume  more  gas.  We  suggest  for  each  event  field reevaluate if indexing is necessary.    All events listed above were revised such that uint arguments are no longer indexed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.6   Wrong Values Emitted in Event", "body": "  Function  updateAttesterManager  uses  the  same  variable  newAttesterManager  in  the  emitted event. The natspec of the event specifies that the first parameter is the address of the previous attester manager, while the second parameter is the new attester manager.  Code partially corrected:    to  pass  msg.sender  and The  function  updateAttesterManager  has  been  revised  in  newAttesterManager  as  parameters  to  the  event  AttesterManagerUpdated.  However,  the  first parameter  msg.sender  is  the  owner  of  the  contract,  and  not  necessarily  the  previous  manager  as described in the event definition.    In  attesterManager role:  ,  the  following  code  is  used  to  emit  the  previous  and  new  addresses  for  the  address _oldAttesterManager = _attesterManager; _setAttesterManager(newAttesterManager); emit AttesterManagerUpdated(_oldAttesterManager, newAttesterManager);  Circle - Circle EVM Bridge -   19  CorrectnessLowVersion1CodeCorrectedVersion2Version3        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.1   Compiler Version Not Fixed and Outdated", "body": "  The  solidity  compiler  is  fixed  only  in  contracts  Ownable,  Pausable  and  Rescuable,  while  other contracts use the following pragma directive:  pragma solidity ^0.7.6;  Although no later compiler version 0.7.x exist, it is a best practice to fix the compiler version in contracts or configuration file.  Known bugs in version 0.7.6 are listed here.  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.17 which contains some bugfixes. However, version 0.8 introduced breaking changes and would require heavy refactoring of the contracts.   changes: All contracts now use the following pragma directive:  pragma solidity 0.7.6;  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.2   Non-canonical Conversion of Bytes to", "body": " Address  The  function  Message.bytes32ToAddress  implements  the  following  statement  to  perform  the  type conversion:  function bytes32ToAddress(bytes32 _buf) public pure returns (address) {     return address(uint160(uint256(_buf))); }  Note that due to downcasting, higher bits of _buf will be omitted. Thus, it is possible to have different input values _buf map to the same address.   changes: Circle has decided to emphasize this behavior in the code by appending the following  description to the function's natspec:  * @dev Warning: it is possible to have different input values _buf map to the same address. * For use cases where this is not acceptable, validate that the first 12 bytes of _buf are zero-padding.  Circle - Circle EVM Bridge -   20  NoteVersion1Version2NoteVersion1Version2      \f7.3   Overflow and Underflow Occurring in TypedMemView  The  function  TypedMemView.index  takes  as  the  third  argument  the  length  of  the  returned  value  in bytes _bytes, which is of type uint8. The length in bits is computed as follows:  uint8 bitLength = _bytes * 8;  If _bytes is 32, the multiplication above overflows as the result 256 cannot be stored in a variable of type  uint8,  hence  bitLength  stores  0.  Furthermore,  when  bitLength  is  passed  to  function leftMask an underflow occurs in the following assembly code:  assembly {     mask := sar(         sub(_len, 1),         ...     ) }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.4   Potential Single Points of Failure", "body": "  Circle  EVM  Bridge  relies  on  a  centralized  attestation  service  (attesters)  to  guarantee  the  integrity  of messages  transmitted  between  chains.  The  protocol  assumes  that  an  adversary  cannot  compromise enough attesters (signatureThreshold) at the same time, otherwise, the bridge becomes vulnerable.  Besides  the  assumption  above,  we  would  like  to  highlight  below  the  accounts  that  are  potential  single points of failure for the security of the bridge.  Message  Transmitter:  Any  account  with  role  owner  or  attesterManager  should  be  carefully protected.  If  any  account  with  these  roles  gets  compromised,  it  can  freely  enable  new  attesters  and execute arbitrary cross-chain messages. Furthermore, the role pauser is critical to be protected in order to keep the bridge operational and avoid denial-of-service (DoS) attacks.  Token Messenger: The account with the role owner should be carefully protected, as if this account gets  compromised,  it  can  set  arbitrary  addresses  as  token  messengers  in  remote  domains  and  then process malicious messages.  Token Minter: The accounts with roles owner and tokenController should be carefully protected. If  any  of  these  accounts  get  compromised,  the  mapping  remoteTokensToLocalTokens  can  be manipulated, which can consequently create severe issues, e.g., an attacker can burn low value tokens in one chain but mint the same amount in high value tokens in the other chain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.5   Return Value of Burn Function", "body": "  The  system  supports  tokens  that  implement  the  IMintBurnToken,  i.e.,  functions  transfer, transferFrom and mint return a boolean value. However, burn function is assumed to not return a  Circle - Circle EVM Bridge -   21  NoteVersion1NoteVersion1NoteVersion1            \fvalue  but  revert  if  unsuccessful.  This  behavior  is  in  line  with  the  implementations  of  USDC  and ERC20Burnable from OpenZeppelin.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.6   Signature Threshold Restrictions", "body": "  The documentation states that the threshold for the required signatures should not be below 2, however, this is not enforced by the codebase. On deployment, the constructor of Attestable contract takes only one attester address as an argument and sets signatureThreshold = 1.  Furthermore,  the  function  setSignatureThreshold  does  not  enforce  that  the  threshold  is  set  to  at least 2. Circle is aware of this behavior and does not intend to enforce the minimum threshold in code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.7   Visibility Modifiers for Constructors", "body": "  Contracts  Attestable  and  Ownable  declare  the  visibility  of  constructors  as  public,  however,  such visibilities in compiler version 0.7.6 are obsolete. More information.   changes: The visibility for constructors has been removed in the updated codebase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "7.8   Attestable._recoverAttesterSignature", "body": " Function Visibility Can Be Pure  The  modifier  of  the  function  _recoverAttesterSignature  can  be  changed  to  pure,  as  it  neither writes nor reads the storage of the contract.   changes: The visibility of the function above has been changed to pure.  Circle - Circle EVM Bridge -   22  NoteVersion1NoteVersion1Version2NoteVersion1Version2            \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/circle-cross-chain-transfer-protocol-cctp/"}, {"title": "6.1   Impossibility to Create One-Side Token1", "body": " Liquidity  The DeposiorUniV3 funnel has a uniswapV3MintCallback() function for properly integrating with Uniswap V3 and move the funds. However, it only moves funds if the owed amount in token0 is greater than 0. Hence, if the current tick is outside of the position's tick range so that it leads to one-sided liquidity in  token1,  no  funds  will  be  transferrable.  Ultimately,  one-sided  token1  liquidity  cannot  be  added.  Thus, deposits could be temporarily DOSed.  CS-MKALLOC-002    amt1Owed is now used for transfers of token1.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "6.2   Incorrect Uniswap V3 Path Interpretation", "body": "  The swapper callback contract for UniswapV3 interprets the last tokens as follows:  lastToken := div(mload(sub(add(add(path, 0x20), mload(path)), 0x14)), 0x1000000000000000000000000)  CS-MKALLOC-003  Namely, it loads the last 20 bytes as the last token. However, the path may have some additional unused data so that the last token does not have any effect on the execution. Consider the following example:  1. The path is encoded as [srcToken fee randomToken dstToken].  2. The swapper will interpret dstToken as the last token.  3. However, in UniswapV3, randomToken will be received.  Maker - DSS Allocator -   12  CriticalHighMediumLowCodeCorrectedCodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                  \f4. In case no slippage requirements for the amount out are present, randomToken will be received  successfully and will be stuck in the swapper contract.  Ultimately,  the  path  is  wrongly  interpreted  which  could,  given  some  configurations,  lead  to  tokens  lost unnecessarily due to bad input values.    The check towards the correctness of path encoding has been removed, as it provides a false sense of security. Ultimately, the swap is protected by the minimum output token amount requirement.  Maker states:  These checks were only meant to provide more explicit revert reasons for a subset of (common) path misconfigurations and were not meant to catch all possible incorrect path arrays. Ultimately the \"\"Swapper/too-few-dst-received\"\" check is the only one that matters. But since that seems to cause confusion, we just removed the checks.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "6.3   Gas Inefficiencies", "body": "  Below is a non-exhaustive list of gas inefficiencies:  1. In AllocatorVault.wipe(), the call vat.frob() takes address(this) as an argument for the gem balance manipulation. However, due to the gem balance not being interacted with, using address(0) may improve gas consumption minimally.  2. In  the  withdrawal  and  deposit  functions  of  the  UniV3Depositor,  an  unnecessary  MSTORE operation is performed when caching era into memory. Using only the SLOAD could be sufficient.  CS-MKALLOC-004    Code has been corrected to optimize the gas efficiency.  Maker - DSS Allocator -   13  InformationalVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "7.1   Lack of Sanity Checks", "body": "  The code often lacks sanity checks for setting certain variables. The following is a non-exhaustive list:  1. On deployment, the conduit mover does not validate whether the ilk and the buffer match against  CS-MKALLOC-001  the registry.  2. Similarly, that is the case for the allocator vault.  Maker states:  The sanity checks are done as part of the init functions (to be called in the relevant spell).  Maker - DSS Allocator -   14  InformationalVersion1Acknowledged    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "8.1   1T NST Minting", "body": "  The  documentation  specifies  that  a  maximum  of  1T  NST  should  be  placed  and  that  at  most  1T  NST should be mintable. However, that may not be the case if the spotter has mat and par set to unsuitable values. Technically, Vat.rate could be decreasing (depending on the jug). Hence, with a decreasing rate, more than 1T NST could be minted. Additionally, governance is expected to provide the allocator vault with a gem balance through Vat.slip(). Calling this multiple times would allow to re-initialize the allocator vault multiple times to create more ink than intended (and, hence, allowing for more debt than expected).  Ultimately, governance should be careful when choosing properties.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "8.2   Deposit and Withdraw Share the Same", "body": " Capacity  The governance can set a PairLimit in DepositorUniV3, which limits the maximum amount of a pair of tokens that can be added or removed from the pool per era. Instead of setting two capacity parameters for adding liquidity and removing liquidity respectively, both actions share the same capacity.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "8.3   Potentially Outdated Debt Estimation", "body": "  In contract AllocatorVault, debt() returns an estimation of the debt that is on the Vault's urn. This estimation  could  be  outdated  if  the  vat's  rate  has  not  been  updated  by  the  jug.drip()  in  the  same block.  The getter debt() has been removed (along with line() and slot()). Maker states that they are not strictly needed and can be implemented in another contract as well.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "8.4   Shutdown Not Considered", "body": "  The shutdown was not in scope and users should be aware that consequences of a potential shutdown have not been investigated as part of this audit.  Maker - DSS Allocator -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f8.5   Topology May Break the Intended Rate Limit  The keepers' ability to move funds between conduits/buffer and swapping tokens is limited by the triplets (from, to, gem) and (src, dst, amt) respectively. However, the actual funds flow between from and to (src and dst) could exceed the config dependent on the topology of the settings.  Assume  there  is  a  config  that  limits  moving  NST  between  conduits  CA  and  CB  to  100  per  hop: (CA,  CB,  100).  If  there  are  another  two  configs  (CA,  CX,  40)  and  (CX,  CB,  60)  exist,  then keepers can move at most 100 + 40 = 140 DAI from CA to CB per hop.  The  same  situation  applies  to  Swapper.  Therefore,  the  topology  of  the  configs  should  be  carefully inspected.  Maker states:  The rate limit for each swap/move pair is an authed configuration of the allocator proxy. It is therefore assumed to know what it is doing and is allowed to set any configuration regardless of paths or duplication.  Maker - DSS Allocator -   16  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-allocator/"}, {"title": "6.1   No Message Relayed on claim", "body": "  transmitted   Anytime  csToken.totalSupply()  or  funds.currentDeposit  are  changed,  the  updated  values function  does  not  call should  be  sendMessageToChild. The claim function has the enforceAndUpdateBalance modifier, which in turn  calls  _updateBalance.  This  function  may  modify  funds.currentDeposit,  and  hence  a message should be relayed to the child contract.  the  child  contract.  However,   the  claim   to   Note that the claim function is the only function with the enforceAndUpdateBalance modifier which does not call sendMessageToChild. Since the modifier itself can modify funds.currentDeposit, it may make sense to include the call to sendMessageToChild in the modifier itself.  ClayStack - ClayStack Matic -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion3CodeCorrected          \f  A message is now relayed at the end of the claim function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.2   Decoding Inefficiencies", "body": "  The ClayTunnel contract puts any message it receives directly in storage. When the stored amounts are retrieved,  they  have  to  be  decoded  each  time.  This  duplicates  effort,  as  well  as  incurring  additional storage  operations  due  to  the  use  of  the  generic  bytes  type.  A  stored  bytes  array  that  contains  64 bytes uses up 3 storage slots, one for the length and then two more for the contained values. Instead, it would  be  more  efficient  to  decode  the  message  when  receiving  it,  then  putting  the  decoded  values  in storage.  Additionally, in _processMessageFromRoot, it is possible to change the type of the data parameter from  bytes  memory  from processMessageFromRoot, where the argument passed is also a bytes calldata. This saves the effort of copying the bytes from calldata to memory.  to  bytes  calldata,  as   is  only  ever  called   function   the     The  relayed  variables  are  now  decoded  when  the  bridged  message  is  received,  and  the  decoded variables  then  persisted  in  storage.  The  data  parameter  was  changed  from  bytes  memory  to bytes calldata.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.3   Redundant Function", "body": "  The  sendMessageToRoot  function  is  redundant,  as  the  root  ClayMain  contract  cannot  receive messages.  The _sendMessageToRoot function in the FxBaseChildTunnel abstract contract is similarly redundant.  The MessageSent event in FxBaseChildTunnel is only used in the above functions, hence it could be removed.    The redundant functions and event were removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.4   Redundant Storage Variables", "body": "  The latestStateId and latestRootMessageSender storage variables in the ClayTunnel contract are not necessary for operation. Additionally, the latestRootMessageSender variable will only ever be set to the address of the ClayMain contract. Removing these redundant variables would reduce the execution cost of _processMessageFromRoot significantly.  ClayStack - ClayStack Matic -   12  DesignLowVersion3CodeCorrectedDesignLowVersion3CodeCorrectedDesignLowVersion3CodeCorrected                        \f  The  latestRootMessageSender  variable  was  removed.  latestStateId  is  now  used  to  enforce strictly increasing state IDs of relayed messages, meaning a reordering of messages due to validators cannot result in the child contract being set to an older state.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.5   Variables Could Be Immutable", "body": "  The  storage  variable  fxChild  in  FxBaseChildTunnel  could  be  immutable,  as  it  is  only  ever  set  in  the constructor.  This  would  reduce  the  number  of  storage  operations  made  when  processing  bridged messages.  Similarly, the storage variable fxRootTunnel can only be set once, in the setFxRootTunnel function. As  this  variable  should  be  known  at  deployment,  and  it  must  be  set  in  order  to  make  the  contract operational, it could also be made immutable and set in the constructor.    The fxChild and fxRootTunnel variables were made immutable and are both set in the constructor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.6   Incorrect Permissions", "body": "  The setDefaultLiquidity function has a doc comment which states it should only be callable with the TIMELOCK_ROLE. However, the implementation checks if the caller has the CS_SERVICE_ROLE.  /**  * ...  * @notice Only `TIMELOCK_ROLE` callable.  * ...  */ function setDefaultLiquidity(uint256 value) external onlyRole(CS_SERVICE_ROLE) {     require(value < PERCENTAGE_BASE, \"CMO06\");     defaultLiquidity = value; }  Specification Changed:  The doc comment was changed to specify the function to be only callable with the CS_SERVICE_ROLE.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.7   Inefficient Modifier", "body": "  ClayStack - ClayStack Matic -   13  DesignLowVersion3CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fThe  CsToken  contract  makes  use  of  the  onlyClayMain  modifier,  which  needs  to  know  what  the address of the ClayMatic contract is. Instead of implementing a storage value that can only be set once, an  immutable  variable  could  be  used.  This  would  also  be  far  more  gas-efficient,  since  immutable variables do not incur storage reads.    The storage variable was made immutable and the onlyOnce modifier removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.8   Logic Contract", "body": "  The ClayMatic and RoleManager contracts have problems with their UUPS logic contracts:  1. The initialize function is unprotected on the logic contracts.  2. The  upgradeTo  function  overrides  the  UUPSUpgradeable  function,  but  does  not  use  the  onlyProxy modifier.  Since there are no unprotected delegateCalls available, the effect of these problems is limited. But one can set the storage variables of logic contracts to any values. Consider using onlyProxy for functions that shouldn't be called on logic contracts directly.    The onlyProxy modifier was added to the initialize and upgradeTo functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.9   Missing Check", "body": "  The comment on the function setMaxWithdrawNodePercentage states:  /**  * ...  * Requirements:  * - `value` can not be zero.  * ...  */ function setMaxWithdrawNodePercentage(uint256 value) external onlyRole(CS_SERVICE_ROLE) {     require(value <= PERCENTAGE_BASE, \"CMO06\");     maxWithdrawNodePercentage = value; }  However, there is no check to make sure value is not equal to zero.    A check was added to make sure value is not equal to zero.  ClayStack - ClayStack Matic -   14  SecurityLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                  \f6.10   Missing whenNotPaused in Migrate Delegation  for All  balance  affecting  migrateDelegation,  this  seems  like  an  oversight  if  pause  is  meant  to  be  used  in  emergency  or upgrade situations where critical contract state should not change in between upgrades.  the  whenNotPaused  modifier  applied  except   functions  have     The whenNotPaused modifier was added to the migrateDelegation function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.11   No Limit On Withdrawal and Deposit Fee", "body": " Amounts  There is currently no limit on any fee amounts besides being below 100%, but this should not be the case from  both  a  trust  and  correctness  perspective.  The  holder  of  TIMELOCK_ROLE  could  set  instant  or regular withdrawal fees to 100% to prevent anyone from withdrawing, or increase deposit fee to 100% to basically prevent anyone from staking any more funds without losing them all, effectively disabling those functions in a round-about way.  Consider setting hard limits in the contract beyond which fees cannot be raised without a total contract upgrade.    Maximum values were added to all fee types.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.12   Possible Underflow", "body": "  In the function _balanced the following check is done:  uint256 stakingFlow = (underlyingToken.balanceOf(address(this)) + funds.stakedDeposit) / 1e10; require(stakingFlow - 1e6 <= userFlow && userFlow <= stakingFlow + 1e6, \"CMB01\");  However,  if  underlyingToken.balanceOf(address(this))  +  funds.stakedDeposit  is  less than 1e16, this will result in an underflow and revert, despite not necessarily being an invalid state.    The code was refactored so the underflow is no longer possible.  ClayStack - ClayStack Matic -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.13   Reuse balanceOf Result When Possible  There  are  various  functions  which  call  underlyingToken.balanceOf(address(this))  multiple times. While in some cases, the balance does change and the additional cross-contract call is necessary, in others it is not. Therefore, the redundant calls could be omitted to save gas.  1. In autoBalance and _balanced, the balance of the contract is queried twice without any balance  change in between.  2. In _sequentiallyStake, the balance of the contract is queried once per loop iteration. While the balance  can  change  between  iterations,  it  may  instead  be  possible  to  check  that  the  balance  is greater than the total amount to stake, rather than checking individually for each staking operation.    1. The mentioned functions were updated to query the balance only once.  2. The total amount to stake is now compared to the balance at the start of the function, instead of  once per loop iteration.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.14   Staking Issues", "body": "  When  autobalance  is  run,  if  the  additional  amount  to  stake  is  consistently  smaller  than  the overStakingThreshold,  the  same  validator  will  be  chosen  every  time.  This  is  because  the activeStakingNode  does  not  change  if  only  the  first  node  is  used.  Thus,  the  amounts  staked  per validator  will  not  converge  if  the  amounts  to  stake  per  balancing  operation  are  consistently  below overStakingThreshold.    The  activeStakingNode  is  now  advanced  by  one  position  at  the  end  of  the  function  to  avoid  the mentioned issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.15   Storage Operations in Loops", "body": "  Many  different  functions  contain  loops  which  access  storage  variables.  Rather  than  reading  a  storage variable  once  per  loop  iteration,  it  is  more  gas-efficient  to  read  it  once  before  the  loop  and  cache  the value in a local variable.  There are also loops which write to storage variables. Again, rather than writing to storage directly in the loop, it's more gas-efficient to write to a local variable and move the final value to storage after the loop.  These optimizations can be applied in the following functions:  1. In  the  function  claim,  the  value  withdrawOrders[msg.sender]  can  be  stored  in  a  variable  outside the loop and reused.  2. In   getMaxWithdrawAmountCs,   the   storage   values   maxNodesToWithdraw   and  maxWithdrawNodePercentage can be cached.  ClayStack - ClayStack Matic -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f3. In  _sequentiallyStake,   the  number  of  storage  writes   to  activeStakingNode  and funds.stakedDeposit  can  be  reduced  significantly.  Additionally,  the  values  totalPoints, overStakingThreshold, stakeManager and underlyingToken could be cached. Note that it may not be possible to apply all these optimizations without causing a \"Stack too deep\" compilation error.  4. In _sequentiallyUnstake, the number of writes to activeUnstakingNode can be reduced. The  values  of  maxNodesToWithdraw  and  maxWithdrawNodePercentage  can  be  cached  to reduce storage reading operations.  5. In  _getMaxWithdrawAmount,   the  maxNodesToWithdraw can be cached.  values   of  maxWithdrawNodePercentage   and  6. In addNodes, the number of writes to totalPoints can be reduced by calculating the value in a local variable and writing to storage after the loop. Similarly, a local variable could be introduced to hold  the  value  of  countStakingNodes  and  the  final  value  written  back  only  at  the  end.  Lastly, stakeManager could be cached so it only has to be read once before the loop.  7. In autoBalance, _updatedStaked, _isNodeActive and _updateNodePoints, the value of  activeNodes.length can be stored locally to reduce storage reads.    The suggested changes were made. In the case of _sequentiallyUnstake, maxNodesToWithdraw was not cached due to the \"Stack too deep\" compilation error.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.16   Validator Contract Check Not Strict Enough", "body": "  Inside of ClayMatic.addNodes, the validity of a validator is checked in the following way:  require(stakeManager.isValidator(val.validatorId()) && !val.locked(), \"CMO10\");  Both  values  validated  against  are  sourced  from  the  supplied  contract  which  could  just  be  a  malicious contract  lying  about  being  a  validator.  A  check  with  stronger  correctness  would  be  to  require  that  the following is true:  stakeManager.getValidatorContract(validatorId) == val  This would prevent adding an invalid validator contract by mistake.    The suggested check was implemented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.17   Wrong Variable Logged", "body": "  In  the  autoBalance  function,  any  accrued  fees  are  transferred  to  the  vault.  Additionally,  an  event  is emitted  to  log  the  transferred  fees.  However,  the  wrong  variable  is  used  for  the  event  so  the  emitted value will always be zero.  ClayStack - ClayStack Matic -   17  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \fif (funds.accruedFees != 0) {     uint256 accruedFees = funds.accruedFees;     funds.accruedFees = 0;     underlyingToken.safeTransfer(vaultManager, accruedFees);     emit LogTransferVault(vaultManager, funds.accruedFees); }    The correct variable is now used to log the event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.18   Consider Using Modifiers for _Balanced and", "body": " _updateBalance Functionality  The calls to _balanced and _updateBalance could be more cleanly implemented via a modifier like the following:  modifier enforceAndUpdateBalance {  _updateBalance();  _;  _balanced(); }  It would prevent needing to manually ensure both are called, in the right order and priority, in any future update to the code and simply enforce the presence of this modifier on the relevant functions.    The suggested modifier was introduced and applied to all relevant functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "6.19   Unnecessary Require", "body": "  In the claim function, the following require statement is unnecessary:  require(amountAvailable >= userAmount + payableFee, \"CMC02\");  The  value  of  userAmount  is  essentially  calculated  as  receivedAmount  -  payableFee.  The  current balance  (amountAvailable)  cannot  be  smaller  than  the  amount  received,  therefore  this  check  will never fail.    The unnecessary require statement was removed.  ClayStack - ClayStack Matic -   18  NoteVersion1CodeCorrectedNoteVersion1CodeCorrected            \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "7.1   Child Contract Is Not Upgradable", "body": "  The  child  ClayTunnel  contract  is  not  upgradable.  Therefore,  if  additional  functionality  were  to  be implemented in the ClayMain contract, which needed to be reflected on the Polygon network, a new child contract would have to be deployed. Hence, any users or protocols relying on the child contract should be aware that the address could change in the future.  ClayStack - ClayStack Matic -   19  NoteVersion3  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/claystack-matic-march-2022/"}, {"title": "5.1   Tokens EIP-721 Typehash", "body": "  The EIP-712 defines set of rules, how the solidity structs should be hashed.  Current LibERC721LazyMint and LibERC1155LazyMint contracts have few violations of this standart:   Mint1155Data struct has uri field, but tokenURI is used in MINT_AND_TRANSFER_TYPEHASH  In  Mint1155Data  MINT_AND_TRANSFER_TYPEHASH, the supply field follows the tokenId field.  supply   follows   struct,   field   the   the   uri   field.   In   Mint721Data struct has uri field, but tokenURI is used in MINT_AND_TRANSFER_TYPEHASH  According to EIP-712, such mismatches are not compatible with the standard.  Code partially corrected:  Field uri was renamed to tokenURI in both contracts. Currently, these contracts are already deployed and changing the supply and tokenId order cannot be fixed.  Rarible Inc. - Staking and Tokens -   8  DesignCorrectnessCriticalHighMediumLowCodePartiallyCorrectedCorrectnessLowVersion1CodePartiallyCorrected             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  2  13  -Severity Findings  -Severity Findings  -Severity Findings   ERC721 Use of Unsafe Methods    Staking Formula Differs From Specificaiton   -Severity Findings   Mismatch in Mint Data Specification    Code Is Not Compilable   Initialization of Staking Contracts Not According to OZ Guidelines   Initializer Not Using Unchained Initializer of Ancestors    Missing updateAccount Function in ERC1155Lazy    Solidity Compiler Versions    Staking Coefficient Can Make Stake Line Longer    Staking Contracts Are Missing __gap Field    Staking Events Data    Staking Exposing Getters    Staking Is Possible When Migrating    Staking Restake Can Cut the Corner    Staking Slope Period Definition   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.1   ERC721 Use of Unsafe Methods", "body": "  The ERC721 standard focuses on ensuring that token transfers do not lock / loose tokens. That is why the  use  of  \"safe\"  functions  such  as  safeTransferFrom  was  introduced.  This  applies  not  only  to transfers,  but  to  minting  as  well.  However,  the  implementation  of  mintAndTransfer  in  the  contract ERC721Lazy does not use the \"safe\" _safeMint but the _mint function, whose use is discouraged.    Function mintAndTransfer now uses _safeMint function.  Rarible Inc. - Staking and Tokens -   9  CriticalHighMediumCodeCorrectedSpeci\ufb01cationChangedLowSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrected            \f6.2   Staking Formula Differs From Specificaiton  The specs define the formula as:  stake = k * tokens. K = (0.07 + 0.93 * (cliffPeriod / 104) ^ 2 + 0.5 * (0.07 + 0.93 * (slopePeriod / 104) ^ 2)).  This formula differs from solidity implementation, mostly due to use of following constants:  uint256 constant ST_FORMULA_MULTIPLIER = 1081000;       //stFormula multiplier = TWO_YEAR_WEEKS^2 * 100 uint256 constant ST_FORMULA_COMPENSATE = 1135050;       //stFormula compensate = (0.7+0.35) * ST_FORMULA_MULTIPLIER uint256 constant ST_FORMULA_SLOPE_MULTIPLIER = 465;     //stFormula slope multiplier = 0.93 * 0.5 * 100 uint256 constant ST_FORMULA_CLIFF_MULTIPLIER = 930;     //stFormula cliff multiplier = 0.93 * 100   ST_FORMULA_MULTIPLIER should be 1086000 to comply with specs.   ST_FORMULA_COMPENSATE should be 1135680 to comply with specs.   ST_FORMULA_SLOPE_MULTIPLIER should be 46.5 to comply with specs.   ST_FORMULA_CLIFF_MULTIPLIER should be 93 to comply with specs.  Specification corrected:  Specificaion  of  formula  was  changed  in  commit  6167554ff40b7b7f9f6d1ce808fd7d62d04ab3f6 to:  stake = K * tokens / 1000; K = ( 11356800 + 9300 * (cliffPeriod)^2 + 4650 * (slopePeriod)^2) / 10816;  Code  was  adjusted  in  commit  888761566077d51937cf7676417ebe0839f2bdfe  implemented according to this specificaion.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.3   Mismatch in Mint Data Specification", "body": "  Mint721Data   The  and LibERC1155LazyMint.sol  were  updated.  Yet,  the  documentation  in  tokens/readme.md  was  not updated. The documentation specifies that the mint data structs have element uri, while in code uri was changed to tokenURI.  LibERC721LazyMint.sol   Mint1155Data   structs   and   in   Moreover,  both  structs  have  an  element  royalties,  tokens/readme.md. That is a mismatch in the specification.  that  are  named  as  fees   in   the  Specification corrected:  The names were fixed in version 3. Names in specs match the ones in code now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.4   Code Is Not Compilable", "body": "  Rarible Inc. - Staking and Tokens -   10  DesignMediumVersion1Speci\ufb01cationChangedCorrectnessLowVersion2Speci\ufb01cationChangedDesignLowVersion1Speci\ufb01cationChanged                      \fStaking contract and token contracts are not compilable due to imports of @rarible libraries. Node pulls outdated libraries that are not compatible with the new code. If imports by path are used, the code would have been compilable. Not using direct imports by path can lead to compilations with outdated libraries. Taking into account the monorepo structure of rarible github, it is safer to use direct path imports.  Specification corrected:  The compilation instructions were added to the readme.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.5   Initialization of Staking Contracts Not", "body": " According to OZ Guidelines  The initialization style of the contract is not according to guidelines from OpenZeppelin libary. In contract StakingBase a __StakingBase_init function is defined as public function. Usually such functions are defined as private and only most derived contract defines  public function initialize where the private chained/unchained init function are called.  Moreover, the initializer should call all unchained initializers of all ancestors of the contract. Currently the __StakingBase_init calls __Ownable_init_unchained but not __Context_init_unchained. The latter has no effect in current version of the OZ library, but that can change in future.    __StakingBase_init  was  renamed  to  __StakingBase_init_unchained.  It  does  not  call  any initializer  of  ancestors  anymore  and  was  made  internal.  The  initialization  was  moved  to  the  Staking contract where __Staking_init calls all unchained initializers of parent contracts. The guidelines are now followed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.6   Initializer Not Using Unchained Initializer of", "body": " Ancestors  The  contract  Mint721Validator  implements  __Mint721Validator_init_unchained  function, that  calls  __EIP712_init  from  OpenZeppelin's  EIP712Upgradeable  contract.  The  OpenZeppelin docs suggests using unchained initializers of parent contracts to prevent initializing a contract twice.    __Mint721Validator_init_unchained calls __EIP712_init_unchained now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.7   Missing updateAccount Function in", "body": " ERC1155Lazy  Rarible Inc. - Staking and Tokens -   11  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe contracts should support Rarible on-chain royalties. As in ERC721Lazy there should be a method calling  _updateAccount  from  AbstractRoyalties.  That  enables  a  registered  royalty  account  to change the address for the royalties for some token ID. Such function is missing in the ERC1155Lazy.    The updateAccount function was added. It allows to perform the previously described actions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.8   Solidity Compiler Versions", "body": "  The defined solidity versions are too different across staking contracts:  pragma solidity >=0.6.2 <0.8.0; pragma solidity ^0.7.0;  Too wide version range >=0.6.2 <0.8.0 can cause compilation with not the latest compiler version, where bugs can present.    The Solidity compiler version was set to 0.7.6 for all contracts in scope.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.9   Staking Coefficient Can Make Stake Line", "body": " Longer  When the staking bias and slope are computed, the computation is done with a certain precision. If bias has  a  significant  difference  compared  to  slope,  the  resulting  params  of  stake  line  can  make  it  longer compared to locked line. For example, bias of 5200, with slope of 100 and cliff of 52 weeks, the stake line will have bias of 23592 and slope of 453. Right after 104 weeks, the lock line will be depleted, and all funds will be withdrawable. The stake line after the same period will have remaining 36 (23592 mod 453) stake  that  will  unlock  only  on  53rd  week.  This  behavior  is  not  documented  in  specs  and  violates  the statement that stake behaves like locked tokens and is just multiplied by value.    Calculations were changed for the staking bias and slope values. The slopePeriod is now defined as ceil(amount / slopePeriod). The staking coefficient affects only staking bias. The staking slope value  is  computed  as  ceil(staking  amount  /  slopePeriod).  As  a  result  of  this  changes,  the \"remained\" will be counted as a last period of slopePeriod. The stake line and balance line will deplete at the same time.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.10   Staking Contracts Are Missing __gap Field", "body": "  Rarible Inc. - Staking and Tokens -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fAll staking contracts, Staking, StakingRestake and StakingBase, do not have the recommended __gap field for upgradeable contracts. Without this field adding new state variables in the future can be problematic.    __gap was added to the above mentioned contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.11   Staking Events Data", "body": "  Some events emitted in staking contract do not provide enough information to easily reconstruct the state of contract.  In function restake the emitted event Restake does not emit new value of counter field. Also the account that performs restake is not emitted. The StakeCreate emits both those fields.   Event Delegate does not emit account that performs redelegation.   No events emitted on stop function call. That is important function that greatly impacts the contract  functionality.   No events emitted on startMigration function call. That is important function that greatly impacts  the contract functionality.    The events are now emitted for all actions, described above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.12   Staking Exposing Getters", "body": "  In current implementation of the staking contract some fields and data is hard to query due to missing getters. The list of information that can improve user experience and minimize human errors:   Output of getStake function. Currently it is internal pure function.   Remaining locked amount   Amount available for withdrawal   For a given Line id, the owner and delegate addresses.   Field stopped of the staking contract   Getting \"current week\" of the contract. E.g. roundTimestamp function output.    Following changes were done, to fix the issues from the above list:   Function getStake is declared as public.   Function locked was added.   Function getAvailableForWithdraw was added.  Rarible Inc. - Staking and Tokens -   13  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                 \f Function getAccountAndDelegate was added.   Field stopped was made public.   Function getWeek was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.13   Staking Is Possible When Migrating", "body": "  The migration is irreversible process that is needed to move stakes to a new contract. But such actions like  stake,  delegateTo  and  restake  are  still  allowed  during  this  process.  Users  can  by  mistake performed  such  actions  and  will  need  to  submit  extra  transaction  to  migrate  their  actions  to  a  new contract.    Function mentioned above now use notMigrating operator that restricts their usage when the contract is migrating.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.14   Staking Restake Can Cut the Corner", "body": "  The restake function checks that the new amount of locked tokens is not lower than the old amount. Also there is a check that the end time of the new line should not be earlier that the old end time. These constraints  allow  the  user  to  restake  with  a  long  slopePeriod,  but  without  a  cliffPeriod,  which  leads  to stake being unlocked earlier than in the original line. Geometrically, this amounts to \"cutting the corner\" of the brokenline.    The restake function now performs checks, that the new line is greater (not strictly) then the old line. Geometrically, this can be interpreted as new line to be always \"above or equal\" the old stake line. This is done by a call to verification internal function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.15   Staking Slope Period Definition", "body": "  The  current  slope  period  is  computed  as  amount  //  slope,  that  is  using  an  integer  division  that rounds down. The effect of this is that, in the week after the slope period ends, the amount % slope tokens will still be staked. This remainder does not contribute to the staking coefficient K. The remainder cannot  be  withdrawn,  but  can  be  delegated  to  and  restaked.  Also  this  extra  period  does  not  counted towards the 2 year limit for the staking period. The current version of the specification does not describe this behavior.    Rarible Inc. - Staking and Tokens -   14  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \fThe  new  slope  period  is  computed  as  ceil(amount  //  slope).  Now  the  \"remainder\"  week  is accounted for staking coefficient and 2 year limit.  Rarible Inc. - Staking and Tokens -   15  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "7.1   Missing Documentation for Public Functions", "body": "  Some functions and state variables in StakingBase.sol are now public. However, functions and getters are not documented. Following functions and variables are lacking documentation in the readme:   getStake   counter   stopped   migrateTo   totalSupplyLine  Rarible Inc. - Staking and Tokens -   16  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/staking-erc721-erc1155/"}, {"title": "6.1   Incorrect Accounting in report()", "body": "  PoolManager.report() is called by a strategy to report the performance when harvesting. First, some parameters are updated and funds are transferred. Then, surplus for the administration is set aside and the gain or loss for SLPs is signaled to StableMaster.  However,  the  propagation  of  loss  for  SLPs  could  lead  to  accounting  issues.  Assume  the  following scenario:   Neither interest for admins nor admin debt has been accumulated so far.   The interests are shared 50/50 for surplus and the stablemaster (the SLPs)  1. Assume 10 SanDAI have been minted and the current rate is 3, meaning that each SanDAI is worth  3 DAI. The pool has 30 of the underlying available which can be used by the strategy.  2. The strategy now signals a loss of 20.  3. loss is 20 and is split equally: lossForSurplus is 10.  4. lossForSurplus > interestsAccumulatedPreLoss holds.  5. The admins cannot currently cover any loss. Hence, their debt is increased by setting adminDebt  to 10.  6. A loss of 10 is signaled to StableMaster. The rate drops from 3 to 2.  7. However, the StableMaster accounts for a loss of 10 DAI while SLPs actually compensated with 20 DAI  since  they  are  temporarily  covering  some  loss  for  the  admins.  Hence,  the  accounting  of  the StableMaster mismatches the SLPs balance in the PoolManager which holds only 10 DAI.  8. Only 5 SanDAI can be redeemed (at the current rate of 2), the remaining 5 SanTokens cannot as they are not backed by funds since PoolMaster holds only 10 underlying tokens (but the rate is 2).  Angle - Staking and Surplus -   11  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedDesignLowVersion2Acknowledged            \fOnly after the adminDebt has been paid back, sufficient funds will be available in the StableMaster. In the meantime, further issues could arise.  Acknowledged:  Angle  has  acknowledged  this  issue  since  such  scenarios  are  unlikely  to  occur.  However,  Angle  will monitor the system. If such a scenario is detected, Angle will handle the situation appropriately.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "6.2   Checks on interestsForSurplus", "body": "  The new interestsForSurplus parameter in the pool manager contract allows to split the strategies' profits between SLPs and the fee distributor. However, that parameter can range from zero to 100%. A high  choice  may  contradict  with  the  specification  that  SLPs  will  earn  more  interest  by  depositing  to protocols through Angle compared to direct deposits. Upper-bounding the aforementioned range further could increase trust and ensure splits are fair.  Acknowledged:  Angle replied:  We don't want to add an upper bound, and as in other part of the protocol we suppose the guardians have aligned incentives with the protocol. Governance could for instance decide to set 100% of the fees for veANGLE holders and at the same time redistribute all the transaction fees to SLPs to counterbalance for that. We added comment to the function setInterestForSurplus.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "6.3   Governance Differences", "body": "  The  Angle  distributor  and  the  liquidity  gauge  both  support  only  one  governor.  That  diverges  from  the other  contracts'  capability  of  having  multiple  governors.  That  change  of  the  governance  system  in  the new module is undocumented.  Acknowledged:  Angle replied:  These differences are due to the change of paradigm of governance where we will use snapshot voting implemented by a multisig instead of true on-chain governance. Note that technically, the `AngleDistributor` could support multiple governors.  Another reason is that most Curve contracts we have forked support only one governor. The `LiquidityGauge` forked from Curve had only one governor, we therefore decided to keep it. The same will go for the other contracts of the protocol.  Most contracts of the protocol were coded to support multiple governors. One will however be used in practice however.  Angle - Staking and Surplus -   12  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                \fNote that also only one governor is supported in the surplus contracts (following the same reasoning).  Angle - Staking and Surplus -   13    \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  4  9  -Severity Findings  -Severity Findings  Ineffective Protection Against Sandwich Attacks, Missing Slippage Protection   -Severity Findings   Potentially Stuck Funds After Collateral Removal    Race Condition on Loss    Reverting on setGaugeKilled()    recoverERC20 Does Not Account for the New interestsAccumulated   -Severity Findings   (Missing) Checks on Path    Commented Code    Confusing Naming    Documentation Mismatches    Gas Optimizations    Guardian Powers    Outdated Compiler Version    burn in Surplus Converters Not Paused   is_killed Remains Unused   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.1   Ineffective Protection Against Sandwich", "body": " Attacks, Missing Slippage Protection  The  buyback  functions  of  the  SurplusConverter  contracts  is  permissioned  in  an  attempt  to  prevent sandwich attacks. This protection however is ineffective due to a phenomena know as Miner Extracted values.  Please  see  this  blogpost  for  more  information.  In  short,  while  the  permissioned  function  may prevent a sandwich attack e.g. from within a smart contract, for miner it's still possible to put a transaction just before and after this transactions in order to sandwich it. Such attacks can actually be observed on chain, this is more than just a theoretical threat.  The calls to the exchanges within the implementations of the buyback() functions have their slippage protection disabled by setting the minimum incoming amount to 0. This is very dangerous.    Angle - Staking and Surplus -   14  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected          \fWhenever  there  is  potential  slippage,  the  buyback  function  now  features  an  additional  parameter specifying the minimum amount to be received. In the current SurplusConverter contracts interacting with an exchange, this value is passed as minimum incoming amount parameter to the router contracts of the exchanges.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.2   Potentially Stuck Funds After Collateral", "body": " Removal  Tokens of the underlying may be stuck in the SurplusConverterSanTokens contract should a collateral be removed  from  the  StableMaster  contract.  buyback()  will  no  longer  work  after  the  collateral  has  been deactivated  in  the  StableMaster  and  it's  no  longer  possible  to  exit  the  underlying  held  by  the SurplusConverterSanToken  contract.  Should  a  collateral  be  removed,  it's  important  to  shut  down  the corresponding SurplusConverterSanTokens contract first.    A  function  recoverERC20,  callable  only  by  a  governor,  has  been  implemented  in  the  parent  contract BaseSurplusConverter to enable withdrawing funds from all the converters.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.3   Race Condition on Loss", "body": "  When a strategy made a loss, a race condition between veAngle holder / long term admins and Standard Liquidity Providers (SLPs) will arise:  Angle Stakers will attempt to call pullSurplus() to evacuate the surplus and protect their profits while SLPs will try to call harvest() on the strategy, which reports the loss to the PoolManager and at least partially tries to cover the loss using interestsAccumulated of the Angle Stakers.  However, the receivers of the funds can trick the SLPs by pulling surplus after each gain immediately.    A new variable tracking the debt to be covered by the admins has been introduced. When the loss is too high such that the currently available interestsAccumulated are not enough to cover for the losses, this debt is accrued. If there is a gain, the gain is first going to reimburse the debt and only afterwards accrue new interestsAccumulated.  Note  that  upon  the  first  loss  to  be  reported  the  race  condition  still  exists.  Admins  may  withdraw  the interestsAccumulated  first  but  then  have  to  cover  the  debt  accrued  by  the  reported  loss  with  the next profit/profits reported.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.4   Reverting on setGaugeKilled()", "body": "  The AngleDistributor has the ability to remove the approval for a gauge through setGaugeKilled. That function contains following line:  Angle - Staking and Surplus -   15  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                        \frequire(IGaugeController(controller).gauge_types(gaugeAddr) == -1 && lastTimeGaugePaid[gaugeAddr] != 0, \"112\");  Note that the controller's gauge_types function is defined as follows:  gauge_type: int128 = self.gauge_types_[_addr] assert gauge_type != 0 return gauge_type - 1  It  reverts  if  the  gauge  type  is  0  (return  value  -1).  However,  the  first  code  snippet  shows  that  the  call reverts if the return type is not -1. Hence, setGaugeKilled() will revert always revert.    The precondition has been simplified to  require(lastTimeGaugePaid[gaugeAddr] != 0, \"112\");  Moreover, it can now only be called by guardians.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.5   recoverERC20 Does Not Account for the New", "body": " interestsAccumulated  Function recoverERC20 of the PoolManager allows the Governor to recover ERC20 tokens held by this contract.  Any  amount  of  arbitrary  ERR20  tokens  held  by  the  contract  can  be  exited,  however  for  the token of the pool there are some restrictions in order to prevent the Governor to pull funds belonging to the protocol. Due to onchain constraints there are some limitations however and this can only be seen as sanity check. The HA claims are not included as it's not feasible to calculate this amount.  The  new  functionality  introduces  interestsAccumulated  which  contains  the  amount  of  tokens reserved as surplus and which can be exited using the pullSurplus() function, however the check in recoverERC20() has not been updated to account for them.    interestsAccumulated is now considered in the computations of recoverERC20().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.6   (Missing) Checks on Path", "body": "  Function addToken of the SurplusConverterUniV2Sushi contract which can only be called by the trusted Guardian role checks the given path:  require(pathLength >= 2 && path[pathLength - 1] == address(rewardToken) && path[0] == token, \"111\");  The corresponding function of the SurplusConverterUniV3 contract doesn't do any check on the path.  Angle - Staking and Surplus -   16  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  SurplusConverterUniV3 now also implements sanity checks for the path.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.7   Commented Code", "body": "  In the surplus converter for UniswapV2 / Sushiswap, the buyback function has the following commented code:  // uint256 amount = IERC20(token).balanceOf(address(this));  For clarity this code could be removed.  However,  the  balance  could  be  used  to  create  a  sanity  check  for  a  successful  swap.  Both,  the UniswapV2/Sushiswap  and  the  UniswapV3  SurplusConverter  contracts  do  not  revert  early  if  the contract's balance is smaller than the specified buyback amount.    The commented code has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.8   Confusing Naming", "body": "  The  contracts  called  surplusConverters  are  to  be  used  as  what  is  called  surplusDistributor inside the PoolManager contract. Especially as there exists another contract called FeeDistributior, the naming may be confusing.  PoolManager.pullSurplus() actually pushes the surplus to the surplusDistributor.  While the structure of the contracts SurplusConverterUniV2Sushi and SurplusConvertUniV3 is identical, one  has  they  are  called updateToken/revokeToken.  functions  called  addToken/revokeToken  while   the  other   in   the  SurplusConverterUniV2Sushi  contract   functions  addToken  and Inside  revokeToken take the parameter _typePath and type respectively. Although these parameters have different names, the meaning of their values is not aligned:  the  complementary   _typePath:   0: SushiswapPath              1: uniswapPath  _typePath:   0: SushiswapPath and uniswapPath              1: SushiswapPath            >-2: UniswapPath  Clear  and  structured  naming  greatly  improves  readability  of  the  code  and  helps  to  avoid  confusion  or potentially resulting coding errors.  Angle - Staking and Surplus -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  The naming has been changed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.9   Documentation Mismatches", "body": "  The documentation of some functions mismatches their implementations in several places:   The  documentation  of  buyback()  for  the  UniswapV3  and  SanToken  converters,  specify  that  it  swaps on Uniswap or Sushiswap, which is incorrect (Copy&Paste error).   The  documentation  the  converter  functions  specifies  the  FeeDistributor  as  the  recipient.  However,  the recipient of the funds could also be another converter (e.g. setFeeDistributor).  Specification changed:  The comments have been corrected accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.10   Gas Optimizations", "body": "  The gas consumption of some functions could be reduced. For example:  PoolManager.report()   if(loss  In  interestsAccumulated is read four times from storage.  the   in   >   0)   branch,   the   variable  In PoolManager.pullSurplus() surplusDistributor is read three times and token is read twice from storage.  In BaseSurplusConverter.setFeeDistributor() rewardToken is read twice from storage.   The Sushi / UniswapV2 surplus converter stores the length of the path. Since this can be retrieved  from the array itself, that results in unnecessary storage writes.   The  buyback  in  the  Sushi  /  UniswapV2  where  both  paths  are  present  reads  either  the  path  for UniswapV2 or Sushiswap twice from storage. Similarly, the router address for one of these will be read twice from storage.   AngleDistributor.toggleDistributions() has two storage reads. However, one could be  sufficient.   Even  though  not  a  gas  optimization:  BaseSurplusConverter  imports  IUniswapRouter  which  is  unused.  This list of examples illustrates some inefficiencies in code which could increase the gas consumption of users. Some of these optimizations may or may not be done by the optimizer. As the exact behavior of the  optimizer  is  unknown/undocumented  the  optimizations  may  be  done  manually,  as  is  done  in  large parts of the Angle codebase already.    All optimizations listed above have been implemented.  Angle - Staking and Surplus -   18  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                     \f7.11   Guardian Powers  The  guardian  has  been  specified  as  a  role  that  can  change  system  parameters.  However,  when transferring funds it is typically required that the governance performs such actions. Note, that in the new code the guardian can be overly powerful (e.g. setting the fee distributor).    Now, the governor role has been introduced to the surplus converter contracts. Note that only governors can set the fee distributor. That restricts the permissions of the guardian.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.12   Outdated Compiler Version", "body": "  The project uses an outdated version of the Vyper compiler.  # @version 0.2.15  At  the  time  of  writing  the  most  recent  Vyper  release  of  version  0.2.x  is  0.2.16  which  contains  some bugfixes but no breaking changes.    The compiler version has been updated to 0.2.16.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.13   burn in Surplus Converters Not Paused", "body": "  The BaseSurplus converter specifies the following for function pause:  /// @dev After calling this function, it is going to be impossible for whitelisted addresses to buyback /// reward tokens or to send the bought back tokens to the `FeeDistributor`  However, as burn() has no whenNotPaused modifier, it is possible to send funds to the fee distributor. Without documentation the expected behavior is unclear.    The whenNotPaused modifier has been added to burn().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "7.14   is_killed Remains Unused", "body": "  is_killed remains unused in code. Therefore, its setter has no effect on the system. That functionality could be removed to reduce code size and, hence, to reduce deployment cost.  Angle - Staking and Surplus -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                              \f  The code has been removed.  Angle - Staking and Surplus -   20  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  Hence,  the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead,  they  should  raise  awareness  in  order  to  improve  the  overall  understanding  for  users  and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "8.1   Arbitrage Opportunities for Whitelisted Role", "body": "  The buyback function swaps one token in another one and, hence, will change the prices of assets on one  pool.  Now  pools  will  now  price  differences  and  thus  arbitrage  opportunities  are  created.  The comments above the buyback function in the BaseSurplusConverter contract describe this. Described as a mitigation for this, the function is permissioned and can only be called by the whitelisted role.  The resulting arbitrage opportunity will anyway be taken advantage of, e.g. by bots. Depending on the amounts involved it could be worthwhile for the whitelisted role to do so / allow the code to do so. Note also that multiple buyback calls could increase the profit further by creating more arbitrage possibilities.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "8.2   Vyper <-> Solidity Compatability", "body": "  Some of the new contracts are written in Vyper. The system now consists of interacting contracts written in Solidity and Vyper. While both compile to EVM bytecode and the interaction are normal low level calls, there might be incompatibilities: Encoding in one and decoding in the other may be problematic and there are  concerns  whether  that  works  correctly  in  all  circumstances.  Hence,  interaction  between  contracts written in Vyper and contracts with Solidity should be considered as experimental. The interaction of such contracts should be tested carefully.  Angle - Staking and Surplus -   21  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol-staking-and-surplus/"}, {"title": "5.1   FeeTier of Swap", "body": "  0  0  0  2  The Swap contract allows authorized callers to add multiple fee tiers. These tiers are not documented. Any fee added as fee tier is valid. All calls to swapTokens() may simply specify the lowest allowed fee, higher fee tiers can just be avoided by the users.  Risk accepted:  Oazo Apps Limited states:  Added a note at the bottom of the Operation Registry section. We accept the risk that the user might change the fee from the front-end.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "5.2   Missing NatSpec", "body": "  The  code  is  not  documented  in  the  NatSpec  format.  It  is  recommended  to  fully  annotate  all  public interfaces. This should help both end users and developers interact with the contracts.  Risk accepted:  To be added later.  Oazo Apps Limited - Modular Proxy Actions -   11  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedDesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                   \fOazo Apps Limited - Modular Proxy Actions -   12    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  2  9  12  -Severity Findings  -Severity Findings   OperationStorage Can Be Polluted    OperationsRegistry: No Access Control   -Severity Findings  Implementation of UseStore Inconsistent With Documentation   Ineffective receiveAtLeast Check After Swap    Maker Deposit Action Uses Full Balance    No Access Control on onFlashLoan    OperationRegistry: No Entry, No Checks    Payable Action.execute()    Reentrancy Into executeOp()    Visibility of aggregate Function    sendToken: Transfers msg.value Instead of send.amount   -Severity Findings   Action Events Not Emitted    Actions: Inconsistent Destination of Tokens    DAI Address Could Be Constant    OperationStorage: Unused owner Variable    OperationsRegistry: No Events Emitted on State Change    Outdated Compiler Version    Receiver of Flashloan    Sanity Check in on Flashloan    Swap Slippage Saved Event Order    Swap.sol: ReceiveAtLeast Does Not Take Into Account the Fee    Unused Return Value of Aave Withdraw    onFlashLoan() Ignoring Fees   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.1   OperationStorage Can Be Polluted", "body": "  Oazo Apps Limited - Modular Proxy Actions -   13  CriticalHighCodeCorrectedCodeCorrectedMediumSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected          \fOperationStorage  is  designed  to  be  used  as  a  temporary  store  of  actions  and  return  values  for  the execution of an operation. Therefore, the variables it contains are deleted at the end of every operation execution.  However,  as  it  lacks  access  control,  and  since  there  is  no  mechanism  to  ensure  that OperationStorage  is  empty  before  an  execution,  action  and  return  values  could  be  maliciously  or erroneously introduced.  In particular, an attacker could store spurious return values with the push function. In the next execution actions  may  retrieve  these  values  instead  of  the  intended  ones  which  are  appended  at  the  end  of  the array.  Finally,  it  should  be  considered  that  the  execution  of  actions  may  reach  untrusted  code  (integrations, tokens). Functions push and finalize may be accessed unexpectedly even within the execution of an action.  This  similarly  applies  to  functions  setOperationActions  and  verifyAction  were  it  is  not obvious whether this can have a negative impact.  Code partially corrected:  OperationStorage  is  now  cleared  at  the  beginning  of  OperationExecutor.executeOp(),  this ensures that the execution of operation does not start with a polluted OperationStorage which mitigates the main issue.  Within  execution  of  actions  untrusted  code  may  be  reached  (integrations,  tokens),  in  theory  they  may the  OperationStorage:  push(),  verifyAction(), execute  state  changing  clearStorageAfter().  functions  of     OperationStorage  contract  now  stores  the  return  values  from  actions  in  a  mapping  where  values  are assigned to the address that pushed them.  mapping(address => bytes32[]) public returnValues;  function push(bytes32 value) external { ... returnValues[msg.sender].push(value); }  function at(uint256 index, address who) external view returns (bytes32) { return returnValues[who][index]; }  When writing to the OperationStorage, an address can only write in the array associated to this address. When  reading  from  the  OperationStorage,  the  caller  must  specify  which  value  from  which  address  he wants to read. This prevents untrusted code to tamper with the return values during an operation.  In case of a flashloan action executed from the AutomationBot (more precicesly a Flashloan action with flag  dsProxyFlashloan  set  to  false)  execution  continues  in  the  context  of  the  OperationExecutor. The  original  initiator  will  be  pushed  to  the  OperationStorage,  when  called  from  the  OperationExecutor functions push, at and len will use this address instead of msg.sender.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.2   OperationsRegistry: No Access Control", "body": "  Oazo Apps Limited - Modular Proxy Actions -   14  SecurityHighVersion1CodeCorrected        \fThe  purpose  of  the  OperationsRegistry  contract  is  to  specify  the  set  of  actions  identified  by  a string  name.  As  this  contract  lacks  access  control,  anyone  could  modify  the  mapping  between operation  and  actions.  This  can  be  done  through  the  addOperation  function,  which  allows  not  only adding a new operation but also modifying any existing one.  As a consequence, an attacker could modify the entries for existing operations. This could prevent the corresponding  verifications  from  succeeding,  and  thus  compromise  the  availability  of  the  system.  An attacker  may  as  well  delete  the  actions  stored  for  an  operation  resulting  in  no  verification  on  the  calls being done in OperationExecutor.aggregate().  The extensive documentation lacks a description of the OperationRegistry.    Access control has been added: There is now an owner, only this owner can add/update operations to the OperationRegistry.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.3   Implementation of UseStore Inconsistent With", "body": " Documentation  The implementation of the read function in UseStore is not consistent with the provided documentation. The function shown in the PDF does not subtract 1. In general, mixing 0-based and 1-based indexing can be a source of errors, so this should be well documented.  Specification changed:  The  excerpt  of  UseStore.read()  shown  in  the  documentation  has  been  updated  and  is  now  in  line with the actual implementation. Furthermore the params mapping section of the documentation has been extended.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.4   Ineffective receiveAtLeast Check After", "body": " Swap  To verify that the swap executed correctly, SwapOnOneInch.execute() checks that the balance is at least what the user wanted to receive:  require(balance >= swap.receiveAtLeast, \"Exchange / Received less\");  The  check  doesn't  take  into  account  that  the  token  balance  before  the  swap  may  have  been  non-zero already.  Hence  the  check  may  pass  despite  the  swap  resulted  in  less  than  receiveAtLeast  tokens. This  code  is  intended  to  be  executed  as  Delegatecall  in  the  context  of  the  users  DsProxy,  a  non-zero balance of the token out before the swap is not an unlikely scenario.  A  similar  check  is  done  in  Swap.sol.  This  contract  however  is  used  differently:  It's  a  helper  contract which  is  not  supposed  to  hold  any  token  balances  in  between  calls,  furthermore  it  forwards  all  token balance. Hence in the Swap contract; from a caller's perspective the check ensures receiveAtLeast.  Oazo Apps Limited - Modular Proxy Actions -   15  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                \f  File SwapOnOneInch.sol no longer exists in the updated codebase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.5   Maker Deposit Action Uses Full Balance", "body": "  While  the  DepositData  struct  contains  an  amount  parameter,  the  maker/Deposit  action  always uses the full available balance. This behavior is not documented and may be unexpected for users who specify an inferior amount.  Code partially corrected:  The code of action maker/Deposit now deposits the amount specified. However the action still exchanges all Ether balance to WETH. Is this intended?    The code wrapping ETH has been removed. This fixes the remaining issue as the user's Ether will not be exchanged to WETH. Note that the user needs to have WETH available instead.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.6   No Access Control on onFlashLoan", "body": "  The onFlashLoan function of the OperationExecutor contract is only intended to be called by the Flashloan provider. As it has no access control it can be called by anyone. The contract will then give approval to the registered lender for amount of asset. While this is not necessarily a problem, it breaks the normal pattern that the OperationExecutor is \"stateless\" in between calls, in the sense that he has given an approval to transfer tokens to a third party.    Access control has been added to OperationExecutor.onFlashLoan(). The function can only be called by the trusted lender returned by the Registry:  address lender = registry.getRegisteredService(FLASH_MINT_MODULE); require(msg.sender == lender, \"Untrusted flashloan lender\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.7   OperationRegistry: No Entry, No Checks", "body": "  Oazo Apps Limited - Modular Proxy Actions -   16  CorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                        \fWhen  there  is  no  operation  stored  for  a  name,  getOperation()  returns  an  empty  array  and subsequently  nothing  is  checked.  Shouldn\u2019t  this  case  be  handled  explicitly  to  avoid  not  checking correctness by accident?  An  operation  name  is  a  string.  This  allows  displaying  the  operation  name  in  a  human  readable  way. However, this can be dangerous as strings support the Unicode charset and many lookalike characters of different alphabets exist in this charset. Hence users might be tricked.  For  https://util.unicode.org/UnicodeJsps/confusables.jsp?a=IncreaseMultipleWithFl  characters,   lookalike   insights   more   into   please   refer   to:    getOperation() of OperationRegistry now reverts on non-existing operations instead of returning an empty array (which results in skipping checks). Custom operation with empty actions have to be explicitly added to the OperationRegistry.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.8   Payable Action.execute()", "body": "  The interface Executable specifies:  function execute(bytes calldata data, uint8[] memory paramsMap) external payable;  The  code  of  actions  is  executed  as  delegatecall  from  within  OperationExecutor.aggregate(). Delegatecall preserves msg.sender and msg.value. The aggregate function of the OperationExecutor is  not  payable,  hence  msg.value  will  always  be  zero.  Calls  to  executeOp()  /  aggregate()  with non-zero msg.value will revert, hence why is the execute function of actions supposed to be payable?  Note that actions may still work with Ether despite not receiving calls with non-zero msg.value: Ether can  be  received  by  the  DsProxies  fallback  function  /  the  DsProxy  can  already  have  an  Ether  balance which can be transferred onwards.    OperationExecutor.executeOp()  is  supposed  to  handle  Ether  transactions,  hence  it  has  been changed to payable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.9   Reentrancy Into executeOp()", "body": "  Function executeOp() can be reentered. At this time OperationStorage may be in an inconsistent state, amongst others (actions), returnValues may contain values.  While  this  is  not  an  intended  use  case,  technically  the  possibility  exists.  To  reduce  risks,  this  may  be restricted especially as the execution reaches untrusted third-party code (integrations, token contracts).  Furthermore note that after a takeAFlashloan action, the OperationExecutor temporarily has the right to  call  execute()  on  the  DsProxy  of  the  user.  OperationExecutor.onFlashloan()  uses  this  to execute aggregate() on the initiator.  Currently this is not exploitable due to:  Oazo Apps Limited - Modular Proxy Actions -   17  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f The DAI Flash Mint Module features a reentrancy protection, hence no second flashloan is currently possible. Note that this is no requirement for an ERC3165 compliant flashloan provider, an arbitrary flashloan proivder may not, e.g., the reference implementation of ERC3165 does not feature such a protection.   ERC3165 requires the initiator being the msg.sender initiating the flashloan. It's not possible for an attacker to get the initiator to be the DsProxy where the OperationExecutor holds the privilege.  In  the  aggregate function.    reentrancy  is  also  possible  with  aggregate(),  please  consider  issue  Visibility  of    The updated code prevents reentrancy into executeOp() by leveraging the OperationStorage contract: The reentrancy lock is set in the OperationStorage at the beginning of the execution and released after the operation.  Releasing  can  only  be  done  by  the  account  which  set  the  reentrancy  lock;  releasing  the  lock  sets  the stored account to 0x0. This ensures that the original call to executeOp() reverts in case of reentrancy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.10   Visibility of aggregate Function", "body": "  Although  the  main  entry  point  into  the  OperationExecutor  contract  is  the  executeOp  function,  the aggregate  function  is  also  public.  In  the  current  implementation  this  is  required  for  the  flashloan functionality to continue execution of the subsequent calls.  This  function,  which  is  not  intended  to  be  called  directly,  may  become  a  source  of  confusion/errors.  In particular,  if  called  directly  it  will  bypass  the  verification  that  the  right  actions  are  executed  for  a  given operation  (as  specified  by  OperationsRegistry).  Furthermore  operationStorage.finalize() will not be executed.  Access to this function might be restricted. This function may be internal, with an exposed external function for onFlashloan() which accepts calls by the OperationExecutor only.    The  visibility  of  the  aggregate  function  has  been  changed  to  internal.  The  callback  from onFlashLoan to the DsProxy is executed via a new callbackAggregate function which is public but restricts execution only by OperationExecutor itself.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.11   sendToken: Transfers msg.value Instead of", "body": " send.amount  In  case  of  Ether  transfer,  action  sendToken  transfers  msg.value  instead  of  the  amount  specified  in sendTokenData.  Note that despite the payable modifier of function execute, (delegate)calls from the OperationExecutor to  this  action  cannot  have  a  non-zero  msg.value  since  OperationExecutor.aggregate()  is  not  Oazo Apps Limited - Modular Proxy Actions -   18  Version1DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \fpayable and would revert on non-zero msg.value. Neither does executeOp(). Hence sendToken will never enter the msg.value > 0 branch in the current setup.    In  case  of  Ether  transfer,  action  sendToken  now  transfers  the  amount  specified  in  sendTokenData. Furthermore  OperationExecutor.executeOp()  now  features  the  payable  modifier  and  accepts calls with Ether. Since function aggregate has been made internal calls with non-zero msg.value are now supported.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.12   Action Events Not Emitted", "body": "  The Executable interface defines an Action event that only some actions emit. The following actions do not emit an event at the end of their execution:   common/PullToken   common/SendToken   common/SetApproval   common/SwapOnOneInch   maker/CdpAllow    All actions now emit the Action event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.13   Actions: Inconsistent Destination of Tokens", "body": "  In  maker/Generate  the  destination  address  data.to  can  be  specified  by  the  caller,  but  this  is  not possible in aave/withdraw. There may be a general pattern actions should adhere to for consistency.    AAVE  withdrawal  &  borrow  actions  now  accept  the  destination  of  tokens,  consistent  with  the  Maker actions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.14   DAI Address Could Be Constant", "body": "  In TakeFlashoan, the DAI address may be hardcoded instead of being queried from the registry.    Oazo Apps Limited - Modular Proxy Actions -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe DAI address is now an immutable set upon deployment.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.15   OperationStorage: Unused owner Variable", "body": "  The OperationStorage contract defines an owner variable that is set to msg.sender in the constructor, but is never used thereafter.    The unused owner variable has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.16   OperationsRegistry: No Events Emitted on", "body": " State Change  No  events  are  defined  or  emitted  in  the  OperationsRegistry  contract.  In  general,  it  is  recommended  to emit an event on every state change. This allows to identify changes easily.    Function addOperation now emits event OperationAdded.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.17   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity ^0.8.5;  Known bugs in version 0.8.5 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1753  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.16.    It was decided to update to compiler version 0.8.15. Client states:  Updated compiler version to 0.8.15. There was a new version after this that came just after we updated, but that did not have changes that were relevant to our scope.  Oazo Apps Limited - Modular Proxy Actions -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                          \f6.18   Receiver of Flashloan  From the documentation we understood that the receiver of the flashloan and the callback would always be  the  OperationExecutor  contract.  For  action  TakeFlashloan  however,  the  caller  can  specify  the receiver using parameter flData.borrower. What's the intention here?    The address of the OperationExecutor is now fetched from the registry and set as borrower.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.19   Sanity Check in on Flashloan", "body": "  The intention behind following check in OperationExecutor.onFlashloan() is unclear:  require(amount == flData.amount, \"loan-inconsistency\");  While checking the actual balance has its limitations (e.g. not clear if token balance originates from the flashloan or whether it has been there before already), why is the sanity check on the specified amounts being done but not on the actual balance ?  After the intermediate report, the check was changed to:  require(IERC20(asset).balanceOf(address(this)) == flData.amount, \"Flashloan inconsistency\");  This is dangerous: Any additional balance of this token held by the OperationExecutor causes a revert of this function. It should be clarified what should be checked and why this is checked.  Initially  the  code  checked  whether  the  parameter  amount  the  caller  (the  flashloan  provider)  passed matches the expected amount. We questioned what's the intention behind this check and highlighted that it doesn't ascertain anything on the actual balance. Checking if at least the balance expected is present might  be  an  option,  but  it  must  be  clear  that  this  doesn't  say  how  much  tokens  have  been  transferred from the flashloan provider (as the OperationExecutor may have had a non-zero token balance before as anyone could just transfer tokens).    The check was changed to:  require(IERC20(asset).balanceOf(address(this)) >= flData.amount, \"Flashloan inconsistency\");  This  does  not  allow  to  determine  whether  the  token  balance  originates  from  the  flashloan  or  if  it  was already in the contract, but now an additional balance of this token held by the OperationExecutor will not cause a revert.  Client adds:  In the event that the lender is compromised and supplies a lesser amount then the Operation execution will fail unless another party has accidentally sent balance to  Oazo Apps Limited - Modular Proxy Actions -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \fthe Operation Executor at some earlier time. The only impacted party would be the person who accidentally sent tokens to the Operation Executor, whose funds are lost anyway.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.20   Swap Slippage Saved Event Order", "body": "  Swap._swap() emits the SlippageSaved event after a swap:  balance = IERC20(toAsset).balanceOf(address(this)); emit SlippageSaved(receiveAtLeast, balance); if (balance < receiveAtLeast) {   revert ReceivedLess(receiveAtLeast, balance); }  While after a revert occurs all state changes including any event logs are thrown away, it might be more appropriate to only emit the event after it has been ascertained that more than receiveAtLeast have been received.    The event is now emitted after the check.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.21   Swap.sol: ReceiveAtLeast Does Not Take", "body": " Into Account the Fee  While the code of Swap._swap() ensures that after the call to the 1inchAggregateor the balance of the SwapContract is more than receiveAtLeast what is sent onwards to the user might be less as the fee may be deducted only afterwards. The expected behavior is not specified.  Specification changed:  The documentation has been updated and now reads:  receiveAtLeast - an amount that needs to be returned from swap, it does not consider fee, in case fee is collected from outgoing token the resulting amount might be less than receiveAtLeast. Sole purpose of ReceiveAtLeast is to prevent high slippage on exchange.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.22   Unused Return Value of Aave Withdraw", "body": "  In the Aave withdraw action, the return value of withdraw is ignored:  Oazo Apps Limited - Modular Proxy Actions -   22  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fILendingPool(registry.getRegisteredService(AAVE_LENDING_POOL)).withdraw(   withdraw.asset,   withdraw.amount,   address(this) );  This  return  value  represents  the  actual  amount  that  was  withdrawn  and  might  be  different  from  the amount given as argument.  Specifically, if type(uint256).max is given as argument amount, then the total available balance is withdrawn and returned.    The withdrawn value is now stored and can be used by subsequent actions.  Oazo Apps Limited replied:  We agreed that all Actions should push a return value to the OperationStorage even if that value is zero (Code change hasn\u2019t occurred yet). This makes paramsMapping simpler and more predictable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.23   onFlashLoan() Ignoring Fees", "body": "  The  documentation  states  that  the  OperationExecutor  implements  the  IERC3156  standard.  The implementation of OperationsExecutor.onFlashloan() however does not support fees. DAI flash mint currently takes no fee hence with the intended flashloan provider the code currently works however the current code doesn't fully implement/support the ERC3156 standard.    onFlashloan() now supports fees.  Oazo Apps Limited - Modular Proxy Actions -   23  CorrectnessLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "7.1   DsProxy With Unsupported Authority", "body": "  A user is free to set the authority contract of his own DSProxy. Depending on the authority contract set,  which  may  be  arbitrary,  ProxyPermission.givePermission()  may  not  be  successful.  The documentation  only  explains  the  expected  case  were  everything  works,  it  does  not  mention  this restriction.  Oazo Apps Limited - Modular Proxy Actions -   24  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-app-modular-proxy-actions/"}, {"title": "6.1   Missing Indexing of Events", "body": "  The  event  NewMonth  contains  no  indexed  fields.  The  event's  field  month  is  a  specific  number.  Yearn might consider indexing it if needed.  CS-YRNDSCNT-004  Code corrected  The field month was indexed in the event NewMonth.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ydiscount-smart-contracts/"}, {"title": "6.2   Race Condition on Team Allowance", "body": "  If the management calls set_team_allowances a second time during the same month while a team has  some  allowance  left,  similar  to  the  well-documented  issue  with  the  ERC20  approve  function,  it  is possible for a team to front-run the transaction to spend its remaining allowance before the management set its allowance to the new amount.  CS-YRNDSCNT-005  Specification changed  Yearn  highlighted  the  trust  assumption  that  the  team  is  a  fully  trusted  party.  Misbehaving  will  lead  to disqualification from participating in the program.  Yearn - yDiscount -   10  CriticalHighMediumLowCodeCorrectedSpeci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChanged                \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ydiscount-smart-contracts/"}, {"title": "7.1   Event Reentrancy", "body": "  In the function buy, the callback is done before logging the event, in the case that the call would reenter the contract, it would be possible to have events emitted out of order.  CS-YRNDSCNT-001  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ydiscount-smart-contracts/"}, {"title": "7.2   Gas Optimizations", "body": "  In  set_contributor_allowances,  self.expiration  is  read  from  storage  once  before  entering the loop and then once at each iteration of the loop, caching it in memory would avoid several SLOAD.  CS-YRNDSCNT-002  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ydiscount-smart-contracts/"}, {"title": "7.3   Inconsistency of the Interface ", "body": " ChainlinkOracle  While the Chainlink documentation specifies that the return type of decimals is an uint8, the interface ChainlinkOracle  defines  the  function  decimals  as  returning  an  uint256.  Although  a  uint8  will always fit in a uint256, it would be more consistent to use uint8 as described in the documentation.  CS-YRNDSCNT-003  Yearn - yDiscount -   11  InformationalVersion1InformationalVersion1InformationalVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ydiscount-smart-contracts/"}, {"title": "6.1   Code With No Effect", "body": "  In  UniswapV3LiquidityPositionLib.__mint,  token0  and  token1  are  overwritten  by  their  own value, hence this code has no effect.   The related assignments have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-dec21/"}, {"title": "6.2   Missing Sanity Check", "body": "  NonfungiblePositionManager   Upon  UniswapV3  LP  external  position  creation,  sorting  of  token0  and  token1  is  not  enforced. UniswapV3  sorted (address(token0)  <  address(token1)),  otherwise  the  transaction  will  revert.  This  means  that  a non-functional  external  position  can  be  instantiated.  For  example,  passing  non-sorted  tokens  to NonfungiblePositionManager.mint will revert on PoolAddress.computeAddress which requires the tokens to be sorted.  tokens   needs   the   be   to     Ordering of the tokens is now enforced on the external position initialization.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-dec21/"}, {"title": "6.3   Redundant Deadline", "body": "  Avantgarde Finance - Sulu Extensions -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fWhen  UniswapV3LiquidityPositionLib._removeLiquidity  is  called,  the  deadline  is  set  to block.timestamp + 1. This is not needed since the call to the NonfungiblePositionManager is part of an already executing transaction.    +1 has been removed.  Avantgarde Finance - Sulu Extensions -   11  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-dec21/"}, {"title": "7.1   PoolTogether V4 Early Exit Fee", "body": "  Upon redeem, PoolTogetherV4 is assumed to have no penalty fee for early withdraws as described in https://docs.pooltogether.com/faq/v3-to-v4-differences.  An  exit  fee  like  in  V3  could  prevent  the  fund manager  to  withdraw  from  PoolTogetherV4.  More  specifically,  pools  that  make  use  of  PrizePool  are assumed get the full amount requested on withdrawal. When the PrizePool.withdrawFrom is called, the  amount  to  be  redeemed  is  calculated  using  _redeem  internal  function.  In  the  case  of PrizePool._redeem, this function calls one of the yield sources implementations which determines the actual amount to be redeemed. Should such a yield source return a redeemed amount that is less than the amount initially requested, the call on integration will fail.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-dec21/"}, {"title": "7.2   Price Oracle Discrepancies", "body": "  In order to calculate the value of a position the actual price between the two tokens is required. For this, the default oracles for the two tokens are used. We assume that there are no big discrepancies between the actual price of the Uniswap pool for the specific pair and the price calculated by the system.  Avantgarde Finance - Sulu Extensions -   12  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-dec21/"}, {"title": "5.1   Aave Pool Size Manipulation", "body": "  To calculate the amount to be deposited into the Aave pool to reach the target interest rate is computed in D3MAavePlan.getTargetAssets*() by computing the difference of target pool size computed and the current pool size. However, estimation of the current pool size  uint256 totalPoolSize = dai.balanceOf(adai) + totalDebt;  is  prone  to  manipulation.  Note  that  Aave  offers  flashloans  that  do  not  update  the  debt.  Hence,  it  is possible to manipulate the pool size and hence the amount moved into the pool by first flashloaning on Aave and then calling exec(). nac  Risk accepted:  MakerDAO responded:  This is a concern we discussed at-length during our internal review. We have identified several scenarios where the D3M could be manipulated in this way.  The high level conclusion we came to in our internal review was that such a manipulation would 1) likely not have a high impact to the system and 2) would be relatively short lived.  MakerDAO - Direct Deposit V2 -   13  DesignCorrectnessCriticalHighMediumLowRiskAcceptedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCorrectnessLowVersion3RiskAccepted              \f5.2   Disable Plan Without Event  The disable function of both, D3MAavePlan and D3MCompoundPlan sets the target interest rate to 0 and emit the Disable event.  Both contracts feature a file function which allows to set the target interest rate to 0 without the Disable event being emitted.  Acknowledged:  The \u201cDisable\u201d event is emitted when the contract is disabled using the disable function. This function can be called permissionlessly if the plan leaves the active state.  When the Maker governance uses the file function to set bar to 0, the \"File\" event is emitted. This pattern matches the pattern elsewhere in Maker contracts when parameters are changed by authorized users.  Analysts monitoring the contract for shutdown will need to look for both Disable() and File(\u201cbar\u201d, 0) in their event parsing scripts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "5.3   Inconsistencies", "body": "  Similar contracts differ at similar places but could be more consistent. For example:   The  D3MAavePool  does  not  validate  that  the  aDAI  address  is  non-zero  while  the  D3MAavePlan  does.   file()  for  D3MCompoundPlan  validates  the  target  interest  rate  against  the  maximum  while  the  D3MAavePlan treats it as special case.   The D3MCompoundPool performs a == check after deposit() while the D3MAavePool performs a  >= check.   The target interest rate is barb in the D3MCompoundPlan and bar in the D3MAavePlan.  Pre-  and  post-conditions  may  be  treated  as  documentation  and,  hence,  having  them  consistent  and similar may clarify the assumptions the D3M Hub makes about the modules' behaviour.     The D3MAavePool now validates that the aDAI address is non-zero.  Acknowledged:  in  file()    An  additional  check   this  must  be  validated  within D3MAavePlan._calculateTargetSupply(). MakerDAO responded that the additional check in D3MCompoundPlan.file() is to prevent spell crafters from shooting themselves in the foot as the block based borrow rate Compound uses does not feel intuitive. Generally the policy is to leave the file functions as simple as possible and put guard rails into other contracts such as dss-exec-lib.  is  unnessesary  as    The  strict  equality  is  desired,  however  in  D3MAavePool  there  may  be  a  1  wei  rounding  error  depending on state hence the looser requirement.  MakerDAO - Direct Deposit V2 -   14  DesignLowVersion3AcknowledgedDesignLowVersion3CodePartiallyCorrectedAcknowledged                  \f MakerDAO responded: In this particular case, bar is a per-year interest rate in RAY units, while barb is a per-block interest rate in WAD units. To name these variables the same for consistency would likely  cause  spell  crafters,  risk,  and  governance  to  make  a  massive  mistake  in  setting  the  target borrow rate in the future. For this reason, we named them differently. That is, they are deliberately inconsistent for safety and security reasons.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "5.4   end.skim() May Leave ink Behind", "body": "  Normally, the ink / art of the pools urn at the VAT should be at a 1:1 ratio. Anyone however may use frob() and by supplying DAI one can reduce any urns debt.  Through the code of D3MHub _fix() is used to fix the urn. In one corner case this is not done:  Just before the VAT is caged, someone repays debt of the urn of a pool. art is now less than ink. After the VAT is caged exec() is called. The following code is executed:  } else if (mode == Mode.MCD_CAGED) { // MCD caged // debt is obtained from free collateral owned by the End module _end = end; _end.skim(ilk, address(_pool)); daiDebt = vat.gem(ilk, address(_end));  end.skim() settles the debt of the urn by confiscating ink. As not all ink is needed to cover the art of the urn, there is some ink remaining. This collateral will be locked forever.  Acknowledged:  MakerDAO states:  This is an acceptable edge case that we assess to pose little or no risk. The actor that \u201cdonates\u201d DAI to create the situation loses value, and the effects on other actors are minimal. DAI holders receive the same distribution they would have had the donation not occurred (although in principle they could have received even more had the donation been taken into account). Vault holders are not affected. The external lending market now technically has a certain amount of locked DAI lending supply, but given the fundamental shift in the nature of DAI due to, Emergency Shutdown of the Maker protocol, this is unlikely to matter at all. While special-case logic could be added in `exec` to account for this, it likely isn\u2019t worth the extra complexity.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "5.5   Immutable InterestRateModel", "body": "  In the D3MCompoundDaiPlan contract, InterestRateModel is marked as immutable :  InterestRateModel public immutable rateModel;  MakerDAO - Direct Deposit V2 -   15  CorrectnessLowVersion3AcknowledgedCorrectnessLowVersion1Acknowledged                \fThis  field  corresponds  to  the  InterestRateModel  field  of  the  CErc20  money  market  that  has  DAI  as underlying  asset.  The  CErc20  contract  inherits  from  the  CToken  contract,  which  means  the InterestRateModel can be updated :  function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     /*...*/ }  An  update  of  the  InterestRateModel  field  of  the  CErc20  contract  cannot  be  reflected  in  the D3MCompoundDaiPlan contract since the InterestRateModel field is marked as immutable.  The stored rateModel is used in function _calculateTargetSupply. Should the interest rate model of the cDAI token be updated unexpectedly, the calculations may be incorrect.  Acknowledged:  Maker acknowledges the issue and states:  If the rate model changes unwinding can be permissionlessly triggered through the hub's `cage` function. We are now also working on having that block `exec` immediately (on a separate branch).  Update:  As  of  pool is caged.  ,  if  the  interest  rate  model  changes,  exec  will  trigger  an  unwind  as  though  the  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "5.6   Optimization of auth Modifier", "body": "  The  auth  modifier  of  the  D3MPlanBase  contract  checks  the  condition  wards[msg.sender]  ==  1. However,  as  the  ward  mapping  only  contains  values  of  0  and  1,  it  is  sufficient  to  check  that wards[msg.sender] != 0. This results in a slightly more efficient compilation of the modifier.  Acknowledged:  Maker prefers to stay with the current implementation as it is used in other Maker repos.  MakerDAO - Direct Deposit V2 -   16  Version3DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Unclaimable or Leftover PoolShares During Global Settlement   -Severity Findings   Unwind Collects Interest, Fails to Reach Target Interest Rate    Discrepancy in the Handling of Unachievable Target Interest Rates   Insufficient Conditions for active() Plan    No Events    No Natspec   0  0  1  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "6.1   Unclaimable or Leftover PoolShares During", "body": " Global Settlement  When winding DAI into a module, backed by the expected pool shares to be received, the gem balance is increased by the DAI amount to be generated. This amount of gem is then locked as ink which, due to the 1:1 ratio will correspond to the urns art.  By design, the accounting in the VAT remains unaware of any changes in the pool shares value held by the D3MPool contract. In normal operation, surplus is handled by taking the profit while the loss case is generally unhandled. Please refer to the corresponding open question at the end of this report.  If  the  VAT  is  caged,  calling  end.skim()  cancels  all  of  the  owed  DAI  from  the  Vault  and  assigns  the freed ink collateral to the END which is later distributed amongst all DAI holders.  The value of the PoolShares held by the D3MPool contract however may changes: For rebasing tokens, the amount of tokens may change (Aave aDAI). For others the exchange rate may change (Compound cDAI).  In  the  late  state  of  the  shutdown  users  will  receive  of  these  D3M  gems.  They  can  then  redeem  these gems for the underlying using D3MHub.exit().  In case of aDAI the call to D3MAavePool.transfer() will transfer the amount of gem in aDAI.  In case of cDAI the call to D3MCompoundPool.transfer() will transfer the amount of gem divided by cDai.exchangeRateCurrent(),  which  translates  to  the  current  amount  of  cDAI  token  which corresponds to this DAI amount.  The third party systems are independent of the VAT. These may continue to operate normally and accrue more interests during the Shutdown process. Or they may be excess profit which has not been collected yet.  MakerDAO - Direct Deposit V2 -   17  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion3CodeCorrected         \fLeftover collateral tokens will remain at the D3MPool contracts:   D3MAavePool:  The  aDAI  balance  held  exceeds  the  sum  of  gem,  hence  not  all  aDAI  can  be  distributed.   D3MCompoundPool:  Due  to  a  favorable  cDai.exchangeRateCurrent()  not  all  cDAI  will  be  consumed when users exit their gem.  Whenever there was a loss, either before or during the shutdown process, not all gem can be redeemed:   D3MAavePool: The aDAI balance held is insufficient to redeem all the gem, hence not all gem can be  redeemed.   D3MCompoundPool:  The  available  cDAI  balance  is  insufficient  to  redeem  all  gem  with  the  current  cDai.exchangeRateCurrent(), hence not all gem can be redeemed.    The gem balance is now treated as a share of the pool's LP token balance. Hence, users will be able to withdraw their corresponding share.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "6.2   Unwind Collects Interest, Fails to Reach", "body": " Target Interest Rate  exec() determines the current state and either winds or unwinds as necessary. If no other constrains apply,  it  attempts  to  have  supplied  plan.getTargetAsset()  amount  of  DAI.  The  implementation  of unwind() however may remove more assets and the resulting pool state is not exactly as targeted.  is   to   due   This  states: Upon  unwinding,  interest  will  automatically  be  collected..  Interests  however  are removed in addition to the calculated supply reduction reducing in less than the calculated amount of DAI remaining in the pool.  implementation   unwind().   README   The   the   of   The  implementation  of  unwind()  first  calculates  the  amount  to  unwind  based  on  the  calculated supplyReduction and constraints:  // Unwind amount is limited by how much: // - max reduction desired // - assets available // - dai debt tracked in vat (CDP or free) uint256 amount = _min(                      _min(                         supplyReduction,                         availableAssets                     ),                     daiDebt                 ); require(amount <= MAXINT256, \"D3MHub/overflow\");  and later adds the fee on top for the amount to withdraw.  // To save gas you can bring the fees back with the unwind uint256 total = amount + fees;  MakerDAO - Direct Deposit V2 -   18  CorrectnessLowVersion3CodeCorrected        \f//uint total = amount; _pool.withdraw(total);  As too many DAI have been removed, the utilization is higher and the target interest rate is not reached. A second call to exec() could rectify this by resupplying the missing amount of DAI.    The implementation of exec() has been redesigned, the issue described above no longer exists.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "6.3   Discrepancy in the Handling of Unachievable", "body": " Target Interest Rates  There  is  no  upper  bound  on  the  value  of  targetInterestRate  in  the  _calculateTargetSupply function, nor on barb in the file function. Consequently, it is possible to obtain a target utilization rate (targetUtil) above 100% in _calculateTargetSupply. This is not possible in Compound, thus the target interest rate is unachievable. However, _calculateTargetSupply will return a non zero value as if the target rate was achievable.  This  is  not  consistent  with  the  behavior  of  _calculateTargetSupply  in  the  other  cases  where  the target  interest  rate  is  not  achievable:  When  targetInterestRate  is  above  normalRate  but jumpMultiplierPerBlock is zero, or when targetInterestRate is below baseRatePerBlock, _calculateTargetSupply returns 0.    _calculateTargetSupply now returns 0 when the calculated utilization is over 100%.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "6.4   Insufficient Conditions for active() Plan", "body": "  Plans can be manually disabled or enabled. However, that may also happen automatically. For example, the  D3MCompoundPlan  will  become  inactive  if  the  implementation  contract  has  changed.  While  the checks for both plans are rather extensive, there could be some properties that could also be considered for the active() view function.  For example:   Aave  does  not  offer  querying  the  implementation  contract  such  as  compound  but  offers getRevision()  which  returns  the  version  of  the  AToken.  Similarly,  that  holds  for  other  Aave contracts such as the lending pool.   Before depositing into Aave, Aave does a validateDeposit() check which checks if an AToken  is active and not frozen.   Before depositing into Compound, the CToken calls mintAllowed() on the Comptroller to check if  the market is listed or paused.  Were these and similar properties considered and why aren't they use in the active() function?  MakerDAO - Direct Deposit V2 -   19  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f  MakerDAO responded:  The first check for Aave (ATOKEN_REVISION) is very helpful and has been added.  The other two concern a paused or inactive token in Aave or Compound. We explored this during our internal review and unfortunately, found that this is not a helpful check to add to `active`. When a plan returns `false` for active, then we attempt to unwind as much of our position as possible. In the case where the AToken is not active/frozen or the CToken is not listed/paused, any transfer of those tokens will revert so we will not be able to withdraw.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "6.5   No Events", "body": "  Neither  function  file  nor  disable  of  the  D3MCompoundDaiPlan  contract  emit  an  event  after  the parameter barb has been changed. Normally file functions of Maker projects emit an event.    Events are now emitted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "6.6   No Natspec", "body": "  The  external  functions,  although  being  view  functions  only,  feature  no  description  /  natspec.  Is  this intentional?  Description  may  allow  user  to  better  understand  the  function  parameters  (e.g.  the currentAssets  of  getTargetAssets())  and  the  return  values,  thus  potentially  avoids  errors.  For example it's not immediately obvious if some parameters are in cDAI or DAI.    MakerDAO added NatSpec documentation.  MakerDAO - Direct Deposit V2 -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Open Questions  Here,  we  list  open  questions  that  came  up  during  the  assessment  and  that  we  would  like  to  clarify  to ensure that no important information is missing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "7.1   Checks on deposit()/ withdraw()", "body": "  Both  pool  implementations  implement  sanity  checks  upon  deposit  in  order  to  ensure  the  expected amount of pool shares has been received.  Upon  withdrawal  the  D3MHub  enforces  that  a  sufficient  amount  of  DAI  is  present.  Otherwise,  the transaction reverts when DAIJOIN.join() fails.  Generally, this checks whether redeeming pool shares resulted in the expected amount of DAI, except in corner cases when there was additional DAI balance present for the D3MHub.  A  situation  where  redeeming  pool  shares  results  in  less  than  expected  DAI  is  not  detected  by  the D3MHub  contract.  While  the  transaction  reverts,  the  D3M  hub  will  remain  unaware.  A  later  call  to execute, after the utilization of the third party has changed, may wind more DAI into this broken system.  Should  there  be  an  on-chain  protection  mechanism  or  will  this  be  handled  by  off-chain  monitoring  and then disabling a pool through the mom?  MakerDAO - Direct Deposit V2 -   21  OpenQuestionVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "8.1   Anyone Can Manipulate the Allocation", "body": "  By design, the plans' computations on how much to withdraw/deposit heavily depends on on-chain state: The  plans  aim  to  reach  a  target  interest  rate  which  is  depending  on  the  current  utilization  ratio.  This depends on:  1. the current pool size  2. the currently borrowed amount  Note, that both can be easily manipulated before exec() is called. This may be done within the same transaction  or  in  separate  transactions.  However,  this  is  almost  like  the  normal  intended  use  of  the system: Pool states change after interactions, exec() is used to return the pool to the desired stated.  The current pool size for example can be manipulated by sandwiching exec() as follows:  1. Deposit DAI into the external system's pool by minting LP tokens.  2. exec()  3. Withdraw DAI by burning LP tokens.  Note that such manipulation can easily be achieved at low cost to a certain degree since, for example the DAI flash mint module, offers DAI flash loans for free.  The second one can be manipulated by sandwiching exec() as follows:  1. Borrow a significant amount of DAI from the pool.  2. exec()  3. Payback the loan.  Note  that  this  manipulation  requires  some  extra  steps  such  as  depositing  collateral  to  borrow  DAI. However, the needed collateral amount could be either already held by a malicious user or could be flash loaned at potentially low cost.  In  summary,  exec()  always  attempts  to  reach  the  target  utilization.  In  a  three-step  process,  first  by modifying the state (e.g., depositing DAI minting pool shares), calling exec() which now winds/unwinds into the wrong direction to temporarily reach the target utilization. Finally, the attacker may undo the state manipulation  of  step  1)  (e.g.,  returning  the  pool  shares  he  borrowed)  and  the  pool  utilization  is significantly off.  As long as exec() works as intended, this is no issue. A subsequent call to exec can return the pool to the desired state. Note that in corner cases this may not be possible: Limitation from maxDeposit() / maxWithdraw(),  Line  or  available  liquidity  to  withdraw  DAI  may  prevent  this.  Should  an  attacker manage to trick exec() to wind/unwind but a subsequent exec() cannot undo this (temporarily), this is problematic.  A potentially costly attack could be to borrower much DAI over a long time such that the position cannot unwind  properly.  A  variation  of  this  could  be  front-running  calls  to  exec()  which  would  unwind  and remove the available DAI liquidity.  MakerDAO - Direct Deposit V2 -   22  NoteVersion1    \f8.2   Caging Arbitrary Ilks  Technically, for the governance it is possible to cage ilks to either do not exist yet or that are not D3M ilks. Potential consequences could be:   The non-existing ilk is added to the system and could be immediately culled.   The non-D3M ilks could be added that could be similarly culled. However, if 0x0 has some ink or  art for that ilk, the ink will be converted to gem while the debt will be written off.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "8.3   Document VAT Shutdown", "body": "  VAT Shutdown considerations are not documented for this special ilk type. Due to the special nature / behavior such documentation should be readily available and may include:   Description of the different states a D3M ilk could be in   Effects of unwinding during shutdown (MCD_cage mode) and a description of the process   Culling and what implications a culled ilk during shutdown has   Unculling and the reasons when it could be worth calling it, and the conditions for when uncull()  can be called   Considerations when ilks were not fully unwinded (e.g. D3M oracles can not be queried and hence  the ilk cannot be caged)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "8.4   Exposure to New Collaterals / Markets", "body": "  Currently the set of ilks / collaterals backing the DAI Stablecoin is rather restricted to well known and trusted assets only.  D3MHub  lends  DAI  to  third  party  protocols  such  as  AAVE  and  Compound.  This  results  in  exposure  to new  markets  and  collateral  assets.  The  risk  can  be  limited  through  the  Line  /  debt  ceiling  set  for  the corresponding ilk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "8.5   Maximizing Revenue", "body": "  By supplying DAI into lending protocols such as Compound/Aave the protocols utilization is reduced and borrowing DAI gets cheaper.  With DAI generated through D3M Maker only profits from interests accrued by the DAI in the third party protocol in contrast to DAI generated with normal ilks where users have to pay the stability fee.  With Compound/Aave users earn interest on their collateral while paying interest for borrowed DAI. The users  position  has  to  be  overcollateralized,  hence  the  supply  interest  are  earned  on  a  larger  amount compared to the borrow interest on the smaller DAI amount.  There  is  a  risk  that  users  can  get  DAI  cheaper  via  these  protocol  compared  to  using  the  Maker  Dai Stablecoin system if the parameters for the target borrow rate / pool utilization are not chosen carefully.  MakerDAO - Direct Deposit V2 -   23  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fE.g. at the time of writing (July 17th, 2022):  Aave V2: The variable borrow APY for DAI is 1.69% at a pool utilization of 33.46% while the supply APY for Ether is 0.08%. Compared to the ETH-A stability fee in Maker is 2.25%.  Compound: The borrow AP for DAI is 1.79% with a pool utilization of 31.19%. The supply APY for LINK token is 0.43% Compared to the Link-A Stability fee in Maker of 2.50%.  The target interest rate must be chosen carefully taking into account the different stability fees of different ilks for the D3M to be worthwhile. Depending on the state of the lending pool (e.g. low utilization / low rates) this may not be possible.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "8.6   Unhandled Loss Case", "body": "  When winding DAI into a module, backed by the expected pool shares to be received the gem balance is increased by the DAI amount to be generated. This amount of gem is then locked as ink which, due to the 1:1 ratio will correspond to the urns art.  By design the accounting in the VAT remains unaware of any changes in the pool shares value held by the D3MPool contract.  If the module generates a profit in form of interests the profit is accounted for.  If the third party system makes a loss, the value of the pool shares held by the D3M pool may decrease. exec() does not catch this and may continue to wind DAI into the module if the plan asks to do so. Such a module / ilk must be caged manually by the governance.  MakerDAO replied:  Note that it is true that when there is a problem, such as a hack in Compound or Aave, the exchange rate or rebalancing can be altered both ways.  We think this risk is not significantly different from existing risks in non-immutable collateral types, and is limited by debt ceilings.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "8.7   VAT Debt Could Increase After END.thaw()", "body": "  After the processing period of the shutdown, the call to END.thaw() will fix the total outstanding supply of DAI according to VAT.debt().  uncull() can still be called. This will suck() and then grab() such that the total debt of the VAT is increased  and,  thus,  it  could  be  possible  that  the  total  outstanding  DAI  supply  is  increased  even  after END.thaw().  MakerDAO states:  We are aware of the importance/need to uncull all culled D3Ms and will be working to add this to our End Keeper processes. This is similar to the importance that all collaterals get skimmed in the waiting period.  MakerDAO - Direct Deposit V2 -   24  NoteVersion1NoteVersion1        \fMakerDAO - Direct Deposit V2 -   25  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-v2/"}, {"title": "5.1   Race Condition on Approvals", "body": "  Since there is no direct way to increase and decrease allowance relative to its current value, the function AllowanceTransfer.approve()  has  a  race  condition  similar  to  one  of  ERC-20  approvals.  Further details regarding the race condition can be found here.  Risk accepted:  Uniswap responded:  We opted not to address this issue. If users really care about this attack vector it means they are likely signing a spender they don\u2019t fully trust, and they can always approve(x), approve(0), approve(y). We also expose a lockdown function that can batch remove approvals for users, before setting new approvals.  Uniswap - Permit2 -   11  SecurityDesignCriticalHighMediumRiskAcceptedLowDesignMediumVersion1RiskAccepted            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Permit2Lib Argument Casting   -Severity Findings  -Severity Findings   CALL to DOMAIN_SEPARATOR()   0  1  0  1  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/uniswap-permit2/"}, {"title": "6.1   Permit2Lib Argument Casting", "body": "  The  functions  permit2  and  transferFrom2  of  Permit2Lib  both  take  uint256  amount  as  an argument. The lib will first attempt to call the token directly and falls back to the call to Permit2 if it fails. However,  the  Permit2.permit  and  Permit2.transferFrom  take  uint160  amount  as  an argument. The initial uint256 amount will be cast to uint160 for that call. Assuming some contract A relies on transferFrom2 for token transfers, the following can happen:  1. The user calls a function on A that attempts to pull funds from the user using transferFrom2. For  amount, the user specifies 2**170.  2. A direct call to token.transferFrom fails.  3. Permit2Lib falls back to Permit2.transferFrom with uint160(2**170) == 0 as an amount.  4. The call is successful. No value is actually transferred.  5. Contract A now thinks that 2**170 tokens were actually transferred.  Similar casting happens in the permit2 function.    The SafeCast library is now used for casting to a uint160 before the Permit2 contract is called. The casting of a value that is greater than type(uint160).max would revert now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/uniswap-permit2/"}, {"title": "6.2   CALL to DOMAIN_SEPARATOR()", "body": "  EIP-712 defines the function DOMAIN_SEPARATOR() as a view function. Hence, it is expected to always work  properly  with  STATICCALL.  However,  Permit2Lib.permit2()  queries  the  domain  separator with CALL, allowing the state to change in sub-calls as well as reentrancy. The contracts that will use the Permit2Lib could break unexpectedly.  Uniswap - Permit2 -   12  CriticalHighCodeCorrectedMediumLowCodeCorrectedSecurityHighVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  The STATICCALL is used to query the DOMAIN_SEPARATOR in    of the code.  Uniswap - Permit2 -   13  Version2\f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/uniswap-permit2/"}, {"title": "7.1   Overflow Theoretically Possible for ", "body": " AllowanceTransfer.nonces  nonce   Nonces  are  incremented  with  unchecked  arithmetic.  This  means  that  incrementing  them  may  lead  to overflows, allowing for replay attacks. This is unlikely to happen solely through permit, which increases uint32.  However,  with the  AllowanceTransfer.invalidateNonces() overflows could happen after 65537 calls since it uses type uint16. Thus, signers can potentially endanger themselves by misusing the invalidateNonces function.  nonce   since   type   one   the   by   of   is    changes: nonce is of type uint48 in updated code. Thus, while the overflow is theoretically still  possible, practically it is highly unlikely to happen.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/uniswap-permit2/"}, {"title": "7.2   Signature Malleability if Misused", "body": "    of  the  code  the  SignatureVerification.verify  function  accepts  EIP-2098 In  the  compact 64 byte signature in addition to the traditional 65 byte signature format. If the replay protection mechanism  is  implemented  using  the  signature  itself,  an  attack  can  be  performed.  The  contracts  of Permit2  use  nonces  the SignatureVerification library must be done with this attack in mind. OpenZeppelin library had such an incident before.  thus  are  safe.  But  any   replay  protection  and   reuse  of   for   Also, the SignatureVerification does not perform checks described in Appendix F of the Ethereum Yellow  paper  e.g.  0  <  s  <  secp256k1n  \u00f7  2  +  1.  Thus,  for  any  given  signature  a  signature  with s-values in the upper range can be calculated. If the replay protection mechanism is implemented using the signature itself, an attack can be performed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/uniswap-permit2/"}, {"title": "7.3   invalidateUnorderedNonces Possible", "body": " Arguments  SignatureTransfer.invalidateUnorderedNonces  can  invalidate  nonces  with  wordPos  values up  to  uint256.max.  However  _useUnorderedNonce  can  only  invalidate  up  to  uint248.max.  This allows the invalidation of nonces that can never be used.  Uniswap - Permit2 -   14  NoteVersion1Version2NoteVersion2Version2NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/uniswap-permit2/"}, {"title": "5.1   Preferential Withdrawal", "body": "  0  0  1  1  When there are more withdrawal requests than can be serviced, all users receive the same percentage of their withdrawals. A user that wants to make a partial withdrawal could take advantage of this.  Consider an example where withdrawal requests are fulfilled at 50%. A user that wants to withdraw 100 shares could instead request to withdraw 200 shares (given he has enough shares). Their request would be fulfilled by half, giving them 100 shares. Now they can cancel the remaining withdrawal request.  In  this  way,  the  user  was  able  to  circumvent  the  withdrawal  limit  at  no  cost.  Other  users  were  able  to withdraw fewer shares than they would have otherwise.  Risk accepted:  Avantgarde Finance states:  This is the intended behavior. Also note that redeemers who request to redeem more than they actually would like to redeem are risking that their entire requested amount be redeemed in full if the cap is not met, the cap is updated by the manager, or other redeemers cancel their requests.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "5.2   BondBuyer: Claims Involving Ether Track", "body": " Wrong Asset  Avantgarde Finance - Sulu Extensions IX -   11  DesignCorrectnessCriticalHighMediumRiskAcceptedLowAcknowledgedDesignMediumVersion1RiskAcceptedCorrectnessLowVersion1Acknowledged                  \fClaiming a position involving Ether will result in the wrong asset being added to the tracked assets of the vault. Note that the vault actually supports receiving Ether (it immediately wraps it as WETH).  Consider the parser of the SolvV2BondBuyerPosition:  else if (_actionId == uint256(ISolvV2BondBuyerPosition.Actions.Claim)) {         (address voucher, uint256 tokenId, ) = __decodeClaimActionArgs(_encodedActionArgs);          ISolvV2BondVoucher voucherContract = ISolvV2BondVoucher(voucher);          uint256 slotId = voucherContract.voucherSlotMapping(tokenId);         ISolvV2BondPool.SlotDetail memory slotDetail = voucherContract.getSlotDetail(slotId);          assetsToReceive_ = new address[](2);         assetsToReceive_[0] = voucherContract.underlying();         assetsToReceive_[1] = slotDetail.fundCurrency;  For arbitrary vouchers, one of the assets may be Ether as Ether is technically supported by the Solv v2 smart contracts.  Solv v2 represents the Ether asset as \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" which in this case will be added to assetsToReceive. Within Enzyme, however, the correct asset to track in this case would be the address of WETH.  This results in an unsupported asset being tracked by a vault which may have severe consequences. For example, it breaks calcGav().  Whether  such  vouchers  actually  exist  depends  on  the  market  configurations  administrated  by  Solv Protocol. These markets may change in the future. Since the external position may interact with any offer on the IVOMarket / any voucher, such an issue may arise.  The InitialVoucherOfferingMarket currently doesn't support to create offers with Ether as underlying since offer()  misses  the  payable  modifier.  Note  that  the  implementation  otherwise  supports  the  case  to handle Ether.  The currency of a voucher may be Ether. Contrary to offer() buy() features the payable modifier and hence such vouchers can be bought successfully. Note that one can't buy such a position in Ether via the external position since it doesn't support providing ERC20 tokens. This however doesn't prevent all  scenarios  where  claim()  may  return  Ether  as  such  an  NFT  may  be  transferred  directly  to  the external position.  Acknowledged:  Avantgarde Finance states:  While ETH can technically be the currency of the offer, Solv\u2019s refund logic depends on it being a stablecoin: https://github.com/solv-finance/solv-v2-ivo/blob/ ac12b7f91a7af67993a0501dc705687801eb3673/vouchers/bond-voucher/ contracts/BondPool.sol#L174  Avantgarde Finance - Sulu Extensions IX -   12    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings  0  0  0  0  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "6.1   Missing indexed in Event", "body": "  The event initialized emitted in GatedRedemptionQueueSharesWrapperLib.init() contains the address of the VaultProxy. This field is not indexed, hence one can't easily search such events for a certain VaultProxy. Given that the Factory doesn`t implement access control when deploying new shares wrappers it may be helpful to have this field indexed so that one can more easily search the events.    The parameter of the event has been indexed.  Avantgarde Finance - Sulu Extensions IX -   13  CriticalHighMediumLowInformationalVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "7.1   Number of Assets", "body": "  By design, the external position framework adds all assets specified as incoming assets to the tracked assets of the vault, regardless whether the vault has a non-zero balance at the end of the operation.  Notably ISolvV2BondBuyerPosition.Actions.Claim adds two assets as both may be received. In a corner case scenario, despite actually receiving one asset only, adding two may exceed the position limit and hence the operation fails.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "7.2   OpenZeppelin ERC20 Hooks", "body": "  The  GatedRedemptionQueueSharesWrapperLib  overrides  transfer()/transferFrom()  in  order  to validate the transfer (__preProcessTransfer).  The OpenZeppelin ERC20 implementation provides a hook, (_beforeTokenTransfer) which could be used  for  this.  Note  that  this  hook  is  also  executed  upon  minting/burning.  For  more  information  please refer to documentation of OpenZeppelin:   https://docs.openzeppelin.com/contracts/3.x/extending-contracts#using-hooks  Avantgarde Finance - Sulu Extensions IX -   14  InformationalVersion1InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "8.1   Bond Buyer Requires Trusted Fund Manager", "body": "  Investors need to trust the fund manager to a certain degree.  fund  manager  can  always  drain   A  https://specs.enzyme.finance/topics/known-risks-and-mitigations#opportunistic-managers  through  bad   trades.  This   funds  e.g.   is  documented:  Note that this is amplified when a fund can use the SolvV2BondBuyer External Position: A malicious fund manager  may  create  an  IVO  offer  via  the  Solv  Protocol  with  a  very  high  lowestPrice  set  for  their collateral  asset.  Then  they  can  buy  this  offer  through  the  External  Position  and  never  pay  back  the principal to the Bond. This would leave the fund with a small amount of collateral, while the fund manager could keep all value that was in the fund.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "8.2   Deployment of", "body": " GatedRedemptionQueueSharesWrapper  Anyone  may  deploy  a  GatedRedemptionQueueSharesWrapper  for  any  fund  through  the  factory.  This includes setting the initial configuration. For example, a deployer can set themselves as manager.  Users and fund owner should be aware and excercise extra caution. The owner of a fund has full control over any such GatedRedemptionQueueSharesWrapper and can reconfigure it.  Multiple SharesWrapper can be deployed for the same fund. Note that they all bear the same name and symbol.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "8.3   Kick Ignores Redemption Limit", "body": "  The kick function in the shares wrapper allows an admin to immediately force a user redemption. This ignores the redemption limit.  Note that the limit of other users' withdrawals is not reduced by this, so the maximum redeemed amount in that period can be the redemption limit, plus any kick actions in addition.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "8.4   Redemption Requests Not Always Possible", "body": "  Note  that  redemption  requests  to  the  shares  wrapper  can  only  be  made  outside  of  the  redemption window.  Avantgarde Finance - Sulu Extensions IX -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fThe comments in the code suggest that window frequency could be chosen every 2 weeks and duration 1 week:      struct RedemptionWindowConfig {     uint64 firstWindowStart; // e.g., Jan 1, 2022; as timestamp     uint32 frequency; // e.g., every 2 weeks; in seconds     uint32 duration; // e.g., 1 week long; in seconds     uint64 relativeSharesCap; // 100% is 1e18; e.g., 50% is 0.5e18 }  With these settings, users would only be able to make redemption requests half of the time. If a user is unlucky,  they  would  need  to  wait  for  an  entire  week  until  they  can  make  a  transaction  that  does  not revert.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "8.5   Vault May Track Unsupported Assets", "body": "  The external position framework relies on the parser of the external position to check the assets returned as _assetsToReceive. The code of the external position framework doesn't do any checks itself and simply  adds  any  asset  to  the  tracked  assets  of  the  vault.  Note  that  this  is  also  independent  of  the balance.  VaultLib.__callOnExternalPosition():  function __callOnExternalPosition(     address _externalPosition,     bytes memory _actionData,     address[] memory _assetsToTransfer,     uint256[] memory _amountsToTransfer,     address[] memory _assetsToReceive ) private {     require(         isActiveExternalPosition(_externalPosition),         \"__callOnExternalPosition: Not an active external position\"     );      for (uint256 i; i < _assetsToTransfer.length; i++) {         __withdrawAssetTo(_assetsToTransfer[i], _externalPosition, _amountsToTransfer[i]);     }      IExternalPosition(_externalPosition).receiveCallFromVault(_actionData);      for (uint256 i; i < _assetsToReceive.length; i++) {         __addTrackedAsset(_assetsToReceive[i]);     } }  ...2e42850b7bbc2237618c38fb01e767d14b606e00      function __addTrackedAsset(address _asset) private notShares(_asset) {     if (!isTrackedAsset(_asset)) {         __validatePositionsLimit();          assetToIsTracked[_asset] = true;         trackedAssets.push(_asset);          emit TrackedAssetAdded(_asset);     } }  Avantgarde Finance - Sulu Extensions IX -   16  NoteVersion1    \fThe SolvV2BondBuyerPositionParser doesn't check these assets sufficiently:  else if (_actionId == uint256(ISolvV2BondBuyerPosition.Actions.Claim)) {             (address voucher, uint256 tokenId, ) = __decodeClaimActionArgs(_encodedActionArgs);              ISolvV2BondVoucher voucherContract = ISolvV2BondVoucher(voucher);              uint256 slotId = voucherContract.voucherSlotMapping(tokenId);             ISolvV2BondPool.SlotDetail memory slotDetail = voucherContract.getSlotDetail(slotId);              assetsToReceive_ = new address[](2);             assetsToReceive_[0] = voucherContract.underlying();             assetsToReceive_[1] = slotDetail.fundCurrency;         }  A voucher's underlying and fundCurrency may be any asset the IVO market supports. There is no check that the fundCurrency is an asset supported by Enyzme. If the position was bought through the external position,  it's  likely  that  the  underlying  is  supported  (else  it  couldn't  have  been  bought.)  Note  that  Solv Bond  Voucher  NFT  positions  may  be  transferred  to  an  external  position  and  consequently  one  cannot rely on the underlying to be supported.  Even when no value is returned in the specific asset, the asset is still added as tracked asset.  Similarly this situation may arise in the SolvV2BondIssuerPosition: CreateOffer() only validates that the received currency is not the native token (Ether). There is no further check on this asset which will be incoming to the vault upon reconcile().  It's unclear if Enyzme supports all possible assets by default (e.g. also when new assets are added by Solv).  Unsupported  assets  tracked  by  a  vault  may  have  severe  consequnces  as  they  break  e.g. calcGav().  It's the fund manager's responsibility to be aware and to act appropriately.  Avantgarde Finance - Sulu Extensions IX -   17  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ix/"}, {"title": "5.1   Trade Function Discrepancy", "body": "  Users  can  call  the  trade  functions  tradeBySourceAmount  and  tradeByTargetAmount  with tradeActions  that  contain  the  same  strategy  multiple  times.  During  the  execution  of  the  trade functions, the corresponding strategies are updated after each trade action has been executed.  This  is,  however,  not  true  for  the  view  functions  tradeSourceAmount  and  tradeTargetAmount:  y and z values of the associated strategies are not updated during the execution. If the same strategy is traded against multiple times in one call, the trade result might therefore diverge from the result of the corresponding trade functions in the same state.  Risk accepted:  Bancor accepts the risk with the following statement:  This is a known issue and is considered an edge case with minimal risk, as matching is done by the SDK  that  prevents  this  case.  The  alternative  would  be  to  check  for  duplicate  strategies  during  the trade which would increase the gas costs for all trades, so we decided against adding such a check  Bancor - Carbon -   10  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedCorrectnessLowVersion1RiskAccepted             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Overflow Might DOS the App    Price Precision Very Low for Some Tokens   -Severity Findings  -Severity Findings   Missing Events    No Function for Fee Withdrawal    Read-only Reentrancy    Zero Amount ERC20 Transfers   0  2  0  4  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.1   Overflow Might DOS the App", "body": "  The _tradeTargetAmount and _tradeSourceAmount functions compute the input/output needed to perform  a  trade  in  a  Strategy.  However,  Strategy  inputs  are  only  constrained  by  the  z  variable  which should be greater or equal to y. This implies that A or B can be set arbitrarily by a user and z has no no limit to the upside.  Let's take the example of _tradeTargetAmount:  function _tradeTargetAmount(uint256 x, Order memory order) private pure returns (uint128) {     uint256 y = uint256(order.y);     uint256 z = uint256(order.z);     uint256 A = uint256(order.A);     uint256 B = uint256(order.B);      if (A == 0) {         return MathEx.mulDivF(x, B * B, ONE * ONE).toUint128();     }      uint256 temp1 = y * A + z * B;     uint256 temp2 = (temp1 * x) / ONE;     uint256 temp3 = temp2 * A + z * z * ONE;     return MathEx.mulDivF(temp1, temp2, temp3).toUint128(); }  Here,  z  could  potentially  be  type(uint128).max,  which  would  imply  that  the  temp3  computation overflows, and the transaction reverts.  An  attacker  could  create  a  simple  Strategy  with  all  parameter  values  (except  the  liquidity)  maxed  out. This Strategy will yield great results in the SDK: It returns extremely favorable rates for any trade. And as the computation in the SDK is not bound by 256 bit limits, these rates will always be sorted to the top of  Bancor - Carbon -   11  CriticalHighCodeCorrectedCodeCorrectedMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrected        \feach getTradeData call without errors. This results in all users relying on the SDK now trading against a Strategy that reverts on-chain.  that   the  mulDiv  Note  type(uint128).max due to the safe downcast to 128 bits.  it  might  also  happen  when   function's  result  ends  up  greater   than    The SDK now incorporates checks to verify that each calculation (e.g., mulDivC) does not exceed 256 functions  _tradeSourceAmount  and bits  and  does  not  go  below  0.  Additionally,  _tradeTargetAmount now calculate factors that are used to scale down intermediate numbers that are too big to fit in 256 bits.  the   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.2   Price Precision Very Low for Some Tokens", "body": "  Pairs containing a very low-value token and a low decimal token create some precision issues. Assume the existence of a token named TOK with 18 decimals and another token named USD with 6 decimals precision. Let's say the price of TOK is 0.00001 USD per TOK.  If  a  user  wants  to  buy  some  TOK  at  constant  price  P  =  0.00001  USD  per  TOK,  then  they  need  to compute the B parameter this way:  B = 2^32 * sqrt(0.00001 * 1e6 / 1e18) B = 13.581879131294592  However,  B  must  be  an  integer,  meaning  it  will  be  rounded  up  or  down  (depending  on  the  frontend implementation). In any case, the price will differ greatly from the intended price resulting in possible loss or no execution for the user.  Note: This issue was already disclosed by Bancor at the beginning of the audit.    Bancor added precision by increasing the multiplying factor to 2^48 instead of 2^32, and implemented an encoding logic to be able to stretch the range of possible rates. Values greater than 2^48 now can have a (negligible) precision loss.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.3   Missing Events", "body": "  Some state-changing actions are missing an event emission. For example, most setters in the Voucher contract are not emitting events.    Missing events have been added to all state-changing functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.4   No Function for Fee Withdrawal", "body": "  Each trade accumulates fees in Strategies._accumulatedFees. There is, however, no function to withdraw  these  fees.  Withdrawal  is  still  possible  by  assigning  the  ROLE_ASSET_MANAGER  role  to  the owner  of  the  contract  and  withdrawing  funds  via  MasterVault.withdrawFunds.  This  is,  however,  Bancor - Carbon -   12  CorrectnessHighVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \ferror-prone as more than the actual amount of fees could be withdrawn. The past has shown that faulty governance proposals can be executed. This should be avoided by restricting the fee withdrawal directly in the contract.    A ROLE_FEES_MANAGER role was added along with a function to withdraw a specific amount of fees of a particular token.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.5   Read-only Reentrancy", "body": "  When updating a strategy, funds are first transferred or withdrawn (which might lead to a callback to the user, for example if the native token is used) before the strategy is updated in storage. Considering the possibility of an external protocol integrating with Carbon, it might be the case that the protocol wants to measure the value of a strategy by reading the order parameters in storage. In this case, the read value would not correspond to the real value of the strategy.  For example, an external integration might accept a Strategy NFT and give the user something in return based on the liquidity the NFT holds. Consider the following process:   The user approves the NFT for the given contract.   The user calls updateStrategy to reduce the liquidity of the Strategy associated with the NFT.  In the callback, the user calls the contract's function that transfers the NFT.   The contract transfers the NFT, checks the associated liquidity and gives the user a return.   The liquidity of the Strategy is reduced and the tokens are sent to the user.    Order data is now updated in storage before any possible calls to the user are performed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.6   Zero Amount ERC20 Transfers", "body": "  Some  tokens  revert  on  transfers  of  0  amount.  Calls  to  CarbonController.createStrategy potentially  try  to  perform  such  0-amount-transfers  if  one  of  the  given  orders  does  not  contain  liquidity. The call would revert in this case.    The code now transfers tokens only if the amount is greater than 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.7   Ambiguous Naming", "body": "  Some functions / error messages are named ambiguously in contrast to the naming of other entities:   The  error  GreaterThanMaxInput  is  thrown  in  CarbonController.tradeByTargetAmount  when a value is smaller than maxInput.   CarbonController.tradeSourceAmount  and  CarbonController.tradeTargetAmount are easily confused with tradeByTargetAmount and tradeBySourceAmount, but the meaning of target and source is reversed.  Bancor - Carbon -   13  SecurityLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                       \f Strategies._tradeSourceAmount  and  _tradeTargetAmount  are  easily  confused  with tradeByTargetAmount and tradeBySourceAmount, but the meaning of target and source is reversed.    Function names were changed and the error name was corrected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.8   Gas Inefficiencies", "body": "  1. If a pool does not already exist when creating a Strategy, the _createPool function returns  the created pool but it is not used and instead read from storage afterwards.  2. The Pool struct id field is redundant as the struct can only be accessed through a mapping  with Pool ID as key.  3. The StoredStrategy struct id field is redundant as the struct can only be accessed through  a mapping with Strategy ID as key.  4. In  _createPool,  the  _poolIds  mapping  is  set  up  with  the  tokens  in  sorted  and  reversed order. Instead, _pool could always sort the tokens before searching in the mapping with little overhead.  5. When updating a Strategy, the packed orders could be updated word by word, just like in the  _trade function.  6. In  tradeBySourceAmount  /  tradeByTargetAmount,  _validateTradeParams  loads  all Strategies  associated  with  the  given  trade  actions  from  storage.  _trade  later  loads  the Strategies from storage again.  7. In _trade, StoredStrategy fields are accessed multiple times (in storage), but could have  rather been saved to memory once.  8. In StoredStrategy, the fields owner and token1 might be redundant as they are not used in the contracts (except in events). Off-chain applications could extract the data elsewhere.    1. The returned pool from the _createPool function is now being used.  2. The id field was removed from struct.  3. The id field was removed from struct.  4. Sorting is now performed where needed, instead of the double sided storage.  5. Orders are now updated word by word.  6. validateTradeParams no longer loads the strategies.  7. Trade flow now loads values only once.  8. Both owner and the tokens were removed from the strategies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.9   Typographical Errors", "body": "  Some comments / symbol names contain typographical errors. Some examples are:  Bancor - Carbon -   14  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f PoolDoesNotExists error thrown in Pools._validatePoolExistance.   The comment \"revert here if the minReturn/maxInput constrants is unmet\" in Strategies._trade.   The   comment   \"the   address   of   the   admin   can't   be   change,   so   [...]\"   in  TransparentUpgradeableProxyImmutable.  Errors corrected:  Typographical errors in various sections of the code have been improved or removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.10   Unused Code", "body": "  A few pieces of code seem to be nut in use in the project anymore. This list is non-exhaustive:  1. In CarbonController, the error ZeroLiquidityProvided is unused.  2. In the MathEx library, the Math library of OpenZeppelin is imported but unused.  3. In Strategies, the StrategyUpdate struct is unused.    Unused code has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "6.11   _updateOrders Error Message", "body": "  Strategies._updateOrders  removes  the  target  amount  of  a  trade  from  the  respective  order's  y value. If this amount is actually larger than y, the transaction reverts on underflow. As this is a common case (for example for trades that are executed after some other trades on the same Strategy), an actual error message might make sense.    An error message has been created and is returned for this specific case.  Bancor - Carbon -   15  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "7.1   No Automatic Order Execution", "body": "  Orders  are  not  evaluated  against  the  set  of  currently  active  orders  upon  creation.  This  means,  that  an order with a price outside of the spread between buy and sell orders (on the respective \"other side\") is not executed against other orders but just included into the set of active orders. If a user were to place an order with a price that is not intended (e.g., due to keyboard input error), this order will be executed at exactly  that  price  (as  soon  as  a  trade  occurs),  even  if  there  are  other  open  orders  the  order  could  be executed against for a better price.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "7.2   Order Prices", "body": "  Users are able to choose order prices arbitrarily, making it possible to create strategies that do not make sense market-wise but might happen by mistake for example.  One could create a Strategy with the buy order prices being greater than the sell order prices, basically giving out liquidity to other users.  Another  possibility  is  a  Strategy  with  partially  overlapping  prices.  In  this  case  there  are  conditions  that could  lead  to  the  user  also  losing  liquidity.  Consider  the  following  example  of  a  Strategy  with  opposite orders in the same price range:   Fees are 0% for simplification.   The buy order buys A tokens for 100 B tokens with a price range of [1, 4].   The sell order sells 50 A tokens for B tokens with a price range of [1, 4].   A trader now buys 100 B tokens for a total of 50 A tokens on the buy curve.   The 50 A tokens are added to the liquidity of the sell curve, resulting in 100 A tokens liquidity. The  capacity of the sell curve is adjusted to 100, moving the curve.   The trader now immediately buys ~67 A tokens on the sell curve for the 100 B tokens they received  before.   The trader made an instant profit of ~17 A tokens.  For these reasons, it is important to note that users should be fully aware of the consequences of their strategy parameters choice.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "7.3   Token Incompatibilities", "body": "  Some tokens are not compatible with the system:   Tokens with fees.   Rebasing tokens.  Bancor - Carbon -   16  NoteVersion1NoteVersion1NoteVersion1          \f7.4   Trade Frontrunning  CarbonController.tradeBySourceAmount  and  tradeByTargetAmount  implement  slippage protection  in  order  to  mitigate  risks  of  frontrunning.  However,  as  Strategies  can  be  updated  by  their owners  for  relatively  cheap  and  with  arbitrary  values,  frontrunning  trades  in  Carbon  is  simpler/cheaper than on traditional AMMs. For this reason, users should keep their slippage protection tight and expect their minima/maxima to be hit regularly.  Consider the following example:   User1 creates a strategy with:   A = 1   B = 1   y = 100   z = 100   User2 creates a trade transaction based on this strategy and expects to receive exactly 100 tokens for the 50 tokens they send in (not considering fees). They set the minimum amount of tokens they want to receive to 80.   User1  observes  the  mempool  and  sees  the  transaction  User2  just  created.  They  now  create  an  updateStrategy transaction with the following changes to their strategy:   A = 0.5   User1 pays a miner to include this transaction before the transaction of User2 (or any other trade  transaction that is performed on the given strategy) in the next block.   After User2's transaction is executed, they receive only ~82 tokens instead of the expected 100.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "7.5   updateStrategy Denial of Service", "body": "  CarbonController.updateStrategy  employs  a  mechanism  that  ensures  that  a  strategy  has  not been  altered  between  the  creation  of  a  transaction  and  the  actual  execution.  An  attacker  could theoretically  block  certain  users  from  ever  updating  their  Strategies  by  frontrunning  their  calls  to updateStrategy with miniscule trades.  Nevertheless, users still have the possibility to delete and re-create their Strategies if they were targeted in such an attack.  Bancor - Carbon -   17  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-carbon/"}, {"title": "5.1   DOMAIN_SEPARATOR Is Not Recomputed if", "body": " chainId Changes  The ERC712Permit.DOMAIN_SEPARATOR is immutable, and thus won't be changed if the chain forks. If Ethereum fork in the future (like PoW fork), the chainId will change however the BasePositionManager on forked  chain  will  still  accept  permit  with  old  chainId.  This  leads  to  cross-chain  replay  attacks,  where signature from one domain is used on the other domain.  CS-KYBE2-003  Kyber Network - KyberSwap Elastic V2 -   12  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedSecurityLowVersion1RiskAccepted             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Oracle Observation Functions Parameters   -Severity Findings  -Severity Findings   Compiler and Library Versions    Missing Sanity Checks    Swap Amount Vs Price Limit Discrepancy    maxNumTicks Computation Can Be Wrong    secondsPerLiquidity of the First LP Starts at UNIX Time 0   0  1  0  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.1   Oracle Observation Functions Parameters", "body": "  The PoolOracle functions observe, observeSingle, and observeFromPoolAt accept arbitrary parameters time that should serve as a reference point for the secondsAgo parameter, and tick that should  be  used  to  transform  the  latest  observation  if  needed.  But  the  Oracle  library  requires  the provided  time  to  be  the  current  block  timestamp,  and  tick  to  be  the  current  tick  of  the  pool.  More specifically  for  time,  the  function  Oracle.lte  requires  a  and  b  to  be  chronologically  before  time. Thus, an arbitrary time parameter may return a wrong value for the accumulator. The same is valid for an arbitrary value of tick, which could yield an incorrect accumulator if the last observation had to be transformed.  CS-KYBE2-001  Example with arbitrary time:  cardinality = 8 block.timestamp = 1050 time = 550 secondsAgo = 100  With  the  following  state,  for  simplicity  assume  that  tick timestamps are showed:    ==observationTimestamp i  ,  only  the i  |350| |500| |700| |900| |1024| |150| |220| |300|                             ^index  Kyber Network - KyberSwap Elastic V2 -   13  CriticalHighCodeCorrectedMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected        \fthe function observeSingle(550, 100, 1024) will yield surrounding observations (4,0) (index 4 for  beforeOrAt  and  index  0  for  atOrAfter),  instead  of  the  expected  (0,1),  and  return  a  wrong tickCumulative value.  Description of changes:  observeFromPoolAt,   Remove  add observeSingleFromPool  to  read  a  single  observation  from  a  pool.  All  observe  functions  use block.timestamp as a time for.  observeSingle   observe,   functions,   and   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.2   Compiler and Library Versions", "body": "  Solc version 0.8.9 is not the most up-to-date version and has known bugs.  The smart contract libraries used by the project are:  \"@openzeppelin/contracts\": \"4.3.1\", \"@openzeppelin/contracts-upgradeable\": \"^4.6.0\",  However, these libraries are neither up to date nor consistent with one another.  CS-KYBE2-002    The OZ libraries now both use version 4.3.1.  Regarding the solc compiler Kyber Network responded:  We  didn\u2019t  upgrade  the  solidity  version  to  latest  as  it  could  increase  the  possible  changes  for  the protocol.  Known bugs in solc 0.8.9 should not be triggered the assessed codebase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.3   Missing Sanity Checks", "body": "  The function TicksFeesReader.getNearestInitializedTicks is missing input sanitization for the tick parameter. It can accept invalid ticks such that tick < MIN_TICK or tick > MAX_TICK. The while loops won't terminate for invalid ticks.  CS-KYBE2-004    A check was added.  require(T.MIN_TICK <= tick && tick <= T.MAX_TICK, 'tick not in range');  Kyber Network - KyberSwap Elastic V2 -   14  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.4   Swap Amount Vs Price Limit Discrepancy  CS-KYBE2-005  The  swap  terminates  in  2  cases:  specified  amount  is  exhausted  or  specified  price  limit  is  reached. However, there exists an edge case when specified amount is just enough to reach a price limit. In that case the Pool will rely on specified amount value as a limit, that will lead to computation of a new pool state  using  estimateIncrementalLiquidity  function.  If  the  price  limit  was  used,  the  new  state computation would be handled by calcIncrementalLiquidity function. The pool state is defined by prices and computation of a new state using token amounts leads to more numeric conversions and thus to less precision.  If  a  Pool  has  following  initialized  tick  ranges:  [a,  b)  [b,  c).  And  current  tick  is  b+1,  a  swap  specifying getSqrtRatioAtTick(b)  as  a  limit  would  switch  the  liquidity  to  the  value  of  [a,  b)  tick  range.  But  a swap swapQty needed to reach the same state would result in a pool state where the liquidity has not being shifted.    The computeSwapStep function uses calcIncrementalLiquidity when the usedAmount is equal to specifiedAmount. Thus, the more precise price limit is used for this edge case.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.5   maxNumTicks Computation Can Be Wrong", "body": "  In the functions TicksFeesReader.getTicksInRange , the computation of maxNumTicks can return a value that is too low when length==0, thus making the returned memory array incomplete.  CS-KYBE2-006  Example, when startTick < 0:  MAX_TICK = 2; MIN_TICK = -2; length = 0; startTick = -1; tickDistance = 1;  With this setting, maxNumTicks=3 and only the ticks -1, 0, 1 will be returned, missing the tick 2. In getAllTicks for this case will be: maxNumTicks=7, while should be 5.  Example, when startTick > 0:  MAX_TICK = 5; MIN_TICK = -5; length = 0; startTick = 2; tickDistance = 2;  With this setting, maxNumTicks=1 and only the tick 2 will be returned, missing the ticks 4 and 5.    Kyber Network - KyberSwap Elastic V2 -   15  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \fThe cases from above are fixed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.6   secondsPerLiquidity of the First LP Starts", "body": " at UNIX Time 0  CS-KYBE2-007  (LP)  opens   liquidity  provider   , the  When  a  1 poolData.secondsPerLiquidityUpdateTime  ==  0  and  _syncSecondsPerLiquidity()  will have  no  effect  since  no  base  liquidity  is  yet  in  the  pool.  When  the  second  position  is  opened  at  t , 2 _syncSecondsPerLiquidity() will update the state, but secondsElapsed will be equal to the time  will be accounted for since 0 delta from UNIX timestamp 0 until now (t instead of t  ). So, the liquidity added by LP  )  of  a  pool  at   first  position   (LP  1  1  2  .  t  1  Description of changes:  Always  update  the  poolData.secondsPerLiquidityUpdateTime  to  the  current  block  timestamp whenever the secondsElapsed > 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.7   Code Duplication", "body": "  In  the  case  !isToken0,  the  function  SwapMath.calFinalPrice  computes  the  same  tmp  value  in each of the subbranches. The computation can be carried out outside of the conditional structure.  CS-KYBE2-008    The common code was moved outside the branch bodies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "6.8   Wrong Comments", "body": "  The natspec of the struct IBasePositionManager.MintParams still mentions the fee in bps, but the fees have been updated to be in feeUnits.  CS-KYBE2-012    @param fee now correctly states that fee is in fee units.  Kyber Network - KyberSwap Elastic V2 -   16  CorrectnessLowVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                    \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "7.1   Gas Griefing Attack", "body": "  The swap function can perform multiple iterations of the while loop before terminating. Such execution can cost a lot of gas. Malicious actor can bring the pool price to an extremely high or low value. This can be  done  during  the  initial  Pool  unlock  or  via  swap.  While  swap  will  require  a  lot  of  gas  from  attacker, similar  amount  of  gas  will  also  be  required  to  bring  the  price  back  to  true  value.  Since  the  amount  of tokens needed to unlockPool is low, the cost of attack is small.  CS-KYBE2-009  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "7.2   Oracle Limitations", "body": "  The tickCumulative from PoolOracle contract can be used to compute the time-weighted average tick for a given period of time. If the price is computed from this tick, this is effectively a geometric mean of the  time-weighted  average  price  (gm-TWAP).  Compared  to  the  arithmetic  mean  TWAP  (am-TWAP), gm-TWAP  is  more  sensitive  to  upward  price  movements  and  less  sensitive  to  downward  price movements. Any protocol that plans to use PoolOracle needs to be aware of this.  In addition, in PoS consensus, the multi-block price manipulations are possible on AMM protocols:  CS-KYBE2-010   https://chainsecurity.com/oracle-manipulation-after-merge/   https://blog.uniswap.org/uniswap-v3-oracles  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "7.3   PoolOracle Observations Mapping Collision", "body": "  The mapping(address => Oracle.Observation[65535]) field in PoolOracle contract allows any msg.sender to modifier consecutive 2**16 storage slots. This theoretically can write to storage slot 151 and  thus  overwrite  the  owner  of  the  contract.  Note  that  solidity  does  not  check  for  storage  pointer overflows. However, this is a practically impossible attack, since it requires attacker to find an address that corresponds to mapping storage slot with 240 fix bits.  CS-KYBE2-011  Kyber Network - KyberSwap Elastic V2 -   17  InformationalVersion1RiskAcceptedInformationalVersion1RiskAcceptedInformationalVersion1RiskAccepted                \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-elastic/"}, {"title": "5.1   Complexity of Commands Effect Evaluation", "body": "  Due to the novelty and non-standard encoding of Weiroll, the end user will need to sign a transaction, without knowing full details about the execution consequences. Standard hardware and software wallets won't  be  able  to  decode  the  content  of  the  commands.  As  a  result,  users  will  need  to  perform blind-signing - signing without verifying the full transaction details. Phishing attacks can be performed on users  to  trick  them  to  sign  commands  that  will  impact  the  token  balances  in  an  undesired  way.  Users should be notified about this risk and only sign transactions from trusted sources and ideally after careful inspection.  Enso - Enso-Weiroll -   10  DesignCorrectnessCriticalHighMediumLowRiskAcceptedDesignLowVersion1RiskAccepted            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Function writeOutputs Can Corrupt Memory   -Severity Findings   Assumptions on Output From Unsuccessful Call    Dynamic Variable Encoding Is Assumed to Be Correct    The Index Is Not Masked    Value for the Call Can Be Loaded From Wrong Memory Location   -Severity Findings  IDX_USE_STATE Case Not Handled Inside Tuples and Arrays    Non-terminated Indices Fail Silently    Unbalanced Tuple Starts and Ends Cause Silent Failure   0  1  4  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.1   Function writeOutputs Can Corrupt Memory", "body": "  To store the pointer of the return data the writeOutputs function performs a write to memory at the index  state  +  32  +  (idx  &  IDX_VALUE_MASK)  *  32  .  However,  a  check  that  this  location  still belongs to the state array of pointers is not performed. This effectively permits writing to locations in memory  that  can  contain  other  variables,  including  data  of  other  state  elements.  The  command (maliciously or accidentally) can trigger such writing and cause unexpected results.    A check was introduced that verifies that idx & IDX_VALUE_MASK < state.length.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.2   Assumptions on Output From Unsuccessful", "body": " Call  Unsuccessful calls are assumed to revert with no output data, with output data of the type Panic() (4 bytes  selector,  empty  payload),  or  with  output  data  of  the  type  Error(string)  (4  bytes  selector,  32 bytes pointer, 32 bytes string size, string content).  Errors can however have arbitrary signatures, which are up to the contract implementors to define.  Enso - Enso-Weiroll -   11  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                 \fFor example, an error of type Error(uint256,uint256) will have its second integer interpreted as a string length in the VM error handling, potentially causing a memory expansion that will consume all the gas, if the uint256 value is big enough.    Additional checks have been introduced to interpret the return data of the error as a string only when it is appropriate to do so.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.3   Dynamic Variable Encoding Is Assumed to Be", "body": " Correct  When CommandBuilder builds inputs from the state, the variable length case for bytes and strings (not array, not tuple) does not verify that the state element at the given index is correct abi encoded data. The following consequences are possible:  The case when state[idx & IDX_VALUE_MASK].length == 0 is not handled correctly. During the encode  loop,  this  is  executed  free  +=  state[idx  &  IDX_VALUE_MASK].length  at  line  113,  or offset += state[idx & IDX_VALUE_MASK].length at line 320. However if the state element is the empty bytes sequence \"\", the free or offset/pointer pointer does not change. The encoding of such  a  state  element  will  write  a  pointer  to  unallocated  free  memory.  If  any  other  dynamic  variable  is allocated  afterward  the  pointer  of  the  empty  state  element  will  point  to  the  same  location.  The  checks performed  requires state[idx & IDX_VALUE_MASK].length % 32 == 0 - this does not prevent the empty state case.  setupDynamicVariable()   in     The following fix was done to address the issue:  A  constraint  was  added  for  the  dynamic  variable  case  in  the  setupDynamicVariable  function:  in addition to state[idx & IDX_VALUE_MASK].length % 32 == 0 check, a check that this lengths does not equal 0 was added. This resolves the issue.  Enso responded:  Added check to revert if argLen == 0 (weiroll.js already encodes 0x as a full bytes32 value, so the state generated with weiroll.js will be unaffected). Also, we now check the variable\u2019s encoded size is the same as the content size.  Note:  The weiroll.js library is out of scope for this assessment, however, encoding of an empty string as full  bytes32  value  does  not  fully  comply  with  abi  encoding.  Such  behavior  was  considered  a  bug  in solidity. Some contracts with strict decoding rules might not accept empty strings encoded this way.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.4   The Index Is Not Masked", "body": "  The IDX_VALUE_MASK is not applied to index values at certain places:  1. Mask is not applied on the index in VM smart contract at line 94.  Enso - Enso-Weiroll -   12  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f2. Mask is not applied on the index in CommandBuilder smart contract at line 396.    The appropriate index masking has been applied.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.5   Value for the Call Can Be Loaded From Wrong", "body": " Memory Location  When a call with value is performed in VM the first index is treated as an index for the state element. The read from this memory location is done via assembly instruction.  bytes memory v = state[uint8(bytes1(indices))]; assembly {     callEth := mload(add(v, 0x20)) }  This mload skips 1 word - the length of the state element. However, the state element can be empty. In this  case,  the  mload  will  read  memory  allocated  for  other  data.  Since  callEth  should  be  a  uint256 typed argument, it should be treated the same way as any other static variable.    Enso responded:  We now validate that the state element\u2019s length is 32 bytes and convert it into a uint256.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.6   IDX_USE_STATE Case Not Handled Inside", "body": " Tuples and Arrays  Indices with the value IDX_USE_STATE behave differently according to whether they belong to dynamic tuples or not. Inside dynamic tuples, the 0xfe == IDX_USE_STATE index is treated as variable length data (bytes or string). 0xfe value is masked and used as an index to 126 state bytes element. Outside of dynamic tuples, it causes the whole state to be ABI encoded at that position. This difference in behavior is not mentioned in the specification.    IDX_USE_STATE now explicitly reverts when used inside a dynamic tuple or array.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.7   Non-terminated Indices Fail Silently", "body": "  Enso - Enso-Weiroll -   13  CorrectnessMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fIf FLAG_EXTENDED_COMMAND is used, and no FF index is included in the indices list, an invalid input will be produced by CommandBuilder.buildInputs() instead of reverting, causing the external contract call to have invalid data.    A new variable, indicesLength, keeps track of the number of indices that needs to be considered by commandBuilder.buildInputs()  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.8   Unbalanced Tuple Starts and Ends Cause", "body": " Silent Failure  In  CommandBuilder.buildInputs()  every  dynamic  array  or  tuple  start  should  be  matched  by  an index of value IDX_DYNAMIC_END. Failing to match opening and closing structures causes offsets not to  be  updated,  and  invalid  output  to  be  produced.  The  invalid  result  risks  being  passed  to  arbitrary external calls.  Since  functions  setupDymamicTuple  and  encodeDynamicTuple  need  to  encounter  an  index IDX_DYNAMIC_LENGTH  to  exit  correctly,  the  alternative  return  statements  at  lines  226  and  343  are superfluous and should never happen.    Function setupDynamicTuple now reverts if no terminating index is found for a dynamic tuple or array.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "6.9   DELEGATECALL and SELFDESTRUCT", "body": "  The VM abstract contract allows DELEGATECALL to the address specified in the command. Any contract that  will  inherit  this  functionality  must  not  perform  a  call  to  an  arbitrary  user-specified  address.  The delegate  call  to  an  address  that  has  a  bytecode  with  SELFDESTRUCT  opcode  will  cause  permanent destruction  of  the  smart  contract.  Thus,  it  is  important  to  allow  DELEGATECALL  only  to  trusted  smart contracts.    Enso responded:  We have removed delegate calls from the VM entirely as there was both risks to the contract via self destruct as well as the ability to change storage values of the importing contract, potentially bricking the contract.  Enso - Enso-Weiroll -   14  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "7.1   Calls to Addresses With No Code", "body": "  The low-level delegatecall, call, and staticcall operations will succeed when used with addresses with no code,  however,  in  the  VM  there  seems  to  be  no  reason  to  use  them  on  addresses  with  no  code, excluding the precompiled contracts. Only VALUECALL has a reason for being used on an address with no code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "7.2   Floating Pragma", "body": "  Enso-Weiroll uses the floating pragma ^0.8.16. Several assumptions about the layout of memory are made in the code, which could potentially change without a major version upgrade. Any solidity compiler version needs to be carefully tested before the deployment of the code to ensure stable functionality.  Enso - Enso-Weiroll -   15  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enso-weiroll-smart-contracts/"}, {"title": "5.1   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity 0.6.6;  in  Known  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1416  version   bugs   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "0.6.6 ", "body": "  0  0  0  2  are:  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At  the  time  of  writing  the  most  recent  Solidity  release  is  version  0.6.12.  For  version  0.6.x  the  most recent release is 0.6.12 which contains some bugfixes but no breaking changes.  The compiler was not changed as the client responded:  We will address this later for an overall code review.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "5.2   _weth Could Be a Constant", "body": "  The  constant  _weth  which  represents  the  same  address  across  all  Enzyme  Bridges  could  be  set  as constant. This would reduce unnessesary storage operations.  Acknowledged:  Avantgarde Finance - Unslashed-Enzyme Bridge -   8  DesignCorrectnessCriticalHighMediumLowRiskAcceptedAcknowledgedDesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                  \fAvantgarde Finance is aware of this and commented that it does have a significant impact as the variable will be accessed a few times only.  Avantgarde Finance - Unslashed-Enzyme Bridge -   9    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Denomination Asset Check on Initialization    Redeem Shares Return Value Not Used    withdrawEthToInvestor Specification Discrepancy   0  0  0  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "6.1   Denomination Asset Check on Initialization", "body": "  For the correct operation of the bridge, it is critical that the denomination asset of the vault is correctly set to WETH during initialization. Such a check is not present in the code.  Code Changed:  A check has been introduced in the initialize function  require(IComptrollerProxy(controllerProxy).getDenominationAsset() == weth, \"EnzymeBridge: wrong fund asset\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "6.2   Redeem Shares Return Value Not Used", "body": "  The return values of  IComptrollerProxy(_controllerProxy).redeemShares()  and  IComptrollerProxy(_controllerProxy).redeemSharesDetailed(...)  are  not  used.  Both  functions  return  the  payout  assets  and  amounts.  Instead,  the  resulting  amount  of tokens  is  checked  using  balanceOf(...),  incurring  additional  gas  costs.  The  benefit  of  the  current implementation  is  the  fact  that  one  can  withdraw  tokens  that  were  already  in  the  vault  before  the redemption. However, this choice is inconsistent with the later choice to only send the ether which was recently unwrapped.  Avantgarde Finance - Unslashed-Enzyme Bridge -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fuint256 result = IWETH9(_weth).balanceOf(address(this)); IWETH9(_weth).withdraw(result); // returns eth to us IInvestable(_investor).receiveEthFromFund{value: result}();  Code Corrected:  return  value  of  redeemShares  and The  code  has  been  changed  so  redeemSharesDetailed. Moreover, the returned result is used to ensure that only one returned asset is used. Finally, the code now withdraws a consistent amount of WETH and ETH. of  it  uses   the   (, payoutAmounts) = IComptrollerProxy(_comptrollerProxy).redeemShares();  ....  (, payoutAmounts) = IComptrollerProxy(_comptrollerProxy).redeemSharesDetailed(sharesQuantity, empty, empty); ...  require(payoutAmounts.length == 1, \"EnzymeBridge: fund not converted\"); ...  uint256 result = payoutAmounts[0]; IWETH9(_weth).withdraw(result); // returns eth to us IInvestable(_investor).receiveEthFromFund{value: result}();  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "6.3   withdrawEthToInvestor Specification", "body": " Discrepancy  The comment for withdrawEthToInvestor reads as follows: Note that due to possible sha re value rounding the resulting amount may be slightly greater than requested .  Another rounding error may happen when the shares' quantity required is calculated:  uint256 sharesQuantity = amount.mul(PRECISION_18E).div(shareValue18ePrecision);  Consider  the  case  when  the  share  value  is  not  affected  by  rounding  errors.  Due  to  possible  rounding errors  when  the  shares'  quantity  is  calculated,  the  shares'  quantity  required  to  receive  the  amount  in WETH may be underestimated. Hence the Ether amount withdrawn might be slightly smaller and thus the comment does not hold.  Specification Changed:  The documentation correctly now states:  /// Note that due to possible share value or division rounding /// the resulting amount may be slightly greater or smaller than requested.  Avantgarde Finance - Unslashed-Enzyme Bridge -   11  CorrectnessLowVersion1Speci\ufb01cationChanged        \f7   Notes  We leverage this section to highlight further findings that are not necessarily issues. The bridge contract in  scope  for  this  review  connects  Unslashed  to  Enzyme  which  consists  of  many  interacting  contracts. Hence, the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead, they should raise awareness in order to improve the overall understanding for users and developers  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "7.1   Illiquid Lending Providers", "body": "  The  basket  can  only  withdraw  when  all  assets  of  the  fund  have  been  exchanged  into  WETH.  Illiquid liquidity protocols may be unable to redeem a large amount of tokens at times. Hence a fund manager may be unable to redeem all assets into their underlying.  E.g. a large amount of WETH has been lent into the Aave liquidity pool. When the fund manager wants to redeem this large amount of derivative tokens back into the underlying WETH, it could be the case that the liquidity may be insufficient as currently a large amount of WETH is lent out.  During this period Ether withdrawal is blocked.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "7.2   Migration to New Enzyme Release Is Not", "body": " Supported  This  Enzyme  Bridge  in  connection  with  the  current  implementation  of  the  Basket  contract  does  not support the migration of a fund to a new release of Enzyme.  When a fund is upgraded in Enzyme, the ComptrollerProxy is replaced by a new one while the old one is selfdestructed. The VaultProxy holding the funds remains.  After such a migration all calls from the bridge to the comptroller will fail as the contract no longer exists. This affects all three functions ( deposit / withdraw / getBalance ).  Note that function setFund() of the basket contract cannot be used to recover from this situation: This function  requires  the  fund's  balance  to  be  0.  The  call  to  the  non-existing  comptroller  will  revert  the transaction.  All shares should be redeemed before a migration is initiated. Shares remaining after a migration might be stuck with the current code.  After looking at the migration scripts present, we understand that the EnzymeBridge is to be used via a Proxy. This would allow to upgrade the implementation and recover the shares.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "7.3   No Fees", "body": "  Funds of Enzyme can configure fees investors have to pay in order to participate in a fund. These fees are paid to the fund manager in the form of shares. Note that the implementation of the Enzyme Bridge relies  on  the  fact  that  the  basket  is  the  only  shareholder  of  the  fund  and  no  other  address  holds  such shares. Hence enabled fees for the fund are not compatible with the bridge, funds of the bridge must not have fees configured.  Avantgarde Finance - Unslashed-Enzyme Bridge -   12  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/unslashed-enzyme-bridge/"}, {"title": "6.1   file() Has No Access Control", "body": "  Function  file()  can  add  and  remove  valid  domains  and  should  be  called  carefully  by  governance. However, the function lacks access control.    Access control was added to file().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-teleport/"}, {"title": "6.2   finalize_register_teleport() Only", "body": " Possible When Open  Calling finalize_register_teleport() on Starknet allows users to take the slower route through Starknet message passing to L1 to prevent censorship by the oracles and ensure availability if oracles are down. However, given that the function is not callable if the bridge is closed, the system, in contrast to the Teleport for Optimism and Arbitrum, is not fully trustless, as users could be censored by closing the teleport instance. Further, censored users that had their L2 DAI burned, will not be able to recover it.    The precondition of finalize_register_teleport() has been removed.  MakerDAO - Starknet Teleport -   10  CriticalHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedSecurityMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                    \f6.3   No Event for finalize_teleport()  finalize_teleport() emits no event in contrast to other functions (e.g. initiate_teleport()). Emitting more events could lead to a better user-experience and easier integration with front-ends.    An event has been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-teleport/"}, {"title": "6.4   Unused Code", "body": "  l2_dai_teleport_gateway  prepares  a  payload  in  initiate_teleport()  even  though  it  remains unused.  l2_dai_teleport_gateway has several unused imports:   BitwiseBuiltin   hash2   assert_le  is_not_zero   get_contract_address   uint256_lt   uint256_check    Unused imports and unused code were removed.  MakerDAO - Starknet Teleport -   11  DesignLowVersion2CodeCorrectedDesignLowVersion1CodeCorrected               \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-starknet-teleport/"}, {"title": "6.1   Rogue Strategy Can Override Storage", "body": "  Core accounting logic is done by the code of TokenizedStrategy which is executed as Delegatecall inside the context of the strategy.  The documentation states the following:  In order to limit the strategists need to think about their storage variables all TokenizedStrategy specific variables are held within and controlled by the TokenizedStrategy. A BaseStrategyData struct is help at a custom storage location that is high enough that no normal implementation should be worried about hitting.  CS-YTS-004  This means all high risk storage updates will always be handled by the TokenizedStrategy, can not be overriden by a rogue or reckless strategist and will be entirely standardized across every strategy deployed, no matter the chain or specific implementation.  A  rogue  or  reckless  strategist  can  overwrite  any  storage  slot,  including  those  at  the  address keccak256(\"yearn.base.strategy.storage\") - 1 and subsequent addresses.  While a genuine strategy wouldn't do this and the concept to separate the storage ensures that with high probability a specific implementation is unlikely do to so by accident, a rogue or reckless strategies can do so intentionally.  Specification changed:  Yearn acknowledged this risk and corrected the specification.  Yearn - Tokenized Strategy -   12  CriticalHighMediumSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedRiskAcceptedSpeci\ufb01cationChangedCorrectnessMediumVersion1Speci\ufb01cationChanged           \f6.2   Initializing TokenizedStrategy  The deployed instance of TokenizedStrategy is only intended to be used via Delegatecall by the custom strategies.  However  the  functions  of  the  contract  are  also  directly  callable.  For  example  the  first  caller  of TokenizedStrategy.init() can initialize the contract. While this doesn't break it's intended use as base for the delegatecalls, it's not desirable.  It's worth noting that after initialization, deposits will still fail due to the callback to the invest() function.  Other functions may execute successfully, such as approvals, role assignments, and parameter updates.  CS-YTS-008    A  constructor  has  been  added  to  TokenizedStrategy  which  initializes  the  implementation  with _strategyStorage().asset=address(1).  As  a  result,  further  direct  calls  to  initialize()  will revert.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "6.3   Non ERC-4626 Compliant Functions", "body": "  maxMint  may  revert  due  to  an  overflow  in  a  calculation,  however  according  to  the  specification  this function  must  not  revert.  This  may  happen  in  an  edge  case  the  availableDepositLimit  returns  a large number and pps<1, convertToShares may overflow.  CS-YTS-007  function maxMint(address _owner) public view returns (uint256 _maxMint) {     _maxMint = IBaseTokenizedStrategy(address(this)).availableDepositLimit(         _owner     );     if (_maxMint != type(uint256).max) {         _maxMint = convertToShares(_maxMint);     } }  In  case  the  strategy  is  in  shutdown  mode,  no  further  deposit  can  be  made.  However,  maxDeposit() may not return 0 when the strategy is shutdown.  The ERC-4626 specification however requires the function to return 0 in this case:  ... if deposits are entirely disabled (even temporarily) it MUST return 0.  More  informational,  the  ERC-4626  specification  is  loosely  defined  in  these  corner  cases  for  these functions. Nevertheless we want to highlight the potentially unexpected amounts returned:  previewRedeem(): In case totalAssets is zero, the conversion is done at a 1:1 ratio. At this point either no shares exist (I) or the value of the existing shares has been dilluted to 0 (II). For (I) the returned value  of  0  is  appropriate.  For  (II)  previewRedeem()  does  not  revert  while  redeem()  reverts;  the specification reads:  Yearn - Tokenized Strategy -   13  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \fMAY revert due to other conditions that would also cause redeem to revert.  previewWithdraw()  returns  the  amount  in  a  1:1  exchange  rate  when  assets==0  but  shares!=0. Again for non-zero values the amount returned may be misleading.  Strictly  speaking  the  value  returned  is  not  breaking  the  specification  but  might  be  unexpected  by  the caller.  The  caller  should  be  aware  of  this  and  any  external  system  should  exercise  caution  when integrating with these functions.    A  comment  has  been  added  to  availableDepositLimit  to  alert  the  strategist  of  the  potential overflow of maxMint() if the deposit limit is too large. In addition, maxDeposit() and maxRedeem() have  been  updated  to  return  0  when  the  strategy  is  shutdown.  previewWithdraw()  and convertToShares()  have  been  adjusted  to  return  0  instead  of  pps=1  in  case  assets==0  but supply>0.  Yearn  also  acknowledged  return  value  of previewRedeem()  if  all  shares  are  diluted  to  0.  Strategists  and  external  systems  are  expected  to  be aware of these behaviors.  the  potential  misleading  non-zero   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "6.4   Payable Fallback Functions", "body": "  The fallback function of `BaseTokenizedStrategy` is marked as payable. However, the code of the delegatecalled  TokenizedStrategy  contract  doesn't  feature  any  functionality  able  to  receive  Ether.  Any such call with a non zero msg.value will revert.  Furthermore, there is a receive() function:  CS-YTS-006  /**  * We are forced to have a receive function do to  * implementing a fallback function.  *  * NOTE: ETH should not be sent to the strategy unless  * designed for within the Strategy. There is no defualt  * way to remove eth incorrectly sent to a strategy.  */ receive() external payable {}  There  is  no  requirement  to  implement  a  receive  function  when  incorporating  a  fallback  function.  In  the absence of a receive function, plain Ether transfers would be handled by the fallback function, which then delegatecalls into the TokenizedStrategy. However, this would cause the call to revert since the contract does not support Ether reception. By including a receive function, the strategy can be enabled to accept Ether. As the comment states, Ether shouldn't be sent to the strategy unless the strategy is design for it.  For  https://docs.soliditylang.org/en/v0.8.18/contracts.html#receive-ether-function  information   please   more   refer   the   to   Solidity   documentation:    The payable modifier and the receive function have been removed to avoid unintentional Ether reception.  Yearn - Tokenized Strategy -   14  DesignLowVersion1CodeCorrected          \f6.5   Problematic Self-Minting When Fee Recipient Is the Contract Itself  CS-YTS-005  Transferring  shares  of  the  strategy  to  itself  is  prevented  since  it  can  interfere  with  the  locked  shares mechanism  which  guards  against  abrupt  price  per  share  increases.  Unlike  _transfer(),  _mint() does  not  feature  this  restriction  since  it  is  intended  to  mint  shares  for  this  contract  as  part  of  the  profit locking mechanism. An explicit check must be done in the function calling _mint(). While this is done in _deposit(), such a check isn't done on the fee recipients.  When  the  performanceFeeRecipient  is  set  as  the  strategy  itself,  it  becomes  possible  to  mint additional shares to the strategy, which are not intended to be locked shares.  Once  enough  time  passes  and  the  fullProfitUnlockDate  is  reached,  _unlockedShares()  will treat the entire balance of this contract, including these additional shares, as unlocked shares.  if (_fullProfitUnlockDate > block.timestamp) {     unchecked {         unlockedShares =             (S.profitUnlockingRate * (block.timestamp - S.lastReport)) /             MAX_BPS_EXTENDED;     } } else if (_fullProfitUnlockDate != 0) {     // All shares have been unlocked.     unlockedShares = S.balances[address(this)]; }  Due  to  the  presence  of  extra  shares,  there  may  be  a  sudden  increase  when  querying  the unlockedShares just before and right after the fullProfitUnlockDate.  This effect may have an impact whenever _totalSupply() is called and may influence the the price per share.  Additionally process_report() is affected. In case the fullProfitUnlockDate has already been reached these shares would simply get burned in _burnUnlockedShares(). Otherwise these shares will be considered as part of the previouslyLockedShares and are locked in the new locking period. Note as this is an increase of the previouslyLockedShares it will impact the calculation of and reduce the newProfitLockingPeriod:  // new_profit_locking_period is a weighted average between the remaining     // time of the previously locked shares and the PROFIT_MAX_UNLOCK_TIME     uint256 newProfitLockingPeriod = (previouslyLockedShares *         remainingTime +         sharesToLock *         _profitMaxUnlockTime) / totalLockedShares;  The issue description focuses on the performanceFeeRecipient as fee recipient, in theory the same situation could arise if the protocolFeesRecipient is set as the strategy contract.    An  extra  check  has  been  added  in  setPerformanceFeeRecipient()  as  well  as  in  init()  which prevents setting the fee recipient to address(this).  Risk accepted:  Yearn - Tokenized Strategy -   15  CorrectnessLowVersion1CodeCorrectedRiskAccepted        \fThe protocolFeeRecipient is set once for all strategies by Yearn Governance and should not be an issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "6.6   Staticcall", "body": "  CS-YTS-009   * Using address(this) will mean any calls using this variable will lead  * to a static call to itself. Which will hit the fallback function and  * delegateCall that to the actual TokenizedStrategy.  ITokenizedStrategy internal TokenizedStrategy;  The comment says that using address(this) will result in a static call to itself, but the term \"static call\" might be misleading. In Ethereum, a \"static call\" typically refers to a STATICCALL, which is a read-only call that cannot modify the contract state. However, in this case, the comment seems to be referring to the fact that the call will simply be to the contract itself. Such calls can lead to state changes.  Specification changed:  Yearn has rephrased the comment to avoid misunderstandings. A legitimate strategist should not use this variable for state-changing calls.  Yearn - Tokenized Strategy -   16  CorrectnessLowVersion1Speci\ufb01cationChanged        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "7.1   Uncovered Loss Not Visible in Reported Event", "body": "  An event Reported will be emitted after report() is called. If an uncovered loss has been realized, this crucial information won't be visible in the event. In case a net loss occurs, price per share decrease (pps) instantly. Revealing this in the event may be useful.  event Reported(uint256 profit,uint256 loss,uint256 performanceFees,uint256 protocolFees)  CS-YTS-001  Yearn states:  The event is meant to match the Vaults event as close as possible and only reveal the amounts determined within the report call. It should be expected that most reports in strategies will be done after all shares have been unlocked since the previous reports, and therefore any loss will cause a PPS decrease. Specific strategies can use this functionalities if desired to offset losses but is not normal behavior, simply extra functionality. PPS is not tracked on chain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "7.2   Use ADDRESS Instead of SLOAD", "body": "  BaseTokenizedStrategy.initialize()  sets  the  storage  variable  TokenizedStrategy  to  the address of the executing context:  CS-YTS-002  // Set instance of the implementation for internal use. TokenizedStrategy = ITokenizedStrategy(address(this));  To call itself, the code of the BaseTokenizedStrategy and the custom strategy implementation would use this  variable  which  results  in  an  SLOAD  operation.  Note  that  opcode  ADDRESS  (in  solidity address(this))  would  return  the  same  address  (the  address  of  the  executing  account)  and  is significantly cheaper.  Yearn states:  The setting of the `TokenizedStrategy` variable in initialization is meant to make it as simple as possible for a strategist to access readable data from the StrategyData struct so having an extra SLOAD is  Yearn - Tokenized Strategy -   17  InformationalVersion1InformationalVersion1      \fworth the reduced complexity of not having to understand what is being called, just that the variable will work.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "7.3   tendTrigger", "body": "  The description of TokenizedStrategy.tend() reads:  * @dev Both 'tendTrigger' and '_tend' will need to be overridden * for this to be used.  However this is not enforced in the code, where tendTrigger() has no effect on tend(), e.g. it could return false and tend() may still execute successfully.  CS-YTS-003  Yearn states:  `tendtrigger` is only to be used off chain, by a keeper bot or management to easily determine if tend should be called, not a requirement for it to be. Tend is able to be called at any point even if the trigger does not say it should.  Yearn - Tokenized Strategy -   18  InformationalVersion1    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "8.1   Withdraw With Unrealized Loss", "body": "  In case there is an unrealized loss, the most vigilant users will come to withdraw funds directly from the idle to avoid the loss. As a result, the tardy users will take the unrealized loss. Besides, tardy users may take an unrealized loss in different ways depending on the actual implementation of _freeFunds().  If custom strategy implementation simply tries to free the funds from the yield source as closer to the requested amount as possible or simply reverts due to insufficient funds, the remaining funds will be withdrawn in a FCFS way where the last users will take all of the unrealized loss and get nothing back.  If  custom  strategy  implementation  distributes  the  unrealized  loss  according  to  the  accounting variables in StrategyData, then all tardy user will share the unrealized loss proportionally.  Different  strategists  may  take  different  choices,  whereas  the  vigilant  users  can  always  drain  the  idle regardless of the unrealized loss in both cases.  Yearn states:  So for the most part those types of decisions are to be left to the strategist to determine what to do in _freeFunds(). The majority of strategies will likely simply withdraw the amount requested, since its 1. not applicable and 2. would require a lot more gas and code to check the actual current state and calculate the full unrealized loss etc. Though if a strategy expects to have this be a common case (like with an options strategy) that specific strategist can add whatever they wish to _freeFunds. It is recommended that _freeFunds revert if losses would be realized by temporary situations. Such as liquidity constraints, that are not expected to last, rather than count it as a loss.  While its possible there are unrealized losses, normal behavior is to not account for those in between reports, but rather losses are handled withdraw by withdraw. Though that can lead to disproportionate amounts depending on when funds are withdrawn its much cheaper and simpler considering its a non-issue for the majority of strategies and the ones it is can choose how to deal with it.  Yearn - Tokenized Strategy -   19  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-tokenized-strategy/"}, {"title": "6.1   DssProxy Constructor Does Not Emit", "body": " SetOwner Event  The constructor of DssProxy does not emit a SetOwner event. Consider emitting an event here to reflect this important storage change.  constructor(address owner_) {     owner = owner_; }    The constructor now emits the setOwner event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-proxy/"}, {"title": "6.2   Optimization of delegatecall Success", "body": " Check  The success check in the execute function of the DssProxy contract is as follows:  assembly {     let succeeded := delegatecall(/*...*/)     /*...*/     switch iszero(succeeded)  MakerDAO - Dss Proxy -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f    case 1 {         revert(add(response, 0x20), size)     } }  However, as delegatecall can only return 0 or 1, the iszero is unnecessary. Instead, one can simply check for case 0. With optimization enabled, this change saves 9 gas and 4 bytes of bytecode.    The optimization has been implemented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-proxy/"}, {"title": "6.3   Possible Failure of create2", "body": "  It is possible for the create2 operation to fail, in which case the returned address will be 0. This failure is not checked, which would result in isProxy[0] being set to 1. Additionally, the owner's seed would be incremented despite not having deployed a contract.  assembly {     proxy := create2(/*...*/) } proxies[owner_] = proxy; isProxy[proxy] = 1;    The code now ensures that the DssProxy has been successfully created:  require(proxy != address(0), \"DssProxyRegistry/creation-failed\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-proxy/"}, {"title": "6.4   Possible Optimization in Proxy Check of", "body": " Registry  In the claim function of the DssProxyRegistry, the following check is made:  require(isProxy[proxy] == 1, \"DssProxyRegistry/not-proxy-from-this-registry\");  The  isProxy  mapping  only  contains  the  values  0  or  1.  Hence,  checking  the  condition  ==  1  is functionally  equivalent  to  checking  the  condition  !=  0.  The  latter  check  is  more  efficiently  compiled,  it saves 6 gas and reduces bytecode by 3 bytes.    MakerDAO - Dss Proxy -   11  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fThe optimization has been implemented.  MakerDAO - Dss Proxy -   12  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-proxy/"}, {"title": "7.1   No Event on execute", "body": "  Integrations must be aware that compared to the DSProxy it replaces, DssProxy no longer emits a event on execute().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-proxy/"}, {"title": "7.2   isProxy Might Point to Addresses Without", "body": " Code  When creating a proxy with the build function, an entry is created in isProxy, which maps the address of the new proxy to 1 :  function build(address owner_) external returns (address payable proxy) {     /*...*/     isProxy[proxy] = 1; }  This  entry  cannot  be  modified.  Hence,  a  proxy  that  has  been  selfdestructed  would  still  appear  in isProxy like a valid proxy.  A selfdestructed proxy in the isProxy mapping would have prevented creation of a new proxy for the owner  using  DssProxyRegistry.build():  Retrieving  the  owner  would  have  reverted.  The implementation of DssProxyRegistry.build() has been changed to handle this case.  MakerDAO - Dss Proxy -   13  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-proxy/"}, {"title": "5.1   Asymmetrical Norm in Price Update Threshold", "body": "  In the tweak_price function the norm value is calculated to determine whether the distance between price_oracle  and  price_scale  is  sufficiently  large  so  that  a  price  update  should  be  tried.  To calculate the norm, the ratios between the price_scale and price_oracle are used. However, the ratios aren't treated symmetrically, i.e. if price_oracle = price_scale * 1.1 then the value 0.1^2 is added to the norm, but if the ratio is reversed, price_oracle * 1.1 = price_scale, then the value 0.09^2 is added. This means the price update is more sensitive to changes where the price oracle is too high, than when it is too low.  Acknowledged:  As typical differences between price_scale and price_oracle are between zero and five percent, the  effect  is  not  as  large.  Hence,  Swiss  Stake  GmbH  decided  to  not  make  any  more  changes  at  the moment  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "5.2   Missing Boundary or Sanity Checks When", "body": " Initializing  Most  variables  have  implicitly  or  explicitly  enforced  minimal  and  maximal  values  or  should  not  take certain values like address zero. These are enforced when changing the values or given the ownership through a claiming scheme. However, there are no sanity checks or any checks at all when initializing the contract. Mistakes can happen and silently set one of the values to an obviously incorrect value.  Swiss Stake GmbH - Tricrypto -   9  DesignCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedDesignLowVersion3AcknowledgedDesignLowVersion1Acknowledged                 \fAcknowledged  Swiss Stake GmbH is aware of the issue and confident no deployment errors will happen. In case of a factory contract the issue needs to be reconsidered.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "5.3   Potential Gas Savings in tweak_price", "body": "  The following code is present in the tweak_price function:  xp: uint256[N_COINS] = empty(uint256[N_COINS]) xp[0] = D_unadjusted / N_COINS for k in range(N_COINS-1):     xp[k+1] = D_unadjusted * 10**18 / (N_COINS * price_scale[k]) xcp_profit: uint256 = 10**18 virtual_price: uint256 = 10**18  these   Most  of  condition old_virtual_price  >  0  is  true.  Hence,  these  variables  could  be  moved  inside  of  the  condition  to save gas in case the condition evaluates to false.  (except  xcp_profit)  are  only  used  when   variables   the   Acknowledged  Swiss  Stake  GmbH  acknowledges  the  issue  with  the  reasoning  that  gas  savings  are  not  significant enough to make a change.  Swiss Stake GmbH - Tricrypto -   10  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Certain Token Combination Cause Numerical Errors   -Severity Findings   Mismatched Bounds    Event Information Missing    Parameter Check Missing    Admin Fees Can Be Claimed Retroactively    Packed Getters Can Be More Restrictive    Slight Code Simplification   0  0  1  6  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.1   Certain Token Combination Cause Numerical", "body": " Errors  If one of the tokens has very few decimals, e.g. Gemini USD which has 2 decimals, and another token either has more than 18 decimals or a fairly low token value, severe numerical errors can arise.  Example:   Token 0: Gemini USD (GUSD), 2 Decimals   Token 1: Another Token (AT), 18 Decimals, 1 AT = 0.005 USD  An exchange of 10,000 GUSD to 2,000,000 AT takes place. Note that the amounts don't matter as the error will occur based on the ratio. The price is computed as:   p = dx * 10**18 / dy   with dx = 10,000 * 10** 2   and dy = 2,000,000 * 10**18   hence, p = 0  In this case the calculated price is zero, which triggers no special checks or fallbacks.  This  situation  PRICE_PRECISION_MUL of 10**8.  is  even  more   likely  due   to   the  packing  of  calculated  prices  and   the  used  Another Example:   Token 0: USDC, 6 Decimals   Token 1: Another Token (AT), 18 Decimals, 1 AT = 1.00 USD  Swiss Stake GmbH - Tricrypto -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrected        \fAn exchange of 10,000 USDC to 10,000 AT takes place. Note that the amounts don't matter as the error will occur based on the ratio. The price is computed as:   p = dx * 10**18 / dy   with dx = 10,000 * 10** 6   and dy = 10,000 * 10**18   hence, p = 10 ** 6  However, during packing this price will be divided by 10**8 and hence become 0.  Overall, the project has a good test suite, but it would benefit from tests containing token contracts with different decimals.    The price calculation was refactored and changed. The token amounts are now scaled to 18 decimals always instead of relative to the other token.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.2   Mismatched Bounds", "body": "  The minimum and maximum values for A in the swap contract and the math contract do not match. In fact, the bounds in the math contract are more restrictive, meaning it's possible to ramp to a new value such that the math contract will revert all calls to newton_y and newton_D, basically locking the system until a valid value for A is set. Additionally, the maximum value for gamma also is mismatched, but the bounds are more restrictive in the swap contract, which does not cause any issues.    The code was corrected to make sure that the bounds of the math contract and the swap contract match.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.3   Event Information Missing", "body": "  The  CurveCryptoSwap  contract  emits  different  events.  When  parameter  ramping  starts,  a RampAgamma  event  is  emitted.  However,  contrary  to  expectations  based  on  the  name,  it  contains  no information about gamma.    The relevant information was added to the RampAgamma event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.4   Parameter Check Missing", "body": "  Swiss Stake GmbH - Tricrypto -   12  DesignLowVersion3CodeCorrectedDesignLowVersion2CodeCorrectedDesignLowVersion2CodeCorrected                        \fSystem parameters can be updated by the administrators of the system. When being updated the new values are checked. The price_threshold and the mid_fee can both be updated, however, the fact that:  assert new_price_threshold > new_mid_fee  will only be checked when the price_threshold is updated and not when mid_fee is updated.    The issue was resolved through refactoring.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.5   Admin Fees Can Be Claimed Retroactively", "body": "  When users see the admin_fee variable of the pool being 0 they will probably assume that no admin fees are being charged at the moment. However, this is not correct. Let's consider the following scenario:  Time Action  0  10  11  12  the pool is started with admin_fee = 0  numerous swap have occurred and xcp_profit has grown  the admin fee is set to 1% using commit_new_parameters and apply_new_parameters  the function claim_admin_fees is called  Users might expect that the admin fees will only be claimed for the time period of 11-12. However, admin fees will be claimed for the time period 0-12. This is because xcp_profit_a hasn't been updated in the meantime.  Code corrected  When changing the admin fee, the admin fees are claimed for the period until the change. Admin fees are only paid for the period beginning at the last time they were claimed. Hence, the issue is resolved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.6   Packed Getters Can Be More Restrictive", "body": "  three   to  access  packed  values:  price_oracle,  price_scale,  and There  are  last_prices. All three functions take an integer as input and retrieve the value at the respective offset. They make sure that the provided integer is:  functions   assert k < N_COINS  However, k == N_COINS - 1 is not a valid input for any of these functions and could also be blocked.  Code corrected  A check to validate k < N_COINS - 1 has been added.  Swiss Stake GmbH - Tricrypto -   13  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f6.7   Slight Code Simplification  Within the claim_admin_fees function there is the following code:  frac: uint256 = vprice * 10**18 / (vprice - fees) - 10**18 total_supply: uint256 = CurveToken(token).totalSupply() claimed: uint256 = CurveToken(token).mint_relative(owner, frac) total_supply += claimed  During mint_relative the totalSupply will be updated. Hence, it could also be queried once after the call to mint_relative instead of querying it before and then updating it later.  Code corrected  The first total supply query was removed and the total supply is queried after the update.  Swiss Stake GmbH - Tricrypto -   14  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  minor  findings  that  should  be  noted  and  considered  for  further development, but don't necessarily require an immediate code change.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "7.1   Possible Price Manipulations", "body": "  We see the following price manipulations as possible:  1. Pushing  price_scale  towards  price_oracle.  In  case  a  user  wants  to  perform  a  larger exchange and the price inside the price_oracle is significantly better for that exchange than the price inside price_scale, then the user can push price_scale towards price_oracle using small  trades.  This  works  as  the  update  for  price_scale  only  depends  on  its  distance  to price_oracle not on previous actions within the same block.  2. The price_oracle is only affected by the last price seen in each block. Hence, big exchanges can be \"hidden\" from the price_oracle if they are followed by other exchanges with a different rate. Note that these trailing exchanges can be way smaller. Such trailing exchanges, if reliably inserted, allow full control over the price_oracle and thereby (as mentioned in the previous comment) also over price_scale.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "7.2   Potential Gas Saving for Balanced Liquidity", "body": " Additions  In  case  last_prices  did  not  change  because  liquidity  was  added  in  the  current  pool  ratios,  the following code part could be skipped.  __xp: uint256[N_COINS] = _xp     dx_price: uint256 = __xp[0] / 10**6     __xp[0] += dx_price     for k in range(N_COINS-1):         self.last_prices[k] = price_scale[k] * dx_price / ...  However, it is unclear whether this is a worthwhile addition as a perfectly balanced liqudity addition will be a rare case unless the UI encourages it to save gas costs.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "7.3   Splitting up Exchanges", "body": "  For users it can be beneficial to split up a larger exchange into multiple smaller exchanges in order to save fees. Depending on the price constellation and the gamma value they can remain in the \"flat\" area of the curve and hence save fees. This is of course detrimental to the liquidity providers. The usefulness of the split depends on the gas costs and the curve parameters.  Swiss Stake GmbH - Tricrypto -   15  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Supported Tokens  There  is  are  variety  of  different  token  implementations  on  the  Ethereum  blockchain.  Using  tokens  with unusual behavior will lead to unexpected changes of the curve or put the smart contracts into a bad state. In particular, the following token types will not work:   rebasing tokens, where balances can change without transfers. These tokens will lead to incorrect  accounting.  tokens with transfer fees. These tokens will lead to incorrect accounting.  tokens with incorrect ERC20 implementations.  tokens with more than 18 decimals  tokens with more than one address  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "7.5   The General Case of n Token Versus A", "body": "  The  audit  was  scoped  for  the  case  n=3  tokens.  Nonetheless,  we  like  to  highlight  our  concerns  for  a bigger  n.  The  contracts  are  written  very  generic  for  the  case  of  n  tokens.  However,  the  n  cannot  be simply increased. As an example, with larger n space for the packed variables becomes smaller. Hence, such cases need to be tested carefully.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "7.6   Variable Naming", "body": "  Naming variables in a clear and understandable way supports the understanding of complex projects like this. Most variables have self explaining names. But some are confusing or used inconsistently like the use  of  x  and  xp.  The  value  (product  of  price  and  amount)  of  a  pool  token  is  usually  denoted  with  xp. However,  the  CurveCryptoMath3  contract  often  does  not  follow  this  naming  convention  consistently and  x  in reduction_coefficient which should be fee_gamma.  is  actually  ANN  *  A_MULTIPLIER  or  gamma   is  used.  Furthermore,  A  which   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "7.7   Vyper Is Still Beta", "body": "  Even though Vyper is used heavily in the latest DeFi projects (especially AMMs), the Vyper language is still  Beta  software  and  should  be  used  with  care  as  bugs  might  arise.  Nevertheless,  Curve  and  other AMMs have used recent Vyper versions successfully.  Swiss Stake GmbH - Tricrypto -   16  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/curve-finance-tricrypto/"}, {"title": "6.1   Offer/Listing Signature Valid for Any Loan", "body": " Contract  The current system requires the Offer or the ListingTerms struct to be signed. However, no information about for which contract address this struct is intended to be used. Thus, it allows the accepting party publishing a loan on-chain to decide whether the loan will be pro-rated or fixed (or other loan types in the future).  Assume the following scenario:  NFTfi - NFTfi Marketplace -   10  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedSecurityHighVersion1CodeCorrected        \f1. Alice talks off-chain to Bob and makes her the offer to lend 100 DAI for her ERC-721 collateral token as a fixed loan where the maximum repayment amount is 200 DAI. Bob sets the loan interest rate to 0 since it is not needed for the loan.  2. Bob sends the signed offer to Alice.  3. Alice  now  calls  acceptOffer  on  the  pro-rated  contract.  Loan  terms  get  prepared  for  later  calculations. _acceptOffer is called internally.  4. Now lender signatures are verified for the offer. Since nothing changed, the call succeeds.  5. Alice can pay back the loan cheaper than Bob agreed to.  In this scenario, Bob would need to have had the pro-rated contract approved for some DAI (e.g. Bob could be an active lender).  Furthermore, the signature could be used on multiple contracts. However, this requires the NFT to be a ERC-1155 token. In such a scenario, Alice could receive a pro-rated and a fixed loan while having only one signature of Bob.  Similar  issues  may  arise  in  the  case  of  signing  listings  where  the  lender  could  for  example  make  a pro-rated  loan  a  fixed  loan.  Since  the  borrower  could  be  an  active  user  of  the  platform,  making  both lending contracts an operator is a plausible assumption. Again, double-loans can be created if the NFT is an  ERC-1155  token  (assuming  the  contracts  are  operators  of  the  user's  NFTs).  Especially,  this  is dangerous, since the documentation describes giving default NFT approvals for NFTfi contracts.  In conclusion, the system is unaware for which contract a signature is intended to be used. Nonces can be reused since they are not stored globally but per lending contract. Hence, replay attacks are possible.    Now,  the  contract  address  is  signed  by  the  party  signing.  Thus,  a  loan  can  be  only  created  on  the intended contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.2   Broken/Partial ERC165 Support", "body": "  Through inheritance the contracts in the composable directory inherit from ERC165 which implements EIP-165 that defines a standard method for publishing and detecting supported interfaces.  function supportsInterface(bytes4 interfaceID) external view returns (bool);  Not all of the aforementioned contracts do overwrite this function to extend its extended functionality.   ERC9981155Extension  additionally   implements   the   IERC998ERC1155TopDown  and   the  IERC1155Receiver interface.   NftfiBundler implements the INftiBundler functions while it does not explicitly implement the interface  (however, the naming suggests otherwise).  ImmutableBundle further implements the IERC721Receiver interface.  Hence, supportsInterface() will not return true for some of the interfaceId it supports.    The supportsInterface return true for interfaceId of all the implemented interfaces.  NFTfi - NFTfi Marketplace -   11  DesignMediumVersion1CodeCorrected         \f6.3   No Sanity Check on Revenue Share  fee.  The  percentage  can  be  set  with Partners  can  earn  a  share  of  PermittedPartners.setPartnerRevenueShare(). However, this method does not check whether the share exceeds 100%.  the  administrator   Assume a loan starts where that is the case. Then, this percentage would be stored in the loan extras of a  loan  which  cannot  be  renegotiated  nor  modified  in  any  way  for  the  loan.  Paying  back  the  loan  will ultimately  revert  since  an  underflow  would  occur  when  computing  the  fee  left  for  the  administrator. Hence, the borrower cannot retrieve his collateral back and liquidation is the only possibility to exit the loan.    100% cannot be exceeded anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.4   Renegotiation Replays Possible", "body": "  Renegotiation is a feature that allows the lender to give the borrower an alternative offer after the loan has been created. However, replay attacks may be possible here.  As  more  loan  types  will  appear,  more  loan  coordinator  contracts  could  be  deployed.  Following  could occur:  1. Borrower A has a loan connected to Coordinator A. Borrower B has a loan connected to Coordinator  B. The lender is in both cases the same.  2. Borrower A and the lender renegotiate the lending terms.  3. Borrower B replays the signature while the signature is not expired yet.  4. The lender has renegotiated two positions instead of only one.  This attack works as long as the data provided to renegotiation functions is the same.    Now, the contract address is signed. Thus, the signature can only be used on the valid contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.5   SmartNFTs May Not Be Composable With", "body": " Other Protocols  When a loan is accepted, two SmartNFT tokens are issued: A promissory note NFT to the lender, and an obligation note NFT to the borrower. The NFT collateral is stored in the NFTfi loan contract until either the borrower  repays  the  loan,  or  the  loan  is  liquidated.  However,  when  either  of  these  events  happen,  the SmartNFT tokens are transparently destroyed, and the addresses owning the respective NFTs receive the collateral and payback. That makes the SmartNFTS untraceable by smart contracts. That could be  NFTfi - NFTfi Marketplace -   12  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                        \fhazardous since the documentation specifies that a possible use-case of these NFTS could be trading them (e.g. selling the loan).  Assume the following scenario:  1. Lender and borrower agree on a loan, create it, and receive the SmartNFTs.  2. As  time  passes,  the  lender  decides  to  sell  the  promissory  note  on  a  platform  as  a  fixed-income  debt-bearing asset. The promissory note is deposited into a smart contract.  3. Now, the borrower pays back the loan. Both SmartNFTs are burned. The collateral is transferred to  the borrower. The payback is transferred to the NFT trade platform.  Ultimately,  the  auction  of  the  promissory  note  cannot  be  ended.  Hence,  funds  could  get  locked  in  the other contract while the lender does not receive anything.  Similarly, if the SmartNFTs are whitelisted in the PermittedList, funds could get lost in the NFTfi system since SmartNFTs could disappear at any time while a loan contract owning them would be clueless. Also, in such a way ImmutableBundles could lose funds.  To conclude, the immediate burning of SmartNFTs could be hazardous for NFTfi and other platforms as they could disappear at any point in time.    Now,  only  whitelisted  contracts  or  EOAs  can  hold  SmartNFTs.  Thus,  governance  must  ensure  that whitelisted contracts hold SmartNFTs that handle the scenarios above correctly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.6   Undeployable SmartNFTs", "body": "  SmartNFTs  are  used  for  the  promissory  note  and  obligation  receipt.  This  contract  inherits  from OpenZeppelin's access control contract. The deployment of the contract may fail.  _setupRole(DEFAULT_ADMIN_ROLE, _admin); grantRole(LOAN_COORDINATOR_ROLE, _loanCoordinator);  It sets _admin as the default administrator for all roles. If _admin is not msg.sender, then grantRole will fail.    _setupRole() is now used instead of grantRole in the constructor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.7   Anyone Can Liquidate", "body": "  The  renegotiation  feature  allows  to  renegotiate  even  if  the  loan  has  expired.  However,  anyone  can liquidate a loan. Thus, it could be possible that the result is not what the users desired. Moreover, fees that could have been earned will not be received.    Now, only the lender can liquidate.  NFTfi - NFTfi Marketplace -   13  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f6.8   Double Getters  For  each  public  variable,  a  getter  is  automatically  generated.  However,  several  contracts  implement additional getter functions for public variables which leads to more code and, hence, higher deployment cost.  Some examples of double getters are:   partnerRevenueShare and getPartnerPermit in PermittedPartners.sol   nftPermits and getNFTPermit in PermittedNFTs.sol   erc20Permits and getERC20Permit in PermittedNFTs.sol  Similar  examples  can  be  also  found  in  other  contracts  such  as  DirectLoanCoordinator,  NftfiHub  and others. Removing double getters may reduce deployment cost.    The double getters have been removed by setting the public variables to private.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.9   Event Issues", "body": "  Many  events  are  emitted  in  the  system  helping  users  and  front-ends.  However,  some  event  could  be indexed to improve the experience. For example:   The permitted list contracts could index the address of the permitted contract.   Registry and loan contracts could have also indexed events  Furthermore, some important state changes do not emit events (e.g. updateMaximumLoanDuration or updateMaximumNumberOfActiveLoans). Note that also the renegotiation lacks events.  Emitting more events and indexing some of their parameters could improve the user-experience.    The events are now indexed and more events are emitted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.10   Gas Inefficiencies", "body": "  Structs are passed to the loan functions as arguments. These structs are passed compactly since they use  for  example  uint32.  However,  some  state  variables  could  follow  this  principle.  For  example, adminFeeInBasisPoints will never be greater than 10000 but is a uint256. The structs store this as a  uint32.  However,  a  smaller  data  type  could  also  be  sufficient.  Similar  gas  optimizations  could  be made.  NFTfi - NFTfi Marketplace -   14  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fFurthermore,  since  the  hub  should  not  change,  it  could  be  made  immutable  in  all  contracts.  For example, DirectLoanCoordinator stores it as an immutable while DirectLoanBase does not. Similar gas savings could be achieved.  Also, some state variable may be redundant. For example, the loan status stored in the loan coordinator. It  is  only  used  for  checking  something  when  burning  the  receipt  NFTs.  However,  burning  requires  the NFT owner to not be zero. Thus, the burn requirements are equivalent to the status checks.  Several  retrieved  values  from  storage  and  from  other  contracts  could  be  cached  in  memory  instead  of reading it multiple times. For example:   The NFT wrapper is retrieved in loanSanityChecks and when setting up the loan terms.   loanIdToLoan[id]  is  read  from  storage  into  memory  in  payBackChecks  and  then  in  payBackLoan.  Further redundant storage reads can be found.  Moreover, DirectLoanFixed._payoffAndFee is computed as follows:  uint256 interestDue = _loanTerms.maximumRepaymentAmount - _loanTerms.loanPrincipalAmount; uint256 adminFee = _computeAdminFee(interestDue, uint256(_loanTerms.loanAdminFeeInBasisPoints)); uint256 payoffAmount = ((_loanTerms.loanPrincipalAmount) + interestDue) - adminFee;  However, the addition could be removed since its result should be the maximum repayment amount.  Overall, gas consumption could be reduced by storing data more compactly, by reducing the number of storage reads and writes, and by removing redundant calculations.    Gas consumption has been reduced.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.11   Gas Inefficiencies in SmartNFTs ", "body": " supportsInterface()  NFTs must implement EIP-165's proposed method supportsInterface(). SmartNFT implement this method. Gas could be saved there by calling only the super method which would, in this case, evaluate all the implementations of the parent classes and cover all implemented interfaces.  Moreover,  deployment  cost  could  be  reduced  by  reducing  the  code  size  by  using  the  methods  and modifiers inherited from AccessControl. Thus, duplicated code could be removed.    The gas consumption of the code has been optimized.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.12   Maximum Number of Loans May Be Violated", "body": "  The  administrator  is  allowed  to  specify  a  maximum  number  of  loans  allowed.  The  following  invariant should always hold:  NFTfi - NFTfi Marketplace -   15  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \ftotalActiveLoans <= maximumNumberOfActiveLoans  However,  that  could  be  violated.  Assume  that  these  are  equal.  Then,  the  administrator  calls updateMaximumNumberOfActiveLoan  to  reduce  the  maximum  number  of  active  loans.  Ultimately, the invariant could be violated.    An additional check was added to ensure that the invariant does not break.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.13   Maximum Repayment Amount", "body": "  The maximum repayment amount is specified by the lender. For both existing loan types this is value is relevant for accepting an offer while unused for accepting listings. The maximum repayment amount is calculated as the sum of the principal loan amount and the interest rate. However, that could be irritating for lenders as they could expect the maximum repayment amount specified by them to be used as the maximum.  Furthermore,  in  the  pro-rated  contract,  renegotiation  could  lead  to  a  scenario  where  the  interest  could grow even after time has elapsed since the interest rate is not modified.    The maximum repayment amount specified by the lender is now always used. Also, the interest rate is now updated for the pro-rated loan.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.14   Not Using safeTransfer for ERC-20", "body": " Transfers  Since  not  all  ERC-20  tokens  adhere  to  the  standard,  it  is  recommended  to  use  safeTransferFrom such  that  interactions  with  a  broader  range  of  tokens  are  possible.  However,  the  transfer  of  the renegotiation fee does not use the safe operation.    safeTransferFrom is now used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.15   Renegotiation on Wrong Contract Possible", "body": "  Renegotiation is a feature that allows the lender to give the borrower an alternative offer after the loan has been created. However, it could be possible to renegotiate a loan on the wrong contract.  NFTfi - NFTfi Marketplace -   16  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThis becomes possible if the maximum loan duration is greater than the current block timestamp and no renegotiation fee is charged.  1. Lender and borrower agree on a direct fixed loan.  2. Lender signs the renegotiation with a high new loan duration for the pro-rated contract.  3. The borrower calls renegotiate on the pro-rated loan contract.  4. The correct SmartNFT ID is fetched from the shared coordinator while the loan data is empty as it is  stored per lending contract.  5. Thus,  if  the  maximum  loan  duration  and  the  new  loan  duration  are  sufficiently  high  and  the  renegotiation fee is 0 (no ERC-20 transfer occurs), all checks pass.  However,  as  the  NFT  wrappers  are  not  initialized,  this  leads  to  unnecessary  state  modifications  while funds cannot be transferred.    Now, the loan contract is compared to the stored contract in the loan coordinator disallowing such wrong renegotiations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.16   Repetitive Validation on Batch Child Transfer", "body": "  safeBatchTransferChild()  allows  children  of  a  token  to  be  batch  transferred.  msg.sender  is validated in each loop iteration to be the root owner of tokenId. However, since only the children of one token id can be batch transferred at once, it is sufficient to validate only once. Ultimately, storage reads and, hence, gas consumption could be reduced.    The method has been optimized.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "6.17   Specification Mismatch", "body": "  The code has several occurrences of specification mismatch. Some examples are:   DirectLoanProRated._setupLoanTermsListing documents that it is a fixed loan.   ERC998TopDown.childExists  specifies  that  it  returns  true  if  a  child  exists.  However,  in  the  extended classes this will return false for ERC-1155 tokens.   ERC998TopDown.ownerOfChild  specifies  that  parameter  tokenId  while  it  has  only  parameter  childTokenId.  Specification changed:  The specification has been updated.  NFTfi - NFTfi Marketplace -   17  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "7.1   Fee Avoidance", "body": "  The liquidation allows the administration fees to be avoided as follows:  1. The borrower transfers his receipt to a contract. As long as the lender has transferred his receipt to  the contract, the borrower can withdraw his receipt.  2. The lender signs a renegotiation and approves the cheating contract.  3. The  lender  calls  the  cheating  contract  method  that  takes  the  renegotiation  and  the  renegotiation  parameters as arguments (and checks whether the parameters are fair).  4. The contract, having the obligatory note, calls renegotiate.  5. The contract pulls the promissory note from the lender.  6. The loan gets liquidated and the contract holds the NFT collateral.  7. The  cheating  contract  implements  a  payback  function  that  is  cheaper  for  the  borrower  and  more profitable  for  the  lender  (splitting  the  admin  fee).  Moreover,  as  a  safeguard  for  the  lender  it implements a liquidation function.  Ultimately, no fees are distributed to the administration while the lender and borrower could profit.  This  behaviour  cannot  occur  anymore.  Since  only  EOA  addresses  could  hold  a  SmartNFT  in  such  a case, the lender would need to trust the borrower.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "7.2   Front-running Offers", "body": "  Alice may receive an Offer of Bob for an ERC-1155 token. Charlie could call acceptOffer() with Bob's signature which would initiate a loan between Bob and Charlie for the same ERC-1155 token. However, Bob's  intend  could  have  been  to  only  allow  Alice  to  take  a  loan  from  him.  From  the  discussions  with NFTfi,  it  was  clarified  that  the  ERC-1155  tokens  to  be  supported  are  the  ones  that  have  at  most  one token per ID.  Hence, governance needs to be careful when whitelisting ERC-1155 contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "7.3   Outdated Compiler Version", "body": "  The solc version is fixed in the hardhat configuration to version 0.8.4. At the time of writing the most recent Solidity release is version 0.8.7.  NFTfi - NFTfi Marketplace -   18  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Possible Inconsistencies After Registry Changes  Many values are stored such that the loan can be resolved, no matter the changes made to the system (e.g. whitelisting ERC-20 tokens). However, the loan registry is global for the whole system. That could introduce several issues:   Assume contract A is stored in the loan registry for loans of type B and Loans are still active. Now, administration  changes  the  contract  for  loan  type  of  B  to  contract  C.  That  could  lock  the  funds  in contract A and make the loans unresolvable or introduce other issues related to that.   The loan coordinator could change in the hub. Thus, loans could become all invalid since changing  the new loan coordinator could also change the smart NFT token contract address.   Loans could become unresolvable if the loan coordinator loses access to a Smart NFT contract.  These and similar issues could occur.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "7.5   Supported Tokens", "body": "  The  protocol  supports  ERC-20  tokens  as  lending  capital.  However,  whitelisting  for  example  ERC-777 tokens (backward-compatible with EIP-20) may lead to unwanted behaviour. For example, paybacks of loan could be blocked by reverting on token reception.  Also,  borrowers  may  receive  less  than  expected  if  the  ERC-20  tokens  collect  transfer  fees  while  the paybacks could fail.  Furthermore,  some  NFTs  could  be  added  that  could  be  burnable  externally  or  have  other  unexpected non-standard behaviour.  In general, governance has to be careful with whitelisting tokens.  NFTfi - NFTfi Marketplace -   19  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/nftfi/"}, {"title": "5.1   Mismatches With Documentation and Lack", "body": " Thereof  Documentation  plays  a  crucial  part  for  understanding  a  codebase  and  integrating  it  into  a  live  system. However,  the  code  lacks  project  specific  documentation  and  is  only  described  in  a  generic  way  in  the MakerDAO Oracle documentation.  Moreover, the interfaces of the CurveLPOracle mismatch the interface specified:   The  documentation  specifies  step()  to  take  a  uint16  as  an  input  parameter  while  the  code defines  step(uint256)  which  checks  that  a  provided  argument  does  not  exceed  the  maximum uint16.   Documented  function  change()  is  missing.  However,  link()  is  undocumented  but  implements  the specified functionality of change().   According to documentation, stop() should only set the stopped flag while void() should set the flag but also reset nxt, cur and zph. In contrast, void() is missing while stop() implements the semantics of void().  Similarly StETHPrice deviates from the MakerDAO medianizer documentation.  Acknowledged:  MakerDAO acknowledges this.  MakerDAO - Curve LP & stETH oracle -   10  DesignCorrectnessCriticalHighMediumLowAcknowledgedCorrectnessLowVersion1Acknowledged            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Curve Registry    Outdated Compiler Version    Potential Inconsistency   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-curve-lp-steth-oracle/"}, {"title": "6.1   Curve Registry", "body": "  0  0  0  3  According to the Curve Documentation of their registry contracts, the central source of truth in the Curve system  is  the  address  provider.  That  contract  allows  changing  the  registry  through  set_address() when the id parameter is set to zero. Currently, the oracle stores the registry as an immutable. Hence, in case the registry changes, the oracle will utilize a wrong registry.    The registry is now queried from the address provider.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-curve-lp-steth-oracle/"}, {"title": "6.2   Outdated Compiler Version", "body": "  The  solc  version  is  fixed  to  version  0.8.9.  The  introduced  changes  in  versions  0.8.10  and  0.8.11 could reduce gas consumption of the inline-assembly code of poke().    Compiler version 0.8.11 was chosen.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-curve-lp-steth-oracle/"}, {"title": "6.3   Potential Inconsistency", "body": "  step() sets a new value to hop which specifies the minimum time between calls to poke(). Function zzz() should return the time of the last poke().  MakerDAO - Curve LP & stETH oracle -   11  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fConsider now the following scenario where hop is 1 hour and the zph is set to the current time + 1 hour. Assume that a call to step() sets hop to 10 minutes. Now, zzz() returns current time + 50 minutes which is in the future. Moreover, the next poke requires waiting for one hour instead of only 10 minutes.  Ultimately, that could lead to temporary inconsistencies.    zph (Time of last price update plus hop, the minimum time between price updates) is now updated on step() using the new value of hop. The update of zph is skipped when it hasn't been set yet but hop is updated.  MakerDAO - Curve LP & stETH oracle -   12  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-curve-lp-steth-oracle/"}, {"title": "6.1   Double Counting During Maple Migration", "body": "  During the migration of Maple positions, double counting of Maple LP tokens is possible as there are no restrictions enforced on lend().  Consider the following scenario:  1. The position holds 10 v1 LP tokens.  2. The snapshot is taken and snapshots are frozen.  3. The  airdrop  of  v2  LP  tokens  happens  and  the  position  receives  10  v2  LP  tokens.  Note  that getManagedAssets() does not consider v2 LP tokens since the v2 pool is not tracked. Hence, the valuation is 10 v1 LP tokens.  4. The  manager   tokens.  Now, getManagedAssets() considers both v1 and v2 LP tokens since lending will start tracking the v2 pool. Hence, the valuation is 10 v1 LP tokens and 20 v2 LP tokens.  to  Maple  v2  and  creates  10  v2  LP   tokens   lends   Thus, funds could be overvalued between airdop and migration execution.    Lending is now only allowed if the position has been migrated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "6.2   Incorrect Comment", "body": "  On  AddOnlyAddressListOwnerConsumerMixin there is the following comment:  __validateAndAddListItemIfUnregistered   the   function   of  Avantgarde Finance - Sulu Extensions VIII -   13  CriticalHighCodeCorrectedMediumLowSpeci\ufb01cationChangedCodeCorrectedCorrectnessHighVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                 \f/// @dev Helper to lookup an item's existence and then attempt to add it. /// AddOnlyAddressListOwnerBase.addToList() performs validation on the item.  The  addToList  function  does  not  actually  perform  the  validation.  The  __validateItems  function does.  Specification changed:  The comment now specifies that the function addValidatedItemsToList() is used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "6.3   Unused Import", "body": "  MapleV1ToV2PoolMapper  which is unused.  imports  \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"    The import has been removed.  Avantgarde Finance - Sulu Extensions VIII -   14  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.1   Lido Rebasing", "body": "  Lido  has  epochs  for  rebasing.  It  could  be  possible  to  sandwich  oracle  updates  with  buying  and  selling shares.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.2   Maple V2 Migrations Can Start Before", "body": " Snapshots  allowMigration() is a governance function that should be called after all snapshots. Note that there is no sanity check that all snapshots have been made. Governance should not call this function too early.  Further,  note  that  the  function  should  only  be  called  after  snapshots  have  been  disallowed  with freezeSnapshots().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.3   Pool Address", "body": "  Note  that  for  the  Aave  v2  and  Aave  v3  adapters,  the  lending  pool's  address  is  stored  and  not  queried from Aave's registry. Managers should be aware that the (lending) pool address used could be outdated.  Avantgarde  Finance  plans  to  upgrade  the  library  contract  in  the  case  that  the  lending  pool  address changes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.4   Potential Maple V2 Rollback", "body": "  Note  that  Maple  V2  could  rollback  their  migration  process.  Avantgarde  Finance  should  be  aware  and quick to react.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.5   Redeemable Amount", "body": "  The action RedeemV2 tries to redeem the input amount poolTokenAmount. However, note that Maple's WithdrawalManager contains the following code  Avantgarde Finance - Sulu Extensions VIII -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \frequire(requestedShares_ == lockedShares_, \"WM:PE:INVALID_SHARES\");  Hence, managers should be aware that RedeemV2 will only succeed if poolTokenAmount is equal to its locked shares.  Avantgarde Finance prefers this in case future implementations of Maple change this logic.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.6   Reverts on Batching Maple Migration", "body": "  The Maple mapper contract implements a batched function for migrating to v2. If a position has already been migrated, the batched function may revert.  Avantgarde Finance replied:  Pretty unlikely to occur and nicer to be able to easily preview a tx failure by not skipping reverting items.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "7.7   Theoretical Out-Of-Gas During Maple V2", "body": " Migrations  snapshotPoolTokenV1BalanceValues()  and  migratePoolsV1ToV2()  load  all  used  pools  from storage.  Theoretically,  these  functions  could  result  in  an  out-of-gas  problem  that  cannot  be  resolved without a contract upgrade.  In contrast, if too many pools are added for getManagedAssets(), this can be resolved by a manager.  Avantgarde Finance - Sulu Extensions VIII -   16  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-viii/"}, {"title": "6.1   Pausing Auto-Compounding Can Be Unfair to", "body": " Users  CS-EVERSTKB2C-001  The  flag  PAUSE_REWARDS_POSITION  introduced  in  the  Accounting  allows  for  pausing  rewards auto-compounding. This led to the following:  1. During the period rewards auto-compounding is disabled, all users joining the protocol and having their stake activated will collect the same amount of rewards independently of the time their stake became active.  2. Provided that enough interchanging is available, a user who wants to begin staking can monitor the mempool  and  frontrun  the  Everstake's  transaction  that  reenables  reward  auto-compounding  to keep its ETH liquid for the largest amount of time possible while maximizing its rewards.  Acknowledged:  Everstake  is  aware  of  this  issue  and  responded  that,  depending  on  their  SOP  for  each  edge  case, staking may be manually paused along with the pausing of the rewards.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "6.2   Interchanging Is Not Performed in Order When", "body": " Withdrawing  Everstake - ETH B2C Staking -   13  CS-EVERSTKB2C-004  DesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedDesignLowVersion3AcknowledgedDesignLowVersion1Acknowledged                   \fBecause  of  the  implementation  of  AddressSet,  when  interchanging  with  pending  deposits  during  a withdrawal,  the  interchanges  are  not  done  in  the  order  the  stakers  deposited.  This  means  that  some users might have to wait for their deposit to become active longer than another user who deposited after them, hence missing the rewards that were distributed during this time.  This issue can be taken advantage of by a user who wants to stake x ETH but does not wish to wait for their deposit to become active. By looking at the mempool, the user can spot transactions withdrawing from the contract. If he finds a withdrawal greater than or equal to x + y where y is the amount that could  be  the transaction  with  his  call  to  Pool.stake  will  guarantee  him  to  be  interchanged  with  the  withdrawal, overtaking all the users in _slotPendingStakers()[activeRound].  interchanged  with  _slotPendingStakers()[activeRound][0],   frontrunning   Acknowledged:  Everstake  responded  that  this  behavior  is  known  and  kept  as  it  is  to  save  gas  since  using  the  proper order would be costly given OpenZeppelin's AddressSet implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "6.3   Minimum Stake Consistency", "body": "  The  Pool  forces  stakers  to  stake  at  least  MIN_STAKE_AMOUNT  per  deposit,  but  it  is  possible  to circumvent this by calling stake() and then either unstakePending() or unstake() to have a final deposited amount smaller than MIN_STAKE_AMOUNT.  CS-EVERSTKB2C-005  Acknowledged:  Everstake  acknowledged  this  behavior  and  explained  that  this  check  is  more  about  excluding  cases when the fees of the transaction would be relatively large compared to the actual deposited amount.  Everstake - ETH B2C Staking -   14  DesignLowVersion1Acknowledged          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  2  6  22  -Severity Findings  -Severity Findings   Replacing a Validator Eventually Blocks the System    Usage of address(this).balance in restake Can Block the System   -Severity Findings   renounceOwnerShip Leaves the _pendingOwner Pending    Missing Input Sanitization    Pausing Withdrawing Is Ineffective    Slashing Is Not Taken Into Account    _simulateAutocompound's Computation of pendingRestaked Is Incorrect    _simulateAutocompound's Computation of totalShare Is Incorrect   -Severity Findings   Wrong Address in Event upon acceptOwnership    RewardsTreasury Overrides SendETH With Identical Implementation    ValidatorList.get Might Not Represent the Reality    _simulateAutocompound Ignores Paused Rewards    Batch Deposit in First Round Skips Shortcut    Events Missing   Inconsistent Event Emission Order   Interchanged Part of a Deposit Is Not Added to depositBalance   Interfaces Not Implemented    Missing Documentation    Missing Indexing of Events    Status of Replaced Validators Is Not Reset    Unnecessary Function Parameter    Variables and Functions Names Are Not Representative    View Functions Are Incorrect for Round 0    Withdrawing May Fail Due to Underflow    Wrong Restake Condition   InterchangeDeposit Emitted When No Interchange    activatedRound Cached Value Not Updated    activeRound==0 Shortcut Breaks Semantics   Everstake - ETH B2C Staking -   15  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected    \f onlyGovernor Not Used    unstakePending Does Not Update _slotPendingStakers   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.1   Replacing a Validator Eventually Blocks the", "body": " System  The function ValidatorList.replace does not set the status of the new validator to Pending. This will make ValidatorList.shift() revert when the next pending validator will be the new validator as its status will be Unknown. If this happens, staking and withdrawing will be blocked. The funds can only be unlocked if the validators are closed and the rewarder on the RewardsTreasury can be changed.  CS-EVERSTKB2C-034    The function has been updated and the new validator' status is now set to Pending.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.2   Usage of address(this).balance in", "body": " restake Can Block the System  CS-EVERSTKB2C-025  The function restake defined in the pool contract is called when auto-compounding is performed and tries  to  deposit  to  the  beacon  deposit  contract  with  fresh  validators  as  much  as  possible  given  the balance of the contract.  As this function relies on the balance of the contract and not the balance computed by the accounting the following is possible:  If  ETH  is  forced  into  the  pool  contract  (using  selfdestruct  for  example),  one  can  increase  the balance  of  the  contract  such  that  any  subsequent  function  call  triggers  a  deposit  to  the  beacon deposit  contract  via  _autocompound  when  it  would  not  without  the  extra  ETH.  As  accounting's pending amount will now be much greater than the actual balance of the pool, any call to deposit or withdraw will eventually revert as it will try to send to the beacon deposit contract ETH that is no longer in the pool.   When a user stakes, _autocompound() is called by deposit() before the deposit is accounted for in _deposit() and after the deposit of the user has been added to the contract's balance. If the balance  of  the  contract,  upon  transferring  the  rewards  from  the  treasury  to  the  pool  contract,  is greater  than  32  ETH,  restake  will  deposit  to  the  beacon  deposit  contract.  As  part  of  the  user's deposit will be gone, the accounting performed by _deposit() will not match the actual balance of the contract and the call will revert as _stake cannot send BEACON_AMOUNT to the beacon deposit contract.    A parameter activatedSlots to indicate how many validators must be deposited to has been added in the restake functions, and the Pool does not rely on its internal balance anymore.  Everstake - ETH B2C Staking -   16  CodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrectedDesignHighVersion1CodeCorrected                 \f7.3   renounceOwnerShip Leaves the _pendingOwner Pending  CS-EVERSTKB2C-033  functions   The  and OwnableWithSuperAdmin.renounceOwnership  delete  the  _owner,  but  not  the  _pendingOwner. When renouncing ownership, there may be still a pending owner. The goal of renouncing ownership is to leave the contract without an owner forever, but if the current owner does initiate ownership transfer and then renounces, the pending owner can still claim ownership of the contract.  TreasuryBase.renounceOwnership     The two functions have been updated to delete the _owner and the _pendingOwner.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.4   Missing Input Sanitization", "body": "  CS-EVERSTKB2C-031  Some function inputs are not sanitized:  1. Pool.initialize(): the parameters rewardsTreasury and poolGovernor are not checked  for address(0).  2. Accounting.initialize():   the  parameter  accountingGovernor   is  not  checked   for  address(0), and poolFee is not checked to be smaller than FEE_DENOMINATOR.  3. TreasuryBase.setRewarder(): rewarder is not checked for address(0).  4. TreasuryBase.setOwner(): owner is not checked for address(0).  5. Pool.setGovernor(): newGovernor is not checked for address(0).    1. Zero address checks are done.  2. Zero address and fee sanitization checks are done.  3. Zero address check is done.  4. the function has been removed and replaced by a transfer-and-accept pattern.  5. Zero address check is done.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.5   Pausing Withdrawing Is Ineffective", "body": "  The function pauseWithdraw can be called by a privileged role to (un)pause the withdrawals. While the function unstakePending has the modifier whenWithdrawActive to ensure that it can only be called  CS-EVERSTKB2C-039  Everstake - ETH B2C Staking -   17  DesignMediumVersion3CodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                        \fonly when withdrawals are allowed, unstake() is not and can be called independently of the pausing of withdrawals.    The function Pool.unstake has been updated with the whenWithdrawActive modifier.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.6   Slashing Is Not Taken Into Account", "body": "  CS-EVERSTKB2C-003  The protocol assumes that slashing will never happen for any of its validators. While the risk of slashing can be greatly reduced by good infrastructure maintenance and monitoring, it can never be zero, in this case, the slashing of a validator could result in putting the protocol in unexpected states and a potential loss  of  funds  for  users.  All  implementations  of  nodes  can  potentially  have  bugs  that  might  lead  to undesired slashing.  For example, any transfer of less than 32 ETH from the validator is considered as an incoming reward, while  if  slashed  this  can  be  an  entire  stake  of  the  validator.  Thus,  if  slashed  just  before  unstaking,  the wrong accounting can lead to unexpected results.    Everstake  added  the  feature  to  stop  the  update  of  rewards  in  case  of  emergency.  When  it  comes  to updating  the  user's  balance  and  refunding  the  users,  see  Trust  Model  and  Users  may  not  be  fully refunded in case of slashing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.7   _simulateAutocompound's Computation of", "body": " pendingRestaked Is Incorrect  When  simulating  the  activation  of  rounds  in  _simulateAutocompound(),  for  each  round  being activated,  pendingRestaked  is  decremented  by  BEACON_AMOUNT.  As  it  might  be  the  case  that pendingAmount/BEACON_AMOUNT  >  pendingRestaked/BEACON_AMOUNT,  a  call  to  the  function could revert after trying to underflow the variable pendingRestaked.  CS-EVERSTKB2C-017    _simulateAutocompound  that pendingAmount/BEACON_AMOUNT > pendingRestaked/BEACON_AMOUNT and correctly decrement pendingRestaked.  assumption   makes   longer   the   no   Everstake - ETH B2C Staking -   18  DesignMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                  \f7.8   _simulateAutocompound's Computation of totalShare Is Incorrect  CS-EVERSTKB2C-018  is   by   called   _deposit   When  deposited (AUTO_COMPOUND_TOTAL_SHARE_POSITION) is incremented with the rewards (both the part that has been  side, __simulateAutocompound()  increments  totalShare  by  unclaimedReward  which,  at  this  point, only  includes  the  part  of  the  rewards  that  is  not  interchanged.  The  totalShare  returned  by _simulateAutocompound() will hence not always match the result of an autocompounding.  _autocompound(),   deposited).  On   interchanged   that  will   amount   other   total   part   and   the   the   the   be     _simulateAutocompound  now  matches  _autocompound()  behavior  and  takes  into  account  the interchanged amounts when computing the total pool's balance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.9   Wrong Address in Event upon ", "body": " acceptOwnership  CS-EVERSTKB2C-043  The  and OwnableWithSuperAdmin._transferOwnership  emit  the  event  the  addresses  of  _owner  and newOwner, which are the same at that point.  TreasuryBase._transferOwnership   functions     The two functions have been updated to emit the event with the previous owner and the new owner.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.10   RewardsTreasury Overrides SendETH With", "body": " Identical Implementation  RewardsTreasury overrides SendETH with the same implementation as TreasuryBase.  CS-EVERSTKB2C-035    Everstake  RewardsTreasury not to have to override sendETH.  inheritance  between   revised   the   the  contracts  and   their   interface   to  allow   for  Everstake - ETH B2C Staking -   19  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion3CodeCorrectedDesignLowVersion3CodeCorrected                        \f7.11   ValidatorList.get Might Not Represent the Reality  Given  a  set  of  Validators  with  the  status  Deposited,  they  may  be  not  closed  in  the  same  order  they appear in _validatorsPubKeys. In such case, calling markAsExited will mark the n first Deposited validator of the list as excited, without caring about which exact validator was closed. This may lead the function  ValidatorList.get  to  return  a  status  that  is  not  representative  of  reality  in  the  case Everstake  did  not  close  validators  in  the  order  they  appear  in  _validatorsPubKeys  (e.g.  in  case  of slashing or leaked private key).  CS-EVERSTKB2C-002    Everstake added the function markValidatorAsExited and a corresponding internal function to the Pool  and  to  ValidatorList  to  allow  for  marking  as  closed  validators  given  its  index  in _validatorsPubKeys.  Provided  right  method  between markValidatorsAsExited  and  markValidatorAsExited  to  close  the  validators  that  have effectively been closed, ValidatorList.get should return the correct status.  that  Everstake  always  uses   the   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.12   _simulateAutocompound Ignores Paused", "body": " Rewards  Accounting._simulateAutocompound does not take the pausing of rewards into account, and thus does not mirror what autocompound would do when the rewards are paused.  CS-EVERSTKB2C-036    function  _simulateAutocompound  has  been  updated   The  _autocompound() when the rewards are paused.  to   reflect   the  behavior  of  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.13   Batch Deposit in First Round Skips Shortcut", "body": "  CS-EVERSTKB2C-022  the   first   round   If  in Accounting._activateRound()  will  be  skipped  as  activeRound  >  0.  In  this  case,  round  0  will have to be activated as any other round by calling activateValidators.  is  closed  within  a  batch  deposit,   (activeRound==0)   the  shortcut     The special handling of the case activeRound==0 has been removed from _activateRound().  Everstake - ETH B2C Staking -   20  DesignLowVersion3CodeCorrectedCorrectnessLowVersion3CodeCorrectedDesignLowVersion1CodeCorrected                        \f7.14   Events Missing  CS-EVERSTKB2C-029  Even  though  many  events  are  emitted  by  the  protocol,  several  important  state  changes  do  not  emit events:  1. OwnableWithSuperAdmin.__OwnableWithSuperAdmin_init_unchained()  does  not  emit  SetSuperAdmin after setting the super admin.  2. Accounting.withdraw()  does  not  emit  InterchangeDeposit  when  interchanging  with  the  pending restaked amount.  3. No  event  is  emitted  by  Accounting.activateValidators()  when  one  or  several  validators  are activated.  4. No  event   is  emitted  when   the  minimum  amount   to   restake   is   set  using  Accounting.setMinRestakeAmount().  5. In Accounting, deposit(), withdrawPending() and withdraw() could emit events as they are  not  necessarily  respectively  called  by  Pool.stake(),  Pool.unstakePending()  and Pool.unstake().  6. Pool.unstake()  emits  no  event  when  no  amount  is  withdrawn  from  the  pending  value  of  the  pool.  7. Pool.restake(),   Pool.setPendingValidators(), Pool.replacePendingValidator(),  Pool.markValidatorsAsExited()  emit  no  event while they perform important state changes.  8. GovernorChanged   in  Pool.initialize()  and Accounting.initialize(), similarly, FeeUpdated is not emitted when setting the pool fee in initialize().  is  emitted  when  setting   the  governor   :  9. OwnableWithSuperAdmin.renounceOwnership  TreasuryBase.renounceOwnership does not.  emits   an   event   but  10. markValidatorsAsExited is defined and emitted in the library ValidatorList, meaning that  it won't be part of the Pool's ABI as it is not redefined there.    The points 1., 2., 3., 4., 6., 7. (all but setPendingValidators), 8., 9., 10. have been fixed.  For 7., Everstake states:  Pool.setPendingValidators()  -  not  important  state  changes.  It's  internal  processing  which  can  be indexed without events.  For point 5.:  Everstake answered that the concerned functions of the accounting can be called either by the pool or by the owner. In the former case, the pool emits relevant events. For the latter case, Everstake states that the owner should call these functions only in an emergency and thus, Everstake claims that no events are needed in those cases as observers would anyway know that this is the owner's actions.  Everstake - ETH B2C Staking -   21  DesignLowVersion1CodeCorrectedVersion3        \f7.15   Inconsistent Event Emission Order  1. While most of the functions emit events after calling functions that might themselves emit an event, Pool._deposit emits StakeDeposited before calling deposit which will itself emit events.  2. Additionally,  in  the  codebase,  the  rule  seems  to  be  doing  storage  change  first  and  then  emitting  events, however, some functions do not follow this pattern:  CS-EVERSTKB2C-024   OwnableWithSuperAdmin.transferOwnership   Governor._updateGovernor    1. The event has been moved after the call to deposit.  2. The events have been moved after the state changes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.16   Interchanged Part of a Deposit Is Not Added", "body": " to depositBalance  When  staking,  the  part  of  the  deposit  that  is  interchanged  with  withdrawals  is  not  added  to sourceStaker.depositBalance.  CS-EVERSTKB2C-026    The  function  AutocompoundAccounting._depositAutocompound  has  been  updated  to  add  the interchanged amount to the sourceStaker.depositBalance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.17   Interfaces Not Implemented", "body": "  Some  of  the  contracts  do  not  implement  their  interfaces  (FooBar  is  IFooBar).  This  would  be  a guarantee for integrators that the contracts carry the same functions signatures as the interfaces. Such contracts are listed below:  CS-EVERSTKB2C-027   TreasuryBase   RewardsTreasury    The  contracts  TreasuryBase  and  RewardsTreasury  have  been  updated  to  implement  their respective interfaces.  Everstake - ETH B2C Staking -   22  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7.18   Missing Documentation  Most of the functions are poorly documented or have no NatSpec description at all.  CS-EVERSTKB2C-028    Extensive documentation has been added for external and public functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.19   Missing Indexing of Events", "body": "  All  events  defined  in  Accounting,  Governor,  Pool,  RewardTreasury,  TreasuryBase  and Withdrawer  contain  no  indexed  fields.  Indexing  some  relevant  fields  will  help  for  searching  events quicker.  CS-EVERSTKB2C-030    The relevant fields have been indexed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.20   Status of Replaced Validators Is Not Reset", "body": "  In the function ValidatorList.replace, the status of the replaced validator is not assigned (=), but compared (==) to ValidatorStatus.Unknown. This line of code will have no effect, and it will not be possible to add again the replaced validator at a later stage.  CS-EVERSTKB2C-037    The status of the replaced validator is correctly reset to Unknown.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.21   Unnecessary Function Parameter", "body": "  The function AutocompoundAccounting._activatePendingBalance(), is always called with the parameter  minPresentedAmount  set  to  true,  thus  the  parameter  and  logic  related  to  it  should  be removed from the codebase.  CS-EVERSTKB2C-038  Everstake - ETH B2C Staking -   23  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                \f  The unnecessary function parameter minPresentedAmount and its related logic have been removed from the codebase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.22   Variables and Functions Names Are Not", "body": " Representative  Having  self-explanatory  names  for  variables  and  functions  greatly  help  the  understanding  of  the  code. The  names  of  some  of  the  variables  and  functions  in  the  codebase  are  misleading.  Here  is  a non-exhaustive list:   all  the  functions  named  with  autocompound,  except  autocompound()  and  _autocompound()  have nothing to do with autocompounding.  CS-EVERSTKB2C-040   AUTO_COMPOUND_TOTAL_SHARE_POSITION  represents   total  amount  of  ETH  currently deposited in the validators, not a share. Moreover, the amount is not only from auto-compounded rewards.  the    ShareState.totalShare represent the total deposited amount at some period, not a share.   ShareState.shareIndex represent the total minted shares at some period, not an index.   STAKER_AUTOCOMPOUND_BALANCES_POSITION  and  the  struct  AutocompoundStakerMining  have nothing to do with autocompounding.    The functions and variables names have been changed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.23   View Functions Are Incorrect for Round 0", "body": "  The special case for activeRound==0 in _activateRound() sets activatedRound to 1 although the validator is not necessarily active yet.  This  means  that  the  following  functions  might  return  incorrect  results  relative  to  the  semantics  of pendingDeposited and active:  CS-EVERSTKB2C-041   pendingDepositedBalance()   pendingDepositedBalanceOf()   depositedBalanceOf()   autocompoundBalanceOf()    The special handling of the case activeRound==0 has been removed from _activateRound().  Everstake - ETH B2C Staking -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f7.24   Withdrawing May Fail Due to Underflow  CS-EVERSTKB2C-042  When computing _shareToAmount(totalShare,  autoCompoundShareIndex, autoCompound TotalShare) - originActiveDepositedBalance in _withdrawFromAutocompound, amounts deposited by the user are compared with amounts obtained from shares using _shareToAmount(), as there might have been a rounding error in the computation of the latter, their comparison might result in an underflow, leading the call to revert.  An easy way to obtain this behavior is to have the user deposit a very low amount of ETH x (10 wei for example) by calling stake() with some large value before calling unstakePending() to leave in the pending deposit of the user x ETH. Supposing now that the price of a share is high at the moment of the activation  of  the  validator,  it  is  possible  that  _shareToAmount(_amountToShare(x))  <  x  as _amountToShare() might have done some rounding.    When only a portion of the user's shares are burned, the accounting subtracts the deposited balance to whatever is larger between the deposited balance and the amount obtained from the shares to be burned to avoid underflow.  When all the shares are burned, no such comparison is done and the deposited amount is updated to be the user's pending amount.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.25   Wrong Restake Condition", "body": "  CS-EVERSTKB2C-044  for   the  Pool   to  deposit  on  a  restake   The  condition  If balance == BEACON_AMOUNT the active round would have been incremented and the pending amount updated  accordingly  during  _autocompound()  because  the  system  expects  a  new  validator  to  be provisioned. But in that case, the validator will not be provisioned because of the strict inequality above. Moreover, the internal accounting of the pending amount will not be representative of the true pending value until the next deposit or reward auto-compounding.  is  balance  >  BEACON_AMOUNT.     The restake condition has been modified and relies on activatedSlots instead of balance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.26   InterchangeDeposit Emitted When No", "body": " Interchange  In the function withdraw, InterchangeDeposit is emitted even if no interchange happened for the given pending staker (activatedAmount==0).  CS-EVERSTKB2C-023  Everstake - ETH B2C Staking -   25  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f  The  withdraw  function  has  been  updated  so  the  InterchangeDeposit  event  is  emitted  only  when some amount is interchanged.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.27   activatedRound Cached Value Not Updated", "body": "  CS-EVERSTKB2C-020  At  the  beginning  of  the  function  Accounting._depositBalance,  activatedRound  is  cached  in memory  and  later  used  when  calling  _depositAccount().  If  activeRound==0  and  enough  ETH  is deposited  so  that  _activateRound()  is  called,  activatedRound  is  set  to  1  in  the  storage  but  its cached value is not updated. Because of this, if _depositBalance was to call _depositAccount() after  _activateRound's  call  (the  user  deposited  enough  to  activate  two  or  more  rounds), _autocompoundAccount()  would  in the  pendingDepositedBalances although the deposit should be active at this time and shares should be minted.  round  0   deposit   cache   user's   the   for     The special handling of the case activeRound==0 has been removed from _activateRound().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.28   activeRound==0 Shortcut Breaks", "body": " Semantics  The implemented shortcut in _activateRound(), the shortcut that marks the round 0 activated breaks the semantics of the activatedRound, which should only represent the number of validators that have been effectively activated.  CS-EVERSTKB2C-021    The special handling of the case activeRound==0 has been removed from _activateRound().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.29   onlyGovernor Not Used", "body": "  The modifier onlyGovernor defined in the Governor is never used in the code base and thus should be removed.  Moreover, as the check ensuring that the msg.sender is the governor is performed after the function's call the modifier is applied to, if the modifier was to be used on a function updating the governor, it could be  that  the  function  is  not  protected  and  could  be  called  by  anyone  providing  themselves  as  the  new governor.  CS-EVERSTKB2C-032  Everstake - ETH B2C Staking -   26  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  The modifier onlyGovernor has been removed from the Governor contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.30   unstakePending Does Not Update", "body": " _slotPendingStakers  When  his  _slotPendingStakers[activeRound] is not updated to remove the staker.  withdraws   pending   stake   user   full   using   a   CS-EVERSTKB2C-019  unstakePending,    The Accounting.withdrawPending function has been updated such that the staker is removed from _slotPendingStakers[activeRound] if they remove all of their pending stakes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.31   Deleting a struct With a Mapping Has No", "body": " Effect  CS-EVERSTKB2C-008  In Solidity, if a struct contains a mapping and one deletes the struct, the mapping will not be deleted. In  deletes _slotPendingStakers()[activeRound],  an  AddressSet,  but  only  the  _values  field  of  the  Set will be defaulted.  Accounting._activateRound()   codebase,   the     The deletion of _slotPendingStakers()[activeRound] has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.32   Event Reentrancy", "body": "  CS-EVERSTKB2C-009  In several functions, an event is emitted after an external call to some address, in the case that the call would reenter the contract, it would be possible to have events emitted out of order.  The list of such patterns is shown below.   Pool.unstake() with _safeEthSend() and the event Unstake.   Pool.unstakePending() with _safeEthSend() and the event StakeCanceled.   Withdrawer._claimWithdrawRequest()  with  ITreasuryBase.sendEth()  and  the  event  ClaimWithdrawRequest.   Accounting.claimPoolFee()  with  IRewardsTreasury.sendEth()  and   the  event  ClaimPoolFee.  Everstake - ETH B2C Staking -   27  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                    \f  All the patterns above have been updated to emit the event first, and then transfer ETH.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.33   Gas Optimizations", "body": "  CS-EVERSTKB2C-011  1. The type casting from address to address is not required in Pool.initialize(), removing it  might save gas during initialization depending on the compiler's optimization setting.  2. pendingValidatorPubKey is read twice from storage in Pool._deposit(), the value could be  cached in memory to avoid one SLOAD.  3. The  checks  of  the  form  a  !=  b  &&  a  !=  c  can  be  modified  following  De  Morgan's  law (!(a  ==  b  ||  a  ==  c))  to  leverage  the  lazy  evaluation  of  the  condition  and  save  gas  on runtime.  4. Some function arguments on call can be replaced by constants. Some examples are:   Accounting._activateRound(): the variable activeRound can be replaced by 0 in  the call _makeAutocompoundRoundCheckpoint(activeRound).   Accounting._depositBalance():  in  the  call  to  _activateRound()  of  the  branch >  parameter replaced  by  if  pendingTotalShare  +  closeCurrentRoundAmount  can  be  BEACON_AMOUNT.  (pendingAmount   0),   the    Accounting._depositBalance(): in the call to _depositAccount() of the branch if  (depositToPendingAmount  >  0),  the  parameter  interchangedAmount  will always be 0.   Accounting._depositBalance():   call AUTO_COMPOUND_PENDING_SHARE_POSITION.setStorageUint256() of the branch if  (depositToPendingAmount  >  0),  the  parameter  pendingTotalShare  will always be 0.  the   in   5. The  activatedSlots  in  the  branch  if  (pendingTotalShare  >  0)  of  the  function Accounting._depositBalance() can be set to 1 instead of incrementing the variable to save gas on runtime.  loop   while  and  multiple  (depositToPendingAmount   branch 6. The  if  function Accounting._depositBalance can be replaced by one update for each involved variable. If the while  loop  was  to  stay,  a  do-while  construct  could  save  gas.  The  same  applies  in _simulateAutocompound().  variables  BEACON_AMOUNT)   stack  >=   increments   the   the   of   in   pendingTotalShare  7. Setting  >=  (depositToPendingAmount  if  Accounting._depositBalance is redundant.  to   0   in  BEACON_AMOUNT)   the   of   the   branch function  8. The  while  loop  in  the  function  Accounting.withdraw()  can  be  simplified  since  in  the  case isFullyDeposited==false,  then  the  remaining  interchangeWithPendingDeposits  is zero.  9. In   the   branch  if  (withdrawFromPendingAmount  >  0)   function Accounting.withdraw,  pendingRestakedValue  -  withdrawFromPendingAmount  is computed twice while it could be done only once.  the   of   Everstake - ETH B2C Staking -   28  InformationalVersion1CodeCorrected      \f10. In  the  function  Accounting.withdraw,  the  pendingTotalShare  is  read  from  storage  twice  when it could be cached in the memory.  11. In   the   branch if  (unclaimedReward  <  MIN_RESTAKE_POSITION.getStorageUint256())  of  the function  Accounting._simulateAutocompound(),  the  constant  0  can  be  used  instead  of unclaimedReward  statement   return   the   of   12. When  simulating  the  withdraw  queue  filling  in  Accounting._simulateAutocompound(),  the in  same  way   branches   could   done   the   be   in   is   it   if/else  unified  Withdrawer._interchangeWithdraw().  13. The  modifier  Governor.onlyGovernor()  does  the  address  check  after  executing  the  code.  Reverting early would save gas.  14. In the function Pool._stake(), value cannot be zero.  15. The increment i++ can be in an unchecked block in multiple for loops.  16. The  function  Withdrawer.  _calculateValidatorClose  can  return  only  one  value,  as  the  two values are linked by a constant factor, one can easily deduce a value from the other one.  17. In   the   function  Withdrawer._calculateWithdrawRequestAmount,   the   withdrawFromActiveDeposit  true  withdrawFromActiveDeposit > pendingTotalShare is true and is hence redundant.  always   will   be   >   0   condition if  18. In the function WithdrawRequests.add, the assignation requests._values[i] = request can  be  moved  inside  the  if  (requests._values[i].value  ==  0)  block  and  the  function can return right after.  19. In   the   functions   WithdrawRequests.info, requests.value[i].afterFilledAmount  is  read  twice  from  the  storage  while  it  could  be cached to avoid one SLOAD.  WithdrawRequests.claim   and   20. In  the  functions  WithdrawRequests.claim  and  WithdrawRequests.info,  the  condition requests._values[i].afterFilledAmount  >  actualFilledAmount  can  be  relaxed  to an  if requests._values[i].afterFilledAmount  ==  actualFilledAmount  their  difference  is null.  comparison   unstrict   since   21. In  the  function  WithdrawRequests.info,  requests._values.length  is  read  from  the  storage at each iteration of the loop. Caching it in the memory would avoid several SLOAD.  22. In   the   function   and set._activePendingElementIndex  are  both  read  three  times  from  the  storage  when  their value could be cached in the memory.  set._activeValidatorIndex   ValidatorList.add,   23. In  the  function  ValidatorList.shift,  set._activePendingElementIndex  is  read  two  times from the storage when its value could be cached in the memory.  24. In   the   _autocompoundAccount, _autoCompoundUserPendingDepositedBalance,  and _withdrawFromAutocompound  field pendingDepositedBalances.length of the staker is read from the storage at each iteration of the loop. Caching it in the memory would avoid several SLOAD.  _autoCompoundUserBalance   AutocompoundAccounting,   functions,   the   of   25. In the first for loop of the function AutocompoundAccounting._autocompoundAccount, both staker.pendingDepositedBalances[j].period  and staker.activePendingDepositedElementIndex are read twice from the storage and could be cached.  26. In  AutocompoundAccounting._autocompoundAccount(),  when  updating  the  pending times  status  three  staker.activePendingDepositedElementIndex from storage, it could be cached.  pendingDeposited,   execution   read   path   one   to   Everstake - ETH B2C Staking -   29  \f27. In  AutocompoundAccounting._autocompoundAccount(),  when  updating  the  pending status to pendingDeposited or to activated, both staker.pendingBalance.balance and staker.pendingBalance.period are read twice from storage.  28. In   AutocompoundAccounting._autoCompoundUserPendingDepositedBalance(),  staker.pendingBalance.period is read twice from storage.  if   29. In  AutocompoundAccounting._autoCompoundUserBalance(),  at  each  iteration  of  the  for both loop,  stakerAutocompoundBalance.pendingDepositedBalances[j].balance  and stakerAutocompoundBalance.pendingDepositedBalances[j].period  are  read  twice from storage.  statement   condition   met,   the   the   not   if   of   is   :  30. The calls to _userActiveBalance to get only the depositedBalance could be replaced by a  simple storage read to save gas.  31. At   the   end   Accounting._simulateAutocompound(), pendingAmount  ==  pendingRestaked  always  holds  as  if  if  (pendingAmount  >  0)  is entered,  then  they  are  both  set  to  0.  Otherwise  pendingAmount==0  and  hopefully  one  should always  have  pendingAmount  >=  pendingRestaked  meaning  that  there  is  no  need  to  keep both var for the while loop.  of     The gas optimizations have been applied.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.34   Governor Is Immutable", "body": "  While  the  Governor  role  of  the  Pool  can  be  transferred  to  another  address  by  the  Owner,  the SuperAdmin or the governor himself at any time, the Governor of the Accounting contract can only be set when calling Accounting.initialize.  CS-EVERSTKB2C-012    The Governor of the Accounting can now be updated using the function setGovernor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.35   Unneeded return Statement", "body": "  When a function signature looks like function foo() external returns(uint a, uint b), the statement return (a, b) is not necessary when the values to be returned have been assigned earlier to the returned variables.  CS-EVERSTKB2C-015  Some examples:   AutocompoundAccounting._withdrawFromAutocompound()   AutocompoundAccounting._autocompoundAccount()  Everstake - ETH B2C Staking -   30  Version3InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f  Some of the unnecessary return statements have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.36   Unused Imports", "body": "  The following imports are not used:  1. \"./interfaces/IPool.sol\" and \"./interfaces/ITreasuryBase.sol\" in Accounting.  2. \"./interfaces/IPool.sol\" in WithdrawTreasury.  3. \"./interfaces/IRewardsTreasury.sol\" in RewardsTreasury.  4. \"./ITreasuryBase.sol\" in IRewardsTreasury.  CS-EVERSTKB2C-016    All unused imports have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.37   Validator Cannot Be Marked as Exited", "body": " Immediately  In  ValidatorList,  markAsExited()  changes  the  status  of  num  validators  from  Deposited  to Exited provided that:  CS-EVERSTKB2C-010   Their status is Deposited.   They are all stored consecutively in set._validatorsPubKeys.   The   first   is  set._validatorsPubKeys.  validator   stored   at   index   set._activeValidatorIndex   of  By the design of the List struct and the functions add and shift, validators that are Deposited are not  always  at  starting  at set._activeValidatorIndex and can be interleaved by validator with another status. A Deposited validator  in  such  configuration  cannot  have  his  status  changed  to  Exited  until  all  previous  validators have the state Deposited or Exited.  slice  of  set._validatorsPubKeys   \"front\"  of   the   the     markAsExited() has been updated in such ways that the num validators to be marked as Exited no longer need to be stored consecutively. Additionally, Pool.reorderPending() can be used to order pending validators to be deposited to in the order as they appear in _validatorsPubKeys. Depending on how Pool.reorderPending() is called this can be used to keep _validatorsPubKeys's length from growing.  Everstake - ETH B2C Staking -   31  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f7.38   initializer Used Over onlyInitializing  CS-EVERSTKB2C-014  The  functions  __OwnableWithSuperAdmin_init_unchained  onlyInitializing would be more correct.  __OwnableWithSuperAdmin_init  the   and initializer  modifier  while  have     The modifier onlyInitializing is used instead of initializer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "7.39   minStake's Value Differs From the", "body": " Documentation  In the Pool.initialize, the minimum stake is set to 0.01 ETH while the documentation states that the minimum users are allowed to stake is 0.1 ETH.  CS-EVERSTKB2C-013    The minimum stake is now set to 0.1 ETH in Pool.initialize.  Everstake - ETH B2C Staking -   32  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f8   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "8.1   Inconsistent Use of override and virtual", "body": "  In solidity, it is not mandatory to use the override keyword when implementing a function from a parent interface.  For  the  sake  of  consistency,  either  none  or  all  implementations  should  be  annotated  with override.  Additionally, Pool.setGovernor is set as virtual although no contract inherits from Pool.  CS-EVERSTKB2C-006  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "8.2   The Sum of Shares Can Be Less Than the", "body": " Total Shares Supply  Due  to  some  rounding  errors,  the  shares  distributed  to  individual  stakers  for  a  given  round  might  not match the total number of shares minted for that round, i.e. _amountToShare(X+Y+Z) >= _amountT oShare(X)  +  _amountToShare(Y)  +  _amountToShare(Z).  The  difference  in  value  cannot  be claimed by anyone.  CS-EVERSTKB2C-007  Everstake - ETH B2C Staking -   33  InformationalVersion1InformationalVersion1      \f9   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "9.1   Deposited Amount Is Gifted if Less Than 1", "body": " Share  Users should be aware that any amount resulting in less than a share will be a donation to the pool. Even though  this  should  be  avoided  by  the  minimum  stake  constraint,  it  is  possible  to  stake  and  unstake pending, leaving a small amount to be activated, which may result in 0 share.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "9.2   Users May Miss Rewards on Closed Validator", "body": "  If  some  validator  is  expected  to  close,  i.e.  EXPECTED_CLOSE_VALIDATORS  >  0,  any  rewards accumulated in the RewardsTreasury that is above 32ETH will be considered as a stake returned by a closing  validator  instead  of  a  reward.  So  any  staker  withdrawing  when  one  or  more  validators  are expected to close and when 32ETH of staking rewards or more are available in the RewardsTreasury will miss that reward.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "9.3   Users May Not Be Fully Refunded in Case of", "body": " Slashing  According  to  the  Trust  Model,  Everstake  plans  to  deploy  an  emergency  treasury  fund,  but  do  not guarantee all the users to be fully refunded in case of slashing.  Everstake states:  We understand and don't neglect the risks related to slashing and we will have a special Emergency Treasury Fund - an Ethereum wallet address for Emergency Cases. Emergency Treasury fund will have some amount of Ethereum to cover at least partly possible unlikely slashing related issues. We also plan to send some defined share of Ethereum service fee received from the Pool by Everstake, approximately 10%.  Example: Pool Service fee is 10% Emergency Treasury Fund share is 10% If all Validators within the Pool generated 10 000 ETH Then Everstake will receive 1 000 ETH as a Pool Service Fee And 100 ETH from Pool Service fee will be send to Emergency Treasury Fund  Everstake - ETH B2C Staking -   34  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/everstake-eth-b2c-staking/"}, {"title": "5.1   Assessement of Finalized After Authed Action", "body": "  CS-CSC-001  In  ScribeOptimistic,  _afterAuthedAction()  will  be  called  after  every  change  to  the  parameters  to drop opPokeData if it's not yet finalized. The evaluation whether the optimistic poke is finalized is done using the possibly new value for opChallengePeriod however.  This has the following consequences:  In case the new challenge period is bigger, _afterAuthedAction will evaluate the finality based on  the  increased  challenge  period.  Consequently  an  already  finalized  opPokeData  becomes challengeable again and may be dropped.  In case the new challenge period is smaller, _afterAuthedAction will evaluate the finality based on  the  decreased  challenge  period.  Consequently  an  previously  un-finalized  opPokeData  will  be regarded finalized immediately.  Risk accepted:  Chronicle has accepted the risk of finality reevaluation and states:  The \"reevaluation of finality\" based on a possibly updated opChallengePeriod is accepted. We plan to update the challenge period in the beginning a few times to find \"the best\" reasonable value. Afterwards, we don't intend to update the challenge period anymore following a \"never stop a running system\" approach.  Chronicle - Scribe -   13  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedRiskAcceptedCorrectnessMediumVersion1RiskAccepted             \fFurthermore, the code has been adjusted that in case a finalized opPokeData is more recent than the _pokeData,  it  will  also  be  pushed  into  _pokeData  and  deleted.  This  avoids  resetting  the  challenge period for a finalized opPokeData. Chronicle states:  _afterAuthedAction has been updated to ensure the challenge period of an opPoke is not reset, which would decrease the possible update frequency via opPoke (). This is achieved via either moving _opPokeData to _pokeData storage if _opPokeData is finalized and newer than _pokeData, or deleting opPokeData otherwise.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "5.2   Drop of opPoke if Authed Action Does Not", "body": " Update Anything  setOpChallengePeriod(),  setMaxChallengeReward(),  and  setBar()  will  always  call _afterAuthedAction() to drop unfinalized opPokeData, even if the updated parameter is the same as the old parameter.  CS-CSC-002  Risk accepted:  Chronicle states:  Skipping the afterAuthedAction in special cases changes the definition of the action, which is defined to be called after every authe'd configuration change.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "5.3   Lift Does Not Drop Unfinalized opPoke", "body": "  ScribeOptimistic generally drops unfinalized optimistic poke data after the update of parameters to avoid any issues connected to an unexpected change of the verification result.  _lift()  is  not  overridden  in  ScribeOptimistic  to  call  _afterAuthedAction()  which  drops  the unfinalized opPokeData. This may allow not yet but soon to be feeds to sign the price update.  CS-CSC-003  Assume Alice is not a member of the current feeds at t   and t   < t   < t  .  2 , Alice signs a price with other bar-1 feeds, and opPoke() it.  1  0  0   At t 0  At t 1  At t  2  , wards add Alice to the feeds.  pokeData becomes valid.  , one comes to challenge the opPokeData, the challenge fails (verification succeeds) and the  In  this  example,  Alice's  signed  data  successfully  passes  the  verification,  though  Alice  has  not  been authorized at t  , the time the price data was aggregated.  0  Risk accepted:  Chronicle states:  Chronicle - Scribe -   14  DesignLowVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                \fThis is a valid issue from a theoretical point of view. However, practically we don't see any problems arising through this.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "5.4   Race of Feeds", "body": "  Given  the  gas  and  runtime  limitation,  bar  shouldn't  be  too  large,  whereas  there  could  be  254 (maxFeeds) feeds at most. In case feeds' amount is larger than bar, feeds may form different subsets and sign with different views of the current price. As the price update frequency is at most once per block (limited by the freshness check of the pokeData.age), there could be a race case among the feeds.  CS-CSC-004  Risk accepted:  Chronicle states:  The bar-to-feed ratio will be set conservatively, i.e. \"far more\" feeds than bar. While the relationship will always be that bar > #feeds/2 to ensure that only a consensus of >50% can advance the oracle to a new price, we want to have more feeds than bar to not risk downtime due to feeds being dropped.  The current configuration is: 22 feeds with a bar of 13.  Chronicle - Scribe -   15  SecurityLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Update Using Stale PokeData   -Severity Findings   Unreset opPokeData After Unsuccessful Challenge   -Severity Findings  Incorrect Formula in Docs   Indexed Fields of Event Poked   0  1  1  2  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "6.1   Update Using Stale PokeData", "body": "  In  ScribeOptimistic  an  optimistic  poke  is  considered  finalized  after  the  challenge  period  elapsed.  If  the optimistic  poke  (opPokeData.age)  is  finalized  and  more  recent  than  the  last  stored  poke  data (pokeData.age), the pricefeed returns the optimistic value:  CS-CSC-011  function _currentPokeData() internal view returns (PokeData memory) {     // Load pokeData slots from storage.     PokeData memory pokeData = _pokeData;     PokeData memory opPokeData = _opPokeData;      // Decide whether _opPokeData is finalized.     bool opPokeDataFinalized =         opPokeData.age + opChallengePeriod <= uint32(block.timestamp);      // Decide and return current pokeData.     if (opPokeDataFinalized && opPokeData.age > pokeData.age) {         return opPokeData;     } else {         return pokeData;     } }  Scribe.poke(), the function to update the pricefeeds _pokeData, only checks whether the new value is more recent than the stored data. It does not check whether there is a more recent finalized optimistic poke:  // Revert if pokeData stale.  if (pokeData.age <= _pokeData.age) {  Chronicle - Scribe -   16  CriticalHighCodeCorrectedMediumCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCorrectnessHighVersion1CodeCorrected          \f     revert StaleMessage(pokeData.age, _pokeData.age);  }  This update is then stored with the current block.timestamp as age:  // Store pokeData's val in _pokeData storage and set its age to now. _pokeData.val = pokeData.val; _pokeData.age = uint32(block.timestamp);  Resulting a stale pokeData could be used to update the pricefeed.  This issue arises in the state (_opPokeDate: finalized, _pokeData: set-older or uninitialized)    _poke() has been marked as virtual in Scribe and overridden in ScribeOptimistic, where it checks the stored  _pokeData  and  the  recent  finalized  optimistic  poke  to  determine  the  most  recent  age.  Thus  it prevents a stale pokeData to update the pricefeed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "6.2   Unreset opPokeData After Unsuccessful", "body": " Challenge  In  ScribeOptimistic,  in  an  unsuccessful  challenge  (successful  signature  verification),  opPokeData  is finalized  and  pushed  to  _pokeData.  _opPokeData  remains  unchanged  however.  This  will  block opPoke() even though the current opPokeData has been finalized until the challenge period is over.  CS-CSC-009  if (ok) {         // Decide whether _opPokeData stale already.         bool opPokeDataStale = opPokeData.age <= _pokeData.age;          // If _opPokeData not stale, finalize it by moving it to the         // _pokeData storage.         if (!opPokeDataStale) {             _pokeData = _opPokeData;         }          emit OpPokeChallengedUnsuccessfully(msg.sender); }    _opPokeData will be deleted in case it is verified successfully and is more fresh than the _pokeData. Thus, this finalized _opPokeData will not block a new opPoke() anymore.  Chronicle - Scribe -   17  DesignMediumVersion1CodeCorrected          \f6.3   Incorrect Formula in Docs  In docs/Schnorr.md, the formula of re-computing challenge in signature verification is incorrect compared to the ones in signing and in code implementation. The order of the last two parameters is wrong.  e = H(Px || Pp || Re || m) mod Q  CS-CSC-012  Specification changed:  The  signature  verification  formula  in  docs/Schnorr.md  has  been  corrected  to  align  with  the  signing formula and the code implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "6.4   Indexed Fields of Event Poked", "body": "  CS-CSC-008  /// @notice Emitted when oracle was successfully poked. /// @param caller The caller's address. /// @param val The value poked. /// @param age The age of the value poked. event Poked(address indexed caller, uint128 val, uint32 age);  Indexing fields in events allows to easily search for certain events. The val and age of the event above are not indexed. Indexing e.g. the age field would allow off chain observers to easily search for prices in the past.    The val and age of the event have been marked as indexed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "6.5   Gas Optimizations", "body": "   getSignerIndexLength() could load the length by assembly.  In _verifySchnorrSignature(), lift(), and drop() the counter i inside of the for loop can be increased in an unchecked scope, as it is always bounded.  CS-CSC-010   There  is  no  amount  limitation  of  inputs  for  abi.encodePacked(),  thus  one  invocation  should and  constructPokeMessage()   parameters   the   all   to   in   suffice  _constructOpPokeMessage().  pack   In _verifySchnorrSignature(), loading a public key at an index can be abstracted into another internal function to decrease code duplication.  In _lift(), the require statement index <= maxFeeds can be moved into the if branch, as we only need to check the number of feeds when a new public key is added.  Chronicle - Scribe -   18  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                       \f The first condition check (opPokeDataFinalized) can be removed in _opPoke(), as the function  would already revert if it is false.  if (!opPokeDataFinalized) {     revert InChallengePeriod(); }  uint32 age = opPokeDataFinalized && opPokeData.age > _pokeData.age         ? opPokeData.age : _pokeData.age;  In LibSchnorr, the following line can be wrapped in an unchecked scope.  uint s = LibSecp256k1.Q() - mulmod(challenge, pubKey.x, LibSecp256k1.Q());  In addAffinePoint(), some intermediate results can be cached to avoid computing repeatedly. For example:  uint left = mulmod(addmod(z1, h, _P), addmod(z1, h, _P), _P);  uint v = mulmod(x1, mulmod(4, mulmod(h, h, _P), _P), _P);  uint j = mulmod(4, mulmod(h, mulmod(h, h, _P), _P), _P);  In  addition,  the  following  optimizations  only  work  if  the  external  view  functions  are  called  by  a  smart contract.  In feeds(), the for loop counter i can start from 1 as the public key at index 0 is an zero point. And i can be increased in an unchecked scope.  In feeds(uint index), the input index can be checked towards 0 for early revert. And the public key at a specific index is not loaded by assembly as before.    Code has been corrected to adopt some of the optimizations.  Chronicle - Scribe -   19      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "7.1   Authed and Tolled May Return Array With", "body": " Duplicates  authed() will return the existing wards addresses as an array. Upon rely() the address is inserted into the mapping and the array. Upon deny() the address is only reset in the mapping and not removed from  the  array.  Consequently,  in  case  an  address  is  added,  then  removed,  and  later  added  back, authed() will return an array that contains a duplicate of this address. The same applies to tolled().  CS-CSC-005  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "7.2   Timestamp of PokeData Aggregation Equal to", "body": " Block.Timestamp  Scribe._poke()  rejects  PokeData  with  timestamps  in  the  future  but  accepts  PokeData  with block.timestamp.  CS-CSC-006  // Revert if pokeData from the future. if (pokeData.age > uint32(block.timestamp)) {     revert FutureMessage(pokeData.age, uint32(block.timestamp)); }  It's a theoretical observation only with no impact in practice, but aggregating the price data and updating the  data  on  chain  seems  infeasible.  In  practice  when  _poke()  is  executed  it  should  hold block.timestamp > pokeData.age or the aggregation of the price data off chain likely happened for a timestamp (slightly) in the future.  Acknowledged:  Chronicle has acknowledged this theoretical observation with no impact in practice.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "7.3   Undropped schnorrData Commitment and", "body": " opFeedIndex  CS-CSC-007  Chronicle - Scribe -   20  InformationalVersion1InformationalVersion1AcknowledgedInformationalVersion1Acknowledged              \f_schnorrDataCommitment stores the schnorr data digest of an optimistically poked data, ensuring it will  be  challenged  by  the  same  schnorr  signature  later.  opFeedIndex  stores  the  feed  who  signs  to endorse  the  opPokeData  and  the  schnorr  signature.  Upon  a  successful  challenge,  these  variables  are not deleted consistently with the _opPokeData. However, as opPokeDataFinalized is computed by the following statement and opChallengePeriod is at most max(uint16), it would always be true after _opPokeData  is  deleted.  Consequently  double  challenging  an  already  dropped  _opPokeData  is  not possible.  bool opPokeDataFinalized =         opPokeData.age + opChallengePeriod <= uint32(block.timestamp);  Acknowledged:  Chronicle states:  You  are  correct  in  that  we  could  drop  the  schnorrDataCommitment  and  opFeed  Index.  However, doing  so  will  increase  the  costs  of  the  subsequent  opPoke  as  writing  to  zero-storage  is  more expensive than overwriting non-zero storage. Note furthermore, that the gas-stipend for emptying the storage is attributed to the opChallenge caller, i.e. a searcher.  Therefore, cleaning the storage would practically give external entities a gas stipend that relays have to pay during the next opPoke().  Chronicle - Scribe -   21  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "8.1   Considerations of pokeData.age", "body": "  pokeData.age is interpreted differently at different stages.   User submitted pokeData.age: it refers to the time it is generated offchain for freshness check and  signature verification.   Onchain stored pokeData.age: it refers to the time the offchain generated data is poked or opPoked  onchain.  In ScribeOptimistic, there could be a potential delay to read the most recent valid opPokeData.age, as it only takes effect after being finalized.  In addition, systems integrate the ScribeOptimistic should aware that an old pokeData could be carried over to the current time (by updating the age to current block.timestamp) in following cases:   A  successful  challenge  (a  failed  verification)  will  drop  the  current  opPokeData  and  advance  the  existing _pokeData.age to current block.timestamp.   An  update  of  the  oracle  parameters  (setBar(),  setOpChallengePeriod(),  drop())  by  the  wards will always advance the valid most fresh pokeData.age to current block.timestamp.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "8.2   Decimals of Price Feed", "body": "  Scribe oracles use 18 decimals for price values. Besides implementing own interfaces to read the price, the  Chainlink  interface  is  implemented  to  serve  potential  customer  already  integrating  with  Chainlink. Note  that  Chainlink  usually  uses  18  decimals  for  ETH  denominated  assets  but  8  decimals  for  USD denominated assets. Hence projects need to be careful especially when switching from Chainlink USD based pricefeeds to Scribe.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "8.3   Implications Regarding the Value of Bar", "body": "  setBar()  incorporates  a  check  to  restrict  the  bar  value  from  being  set  to  zero.  However,  the  upper boundary is only limited by the uint8 datatype, which is 255.   The  system  can  accommodate  a  maximum  of  254  feeds  (assuming  no  feed  is  ever  removed).  Therefore, if the bar is set to 255, the processing of any poke becomes unfeasible.   Once the bar value crosses a certain threshold, verifying the aggregated signature may surpass the  block gas limit, thereby rendering on-chain verification impossible.   Dropping  feeds  (e.g.  directly  or  in  ScribeOptimistic  after  a  successful  challenge)  may  result  in  the  number of feeds remaining being insufficient to cover bar.  The privileged role is expected to set the value for bar correctly.  Chronicle - Scribe -   22  NoteVersion1NoteVersion1NoteVersion1          \f8.4   Max 254 Feeds Over the Contracts Lifetime  By design, a Scribe Pricefeed can have a maximum of 254 feeds added: Adding a new pricefeed pushes the public key into the _pubKeys array. Removing a price feed resets the pricefeeds public key entry to the  zero  point,  however  this  does  not  free  up  the  space.  Feeds  IDs  are  hence  never  reused  but  the tradeoff is the maximum number of possible feeds that can be added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "8.5   Penalty to Rogue Feeds", "body": "  If  a  feed  endorses  an  invalid  schnorrData  /  pokeData  combination  in  ScribeOptimistic,  the  feed  will  be dropped when challenged. In addition to dropping the feed, there is no more penalty to the feeds on the contract level.  Chronicle states:  Any kind of penalty regarding misbehaving feeds will be handled on the social layer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "8.6   Price Change", "body": "  Systems  that  integrate  with  Scribe  or  ScribeOptimistic  should  be  aware  of  the  possible  ways  that  can change the price (pokeData.val).  Below we list occasions where the price can change immediately as well as some potential ways how this could be leveraged (i.e. bundled):   Authenticated (in Scribe and ScribeOptimistic): _poke() invoked with a valid new pokeData and  schnorr signature from feeds. The current price will advance to a new price.   Wards  (only  in  ScribeOptimistic):  _afterAuthedAction()  invoked  by  the  wards  which  drops  a previously  finalized  opPokeData  according  to  the  new  challenge  period.  In  case  this  dropped opPokeData is the freshest one, the current price will rollback to the _pokeData.   Permissionless  (only   in  ScribeOptimistic):  onChallenge()  which   fresh opPokeData  and  pushes  it  to  _pokeData.  The  current  price  will  advance  to  the  new  price (opPokeData). Similarly, after an optimistic poke, anyone could execute poke() using this signed data to advance the price immediately.  finalizes  a  valid   When  integrating  with  ScribeOptimistic  projects  must  be  aware  that  an  optimistic  price  update  is generally but not always subject to the challenge period delay: anyone may finalize it at any point during the challenge period.  Chronicle - Scribe -   23  NoteVersion1NoteVersion1NoteVersion1            \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/chronicle-scribe-makerdao/"}, {"title": "5.1   Liquity: Lack of Support for ", "body": " claimCollateral()  0  0  1  0  The technical documentation of Liquity writes the following:  claimCollateral(address _user): when a borrower\u2019s Trove has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio above 110%, this function allows the borrower to claim their ETH collateral surplus that remains in the system (collateral - debt upon redemption; collateral - 110% of the debt upon liquidation).  However,  the  Liquity  position  library  does  not  support  such  an  action.  Hence,  it  could  be  possible  that funds could become stuck in some situations (e.g. liquidations in recovery mode).  Avantgarde Finance - Sulu Extensions -   9  DesignCriticalHighMediumLowDesignMediumVersion1         \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Redundant While-loop    Unstaking sOHM Leaves Dust   0  0  0  2  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-jan22/"}, {"title": "6.1   Redundant While-loop", "body": "  curveLiquidityAdapter.__parseSpendAssetsForLendingCalls  aims  to  detect  the  spent assets  and  the  amounts  of  them  so  that  they  can  be  post-processed  by  the  Integration  Manager.  It includes the following while-loop which should always terminate after one iteration.  while (spendAssetsIndex < spendAssetsCount) {     for (uint256 i; i < _orderedOutgoingAssetAmounts.length; i++) {         if (_orderedOutgoingAssetAmounts[i] > 0) {             spendAssets_[spendAssetsIndex] = __castWrappedIfNativeAsset(                 canonicalPoolAssets[i]             );             spendAssetAmounts_[spendAssetsIndex] = _orderedOutgoingAssetAmounts[i];             spendAssetsIndex++;         }     } }  Notice  that  spendAssetsIndex  increases  to  the  maximum  value  of  spendAssetCount  inside  the for-loop.    The  while-loop  been  spendAssetsIndex == spendAssetsCount was added.  removed  while   has   an   early   exit   of   the   for-loop  when  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-jan22/"}, {"title": "6.2   Unstaking sOHM Leaves Dust", "body": "  sOHM is a rebasing token, meaning that the number of tokens a vault has increases after each epoch. Sulu currently allows managers to define the number of sOHM tokens they want to unstake. Consider the following case:  Avantgarde Finance - Sulu Extensions -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f A fund manager M wants to unstake all the sOHM the fund holds   The fund manager submits a transaction where they unstake the total amount of the tokens   A rebase happens and the number of sOHM increases   The transaction is mined.  This will lead to the fund holding a dusty amount of sOHM together with the unstaked OHM tokens.    The code has been adapted to support unstaking the maximum amount when uint.max is specified as the unstake amount.  Avantgarde Finance - Sulu Extensions -   11  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-jan22/"}, {"title": "7.1   Rewards in Different Gauge Version", "body": "  CurveLiquidityAdapter is implemented in such a way so that it is compatible with version 2, 3 and 4 of  the  gauge  tokens.  When  claim_rewards  for  the  gauge  tokens  v2  and  v3,  rewards  are  accrued. However,  this  is  not  true  for  v4  where  users  should  pass  a  specific  argument  for  the  rewards  to  be accrued.  Avantgarde Finance - Sulu Extensions -   12  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-jan22/"}, {"title": "5.1   Admin Set Too Early in ", "body": " LiquidityGaugeV4Strat  The  admin  is  transferred  via  a  commit-accept  scheme  in  LiquidityGaugeV4Strat.  However,  the scheme is bypassed by directly setting the new admin in commit_transfer_ownership:  @external def commit_transfer_ownership(addr: address):     \"\"\"  StakeDAO - LiquidLockers -   10  DesignCorrectnessCriticalHighMediumAcknowledgedAcknowledgedLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCorrectnessMediumVersion1Acknowledged           \f    @notice Transfer ownership of Gauge to `addr`     @param addr Address to have ownership transferred to     \"\"\"     assert msg.sender == self.admin  # dev: admin only     assert addr != ZERO_ADDRESS  # dev: future admin cannot be the 0 address      self.future_admin = addr     self.admin = addr     log CommitOwnership(addr)  While this doesn't compromise the security of the contract, it causes the emitted event to be incorrect and is misleading to users who don't believe an immediate transfer of ownership is possible. Furthermore, the function accept_transfer_ownership is made redundant if this behavior is intended.  Acknowledged  StakeDAO  acknowledges  the  issue  and  noted  that  they  had  to  implement  this  function  for  the  factory contract so that it can transfer the admin of the contract in one transaction.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.2   Zero Address Reward Distributor", "body": "  The add_reward functions in all gauge contracts do not check that the _distributor address is not the  zero  address.  This  is  problematic  as  set_reward_distributor  asserts  that  the  distributor address  is  not  zero.  Therefore,  if  add_reward  is  called  with  the  zero  address  as  the  _distributor parameter, a reward distributor can never be set for this reward token entry.  Acknowledged  StakeDAO  acknowledges  the  issue  without  changes  as  they  rate  the  chances  as  very  low  that  the described issue happens. They state the issue only occurs when they add a reward distributor manually to the LiquidityGaugeV4.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.3   Functions Marked public Should Be", "body": " external  The following functions are public but not called from within the corresponding contract. Hence, they should be marked external.   AngleStrategy.deposit   AngleStrategy.withdraw   AngleVault.init   AngleVault.deposit   AngleVaultGUni.deposit   BalancerVault.init  StakeDAO - LiquidLockers -   11  CorrectnessMediumVersion1AcknowledgedDesignLowVersion1Acknowledged                \f BalancerVault.deposit   BalancerVault.provideLiquidityAndDeposit   BalancerVault.withdraw   CurveVault.init   CurveVault.deposit  Acknowledged  Client acknowledges the issue without changing the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.4   Inconsistent Limits on Fees", "body": "  The  constraints  for  which  fees  can  be  set  is  inconsistent  between  strategies.  For  example,  the AngleStrategy  contract  allows  each  individual  fee  to  be  as  high  as  BASE_FEE,  whereas  the BalancerStrategy contract only allows the sum of all fees for a gauge to be as high as BASE_FEE.  Acknowledged  StakeDAO is aware of the issue and acknowledges it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.5   MANAGEFEE Enum Defined Multiple Times", "body": "  The  MANAGEFEE  enum  is  defined  once  in  each  Strategy  contract.  It  would  be  simpler  and  less error-prone to instead define it in the shared interface instead.  Acknowledged  StakeDAO is aware of the issues and acknowledges it. They might change it in future releases.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.6   Misleading Governance Addresses", "body": "  A Strategy contracts calls its respective Locker contract in its deposit, withdraw and claim functions. It  specifically  calls  the  Locker's  execute  function,  which  has  the  onlyGovernance  modifier.  Any reasonable user would assume that onlyGovernance modifier means that the execute function could only be called by the governance contract. However, the Locker's governance address is instead set to the Strategy contract's address in order to allow this functionality.  Acknowledged:  StakeDAO - LiquidLockers -   12  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                        \fAccording  to  StakeDAO,  this  is  related  to  their  flow.  There  are  many  layers  of  governance.  The governance address of the Locker contract is the Strategy contract. The governance of the Strategy is the  voter  contract,  which  is  a  helper  contract  to  facilitate  on-chain  voting  and  admin  functionality.  The voter contract is owned by a multisig.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.7   Missing Check if withdrawFee Is Zero", "body": "  In  the  Angle  vault  contract's  withdraw  function  a  transfer  to  the  governance  contract  is  done  to  send potential fees. The transfer is also done if the fees are actually zero.  Acknowledged:  StakeDAO acknowledges this issue as it is only present in the AngleVault contract and has been fixed for other vault implementations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.8   Missing Events", "body": "  Multiple  functions  perform  important  state  changes  without  emitting  an  event.  For  example,  the  setter functions in the vault and strategy contracts.  Acknowledged:  StakeDAO does not see the necessity to emit these events and acknowledges the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.9   Missing Sanity Checks", "body": "  There are multiple setter functions missing the address zero sanity check.   toggleVault and all setter functions in AngleStrategy except for setVaultGaugeFactory   Multiple setter functions in the different vault contracts  Additionally, withdraw and deposit in LiquidityGaugeV4Strat can be called with _addr = 0.  There are no limits imposed when setting the keeperFee and withdrawalFee for a vault. This allows setting an arbitrarily high fee, even above 1.  Acknowledged  StakeDAO states that they do the checks on their side.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.10   NatSpec Missing", "body": "  StakeDAO - LiquidLockers -   13  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                                \fMany contracts are missing NatSpec. Some only have partial or incomplete NatSpec.  Acknowledged:  StakeDAO is implementing NatSpec documentation in newer deployments.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.11   Non-indexed Events", "body": "  The  events  in  the  following  contracts  signal  important  state  updates  which  include  addresses.  The corresponding address is part of the event but not indexed.  In liquidityGaugeV4Strat:   UpdateLiquidityLimit   CommitOwnership   ApplyOwnership  All Events in AngleVault, AngleVaultGUni, BalancerVault, CurveVault and BaseStrategy.  Acknowledged:  As indexed events cost more gas, StakeDAO decided not to add them but handle fetching and filtering events on their side.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.12   State Variable Could Be Immutable", "body": "  The state variable token in the AngleVaultGUni contract could be made immutable to save gas.  Acknowledged:  StakeDAO will take this gas optimization into consideration in future implementations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.13   Superfluous Variable Assignment", "body": "  The  BalancerVault  contract  writes  assets[i]  =  address(tokens[i])  in  a  loop.  This  variable assignment seems superfluous.  Acknowledged:  StakeDAO  has  decided  to  acknowledge  this  unnecessary  gas  consumption  as  it  does  not  have  any impacts on security.  StakeDAO - LiquidLockers -   14  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                          \f5.14   Unnecessary External Call to approve  In  AngleVault.deposit,  BalancerVault.setLiquidityGauge  and  CurveVault.deposit  the corresponding contract's approve function is called with an external call when an internal call could have been performed.  Acknowledged:  StakeDAO  will  consider  changing  this  unnecessary  external  call  to  a  function  call  in  future implementations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.15   Unused Imports", "body": "  Some contracts import code that is not used in the contract. E.g., AddressUpgradeable is imported in AngleVault  and  used  in  the  using  statement  without  ever  using  functionality  from  the  library. Removing all unused imports and library contracts enhances the code quality and readability.  Acknowledged:  StakeDAO acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "5.16   Wrong Event Emitted", "body": "  The Transfer event emitted at the end of the withdraw function in the LiquidityGaugeV4Strat contract has incorrect parameters. It emits msg.sender as the _from address instead of _addr.  Acknowledged:  StakeDAO acknowledges the issue. To track the correct event, they would track the vault's withdraw event.  StakeDAO - LiquidLockers -   15  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedCorrectnessLowVersion1Acknowledged                      \f6   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "6.1   Inconsistent Withdraw Fees", "body": "  When withdrawing from a Vault it matters if the vault currently has accumulated a token balance due to deposits being made without using the earn option. If the withdrawn amount is smaller than the balance, the users end up in a race condition to save the withdraw fees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "6.2   Known Issues Before the Audit", "body": "  The following two issues were known before the audit:  In AngleVault:  > withdrawAll() wrongly defined. Since that every LP obtained will be staked directly into the related LGV4, for this reason the msg.sender's balance would be always 0.  In CurveStrategy:  > An edge case can happen within the harvest() for certain type of curve gauges, with more than one extra reward.  StakeDAO - LiquidLockers -   16  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-liquidlockers/"}, {"title": "7.1   Chainlink Query May Revert", "body": "  The Pool contract relies on ChainLink assumptions that do not hold. Chainlink's round IDs do not always increase monotonically. Therefore, the getRoundData queries can revert. Relying on _roundId-- in GeometricBrownianMotionOracle.getHistoricalPrice is not correct, since querying an invalid ID will make the swap revert.    The  call  to  the  price  feed's  getRoundData  function  has  been  moved  in  a  try/catch  block  and  the function returns (0, 0) if the oracle call reverts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.2   Dynamic Weights Changing Problem", "body": "  Swaap Labs - Swaap Core V1 -   13  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedDesignHighVersion1CodeCorrectedSecurityHighVersion1CodeCorrected                 \fAssume the pool has 10 X and 10 Y tokens that both have weight of 1. Initial invariant:  10X * 10Y = 100 Now  assume  attacker  sees  an  update  in  oracle  price,  that  will  change  the  weight  of  X  tokens  to  2. Attacker performs a trade: in 990 Y, out 9.9 X. New constant product:  After ChainLink price update, the X tokens weight become 2. New invariant:  (0.1X)2 * 1000Y = 10  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "0.1X * 1000Y = 100", "body": "  In 0.9 X, out 990 Y. The invariant holds:  New constant product:  (1X)2 * 10Y = 10  With 2 these trades that surround the price update, attacker profited by 9 X tokens.  The sandwiching can be performed using the Flashbots service. This issue is similar to the one that was discovered in Curve.    Swaap Labs introduced 2 solutions:  1. The   relative   price  AfterSwapPoolPrice/OraclePrice <= 102% + fee  difference   between   oracle   and   pool   price   is   capped:  2. If the user sells token that is in shortage, and the token price experienced increase in the current  block, extra fee is applied to compensate for a possible impermanent loss of the pool.  Together these 2 solutions help with the weight change sandwich attack.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.3   Geometric Brownian Motion Parameter", "body": " Estimation  For a returns R over time window T, the code estimates Geometric Brownian Motion parameters using these formulas:  Ri  N \u2211 i = 0 T  \u03bc =  N \u2211 i = 0  \u03c32 =  (Ri \u2212 \u03bc)2 + (T \u2212 N) * \u03bc2  T \u2212 1  According to specification, the second term in s computation is responsible for times, when the sample is missing and thus the return at that point is assumed to be 0.  Assuming dt is a regular sampling period, the N = T/dt - number of samples. In that case, a common way to estimate the GBM parameters using successive observations method is given by:  Ri  N \u2211 i = 0 N  \u0302\u03bc =  N \u2211 i = 0  \u0302\u03c32 =  (Ri \u2212 \u0302\u03bc)2  T N \u2211 i = 0  (Ri \u2212 \u0302\u03bc)2  T * dt N \u2211 i = 0  Ri  T + \u03c32  2  \u03c32 =  \u0302\u03c32 dt =  \u03bc =  \u0302\u03bc  dt + \u03c32  2 =  Swaap Labs - Swaap Core V1 -   14  DesignMediumVersion1CodeCorrected        \fComparing these estimations to code estimations, we can see following discrepancies:  1. Code m estimate lacks a 0.5 * s^2 term, and thus will be underestimated. 2. Code s estimate lacks a dt scaling factor, and thus will be overestimated. 3. Code  s  estimate  has  a  (T  -  N)/T  *  m^2  term,  that  also  doesn't  help  with  precision  of  the  estimate.  To  summarize,  the  outputs  of  GeometricBrownianMotionOracle.getStatistics  can  have  big errors, that might lead to impermanent losses of LPs as well as to overpriced swaps.  In addition, for Chainlink price oracles the sampling periods are not consistent and affected by Deviation and  Heartbeat  Thresholds.  Thus  the  code  computed  estimations  in  most  cases  will  fail  to  accurately estimate the price evolution process, even if it has the GBM nature.  Code modified:  The  parameters  estimation  method  has  been  modified  to  use  the  price  ratios  between  two  successive period instead of the return. The new implementation uses the following formulas:  Si = pricei \u0394i = timestampi \u2212 timestampi \u2212 1 T log(Sn  \u03bc = 1  )  S0  \u03c32 = 1  N \u2212 1 [\u22121  T log(Sn  )2 +  N \u2211 i = 1  log( Si Si \u2212 1 \u0394i  )2  ]  S0 These formulas come from the maximum likelihood estimation (MLE) for the GBM parameters. However to be the true MLE, mu should have a correction factor of + 0.5 * sigma^2. This correction factor is not  needed  here  because  Swaap  Labs  computes  the  z-percentile  of  the  lognormal  distribution,  which only needs mu + 0.5 * sigma^2 - 0.5 * sigma^2 = mu. Thus, the computed mu and sigma are consistent with their future usage.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.4   Inverted Token Performance", "body": "  The signature of the function is:  _getTokenPerformance(uint256 initialPrice, uint256 latestPrice)  and  computes  the  performance  ratio  as  latestPrice  /  initialprice.  However,  the  function  is (latestPrice_param, always  initialPrice_param),  ratio initialPrice_param / latestPrice_param.  arguments  result  of   inverted  performance   the  call  will  yield   called  with   the  the   following   order   the   the   in     Natspec and _getTokenPerformance call input order was fixed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.5   View Functions Reentrancy", "body": "  Some  view  functions  don't  use  the  _viewlock_  modifier.  In  case  of  reentrancy  due  to  ERC20  token calls (e.g. ERC777), these getters can return unreliable data. This may break the integration with other contracts and systems that rely on these getters. Such getter functions are:  Swaap Labs - Swaap Core V1 -   15  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                \f getAmountOutGivenInMMM  Please note, this list might be incomplete. Any function of a contract that does external call need to be lock or viewlock protected, if other external contract might rely on the data from this contract, such as spot prices, weights, etc.    View locks have been added to all view functions in the Pool.sol contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.6   Zero Exit Fee Allows Just-In-Time Liquidity", "body": " Provision  Since the system is not totally impermanent loss resistant, liquidity providers are still exposed to a risk. To  cope  with  the  risk,  malicious  liquidity  providers  can  sandwich  large  swaps  transactions  and  collect most of the swap fee without the risk of an impermanent loss.    JIT liquidity provision is mitigated by the use of a cooldown timer of 2 blocks. A LP that provided liquidity to  a  pool  cannot  exit  the  pool  or  transfer  LP  tokens  (by  either  transfer  or  approval  and transferFrom) for a period of 2 blocks after the liquidity provision.  However, this may block proxy contracts to manage funds for users. To cope with this issue, Swaap Labs added the joinPoolForTxOrigin, a function that pulls funds from msg.sender, but deposits them to the  tx.origin.  Since  it  is  not  the  authorization  by  the  tx.origin,  this  does  not  raise  problems  like https://swcregistry.io/docs/SWC-115.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.7   Num.abs Function Name", "body": "  The name of Num.abs function does not match its functionality.    The Num.abs function has been renamed Num.positivePart.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.8   getRoundData Function Duplication", "body": "  function  getRoundData  and   in functionality  The  GeometricBrownianMotion and in ChainlinkUtils. Functionality duplication should be avoided as it increases the amount of code to deploy and deteriorates code maintainability.  is  duplicated.   implemented   its   is   It   Swaap Labs - Swaap Core V1 -   16  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion2CodeCorrectedDesignLowVersion2CodeCorrected                        \f  The getRoundData function in GeometricBrownianMotion has been removed and its use has been replaced by the getRoundData function from ChainlinkUtils.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.9   Compiler Version Not Fixed and Outdated", "body": "  The  solidity  compiler  is  not  fixed  in  the  contracts.  The  version,  however,  is  defined  in  the truffle-config.js to be 0.8.0.  In the Factory contract the following pragma directive is used:  pragma solidity ^0.8.0;  Known bugs in version 0.8.0 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1531  More information about these bugs can be found here:  https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.12 which contains some bugfixes.    The compiler was fixed to version 0.8.12.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.10   Gas Inefficiency and Duplicated Checks", "body": "  1. In  the  GeometricBrownianMotionOracle.getHistoricalPrices  function,  idx  is  set  to hpParameters.lookbackInRound + 1 and then directly to 1. The second first assignation has no effect.  2. Math.getLogSpreadFactor checks horizon and variance for >= 0, this check is useless since  both values are uint256.  3. Math.getLogSpreadFactor does division by two with 5 * Const.BONE / 10, simply dividing  by 2 would save gas.  4. In  Math.getInAmountAtprice   it   is  possible   to  pack  computations   to  save  calls   to  LogExpMath.pow.  5. Some  state  variables  can   fit   in  smaller   types   (e.g.,  with   its  current  bounds,  dynamicCoverageFeesZ could fit in a uint64). Saving storage slots might save gas.  6. TokenBase's  _burn  and  _move  functions  check  that  there  is  enough  balance,  the  check  for  underflow is by default since compiler version 0.8.0.  7. PoolToken.transferFrom check that there is enough allowance, the check for underflow is by  default since compiler version 0.8.0.  8. PoolToken's  _name,  _symbol  and  _decimal  can  be  constant  and  their  respective  getter  functions can be external. This will save gas.  Swaap Labs - Swaap Core V1 -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f9. The overflow checks in numerous Num functions are not necessary anymore since compiler version ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "0.8.0,  which  features  automatic  overflow  check.  The  division  by  zero  checks  are  not  necessary,", "body": " solidity division will revert on a division by 0.  10. Elements  of  the  Pool.Record  struct  can  have  a  smaller  type  (e.g.  index,  denorm)  and  be  reordered to save storage.  11. The Pool's state variable _factory can be immutable.  12. Pool.joinPool, Pool.getAmountOutGivenInMMM, Pool.finalize can be external.  13. The  check  for  _controller  address  and  finalization  in  Pool.bindMMM  are  redundant  with  the  ones in Pool.rebindMMM.  14. When  resetting  storage  slots  on  mappings,  e.g.  in  unbindMMM,  the  use  of  delete  is  recommended for lower gas usage.  15. The  second  require  of  _getAmountOutGivenInMMMWithTimestamp  is  a  less  strict  version  of  the first requirement.  Version 2:  1. Const.MAX_IN_RATIO and Const.MAX_OUT_RATIO are never used in the code, they should be  removed.  2. getMMMWeight  is  always  called  with  shortage  =  true,  removing  the  argument  and  code  related to shortage = false will save gas.    1. idx is set to 1 at variable declaration.  2. Both checks for >= 0 have been removed.  3. The multiplication by 5 / 10 has been replaced by a division by 2.  4. The terms under w_o / (w_o + w_i) have been grouped together.  5. Acknowledged. Some state variables have been changed to use a smaller type.  6. The checks for sufficient balance have been removed.  7. The check for sufficient allowance has been removed.  8. PoolToken's  _name,  _symbol  and  _decimal  have  been  changed  to  constant  and  their  respective getter function have external visibility.  9. Unnecessary overflow checks in Num library have been removed.  10. index and denorm types have been reduced to uint8 and uint80 resp.  11. _factory state variable has been changed to immutable.  12. Pool.joinPool,  Pool.getAmountOutGivenInMMM,  Pool.finalize  visibility  has  been  changed to external.  13. The checks have been moved to the common _rebindMMM function.  14. delete is now used to reset the storage fields in the mappings.  15. Both require have been removed. The check has been replaced by the oracle update sandwich  protection.  Version 2:  1. Unused constants have been removed.  2. The shortage parameter of function getMMMWeight has been removed.  Swaap Labs - Swaap Core V1 -   18  \f7.11   Num Library Function Visibility  The functions of Num library have public visibility. This way, any contract that will need to deploy this library, will use it as an external contract. It means that any call to the library functions will result in quite expensive CALL opcode. If the visibility of those functions were internal, the function code would be then  inlined  at  the  point  of  use.  This  way  bytecode  size  of  Pool  will  be  smaller  and  gas  cost  for  each see: library  https://docs.soliditylang.org/en/latest/contracts.html#libraries  operation   smaller   more   well.   info   call   For   will   be   as     The visibility of the functions in the Num library has been changed to internal.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.12   Specification Mismatch", "body": "  1. The formula provided in the documentation for getInAmountAtPrice multiplies the desired price by  w_out  /  w_in  which  is  wrong,  however  the  implementation  correctly  multiplies  by w_in / w_out.  2. In the whitepaper, when the stochastic buy-sell spread is computed, the p-percentile of the random  variable is divided by the latest oracle price, this is not the case in the implementation.  3. The @dev natspec of getNextSample is incomplete  4. The @dev natspec of getRoundData makes a wrong assumption, the function will revert if no data  can be found as specified in https://docs.chain.link/docs/faq/#can-the-data-feed-read-revert.  5. The  specification  of  some  public  and  external   functions,  e.g.  joinPool,  finalize,  calcSpotPrice, is missing.  6. The @notice natspec of rebindMMM is incomplete.  7. The  natspec  of  Pool._getTokenPerformance  defines  twice  the  first  parameter  and  not  the  second one  Version 2:  1. The  @dev  natspec  of  GeometricBrownianMotionOracle.getHistoricalPrices  does  not reflect the implementation. If no historical data was found, the latest data and startIndex == 0 will be returned. If round data is 0, the round will simply be skipped, the algorithm will not stop filling prices/timestamps.  2. The _getParametersEstimation doesn't describe all @param.  Specification partially corrected:  1. The formula in the documentation has been corrected.  2. Specification changed.  3. The @dev natspec for getNextSample has been completed.  4. The implementation of getRoundData now matches the natspec.  Swaap Labs - Swaap Core V1 -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChanged                \f5. Comments or natspec have been added for some public and external functions.  6. The natspec for rebindMMM has been completed.  7. The second parameter is now described in the natspec.  Version 2:  1. The @dev natspec has been updated to reflect the implementation.  2. The missing parameters natspec has been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "7.13   Time Window of 1 Will Revert", "body": "  A  time  window  of  1  second  will  make  getStatistics  revert  due  to  a  division  by  zero.  The Const.MIN_LOOKBACK_IN_SEC  limit  enforced  on  _priceStatisticsLookbackInSec  storage variable  in  setPriceStatisticsLookbackInSec  function  does  not  prevent  this  case  from happening.    If time window = 1, the variance and mean are considered to be 0.  Swaap Labs - Swaap Core V1 -   20  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "8.1   Compatibility Issues Due to tx.origin", "body": "  The use of tx.origin limits certain functionality of the contract. Such contracts can be not deployable on chains that don't support ORIGIN opcode, e.g. Optimism. In addition, usage of this contract by wallet contracts like Gnosis wallet can also be limited.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "8.2   ERC20 Compatibility", "body": "  The _pull/_pushUnderlying functions of the Pool expect transferFrom and transfer to always return  a  boolean.  However,  some  tokens,  for  example  USDT,  do  not  follow  this  pattern  and  are  thus incompatible with the system. OpenZeppelin has a SafeERC20 library, which helps with such tokens.  In addition, the usage of ERC20 tokens with fees, rebalancing tokens, or tokens with reentrancies can be problematic to integrate. Swaap Labs needs to carefully consider what tokens can be supported by the Pool.  The _pull/_pushUnderlying functions have been modified to use the SafeERC20 library for token transfer.  Swaap Labs - Swaap Core V1 -   21  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-core-v1/"}, {"title": "6.1   Missing ETH Unwrapping", "body": "  The  AutomationExecutor  allows  its  owner  to  withdraw  tokens  or  native  ETH.  As  the  Oazo  team informed  us,  the  main  purpose  of  this  function  is  to  withdraw  ETH  converted  from  DAI.  The  exchange contract  is  not  able  to  handle  native  ETH  but  needs  its  wrapped  version.  Hence  there  is  a  need  for unwrapping functionality to be able to use native ETH. However, such functionality is not implemented.    unwrapWETH has been implemented. It can be called only by the owner of the AutomationExecutor contract and calls weth.withdraw function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.2   Accidental Approval Revocation", "body": "  On removeTrigger a user can accidentally set the removeAllowance variable to true. If this happens the approval to the automation bot is revoked. A user can only re-approve the automation bot indirectly by adding another trigger since there is no function to do this directly. Another option for the user is to use the revocation manager.  Oazo Apps Limited - Automation Consultancy -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fCode corrected  The functionality to grant approval to the automation bot has been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.3   Dead Code", "body": "  In  ServiceRegistry,  functions  addTrustedAddress,  removeTrustedAddress  and isTrusted  manipulate  the  trustedAddresses  mapping.  However,  this  mapping  is  not  used  by  the rest of the implementation. Moreover, McdUtils.convertTo18 is also never used.  the     The dead code has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.4   Missing Sanity Checks", "body": "  There are multiple points in the contract where sanity checks are missing. The absence of such checks can allow users to assign invalid values to variables:  1. AutomationBot.addRecord  does  not  sanitize  triggerType  and  triggerData.  Also, triggerData  includes  slLevel  which  can  have  invalid  values  that  cause  reverts  inside isExecutionLegal. Should the variables store invalid data the corresponding trigger will not be able to execute at a later point in time.  2. AutomationExecutor.(transferOwnership,  setExchange)  does  not  sanitize  the  input values. Notice that there is no delayed execution implemented for this contract.  3. ServiceRegistry.constructor sanitizes the required delay by requiring it to be less than the  maximum  integer.  However,  any  value  close  to  the  maximum  integer  would  be  valid  and problematic for the system.    1. AutomationBot.addRecord   validates   the   triggerData   by   using  commandAddress.isTriggerDataValid.  2. AutomationExecutor now sanitizes the data.  3. The maximum required delay is now set to 30 days.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.5   Outdated Compiler", "body": "  The system is compiled using solidity version 0.8.4. However, more recent versions are available. At the time of writing 0.8.13 is the most recent version.  Oazo Apps Limited - Automation Consultancy -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  The compiler version 0.8.13 is now used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.6   Redundant Authorization", "body": "  In McdUtils.drawDebt, the authorization of the AutomationBot to daiJoin is given every time the call is made since the following line is always executed:  IVat(vat).hope(daiJoin);  We noticed that the implementation is quite similar to https://github.com/OasisDEX/multiply-proxy-action s/blob/develop/contracts/multiply/MultiplyProxyActions.sol#L205. However, there is always a check if the authorization is needed.    The current implementation only grants authorization to daiJoin, if it has not been given before.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.7   Rounding Errors", "body": "  According to the specification (https://github.com/dapphub/ds-math), DSMath.wmul should be used with two  Wads  and  DSMath.rdiv  should  be  used  with  two  Rays.  However,  this  is  not  true  in McdView.getRatio where the following snippet exists:  uint256 ratio = rdiv(wmul(collateral, price), debt);  Here,  wmul  is  applied  on  collateral  which  is  a  wad  and  price  which  is  a  9-decimal  number.  The result will also be a 9-decimals number. Later, rdiv is applied on this 9-decimal number and debt which is a wad. The result is a Wad instead of a Ray. Wrong usage of DSMath leads to rounding errors. This means that a vault is rendered closable at different levels than the users have actually set.    In the current implementation price is a Wad and the problematic snippet has been rewritten to:  return wdiv(wmul(collateral, price), debt);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.8   Specification Discrepancies", "body": "  Oazo Apps Limited - Automation Consultancy -   13  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChanged                        \fThere  are  some  discrepancies  between  the  provided  specification  and  the  actual  implementation.  We follow the enumeration provided in the documentation.  System Requirements & Assumptions:  ServiceRegistry:  1. The addresses are not trusted, in the sense that the trustedAddresses mapping is not used. 4. removeTrustedAddress also does not use the delayedExecution modifier.  AutomationBot:  5. If a user executes addRecord directly to add a trigger then cdpAllow will not be called. 13. The permission might have been revoked by the user.  Smart Contract Architecture:  AutomationExecutor:   swapTokenForDai is documented but does not exist.   swap is implemented but not documented.  Specification changed:  All the discrepancies in the specification have been fixed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.9   Use Safe Calls", "body": "  AutomationExecutor exposes swap and withdraw functions. These functions, interact with ERC20 contracts  by  calling  ERC20.approve  and  ERC20.transfer.  However,  these  calls  will  fail,  should  a user  try  to  interact  with  a  USDT  contract.  For  example,  a  user  sends  accidentally  USDT  to  the AutomationExecutor, the amount will remain stuck there since any withdrawal by the owner will fail.    SafeERC20  used.  SafeERC20.safeIncreaseAllowance  and  ERC20.transfer  has  been  SafeERC20.safeTransfer.  ERC20.approve   library   been   now   has   is   replaced  with replaced  with  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.10   Zero Debt Vaults", "body": "  returns  0  when   the  debt  of  a  vault   McdUtils.getRatio  than CloseCommand.isExecutionLegal will return true, and thus, render the vault closable. This means that  a  caller  might  try  to  close  the  a  zero  debt  vault.  When  the  AutomationExecutor  calls AutomationBot.execute, the latter will try to withdraw extra debt (drawDaiFromVault) to cover its gas costs. However, the Maker system only allows users to withdraw debt that exceeds a specific limit (dust).  Since  the  amount  of  extra  debt  withdrawn  to  cover  the  caller  is  small  compared  to  the  dust amount, the whole transaction will revert.  is  0.  This  means     Oazo Apps Limited - Automation Consultancy -   14  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fAn execution of the CloseCommand is legal as long as the collateralization ratio is not 0.  Oazo Apps Limited - Automation Consultancy -   15  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-automation-consultancy-smart-contracts/"}, {"title": "6.1   onTokenTransfer Wrong Accounting", "body": "  When triggering onTokenTransfer with only one deposit, stake_amount is assumed to be 32 STAKE but is not checked. This allows a depositor to call STAKE.transfer with 1 STAKE but to be accounted for 32 in the Merkle tree.  Code corrected  In case of a single transfer the amount is set to the transferred amount specified. In batch transfers it is set to 32 Ether. This behavior is coherent with the behavior of single deposits and batch deposits.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-stake-beacon-chain-sbc-deposit/"}, {"title": "6.2   EIP1967 Storage Addresses", "body": "  Hard-coding long strings could be error prone. The storage addresses of implementation and admin are hardcoded as hex values in multiple places. This adds complexity and is even more error prone. A clean  mitigation  would  be  to  set  the  storage  addresses  used  for  implementation  and  admin  as constants once and use this constant later on.  Code corrected  The hard coded strings were replaced by constants.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-stake-beacon-chain-sbc-deposit/"}, {"title": "6.3   Interface Name Mismatch", "body": "  POA Network - SBC Deposit -   9  CriticalCodeCorrectedHighMediumLowCodeCorrectedCodeCorrectedCorrectnessCriticalVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                         \fThe name of the file and interface IERC667 should be IERC677 to be compliant with the transferAndCall Token Standard.  Code corrected  The file was renamed with the appropriate name.  POA Network - SBC Deposit -   10  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-stake-beacon-chain-sbc-deposit/"}, {"title": "7.1   Admin Power", "body": "  The system is administrated. The admin account has the complete power including withdrawing all funds by updating the implementation contract. Hence, the security of the admin key is of utmost importance as well  as  the  trust  in  the  key  holder/s.  POA  network  provided  the  information  that  they  are  aware  of  this note and will keep the admin contract under control by a multisig.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-stake-beacon-chain-sbc-deposit/"}, {"title": "7.2   Locked Tokens in Implementation", "body": "  The  admin  can  withdraw  all  tokens  balances  from  the  proxy,  but  funds  sent  to  the  implementation contract are stuck.  POA  Network  reasoned  that  from  their  past  experience  with  user  support  requests,  users  tend  to mistakenly  send  tokens  only  to  the  proxy  contract,  since  only  its  address  is  being  publicly  advertised. Implementation  contract  is  \u201chidden\u201d  from  regular  users,  so  they  are  unlikely  to  send  tokens  to  that address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-stake-beacon-chain-sbc-deposit/"}, {"title": "7.3   Proxy/implementation Separation", "body": "   The proxy takes care of the zero hashes initialization. To be consistent, this logic should belong into  the implementation contract.   The admin is able to act on both the proxy and implementation logics. It is usually a good practice to  separate roles of proxy from roles of implementation.  POA network is aware of this note and explained that this is the intended behavior.  POA Network - SBC Deposit -   11  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-stake-beacon-chain-sbc-deposit/"}, {"title": "5.1   Problems Related to Consent and", "body": " ConsentVerification  The consent ECDSA signature that the depositor needs to provide has the following design issues:  1. When Alice wants to deposit 100 wei ERC20 token from Optimism to Bob on mainnet, she has to sign EIP712 hash of Consent(Bob, 100, \"\"). However, the same signature she has to provide if Alice wants to deposit 100 ERC20 token from Polygon to Bob. This signature does not contain any  information  about  origin  domain.  Only  address  of  ConsentVerification  contract  on  the destination chain is taken into account.  2. Only EOA addresses are able to sign data. Multisig wallets or any other smart contract addresses won't be able to provide a consent signature. This limits potential integrations of SRG with the other systems  3. Consent itself is redundant. Both ERC20Gateway and savETHGateway allow only deposits when msg.sender == ownerGivingConsent. Thus, only Alice will be able to insert the deposit leaf into Accumulator. Check that deposit is inserted into the Accumulator tree can be seen as an \"Alice wanted to transfer funds to Bob\" check. In addition, deposit leaf insertion contains more information and thus is a stronger constraint.  4. CONSENT_TYPEHASH violates the EIP712 specification. The type of a struct must be encoded as name || \"(\" || member_1 || \",\" || member_2 || \",\" || \u2026 || member_n \")\" where each member is written as type || \" \" || name. The CONSENT_TYPEHASH doesn't have member names.  Blockswap - SRG -   15  DesignCorrectnessCriticalHighMediumAcknowledgedLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedDesignMediumVersion1Acknowledged          \f5. ConsentVerification.computeTypedStructHash  violates  the  EIP712  specification.  Each  encoded member value must be exactly 32-byte long. abi.encodePacked will encode address _paramOne as 20-byte long.  Acknowledged:  Blockswap responded:  We will be addressing these as part of the transportation layer upgrade we mentioned in the call  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "5.2   Finalization of Extension Can Stuck", "body": "  Once  deposit  or  pokeLatestBalance  functions  get  called,  they  need  to  be  finalized  on  the destination  domain,  using  push  and  balanceIncrease  functions.  However,  this  second  call  can  be \"stuck\".  The  SRG  system  does  not  offer  users  any  way  to  recover  stuck  funds.  Some  reasons  can  be user  mistakes,  e.g.  user  deposited  to  addresses  nobody  has  control  over  on  their  destination  domain. However, more serious are issues where origin domain functions do not perform strict enough verification of the parameters.  For example:  1. Consent verification relies on OZ library that enforces s-value of v,r,s tuple to be in the lower range of  secp256k1n  curve.  In  general,  ecrecover  percompile  supports  both  high  and  low  s-value signatures. During the deposit function call, only the v-values are constrained.  2. If batch staking rule constant is misconfigured, a check on deposit might be satisfied, while during  the push the amountExtended value can be too small.  Acknowledged:  Blockswap responded:  Users should always be able to verify their transactions before signing to ensure funds are not locked much like when interacting with a single blockchain and ensuring things like recipient are correct etc.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "5.3   Missing Status by", "body": " EndorserLifecycleStatusUpdated  When  the  event  EndorserLifecycleStatusUpdated  gets  emitted,  it  just  indicates  the  status  of  a given endorser has been updated, without containing any further information about its current status. As a better practice, the current status of the endorser can be embodied in this event.  Acknowledged:  Blockswap responded:  Indexers can read the state of the contract at the time of event emission. We will address this later  Blockswap - SRG -   16  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                  \f5.4   Pausing and Unpausing Emit Misleading Events  Some functions, which perform the state transitions of the Gateway contract do not check, whether the contract is already in the needed state:   pauseGateway   unpauseGateway   pauseDomain   unpauseDomain  As a result, repeated calls to these functions will have no effects on the state but will trigger an event. Some of these functions also do not check, whether the killswitch was triggered for this domain. Thus, pauseGateway after triggerKillSwitch can be called.  Acknowledged:  Blockswap has acknowledged the issue without fixing it, responding:  We are ok with this. contract storage should always be checked for the source of truth  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "5.5   RPBS _isOnCurve Infinity Point", "body": "  Most  of  the  bn128  libraries  consider  that  the  infinity  point  belongs  to  the  curve.  The  _isOnCurve function does not.  Reference:   Ethereum   Clearmatic bn256  Acknowledged:  Blockswap  has  acknowledged  that  their  implementation  does  not  follow  the  implementation  of  bn128. Blockswap responded:  We will be addressing these as part of the transportation layer upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "5.6   Repeated Pokes", "body": "  For  a  single  pokeLatestBalance  action,  the  balanceIncrease  finalization  can  be  done  multiple times.  Only  the  first  balanceIncrease  will  have  an  effect.  All  other  calls  will  result  in  no  balance update, however, the poke leaf will still be inserted in the Accumulator. In theory, an attacker can spam this transaction to deplete all the leaves in the Merkle tree.  Acknowledged:  Blockswap - SRG -   17  DesignLowVersion1AcknowledgedCorrectnessLowVersion1AcknowledgedDesignLowVersion1Acknowledged                      \fBlockswap responded:  We will add a spam mitigation strategy later.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "5.7   saveETHManager.init Is Not Defined in", "body": " ISavETHManager  In StakeHouseUniverseDestinationGateway.init an ERC1967 Proxy gets deployed for the logic contract  _saveETHManagerLogic.  However,  when  encoding  _data  input  field  for  the  constructor  of ERC1967, it assumes  1. init function is implemented for savETHManager, although not defined in ISavETHManager  2. init   savETHManager  savETHDestinationReporter.init, which might be invalid assumption.  function   exact   has   the   of   same   layout   as  These assumptions can be wrong.  Acknowledged:  Blockswap has acknowledged it, claiming that calling this function from external users is not encouraged.  Blockswap - SRG -   18  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Cost of bytesToHex    ERC20 Token Decimals   Inconsistent DepositEvent Amount Units    batchDeposit Reverts if the Lengths of Input Arrays Match   -Severity Findings   EIP165 Interface Implementation Check Is Not Fully Correct    Sandwich Attack Without MEV Services    Deployed Event of Gateway Is Not Informative    whenGatewayAndPushNotKilled Specification Mistmatch    dETH Dispensers Are Not a IsavETHDispenser   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.1   Cost of bytesToHex", "body": "  0  0  4  5  The bytesToHex is used to convert bytes to hex string. The only reason for this is to be compliant with the elliptic-js library. The bytesToHex is an extremely inefficient on-chain. Such conversions on-chain are  strongly  discouraged.  They  are  computationally  expensive  and  may  lead  to  gas  exhaustion.  This does not pose a direct security risk, but it lowers the overall usability and scalability of the contract.    The RPBS-sol package now operates with the bytes representation directly, without conversion to hex. The  new  function  encodePoint  is  used  in  the  assessed  contracts  instead  of  encodePointHex function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.2   ERC20 Token Decimals", "body": "  The  GatewayToken  contract  inherits  from  ERC20Upgradeable  fixed  decimals  of  18.  In  general,  this might be not the same as the original token decimals. As a result, this might break UIs that will deal with such bridged tokens. Also, protocols that rely on decimals might have problems with compatibility.  Blockswap - SRG -   19  CriticalHighMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                 \f  The GatewayToken.decimals now returns a variable that can be set in the init function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.3   Inconsistent DepositEvent Amount Units", "body": "  The  ERC20Gateway.deposit  function  users  provide  the  amount  of  tokens  to  extend  as  a BaseInputParams.paramTwo in wei. This param in wei will contribute to the deposit leaf hash. Same paramTwo  in  wei  will  be  emitted  in  DepositEvent.  On  the  destination  domain  recipient  will  need  to specify the same paramTwo in _depositMetadata.baseDepositInfo.paramTwo.  However, this is not consistent with savETHGateway. In savETHGateway.deposit the user provides the KNOT that he wants to migrate. The savETHRegistry.knotDETHBalanceInIndex in gwei of this KNOT will contribute to the deposit leaf hash. But the knotDETHBalanceInIndex in wei will be emitted in Deposit tx. On push, _depositMetadata.amount in gwei will be converted to wei and the savETH on the destination domain will be minted. In summary, inconsistency is that units of event do not match the  value  from  _depositMetadata.amount  and  the  deposit  leaf  hash.  Assuming  that  the  endorsers will be querying the depositMetadata for the attestation, an extra conversion of deposit event values will be needed for one of these cases to compute the hash of the RPBS info.    Blockswap  has  successfully  resolved  this  inconsistency  in  various  parts  of  the  codebase  (both dispensers and ingestors).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.4   batchDeposit Reverts if the Lengths of Input", "body": " Arrays Match  To  batch  deposit  a  set  of  transactions  to  their  corresponding  domains  given  suitable  input  params  for each deposit, the input arrays should have the same length. However, in the implementation:  uint256 numOfElements = _transactionSummaries.length; if (numOfElements == 0) revert EmptyArray(); if (numOfElements == _domainIds.length) revert InconsistentArrayLengths(); if (numOfElements == _baseParams.length) revert InconsistentArrayLengths();  Which  means  a  correctly  formed  input  will  not  be  handled.  The  functionality  of  all  functions  must  be tested before deployment.    Conditions were fixed. Now all 3 input arrays of the batchDeposit function required to be of the same length.  Blockswap - SRG -   20  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                  \f6.5   EIP165 Interface Implementation Check Is Not Fully Correct  According to eip-165, to detect that contract implements ERC-165, the source contract needs to make 2 calls.  First  call  -  to  check  that  IERC165  is  supported.  Second  call  -  to  check  that  the  invalid  interface 0xffffffff is not supported.  However,  the  Gateway._assertModuleAdheresToERC165Interface  function  only  performs  the first call.  Source: https://eips.ethereum.org/EIPS/eip-165#how-to-detect-if-a-contract-implements-erc-165    A  check  has  been  added  to  ensure  that  a  module  supporting  IERC165  does  not  support  an  invalid interface.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.6   Sandwich Attack Without MEV Services", "body": "  The savETHRegistry has the following arbitrage opportunity, that bots can profit from: if a bot sees fees being to a KNOT, that belongs to an open index, a bot can sandwich this mintDETHReserves function call by 2 transactions: isolateKnotFromOpenIndex and addKnotToOpenIndex. This way, bot will get ownership of the KNOT that will have fees minted. As a result, the savETH rate won't increase. To execute  this  sandwich  attack  on  the  mainnet,  the  bot  needs  access  to  MEV  service.  However,  on  the destination domains, with the help of the poke function bots can steal fees from the open index without such  services.  The  bot  just  needs  to  have  a  smart  contract  that  sandwiches  balanceIncrease  the same  way  as  mintDETHReserves.  Since  balanceIncrease  in  a  mintDETHReserves  on  a destination domain without access control, this is possible.  Specification corrected:  Users,  who  put  the  KNOT  into  an  open  index  voluntarily,  accept  the  lower  fees  (potentially  0).  In exchange, they get liquid assets that can be traded. Any actor is encouraged to perform balance updates (such as mintDETHReserves). The MEV sandwich described in this issue is seen as an arbitrage from that perspective. Hence, no fixes are needed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.7   Deployed Event of Gateway Is Not Informative", "body": "  After initialization of a gateway through __Gateway_init, a mere event Deployed is emitted without any arguments. This event does not contain any parameters. Since it is used in the proxy initialization, this event increases the bytecode size of the deployed contract.  Specification corrected:  Blockswap responded:  Blockswap - SRG -   21  CorrectnessLowVersion2CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1Speci\ufb01cationChanged                      \fAfter  an  event  is  emitted,  all  contract  states  can  be  read  directly  from  a  node  saving  deployment costs from not emitting data in events.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.8   whenGatewayAndPushNotKilled", "body": " Specification Mistmatch  As the name of the modifier suggests, not only should the gateway be operational, but also push for the foreign domain should not be killed. However, this modifier performs the following checks:  if (!domainMetadata.operational && isPushKilled[_domainId]) revert DomainOperationsArePausedOrKilled();  It  means  the  scenarios,  in  which  either  domain  is  not  operational  or  is  killed,  the  modifier  reverts.  To make it comply with the specification, an OR operator instead of AND should be used.    the  ||  The  &&  operator  was  the whenGatewayAndPushNotKilled will not revert only when the domain is operational and push is not killed on the domain.  if  condition  above.  Now   replaced  by   the   in   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.9   dETH Dispensers Are Not a IsavETHDispenser", "body": "  The savETHGateway uses IsavETHDispenser to communicate with dETHDestinationDispenser and dETHOriginDispenser. However those contracts do not implement the aforementioned interface. Change of the code can break compliance with the interface, that will not be reported by the compiler.    dETHDestinationDispenser  and  dETHOriginDispenser  contracts  now  IsavETHDispenser interface.  implement   the  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "6.10   RPBS Endorsement Expiry", "body": "  Function  verify  in  RPBSVerificationLibrary  fetches  the  first  endorsement  and  verifies  that  it  is not expired require(signatureExpiry > block.timestamp, \"Signature expired\"). Then, it iterates over the array of endorsements and checks that all of them have the same expiry time as the first endorsement. Though correct, it obliges the endorsers to agree on a common signature expiration. What is the expiration definition procedure and how do endorsers guarantee that this expiration will be the same for all signatures?    In    of the code each Endorser need to specify its own expiry period.  Blockswap - SRG -   22  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrectedVersion3                      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "7.1   Endorser Setting Change", "body": "  First,  the  change  of  the  Endorser  status  from  ACTIVE  to  any  other  status  will  result  in  a  revert  of  the pending push and balanceIncrease transactions if they were endorsed by the deactivated Endorser, while it was still active.  Second,  the  increase  of  the  numberOfEndorsementsRequired  threshold  can  cause  similar  in-flight message failure.  Acknowledged:  Blockswap responded:  As long as the user can re-submit the transaction, then there is no issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "7.2   Gas Optimisation", "body": "  The  codebase  has  several  inefficiencies  in  terms  of  gas  costs  when  deploying  and  executing  smart contracts. Here, we report a list of non-exhaustive possible gas optimizations:  1. The modifier Gateway.whenGatewayAndDomainNotPausedOrKilled loads information about a specific domain Id to the storage and later reads the underlying information from storage, which is quite inefficient.  2. ERC20Gateway._assertConsumptionAuthorised   reverts   msg.sender  !=  _baseParams.ownerGivingConsent.  However,  performed in _consume function, before calling to _assertConsumptionAuthorised.  the  same  check   if is  3. Gateway.injectForeignDomainCheckpoint  checks   the dispenser and then calls into Dispenser.injectForeignDomainCheckpoint which performs the exact same check.  that  recovery   is  enabled   for   4. Gateway.batchDeposit iterates through every deposit in a list and calls to Gateway.deposit which  solely  calls  into  Gateway._consume.  By  calling  _consume  directly  from  batchDeposit gas can be saved.  5. Once  Gateway.batchDeposit  directly  calls  to  _consume,  the  visibility  of  Gateway.deposit  can also be changed to external.  6. Gateway._dispense, in case of recovery not being enabled, performs a multitude of checks (e.g. validating  consent  signature,  asserting  dispense  being  authorized,  and  finally  dispensing  in  the dispenser module). After all of these gas expensive operations, it checks whether UTXO is already spent  or  not.  In  case  of  an  attempt  to  use  spent  UTXO  the  revert  will  happen  late  in  execution. Moving this check earlier would consume less gas in this scenario.  Blockswap - SRG -   23  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged          \f7. Gateway._dispense, in case of recovery being enabled, checks that a non-zero recovery Merkle root  has  been  injected.  Later,  it  calls  to  dispenseViaRecovery  of  the  dispenser,  which  again assures that the recovery Merkle root is injected.  8. Domain.dispense, checks isRecoveryEnabled, however, Gateway will only call this function if it  is not set.  9. ConsentVerification.validateConsentSignature  is  defined  as  public  but  never  used  internally. Its visibility can be changed to external to save gas.  10. Both   functions   and _onlyValidStakeHouseKnot  in  savETHRegistryDestinationGateway  have  the  exact same functionality, only with different naming. It makes bytecode of the contract larger; hence, the deployment costs would be more expensive.  _onlyStakeHouseKnotThatHasNotRageQuit   11. Gateway.deposit can increase userConsentNonce without the use of the safemath.  12. The  fields  in  the  Domain  struct  from  the  IGateway  can  be  benefit  from  tight  variable  packing  patterns.  13. The  balanceIncrease  function  checks  that  accumulator  of  the  the  domain  is  not  0.  The  same check is performed in the whenGatewayAndDomainNotPausedOrKilled modifier of the same function.  14. Many functions of the savETHGateway query saveETHRegistry from the universe multiple times  in the same function.  Acknowledged:  Blockswap will consider these optimizations later and apply changes when needed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "7.3   Hash Function Consideration", "body": "  The SRG uses sha256 function in multiple places. For example, in the Accumulator Merkle tree contract and for computation of certain constants like DEPOSIT_TYPE_HASH. While the original ETH2.0 Beacon staking  contract  uses  the  aforementioned  hash  function,  the  main  reason  for  that  was  an  assumption, that  node  software  will  be  implemented  in  languages  that  do  not  have  well-established  analog  for keccak256 function.  In  EVM  sha256  is  a  precompiled  contract,  and  calling  into  it  is  more  expensive  than  the  opcode keccak256.  sha256  is  twice  more  expensive  than  keccak256  based  on  gas  params.  This  cost difference  also  does  not  include  overhead  for  creating  memory  layout  for  the  STATICCALL  to  the precompiled contract.  Acknowledged:  Blockswap responded to the issue as:  We will look into the optimisations and consider them as and when needed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "7.4   Recovery Merkle Tree Considerations", "body": "  Blockswap - SRG -   24  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged            \fTo enable recovery, a domain must be killed first. Once it will be killed, some state extension messages can stuck in-flight, meaning that the deposit tx happened on one domain, but the push for that deposit did not happen on the other domain. Consider the scenario, in which Alice has issued a deposit on mainnet chain to Bob on the Optimism chain. This extension is in-flight and still not pushed on Optimism. If then Optimism will be killed on Mainnet, this transaction must be considered during the Recovery Merkle Tree computation, even if Bob never pushed this on Optimism.  A similar case happens when Bob has issued a deposit from Optimism to Alice on mainnet chain. If then Optimism will be killed on Mainnet, this transaction must be considered during the Recovery Merkle Tree computation, if Alice did not push this on Mainnet before the recovery activation.  Acknowledged:  Blockswap mentioned in the response Doc, that this is by design.  Blockswap - SRG -   25  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "8.1   Asset Flow per Time Limit", "body": "  The SRG system consists of multiple gateways on different chains. If a certain chain gateway is hacked, e.g.  invalid  state  is  inserted  into  Accumulator,  the  attacker  can  use  connections  between  gateways  to extend the bad state to the other chains. As a result, a system as a whole depends on the security of any of its components. Limits like \"extension of X tokens per day is allowed\" can limit the effect of bad state spread and give time for reactive measures.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "8.2   Checked Properties", "body": "  Certain  invariants  of  Blockswap  SRG  system  were  checked  during  this  assessment  or  explicitly considered:   GatewayToken needs to be deployed with the same decimal value as the original token.   ERC20  Gateway  is  capable  of  handling  simple  ERC20  tokens.  Any  special  tokens  need  to  be  wrapped. Consider this list: https://github.com/d-xo/weird-erc20   Tree leaf of the Recovery Merkle tree should never be made of 64 bytes. Intermediate nodes might become claimable due to the collisions with the total length of leaf components matching the length of  See: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3091  concatenated   hashes.   two    To prevent cross-domain replays any leaf inserted into the accumulator needs to contain origin and  destination chain ids, and origin and destination gateway addresses.   Any kind of leaf that is inserted into Accumulator needs to have a unique prefix like TYPE_HASH to  prevent collisions with other leaf types.   The  total  supply  of  ERC20  tokens  minted  on  some  destination  domain  should  equal  the  totalExtended value of the origin domain on this destination domain.   The  total  supply  of  ERC20  tokens  minted  on  some  destination  domain  should  equal  the  totalExtended value of this destination domain on the origin domain.   Balances  or  KNOTs  deposited  from  the  origin  domain  can  always  be  pushed  on  the  destination  domain, assuming both domains are not paused/killed.  In  case  of  ERC20:  ERC20OriginDispenser  must  be  ERC20DestinationIngestor must be the burner of GatewayToken.  the  minter  of  GatewayToken.  In the case of ERC20: the sum of leaf amounts in the Recovery Merkle tree should always equal the origin's totalExtended value of the recovered domain.  In the case of dETH: the set of leaf KNOTs in the Recovery Merkle tree should always be the same as  KNOTs  that  belong  to  the  destination  index  on  the  origin  domain.  No  leaf  should  contain  the same KNOT twice.  Such invariants need to be considered during future updates.  Blockswap - SRG -   26  NoteVersion1NoteVersion1         \f8.3   Handling ERC20 With Access Control Functionality  Some  ERC20  tokens  can  ban  certain  addresses  from  sending  and  receiving  the  tokens,  e.g.  USDC. Assume a scenario, where Alice deposits USDC tokens from Optimism back to the mainnet. Upon push, the receiver of USDC on the mainnet chain might be blacklisted. In this scenario, Alice's tokens will be locked and the push transaction will revert.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "8.4   Restrictive Partially Blind Signatures (RPBS)", "body": " Do Not Contain Unknown Blind Data  The  blinded  message  of  RPBS  contains  only  the  Merkle  tree  proof.  However,  the  common  RPBS  info contains  depositLeafIndex,  gatewayRoot  and  accumulatorCount.  Endorsers  even  without  knowing  the actual data in a blinded message, in the current version of the code Endorsers can recompute the proof themself. This can potentially be used by Endorsers to censor the depositor. In addition, RPBS schema does  not  bring  any  benefit  compared  to  more  simple  ECDSA  signatures.  Effectively  no  blinding  is happening.  Assuming RPBS schema will be used in future versions of the systems, where the blinded data will be used, developers must be careful with what is being blinded.  If the entropy of the blinded data is not great, e.g. the deposit leaf index is blinded, the Endorsers still can randomly guess what data is being blinded. For example with the deposit leaf index - not many indexes can potentially be pending. A source of entropy can be included in the blinded message, which will make guessing impossible.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "8.5   knotDETHBalanceInIndex Change Will Revert", "body": " Pending Transaction  The  txSummary  of  the  savETHGateway  deposit  should  include  the  knotDETHBalanceInIndex. However, the change in this value can cause pending deposits to revert. Such increases can be caused by mintDETHReserves and balanceIncrease function calls. Please note that balanceIncrease is an  unrestricted  function.  Since  the  events  of  balance  increase  are  assumed  not  to  be  frequent,  the likelihood of this problem is small.  Blockswap - SRG -   27  NoteVersion1NoteVersion1NoteVersion1            \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/blockswap-srg-state-replication-gateway/"}, {"title": "5.1   Gain Exceeds Max_Debt", "body": "  In contract VaultV3, any strategy gains upon process_report() will be reported by increasing the strategy's  current_debt  and  the  vault's  total_debt  regardless  of  the  strategy's  max_debt parameter. In this case, the debt of a strategy can exceed its upper bound.  CS-YVV3-001  Acknowledged:  Yearn states:  This is deemed acceptable if caused by profits. Since debt can be lowered at any time after by the DEBT_MANAGER.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "5.2   Reentrancy and process_report()", "body": "  CS-YVV3-002  process_report()  to IAccountant(accountant).report(). Note that these are trusted roles, however, if the accountant can dispatch a call from the (FORCE_)REVOKE_STRATEGY_MANAGER role, a strategy could be revoked during the process of reporting it, which breaks the correct execution flow.  the  Vault   functions   external   reenter   can   call   the   of   in   Yearn - V3 Vaults -   11  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedRiskAcceptedCorrectnessLowVersion1AcknowledgedSecurityLowVersion1RiskAccepted                   \fFurthermore,  similarly  a  strategy  may  enter  into  proces_report()  while  an  update  of  its  debt  is  in process  (update_debt()).  Roles  are  trusted  to  not  misbehave,  the  smart  contract  implementation however does not prevent this scenario.  Risk accepted:  Yearn states:  Reentrancy was intentionally left off process_report() so that an accountant can reenter \u2018deposit\u2019 if need be to issue refunds. It is expected that the accountant never be set to a role other than accountant. And be given no other permissions.  Yearn - V3 Vaults -   12    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Disproportional Unrealized Loss on Redemption   Inconsistent Debt Accounting on Withdrawal From Strategies   -Severity Findings   Add Self as a Strategy   Incorrect Return Type of Decimals   Incorrect Return Value   Incorrect and Missing Specification    Missing Event upon Role Change    Non ERC-4626 Compliant Functions    Unchecked Profit Max Unlock Time    Unprotected Sweep Function   0  0  2  8  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.1   Disproportional Unrealized Loss on", "body": " Redemption  If total_idle is insufficient to fulfill a user's withdrawal, _redeem() attempts to retrieve assets from the  strategies  a  user  defined  or  overridden  by  the  queue_manager.  Should  a  queried  strategy  have unrealized loss, the user will take part of the unrealized loss. However, the user may take the loss in a disproportional way as shown in the code.   First, the user's share of the unrealized loss is computed based on assets_to_withdraw.   Afterwards, assets_to_withdraw is capped by its upper bound.  CS-YVV3-014  Yearn - V3 Vaults -   13  CriticalHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected            \funrealised_losses_share: uint256 = self._assess_share_of_unrealised_losses(strategy, assets_to_withdraw) if unrealised_losses_share > 0:     # User now \"needs\" less assets to be unlocked (as he took some as losses)     assets_to_withdraw -= unrealised_losses_share     requested_assets -= unrealised_losses_share     # NOTE: done here instead of waiting for regular update of these values because it's a rare case     # (so we can save minor amounts of gas)     assets_needed -= unrealised_losses_share     curr_total_debt -= unrealised_losses_share  # After losses are taken, vault asks what is the max amount to withdraw assets_to_withdraw = min(assets_to_withdraw, min(self.strategies[strategy].current_debt, IStrategy(strategy).maxWithdraw(self)))  If  assets_to_withdraw  is  restricted  to  strategy.maxWithdraw(self),  the  user  will  cover  more than his proportional share of the loss. In addition, the updated current_debt of this strategy as well as the  vault's  total  debt  will  diverge  from  the  real  debt  because  unrealised_losses_share  has  been overestimated.  current_debt: uint256 = self.strategies[strategy].current_debt new_debt: uint256 = current_debt - (assets_to_withdraw + unrealised_losses_share)  # Update strategies storage self.strategies[strategy].current_debt = new_debt    When  max_withdraw  is  the  limiting  factor  for  assets_to_withdraw,  the  unrealised  loss  the  user takes is now adjusted proportionally. As a result, the user no longer bears more than their fair share of the loss, and the update to current_debt is done using the correct value.  # If max withdraw is limiting the amount to pull, we need to adjust the portion of # the unrealized loss the user should take. if max_withdraw < assets_to_withdraw - unrealised_losses_share:     # How much would we want to withdraw     wanted: uint256 = assets_to_withdraw - unrealised_losses_share     # Get the proportion of unrealised comparing what we want vs. what we can get     unrealised_losses_share = unrealised_losses_share * max_withdraw / wanted     # Adjust assets_to_withdraw so all future calcultations work correctly     assets_to_withdraw = max_withdraw + unrealised_losses_share  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.2   Inconsistent Debt Accounting on Withdrawal", "body": " From Strategies  If total_idle is insufficient to fulfill the redemption, _redeem() attempts to retrieve assets from the strategies.  Should  a  queried  strategy  have  an  unrealized  loss,  the  user  has  to  take  a  part  of  this  loss, which  is  regarded  as  realized  and  deducted  from  curr_total_debt.  At  the  end  of  the  loop, self.total_debt is updated to curr_total_debt.  # CHECK FOR UNREALISED LOSSES # If unrealised losses > 0, then the user will take the proportional share and realise it # (required to avoid users withdrawing from lossy strategies) # NOTE: assets_to_withdraw will be capped to strategy's current_debt within the function # NOTE: strategies need to manage the fact that realising part of the loss can mean the realisation of 100% of the loss !!  CS-YVV3-006  Yearn - V3 Vaults -   14  CorrectnessMediumVersion1CodeCorrected        \f#  (i.e. if for withdrawing 10% of the strategy it needs to unwind the whole position, generated losses might be bigger) unrealised_losses_share: uint256 = self._assess_share_of_unrealised_losses(strategy, assets_to_withdraw) if unrealised_losses_share > 0:         # User now \"needs\" less assets to be unlocked (as he took some as losses)         assets_to_withdraw -= unrealised_losses_share         requested_assets -= unrealised_losses_share         # NOTE: done here instead of waiting for regular update of these values because it's a         # rare case (so we can save minor amounts of gas)         assets_needed -= unrealised_losses_share         curr_total_debt -= unrealised_losses_share  # After losses are taken, vault asks what is the max amount to withdraw assets_to_withdraw = min(assets_to_withdraw, min(self.strategies[strategy].current_debt, IStrategy(strategy).maxWithdraw(self)))  # continue to next strategy if nothing to withdraw if assets_to_withdraw == 0:     continue  However, in case the strategy with unrealized loss reports 0 on maxWithdraw(), it will jump to the next iteration  debt code  which  (strategies.current_debt).  Consequently,  the  sum  of  all  strategies.current_debt  will exceed self.total_debt and result in an accounting inconsistency.  strategy-specific   following   updates   skip   and   the   the   current_debt: uint256 = self.strategies[strategy].current_debt new_debt: uint256 = current_debt - (assets_to_withdraw + unrealised_losses_share)  # Update strategies storage self.strategies[strategy].current_debt = new_debt # Log the debt update log DebtUpdated(strategy, current_debt, new_debt)    The updated code ensures accurate accounting before proceeding to the next loop iteration when it is not possible to withdraw funds from a strategy:  1. If funds are simply locked, the users share of the loss to cover is zero and all accounting is correct.  2. If the strategy has a complete loss, the user realiszes this loss and the strategies debt is updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.3   Add Self as a Strategy", "body": "  The vault should not add itself as a strategy. Otherwise, update_debt will revert when funds are to be deposited into the strategy, as the recipient of the shares cannot be the vault itself.  CS-YVV3-012    In the updated code it is no longer possible to add the vault itself as a strategy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.4   Incorrect Return Type of Decimals", "body": "  decimals() of contract VaultV3 returns an uint256 which does not comply with the ERC20 standard where an uint8 is returned.  CS-YVV3-009  Yearn - V3 Vaults -   15  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f  The type of the return value has been changed to uint8 which is compliant with the specification.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.5   Incorrect Return Value", "body": "  CS-YVV3-011  mint()  returns  the  calculated  amount  of  assets  to  deposit,  instead  of  the  actual  amount  of  assets into  assets  equal  max(uint256), deposited.  self._deposit()  considers  this  a  \"magic  value\"  and  will  only  deposit  the  user's  balance.  mint() however will return max(uint256) and not the actual amount of assets deposited.  If  a  user  mints  shares  which  converted   The  same  issue  exists  for  withdraw()  when  the  amount  of  assets  converted  to  shares  equals max(uint256).  The possibility of these scenarios depends on the exchange rate between shares and assets. The caller might rely on the returned values for further calculations or decision-making processes, which could lead to unintended consequences due to the discrepancy in the returned and actual deposited or withdrawn assets.    Yearn has removed the ability to pass MAX_UINT as a \"magic value\" to use the full balance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.6   Incorrect and Missing Specification", "body": "  In contract VaultV3, mint() returns the amount of assets deposited instead of shares according to its specification. In addition, the specifications of withdraw() and redeem() are missing.  CS-YVV3-010  Specification changed:  The  specification  of  mint()  has  been  corrected.  Specification  has  been  added  for  withdraw()  and redeem().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.7   Missing Event upon Role Change", "body": "  In  contrast  to  other  sections  of  the  code,  role  management  functions  (with  the  exception  of accept_role_manager)  do  not  emit  events  upon  these  important  state  changes.  Emitting  events would enable external parties to observe these important state changes more easily.  CS-YVV3-013  Yearn - V3 Vaults -   16  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \f  Events  have  been  added  to  set_role(),  set_open_role()  and  close_open_role().  Note  that transfer_role_manager() does not emit an event, an event is emitted upon the completion of the role transfer in accept_role_manager() only.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.8   Non ERC-4626 Compliant Functions", "body": "  In case the vault is in shutdown mode, no further deposit can be made. However, maxDeposit() does not return 0 when the vault is shutdown.  The ERC-4626 specification however requires the function to return 0 in this case:  CS-YVV3-007  ... if deposits are entirely disabled (even temporarily) it MUST return 0.  In addition, maxWithdraw() assumes a full withdrawal is possible if queue_manager is set regardless of the unrealized loss. This conflicts with the specification which reads:  MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary)  Besides, convertToShares() does not distinguish the following cases when total_assets is 0:   This is the first deposit where price per share is 1.   The vault is dead where there are shares remaining but no assets. The price per share is 0 because  further deposit would revert in _issue_shares_for_amount.  This  would  be  misleading  convertToShares() but fail on deposit().  for  external  contracts   to  see  a  non-zero  value  when  using  More  informational,  the  ERC-4626  specification  is  loosely  defined  in  these  corner  cases  for  these functions. Nevertheless we want to highlight the potentially unexpected amounts returned:  previewRedeem(): In case totalAssets is zero, the conversion is done at a 1:1 ratio. At this point either no shares exist (I) or the value of the existing shares has been diluted to 0 (II). For (I) the returned value  of  0  is  appropriate.  For  (II)  previewRedeem()  does  not  revert  while  redeem()  reverts;  the specification reads:  MAY revert due to other conditions that would also cause redeem to revert.  previewWithdraw()  returns  the  amount  in  a  1:1  exchange  rate  when  assets==0  but  shares!=0. Again for non-zero values the amount returned may be misleading.  Strictly  speaking  the  value  returned  is  not  breaking  the  specification  but  might  be  unexpected  by  the caller.  The  caller  should  be  aware  of  this  and  any  external  system  should  exercise  caution  when integrating with these functions.  The full specification can be found here: https://eips.ethereum.org/EIPS/eip-4626    The  code  has  been  changed  so  that  the  deposit  limit  is  set  to  0  when  the  vault  is  shutdown,  thus maxDeposit() would return 0 in this case. convertToShares() has been adjusted to distinguish the case  when  the  vault  is  dead.  The  potentially  misleading  return  value  of  previewWithdraw()  is acknowledged.  Yearn - V3 Vaults -   17  CorrectnessLowVersion1CodeCorrected        \fYearn also acknowledged the risk of maxWithdraw() and states:  It is deemed acceptable for maxWithdraw() to not take into account unrealized losses. Since this would be very gas intensive for a function potentially used on chain, and is not possible to accurately account for vaults that allow custom withdraw queues.  The  external  system  is  expected  to  exercise  caution  with  the  features  of  this  contract  during  their integration.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.9   Unchecked Profit Max Unlock Time", "body": "  In  contract  VaultV3,  profit_max_unlock_time  is  not  checked  at  initialization.  A  faulty  value  may lead  to  unexpected  behaviors.  In  case  profit_max_unlock_time==0,  the  profit  of  the  vault  will  be locked forever. In case profit_max_unlock_time is too large, the weighted average computation of new_profit_locking_period may revert, which blocks process_report() as a consequence.  CS-YVV3-015    profit_max_unlock_time  is  now  checked  in  the  vault  constructor  and  setter  ensuring  that  it  is greater than 0 and less than 1 year.  # Must be > 0 so we can unlock shares assert profit_max_unlock_time > 0 # dev: profit unlock time too low # Must be less than one year for report cycles assert profit_max_unlock_time <= 31_556_952 # dev: profit unlock time too long  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "6.10   Unprotected Sweep Function", "body": "  sweep()  is  not  protected  by  the  reentrancy  guard.  If  trusted  roles  misbehave  it's  possible  to  sweep assets  of  the  vault  at  a  time  when  the  value  of  total_idle  is  stale.  No  direct  issue  has  been uncovered, however this permits excessive access which may introduce unnecessary risks.  CS-YVV3-008  deposit(),   In  of by  erc20_safe_transfer_from() only if the weird underlying token calls back to the sender after transferring the token.  sweep()   reenter   calling   could   hook   one   the   in    Another case is that a strategy reenters sweep() when update_debt() calls withdraw() on the strategy.  As  the  balance  withdrawn  is  determined  based  on  the  delta  of  the  actual  balance,  this shouldn't have any negative impact, apart from potentially spurious events.    A guard has been added for extra safety.  Yearn - V3 Vaults -   18  DesignLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                 \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "7.1   Loose Token Decimal Restriction", "body": "  The  vault's  share  token  has  the  same  token  decimal  as  the  underlying  token.  The  underlying  token decimal is restricted (<= 38) in the VaultV3 constructor.  Token decimals are only for user representation and front-end interfaces. At the smart contract level, all balances  maintain  token  decimal  precision.  Overflows  could  potentially  occur  if  a  token  permits sufficiently large balances, leading to an overflow when these balances are multiplied. Importantly, this issue is unrelated to decimals, so the check in the constructor cannot prevent it.  Note  that  we  are  not  aware  of  any  meaningful  token  with  this  behavior,  this  is  more  a  theoretical consideration.  CS-YVV3-003  Yearn  understand  that  overflows  are  still  possible  no  matter  the  token  decimal  value  used.  The  check was updated, it now only ensures that the decimal value does not exceed an uint8. Legitimate vaults with a normal underlying token will not trigger any overflows.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "7.2   Updating Queue_Manager", "body": "  CS-YVV3-004  The  queue_manager  smart  contract  defines  the  withdrawal  sequence  for  a  vault.  Whenever  a  new calling informs  strategy  queue_manager.new_strategy(address strategy).  queue_manager   added,   vault   the   the   by   is   The  queue  manager  for  the  vault  can  be  updated  using  set_queue_manager().  Note  that  the  new queue manager is not informed about all existing strategies of the vault; in this case the queue manager must be configured correctly manually.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "7.3   yv<Asset_Symbol> Not Enforced", "body": "  The  system  specification  requires  the  shares  to  be  named  yv<Asset_Symbol>.  Note  that  this  isn't enforced by the code, the share name can be freely defined when deploying a new Vault.  CS-YVV3-005  Yearn - V3 Vaults -   19  InformationalVersion1InformationalVersion1InformationalVersion1          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.1   Debt Rebalanced in a Linear Way", "body": "  During update_debt(), if the target debt value cannot be reached given the vault and strategy specific limitations on the idle and debt, it will not revert. Instead, it will rebalance the debt to the closest value towards  the  target.  This  behavior  assumes  it  is  always  better  to  be  closer  to  the  target.  However,  the assumption may not always be true for different strategies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.2   No User Protection on Shares Redemption", "body": "  If during redemption funds must be pulled from a strategy at a loss, the user must cover his share of this not  yet  realized  loss.  Additionally,  in  case  the  call  to  strategy.withdraw()  results  in  less  than  the requested assets, the user takes the full loss.  Unaware  users  may  redeem  their  shares  for  less  of  the  underlying  than  they  expect.  There  is  no protection e.g. in form of a parameter which allows the user to specify the minimum amount of underlying to receive / shares to be burned he tolerates before the transaction should revert.  Yearn states:  It is expected that off chain users interact with the vaults through an ERC-4626 router which has logic to set minimums and slippage tolerance for deposits and withdrawals. And on chain users can either use the router or set their own limits.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.3   Queue Manager Can Pause Withdrawals From", "body": " Strategies  A faulty or malicious queue_manager with should_override enabled can pause users' withdrawals from  strategies  by:  (1)  directly  revert.  (2)  return  a  non-existing  strategy.  queue_manager  must  be properly configured and trusted if enabled.    the  should_override  option  has  been  removed  so  users  can  always  bypass  the In  queue_manager  if  a  customized  withdraw  queue  is  specified.  Otherwise,  the  withdraw  queue  will  be queried from the queue_manager.  Yearn - V3 Vaults -   20  NoteVersion1NoteVersion1NoteVersion1Version2          \fif queue_manager != empty(address):     if len(_strategies) == 0:         _strategies = IQueueManager(queue_manager).withdraw_queue(self)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.4   Race Condition on Withdrawal From", "body": " Strategies  If total_idle is insufficient to fulfill the redemption, _redeem() attempts to retrieve assets from the strategies. Should a queried strategy have unrealized loss, the user has to take a part of this loss. In case the vault has global unrealized loss, users may engage in a race to withdraw from the optimal strategies.  In  case  the  queue_manager  is  disabled,  users  will  race  to  withdraw  from  the  strategies  without unrealized loss. As a consequence, the tardy users will take more unrealized loss.  In case the queue_manager is enabled, withdrawals may be biased across all strategies depending on the actual construction of the withdraw_queue.  Users  will  only  share  the  unrealized  loss  of  a  strategy  in  a  fair  way  if  it  is  reported  by  the REPORTING_MANAGER.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.5   Tokens With a Blacklist", "body": "  Tokens such as USDC maintain a blacklist that prohibits the transfer of tokens to and from the addresses listed  on  it.  Assuming  a  vault  utilizes  such  a  token,  a  blacklisted  address  would  be  unable  to  be  the recipient when funds are withdrawn. If a strategy is blacklisted, withdrawal of allocated funds would be impossible.  Furthermore,  if  a  vault  itself  is  blacklisted,  the  withdrawal  of  all  deposited  funds  would  be prevented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.6   Trade-off in Profits Distribution", "body": "  All profits getting paid to vault depositors are retroactive:   New joiners of a vault will share part of the locked profits accumulated before they entered.   The locked profits generated by their deposits will be forfeited upon their withdrawals.  This is a trade-off to improve the gameability and avoid intensive gas to track specific accounts for the time they deposit. As long as the profits are distributed slowly and continuously, no whales are expected to game the system by deposit right before a profit harvest and realize full gains.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "8.7   User-Selected Strategies", "body": "  If no queue manager is configured, when idle funds are insufficient for a withdrawal, users can specify which strategies should be used to retrieve funds.  Yearn - V3 Vaults -   21  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \fThis  could  enable  users  to  substantially  interfere  with  the  planned  allocation  of  assets,  necessitating frequent intervention from the debt_manager.  Yearn - V3 Vaults -   22  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-v3-vaults/"}, {"title": "5.1   No Documentation", "body": "  0  0  0  4  No  documentation  is  available  for  ERC20Pods.  This  abstract  contract  is  intended  to  be  used  by  third parties hence documentation is vital to avoid issues. For authors of pods it must be clearly documented what they have to take into account and what they can rely on, such as:   Failed calls to Pod.updateBalances() are ignored, consequently authors of pods must be aware  of the consequences for their pods   Amount of gas available   When  exactly  the  token  triggers  Pod.updateBalances():  Upon  non-zero  token  transfers  and when the pod is added/removed from an account having non-zero balance. Misunderstandings by a developer of a Pod may lead to correctness issues.  The trust model should be clearly specified, including:   How exactly pods are trusted / untrusted   Whether only trusted parties can add/remove pods to/from an account. If this holds, the docs should  clearly state that a developer extending ERC20Pods must adhere to this  Furthermore  not  all  token  holders,  e.g.  contracts  can  call  addPod()  themselves.  The  documentation may elaborate on this topic, e.g., what can be assumed / what the limitations are.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "5.2   Consistency on Zero Amount Transfers", "body": "  1inch - ERC20 Pods -   10  SecurityDesignCriticalHighMediumLowAcknowledgedRiskAcceptedAcknowledgedSecurityLowVersion1DesignLowVersion1Acknowledged                \fThe ERC20 standard specifies Note Transfers of 0 values MUST be treated as normal t ransfers  and  fire  the  Transfer  event..  For  consistency,  it  may  make  sense  to  inform  the registered pods about 0 balance actions and 0 amount transfers. If this behavior is desired the way it is, it should be mentioned somewhere so that Pod developer are aware that 0 balance or 0 amount transfers are not notified to the Pod.  Acknowledged:  1inch acknowledged the issue and decided to leave the code as it is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "5.3   Side Effects of _updateBalances()", "body": "  While  the  gas  check  prevents  direct  reentrancy  into  the  token  on  functions  changing  the  balance, 200_000 gas is enough to make some other state changes that could affect to-be-updated pods. Notably upon updating the first pod A, this contract may interact with another pod B which is to be updated later in the  sequence  and  hence  does  not  yet  know  about  these  balance  changes  pod  A  currently  executing already is aware of. While we have not uncovered any direct issue, a badly designed or adversarial pod could be problematic. No trust model nor specification covering this scenario is available.  Risk accepted:  1inch is aware of and accepts the risk.    introduced  a  reentrancy  guard.  Note  that  this  can  be  leveraged  by  a  pod  to  detect  such  a scenario  and  revert.  While  the  state  of  the  reentrancy  guard  itself  cannot  be  querried  direcly,  public functions  balanceOf  and  podBalanceOf  now  feature  the  nonReentrant(View)  modifier  and  will revert if called in such a situation. Hence in the scenario described above pod B could call balanceOf() and be protected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "5.4   Zero Address Consistency in AddressArray", "body": "  When querying an index that is out-of-bounds with AddressArray.at, the function does not revert and returns  address(0).  Thus,  it  is  not  possible  to  distinguish  between  an  address(0)  that  would effectively be part of the array, and an out-of-bounds access.  Acknowledged:  1inch  is  aware  of  the  issue  and  states  that  in  the  current  use  case,  no  pod  with  address(0)  can  be added. While this is true in the case of ERC20Pods, it can still be an issue for other contracts using the library.  1inch - ERC20 Pods -   11  SecurityLowVersion1RiskAcceptedVersion2DesignLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   ERC20Pods podsLimit Sanitization    Missing Events    Operations Order on Pod Removal   0  0  0  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "6.1   ERC20Pods podsLimit Sanitization", "body": "  The  podsLimit  in  the  ERC20Pods's  constructor  is  never  sanitized.  If  podsLimit  is  zero,  the functionality  added  by  ERC20Pods  cannot  be  used,  so  it  would  not  make  sense  to  allow  setting podsLimit=0.    The constructor of the ERC20Pods contract now checks that podsLimit is not zero.  Note  that  in  sanitized. Unsuitable values could make the ERC20Pods unusable.    the  constructor  takes  a  second  parameter  podCallGasLimit_  which  is  not  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "6.2   Missing Events", "body": "  Typically, events help track the state of the smart contract. To be able to reconstruct the state offchain, events should be emitted when users add and remove pods.    Two  events  PodAdded  and  PodRemoved  have  been  added  and  are  emitted  whenever  a  pod  is added/removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "6.3   Operations Order on Pod Removal", "body": "  1inch - ERC20 Pods -   12  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fWhen a pod is removed with removePod, it is first removed from the internal address set, and then the balances are updated. But when calling removeAllPods, the balances are updated before the pod is removed  from  the  address  set.  Thus,  there  are  two  different  behaviors  for  the  same  action  and  the potential for inconsistencies arises.    The function removeAllPods now follows the order of removePod by first removing the pod from the address set and then update the balances.  1inch - ERC20 Pods -   13  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "7.1   Failed Call to Pod Is Silent", "body": "  ERC20Pods._updateBalances()  calls  the  pod  with  a  fixed  amount  of  gas.  If  this  call  fails,  the execution nonetheless continues normally in order to not block the ERC20. Users must be aware that a failed call to a pod is silent and will not emit any event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "7.2   Integrations May Break Due to Gas", "body": " Requirements  A  transfer  of  an  ERC20Pods  may  require  significantly  more  gas  than  the  transfer  of  a  normal  ERC20. This especially applies when sender and receiver are connected to multiple distinct pods. Moreover, the current abstract contract ERC20Pods allows an user to register any arbitrary pod for his address.  In the worst case each of the pods uses the full 200'000 gas available. When sender and receiver have distinct pods this amounts to 2 * podsLimit gas.  Integrations must take this into account in order to avoid running into problems such as, but not limited to:  An example could be a liquidation of a position where in an extreme case multiple different ERC20Pods where each sender/receiver is connected to several pods must be transferred. The liquidation may not be possible due to the gas requirement exceeding the block gas limit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "7.3   Not Exactly _POD_CALL_GAS_LIMIT", "body": " Available  A  Pod  cannot  rely  on  having  exactly  200'000  gas  available  upon  being  called.  While  it  is  taken  into account that a maximum of 63/64 of the remaining gas can be passed to the call, due to the overhead between the check and the call:  if lt(div(mul(gas(), 63), 64), _POD_CALL_GAS_LIMIT) {         mstore(0, exception)         revert(0, 4)     }         pop(call(_POD_CALL_GAS_LIMIT, pod, 0, ptr, 0x64, 0, 0))     }  in a corner case scenario the call may receive slightly less gas.  1inch - ERC20 Pods -   14  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Order of Pods in AddressSet  Users msut be aware that upon pod removal, the order in the pods in the AddressSet may change, so two calls to podAt with index X, with a call to removePod in-between, may not yield the same result.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "7.5   Unaffected Elements of the Output Memory", "body": " Array on AddressArray.get()  providing   function When  AddressArray.get(Data storage self, address[] memory output), users must be aware that if length(self) < output.length(), only the length(self) first elements of output will be overwritten, leaving the remaining elements of output untouched.  memory   output   array   the   an   to   1inch - ERC20 Pods -   15  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/1inch-erc20-pods/"}, {"title": "6.1   Compromised Guardian Can Block the", "body": " Executor  The guardian role has the privilege to cancel queued actions sets before they are executed. Updating the guardian  address  can  only  be  done  through  an  action.  If  the  guardian  account  is  compromised,  it  can always cancel an actions set which tries to update the guardian role to a new address. Effectively, once the guardian address is compromised it can block the Executor indefinitely.  Risk accepted:  Aave replied:  The guardian address is designed to be a multisig or governance executor (never an EOA) so having a compromised guardian is unlikely to happen.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/aave-bridge-executors/"}, {"title": "6.2   Dangerous Delegatecalls", "body": "  Actions  sets  may  include  actions  (calls)  to  be  executed  as  DELEGATECALL  in  the  context  of  the BridgeExecutor. While this allows to aggregate multiple calls governed by code which can adapt to on chain  state,  should  the  called  contract  write  to  storage,  this  would  write  to  the  storage  of  the BridgeExecutor.  Hence  variables  of  the  contract  may  be  overwritten.  This  can  result  in  the  internal  Aave - Bridge Executors -   11  SecurityDesignCriticalHighMediumLowRiskAcceptedRiskAcceptedRiskAcceptedRiskAcceptedSecurityLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \fvariables  being  changed  without  respecting  the  restrictions  enforced  in  their  setter  function,  e.g. updateGracePeriod() and the check for the minimum grace period.  Besides,  a  Delegatecall  is  also  able  to  modify/delete  existing  actions  sets,  insert  arbitrary  new  actions sets or manipulate entries in _queuedActions. The governance must be aware of this danger.  Untrusted code must never be called with DELEGATECALL.  Furthermore,  note  that  the  following  corner  case  exists:  An  action  consisting  of  a  call  to  the BridgeExecutor's executeDelegateCall function technically allows the governance to execute a call as a Delegatecall (with the risks mentioned above) despite the flag withDelegatecalls being set to false.  Risk accepted:  Aave replied:  The Executor contract assumes that any set of transactions that are queued by a successful proposal is legit. Thus, there are no bad actions that the contract can execute since the proposal passes multiple checks by the community, devs, white hats, auditors, etc.  The executeDelegateCall function is designed to be used for executing payload contracts, where a set of actions are described (instead of having multiple encoded calldatas). The governance should check that the delegate call execution does not update or alter any executor contract's state variable.  Apart from that, the correct way of doing a delegate call is through the action set and the execute function, instead of calling directly to executeDelegateCall. The community would detect and raise this concern if applicable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/aave-bridge-executors/"}, {"title": "6.3   Function Signature as String, Unicode", "body": " Charset  An action may contain the function signature as a string. This allows to display the function to be called in a  human  readable  way.  However,  this  can  be  dangerous  as  strings  support  the  unicode  charset  and many  lookalike  characters  of  different  alphabets  exist  in  this  charset.  Hence  users  might  be  tricked  to approve an action which seemingly contains the intended function call, but actually results in a different function  selector.  Given  a  function  selector  consists  of  4  bytes  only,  it  might  be  feasible  to  find  such  a collision.  For  characters,  into  https://util.unicode.org/UnicodeJsps/confusables.jsp?a=setReserveActive  lookalike   insights   more   please   refer   to:  Risk accepted:  Aave replied:  Governance should assess, test and simulate each proposal, checking the outcome of its changes without trusting string function signatures. Having the function signature human-readable is not a way of validating the legitimacy of proposals by any means.  Aave - Bridge Executors -   12  SecurityLowVersion1RiskAccepted          \f6.4   Potential Reentrancy on execute  The function execute is not protected against reentrancy. While the governance is trusted to not create actions sets which reenter into execute() and start executing another actions set, generally speaking an  action  may  reach  untrusted  third-party  code.  This  untrusted  code  may  reenter  the  BridgeExecutor. This would break the atomicity of sets of actions and may result in unexpected executions and states.  Risk accepted:  Aave replied:  The community and governance decide if an action set should execute any other action set of the same executor. The community should asses every governance proposal carefully.  Aave - Bridge Executors -   13  SecurityLowVersion1RiskAccepted      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/aave-bridge-executors/"}, {"title": "7.1   Execution Order of Queued Actions Sets", "body": "  Multiple  queued  actions  sets  which  are  ready  for  execution  may  be  executed  in  an  arbitrary  order.  All actions which depend on a particular execution order must be placed within the same actions set where the  order  of  execution  is  defined.  If  multiple  actions  sets  exist  at  the  same  time,  they  must  be independent of each other.  Moreover,  updating  critical  system  variables  in  one  actions  set  might  change  the  behavior  of  other actions sets. For example, assume _delay is set to one day at the beginning. Actions set A is queued in the BridgeExecutor, A updates _delay to one second. On L1, the governance decides on actions set B. Governance should be careful, depending on whether A is executed before/after actions set B is queued on L2, a different _delay is applied before B can be executed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/aave-bridge-executors/"}, {"title": "7.2   Impact of Rollback, Finality of Actions", "body": "  Especially  regarding  finality,  L2  solutions  based  on  optimistic  rollups  behave  differently  than  L1 Ethereum.  Should a rollback happen due to the discovery of an incorrect tx, this tx and all subsequent tx have to be reexecuted. This impacts the timestamp of the transaction. Most of the times incorrect transaction results are detected immediately and the rollback happens immediately, however in a worst-case scenario the rollback might happen just before the end of the fault proof period. In such cases the timestamp of the transaction changes significantly.  The  BridgeExecutor  heavily  relies  on  the  timestamps,  e.g.  to  determine  whether  an  action  can  be executed or if it already expired. Similarly the execution time is calculated based on the timestamp when queue() is executed. After a rollback the timestamps may have shifted and e.g. a previously executed actions set can no longer be executed as it has expired.  Furthermore,  the  order  of  transactions  after  a  rollback  is  not  guaranteed,  there  may  be  a  change  of sequence between a transaction to execute() or cancel() a pending actions set.  Validating  all  transactions  may  help  to  detect  incorrect  transactions  early,  however  in  a  worst-case scenario  (e.g.  a  bug  in  the  validator  software)  may  not  detect  such  a  wrong  transaction  and  an unexpected fraud proof may be submitted resulting in a rollback.  The  governance  needs  to  be  careful  about  finality  on  L2.  Overall  L2  solutions  are  still  considered  as experimental, interactions must be done with care.  Note that at the time of this review Optimism has not yet implemented fraud proofs while in Arbitrum only whitelisted addresses can create a challenge.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/aave-bridge-executors/"}, {"title": "7.3   Potentially Resurrected ActionsSet", "body": "  Aave - Bridge Executors -   14  NoteVersion1NoteVersion1NoteVersion1          \fAn  actions  set  expires  if  the  _gracePeriod  has  elapsed  since  the  executionTime.  However,  an expired  actions  set  may  resurrect  if  the  _gracePeriod  is  extended  by  the  governance  later  in  the future. Resulting an expired actions set might be executable again.  It  should  be  carefully  thought  about  if  this  suspended  state  should  be  allowed,  especially  as  the guardian can only cancel queued actions set which have not yet expired.  Aave - Bridge Executors -   15  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/aave-bridge-executors/"}, {"title": "6.1   Public Setter Functions Can Be Frontrun", "body": "  The following functions can only be executed once and have no access controls:  1. FxBaseRootTunnel.setFxChildTunnel  2. FxBaseChildTunnel.setFxRootTunnel  3. FxRoot.setFxChild  4. FxChild.setFxRoot  5. FxERC20.initialize  6. FxERC721.initialize  7. FxERC1155.initialize  If  deployment  and  initialization  is  not  done  within  one  transaction  it  would  be  possible  for  a  malicious actor to frontrun the deployer's call to the functions and instead call them with malicious values first. This will cause the deployer's function call to revert.  FxBaseRootTunnel  and  FxBaseChildTunnel  are  to  be  inherited  by  contracts  in  order  to  use  the bridging  functionality  of  the  Fx  Portal.  This  may  lead  to  problems  with  their  deployment.  Implementors should be aware of this behavior, mitigate this and ensure/verify that initialization is done correctly. If their setTunnel functions are frontrun, the contract will need to be redeployed. This can be expensive in terms of gas.  The  Wrapper  contracts  FxRoot  and  FxChild  for  the  interaction  with  the  StateSender  have  already been  deployed  and  initialized  correctly.  If  a  new  instance  of  one  of  these  contracts  is  deployed,  the the  Token  contracts the  deployer  must  verify  FxERC20/ERC721/ERC115  used  the in  initialize() function is called from contracts within the same transactions.  the  examples  minimal  proxy  contracts  are  deployed   functions  are  called  correctly.  For   that   Polygon - Fx Portal -   12  DesignCorrectnessCriticalHighMediumRiskAcceptedCodePartiallyCorrectedLowDesignMediumVersion1RiskAccepted          \fRisk accepted:  Polygon states:  It is a known risk that initialization functions can be frontrun, but this is low-risk since there is no incentive for a malicious actor to do so.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "6.2   Use (Up to Date) Dependencies", "body": "  Several  contracts  present  in  lib  or  tokens  are  copy  &  pasted  from  third  party  repositories.  An exception  to  this  pattern  is  the  SafeERC20  library  which  is  imported  from  a  dependency  listed  in  the package.json  file.  This  pattern  is  generally  preferable.  Note  that  several  of  the  copy  &  pasted dependencies are also from this OpenZeppelin contracts dependency, hence could simply be imported from there.  Package.json  package-lock.json allows to fix specific version.  the  dependencies  and   lists   the   requirements  on   the  version,  while  This allows to effortlessly update to newer versions of these contract which may include bug fixes. Note that  this  must  be  done  with  due  care  as  functionality  could  change.  Once  a  new  version  has  been deemed suitably safe, the new version can be fixed in package-lock.json.  Most copy & pasted contracts are old versions, furthermore the version of the OpenZeppelin dependency is  outdated.  Notably,  the  implementation  of  ERC721  contains  several  changes  reloading  state  after beforeTokenTransfer(), which may have updated this data.  Code partially corrected:  The  dependencies  in  package.json  were  changed  to  more  recent  versions.  ERC20.sol  and IERC20.sol were updated to OpenZeppelin v4.7.3.  The other copy & pasted contracts in lib have not been updated.  Polygon - Fx Portal -   13  DesignMediumVersion1CodePartiallyCorrected          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   mapToken() Callable Only by Mappers   -Severity Findings   Description of toBoolean() Is Incorrect    FxMintableERC20RootTunnel connectedToken Initialized Incorrectly   -Severity Findings   Codehash Variable Type Could Be Set to Immutable    FxMintableERC20ChildTunnel Has No withdrawTo Function    FxMintableERC20RootTunnel Events Missing    Outdated Compiler Version    Return Value of _checkBlockMembershipInCheckpoint()    SafeMath Library Is Redundant    Unused Variable in FxMintableERC20RootTunnel    _processMessageFromChild Comment Incorrect   0  1  2  8  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.1   mapToken() Callable Only by Mappers", "body": "  In FxERC20RootTunnel and FxERC721RootTunnel, the mapToken function is annotated as follows:  /**  * @notice Map a token to enable its movement via the PoS Portal, callable only by mappers  * @param rootToken address of token on root chain  */ function mapToken(address rootToken) public {  The function however has no access control, anyone may map a token.  The  same  function  in  FxERC1155RootTunnel  lacks  a  function  description.  It  also  has  no  access control.  Specification changed:  The comment has been changed to:  //@notice Map a token to enable its movement via the PoS Portal, callable by anyone  Polygon - Fx Portal -   14  CriticalHighSpeci\ufb01cationChangedMediumSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCorrectnessHighVersion1Speci\ufb01cationChanged        \f7.2   Description of toBoolean() Is Incorrect  In RLPReader, the description of toBoolean() states that \"any non-zero byte is considered true\". The function takes an RLPItem as input.  In  RLP  encoding,  byte  values  in  the  range  [0x80-0xff]  are  encoded  as  2  bytes  like  this: [0x81, the_byte]. For RLPItems encoding such values, toBoolean() will revert, since it enforces that the length of the RLPItem is 1. This is a mismatch, as these values are non-zero and should return true according to the comment.  Specification changed:  The comment has been changed to:  // any non-zero byte < 128 is considered true  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.3   FxMintableERC20RootTunnel", "body": " connectedToken Initialized Incorrectly  the  _deployRootToken   rootToken's In  _connectedToken field is initialized as rootToken. This means the rootToken's _connectedToken will be itself, not the childToken on the other chain.  function  of  FxMintableERC20RootTunnel,   the     The _connectedToken is now correctly initialized with the childToken.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.4   Codehash Variable Type Could Be Set to", "body": " Immutable  In  the  following  contracts  the  variable  childTokenTemplateCodeHash  could  be  changed  to  an immutable:  1. FxERC20RootTunnel.sol  2. FxERC721RootTunnel.sol  3. FxERC1155RootTunnel.sol  This avoids unnessesary and expensive reads from storage, hence reduces the gas consumption.  Polygon - Fx Portal -   15  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  These and more variables have been declared immutable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.5   FxMintableERC20ChildTunnel Has No", "body": " withdrawTo Function  The  FxMintableERC20ChildTunnel  has  no  withdrawTo  function,  unlike  the  other  example contracts. Tokens can only be withdrawn to the same address on the RootChain as the calling address on the ChildChain.  This may make it impossible for some smart contract wallets to bridge tokens, since the user may not be able to deploy the smart contract wallet at the same address on the other chain.    A  withdrawTo()  function  has  been  added,  which  takes  a  receiver  argument.  It  calls  an  internal function  _withdraw(),  which  is  identical  to  the  previous  withdraw()  function,  except  that  it  calls _sendMessageToRoot() with the receiver address instead of msg.sender.  The public withdraw() function's functionality is unchanged.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.6   FxMintableERC20RootTunnel Events Missing", "body": "  The  FxMintableERC20RootTunnel  contract  emits  no  events  when  tokens  are  deposited  or withdrawn, which is different behavior than all other example contracts.    The missing events have been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.7   Outdated Compiler Version", "body": "  The project's hardhat config specifies an outdated version of the Solidity compiler.  solidity: { version: \"0.8.0\",  Known bugs in version 0.8.0 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1685  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing, the most recent Solidity release is version 0.8.16.  Polygon - Fx Portal -   16  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  The compiler version has been updated to 0.8.17.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.8   Return Value of ", "body": " _checkBlockMembershipInCheckpoint()  FxBaseRootTunnel._validateAndExtractMessage()   to In  _checkBlockMembershipInCheckpoint() is made. This internal function has a return value which however is ignored.  call   a     The return value has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.9   SafeMath Library Is Redundant", "body": "  An  old  version  of  FxERC20MintableRootTunnel.  the  SafeMath   library  (made   for  Solidity  <0.8)   is  used   in  ERC20  and  The main use of SafeMath was previously to revert on arithmetic overflow. As of Solidity 0.8, overflow checks were introduced into the Solidity compiler.  This makes the use of SafeMath redundant.    The SafeMath library has been removed.  ERC20.sol  and  IERC20.sol  have  been  updated  to  OpenZeppelin  v4.7.3,  which  does  not  use SafeMath. The required IERC20MetaData.sol has also been added.  FxERC20MintableRootTunnel no longer uses SafeMath.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.10   Unused Variable in", "body": " FxMintableERC20RootTunnel  The  childTokenTemplateCodeHash  variable  in  FxMintableERC20RootTunnel  is  declared  but never used.    Polygon - Fx Portal -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe unused variable has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "7.11   _processMessageFromChild Comment", "body": " Incorrect  The comment of _processMessageFromChild() in FxBaseRootTunnel says that is called from the onStateReceive function. This is incorrect. It is actually called from receiveMessage().  Specification changed:  The comment has been changed to  //This is called by receiveMessage function.  Polygon - Fx Portal -   18  CorrectnessLowVersion1Speci\ufb01cationChanged        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "8.1   FxERC20RootTunnel Cannot Map All ERC-20", "body": " Tokens  mapToken in FxERC20RootTunnel calls ERC20.decimals().  //name, symbol and decimals ERC20 rootTokenContract = ERC20(rootToken); string memory name = rootTokenContract.name(); string memory symbol = rootTokenContract.symbol(); uint8 decimals = rootTokenContract.decimals();  In the ERC-20 standard, decimals is optional.  If the rootToken does not have a decimals function, the call will revert and it will be impossible to map this token.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "8.2   _processMessageFromRoot() Must Succeed", "body": "  Messages synced from Ethereum to Polygon via the StateSender are executed only once. This execution through  FxChild.onStateReceived()  has  5  million  gas  available.  Should  the  execution  revert  for any reason, the message is lost.  The  individual  implementation  of  _processMessageFromRoot()  of  smart  contracts  using  the FxStateChildTunnel  of  the  Fx  Portal  must  respect  that.  They  should  not  contain  external  calls  or anything that may revert if lost messages cannot be tolerated.  Polygon - Fx Portal -   19  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-fx-portal/"}, {"title": "5.1   CRV Not Locked When Used to Mint YCRV", "body": "  When YCRV is minted with the mint() function, CRV is not locked.  In yveCRV, CRV is locked upon minting. In YCRV.mint(...) it is not locked immediately, but a separate call to StrategyProxy.lock() is needed.  assert ERC20(CRV).transferFrom(msg.sender, VOTER, amount)  # dev: no allowance self._mint(_recipient, amount) log Mint(msg.sender, _recipient, False, amount) return amount  Not locking the CRV immediately in the CRV voting escrow implies a mismatch between the total supply of  YCRV  and  the  effective  voting  power  and  total  rewards  of  VOTER.  It  also  imposes  increased  trust requirements towards governance, which might sweep the not yet locked CRV from the VOTER.  Risk accepted  Yearn states:  Locking CRV is gas intensive. Decision was made to have locking occur at some periodic interval via external process rather than burden each user with gas costs.  Yearn - yCRV and ZapYCRV -   10  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedCorrectnessMediumVersion1RiskAccepted             \f5.2   Trades During ZapYCRV.zap Conversions  The ZapYCRV.zap function can involve multiple Curve pools during the conversion.  First, CRV -> LPYCRV conversions will involve up to 2 trades in LPYCRV pool:  1. Trade of all CRV to yCRV  2. Trade of some yCRV to CRV, during the unbalanced deposit into the pool  Compared to trade of some CRV to yCRV and a balanced deposit, the 2 trades double pay the fees.  Second,  in  the  case  when  CVXCRV  is  an  input,  these  2  trades  are  preceded  by  a  trade  on CVXCRVPOOL.  Please  note,  that  due  to  number  of  pools  and  exchanges  during  the  conversion  process  the  min_out argument  can  be  hard  to  specify  precisely.  In  addition,  imprecise  min_out  specified  would  allow  3rd parties to front run the zap.  Risk accepted  Yearn states:  Realize that for some specific paths, this can be inefficient. However, hardcoding paths will lead to more contract complexity and overall gas consumption (including for users who\u2019s zap path touches neither of these tokens) which we view as undesirable. We agree that users can potentially lose more due to swap fees, but ultimately most of those same fees get realized to the pool LPs, helping to repay them over time.  Yearn - yCRV and ZapYCRV -   11  SecurityLowVersion1RiskAccepted        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   LPYCRV Outputs Not Transferred to User   -Severity Findings  Incorrect relative_price When Input Is Not Legacy and Output Is LPYCRV   -Severity Findings   ZapYCRV _min_out LPYCRV Limit   -Severity Findings   ERC20 Return Values Not Checked    ZapYCRV.zap Natspec   1  1  1  2  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "6.1   LPYCRV Outputs Not Transferred to User", "body": "  In the zap function of ZapYCRV, converting to LPYCRV as _output_token will not transfer LPYCRV to the user but leave it in the ZapYCRV contract instead.  When  LPYCRV  is  the  output  token,  ZapYCRV  should  first  deposit  YCRV  as  liquidity  in  the  POOL StableSwap pool, receiving the POOL liquidity token. The POOL liquidity token should then be deposited in the LPYCRV vault and the issued shares transferred to the user.  The following line of code in _convert_to_output is responsible for the specified logic.  amount_out: uint256 = Vault(LPYCRV).deposit(self._lp([0, amount], _min_out,     _recipient))  which calls the self._lp(...) function, defined as  @internal def _lp(_amounts: uint256[2], _min_out: uint256, _recipient: address) -> uint256:     return Curve(POOL).add_liquidity(_amounts, _min_out)  The  _recipient  argument  is  passed  to  the  _lp  function,  but  never  used.  The  _lp  function  doesn't actually need the _recipient argument, because ZapYCRV will still need to deposit the liquidity token into the LPYCRV vault.  The Vault(LPYCRV).deposit function is called without specifying the recipient argument, which therefore  defaults  to  msg.sender,  which  is  the  ZapYCRV  contract  in  the  context  of  the  deposit  call. Finally the zap function returns and the issued shares of LPYCRV are never transferred to the user, but left to ZapYCRV instead.  Yearn - yCRV and ZapYCRV -   12  CriticalCodeCorrectedHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCorrectnessCriticalVersion1CodeCorrected         \fCode corrected  The recipient argument of the _lp function has been removed.  @internal def _lp(_amounts: uint256[2]) -> uint256:         return Curve(POOL).add_liquidity(_amounts, 0)  A  recipient  value  _convert_to_output function.  is  now  specified   in   the  deposit  call   to   the  LPYCRV  vault   in   the  amount_out: uint256 = Vault(LPYCRV).deposit(self._lp([0, amount]), _recipient)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "6.2   Incorrect relative_price When Input Is Not", "body": " Legacy and Output Is LPYCRV  In relative_price the relative price for the POOL liquidity token is returned instead of the relative price of LPYCRV when _input_token is not a legacy token and _output_token is LPYCRV.  The relative price for _input_token not in legacy_tokens and _output_token equal to LPYCRV is computed as follow:  return amount * 10 ** 18 / Curve(POOL).get_virtual_price()  This doesn't take into account that the output token is LPYCRV and not POOL, so the POOL tokens need to be used to purchase LPYCRV shares at price Vault(LPYCRV).pricePerShare().  When _input_token is a legacy token, it is computed correctly as follows:  lp_amount: uint256 = amount * 10 ** 18 / Curve(POOL).get_virtual_price() return lp_amount * 10 ** 18 / Vault(LPYCRV).pricePerShare()  Code corrected  return amount * 10 ** 18 / Curve(POOL).get_virtual_price()  is replaced with  lp_amount: uint256 = amount * 10 ** 18 / Curve(POOL).get_virtual_price() return lp_amount * 10 ** 18 / Vault(LPYCRV).pricePerShare()  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "6.3   ZapYCRV _min_out LPYCRV Limit", "body": "  In ZapYCRV.zap, the _min_out argument of the zap function asserts a lower bound on the amount of output token received by the user. When _output_token is LPYCRV it incorrectly asserts the amount of liquidity tokens issued as an intermediate conversion step by Curve(POOL).add_liquidity.  Yearn - yCRV and ZapYCRV -   13  CorrectnessHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \fIn the LPYCRV branch of _convert_to_output, _min_out gets first passed to _lp(), which uses it as a lower bound to the amount of liquidity tokens issued by Curve(POOL).add_liquidity()  @internal def _lp(_amounts: uint256[2], _min_out: uint256, _recipient: address) -> uint256:     return Curve(POOL).add_liquidity(_amounts, _min_out)  It is then used again as a lower bound for amount_out issued by Vault(LPYCRV).deposit().  amount_out: uint256 = Vault(LPYCRV).deposit(self._lp([0, amount], _min_out, _recipient)) assert amount_out >= _min_out # dev: min out  This  basically  makes  _min_out  used  for  limit  of  LPYCRV  vault  shares  and  POOL  LP  shares.  Due  to how the share values are computed, in the general case they will be not worth 1:1. Thus, _min_out as a limit is not practical.  Code corrected  The _min_out argument of the _lp function has been removed. Thus it is not used as a lower bound to the amount of liquidity tokens issued by Curve(POOL).add_liquidity() anymore.  @internal def _lp(_amounts: uint256[2]) -> uint256:     return Curve(POOL).add_liquidity(_amounts, 0)  Yearn notes:  Hardcode the minimum to 0 in add_liquidity, as we will rely on subsequent check to compare user inputted min_out.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "6.4   ERC20 Return Values Not Checked", "body": "  According to EIP-20, Callers MUST NOT assume that false is never returned. However, not all calls to ERC20 assert that true is returned. ZapYCRV and yCRV do not check bool success values for calls to ERC20.approve  and  ERC20.transfer.  Even  though  in  most  cases  the  contracts  are  known  in advance and it is safe not to check this value, new features and codebase reuse can lead to potential problems.  In function sweep in both contracts the return value of ERC20.transfer can be missing, if for example USDT is used. In that case the call will fail.  Code corrected  Asserts have been added to the approve and transfer calls to make sure that true is returned.  Compiler  version  has  been  increased  to  vyper  0.3.6  in  order  to  use  the  external  call  keyword argument  default_return_value=True,  which  ensures  that  transfer  calls  do  not  revert  when calling non EIP-20 compliant tokens such as USDT which do not return a boolean value.  Yearn - yCRV and ZapYCRV -   14  CorrectnessLowVersion1CodeCorrected          \f6.5   ZapYCRV.zap Natspec  The  @param  _input_token  for  zap  function  does  not  describe  that  cvxCRV  can  be  used  as  input token.  Code corrected  The cvxCRV has been added to the @param _input_token in the zap function's natspec.  Yearn - yCRV and ZapYCRV -   15  CorrectnessLowVersion1CodeCorrected      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "7.1   Some but Not All Fees Are Accounted for in ", "body": " calc_expected_out  The natspec of calc_expected_out says that fees are not accounted for when computing the result. But  actually,  almost  in  all  cases,  when  the  Curve  pools  are  used,  they  are  accounted.  The  only  case when the fees are not taken into account is when the output token is LPYCRV. Then the deposit of YCRV in POOL is simulated with Curve(POOL).calc_token_amount(...), which does not account for the fees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "7.2   ZapYCRV Curve StableSwap Token Indices", "body": " Sanity Check  ZapYCRV  contract  uses  POOL  contract,  that  is  assumed  to  be  Curve  Finance  StableSwap  contract.  In StableSwap  the  tokens  can  be  in  any  order.  The  yCRV/CRV  pool  is  not  yet  deployed.  Thus,  the assumption that CRV will be index 0 and yCRV will have index 1 might be violated. A sanity check in the constructor  of  ZapYCRV  contract  can  prevent  human  and  misconfiguration  errors  and  lower  the  costs associated with redeployment.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "7.3   ZapYCRV Return Values Ignored", "body": "  the   ZapYCRV._zap_from_legacy   In  to IYCRV(YCRV).burn_to_mint  are  ignored.  Return  value  is  assumed  to  be  same  as  the  amount argument  that  the  function  takes.  However,  in  case  when  the  amount  is  equal  to  MAX_UINT256,  the burn_to_mint  might  return  other  value.  In  the  current  version  such  situation  should  never  happen, because  this  case  is  handled  by  the  zap  function  itself.  In  ZapYCRV._zap_from_legacy,  amount should never be equal to MAX_UINT256. However use of return value will prevent potential bugs in case of code reuse or if new features are added.  function   return   value   calls   the   of   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "7.4   yCRV as an ERC20 Implementation", "body": "  There are 2 things we would like to note regarding the yCRV token.  1. The approve function has a known race condition attack vector described here  Yearn - yCRV and ZapYCRV -   16  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \f2. The  transferFrom  function  does  not  emit  Approval  event.  While  this  is  compliant  with specification,  one  cannot  reconstruct  the  state  of  user  allowances  based  only  on  events,  since transferFrom does not emit any special events that show that approval was used.  Yearn - yCRV and ZapYCRV -   17  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-finance-ycrv-and-zapycrv/"}, {"title": "7.1   Burn Function Redundant Checks", "body": "  In Dai contract, some gas savings are possible.  The  safeMath  operator  _sub  can  be  removed  in  totalSupply  =  _sub(totalSupply,  value);, because of the check:  uint256 balance = balanceOf[from]; require(balance >= value, \"Dai/insufficient-balance\");    The  redundant  check  was  removed.  Similar  check  in  mint  function  was  found  and  removed  by MakerDAO team themselves.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-optimism-dai-bridge/"}, {"title": "7.2   Contract L2GovernanceRelay Unnecessary", "body": " Statefulness  The  L2GovernanceRelay  contract  defines  the  l1GovernanceRelay  field  and  inherits  from  the messenger field from OVM_CrossDomainEnabled.  Those 2 fields could be declared as immutable as they are never changed after the initial assignment. The  L1GovernanceRelay  address  can  be  precomputed  and  passed  to  L2GovernanceRelay  as  a constructor variable.    MakerDAO - Optimism DAI Bridge -   9  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                 \fThe l1GovernanceRelay is an immutable field now. The messenger is still a storage field, because changing  it  will  require  a  change  in  the  Optimism  contracts  library,  that  are  out  of  scope  for  this assessment.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-optimism-dai-bridge/"}, {"title": "7.3   Init Function of L2GovernanceRelay", "body": "  The  function  init  for  L2GovernanceRelay  contract  is  needed  to  set  the  l1GovernanceRelay  field. This  function  is  not  protected  by  any  access  modifier  and  can  be  called  by  anyone.  The  attacker  can potentially call this function himself and ruin the deployment. Such attack will require the redeployment of L2GovernanceRelay contract and potentially of the L1GovernanceRelay. In addition the attacker can find a potential transaction that will revert the optimism history to such extend, where the L2GovernanceRelay deployment has happened, but init hasn't. This way attacker can init contract again himself, effectively getting a full control over the L2GovernanceRelay.    The L2GovernanceRelay now has only a constructor, where the immutable l1GovernanceRelay is set.  MakerDAO - Optimism DAI Bridge -   10  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-optimism-dai-bridge/"}, {"title": "8.1   Constructors Marked Public", "body": "  L2DAITokenBridge.sol and dai.sol contracts have constructor with public modifier. This visability modifier will be ingnored by the solidity compiler.  MakerDAO - Optimism DAI Bridge -   11  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-optimism-dai-bridge/"}, {"title": "5.1   Possible Gas Optimization for Mappings", "body": "  Although the value for the mapping isOracle is of type bool which needs only 1 bit of storage, Solidity uses a word (256 bits) for each stored value and performs some additional operations when operating bool values (masking). Therefore, using uint instead of bool is slightly more efficient.  Acknowledged:  Maker acknowledged the issue.  MakerDAO - G-UNI LP Oracle -   9  DesignCriticalHighMediumLowAcknowledgedDesignLowVersion1Acknowledged           \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Missing Documentation   -Severity Findings   Unused Constant Variable   0  0  1  1  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-g-uni-lp-oracle/"}, {"title": "6.1   Missing Documentation", "body": "  The requirements about the oracles for the underlying tokens are not documented. In the supplied test file we see following oracles:  address constant USDC_ORACLE        = 0x77b68899b99b686F415d074278a9a16b336085A0; address constant DAI_ORACLE         = 0x47c3dC029825Da43BE595E21fffD0b66FfcB7F6e; address constant ETH_ORACLE         = 0x81FE72B5A8d1A857d176C3E7d5Bd2679A9B85763;  The oracles for USDC and DAI return the unit value of one. The ETH oracle is updated roughly once an hour hence the price returned is not live. For the proper working of the GUniLPOracle a live price feed is required, frequently updated and without a time delay. When GUniLPOracle.seek() is executed, the underlying price feeds must return live values.  Furthermore the underlying principle how the price is determined could be described more clearly in the Readme:  This price feed works by determining how many of token0 and token1 the underlying liquidity position in UniswapV3  held  by  the  GUniPool  has  at  the  current  price.  This  current  price  is  solely  determined  by Maker oracles and independent of the current state of the UniswapV3 pool. The assumption is that  1. The Maker oracles for the underlying tokens return the current market rate  2. In general, e.g. outside flashloan scenarios, the UniswapV3 pool will be balanced at the current market rate. This means that the GUnipool tokens can be redeemed at this current market rate.  Hence  such  a  GUnipool  token  collateral  is  priced  based  on  its  underlying  tokens,  independent  of  the state of the GUni/Uniswap V3 pool. The documentation may be expanded to explain and motivate this.  Specification changed:  Maker responded:  It was a mistake that the test was referring to the ETH/USD OSM. It should have referenced the ETH/USD Medianizer to get a live price feed.  MakerDAO - G-UNI LP Oracle -   10  CriticalHighMediumSpeci\ufb01cationChangedLowCodeCorrectedDesignMediumVersion1Speci\ufb01cationChanged        \fFurthermore the readme has been updated and now contains:  Underlying price oracles `orb0` and `orb1` should refer to either a Medianizer, DSValue or some other `read()` compliant oracle. OSMs should not be used to the double delay.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-g-uni-lp-oracle/"}, {"title": "6.2   Unused Constant Variable", "body": "  The  variable  WAD  is  declared  as  constant  and  initialized  to  10  **  18,  however  it's  never  used  in  the code.    The unused constant has been removed.  MakerDAO - G-UNI LP Oracle -   11  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-g-uni-lp-oracle/"}, {"title": "7.1   Misleading Function Name link", "body": "  The  function  name  link(uint256  _id,  address  _orb)  is  misleading  as  it  gives  the  impression that the token _id is linked to the respective oracle initially by this function. However, this function only updates an existing link of the token with the respective oracle (initialized in the constructor).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-g-uni-lp-oracle/"}, {"title": "7.2   NewGUniLPOracle Indexed Fields", "body": "  The  event  NewGUniLPOracle  has  two  indexed  parameters  corresponding  to  the  token  addresses.  In practice, it might be useful if the field address owner is indexed also, as it would allow users to easily filter oracles from a trusted owner.  MakerDAO - G-UNI LP Oracle -   12  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-g-uni-lp-oracle/"}, {"title": "6.1   Use of Atomic Transactions Only", "body": "  The  router  performs  critical  actions,  of  which  many  should  not  be  done  separately  in  multiple transactions. All critical operations must be done in one atomic transaction.  Yearn - Yearn ERC4626 Router -   10  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-erc4626-router/"}, {"title": "5.1   Compression of Epochs in Struct", "body": "  0  0  0  4  It  is  unlikely  that  the  channel  struct  values  for  ticketEpoch  or  channelEpoch  will  ever  reach  the maximum  number  of  uint256.  HOPRNet  should  re-evaluate  if  these  values  can  be  bounded  e.g.  by uint128 and share a storage slot and thus lower the gas consumption of the contract.  Acknowledged  Gas efficiency issues are considered out of scope.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "5.2   Gas Optimization", "body": "  The contract includes a struct that stores in storage a mapping with all channels and the respective state for each channel as following:  struct Channel {     uint256 balance;     bytes32 commitment;     uint256 ticketEpoch;     uint256 ticketIndex;     ChannelStatus status;  HOPRNet - Payment Channel -   8  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                   \f    uint256 channelEpoch;     // the time when the channel can be closed - NB: overloads at year >2105     uint32 closureTime;   }  The Channel struct includes an attribute status which is of type enum ChannelStatus and has only 4  values,  therefore  occupies  only  8  bits  in  the  storage.  Given  that  there  is  another  attribute uint32 closureTime that occupies another 32 bits, these two attribute status and closureTime should be reordered and placed together to optimize the overall storage used by the contract.  Acknowledged  Gas efficiency issues are considered out of scope.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "5.3   Node Can Set Ticket Index to Arbitrary High", "body": " Values  The ticket issuing node can set the ticket index at will. If this index is set to a value close or equal to max uint, the tickets would be unusable (not redeemable) quickly and the channel would need to be reset.  Acknowledged  The issue has been discussed and it was decided to check the ticket index off-chain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "5.4   Redundant Sanity Checks", "body": "  The function fundChannelMulti checks if the two amounts are greater than zero, which are checked later again in the function _fundChannel.  The  modifier  validateSourceAndDest  is  executed  twice  for  each  call  of  _fundChannel  from fundChannelMulti if one would fund both channels directions.  Acknowledged  Hopr provided the reasoning why it is done this way and that efficiency issues are out of scope.  HOPRNet - Payment Channel -   9  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Reentrancy Can Drain Money   -Severity Findings  -Severity Findings  Inconsistent States and Events   -Severity Findings   Channel Transition Model    Redundant Imports    Token Transfers Inconsistent    Variables Could Be Labeled Immutable   1  0  1  4  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "6.1   Reentrancy Can Drain Money", "body": "  The HoprChannels smart contract uses the ERC777 HoprToken to settle payments. The ERC777 token allows  reentrancies  during  the  transfer  via  sender  and  receiver  hooks.  An  attacker  can  utilize  this reentrancy to drain the balance of HoprChannels contract. One of the places where this can happen is in the finalizeChannelClosure function.  We describe a more elaborate attack and a straightforward attack.  Attack  setup:  Alice  and  Bob  cooperate.  They  have  created  channels  between  them,  Alice  has  called initiateChannelClosure  for  her  channel  with  Bob,  that  holds  100  tokens.  Bob  has  valid  and  yet unclaimed ticket for 75 tokens. Closure time has passed for the Alice owned channel. Alice has a smart contract registered for ERC777 hook. Bob is smart contracts that is registered in the ERC1820 registry for the ERC777 hooks.   Alice calls finalizeChannelClosure with Bob as destination.   During the call token.transfer(Alice, 100); in this function, Alice contract gets called.   Alice contract calls to Bob contract.   Bob contract calls the redeemTicket with valid unclaimed ticket.   Channel (Alice, Bob) is spending and (Bob, Alice) is earning.   Balance of (Alice, Bob) is decreased by 75. Since the balance of the channel is  still 100, the new value will be 25.   Balance of (Bob, Alice) is increased by 75.   Function redeemTicket returns.   The Bob contract execution returns to Alice  HOPRNet - Payment Channel -   10  CriticalCodeCorrectedHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected         \f Alice contract returns finalizeChannelClosure call.   The execution continues after the call token.transfer(Alice, 100);   The balance (25 tokens) of Alice owned channel is nullified with delete and the status is set to the  CLOSED.  As a result of above described schema, the initial 100 tokens of (Alice, Bob) channel will be payed out to Alice, and in addition Bob will get 75 tokens from his ticket claim. Thus instead of 100 tokens 175 tokens were withdrawn.  The straightforward attack would be to reenter multiple time into the finalizeChannelClosure as the state  variables  are  changed  after  the  reentrancy  possibility.  As  a  general  rule,  all  state  dependent operations should be done before the possible reentrancy. Additionally, reentrancies could be completely blocked if not needed.    In functions that perform transfers of HOPRToken the transfer operations are moved to the end of the functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "6.2   Inconsistent States and Events", "body": "  Functions using ERC777 transfers can be reentered (a reentrancy does not necessarily need to happen in  the  same  function  but  in  another  relevant  function  in  the  system.).  Some  of  these  functions  have  a code  after  the  possible  reentrancy  point.  This  might  become  problematic  if  the  logic  relies  on  state variables  like  in  finalizeChannelClosure,  redeemTicket.  Besides  the  more  critical  reentrancy issue we mentioned, these function's events might be inconsistent or misleading.  in  redeemTicket  event  ChannelUpdate   For  example,  is  emitted.  This  event  uses spendingChannel storage variable. Given the redeemTicket is called and the ERC777 hook is used to change any storage variable used in these events, the events can emit inconsistent information. This can be done if during the transfer, the hook calls the bumpChannel in between.  The same applies to the other places where logic after the reentrancy possibility relies on state variables. We do not know if the client's or third party software will rely on these events. If so, the severity of the issue would be affected.    In functions that perform transfers of HOPRToken the transfer operations are moved to the end of the functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "6.3   Channel Transition Model", "body": "  According  to  the  channels  states  transition  model,  the  channel  in  Waiting  for  commitment  state cannot be taken into Pending To Close. In the smart contract code, such behavior is allowed in the initiateChannelClosure  function.  In  addition,  the  specification  provided  by  HOPRNet  also  allows such behavior.  HOPRNet - Payment Channel -   11  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f  The transition model for channel states has been updated accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "6.4   Redundant Imports", "body": "  The SafeERC20.sol library is imported twice in line 10 and 11.  Code corrected  The redundant import is removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "6.5   Token Transfers Inconsistent", "body": "  The  HoprChannels  contract  has  inconsistent  use  of  SafeERC20  functions.  Since  the  token  is  known HoprToken contract that cannot be changed after the deployment, the use of SafeERC20 functions is redundant and introduces the unnecessary gas expenses.  token.transfer(msg.sender, channel.balance); token.safeTransfer(msg.sender, amount); token.safeTransferFrom(msg.sender, address(this), amount1 + amount2);  Code corrected  transfer is now used consistently.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "6.6   Variables Could Be Labeled Immutable", "body": "  The keyword immutable and constant can be used to save gas because the compiler does not reserve a storage  slot  for  these  variables,  and  every  occurrence  is  replaced  by  the  respective  value.  Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed.  token  and  secsClosure  variable  can  not  be  changed  and  can  be  set  immutable. FUND_CHANNEL_MULTI_SIZE could be set to constant (if calculated beforehand) or else immutable as the value is known when compiling the contract and cannot be changed later.  to   Code corrected  The variables were labeled immutable.  HOPRNet - Payment Channel -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}]