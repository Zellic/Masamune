[{"title": "There is no automated test coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.", "body": "There is no automated test coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#there-is-no-automated-test-coverage-report.-without-this-report-it-is-impossible-to-know-whether-there-are-parts-of-the-code-never-executed-by-the-automated-tests;-so-for-every-change,-a-full-manual-test-suite-has-to-be-executed-to-make-sure-that-nothing-is-broken-or-misbehaving.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding the test coverage report, and making it reach at least 95% of the source code.", "body": "Consider adding the test coverage report, and making it reach at least 95% of the source code.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-adding-the-test-coverage-report,-and-making-it-reach-at-least-95%-of-the-source-code.", "labels": ["OpenZeppelin"]}, {"title": "Canceled event not\u00a0emitted", "body": "Canceled event not\u00a0emitted", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#canceled-event-not\u00a0emitted", "labels": ["OpenZeppelin"]}, {"title": "The Marmo contract has a\u00a0Canceled event that should be emitted when an intent is canceled. However, this event is not emitted by the cancel function. This will make more difficult for clients to follow the status of intents, forcing them to either listen for all the transactions of the contract or to poll calling isCanceled.", "body": "The Marmo contract has a\u00a0Canceled event that should be emitted when an intent is canceled. However, this event is not emitted by the cancel function. This will make more difficult for clients to follow the status of intents, forcing them to either listen for all the transactions of the contract or to poll calling isCanceled.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-marmo-contract-has-a\u00a0canceled-event-that-should-be-emitted-when-an-intent-is-canceled.-however,-this-event-is-not-emitted-by-the-cancel-function.-this-will-make-more-difficult-for-clients-to-follow-the-status-of-intents,-forcing-them-to-either-listen-for-all-the-transactions-of-the-contract-or-to-poll-calling-iscanceled.", "labels": ["OpenZeppelin"]}, {"title": "Consider emitting Canceled at the end of the cancel function.", "body": "Consider emitting Canceled at the end of the cancel function.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-emitting-canceled-at-the-end-of-the-cancel-function.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #29.", "body": "Update: Fixed in pull request #29.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-fixed-in-pull-request-#29.", "labels": ["OpenZeppelin"]}, {"title": "MarmoStork does not check the size of the implementation contract address explicitly", "body": "MarmoStork does not check the size of the implementation contract address explicitly", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#marmostork-does-not-check-the-size-of-the-implementation-contract-address-explicitly", "labels": ["OpenZeppelin"]}, {"title": "The constructor of the MarmoStork contract takes an array of bytes in the _source argument, and uses it as the destination address for a delegatecall. An ethereum address has 20 bytes, but the size of this array is not checked at the beginning of the function.", "body": "The constructor of the MarmoStork contract takes an array of bytes in the _source argument, and uses it as the destination address for a delegatecall. An ethereum address has 20 bytes, but the size of this array is not checked at the beginning of the function.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-constructor-of-the-marmostork-contract-takes-an-array-of-bytes-in-the-_source-argument,-and-uses-it-as-the-destination-address-for-a-delegatecall.-an-ethereum-address-has-20-bytes,-but-the-size-of-this-array-is-not-checked-at-the-beginning-of-the-function.", "labels": ["OpenZeppelin"]}, {"title": "The length of this _source argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resulting bytecode will have an unintended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulating the length. But, for example, taking the part that generates the opcode that should push the address to the stack when the _source array length is bigger than that of a valid address, it can even result in the selfdestruct opcode instead of the expected push20.", "body": "The length of this _source argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resulting bytecode will have an unintended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulating the length. But, for example, taking the part that generates the opcode that should push the address to the stack when the _source array length is bigger than that of a valid address, it can even result in the selfdestruct opcode instead of the expected push20.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-length-of-this-_source-argument-is-then-used-to-generate-the-bytecode-of-the-contract-that-will-delegate-the-calls.-if-an-array-that-is-not-a-valid-address-is-passed-to-this-constructor,-the-resulting-bytecode-will-have-an-unintended-behavior.-the-part-generated-from-the-length-of-the-array-is-surrounded-by-other-hardcoded-bytecode,-so-it-would-be-very-difficult-to-craft-an-attack-just-by-manipulating-the-length.-but,-for-example,-taking-the-part-that-generates-the-opcode-that-should-push-the-address-to-the-stack-when-the-_source-array-length-is-bigger-than-that-of-a-valid-address,-it-can-even-result-in-the-selfdestruct-opcode-instead-of-the-expected-push20.", "labels": ["OpenZeppelin"]}, {"title": "Later in the constructor, this argument is converted to an address calling the toAddress function which does require the length to be 20 or less. So a bigger array will end up reverting the constructor, but this does not happen explicitly and because of that it has the risk of being removed by mistake.", "body": "Later in the constructor, this argument is converted to an address calling the toAddress function which does require the length to be 20 or less. So a bigger array will end up reverting the constructor, but this does not happen explicitly and because of that it has the risk of being removed by mistake.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#later-in-the-constructor,-this-argument-is-converted-to-an-address-calling-the-toaddress-function-which-does-require-the-length-to-be-20-or-less.-so-a-bigger-array-will-end-up-reverting-the-constructor,-but-this-does-not-happen-explicitly-and-because-of-that-it-has-the-risk-of-being-removed-by-mistake.", "labels": ["OpenZeppelin"]}, {"title": "Consider changing the type of the _source parameter to address. This will make the expectations clear and prevent any issues derived from invalid addresses. Alternatively, consider requiring the array to be 20 bytes at the start of the constructor, following best practices to fail early and to structure your functions starting with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.", "body": "Consider changing the type of the _source parameter to address. This will make the expectations clear and prevent any issues derived from invalid addresses. Alternatively, consider requiring the array to be 20 bytes at the start of the constructor, following best practices to fail early and to structure your functions starting with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-changing-the-type-of-the-_source-parameter-to-address.-this-will-make-the-expectations-clear-and-prevent-any-issues-derived-from-invalid-addresses.-alternatively,-consider-requiring-the-array-to-be-20-bytes-at-the-start-of-the-constructor,-following-best-practices-to-fail-early-and-to-structure-your-functions-starting-with-the-conditions.-both-options-have-an-added-benefit:-a-fixed-size-would-simplify-the-bytecode-generation-because-more-terms-can-be-replaced-by-constants.", "labels": ["OpenZeppelin"]}, {"title": "pull request #30", "body": "pull request #30", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#pull-request-#30", "labels": ["OpenZeppelin"]}, {"title": "constructor of MarmoStork", "body": "constructor of MarmoStork", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#constructor-of-marmostork", "labels": ["OpenZeppelin"]}, {"title": "README is\u00a0empty", "body": "README is\u00a0empty", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#readme-is\u00a0empty", "labels": ["OpenZeppelin"]}, {"title": "The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.", "body": "The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-readme.md-files-on-the-root-of-the-git-repositories-are-the-first-documents-that-most-developers-will-read,-so-they-should-be-complete,-clear,-concise-and-accurate.", "labels": ["OpenZeppelin"]}, {"title": "The README.md of the Marmo contracts has no information about what is the purpose of the project nor how to use it.", "body": "The README.md of the Marmo contracts has no information about what is the purpose of the project nor how to use it.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-readme.md-of-the-marmo-contracts-has-no-information-about-what-is-the-purpose-of-the-project-nor-how-to-use-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to the parts of the project.", "body": "Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to the parts of the project.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-following-standard-readme-to-define-the-structure-and-contents-for-the-readme.md-file.-consider-including-an-explanation-of-the-core-concepts-of-the-repository,-the-usage-workflows,-the-public-apis,-instructions-to-test-and-deploy-it,-and-how-it-relates-to-the-parts-of-the-project.", "labels": ["OpenZeppelin"]}, {"title": "Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.", "body": "Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#make-sure-to-include-instructions-for-the-responsible-disclosure-of-any-security-vulnerabilities-found-in-the-project.", "labels": ["OpenZeppelin"]}, {"title": "README file", "body": "README file", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#readme-file", "labels": ["OpenZeppelin"]}, {"title": "Standard Readme", "body": "There are hard-coded values in the code  There are hard-coded values in several Marmo contracts. For example, 65536 and 0xff. These values make the code harder to understand and to maintain.  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For complex values, consider adding a comment explaining how were they calculated or why were they chosen.  #33  #37  32  in  Marmo.sol  line 125  0x20  in  MarmoStork.sol  line 82  Restricted Address Range is in Draft  The Marmo contract can be made unusable by setting the signer to the invalid address 65536. This address was chosen because it is the first one after the restricted range, as defined by EIP1352: Specify restricted address range for precompiles/system contracts.  This EIP is still a draft, so there is a little risk of it changing in the future and making 65536 one of the restricted addresses. If the code has to be released to production before the EIP is finalized, consider using a random address to invalidate the contract, instead of one so close to the restricted range.  pull request #33  higher address as an invalid signer  Duplicated Code to Get the Signer  signer  function that returns the address of the signer. This code is  duplicated in the  init  function.  Consider calling signer from the init function, instead of duplicating the code.  Update: The RCN team decided not to fix this in order to save one jump operation.  Misleading comment about destroying the wallet  The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.  Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed in pull request #38.  Invalid address check uses assert  The relay function of the Marmo contract fails when the signer is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.  Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.  Update: Fixed in pull request #34.  Relayed event is emitted before the action is executed  emits a  Relayed  event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.  Consider moving the emit of the Relayed event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an intent between two events.  Block on intent receipt can overflow  An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.  Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.  Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.  Re-implementing ECDSA signature recovery  The Marmo project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.  Consider using the recover function from OpenZeppelin to reduce the code surface area.  An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The MarmoStork contract has no way to check whether a wallet has been revealed.  Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.  Notes & Additional Information  In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 20181225, and was renamed to Ethlint. Consider removing the Solium dependency.  The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.  The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.  An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.  signer to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.  Relayed to IntentRelayed.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Marmo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#standard-readme", "labels": ["OpenZeppelin"]}, {"title": "There are hard-coded values in the\u00a0code", "body": "There are hard-coded values in the\u00a0code", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#there-are-hard-coded-values-in-the\u00a0code", "labels": ["OpenZeppelin"]}, {"title": "There are hard-coded values in several Marmo contracts. For example, 65536 and 0xff. These values make the code harder to understand and to maintain.", "body": "There are hard-coded values in several Marmo contracts. For example, 65536 and 0xff. These values make the code harder to understand and to maintain.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#there-are-hard-coded-values-in-several-marmo-contracts.-for-example,-65536-and-0xff.-these-values-make-the-code-harder-to-understand-and-to-maintain.", "labels": ["OpenZeppelin"]}, {"title": "Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For complex values, consider adding a comment explaining how were they calculated or why were they chosen.", "body": "Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For complex values, consider adding a comment explaining how were they calculated or why were they chosen.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-defining-a-constant-variable-for-every-hard-coded-value,-giving-it-a-clear-and-explanatory-name.-for-complex-values,-consider-adding-a-comment-explaining-how-were-they-calculated-or-why-were-they-chosen.", "labels": ["OpenZeppelin"]}, {"title": "#33", "body": "higher address as an invalid signer  Duplicated Code to Get the Signer  signer  function that returns the address of the signer. This code is  duplicated in the  init  function.  Consider calling signer from the init function, instead of duplicating the code.  Update: The RCN team decided not to fix this in order to save one jump operation.  Misleading comment about destroying the wallet  The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.  Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed in pull request #38.  Invalid address check uses assert  The relay function of the Marmo contract fails when the signer is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.  Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.  Update: Fixed in pull request #34.  Relayed event is emitted before the action is executed  emits a  Relayed  event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.  Consider moving the emit of the Relayed event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an intent between two events.  Block on intent receipt can overflow  An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.  Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.  Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.  Re-implementing ECDSA signature recovery  The Marmo project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.  Consider using the recover function from OpenZeppelin to reduce the code surface area.  An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The MarmoStork contract has no way to check whether a wallet has been revealed.  Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.  Notes & Additional Information  In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 20181225, and was renamed to Ethlint. Consider removing the Solium dependency.  The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.  The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.  An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.  signer to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.  Relayed to IntentRelayed.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Marmo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120##33", "labels": ["OpenZeppelin"]}, {"title": "#37", "body": "#37", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120##37", "labels": ["OpenZeppelin"]}, {"title": "32", "body": "32", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#32", "labels": ["OpenZeppelin"]}, {"title": "in", "body": "the marmo-contracts repository. The version used for this report is d3fb5922a4f01e47d585343d08cccfad659b3584.  Followg are our assessment and recommendations,  order of importance.  Update: the RCN team made some fixes based on our recommendations. We address below the fixes troduced up to commit cbe0388bd7a624f8ca73d805af4d31c5d0b53960.  Critical Severity  None.  High Severity  Assembly and bytecode without extensive documentation  The Marmo contracts clude multiple assembly blocks and a big amount of bytecode. While it is not a security vulnerability right now, this is at the same time the most complicated and the most critical part of the system, it needs to be documented with extra care.  These assembly blocks and bytecode are not extensively documented. Developers may misunderstand the purpose of the code and cause unexpected errors when attemptg to modify it.  Consider clearly documentg the tent of each block of assembly code, as well as exhaustively documentg every opcode and every parameter. This will guide future contributors and reviewers when tryg to understand, extend or fix the code.  pull request #28  library  MarmoStork constructor  Implementations have full control over the Marmo wallet  relay  function of the  Marmo  contract uses  This gives implementations a lot of power and forces users to verify its deployed code every time they want to relay an tent. Users could call the wrong implementations by mistake or by deception and lose control over their own wallets.  One possible solution would be to whitelist the EXTCODEHASH of verified implementations, and to block calls to unverified implementations. That brgs limitations and an extra layer of complexity, though. If decided to leave as is, we recommend statg this risk clearly and display it to user  Update: This is by design. The RCN team does not plan to control a Marmo ecosystem, but to encourage users to deploy their private Marmo stances to relay their own tents. Also, the system is designed to be used through an SDK which will prevent many problems that could happen if the tents are generated manually.  Medium Severity  Missg test coverage report  There is no automated test coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothg is broken or misbehavg.  Consider addg the test coverage report, and makg it reach at least 95% of the source code.  Canceled event not emitted  The Marmo contract has a Canceled event that should be emitted when an tent is canceled. However, this event is not emitted by the cancel function. This will make more difficult for clients to follow the status of tents, forcg them to either listen for all the transactions of the contract or to poll callg isCanceled.  Consider emittg Canceled at the end of the cancel function.  Update: Fixed  pull request #29.  MarmoStork does not check the size of the implementation contract address explicitly  The constructor of the MarmoStork contract takes an array of bytes  the _source argument, and uses it as the destation address for a delegatecall. An ethereum address has 20 bytes, but the size of this array is not checked at the begng of the function.  The length of this _source argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resultg bytecode will have an untended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulatg the length. But, for example, takg the part that generates the opcode that should push the address to the stack when the _source array length is bigger than that of a valid address, it can even result  the selfdestruct opcode stead of the expected push20.  Later  the constructor, this argument is converted to an address callg the toAddress function which does require the length to be 20 or less. So a bigger array will end up revertg the constructor, but this does not happen explicitly and because of that it has the risk of beg removed by mistake.  Consider changg the type of the _source parameter to address. This will make the expectations clear and prevent any issues derived from valid addresses. Alternatively, consider requirg the array to be 20 bytes at the start of the constructor, followg best practices to fail early and to structure your functions startg with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.  pull request #30  constructor of MarmoStork  Low Severity  README is empty  The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.  The README.md of the Marmo contracts has no formation about what is the purpose of the project nor how to use it.  Consider followg Standard Readme to defe the structure and contents for the README.md file. Consider cludg an explanation of the core concepts of the repository, the usage workflows, the public APIs, structions to test and deploy it, and how it relates to the parts of the project.  Make sure to clude structions for the responsible disclosure of any security vulnerabilities found  the project.  README file  Standard Readme  There are hard-coded values  the code  There are hard-coded values  several Marmo contracts. For example, 65536 and 0xff. These values make the code harder to understand and to mata.  Consider defg a constant variable for every hard-coded value, givg it a clear and explanatory name. For complex values, consider addg a comment explag how were they calculated or why were they chosen.  #33  #37  32    Marmo.sol  le 125  0x20    MarmoStork.sol  le 82  Restricted Address Range is  Draft  The Marmo contract can be made unusable by settg the signer to the valid address 65536. This address was chosen because it is the first one after the restricted range, as defed by EIP1352: Specify restricted address range for precompiles/system contracts.  This EIP is still a draft, so there is a little risk of it changg  the future and makg 65536 one of the restricted addresses. If the code has to be released to production before the EIP is falized, consider usg a random address to validate the contract, stead of one so close to the restricted range.  pull request #33  higher address as an valid signer  Duplicated Code to Get the Signer  signer  function that returns the address of the signer. This code is  duplicated  the  it  function.  Consider callg signer from the it function, stead of duplicatg the code.  Update: The RCN team decided not to fix this  order to save one jump operation.  Misleadg comment about destroyg the wallet  The Marmo contract has a special INVALID_ADDRESS. Accordg to the comments, the purpose of this address is to destroy the wallet. However, settg the signer to this valid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.  Consider updatg the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed  pull request #38.  Invalid address check uses assert  The relay function of the Marmo contract fails when the signer is the valid address. This failure is executed with the assert function, so if somebody calls an validated contract by mistake, they will lose their gas.  Consider usg require stead of assert to be more forgivg and return the remag gas when an validated contract is called. Also, the semantics of the require statement are closer to the tent of this feature.  Update: Fixed  pull request #34.  Relayed event is emitted before the action is executed  emits a  Relayed  event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signalg is executed.  Consider movg the emit of the Relayed event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an tent between two events.  Block on tent receipt can overflow  An tent receipt encodes the block  which it was relayed usg 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit  95 bits, which means that the block can overflow as mentioned  a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However,  the case of an overflow the relayedAt function will return wrong formation.  Consider beg extra safe by revertg when the block is bigger than the value that can be stored, or by storg the block  a ut256 variable. Or alternatively, consider documentg more thoroughly the effects of storg the block  95 bits.  Update: The RCN team decided not to implement a revert  this case due to the costs and complications of addressg somethg with this low probability.  Re-implementg ECDSA signature recovery  The Marmo project cludes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppel package, which has been audited and is constantly reviewed by the community.  Consider usg the recover function from OpenZeppel to reduce the code surface area.  An important pot related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppel implementation, and it is currently beg discussed with the community to fd the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documentg this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The MarmoStork contract has no way to check whether a wallet has been revealed.  Consider addg a mappg to save all the addresses of wallets that have been revealed. Consider emittg an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the tent. This means that an tent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider addg a nonce to the tent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sendg the same tent multiple times.  Notes & Additional Information  In the package.json file, ethlt and solium are listed as dependencies. Solium has been deprecated startg with version 1.2.0 on 20181225, and was renamed to Ethlt. Consider removg the Solium dependency.  The Truffle config file is full of comments and commented options comg from the template. Consider removg all the thgs that are not relevant for the developers of the Marmo project.  The docstrgs of the contracts are not followg the Ethereum Natural Specification Format (NatSpec). Consider followg this specification on everythg that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider addg all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifyg the code to use assert stead, to accurately reflect your tentions.  An tent receipt encodes the block  which it was relayed. When the tent is canceled, the block value is set to 0. Consider usg the receipt to also record the block  which the tent was canceled, which might be useful for user terfaces or other projects usg the system.  To favor explicitness and readability, several parts of the contracts may benefit from better namg. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.  signer to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.  Relayed to IntentRelayed.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifyg the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are usg the term meta-transactions stead of tents. While tent is a good name for this concept, consider renamg it to be more aligned with the ecosystem and what people are startg to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishg, the above review reflects the current understandg of known security patterns as they relate to the Marmo contracts. The above should not be construed as vestment advice. For general formation about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managg markets and risk with...  Security Audits  Truf Audit  The TruStakeMATICv2 and its supportg contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#in", "labels": ["OpenZeppelin"]}, {"title": "Marmo.sol", "body": "Marmo.sol", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#marmo.sol", "labels": ["OpenZeppelin"]}, {"title": "line 125", "body": "line 125", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#line-125", "labels": ["OpenZeppelin"]}, {"title": "0x20", "body": "0x20", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#0x20", "labels": ["OpenZeppelin"]}, {"title": "MarmoStork.sol", "body": "MarmoStork.sol", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#marmostork.sol", "labels": ["OpenZeppelin"]}, {"title": "line 82", "body": "line 82", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#line-82", "labels": ["OpenZeppelin"]}, {"title": "Restricted Address Range is in\u00a0Draft", "body": "Restricted Address Range is in\u00a0Draft", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#restricted-address-range-is-in\u00a0draft", "labels": ["OpenZeppelin"]}, {"title": "The Marmo contract can be made unusable by setting the signer to the invalid address 65536. This address was chosen because it is the first one after the restricted range, as defined by EIP1352: Specify restricted address range for precompiles/system contracts.", "body": "The Marmo contract can be made unusable by setting the signer to the invalid address 65536. This address was chosen because it is the first one after the restricted range, as defined by EIP1352: Specify restricted address range for precompiles/system contracts.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-marmo-contract-can-be-made-unusable-by-setting-the-signer-to-the-invalid-address-65536.-this-address-was-chosen-because-it-is-the-first-one-after-the-restricted-range,-as-defined-by-eip1352:-specify-restricted-address-range-for-precompiles/system-contracts.", "labels": ["OpenZeppelin"]}, {"title": "This EIP is still a draft, so there is a little risk of it changing in the future and making 65536 one of the restricted addresses. If the code has to be released to production before the EIP is finalized, consider using a random address to invalidate the contract, instead of one so close to the restricted range.", "body": "This EIP is still a draft, so there is a little risk of it changing in the future and making 65536 one of the restricted addresses. If the code has to be released to production before the EIP is finalized, consider using a random address to invalidate the contract, instead of one so close to the restricted range.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#this-eip-is-still-a-draft,-so-there-is-a-little-risk-of-it-changing-in-the-future-and-making-65536-one-of-the-restricted-addresses.-if-the-code-has-to-be-released-to-production-before-the-eip-is-finalized,-consider-using-a-random-address-to-invalidate-the-contract,-instead-of-one-so-close-to-the-restricted-range.", "labels": ["OpenZeppelin"]}, {"title": "pull request #33", "body": "pull request #33", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#pull-request-#33", "labels": ["OpenZeppelin"]}, {"title": "higher address as an invalid signer", "body": "higher address as an invalid signer", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#higher-address-as-an-invalid-signer", "labels": ["OpenZeppelin"]}, {"title": "Duplicated Code to Get the\u00a0Signer", "body": "Duplicated Code to Get the\u00a0Signer", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#duplicated-code-to-get-the\u00a0signer", "labels": ["OpenZeppelin"]}, {"title": "signer", "body": "Duplicated Code to Get the Signer    function that returns the address of the . This code is  duplicated in the  init  function.  Consider calling  from the init function, instead of duplicating the code.  Update: The RCN team decided not to fix this in order to save one jump operation.  Misleading comment about destroying the wallet  The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the  to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.  Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed in pull request #38.  Invalid address check uses assert  The relay function of the Marmo contract fails when the  is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.  Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.  Update: Fixed in pull request #34.  Relayed event is emitted before the action is executed  emits a  Relayed  event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.  Consider moving the emit of the Relayed event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an intent between two events.  Block on intent receipt can overflow  An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.  Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.  Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.  Re-implementing ECDSA signature recovery  The Marmo project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.  Consider using the recover function from OpenZeppelin to reduce the code surface area.  An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The MarmoStork contract has no way to check whether a wallet has been revealed.  Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.  Notes & Additional Information  In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 20181225, and was renamed to Ethlint. Consider removing the Solium dependency.  The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.  The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.  An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.   to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.  Relayed to IntentRelayed.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Marmo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#signer", "labels": ["OpenZeppelin"]}, {"title": "function that returns the address of the signer. This code is", "body": "function that returns the address of the signer. This code is", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#function-that-returns-the-address-of-the-signer.-this-code-is", "labels": ["OpenZeppelin"]}, {"title": "duplicated in the", "body": "duplicated in the", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#duplicated-in-the", "labels": ["OpenZeppelin"]}, {"title": "init", "body": "init", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#init", "labels": ["OpenZeppelin"]}, {"title": "function.", "body": "Update: Fixed in pull request #29.  MarmoStork does not check the size of the implementation contract address explicitly  The constructor of the MarmoStork contract takes an array of bytes in the _source argument, and uses it as the destination address for a delegatecall. An ethereum address has 20 bytes, but the size of this array is not checked at the beginning of the   The length of this _source argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resulting bytecode will have an unintended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulating the length. But, for example, taking the part that generates the opcode that should push the address to the stack when the _source array length is bigger than that of a valid address, it can even result in the selfdestruct opcode instead of the expected push20.  Later in the constructor, this argument is converted to an address calling the toAddress function which does require the length to be 20 or less. So a bigger array will end up reverting the constructor, but this does not happen explicitly and because of that it has the risk of being removed by mistake.  Consider changing the type of the _source parameter to address. This will make the expectations clear and prevent any issues derived from invalid addresses. Alternatively, consider requiring the array to be 20 bytes at the start of the constructor, following best practices to fail early and to structure your functions starting with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.  pull request #30  constructor of MarmoStork  Low Severity  README is empty  The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.  The README.md of the Marmo contracts has no information about what is the purpose of the project nor how to use it.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to the parts of the project.  Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.  README file  Standard Readme  There are hard-coded values in the code  There are hard-coded values in several Marmo contracts. For example, 65536 and 0xff. These values make the code harder to understand and to maintain.  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For complex values, consider adding a comment explaining how were they calculated or why were they chosen.  #33  #37  32  in  Marmo.sol  line 125  0x20  in  MarmoStork.sol  line 82  Restricted Address Range is in Draft  The Marmo contract can be made unusable by setting the signer to the invalid address 65536. This address was chosen because it is the first one after the restricted range, as defined by EIP1352: Specify restricted address range for precompiles/system contracts.  This EIP is still a draft, so there is a little risk of it changing in the future and making 65536 one of the restricted addresses. If the code has to be released to production before the EIP is finalized, consider using a random address to invalidate the contract, instead of one so close to the restricted range.  pull request #33  higher address as an invalid signer  Duplicated Code to Get the Signer  signer  function that returns the address of the signer. This code is  duplicated in the  init    Consider calling signer from the init function, instead of duplicating the code.  Update: The RCN team decided not to fix this in order to save one jump operation.  Misleading comment about destroying the wallet  The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.  Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed in pull request #38.  Invalid address check uses assert  The relay function of the Marmo contract fails when the signer is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.  Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.  Update: Fixed in pull request #34.  Relayed event is emitted before the action is executed  emits a  Relayed  event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.  Consider moving the emit of the Relayed event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an intent between two events.  Block on intent receipt can overflow  An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.  Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.  Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.  Re-implementing ECDSA signature recovery  The Marmo project includes an implementation of the ECDSA signature recovery  This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.  Consider using the recover function from OpenZeppelin to reduce the code surface area.  An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The MarmoStork contract has no way to check whether a wallet has been revealed.  Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.  Notes & Additional Information  In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 20181225, and was renamed to Ethlint. Consider removing the Solium dependency.  The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.  The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.  An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.  signer to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.  Relayed to IntentRelayed.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Marmo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#function.", "labels": ["OpenZeppelin"]}, {"title": "Consider calling signer from the init function, instead of duplicating the code.", "body": "Consider calling signer from the init function, instead of duplicating the code.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-calling-signer-from-the-init-function,-instead-of-duplicating-the-code.", "labels": ["OpenZeppelin"]}, {"title": "Update: The RCN team decided not to fix this in order to save one jump operation.", "body": "Update: The RCN team decided not to fix this in order to save one jump operation.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-the-rcn-team-decided-not-to-fix-this-in-order-to-save-one-jump-operation.", "labels": ["OpenZeppelin"]}, {"title": "Misleading comment about destroying the\u00a0wallet", "body": "Misleading comment about destroying the\u00a0wallet", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#misleading-comment-about-destroying-the\u00a0wallet", "labels": ["OpenZeppelin"]}, {"title": "The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.", "body": "The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-marmo-contract-has-a-special-invalid_address.-according-to-the-comments,-the-purpose-of-this-address-is-to-destroy-the-wallet.-however,-setting-the-signer-to-this-invalid-address-does-not-destroy-the-wallet.-instead,-it-does-make-it-impossible-to-relay-any-further-transactions,-but-the-wallet-contract-still-exists.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.", "body": "Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-updating-the-comments-to-more-accurately-describe-the-purpose-and-effect-of-the-invalid_address.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #38.", "body": "Update: Fixed in pull request #38.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-fixed-in-pull-request-#38.", "labels": ["OpenZeppelin"]}, {"title": "Invalid address check uses\u00a0assert", "body": "Invalid address check uses\u00a0assert", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#invalid-address-check-uses\u00a0assert", "labels": ["OpenZeppelin"]}, {"title": "The relay function of the Marmo contract fails when the signer is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.", "body": "The relay function of the Marmo contract fails when the signer is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-relay-function-of-the-marmo-contract-fails-when-the-signer-is-the-invalid-address.-this-failure-is-executed-with-the-assert-function,-so-if-somebody-calls-an-invalidated-contract-by-mistake,-they-will-lose-their-gas.", "labels": ["OpenZeppelin"]}, {"title": "Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.", "body": "Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-using-require-instead-of-assert-to-be-more-forgiving-and-return-the-remaining-gas-when-an-invalidated-contract-is-called.-also,-the-semantics-of-the-require-statement-are-closer-to-the-intent-of-this-feature.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #34.", "body": "Update: Fixed in pull request #34.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-fixed-in-pull-request-#34.", "labels": ["OpenZeppelin"]}, {"title": "Relayed event is emitted before the action is\u00a0executed", "body": "Relayed event is emitted before the action is\u00a0executed", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#relayed-event-is-emitted-before-the-action-is\u00a0executed", "labels": ["OpenZeppelin"]}, {"title": "emits a", "body": "emits a", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#emits-a", "labels": ["OpenZeppelin"]}, {"title": "Relayed", "body": "event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.  Consider moving the emit of the  event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an intent between two events.  Block on intent receipt can overflow  An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.  Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.  Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.  Re-implementing ECDSA signature recovery  The Marmo project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.  Consider using the recover function from OpenZeppelin to reduce the code surface area.  An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The MarmoStork contract has no way to check whether a wallet has been revealed.  Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.  Notes & Additional Information  In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 20181225, and was renamed to Ethlint. Consider removing the Solium dependency.  The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.  The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.  An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.  signer to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.   to Intent.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Marmo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#relayed", "labels": ["OpenZeppelin"]}, {"title": "event. This event is emitted before the", "body": "event. This event is emitted before the", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#event.-this-event-is-emitted-before-the", "labels": ["OpenZeppelin"]}, {"title": "reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.", "body": "reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#reentrancy-protection,-it-is-safer-and-clearer-to-emit-events-immediately-after-the-action-they-are-signaling-is-executed.", "labels": ["OpenZeppelin"]}, {"title": "Consider moving the emit of the Relayed event immediately after the delegatecall statement.", "body": "Consider moving the emit of the Relayed event immediately after the delegatecall statement.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-moving-the-emit-of-the-relayed-event-immediately-after-the-delegatecall-statement.", "labels": ["OpenZeppelin"]}, {"title": "Update: This is by design. The RCN team wants to have the execution of an intent between two events.", "body": "Update: This is by design. The RCN team wants to have the execution of an intent between two events.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-this-is-by-design.-the-rcn-team-wants-to-have-the-execution-of-an-intent-between-two-events.", "labels": ["OpenZeppelin"]}, {"title": "Block on intent receipt can\u00a0overflow", "body": "Block on intent receipt can\u00a0overflow", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#block-on-intent-receipt-can\u00a0overflow", "labels": ["OpenZeppelin"]}, {"title": "An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.", "body": "An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#an-intent-receipt-encodes-the-block-in-which-it-was-relayed-using-95-bits.-theoretically,-the-block-numbers-can-be-bigger-than-the-maximum-number-that-can-fit-in-95-bits,-which-means-that-the-block-can-overflow-as-mentioned-in-a-comment.", "labels": ["OpenZeppelin"]}, {"title": "It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.", "body": "It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the Marmo contract. However, in the case of an overflow the relayedAt function will return wrong information.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#it-is-more-likely-that-the-ethereum-ecosystem-will-be-completely-different-before-we-get-to-that-many-blocks,-and-it-is-true-that-an-overflow-will-not-affect-the-assumptions-and-conditions-of-the-marmo-contract.-however,-in-the-case-of-an-overflow-the-relayedat-function-will-return-wrong-information.", "labels": ["OpenZeppelin"]}, {"title": "Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.", "body": "Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-being-extra-safe-by-reverting-when-the-block-is-bigger-than-the-value-that-can-be-stored,-or-by-storing-the-block-in-a-uint256-variable.-or-alternatively,-consider-documenting-more-thoroughly-the-effects-of-storing-the-block-in-95-bits.", "labels": ["OpenZeppelin"]}, {"title": "Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.", "body": "Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-the-rcn-team-decided-not-to-implement-a-revert-in-this-case-due-to-the-costs-and-complications-of-addressing-something-with-this-low-probability.", "labels": ["OpenZeppelin"]}, {"title": "Re-implementing ECDSA signature recovery", "body": "Re-implementing ECDSA signature recovery", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#re-implementing-ecdsa-signature-recovery", "labels": ["OpenZeppelin"]}, {"title": "The Marmo project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.", "body": "The Marmo project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-marmo-project-includes-an-implementation-of-the-ecdsa-signature-recovery-function.-this-function-is-already-part-of-the-openzeppelin-package,-which-has-been-audited-and-is-constantly-reviewed-by-the-community.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the recover function from OpenZeppelin to reduce the code surface area.", "body": "Consider using the recover function from OpenZeppelin to reduce the code surface area.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-using-the-recover-function-from-openzeppelin-to-reduce-the-code-surface-area.", "labels": ["OpenZeppelin"]}, {"title": "An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.", "body": "An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the Marmo contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#an-important-point-related-to-this-implementation-is-that-it-is-subject-to-signature-malleability,-which-means-that-multiple-signatures-will-be-considered-valid.-this-also-affects-the-openzeppelin-implementation,-and-it-is-currently-being-discussed-with-the-community-to-find-the-best-solution.-this-issue-does-not-affect-the-marmo-contracts-because-the-signatures-are-not-used-as-if-they-were-unique.-however,-consider-documenting-this-to-make-it-clear-that-higher-layer-applications-should-not-consider-the-signatures-unique-either.", "labels": ["OpenZeppelin"]}, {"title": "Update: The RCN team decided not to add external dependencies to their project.", "body": "Update: The RCN team decided not to add external dependencies to their project.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-the-rcn-team-decided-not-to-add-external-dependencies-to-their-project.", "labels": ["OpenZeppelin"]}, {"title": "No way to check whether a wallet has been\u00a0revealed", "body": "No way to check whether a wallet has been\u00a0revealed", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#no-way-to-check-whether-a-wallet-has-been\u00a0revealed", "labels": ["OpenZeppelin"]}, {"title": "The MarmoStork contract has no way to check whether a wallet has been revealed.", "body": "The MarmoStork contract has no way to check whether a wallet has been revealed.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-marmostork-contract-has-no-way-to-check-whether-a-wallet-has-been-revealed.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.", "body": "Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-adding-a-mapping-to-save-all-the-addresses-of-wallets-that-have-been-revealed.-consider-emitting-an-event-after-a-wallet-is-revealed.", "labels": ["OpenZeppelin"]}, {"title": "Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.", "body": "Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-the-rcn-team-considers-this-functionality-unnecessary-because-extcodesize-allows-to-check-if-an-address-has-code.", "labels": ["OpenZeppelin"]}, {"title": "Transactions can be relayed only\u00a0once", "body": "Transactions can be relayed only\u00a0once", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#transactions-can-be-relayed-only\u00a0once", "labels": ["OpenZeppelin"]}, {"title": "The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.", "body": "The relay function of the Marmo contract uses the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-relay-function-of-the-marmo-contract-uses-the-address-of-the-wallet,-the-address-of-the-implementation,-and-the-signed-transaction-data-as-the-id-of-the-intent.-this-means-that-an-intent-can-be-relayed-only-once.", "labels": ["OpenZeppelin"]}, {"title": "This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.", "body": "This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#this-is-correct-to-prevent-replay-attacks.-however,-note-that-there-will-be-many-valid-cases-to-call-the-same-transaction-multiple-times.-consider-adding-a-nonce-to-the-intent-data,-to-allow-users-to-relay-the-same-transaction-securely.", "labels": ["OpenZeppelin"]}, {"title": "Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.", "body": "Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-the-marmo-sdk-adds-a-salt-to-the-transaction-data-to-allow-sending-the-same-intent-multiple-times.", "labels": ["OpenZeppelin"]}, {"title": "In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 2018\u201312\u201325, and was renamed to Ethlint. Consider removing the Solium dependency.", "body": "In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 2018\u201312\u201325, and was renamed to Ethlint. Consider removing the Solium dependency.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#in-the-package.json-file,-ethlint-and-solium-are-listed-as-dependencies.-solium-has-been-deprecated-starting-with-version-1.2.0-on-2018\u201312\u201325,-and-was-renamed-to-ethlint.-consider-removing-the-solium-dependency.", "labels": ["OpenZeppelin"]}, {"title": "The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.", "body": "The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-truffle-config-file-is-full-of-comments-and-commented-options-coming-from-the-template.-consider-removing-all-the-things-that-are-not-relevant-for-the-developers-of-the-marmo-project.", "labels": ["OpenZeppelin"]}, {"title": "The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts\u2019 public API.", "body": "The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts\u2019 public API.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-docstrings-of-the-contracts-are-not-following-the-ethereum-natural-specification-format-(natspec).-consider-following-this-specification-on-everything-that-is-part-of-the-contracts\u2019-public-api.", "labels": ["OpenZeppelin"]}, {"title": "In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.", "body": "In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#in-the-marmo-contract,-there-are-two-cases-that-call-revert(\"unknown-error\");-(l95-and-l138).-while-it-is-a-good-safeguard-to-catch-unexpected-conditions,-these-states-should-be-impossible-to-reach.-with-a-unit-test-suite-that-covers-all-the-possible-code-paths,-the-impossibility-of-those-states-can-be-verified.-consider-adding-all-the-required-unit-tests-to-safely-remove-the-revert-statements.-if-you-prefer-to-stay-extra-safe-and-keep-these-statements,-consider-modifying-the-code-to-use-assert-instead,-to-accurately-reflect-your-intentions.", "labels": ["OpenZeppelin"]}, {"title": "An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.", "body": "An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#an-intent-receipt-encodes-the-block-in-which-it-was-relayed.-when-the-intent-is-canceled,-the-block-value-is-set-to-0.-consider-using-the-receipt-to-also-record-the-block-in-which-the-intent-was-canceled,-which-might-be-useful-for-user-interfaces-or-other-projects-using-the-system.", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are: \u2013 MarmoStork to MarmoWalletFactory. \u2013 bytecode to deploymentBytecode. \u2013 marmo to marmoWalletImplementation. \u2013 marmoOf to getMarmoWalletAddress. \u2013 reveal to createMarmoWallet. \u2013 p to marmoWallet. \u2013 Marmo to MarmoWallet. \u2013 signer to existentSigner. \u2013 relayedBy to getIntentRelayer. \u2013 relayedAt to getBlockOfIntentExecution. \u2013 Relayed to IntentRelayed. \u2013 Canceled to IntentCanceled. \u2013 isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid. \u2013 relay to relayIntent. \u2013 _implementation to _executor. \u2013 MarmoImp to MarmoExecutor. \u2013 Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are: \u2013 MarmoStork to MarmoWalletFactory. \u2013 bytecode to deploymentBytecode. \u2013 marmo to marmoWalletImplementation. \u2013 marmoOf to getMarmoWalletAddress. \u2013 reveal to createMarmoWallet. \u2013 p to marmoWallet. \u2013 Marmo to MarmoWallet. \u2013 signer to existentSigner. \u2013 relayedBy to getIntentRelayer. \u2013 relayedAt to getBlockOfIntentExecution. \u2013 Relayed to IntentRelayed. \u2013 Canceled to IntentCanceled. \u2013 isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid. \u2013 relay to relayIntent. \u2013 _implementation to _executor. \u2013 MarmoImp to MarmoExecutor. \u2013 Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#to-favor-explicitness-and-readability,-several-parts-of-the-contracts-may-benefit-from-better-naming.-our-suggestions-are:-\u2013-marmostork-to-marmowalletfactory.-\u2013-bytecode-to-deploymentbytecode.-\u2013-marmo-to-marmowalletimplementation.-\u2013-marmoof-to-getmarmowalletaddress.-\u2013-reveal-to-createmarmowallet.-\u2013-p-to-marmowallet.-\u2013-marmo-to-marmowallet.-\u2013-signer-to-existentsigner.-\u2013-relayedby-to-getintentrelayer.-\u2013-relayedat-to-getblockofintentexecution.-\u2013-relayed-to-intentrelayed.-\u2013-canceled-to-intentcanceled.-\u2013-iscanceled-to-isintentcanceled.-maybe-even-consider-here-modifying-the-implementation-to-avoid-the-negative,-and-call-it-isintentvalid.-\u2013-relay-to-relayintent.-\u2013-_implementation-to-_executor.-\u2013-marmoimp-to-marmoexecutor.-\u2013-receipt-to-intentexecuted.-note-that-most-of-the-projects-similar-to-marmo-are-using-the-term-meta-transactions-instead-of-intents.-while-intent-is-a-good-name-for-this-concept,-consider-renaming-it-to-be-more-aligned-with-the-ecosystem-and-what-people-are-starting-to-expect.", "labels": ["OpenZeppelin"]}, {"title": "None.", "body": "Medium Severity  Missing zero address checks  In several places in the code, addresses are passed as parameters to functions. In many of these instances, the functions do not validate that the passed address is not the address 0. In the Controller contract, this happens in functions configureController (which only checks _worker) and removeController.  In the MintController contract, on the other hand, it might be expected that the constructor sets the minterManager variable to 0, but the setMinterManager function does not prevent setting it to 0.  While this does not currently pose a security risk, consider adding checks for the passed addresses being nonzero to prevent unexpected behavior where required, or documenting the fact that a zero address is indeed a valid parameter.  all  passed  arguments  No way to decrement an allowance without reconfiguring minter  The MintController contract provides a mechanism to increment a minters allowance that only works if the minter is active, thus preventing the accidental reactivation of inactive minters, and, as described in the inline documentation, the usage of a signed transaction to reactivate a minter. This mechanism is implemented in the incrementMinterAllowance function, which in turn calls minterManager.isMinter to perform the required check.  The contract, however, provides no analogous mechanism for decreasing a minters allowance, meaning that this can only be achieved by resetting the minter through the configureMinter function.  It might well be that this is intended design and that decrementing minter allowances does not make sense in context; if this is not the case, however, consider providing this complementary functionality.  Update: the decrementMinterAllowance function was introduced to handle allowance decrements without risking undesired minter reactivation. Its implementation is such that, if the value by which to decrement the allowance is greater than the current allowance, the latter is set to zero. Consider documenting this behavior inline.  Note that no checks are here performed as to whether allowance decrements are taking place after tokens were already minted, since the actual minting logic is handled elsewhere. The interaction between minting and allowance management is outside the scope of this audit, consider running a full security audit on the corresponding contracts as well, if not done already.  Low Severity  Experimental version of Ownable used  custom version of  Ownable, which was taken from the  labs  repository of ZeppelinOS and later edited. This is experimental code, and, as stated in the  README, not meant for production. As a side note, the import is made with  Given that the project is already using OpenZeppelin, consider using its well-tested version of Ownable.  Lack of check might lead to gas burn  The incrementMinterAllowance function can be called with a parameter value of allowanceIncrement = 0. This would lead to gas expenditure with no state changes or useful computation.  Consider checking that allowanceIncrement > 0 to avoid unnecessary gas costs.  now requires  Missing error messages in require statements  43 and  57 in  94 in  Update: all require statements now provide messages for the reverts.  Unaudited version of OpenZeppelin used  The repository in which the audited contracts are held is using openzeppelin-solidity v1.11.0. This is an outdated release, and was never audited. At the time of writing the latest stable version is v2.0.0, which has gone through an external security audit.  Consider updating the project to the newer, audited version.  Room for improvement in contracts documentation  The Centre Token minting contracts are in general well documented, and the documentation adheres to the NatSpec format. There is, however, room for improvement. First, MasterMinter.sol has no documentation at all. Second, while all contracts have a short description of each function, all comments make use of only the @dev tag among the many available in NatSpec.  Yet another instance where documentation can be improved is the following comment in Controller.sol:set the controller of a particular _worker. This might lead the user to think that each worker has a single controller, while the system in fact allows it to have more than one.  Finally, the comment allows control of configure/remove minter\u2026 in MintController seems to refer to the configureMinter and removeMinter functions, but these are not referenced using their full names.  Consider adding complete docstrings for all contracts, struct fields, state variables, mapping keys and functions, and having comments more clearly and faithfully represent the functionality of the contracts.  two  occasions  Notes & Additional Information:  Controller.sol, MintController.sol and MasterMinter.sol are using an outdated Solidity release: v0.4.24. Consider using the latest version of the Solidity compiler (v0.5.2 at the time of writing) throughout the code. removeController does not check if the controller is set before removal, allowing for subsequent calls to the function, which will confusingly emit repeated ControllerRemoved events with the same address. Consider whether this check should be included in order to avoid this behavior. Update: a check was added to prevent this behavior.  Controller explicitly defines an empty constructor, which, according to the Solidity docs, is exactly what the contract would assume if this piece of code was absent. Consider removing the empty constructor for clarity. Update: the empty constructor was removed.  Several functions (configureController and removeController in Controller, and setMinterManager in MintController) return hardcoded boolean values. Consider documenting this if it arises from the need of conforming to an interface. Update: these functions no longer return a boolean.  Several functions in the code (configureController and removeController in Controller, and setMinterManager, removeMinter, configureMinter, and incrementMinterAllowance in MintController.sol) are marked as public, but are never called from within the contract hierarchy. Consider making these functions external if they are only to be called from other contracts.  Consider moving MinterManagementInterface to an individual file and importing it from MinterController.sol, thus allowing it to be cleanly imported from other files in the project. Update: the interface now lives in its own MinterManagementInterface.sol file.  Consider restricting the visibility of the controllers and minterManager variables to internal or private and providing the required getter functions as a good encapsulation practice. Update: these variables are now internal, and the corresponding getters are in place.  In line 61 of MintController, the minterManager variable is implicitly converted to the address type. Starting from Solidity version v0.5.0, implicit address conversions issue an error. Consider explicitly casting minterManager to the address type in case the decision is later made to use a newer version of Solidity. Update: the casting is now done explicitly.  Repeatedly in the code (Controller.sol lines 56, 66; MintController.sol lines 60, 71, 80, 92), the public keyword appears after the custom modifiers. According to the Solidity docs on Function declaration, however, The visibility modifier for a function should come before other modifiers. Update: the ordering of the modifiers now conforms to the suggested one.  The line wrapping is inconsistent in the codebase. Comments appear to be wrapped at around 86 characters but some parts of the code extend beyond that limit (e.g. line 49 of MintController.sol, which goes to 128). Consider adhering to a single limit and applying it throughout. The recommended width is 80 columns. Update: line wrapping is now consistent throughout.  There is an inconsistency in function parameter naming. In Controller they all start with an underscore, while in MintController only those of constructor and setMinterManager do. Consider using underscores in all parameter names. Update: all parameter names now start with underscores, except only for those of the new MinterAllowanceDecremented event. Apart from this, there is an extra blank line between the declaration of this new event and the preceding ones.  All import statements use single quotes, double quotes are recommended in the Solidity Style Guide. Update: import statements now use double quotes.  There is a double space in line 52 of MintController.sol. Update: the double space was removed.  Functions incrementMinterAllowance and internal_setMinterAllowance in MintController are not correctly indented. Update: these indentation issues were resolved.  Conclusion  No critical or high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Centre Token minting contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#none.", "labels": ["OpenZeppelin"]}, {"title": "Missing zero address\u00a0checks", "body": "Missing zero address\u00a0checks", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#missing-zero-address\u00a0checks", "labels": ["OpenZeppelin"]}, {"title": "In several places in the code, addresses are passed as parameters to functions. In many of these instances, the functions do not validate that the passed address is not the address 0. In the Controller contract, this happens in functions configureController (which only checks _worker) and removeController.", "body": "In several places in the code, addresses are passed as parameters to functions. In many of these instances, the functions do not validate that the passed address is not the address 0. In the Controller contract, this happens in functions configureController (which only checks _worker) and removeController.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#in-several-places-in-the-code,-addresses-are-passed-as-parameters-to-functions.-in-many-of-these-instances,-the-functions-do-not-validate-that-the-passed-address-is-not-the-address-0.-in-the-controller-contract,-this-happens-in-functions-configurecontroller-(which-only-checks-_worker)-and-removecontroller.", "labels": ["OpenZeppelin"]}, {"title": "In the MintController contract, on the other hand, it might be expected that the constructor sets the minterManager variable to 0, but the setMinterManager function does not prevent setting it to 0.", "body": "In the MintController contract, on the other hand, it might be expected that the constructor sets the minterManager variable to 0, but the setMinterManager function does not prevent setting it to 0.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#in-the-mintcontroller-contract,-on-the-other-hand,-it-might-be-expected-that-the-constructor-sets-the-mintermanager-variable-to-0,-but-the-setmintermanager-function-does-not-prevent-setting-it-to-0.", "labels": ["OpenZeppelin"]}, {"title": "While this does not currently pose a security risk, consider adding checks for the passed addresses being nonzero to prevent unexpected behavior where required, or documenting the fact that a zero address is indeed a valid parameter.", "body": "While this does not currently pose a security risk, consider adding checks for the passed addresses being nonzero to prevent unexpected behavior where required, or documenting the fact that a zero address is indeed a valid parameter.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#while-this-does-not-currently-pose-a-security-risk,-consider-adding-checks-for-the-passed-addresses-being-nonzero-to-prevent-unexpected-behavior-where-required,-or-documenting-the-fact-that-a-zero-address-is-indeed-a-valid-parameter.", "labels": ["OpenZeppelin"]}, {"title": "all", "body": "all", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#all", "labels": ["OpenZeppelin"]}, {"title": "passed", "body": "address is not the address 0. In the Controller contract, this happens in functions configureController (which only checks _worker) and removeController.  In the MintController contract, on the other hand, it might be expected that the constructor sets the minterManager variable to 0, but the setMinterManager function does not prevent setting it to 0.  While this does not currently pose a security risk, consider adding checks for the  addresses being nonzero to prevent unexpected behavior where required, or documenting the fact that a zero address is indeed a valid parameter.  all    arguments  No way to decrement an allowance without reconfiguring minter  The MintController contract provides a mechanism to increment a minters allowance that only works if the minter is active, thus preventing the accidental reactivation of inactive minters, and, as described in the inline documentation, the usage of a signed transaction to reactivate a minter. This mechanism is implemented in the incrementMinterAllowance function, which in turn calls minterManager.isMinter to perform the required check.  The contract, however, provides no analogous mechanism for decreasing a minters allowance, meaning that this can only be achieved by resetting the minter through the configureMinter function.  It might well be that this is intended design and that decrementing minter allowances does not make sense in context; if this is not the case, however, consider providing this complementary functionality.  Update: the decrementMinterAllowance function was introduced to handle allowance decrements without risking undesired minter reactivation. Its implementation is such that, if the value by which to decrement the allowance is greater than the current allowance, the latter is set to zero. Consider documenting this behavior inline.  Note that no checks are here performed as to whether allowance decrements are taking place after tokens were already minted, since the actual minting logic is handled elsewhere. The interaction between minting and allowance management is outside the scope of this audit, consider running a full security audit on the corresponding contracts as well, if not done already.  Low Severity  Experimental version of Ownable used  custom version of  Ownable, which was taken from the  labs  repository of ZeppelinOS and later edited. This is experimental code, and, as stated in the  README, not meant for production. As a side note, the import is made with  Given that the project is already using OpenZeppelin, consider using its well-tested version of Ownable.  Lack of check might lead to gas burn  The incrementMinterAllowance function can be called with a parameter value of allowanceIncrement = 0. This would lead to gas expenditure with no state changes or useful computation.  Consider checking that allowanceIncrement > 0 to avoid unnecessary gas costs.  now requires  Missing error messages in require statements  43 and  57 in  94 in  Update: all require statements now provide messages for the reverts.  Unaudited version of OpenZeppelin used  The repository in which the audited contracts are held is using openzeppelin-solidity v1.11.0. This is an outdated release, and was never audited. At the time of writing the latest stable version is v2.0.0, which has gone through an external security audit.  Consider updating the project to the newer, audited version.  Room for improvement in contracts documentation  The Centre Token minting contracts are in general well documented, and the documentation adheres to the NatSpec format. There is, however, room for improvement. First, MasterMinter.sol has no documentation at all. Second, while all contracts have a short description of each function, all comments make use of only the @dev tag among the many available in NatSpec.  Yet another instance where documentation can be improved is the following comment in Controller.sol:set the controller of a particular _worker. This might lead the user to think that each worker has a single controller, while the system in fact allows it to have more than one.  Finally, the comment allows control of configure/remove minter\u2026 in MintController seems to refer to the configureMinter and removeMinter functions, but these are not referenced using their full names.  Consider adding complete docstrings for all contracts, struct fields, state variables, mapping keys and functions, and having comments more clearly and faithfully represent the functionality of the contracts.  two  occasions  Notes & Additional Information:  Controller.sol, MintController.sol and MasterMinter.sol are using an outdated Solidity release: v0.4.24. Consider using the latest version of the Solidity compiler (v0.5.2 at the time of writing) throughout the code. removeController does not check if the controller is set before removal, allowing for subsequent calls to the function, which will confusingly emit repeated ControllerRemoved events with the same address. Consider whether this check should be included in order to avoid this behavior. Update: a check was added to prevent this behavior.  Controller explicitly defines an empty constructor, which, according to the Solidity docs, is exactly what the contract would assume if this piece of code was absent. Consider removing the empty constructor for clarity. Update: the empty constructor was removed.  Several functions (configureController and removeController in Controller, and setMinterManager in MintController) return hardcoded boolean values. Consider documenting this if it arises from the need of conforming to an interface. Update: these functions no longer return a boolean.  Several functions in the code (configureController and removeController in Controller, and setMinterManager, removeMinter, configureMinter, and incrementMinterAllowance in MintController.sol) are marked as public, but are never called from within the contract hierarchy. Consider making these functions external if they are only to be called from other contracts.  Consider moving MinterManagementInterface to an individual file and importing it from MinterController.sol, thus allowing it to be cleanly imported from other files in the project. Update: the interface now lives in its own MinterManagementInterface.sol file.  Consider restricting the visibility of the controllers and minterManager variables to internal or private and providing the required getter functions as a good encapsulation practice. Update: these variables are now internal, and the corresponding getters are in place.  In line 61 of MintController, the minterManager variable is implicitly converted to the address type. Starting from Solidity version v0.5.0, implicit address conversions issue an error. Consider explicitly casting minterManager to the address type in case the decision is later made to use a newer version of Solidity. Update: the casting is now done explicitly.  Repeatedly in the code (Controller.sol lines 56, 66; MintController.sol lines 60, 71, 80, 92), the public keyword appears after the custom modifiers. According to the Solidity docs on Function declaration, however, The visibility modifier for a function should come before other modifiers. Update: the ordering of the modifiers now conforms to the suggested one.  The line wrapping is inconsistent in the codebase. Comments appear to be wrapped at around 86 characters but some parts of the code extend beyond that limit (e.g. line 49 of MintController.sol, which goes to 128). Consider adhering to a single limit and applying it throughout. The recommended width is 80 columns. Update: line wrapping is now consistent throughout.  There is an inconsistency in function parameter naming. In Controller they all start with an underscore, while in MintController only those of constructor and setMinterManager do. Consider using underscores in all parameter names. Update: all parameter names now start with underscores, except only for those of the new MinterAllowanceDecremented event. Apart from this, there is an extra blank line between the declaration of this new event and the preceding ones.  All import statements use single quotes, double quotes are recommended in the Solidity Style Guide. Update: import statements now use double quotes.  There is a double space in line 52 of MintController.sol. Update: the double space was removed.  Functions incrementMinterAllowance and internal_setMinterAllowance in MintController are not correctly indented. Update: these indentation issues were resolved.  Conclusion  No critical or high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Centre Token minting contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#passed", "labels": ["OpenZeppelin"]}, {"title": "arguments", "body": "arguments", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#arguments", "labels": ["OpenZeppelin"]}, {"title": "No way to decrement an allowance without reconfiguring minter", "body": "No way to decrement an allowance without reconfiguring minter", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#no-way-to-decrement-an-allowance-without-reconfiguring-minter", "labels": ["OpenZeppelin"]}, {"title": "The MintController contract provides a mechanism to increment a minter\u2019s allowance that only works if the minter is active, thus preventing the accidental reactivation of inactive minters, and, as described in the inline documentation, the usage of a signed transaction to reactivate a minter. This mechanism is implemented in the incrementMinterAllowance function, which in turn calls minterManager.isMinter to perform the required check.", "body": "The MintController contract provides a mechanism to increment a minter\u2019s allowance that only works if the minter is active, thus preventing the accidental reactivation of inactive minters, and, as described in the inline documentation, the usage of a signed transaction to reactivate a minter. This mechanism is implemented in the incrementMinterAllowance function, which in turn calls minterManager.isMinter to perform the required check.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#the-mintcontroller-contract-provides-a-mechanism-to-increment-a-minter\u2019s-allowance-that-only-works-if-the-minter-is-active,-thus-preventing-the-accidental-reactivation-of-inactive-minters,-and,-as-described-in-the-inline-documentation,-the-usage-of-a-signed-transaction-to-reactivate-a-minter.-this-mechanism-is-implemented-in-the-incrementminterallowance-function,-which-in-turn-calls-mintermanager.isminter-to-perform-the-required-check.", "labels": ["OpenZeppelin"]}, {"title": "The contract, however, provides no analogous mechanism for decreasing a minter\u2019s allowance, meaning that this can only be achieved by \u201cresetting\u201d the minter through the configureMinter function.", "body": "The contract, however, provides no analogous mechanism for decreasing a minter\u2019s allowance, meaning that this can only be achieved by \u201cresetting\u201d the minter through the configureMinter function.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#the-contract,-however,-provides-no-analogous-mechanism-for-decreasing-a-minter\u2019s-allowance,-meaning-that-this-can-only-be-achieved-by-\u201cresetting\u201d-the-minter-through-the-configureminter-function.", "labels": ["OpenZeppelin"]}, {"title": "It might well be that this is intended design and that decrementing minter allowances does not make sense in context; if this is not the case, however, consider providing this complementary functionality.", "body": "It might well be that this is intended design and that decrementing minter allowances does not make sense in context; if this is not the case, however, consider providing this complementary functionality.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#it-might-well-be-that-this-is-intended-design-and-that-decrementing-minter-allowances-does-not-make-sense-in-context;-if-this-is-not-the-case,-however,-consider-providing-this-complementary-functionality.", "labels": ["OpenZeppelin"]}, {"title": "Update: the decrementMinterAllowance function was introduced to handle allowance decrements without risking undesired minter reactivation. Its implementation is such that, if the value by which to decrement the allowance is greater than the current allowance, the latter is set to zero. Consider documenting this behavior inline.", "body": "Update: the decrementMinterAllowance function was introduced to handle allowance decrements without risking undesired minter reactivation. Its implementation is such that, if the value by which to decrement the allowance is greater than the current allowance, the latter is set to zero. Consider documenting this behavior inline.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#update:-the-decrementminterallowance-function-was-introduced-to-handle-allowance-decrements-without-risking-undesired-minter-reactivation.-its-implementation-is-such-that,-if-the-value-by-which-to-decrement-the-allowance-is-greater-than-the-current-allowance,-the-latter-is-set-to-zero.-consider-documenting-this-behavior-inline.", "labels": ["OpenZeppelin"]}, {"title": "Note that no checks are here performed as to whether allowance decrements are taking place after tokens were already minted, since the actual minting logic is handled elsewhere. The interaction between minting and allowance management is outside the scope of this audit, consider running a full security audit on the corresponding contracts as well, if not done already.", "body": "Note that no checks are here performed as to whether allowance decrements are taking place after tokens were already minted, since the actual minting logic is handled elsewhere. The interaction between minting and allowance management is outside the scope of this audit, consider running a full security audit on the corresponding contracts as well, if not done already.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#note-that-no-checks-are-here-performed-as-to-whether-allowance-decrements-are-taking-place-after-tokens-were-already-minted,-since-the-actual-minting-logic-is-handled-elsewhere.-the-interaction-between-minting-and-allowance-management-is-outside-the-scope-of-this-audit,-consider-running-a-full-security-audit-on-the-corresponding-contracts-as-well,-if-not-done-already.", "labels": ["OpenZeppelin"]}, {"title": "Experimental version of Ownable\u00a0used", "body": "Experimental version of Ownable\u00a0used", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#experimental-version-of-ownable\u00a0used", "labels": ["OpenZeppelin"]}, {"title": "custom version of", "body": "custom version of", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#custom-version-of", "labels": ["OpenZeppelin"]}, {"title": "Ownable, which was taken from the", "body": "Ownable, which was taken from the", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#ownable,-which-was-taken-from-the", "labels": ["OpenZeppelin"]}, {"title": "labs", "body": "labs", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#labs", "labels": ["OpenZeppelin"]}, {"title": "repository of ZeppelinOS and later edited. This is experimental code, and, as stated in the", "body": "repository of ZeppelinOS and later edited. This is experimental code, and, as stated in the", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#repository-of-zeppelinos-and-later-edited.-this-is-experimental-code,-and,-as-stated-in-the", "labels": ["OpenZeppelin"]}, {"title": "README, not meant for production. As a side note, the import is made with", "body": "README, not meant for production. As a side note, the import is made with", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#readme,-not-meant-for-production.-as-a-side-note,-the-import-is-made-with", "labels": ["OpenZeppelin"]}, {"title": "Given that the project is already using OpenZeppelin, consider using its well-tested version of Ownable.", "body": "Given that the project is already using OpenZeppelin, consider using its well-tested version of Ownable.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#given-that-the-project-is-already-using-openzeppelin,-consider-using-its-well-tested-version-of-ownable.", "labels": ["OpenZeppelin"]}, {"title": "Lack of check might lead to gas\u00a0burn", "body": "Lack of check might lead to gas\u00a0burn", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#lack-of-check-might-lead-to-gas\u00a0burn", "labels": ["OpenZeppelin"]}, {"title": "The incrementMinterAllowance function can be called with a parameter value of allowanceIncrement = 0. This would lead to gas expenditure with no state changes or useful computation.", "body": "The incrementMinterAllowance function can be called with a parameter value of allowanceIncrement = 0. This would lead to gas expenditure with no state changes or useful computation.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#the-incrementminterallowance-function-can-be-called-with-a-parameter-value-of-allowanceincrement-=-0.-this-would-lead-to-gas-expenditure-with-no-state-changes-or-useful-computation.", "labels": ["OpenZeppelin"]}, {"title": "Consider checking that allowanceIncrement > 0 to avoid unnecessary gas costs.", "body": "Consider checking that allowanceIncrement > 0 to avoid unnecessary gas costs.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#consider-checking-that-allowanceincrement->-0-to-avoid-unnecessary-gas-costs.", "labels": ["OpenZeppelin"]}, {"title": "now requires", "body": "now requires", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#now-requires", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Missing error messages in require statements", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "43 and", "body": "43 and", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#43-and", "labels": ["OpenZeppelin"]}, {"title": "57 in", "body": "57 in", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#57-in", "labels": ["OpenZeppelin"]}, {"title": "94 in", "body": "94 in", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#94-in", "labels": ["OpenZeppelin"]}, {"title": "Update: all require statements now provide messages for the reverts.", "body": "Update: all require statements now provide messages for the reverts.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#update:-all-require-statements-now-provide-messages-for-the-reverts.", "labels": ["OpenZeppelin"]}, {"title": "Unaudited version of OpenZeppelin used", "body": "Unaudited version of OpenZeppelin used", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#unaudited-version-of-openzeppelin-used", "labels": ["OpenZeppelin"]}, {"title": "The repository in which the audited contracts are held is using openzeppelin-solidity v1.11.0. This is an outdated release, and was never audited. At the time of writing the latest stable version is v2.0.0, which has gone through an external security audit.", "body": "The repository in which the audited contracts are held is using openzeppelin-solidity v1.11.0. This is an outdated release, and was never audited. At the time of writing the latest stable version is v2.0.0, which has gone through an external security audit.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#the-repository-in-which-the-audited-contracts-are-held-is-using-openzeppelin-solidity-v1.11.0.-this-is-an-outdated-release,-and-was-never-audited.-at-the-time-of-writing-the-latest-stable-version-is-v2.0.0,-which-has-gone-through-an-external-security-audit.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the project to the newer, audited version.", "body": "Consider updating the project to the newer, audited version.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#consider-updating-the-project-to-the-newer,-audited-version.", "labels": ["OpenZeppelin"]}, {"title": "Room for improvement in contracts documentation", "body": "Room for improvement in contracts documentation", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#room-for-improvement-in-contracts-documentation", "labels": ["OpenZeppelin"]}, {"title": "The Centre Token minting contracts are in general well documented, and the documentation adheres to the NatSpec format. There is, however, room for improvement. First, MasterMinter.sol has no documentation at all. Second, while all contracts have a short description of each function, all comments make use of only the @dev tag among the many available in NatSpec.", "body": "The Centre Token minting contracts are in general well documented, and the documentation adheres to the NatSpec format. There is, however, room for improvement. First, MasterMinter.sol has no documentation at all. Second, while all contracts have a short description of each function, all comments make use of only the @dev tag among the many available in NatSpec.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#the-centre-token-minting-contracts-are-in-general-well-documented,-and-the-documentation-adheres-to-the-natspec-format.-there-is,-however,-room-for-improvement.-first,-masterminter.sol-has-no-documentation-at-all.-second,-while-all-contracts-have-a-short-description-of-each-function,-all-comments-make-use-of-only-the-@dev-tag-among-the-many-available-in-natspec.", "labels": ["OpenZeppelin"]}, {"title": "Yet another instance where documentation can be improved is the following comment in Controller.sol:\u201cset the controller of a particular _worker\u201d. This might lead the user to think that each worker has a single controller, while the system in fact allows it to have more than one.", "body": "Yet another instance where documentation can be improved is the following comment in Controller.sol:\u201cset the controller of a particular _worker\u201d. This might lead the user to think that each worker has a single controller, while the system in fact allows it to have more than one.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#yet-another-instance-where-documentation-can-be-improved-is-the-following-comment-in-controller.sol:\u201cset-the-controller-of-a-particular-_worker\u201d.-this-might-lead-the-user-to-think-that-each-worker-has-a-single-controller,-while-the-system-in-fact-allows-it-to-have-more-than-one.", "labels": ["OpenZeppelin"]}, {"title": "Finally, the comment \u201callows control of configure/remove minter\u2026\u201d in MintController seems to refer to the configureMinter and removeMinter functions, but these are not referenced using their full names.", "body": "Finally, the comment \u201callows control of configure/remove minter\u2026\u201d in MintController seems to refer to the configureMinter and removeMinter functions, but these are not referenced using their full names.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#finally,-the-comment-\u201callows-control-of-configure/remove-minter\u2026\u201d-in-mintcontroller-seems-to-refer-to-the-configureminter-and-removeminter-functions,-but-these-are-not-referenced-using-their-full-names.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding complete docstrings for all contracts, struct fields, state variables, mapping keys and functions, and having comments more clearly and faithfully represent the functionality of the contracts.", "body": "Consider adding complete docstrings for all contracts, struct fields, state variables, mapping keys and functions, and having comments more clearly and faithfully represent the functionality of the contracts.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#consider-adding-complete-docstrings-for-all-contracts,-struct-fields,-state-variables,-mapping-keys-and-functions,-and-having-comments-more-clearly-and-faithfully-represent-the-functionality-of-the-contracts.", "labels": ["OpenZeppelin"]}, {"title": "two", "body": "two", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#two", "labels": ["OpenZeppelin"]}, {"title": "occasions", "body": "occasions", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#occasions", "labels": ["OpenZeppelin"]}, {"title": ":", "body": "all require statements now provide messages for the reverts.  Unaudited version of OpenZeppelin used  The repository in which the audited contracts are held is using openzeppelin-solidity v1.11.0. This is an outdated release, and was never audited. At the time of writing the latest stable version is v2.0.0, which has gone through an external security audit.  Consider updating the project to the newer, audited version.  Room for improvement in contracts documentation  The Centre Token minting contracts are in general well documented, and the documentation adheres to the NatSpec format. There is, however, room for improvement. First, MasterMinter.sol has no documentation at all. Second, while all contracts have a short description of each function, all comments make use of only the @dev tag among the many available in NatSpec.  Yet another instance where documentation can be improved is the following comment in Controller.solset the controller of a particular _worker. This might lead the user to think that each worker has a single controller, while the system in fact allows it to have more than one.  Finally, the comment allows control of configure/remove minter\u2026 in MintController seems to refer to the configureMinter and removeMinter functions, but these are not referenced using their full names.  Consider adding complete docstrings for all contracts, struct fields, state variables, mapping keys and functions, and having comments more clearly and faithfully represent the functionality of the contracts.  two  occasions  Notes & Additional Information  Controller.sol, MintController.sol and MasterMinter.sol are using an outdated Solidity release v0.4.24. Consider using the latest version of the Solidity compiler (v0.5.2 at the time of writing) throughout the code. removeController does not check if the controller is set before removal, allowing for subsequent calls to the function, which will confusingly emit repeated ControllerRemoved events with the same address. Consider whether this check should be included in order to avoid this behavior. Update a check was added to prevent this behavior.  Controller explicitly defines an empty constructor, which, according to the Solidity docs, is exactly what the contract would assume if this piece of code was absent. Consider removing the empty constructor for clarity. Update the empty constructor was removed.  Several functions (configureController and removeController in Controller, and setMinterManager in MintController) return hardcoded boolean values. Consider documenting this if it arises from the need of conforming to an interface. Update these functions no longer return a boolean.  Several functions in the code (configureController and removeController in Controller, and setMinterManager, removeMinter, configureMinter, and incrementMinterAllowance in MintController.sol) are marked as public, but are never called from within the contract hierarchy. Consider making these functions external if they are only to be called from other contracts.  Consider moving MinterManagementInterface to an individual file and importing it from MinterController.sol, thus allowing it to be cleanly imported from other files in the project. Update the interface now lives in its own MinterManagementInterface.sol file.  Consider restricting the visibility of the controllers and minterManager variables to internal or private and providing the required getter functions as a good encapsulation practice. Update these variables are now internal, and the corresponding getters are in place.  In line 61 of MintController, the minterManager variable is implicitly converted to the address type. Starting from Solidity version v0.5.0, implicit address conversions issue an error. Consider explicitly casting minterManager to the address type in case the decision is later made to use a newer version of Solidity. Update the casting is now done explicitly.  Repeatedly in the code (Controller.sol lines 56, 66; MintController.sol lines 60, 71, 80, 92), the public keyword appears after the custom modifiers. According to the Solidity docs on Function declaration, however, The visibility modifier for a function should come before other modifiers. Update the ordering of the modifiers now conforms to the suggested one.  The line wrapping is inconsistent in the codebase. Comments appear to be wrapped at around 86 characters but some parts of the code extend beyond that limit (e.g. line 49 of MintController.sol, which goes to 128). Consider adhering to a single limit and applying it throughout. The recommended width is 80 columns. Update line wrapping is now consistent throughout.  There is an inconsistency in function parameter naming. In Controller they all start with an underscore, while in MintController only those of constructor and setMinterManager do. Consider using underscores in all parameter names. Update all parameter names now start with underscores, except only for those of the new MinterAllowanceDecremented event. Apart from this, there is an extra blank line between the declaration of this new event and the preceding ones.  All import statements use single quotes, double quotes are recommended in the Solidity Style Guide. Update import statements now use double quotes.  There is a double space in line 52 of MintController.sol. Update the double space was removed.  Functions incrementMinterAllowance and internal_setMinterAllowance in MintController are not correctly indented. Update these indentation issues were resolved.  Conclusion  No critical or high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Centre Token minting contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#:", "labels": ["OpenZeppelin"]}, {"title": "Controller.sol, MintController.sol and MasterMinter.sol are using an outdated Solidity release: v0.4.24. Consider using the latest version of the Solidity compiler (v0.5.2 at the time of writing) throughout the code. removeController does not check if the controller is set before removal, allowing for subsequent calls to the function, which will confusingly emit repeated ControllerRemoved events with the same address. Consider whether this check should be included in order to avoid this behavior. Update: a check was added to prevent this behavior.", "body": "Controller.sol, MintController.sol and MasterMinter.sol are using an outdated Solidity release: v0.4.24. Consider using the latest version of the Solidity compiler (v0.5.2 at the time of writing) throughout the code. removeController does not check if the controller is set before removal, allowing for subsequent calls to the function, which will confusingly emit repeated ControllerRemoved events with the same address. Consider whether this check should be included in order to avoid this behavior. Update: a check was added to prevent this behavior.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#controller.sol,-mintcontroller.sol-and-masterminter.sol-are-using-an-outdated-solidity-release:-v0.4.24.-consider-using-the-latest-version-of-the-solidity-compiler-(v0.5.2-at-the-time-of-writing)-throughout-the-code.-removecontroller-does-not-check-if-the-controller-is-set-before-removal,-allowing-for-subsequent-calls-to-the-function,-which-will-confusingly-emit-repeated-controllerremoved-events-with-the-same-address.-consider-whether-this-check-should-be-included-in-order-to-avoid-this-behavior.-update:-a-check-was-added-to-prevent-this-behavior.", "labels": ["OpenZeppelin"]}, {"title": "Controller explicitly defines an empty constructor, which, according to the Solidity docs, is exactly what the contract would assume if this piece of code was absent. Consider removing the empty constructor for clarity. Update: the empty constructor was removed.", "body": "Controller explicitly defines an empty constructor, which, according to the Solidity docs, is exactly what the contract would assume if this piece of code was absent. Consider removing the empty constructor for clarity. Update: the empty constructor was removed.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#controller-explicitly-defines-an-empty-constructor,-which,-according-to-the-solidity-docs,-is-exactly-what-the-contract-would-assume-if-this-piece-of-code-was-absent.-consider-removing-the-empty-constructor-for-clarity.-update:-the-empty-constructor-was-removed.", "labels": ["OpenZeppelin"]}, {"title": "Several functions (configureController and removeController in Controller, and setMinterManager in MintController) return hardcoded boolean values. Consider documenting this if it arises from the need of conforming to an interface. Update: these functions no longer return a boolean.", "body": "Several functions (configureController and removeController in Controller, and setMinterManager in MintController) return hardcoded boolean values. Consider documenting this if it arises from the need of conforming to an interface. Update: these functions no longer return a boolean.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#several-functions-(configurecontroller-and-removecontroller-in-controller,-and-setmintermanager-in-mintcontroller)-return-hardcoded-boolean-values.-consider-documenting-this-if-it-arises-from-the-need-of-conforming-to-an-interface.-update:-these-functions-no-longer-return-a-boolean.", "labels": ["OpenZeppelin"]}, {"title": "Several functions in the code (configureController and removeController in Controller, and setMinterManager, removeMinter, configureMinter, and incrementMinterAllowance in MintController.sol) are marked as public, but are never called from within the contract hierarchy. Consider making these functions external if they are only to be called from other contracts.", "body": "Several functions in the code (configureController and removeController in Controller, and setMinterManager, removeMinter, configureMinter, and incrementMinterAllowance in MintController.sol) are marked as public, but are never called from within the contract hierarchy. Consider making these functions external if they are only to be called from other contracts.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#several-functions-in-the-code-(configurecontroller-and-removecontroller-in-controller,-and-setmintermanager,-removeminter,-configureminter,-and-incrementminterallowance-in-mintcontroller.sol)-are-marked-as-public,-but-are-never-called-from-within-the-contract-hierarchy.-consider-making-these-functions-external-if-they-are-only-to-be-called-from-other-contracts.", "labels": ["OpenZeppelin"]}, {"title": "Consider moving MinterManagementInterface to an individual file and importing it from MinterController.sol, thus allowing it to be cleanly imported from other files in the project. Update: the interface now lives in its own MinterManagementInterface.sol file.", "body": "Consider moving MinterManagementInterface to an individual file and importing it from MinterController.sol, thus allowing it to be cleanly imported from other files in the project. Update: the interface now lives in its own MinterManagementInterface.sol file.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#consider-moving-mintermanagementinterface-to-an-individual-file-and-importing-it-from-mintercontroller.sol,-thus-allowing-it-to-be-cleanly-imported-from-other-files-in-the-project.-update:-the-interface-now-lives-in-its-own-mintermanagementinterface.sol-file.", "labels": ["OpenZeppelin"]}, {"title": "Consider restricting the visibility of the controllers and minterManager variables to internal or private and providing the required getter functions as a good encapsulation practice. Update: these variables are now internal, and the corresponding getters are in place.", "body": "Consider restricting the visibility of the controllers and minterManager variables to internal or private and providing the required getter functions as a good encapsulation practice. Update: these variables are now internal, and the corresponding getters are in place.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#consider-restricting-the-visibility-of-the-controllers-and-mintermanager-variables-to-internal-or-private-and-providing-the-required-getter-functions-as-a-good-encapsulation-practice.-update:-these-variables-are-now-internal,-and-the-corresponding-getters-are-in-place.", "labels": ["OpenZeppelin"]}, {"title": "In line 61 of MintController, the minterManager variable is implicitly converted to the address type. Starting from Solidity version v0.5.0, implicit address conversions issue an error. Consider explicitly casting minterManager to the address type in case the decision is later made to use a newer version of Solidity. Update: the casting is now done explicitly.", "body": "In line 61 of MintController, the minterManager variable is implicitly converted to the address type. Starting from Solidity version v0.5.0, implicit address conversions issue an error. Consider explicitly casting minterManager to the address type in case the decision is later made to use a newer version of Solidity. Update: the casting is now done explicitly.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#in-line-61-of-mintcontroller,-the-mintermanager-variable-is-implicitly-converted-to-the-address-type.-starting-from-solidity-version-v0.5.0,-implicit-address-conversions-issue-an-error.-consider-explicitly-casting-mintermanager-to-the-address-type-in-case-the-decision-is-later-made-to-use-a-newer-version-of-solidity.-update:-the-casting-is-now-done-explicitly.", "labels": ["OpenZeppelin"]}, {"title": "Repeatedly in the code (Controller.sol lines 56, 66; MintController.sol lines 60, 71, 80, 92), the public keyword appears after the custom modifiers. According to the Solidity docs on Function declaration, however, \u201cThe visibility modifier for a function should come before other modifiers\u201d. Update: the ordering of the modifiers now conforms to the suggested one.", "body": "Repeatedly in the code (Controller.sol lines 56, 66; MintController.sol lines 60, 71, 80, 92), the public keyword appears after the custom modifiers. According to the Solidity docs on Function declaration, however, \u201cThe visibility modifier for a function should come before other modifiers\u201d. Update: the ordering of the modifiers now conforms to the suggested one.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#repeatedly-in-the-code-(controller.sol-lines-56,-66;-mintcontroller.sol-lines-60,-71,-80,-92),-the-public-keyword-appears-after-the-custom-modifiers.-according-to-the-solidity-docs-on-function-declaration,-however,-\u201cthe-visibility-modifier-for-a-function-should-come-before-other-modifiers\u201d.-update:-the-ordering-of-the-modifiers-now-conforms-to-the-suggested-one.", "labels": ["OpenZeppelin"]}, {"title": "The line wrapping is inconsistent in the codebase. Comments appear to be wrapped at around 86 characters but some parts of the code extend beyond that limit (e.g. line 49 of MintController.sol, which goes to 128). Consider adhering to a single limit and applying it throughout. The recommended width is 80 columns. Update: line wrapping is now consistent throughout.", "body": "The line wrapping is inconsistent in the codebase. Comments appear to be wrapped at around 86 characters but some parts of the code extend beyond that limit (e.g. line 49 of MintController.sol, which goes to 128). Consider adhering to a single limit and applying it throughout. The recommended width is 80 columns. Update: line wrapping is now consistent throughout.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#the-line-wrapping-is-inconsistent-in-the-codebase.-comments-appear-to-be-wrapped-at-around-86-characters-but-some-parts-of-the-code-extend-beyond-that-limit-(e.g.-line-49-of-mintcontroller.sol,-which-goes-to-128).-consider-adhering-to-a-single-limit-and-applying-it-throughout.-the-recommended-width-is-80-columns.-update:-line-wrapping-is-now-consistent-throughout.", "labels": ["OpenZeppelin"]}, {"title": "There is an inconsistency in function parameter naming. In Controller they all start with an underscore, while in MintController only those of constructor and setMinterManager do. Consider using underscores in all parameter names. Update: all parameter names now start with underscores, except only for those of the new MinterAllowanceDecremented event. Apart from this, there is an extra blank line between the declaration of this new event and the preceding ones.", "body": "There is an inconsistency in function parameter naming. In Controller they all start with an underscore, while in MintController only those of constructor and setMinterManager do. Consider using underscores in all parameter names. Update: all parameter names now start with underscores, except only for those of the new MinterAllowanceDecremented event. Apart from this, there is an extra blank line between the declaration of this new event and the preceding ones.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#there-is-an-inconsistency-in-function-parameter-naming.-in-controller-they-all-start-with-an-underscore,-while-in-mintcontroller-only-those-of-constructor-and-setmintermanager-do.-consider-using-underscores-in-all-parameter-names.-update:-all-parameter-names-now-start-with-underscores,-except-only-for-those-of-the-new-minterallowancedecremented-event.-apart-from-this,-there-is-an-extra-blank-line-between-the-declaration-of-this-new-event-and-the-preceding-ones.", "labels": ["OpenZeppelin"]}, {"title": "All import statements use single quotes, double quotes are recommended in the Solidity Style Guide. Update: import statements now use double quotes.", "body": "All import statements use single quotes, double quotes are recommended in the Solidity Style Guide. Update: import statements now use double quotes.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#all-import-statements-use-single-quotes,-double-quotes-are-recommended-in-the-solidity-style-guide.-update:-import-statements-now-use-double-quotes.", "labels": ["OpenZeppelin"]}, {"title": "There is a double space in line 52 of MintController.sol. Update: the double space was removed.", "body": "There is a double space in line 52 of MintController.sol. Update: the double space was removed.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#there-is-a-double-space-in-line-52-of-mintcontroller.sol.-update:-the-double-space-was-removed.", "labels": ["OpenZeppelin"]}, {"title": "Functions incrementMinterAllowance and internal_setMinterAllowance in MintController are not correctly indented. Update: these indentation issues were resolved.", "body": "Functions incrementMinterAllowance and internal_setMinterAllowance in MintController are not correctly indented. Update: these indentation issues were resolved.", "html_url": "https://blog.openzeppelin.com/centre-token-minting-contracts-audit-6e723177d44b#functions-incrementminterallowance-and-internal_setminterallowance-in-mintcontroller-are-not-correctly-indented.-update:-these-indentation-issues-were-resolved.", "labels": ["OpenZeppelin"]}, {"title": "None.", "body": "None.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#none.", "labels": ["OpenZeppelin"]}, {"title": "The Escrow\u2019s owner can arbitrarily increase the balance of any job without spending RNDR\u00a0tokens", "body": "The Escrow\u2019s owner can arbitrarily increase the balance of any job without spending RNDR\u00a0tokens", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#the-escrow\u2019s-owner-can-arbitrarily-increase-the-balance-of-any-job-without-spending-rndr\u00a0tokens", "labels": ["OpenZeppelin"]}, {"title": "renderTokenAddress variable. The owner of the", "body": "renderTokenAddress variable. The owner of the", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#rendertokenaddress-variable.-the-owner-of-the", "labels": ["OpenZeppelin"]}, {"title": "changeRenderTokenAddress. If the owner called", "body": "changeRenderTokenAddress. If the owner called", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#changerendertokenaddress.-if-the-owner-called", "labels": ["OpenZeppelin"]}, {"title": "changeRenderTokenAddress passing the address of an account controlled by them as a parameter, they would therefore be allowed to call", "body": "changeRenderTokenAddress passing the address of an account controlled by them as a parameter, they would therefore be allowed to call", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#changerendertokenaddress-passing-the-address-of-an-account-controlled-by-them-as-a-parameter,-they-would-therefore-be-allowed-to-call", "labels": ["OpenZeppelin"]}, {"title": "fundJob from that account and arbitrarily increase any job balance, at any point in time, without spending any tokens.", "body": "fundJob from that account and arbitrarily increase any job balance, at any point in time, without spending any tokens.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#fundjob-from-that-account-and-arbitrarily-increase-any-job-balance,-at-any-point-in-time,-without-spending-any-tokens.", "labels": ["OpenZeppelin"]}, {"title": "Consider analyzing the removal of the changeRenderTokenAddress function, or at least properly documenting the rationale behind its inclusion in the contract, so users are aware of such a dangerous scenario. While an attempt to do so was found in Escrow.sol , where a comment states that the function \u201c[\u2026] is included as a failsafe\u201d, the issues that this mechanism would prevent from occurring are never explained.", "body": "Consider analyzing the removal of the changeRenderTokenAddress function, or at least properly documenting the rationale behind its inclusion in the contract, so users are aware of such a dangerous scenario. While an attempt to do so was found in Escrow.sol , where a comment states that the function \u201c[\u2026] is included as a failsafe\u201d, the issues that this mechanism would prevent from occurring are never explained.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-analyzing-the-removal-of-the-changerendertokenaddress-function,-or-at-least-properly-documenting-the-rationale-behind-its-inclusion-in-the-contract,-so-users-are-aware-of-such-a-dangerous-scenario.-while-an-attempt-to-do-so-was-found-in-escrow.sol-,-where-a-comment-states-that-the-function-\u201c[\u2026]-is-included-as-a-failsafe\u201d,-the-issues-that-this-mechanism-would-prevent-from-occurring-are-never-explained.", "labels": ["OpenZeppelin"]}, {"title": "Update: an event is now emitted when the changeRenderTokenAddress function is called, and documentation was added explaining the rationale for having this function.", "body": "Update: an event is now emitted when the changeRenderTokenAddress function is called, and documentation was added explaining the rationale for having this function.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-an-event-is-now-emitted-when-the-changerendertokenaddress-function-is-called,-and-documentation-was-added-explaining-the-rationale-for-having-this-function.", "labels": ["OpenZeppelin"]}, {"title": "Unsafe arithmetic operations in Airdrop\u00a0contract", "body": "Unsafe arithmetic operations in Airdrop\u00a0contract", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#unsafe-arithmetic-operations-in-airdrop\u00a0contract", "labels": ["OpenZeppelin"]}, {"title": "30 ,", "body": "30 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#30-,", "labels": ["OpenZeppelin"]}, {"title": "39 ,", "body": "39 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#39-,", "labels": ["OpenZeppelin"]}, {"title": "56 ,", "body": "56 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#56-,", "labels": ["OpenZeppelin"]}, {"title": "58 ,", "body": "58 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#58-,", "labels": ["OpenZeppelin"]}, {"title": "64 and", "body": "64 and", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#64-and", "labels": ["OpenZeppelin"]}, {"title": "65 ) , leading to attempts to store numbers outside the range of the data types of their target variables. There are in particular two situations which could potentially cause integer overflows/underflows.", "body": "65 ) , leading to attempts to store numbers outside the range of the data types of their target variables. There are in particular two situations which could potentially cause integer overflows/underflows.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#65-)-,-leading-to-attempts-to-store-numbers-outside-the-range-of-the-data-types-of-their-target-variables.-there-are-in-particular-two-situations-which-could-potentially-cause-integer-overflows/underflows.", "labels": ["OpenZeppelin"]}, {"title": "addManyUsers function. This function iterates through a", "body": "addManyUsers function. This function iterates through a", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#addmanyusers-function.-this-function-iterates-through-a", "labels": ["OpenZeppelin"]}, {"title": "addUser is called, which adds the respective user amount to the storage variable", "body": "addUser is called, which adds the respective user amount to the storage variable", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#adduser-is-called,-which-adds-the-respective-user-amount-to-the-storage-variable", "labels": ["OpenZeppelin"]}, {"title": "payManyUsers function could lead to an integer underflow. After the contract is deployed, the storage variable", "body": "payManyUsers function could lead to an integer underflow. After the contract is deployed, the storage variable", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#paymanyusers-function-could-lead-to-an-integer-underflow.-after-the-contract-is-deployed,-the-storage-variable", "labels": ["OpenZeppelin"]}, {"title": "nextUserToBePaid equals 0. When calling", "body": "nextUserToBePaid equals 0. When calling", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#nextusertobepaid-equals-0.-when-calling", "labels": ["OpenZeppelin"]}, {"title": "payManyUsers , if 0 was passed as the value of the", "body": "payManyUsers , if 0 was passed as the value of the", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#paymanyusers-,-if-0-was-passed-as-the-value-of-the", "labels": ["OpenZeppelin"]}, {"title": "immediately followin", "body": "immediately followin", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#immediately-followin", "labels": ["OpenZeppelin"]}, {"title": "if", "body": "clause would prevent something unexpected to happen, this approach is error-prone and not advised.  Consider using OpenZeppelins  SafeMath library to avoid underflows/overflows when doing mathematical operations.  Update: the SafeMath library is now being used throughout.  Contract owners can change business logic unnoticeably  In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:  RenderToken#setEscrowContractAddress :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.  Escrow#changeRenderTokenAddress : the address of the token contract.  Escrow#changeDisbursalAddress : the address authorized to distribute tokens for completed jobs.  Consider emitting events to noty users about any modications of such importance in the contracts business logic.  Update: events are now emitted to provide users with a mechanism to track these changes.  Inconsistent and experimental use of Solidity versions  While the individual contracts can be compiled using dferent versions of the Solidity compiler, profuse versioning among the same codebase is confusing and error-prone. As indicated by its name, the experimental feature should not be used in production.  Consider using the latest (0.4.25 at the time of writing) version of the Solidity compiler throughout the code.  Update: Solidity version v0.4.24 is now used throughout the project.  Medium Severity  Two dferent minting functions coexist in the RenderToken contract  LegacyToken.sol and  MigratableERC20.sol files were extracted from an  example provided as a guide in an early version of ZeppelinOS. This guide explains how to migrate old token balances by burning old and minting new tokens, for which it introduced a  _mint function in the new token, which extended  openzeppelin-zos (now renamed to  RenderToken  _mint function that is declared in  MintableToken , which already has a minting function named  mint. Duplicating the minting functionality is confusing and potentially dangerous. Whichever form the migration ends up taking, consider using the already existing  Update: The RenderToken contract now extends from openzeppelin-eth'sStandardToken instead of MintableToken, and there is now a single minting function called _mintMigratedTokens.  Input arrays with mismatched length will make addManyUsers throw  addManyUsers function in the  Consider including a require clause with an explicit error message to check for matching array length.  Update: a require statement now checks for matching array length.  Omission of the transfer in disburseJob leads to inconsistent balance state  The RenderToken contract interacts with the Escrow contract by funding jobs, transferring tokens to increase the dferent jobs balances, which are tracked by the Escrow. The disburseJob function later takes care of redistributing these funds among the recipients.  This function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the disburseJobfunction will leave the Escrow in an inconsistent state where the sum of the total jobBalances is dferent from its total token balance, since the former are depleted by the function but the latter isnt.  Even  the jobBalances mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the Escrowbalance tracking in a way that doesnt lead to inconsistencies, or using the PullPayment/Escrow solution provided in the OpenZeppelin suite.  Update: the disburseJob function now performs the token transfers.  payUser fails silently  the bonus was already paid  In the payUser function of the AirDrop contract, an  clause is used to check whether a bonus has already been paid. In the case the condition amount &gt; 0 is not satisfied, the payment will not be performed, giving the caller no notice that it didnt go through apart from the lack of an associated event.  Consider complementing the  with an else clause that handles the logic when the condition fails.  Update: an event is now emitted in case the  condition fails.  Unchecked ERC20 transfer operation  Inside the payUser function, a transfer is being made but there are no checks validating its successful completion. If the transfer somehow fails, an event logging the successful operation would be emitted despite the transferee not getting their tokens.  Consider using OpenZeppelins  SafeERC20 library and its safeTransfer function, or surrounding the transfer operation with a require statement.  Update: the SafeERC20 library is now used.  Missing checks for null addresses in RenderToken and Airdrop contracts  In RenderToken, the setEscrowContractAddress function allows the tokens owner to change the escrows address (i.e. the contract variable escrowContractAddress ). However, the function does not implement a check to prevent the null address from being set.  Similarly in Airdrop, the contracts constructor receives as a parameter an address that is assigned to the contract variable renderTokenAddress with no checks preventing the null address from being used.  Consider implementing no-null address validations before setting these variables to avoid potential problems downstream.  Update: null checks are now [in(https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L88) place for address changes.  Storage modication on event emission  In the addUser function of the Airdrop contract, an item is pushed into the bonusAddresses array. The result of the operation, which is the length for that array after the addition, is used as a parameter in the AddedUser event emission. This, while valid Solidity, is confusing and error-prone.  Consider performing the storage modication and keeping the resulting value in a temporary variable before emitting the event for code clarity.  Update: the temporary value is now assigned to a variable before emitting the event.  Low Severity  Event parameters are not indexed  The AddedUser and PaidUser events defined in Airdrop as well as the JobBalanceUpdate event defined in Escrow are not indexing their parameters. This means that they will not be searchable in terms of those variables, making it impossible to track job balance histories, user additions or payments.  Update: the AddUser and PaidUser events now index their parameters, but the JobBalanceUpdate one still doesnt. String indexing had an associated [web3(https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814) issue , which is purportedly solved in version 1.0. Alternatively, two workarounds for this issue are discussed here.  Deceptive inline comment in Escrow contract  Considering the issue The Escrows owner can arbitrarily increase the balance of any job without spending RNDR tokens above, the comment in Escrow.sol that states: Jobs can only be created through the RNDR contract is false and may be misleading for users reading the contracts code. Consider rephrasing it clearly to state that job balances can be arbitrarily incremented by whatever account the owner of the contract sets as the renderTokenAddress.  Update: the comment was fixed to read: Jobs can only be created by the address stored in the renderTokenAddress variable .  Missing error messages in require statements  Escrow  :L70 ,  Escrow  :L89 ,  Escrow  :L109 ,  RenderToken  :L40 ,  RenderToken  :L45 ) that provide no error messages. Consider including specic and informative error messages in all require statements.  Update: all require statements now provide appropriate error messages.  Missing docstrings in contract and functions in Airdrop contract  TheAirDrop contracts source code, which handles token distribution, has no inline documentation whatsoever. Consider documenting with docstrings everything that is part of the public API.  Update: the AirDrop contract is now thoroughly documented.  Untested functions in RenderToken  The RenderToken contract implements functions (e.g. holdInEscrow ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.  Update: some testing of holdInEscrow was done in the Escrow.js file, but an additional test for this function was added to the RenderToken.js file.  Broken testing instructions in README files  Token-Audit/README.md file do not work  followed literally. An error   Token-Airdrop/README.md file also do not work, with the error   Consider updating the instructions and including a working cross-platform configuration so developers and auditors can successfully run the test suite. Furthermore, given that the test suite for the Airdrop contract can only be run using thetruffle v5.0.0-beta release, consider including this version of truffle as a dev dependency in the package.json file of the project.  Update: the README files were updated with new testing instructions.  Erroneous documentation in initialize functions  Initialize functions (in Escrow and RenderToken ) are incorrectly documented, since these functions are not contract constructors. Consider updating the inline documentation to fix these errors.  Update: documentation now refers to the functions as initializers instead of constructors.  Inconsistent use of imports in contracts  Update: all imports use now a consistent style.  Inconsistent coding style among dferent files  There is a signicant coding-style dference between the contracts in the Token-Audit repository and those in Token-Airdrop repository. The contracts in the first one use docstrings, libraries like OpenZeppelins  SafeMath , and 2-space indentation. The latter, on the other hand, has no comments in the source code nor takes security considerations into account by using already audited libraries, and uses 4-space indentation. Consider following best practices and applying the same style guidelines across all files.  Update: both repositories use now a consistent coding style.  Notes & Additional Information  The addresses of job funders are presumably meant to be tracked off-chain, but consider adding an event-based tracking layer as a failsafe (i.e., _emitting an event identying the contributor in RenderTokens holdInEscrow function)._Update: an event is now emitted.  In the Airdrop contract, consider prefixing all internal functions with an underscore to clearly denote their visibility.Update: internal functions are now prefixed with an underscore.  Several public functions can be restricted to external. In particular: functions fundJob, changeDisbursalAddress, changeRenderTokenAddress, disburseJob, and jobBalance in the Escrow contract, and functions addManyUsers, payManyUsers, finalizeList, returnTokens and getUserCount in the AirDrop contract.Update: these functions were restricted to external.  Consider including brackets in all control flow statements (e.g. in Airdrop.sol ) , to prevent issues with future versions of the language.Update: brackets were added.  Consider declaring the canDisburse modier before all function definitions.Update: the modier was moved before all functions.  Consider making all instances of uint explicitly uint256 (see Escrow.sol :L72 and Airdrop.sol :L47 ).Update: all uint types are now explicitly uint256.  Variables listFinalized and nextUserToBePaid are explicitly initialized in AirDrop, but totalBonus is not. Consider initializing this last variable explicitly as well for code consistency.Update: totalBonus is now initialized.  Consider explicitly marking all contract variables as private and defining getters/setters where appropriate, or at least explicit setting the visibility of all contract variables (e.g. jobBalances in theEscrow contract is not declared as public)._Update: jobBalances is now declared as private.  In order to load the Airdrop contract to execute the payments, it is necessary that someone with minting privileges or enough tokens adds balance from a RenderToken contract to the address of the recently deployed Airdrop contract. For clarity purposes, consider expanding step number five on the instructions in Token-Airdrop/README.md file to clearly state this precondition.Update: the README file has updated wording on this point.  Conclusion  No critical and four high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the OTOY RNDR Token contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#if", "labels": ["OpenZeppelin"]}, {"title": "clause would prevent something unexpected to happen, this approach is error-prone and not advised.", "body": "clause would prevent something unexpected to happen, this approach is error-prone and not advised.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#clause-would-prevent-something-unexpected-to-happen,-this-approach-is-error-prone-and-not-advised.", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s  SafeMath library to avoid underflows/overflows when doing mathematical operations.", "body": "Consider using OpenZeppelin\u2019s  SafeMath library to avoid underflows/overflows when doing mathematical operations.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-using-openzeppelin\u2019s--safemath-library-to-avoid-underflows/overflows-when-doing-mathematical-operations.", "labels": ["OpenZeppelin"]}, {"title": "Update: the SafeMath library is now being used throughout.", "body": "Update: the SafeMath library is now being used throughout.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-safemath-library-is-now-being-used-throughout.", "labels": ["OpenZeppelin"]}, {"title": "Contract owners can change business logic unnoticeably", "body": "Contract owners can change business logic unnoticeably", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#contract-owners-can-change-business-logic-unnoticeably", "labels": ["OpenZeppelin"]}, {"title": "In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:", "body": "In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#in-several-contracts,-the-owner-can-arbitrarily-change-the-business-logic-by-setting-new-contract-addresses,-without-properly-warning-users-of-those-changes.-examples-are:", "labels": ["OpenZeppelin"]}, {"title": "RenderToken#setEscrowContractAddress :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.", "body": "RenderToken#setEscrowContractAddress :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#rendertoken#setescrowcontractaddress-:the-address-that-will-hold-tokens-in-escrow-and-keep-a-ledger-of-funds-available-for-jobs.", "labels": ["OpenZeppelin"]}, {"title": "Escrow#changeRenderTokenAddress : the address of the token contract.", "body": "Escrow#changeRenderTokenAddress : the address of the token contract.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#escrow#changerendertokenaddress-:-the-address-of-the-token-contract.", "labels": ["OpenZeppelin"]}, {"title": "Escrow#changeDisbursalAddress : the address authorized to distribute tokens for completed jobs.", "body": "Escrow#changeDisbursalAddress : the address authorized to distribute tokens for completed jobs.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#escrow#changedisbursaladdress-:-the-address-authorized-to-distribute-tokens-for-completed-jobs.", "labels": ["OpenZeppelin"]}, {"title": "Consider emitting events to notify users about any modifications of such importance in the contracts\u2019 business logic.", "body": "Consider emitting events to notify users about any modifications of such importance in the contracts\u2019 business logic.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-emitting-events-to-notify-users-about-any-modifications-of-such-importance-in-the-contracts\u2019-business-logic.", "labels": ["OpenZeppelin"]}, {"title": "Update: events are now emitted to provide users with a mechanism to track these changes.", "body": "Update: events are now emitted to provide users with a mechanism to track these changes.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-events-are-now-emitted-to-provide-users-with-a-mechanism-to-track-these-changes.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent and experimental use of Solidity\u00a0versions", "body": "Inconsistent and experimental use of Solidity\u00a0versions", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#inconsistent-and-experimental-use-of-solidity\u00a0versions", "labels": ["OpenZeppelin"]}, {"title": "While the individual contracts can be compiled using different versions of the Solidity compiler, profuse versioning among the same codebase is confusing and error-prone. As indicated by its name, the experimental feature should not be used in production.", "body": "While the individual contracts can be compiled using different versions of the Solidity compiler, profuse versioning among the same codebase is confusing and error-prone. As indicated by its name, the experimental feature should not be used in production.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#while-the-individual-contracts-can-be-compiled-using-different-versions-of-the-solidity-compiler,-profuse-versioning-among-the-same-codebase-is-confusing-and-error-prone.-as-indicated-by-its-name,-the-experimental-feature-should-not-be-used-in-production.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the latest (0.4.25 at the time of writing) version of the Solidity compiler throughout the code.", "body": "Consider using the latest (0.4.25 at the time of writing) version of the Solidity compiler throughout the code.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-using-the-latest-(0.4.25-at-the-time-of-writing)-version-of-the-solidity-compiler-throughout-the-code.", "labels": ["OpenZeppelin"]}, {"title": "Update: Solidity version v0.4.24 is now used throughout the project.", "body": "Update: Solidity version v0.4.24 is now used throughout the project.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-solidity-version-v0.4.24-is-now-used-throughout-the-project.", "labels": ["OpenZeppelin"]}, {"title": "Two different minting functions coexist in the RenderToken contract", "body": "Two different minting functions coexist in the RenderToken contract", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#two-different-minting-functions-coexist-in-the-rendertoken-contract", "labels": ["OpenZeppelin"]}, {"title": "LegacyToken.sol and", "body": "LegacyToken.sol and", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#legacytoken.sol-and", "labels": ["OpenZeppelin"]}, {"title": "MigratableERC20.sol files were extracted from an", "body": "MigratableERC20.sol files were extracted from an", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#migratableerc20.sol-files-were-extracted-from-an", "labels": ["OpenZeppelin"]}, {"title": "example provided as a guide in an early version of ZeppelinOS. This guide explains how to migrate old token balances by burning old and minting new tokens, for which it introduced a", "body": "example provided as a guide in an early version of ZeppelinOS. This guide explains how to migrate old token balances by burning old and minting new tokens, for which it introduced a", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#example-provided-as-a-guide-in-an-early-version-of-zeppelinos.-this-guide-explains-how-to-migrate-old-token-balances-by-burning-old-and-minting-new-tokens,-for-which-it-introduced-a", "labels": ["OpenZeppelin"]}, {"title": "_mint function in the new token, which extended", "body": "_mint function in the new token, which extended", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#_mint-function-in-the-new-token,-which-extended", "labels": ["OpenZeppelin"]}, {"title": "openzeppelin-zos (now renamed to", "body": "openzeppelin-zos (now renamed to", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#openzeppelin-zos-(now-renamed-to", "labels": ["OpenZeppelin"]}, {"title": "RenderToken", "body": "Address passing the address of an account controlled by them as a parameter, they would therefore be allowed to call  fundJob from that account and arbitrarily increase any job balance, at any point in time, without spending any tokens.  Consider analyzing the removal of the changeAddress function, or at least properly documenting the rationale behind its inclusion in the contract, so users are aware of such a dangerous scenario. While an attempt to do so was found in Escrow.sol , where a comment states that the function [\u2026] is included as a failsafe, the issues that this mechanism would prevent from occurring are never explained.  Update: an event is now emitted when the changeAddress function is called, and documentation was added explaining the rationale for having this function.  Unsafe arithmetic operations in Airdrop contract  30 ,  39 ,  56 ,  58 ,  64 and  65 ) , leading to attempts to store numbers outside the range of the data types of their target variables. There are in particular two situations which could potentially cause integer overflows/underflows.  addManyUsers function. This function iterates through a  addUser is called, which adds the respective user amount to the storage variable  payManyUsers function could lead to an integer underflow. After the contract is deployed, the storage variable  nextUserToBePaid equals 0. When calling  payManyUsers , if 0 was passed as the value of the  immediately followin  if  clause would prevent something unexpected to happen, this approach is error-prone and not advised.  Consider using OpenZeppelins  SafeMath library to avoid underflows/overflows when doing mathematical operations.  Update: the SafeMath library is now being used throughout.  Contract owners can change business logic unnoticeably  In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:  #setEscrowContractAddress :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.  Escrow#changeAddress : the address of the token contract.  Escrow#changeDisbursalAddress : the address authorized to distribute tokens for completed jobs.  Consider emitting events to notify users about any modifications of such importance in the contracts business logic.  Update: events are now emitted to provide users with a mechanism to track these changes.  Inconsistent and experimental use of Solidity versions  While the individual contracts can be compiled using different versions of the Solidity compiler, profuse versioning among the same codebase is confusing and error-prone. As indicated by its name, the experimental feature should not be used in production.  Consider using the latest (0.4.25 at the time of writing) version of the Solidity compiler throughout the code.  Update: Solidity version v0.4.24 is now used throughout the project.  Medium Severity  Two different minting functions coexist in the  contract  LegacyToken.sol and  MigratableERC20.sol files were extracted from an  example provided as a guide in an early version of ZeppelinOS. This guide explains how to migrate old token balances by burning old and minting new tokens, for which it introduced a  _mint function in the new token, which extended  openzeppelin-zos (now renamed to    _mint function that is declared in  MintableToken , which already has a minting function named  mint. Duplicating the minting functionality is confusing and potentially dangerous. Whichever form the migration ends up taking, consider using the already existing  Update: The  contract now extends from openzeppelin-eth'sStandardToken instead of MintableToken, and there is now a single minting function called _mintMigratedTokens.  Input arrays with mismatched length will make addManyUsers throw  addManyUsers function in the  Consider including a require clause with an explicit error message to check for matching array length.  Update: a require statement now checks for matching array length.  Omission of the transfer in disburseJob leads to inconsistent balance state  The  contract interacts with the Escrow contract by funding jobs, transferring tokens to increase the different jobs balances, which are tracked by the Escrow. The disburseJob function later takes care of redistributing these funds among the recipients.  This function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the disburseJobfunction will leave the Escrow in an inconsistent state where the sum of the total jobBalances is different from its total token balance, since the former are depleted by the function but the latter isnt.  Even if the jobBalances mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the Escrowbalance tracking in a way that doesnt lead to inconsistencies, or using the PullPayment/Escrow solution provided in the OpenZeppelin suite.  Update: the disburseJob function now performs the token transfers.  payUser fails silently if the bonus was already paid  In the payUser function of the AirDrop contract, an if clause is used to check whether a bonus has already been paid. In the case the condition amount &gt; 0 is not satisfied, the payment will not be performed, giving the caller no notice that it didnt go through apart from the lack of an associated event.  Consider complementing the if with an else clause that handles the logic when the condition fails.  Update: an event is now emitted in case the if condition fails.  Unchecked ERC20 transfer operation  Inside the payUser function, a transfer is being made but there are no checks validating its successful completion. If the transfer somehow fails, an event logging the successful operation would be emitted despite the transferee not getting their tokens.  Consider using OpenZeppelins  SafeERC20 library and its safeTransfer function, or surrounding the transfer operation with a require statement.  Update: the SafeERC20 library is now used.  Missing checks for null addresses in  and Airdrop contracts  In , the setEscrowContractAddress function allows the tokens owner to change the escrows address (i.e. the contract variable escrowContractAddress ). However, the function does not implement a check to prevent the null address from being set.  Similarly in Airdrop, the contracts constructor receives as a parameter an address that is assigned to the contract variable renderTokenAddress with no checks preventing the null address from being used.  Consider implementing no-null address validations before setting these variables to avoid potential problems downstream.  Update: null checks are now [in(https://github.com/jeualvarez/Token-Audit/blob/master/contracts/.sol#L88) place for address changes.  Storage modification on event emission  In the addUser function of the Airdrop contract, an item is pushed into the bonusAddresses array. The result of the operation, which is the length for that array after the addition, is used as a parameter in the AddedUser event emission. This, while valid Solidity, is confusing and error-prone.  Consider performing the storage modification and keeping the resulting value in a temporary variable before emitting the event for code clarity.  Update: the temporary value is now assigned to a variable before emitting the event.  Low Severity  Event parameters are not indexed  The AddedUser and PaidUser events defined in Airdrop as well as the JobBalanceUpdate event defined in Escrow are not indexing their parameters. This means that they will not be searchable in terms of those variables, making it impossible to track job balance histories, user additions or payments.  Update: the AddUser and PaidUser events now index their parameters, but the JobBalanceUpdate one still doesnt. String indexing had an associated [web3(https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814) issue , which is purportedly solved in version 1.0. Alternatively, two workarounds for this issue are discussed here.  Deceptive inline comment in Escrow contract  Considering the issue The Escrows owner can arbitrarily increase the balance of any job without spending RNDR tokens above, the comment in Escrow.sol that states: Jobs can only be created through the RNDR contract is false and may be misleading for users reading the contracts code. Consider rephrasing it clearly to state that job balances can be arbitrarily incremented by whatever account the owner of the contract sets as the renderTokenAddress.  Update: the comment was fixed to read: Jobs can only be created by the address stored in the renderTokenAddress variable .  Missing error messages in require statements  Escrow  :L70 ,  Escrow  :L89 ,  Escrow  :L109 ,    :L40 ,    :L45 ) that provide no error messages. Consider including specific and informative error messages in all require statements.  Update: all require statements now provide appropriate error messages.  Missing docstrings in contract and functions in Airdrop contract  TheAirDrop contracts source code, which handles token distribution, has no inline documentation whatsoever. Consider documenting with docstrings everything that is part of the public API.  Update: the AirDrop contract is now thoroughly documented.  Untested functions in   The  contract implements functions (e.g. holdInEscrow ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.  Update: some testing of holdInEscrow was done in the Escrow.js file, but an additional test for this function was added to the .js file.  Broken testing instructions in README files  Token-Audit/README.md file do not work if followed literally. An error   Token-Airdrop/README.md file also do not work, with the error   Consider updating the instructions and including a working cross-platform configuration so developers and auditors can successfully run the test suite. Furthermore, given that the test suite for the Airdrop contract can only be run using thetruffle v5.0.0-beta release, consider including this version of truffle as a dev dependency in the package.json file of the project.  Update: the README files were updated with new testing instructions.  Erroneous documentation in initialize functions  Initialize functions (in Escrow and  ) are incorrectly documented, since these functions are not contract constructors. Consider updating the inline documentation to fix these errors.  Update: documentation now refers to the functions as initializers instead of constructors.  Inconsistent use of imports in contracts  Update: all imports use now a consistent style.  Inconsistent coding style among different files  There is a significant coding-style difference between the contracts in the Token-Audit repository and those in Token-Airdrop repository. The contracts in the first one use docstrings, libraries like OpenZeppelins  SafeMath , and 2-space indentation. The latter, on the other hand, has no comments in the source code nor takes security considerations into account by using already audited libraries, and uses 4-space indentation. Consider following best practices and applying the same style guidelines across all files.  Update: both repositories use now a consistent coding style.  Notes & Additional Information  The addresses of job funders are presumably meant to be tracked off-chain, but consider adding an event-based tracking layer as a failsafe (i.e., _emitting an event identifying the contributor in s holdInEscrow function)._Update: an event is now emitted.  In the Airdrop contract, consider prefixing all internal functions with an underscore to clearly denote their visibility.Update: internal functions are now prefixed with an underscore.  Several public functions can be restricted to external. In particular: functions fundJob, changeDisbursalAddress, changeAddress, disburseJob, and jobBalance in the Escrow contract, and functions addManyUsers, payManyUsers, finalizeList, returnTokens and getUserCount in the AirDrop contract.Update: these functions were restricted to external.  Consider including brackets in all control flow statements (e.g. in Airdrop.sol ) , to prevent issues with future versions of the language.Update: brackets were added.  Consider declaring the canDisburse modifier before all function definitions.Update: the modifier was moved before all functions.  Consider making all instances of uint explicitly uint256 (see Escrow.sol :L72 and Airdrop.sol :L47 ).Update: all uint types are now explicitly uint256.  Variables listFinalized and nextUserToBePaid are explicitly initialized in AirDrop, but totalBonus is not. Consider initializing this last variable explicitly as well for code consistency.Update: totalBonus is now initialized.  Consider explicitly marking all contract variables as private and defining getters/setters where appropriate, or at least explicit setting the visibility of all contract variables (e.g. jobBalances in theEscrow contract is not declared as public)._Update: jobBalances is now declared as private.  In order to load the Airdrop contract to execute the payments, it is necessary that someone with minting privileges or enough tokens adds balance from a  contract to the address of the recently deployed Airdrop contract. For clarity purposes, consider expanding step number five on the instructions in Token-Airdrop/README.md file to clearly state this precondition.Update: the README file has updated wording on this point.  Conclusion  No critical and four high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the OTOY RNDR Token contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#rendertoken", "labels": ["OpenZeppelin"]}, {"title": "_mint function that is declared in", "body": "_mint function that is declared in", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#_mint-function-that-is-declared-in", "labels": ["OpenZeppelin"]}, {"title": "MintableToken , which already has a minting function named", "body": "MintableToken , which already has a minting function named", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#mintabletoken-,-which-already-has-a-minting-function-named", "labels": ["OpenZeppelin"]}, {"title": "mint. Duplicating the minting functionality is confusing and potentially dangerous. Whichever form the migration ends up taking, consider using the already existing", "body": "mint. Duplicating the minting functionality is confusing and potentially dangerous. Whichever form the migration ends up taking, consider using the already existing", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#mint.-duplicating-the-minting-functionality-is-confusing-and-potentially-dangerous.-whichever-form-the-migration-ends-up-taking,-consider-using-the-already-existing", "labels": ["OpenZeppelin"]}, {"title": "Update: The RenderToken contract now extends from openzeppelin-eth'sStandardToken instead of MintableToken, and there is now a single minting function called _mintMigratedTokens.", "body": "Update: The RenderToken contract now extends from openzeppelin-eth'sStandardToken instead of MintableToken, and there is now a single minting function called _mintMigratedTokens.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-rendertoken-contract-now-extends-from-openzeppelin-eth'sstandardtoken-instead-of-mintabletoken,-and-there-is-now-a-single-minting-function-called-_mintmigratedtokens.", "labels": ["OpenZeppelin"]}, {"title": "Input arrays with mismatched length will make addManyUsers throw", "body": "Input arrays with mismatched length will make addManyUsers throw", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#input-arrays-with-mismatched-length-will-make-addmanyusers-throw", "labels": ["OpenZeppelin"]}, {"title": "addManyUsers function in the", "body": "addManyUsers function in the", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#addmanyusers-function-in-the", "labels": ["OpenZeppelin"]}, {"title": "Consider including a require clause with an explicit error message to check for matching array length.", "body": "Consider including a require clause with an explicit error message to check for matching array length.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-including-a-require-clause-with-an-explicit-error-message-to-check-for-matching-array-length.", "labels": ["OpenZeppelin"]}, {"title": "Update: a require statement now checks for matching array length.", "body": "Update: a require statement now checks for matching array length.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-a-require-statement-now-checks-for-matching-array-length.", "labels": ["OpenZeppelin"]}, {"title": "Omission of the transfer in disburseJob leads to inconsistent balance\u00a0state", "body": "Omission of the transfer in disburseJob leads to inconsistent balance\u00a0state", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#omission-of-the-transfer-in-disbursejob-leads-to-inconsistent-balance\u00a0state", "labels": ["OpenZeppelin"]}, {"title": "The RenderToken contract interacts with the Escrow contract by funding jobs, transferring tokens to increase the different jobs\u2019 balances, which are tracked by the Escrow. The disburseJob function later takes care of redistributing these funds among the recipients.", "body": "The RenderToken contract interacts with the Escrow contract by funding jobs, transferring tokens to increase the different jobs\u2019 balances, which are tracked by the Escrow. The disburseJob function later takes care of redistributing these funds among the recipients.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#the-rendertoken-contract-interacts-with-the-escrow-contract-by-funding-jobs,-transferring-tokens-to-increase-the-different-jobs\u2019-balances,-which-are-tracked-by-the-escrow.-the-disbursejob-function-later-takes-care-of-redistributing-these-funds-among-the-recipients.", "labels": ["OpenZeppelin"]}, {"title": "This function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the disburseJobfunction will leave the Escrow in an inconsistent state where the sum of the total jobBalances is different from its total token balance, since the former are depleted by the function but the latter isn\u2019t.", "body": "This function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the disburseJobfunction will leave the Escrow in an inconsistent state where the sum of the total jobBalances is different from its total token balance, since the former are depleted by the function but the latter isn\u2019t.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#this-function,-however,-does-not-actually-transfer-the-tokens-to-the-recipients,-but-simply-sets-an-allowance,-which-the-recipients-can-then-use-to-transfer-the-tokens-themselves.-while-there-is-merit-in-using-a-pattern-where-the-beneficiaries-are-in-charge-of-withdrawing-their-funds,-the-disbursejobfunction-will-leave-the-escrow-in-an-inconsistent-state-where-the-sum-of-the-total-jobbalances-is-different-from-its-total-token-balance,-since-the-former-are-depleted-by-the-function-but-the-latter-isn\u2019t.", "labels": ["OpenZeppelin"]}, {"title": "Even if the jobBalances mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the Escrowbalance tracking in a way that doesn\u2019t lead to inconsistencies, or using the PullPayment/Escrow solution provided in the OpenZeppelin suite.", "body": "Even if the jobBalances mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the Escrowbalance tracking in a way that doesn\u2019t lead to inconsistencies, or using the PullPayment/Escrow solution provided in the OpenZeppelin suite.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#even-if-the-jobbalances-mapping-cannot-be-traversed-to-get-the-total-balance-without-an-external-listing-of-jobs,-consider-implementing-the-escrowbalance-tracking-in-a-way-that-doesn\u2019t-lead-to-inconsistencies,-or-using-the-pullpayment/escrow-solution-provided-in-the-openzeppelin-suite.", "labels": ["OpenZeppelin"]}, {"title": "Update: the disburseJob function now performs the token transfers.", "body": "Update: the disburseJob function now performs the token transfers.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-disbursejob-function-now-performs-the-token-transfers.", "labels": ["OpenZeppelin"]}, {"title": "payUser fails silently if the bonus was already\u00a0paid", "body": "payUser fails silently if the bonus was already\u00a0paid", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#payuser-fails-silently-if-the-bonus-was-already\u00a0paid", "labels": ["OpenZeppelin"]}, {"title": "In the payUser function of the AirDrop contract, an if clause is used to check whether a bonus has already been paid. In the case the condition amount &gt; 0 is not satisfied, the payment will not be performed, giving the caller no notice that it didn\u2019t go through apart from the lack of an associated event.", "body": "In the payUser function of the AirDrop contract, an if clause is used to check whether a bonus has already been paid. In the case the condition amount &gt; 0 is not satisfied, the payment will not be performed, giving the caller no notice that it didn\u2019t go through apart from the lack of an associated event.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#in-the-payuser-function-of-the-airdrop-contract,-an-if-clause-is-used-to-check-whether-a-bonus-has-already-been-paid.-in-the-case-the-condition-amount-&gt;-0-is-not-satisfied,-the-payment-will-not-be-performed,-giving-the-caller-no-notice-that-it-didn\u2019t-go-through-apart-from-the-lack-of-an-associated-event.", "labels": ["OpenZeppelin"]}, {"title": "Consider complementing the if with an else clause that handles the logic when the condition fails.", "body": "Consider complementing the if with an else clause that handles the logic when the condition fails.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-complementing-the-if-with-an-else-clause-that-handles-the-logic-when-the-condition-fails.", "labels": ["OpenZeppelin"]}, {"title": "Update: an event is now emitted in case the if condition fails.", "body": "Update: an event is now emitted in case the if condition fails.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-an-event-is-now-emitted-in-case-the-if-condition-fails.", "labels": ["OpenZeppelin"]}, {"title": "Unchecked ERC20 transfer operation", "body": "Unchecked ERC20 transfer operation", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#unchecked-erc20-transfer-operation", "labels": ["OpenZeppelin"]}, {"title": "Inside the payUser function, a transfer is being made but there are no checks validating its successful completion. If the transfer somehow fails, an event logging the successful operation would be emitted despite the transferee not getting their tokens.", "body": "Inside the payUser function, a transfer is being made but there are no checks validating its successful completion. If the transfer somehow fails, an event logging the successful operation would be emitted despite the transferee not getting their tokens.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#inside-the-payuser-function,-a-transfer-is-being-made-but-there-are-no-checks-validating-its-successful-completion.-if-the-transfer-somehow-fails,-an-event-logging-the-successful-operation-would-be-emitted-despite-the-transferee-not-getting-their-tokens.", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s  SafeERC20 library and its safeTransfer function, or surrounding the transfer operation with a require statement.", "body": "Consider using OpenZeppelin\u2019s  SafeERC20 library and its safeTransfer function, or surrounding the transfer operation with a require statement.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-using-openzeppelin\u2019s--safeerc20-library-and-its-safetransfer-function,-or-surrounding-the-transfer-operation-with-a-require-statement.", "labels": ["OpenZeppelin"]}, {"title": "Update: the SafeERC20 library is now used.", "body": "Update: the SafeERC20 library is now used.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-safeerc20-library-is-now-used.", "labels": ["OpenZeppelin"]}, {"title": "Missing checks for null addresses in RenderToken and Airdrop contracts", "body": "Missing checks for null addresses in RenderToken and Airdrop contracts", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#missing-checks-for-null-addresses-in-rendertoken-and-airdrop-contracts", "labels": ["OpenZeppelin"]}, {"title": "In RenderToken, the setEscrowContractAddress function allows the token\u2019s owner to change the escrow\u2019s address (i.e. the contract variable escrowContractAddress ). However, the function does not implement a check to prevent the null address from being set.", "body": "In RenderToken, the setEscrowContractAddress function allows the token\u2019s owner to change the escrow\u2019s address (i.e. the contract variable escrowContractAddress ). However, the function does not implement a check to prevent the null address from being set.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#in-rendertoken,-the-setescrowcontractaddress-function-allows-the-token\u2019s-owner-to-change-the-escrow\u2019s-address-(i.e.-the-contract-variable-escrowcontractaddress-).-however,-the-function-does-not-implement-a-check-to-prevent-the-null-address-from-being-set.", "labels": ["OpenZeppelin"]}, {"title": "Similarly in Airdrop, the contract\u2019s constructor receives as a parameter an address that is assigned to the contract variable renderTokenAddress with no checks preventing the null address from being used.", "body": "Similarly in Airdrop, the contract\u2019s constructor receives as a parameter an address that is assigned to the contract variable renderTokenAddress with no checks preventing the null address from being used.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#similarly-in-airdrop,-the-contract\u2019s-constructor-receives-as-a-parameter-an-address-that-is-assigned-to-the-contract-variable-rendertokenaddress-with-no-checks-preventing-the-null-address-from-being-used.", "labels": ["OpenZeppelin"]}, {"title": "Consider implementing no-null address validations before setting these variables to avoid potential problems downstream.", "body": "Consider implementing no-null address validations before setting these variables to avoid potential problems downstream.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-implementing-no-null-address-validations-before-setting-these-variables-to-avoid-potential-problems-downstream.", "labels": ["OpenZeppelin"]}, {"title": "Update: null checks are now [in(https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L88) place for address changes.", "body": "Update: null checks are now [in(https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L88) place for address changes.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-null-checks-are-now-[in(https://github.com/jeualvarez/token-audit/blob/master/contracts/rendertoken.sol#l88)-place-for-address-changes.", "labels": ["OpenZeppelin"]}, {"title": "Storage modification on event\u00a0emission", "body": "Storage modification on event\u00a0emission", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#storage-modification-on-event\u00a0emission", "labels": ["OpenZeppelin"]}, {"title": "In the addUser function of the Airdrop contract, an item is pushed into the bonusAddresses array. The result of the operation, which is the length for that array after the addition, is used as a parameter in the AddedUser event emission. This, while valid Solidity, is confusing and error-prone.", "body": "In the addUser function of the Airdrop contract, an item is pushed into the bonusAddresses array. The result of the operation, which is the length for that array after the addition, is used as a parameter in the AddedUser event emission. This, while valid Solidity, is confusing and error-prone.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#in-the-adduser-function-of-the-airdrop-contract,-an-item-is-pushed-into-the-bonusaddresses-array.-the-result-of-the-operation,-which-is-the-length-for-that-array-after-the-addition,-is-used-as-a-parameter-in-the-addeduser-event-emission.-this,-while-valid-solidity,-is-confusing-and-error-prone.", "labels": ["OpenZeppelin"]}, {"title": "Consider performing the storage modification and keeping the resulting value in a temporary variable before emitting the event for code clarity.", "body": "Consider performing the storage modification and keeping the resulting value in a temporary variable before emitting the event for code clarity.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-performing-the-storage-modification-and-keeping-the-resulting-value-in-a-temporary-variable-before-emitting-the-event-for-code-clarity.", "labels": ["OpenZeppelin"]}, {"title": "Update: the temporary value is now assigned to a variable before emitting the event.", "body": "Update: the temporary value is now assigned to a variable before emitting the event.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-temporary-value-is-now-assigned-to-a-variable-before-emitting-the-event.", "labels": ["OpenZeppelin"]}, {"title": "Event parameters are not\u00a0indexed", "body": "Event parameters are not\u00a0indexed", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#event-parameters-are-not\u00a0indexed", "labels": ["OpenZeppelin"]}, {"title": "The AddedUser and PaidUser events defined in Airdrop as well as the JobBalanceUpdate event defined in Escrow are not indexing their parameters. This means that they will not be searchable in terms of those variables, making it impossible to track job balance histories, user additions or payments.", "body": "The AddedUser and PaidUser events defined in Airdrop as well as the JobBalanceUpdate event defined in Escrow are not indexing their parameters. This means that they will not be searchable in terms of those variables, making it impossible to track job balance histories, user additions or payments.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#the-addeduser-and-paiduser-events-defined-in-airdrop-as-well-as-the-jobbalanceupdate-event-defined-in-escrow-are-not-indexing-their-parameters.-this-means-that-they-will-not-be-searchable-in-terms-of-those-variables,-making-it-impossible-to-track-job-balance-histories,-user-additions-or-payments.", "labels": ["OpenZeppelin"]}, {"title": "Update: the AddUser and PaidUser events now index their parameters, but the JobBalanceUpdate one still doesn\u2019t. String indexing had an associated [web3(https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814) issue , which is purportedly solved in version 1.0. Alternatively, two workarounds for this issue are discussed here.", "body": "Update: the AddUser and PaidUser events now index their parameters, but the JobBalanceUpdate one still doesn\u2019t. String indexing had an associated [web3(https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814) issue , which is purportedly solved in version 1.0. Alternatively, two workarounds for this issue are discussed here.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-adduser-and-paiduser-events-now-index-their-parameters,-but-the-jobbalanceupdate-one-still-doesn\u2019t.-string-indexing-had-an-associated-[web3(https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814)-issue-,-which-is-purportedly-solved-in-version-1.0.-alternatively,-two-workarounds-for-this-issue-are-discussed-here.", "labels": ["OpenZeppelin"]}, {"title": "Deceptive inline comment in Escrow\u00a0contract", "body": "Deceptive inline comment in Escrow\u00a0contract", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#deceptive-inline-comment-in-escrow\u00a0contract", "labels": ["OpenZeppelin"]}, {"title": "Considering the issue \u201cThe Escrow\u2019s owner can arbitrarily increase the balance of any job without spending RNDR tokens\u201d above, the comment in Escrow.sol that states: \u201cJobs can only be created through the RNDR contract\u201d is false and may be misleading for users reading the contract\u2019s code. Consider rephrasing it clearly to state that job balances can be arbitrarily incremented by whatever account the owner of the contract sets as the renderTokenAddress.", "body": "Considering the issue \u201cThe Escrow\u2019s owner can arbitrarily increase the balance of any job without spending RNDR tokens\u201d above, the comment in Escrow.sol that states: \u201cJobs can only be created through the RNDR contract\u201d is false and may be misleading for users reading the contract\u2019s code. Consider rephrasing it clearly to state that job balances can be arbitrarily incremented by whatever account the owner of the contract sets as the renderTokenAddress.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#considering-the-issue-\u201cthe-escrow\u2019s-owner-can-arbitrarily-increase-the-balance-of-any-job-without-spending-rndr-tokens\u201d-above,-the-comment-in-escrow.sol-that-states:-\u201cjobs-can-only-be-created-through-the-rndr-contract\u201d-is-false-and-may-be-misleading-for-users-reading-the-contract\u2019s-code.-consider-rephrasing-it-clearly-to-state-that-job-balances-can-be-arbitrarily-incremented-by-whatever-account-the-owner-of-the-contract-sets-as-the-rendertokenaddress.", "labels": ["OpenZeppelin"]}, {"title": "Update: the comment was fixed to read: \u201cJobs can only be created by the address stored in the renderTokenAddress variable \u201d.", "body": "Update: the comment was fixed to read: \u201cJobs can only be created by the address stored in the renderTokenAddress variable \u201d.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-comment-was-fixed-to-read:-\u201cjobs-can-only-be-created-by-the-address-stored-in-the-rendertokenaddress-variable-\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Missing error messages in require statements", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Escrow", "body": ".sol , where a comment states that the function [\u2026] is included as a failsafe, the issues that this mechanism would prevent from occurring are never explained.  Update: an event is now emitted when the changeRenderTokenAddress function is called, and documentation was added explaining the rationale for having this function.  Unsafe arithmetic operations in Airdrop contract  30 ,  39 ,  56 ,  58 ,  64 and  65 ) , leading to attempts to store numbers outside the range of the data types of their target variables. There are in particular two situations which could potentially cause integer overflows/underflows.  addManyUsers function. This function iterates through a  addUser is called, which adds the respective user amount to the storage variable  payManyUsers function could lead to an integer underflow. After the contract is deployed, the storage variable  nextUserToBePaid equals 0. When calling  payManyUsers , if 0 was passed as the value of the  immediately followin  if  clause would prevent something unexpected to happen, this approach is error-prone and not advised.  Consider using OpenZeppelins  SafeMath library to avoid underflows/overflows when doing mathematical operations.  Update: the SafeMath library is now being used throughout.  Contract owners can change business logic unnoticeably  In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:  RenderToken#setContractAddress :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.  #changeRenderTokenAddress : the address of the token contract.  #changeDisbursalAddress : the address authorized to distribute tokens for completed jobs.  Consider emitting events to notify users about any modifications of such importance in the contracts business logic.  Update: events are now emitted to provide users with a mechanism to track these changes.  Inconsistent and experimental use of Solidity versions  While the individual contracts can be compiled using different versions of the Solidity compiler, profuse versioning among the same codebase is confusing and error-prone. As indicated by its name, the experimental feature should not be used in production.  Consider using the latest (0.4.25 at the time of writing) version of the Solidity compiler throughout the code.  Update: Solidity version v0.4.24 is now used throughout the project.  Medium Severity  Two different minting functions coexist in the RenderToken contract  LegacyToken.sol and  MigratableERC20.sol files were extracted from an  example provided as a guide in an early version of ZeppelinOS. This guide explains how to migrate old token balances by burning old and minting new tokens, for which it introduced a  _mint function in the new token, which extended  openzeppelin-zos (now renamed to  RenderToken  _mint function that is declared in  MintableToken , which already has a minting function named  mint. Duplicating the minting functionality is confusing and potentially dangerous. Whichever form the migration ends up taking, consider using the already existing  Update: The RenderToken contract now extends from openzeppelin-eth'sStandardToken instead of MintableToken, and there is now a single minting function called _mintMigratedTokens.  Input arrays with mismatched length will make addManyUsers throw  addManyUsers function in the  Consider including a require clause with an explicit error message to check for matching array length.  Update: a require statement now checks for matching array length.  Omission of the transfer in disburseJob leads to inconsistent balance state  The RenderToken contract interacts with the  contract by funding jobs, transferring tokens to increase the different jobs balances, which are tracked by the . The disburseJob function later takes care of redistributing these funds among the recipients.  This function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the disburseJobfunction will leave the  in an inconsistent state where the sum of the total jobBalances is different from its total token balance, since the former are depleted by the function but the latter isnt.  Even if the jobBalances mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the balance tracking in a way that doesnt lead to inconsistencies, or using the PullPayment/ solution provided in the OpenZeppelin suite.  Update: the disburseJob function now performs the token transfers.  payUser fails silently if the bonus was already paid  In the payUser function of the AirDrop contract, an if clause is used to check whether a bonus has already been paid. In the case the condition amount &gt; 0 is not satisfied, the payment will not be performed, giving the caller no notice that it didnt go through apart from the lack of an associated event.  Consider complementing the if with an else clause that handles the logic when the condition fails.  Update: an event is now emitted in case the if condition fails.  Unchecked ERC20 transfer operation  Inside the payUser function, a transfer is being made but there are no checks validating its successful completion. If the transfer somehow fails, an event logging the successful operation would be emitted despite the transferee not getting their tokens.  Consider using OpenZeppelins  SafeERC20 library and its safeTransfer function, or surrounding the transfer operation with a require statement.  Update: the SafeERC20 library is now used.  Missing checks for null addresses in RenderToken and Airdrop contracts  In RenderToken, the setContractAddress function allows the tokens owner to change the escrows address (i.e. the contract variable escrowContractAddress ). However, the function does not implement a check to prevent the null address from being set.  Similarly in Airdrop, the contracts constructor receives as a parameter an address that is assigned to the contract variable renderTokenAddress with no checks preventing the null address from being used.  Consider implementing no-null address validations before setting these variables to avoid potential problems downstream.  Update: null checks are now [in(https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L88) place for address changes.  Storage modification on event emission  In the addUser function of the Airdrop contract, an item is pushed into the bonusAddresses array. The result of the operation, which is the length for that array after the addition, is used as a parameter in the AddedUser event emission. This, while valid Solidity, is confusing and error-prone.  Consider performing the storage modification and keeping the resulting value in a temporary variable before emitting the event for code clarity.  Update: the temporary value is now assigned to a variable before emitting the event.  Low Severity  Event parameters are not indexed  The AddedUser and PaidUser events defined in Airdrop as well as the JobBalanceUpdate event defined in  are not indexing their parameters. This means that they will not be searchable in terms of those variables, making it impossible to track job balance histories, user additions or payments.  Update: the AddUser and PaidUser events now index their parameters, but the JobBalanceUpdate one still doesnt. String indexing had an associated [web3(https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814) issue , which is purportedly solved in version 1.0. Alternatively, two workarounds for this issue are discussed here.  Deceptive inline comment in  contract  Considering the issue The s owner can arbitrarily increase the balance of any job without spending RNDR tokens above, the comment in .sol that states: Jobs can only be created through the RNDR contract is false and may be misleading for users reading the contracts code. Consider rephrasing it clearly to state that job balances can be arbitrarily incremented by whatever account the owner of the contract sets as the renderTokenAddress.  Update: the comment was fixed to read: Jobs can only be created by the address stored in the renderTokenAddress variable .  Missing error messages in require statements    :L70 ,    :L89 ,    :L109 ,  RenderToken  :L40 ,  RenderToken  :L45 ) that provide no error messages. Consider including specific and informative error messages in all require statements.  Update: all require statements now provide appropriate error messages.  Missing docstrings in contract and functions in Airdrop contract  TheAirDrop contracts source code, which handles token distribution, has no inline documentation whatsoever. Consider documenting with docstrings everything that is part of the public API.  Update: the AirDrop contract is now thoroughly documented.  Untested functions in RenderToken  The RenderToken contract implements functions (e.g. holdIn ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.  Update: some testing of holdIn was done in the .js file, but an additional test for this function was added to the RenderToken.js file.  Broken testing instructions in README files  Token-Audit/README.md file do not work if followed literally. An error   Token-Airdrop/README.md file also do not work, with the error   Consider updating the instructions and including a working cross-platform configuration so developers and auditors can successfully run the test suite. Furthermore, given that the test suite for the Airdrop contract can only be run using thetruffle v5.0.0-beta release, consider including this version of truffle as a dev dependency in the package.json file of the project.  Update: the README files were updated with new testing instructions.  Erroneous documentation in initialize functions  Initialize functions (in  and RenderToken ) are incorrectly documented, since these functions are not contract constructors. Consider updating the inline documentation to fix these errors.  Update: documentation now refers to the functions as initializers instead of constructors.  Inconsistent use of imports in contracts  Update: all imports use now a consistent style.  Inconsistent coding style among different files  There is a significant coding-style difference between the contracts in the Token-Audit repository and those in Token-Airdrop repository. The contracts in the first one use docstrings, libraries like OpenZeppelins  SafeMath , and 2-space indentation. The latter, on the other hand, has no comments in the source code nor takes security considerations into account by using already audited libraries, and uses 4-space indentation. Consider following best practices and applying the same style guidelines across all files.  Update: both repositories use now a consistent coding style.  Notes & Additional Information  The addresses of job funders are presumably meant to be tracked off-chain, but consider adding an event-based tracking layer as a failsafe (i.e., _emitting an event identifying the contributor in RenderTokens holdIn function)._Update: an event is now emitted.  In the Airdrop contract, consider prefixing all internal functions with an underscore to clearly denote their visibility.Update: internal functions are now prefixed with an underscore.  Several public functions can be restricted to external. In particular: functions fundJob, changeDisbursalAddress, changeRenderTokenAddress, disburseJob, and jobBalance in the  contract, and functions addManyUsers, payManyUsers, finalizeList, returnTokens and getUserCount in the AirDrop contract.Update: these functions were restricted to external.  Consider including brackets in all control flow statements (e.g. in Airdrop.sol ) , to prevent issues with future versions of the language.Update: brackets were added.  Consider declaring the canDisburse modifier before all function definitions.Update: the modifier was moved before all functions.  Consider making all instances of uint explicitly uint256 (see .sol :L72 and Airdrop.sol :L47 ).Update: all uint types are now explicitly uint256.  Variables listFinalized and nextUserToBePaid are explicitly initialized in AirDrop, but totalBonus is not. Consider initializing this last variable explicitly as well for code consistency.Update: totalBonus is now initialized.  Consider explicitly marking all contract variables as private and defining getters/setters where appropriate, or at least explicit setting the visibility of all contract variables (e.g. jobBalances in the contract is not declared as public)._Update: jobBalances is now declared as private.  In order to load the Airdrop contract to execute the payments, it is necessary that someone with minting privileges or enough tokens adds balance from a RenderToken contract to the address of the recently deployed Airdrop contract. For clarity purposes, consider expanding step number five on the instructions in Token-Airdrop/README.md file to clearly state this precondition.Update: the README file has updated wording on this point.  Conclusion  No critical and four high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the OTOY RNDR Token contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#escrow", "labels": ["OpenZeppelin"]}, {"title": ":L70 ,", "body": ":L70 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#:l70-,", "labels": ["OpenZeppelin"]}, {"title": ":L89 ,", "body": ":L89 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#:l89-,", "labels": ["OpenZeppelin"]}, {"title": ":L109 ,", "body": ":L109 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#:l109-,", "labels": ["OpenZeppelin"]}, {"title": ":L40 ,", "body": ":L40 ,", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#:l40-,", "labels": ["OpenZeppelin"]}, {"title": ":L45 ) that provide no error messages. Consider including specific and informative error messages in all require statements.", "body": ":L45 ) that provide no error messages. Consider including specific and informative error messages in all require statements.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#:l45-)-that-provide-no-error-messages.-consider-including-specific-and-informative-error-messages-in-all-require-statements.", "labels": ["OpenZeppelin"]}, {"title": "Update: all require statements now provide appropriate error messages.", "body": "Update: all require statements now provide appropriate error messages.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-all-require-statements-now-provide-appropriate-error-messages.", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings in contract and functions in Airdrop\u00a0contract", "body": "Missing docstrings in contract and functions in Airdrop\u00a0contract", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#missing-docstrings-in-contract-and-functions-in-airdrop\u00a0contract", "labels": ["OpenZeppelin"]}, {"title": "TheAirDrop contract\u2019s source code, which handles token distribution, has no inline documentation whatsoever. Consider documenting with docstrings everything that is part of the public API.", "body": "TheAirDrop contract\u2019s source code, which handles token distribution, has no inline documentation whatsoever. Consider documenting with docstrings everything that is part of the public API.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#theairdrop-contract\u2019s-source-code,-which-handles-token-distribution,-has-no-inline-documentation-whatsoever.-consider-documenting-with-docstrings-everything-that-is-part-of-the-public-api.", "labels": ["OpenZeppelin"]}, {"title": "Update: the AirDrop contract is now thoroughly documented.", "body": "Update: the AirDrop contract is now thoroughly documented.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-airdrop-contract-is-now-thoroughly-documented.", "labels": ["OpenZeppelin"]}, {"title": "Untested functions in RenderToken", "body": "Untested functions in RenderToken", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#untested-functions-in-rendertoken", "labels": ["OpenZeppelin"]}, {"title": "The RenderToken contract implements functions (e.g. holdInEscrow ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.", "body": "The RenderToken contract implements functions (e.g. holdInEscrow ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#the-rendertoken-contract-implements-functions-(e.g.-holdinescrow-)-that-are-not-being-tested-in-the-test-suite.-consider-testing-all-functions-implemented-in-contracts-to-ensure-they-behave-as-expected.", "labels": ["OpenZeppelin"]}, {"title": "Update: some testing of holdInEscrow was done in the Escrow.js file, but an additional test for this function was added to the RenderToken.js file.", "body": "Update: some testing of holdInEscrow was done in the Escrow.js file, but an additional test for this function was added to the RenderToken.js file.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-some-testing-of-holdinescrow-was-done-in-the-escrow.js-file,-but-an-additional-test-for-this-function-was-added-to-the-rendertoken.js-file.", "labels": ["OpenZeppelin"]}, {"title": "Broken testing instructions in README\u00a0files", "body": "Broken testing instructions in README\u00a0files", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#broken-testing-instructions-in-readme\u00a0files", "labels": ["OpenZeppelin"]}, {"title": "Token-Audit/README.md file do not work if followed literally. An error \u201c", "body": "Token-Audit/README.md file do not work if followed literally. An error \u201c", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#token-audit/readme.md-file-do-not-work-if-followed-literally.-an-error-\u201c", "labels": ["OpenZeppelin"]}, {"title": "Token-Airdrop/README.md file also do not work, with the error \u201c", "body": "Token-Airdrop/README.md file also do not work, with the error \u201c", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#token-airdrop/readme.md-file-also-do-not-work,-with-the-error-\u201c", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the instructions and including a working cross-platform configuration so developers and auditors can successfully run the test suite. Furthermore, given that the test suite for the Airdrop contract can only be run using thetruffle v5.0.0-beta release, consider including this version of truffle as a dev dependency in the package.json file of the project.", "body": "Consider updating the instructions and including a working cross-platform configuration so developers and auditors can successfully run the test suite. Furthermore, given that the test suite for the Airdrop contract can only be run using thetruffle v5.0.0-beta release, consider including this version of truffle as a dev dependency in the package.json file of the project.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-updating-the-instructions-and-including-a-working-cross-platform-configuration-so-developers-and-auditors-can-successfully-run-the-test-suite.-furthermore,-given-that-the-test-suite-for-the-airdrop-contract-can-only-be-run-using-thetruffle-v5.0.0-beta-release,-consider-including-this-version-of-truffle-as-a-dev-dependency-in-the-package.json-file-of-the-project.", "labels": ["OpenZeppelin"]}, {"title": "Update: the README files were updated with new testing instructions.", "body": "Update: the README files were updated with new testing instructions.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-the-readme-files-were-updated-with-new-testing-instructions.", "labels": ["OpenZeppelin"]}, {"title": "Erroneous documentation in initialize functions", "body": "Erroneous documentation in initialize functions", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#erroneous-documentation-in-initialize-functions", "labels": ["OpenZeppelin"]}, {"title": "Initialize functions (in Escrow and RenderToken ) are incorrectly documented, since these functions are not contract constructors. Consider updating the inline documentation to fix these errors.", "body": "Initialize functions (in Escrow and RenderToken ) are incorrectly documented, since these functions are not contract constructors. Consider updating the inline documentation to fix these errors.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#initialize-functions-(in-escrow-and-rendertoken-)-are-incorrectly-documented,-since-these-functions-are-not-contract-constructors.-consider-updating-the-inline-documentation-to-fix-these-errors.", "labels": ["OpenZeppelin"]}, {"title": "Update: documentation now refers to the functions as initializers instead of constructors.", "body": "Update: documentation now refers to the functions as initializers instead of constructors.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-documentation-now-refers-to-the-functions-as-initializers-instead-of-constructors.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of imports in contracts", "body": "Inconsistent use of imports in contracts", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#inconsistent-use-of-imports-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "Update: all imports use now a consistent style.", "body": "Update: all imports use now a consistent style.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-all-imports-use-now-a-consistent-style.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent coding style among different files", "body": "Inconsistent coding style among different files", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#inconsistent-coding-style-among-different-files", "labels": ["OpenZeppelin"]}, {"title": "There is a significant coding-style difference between the contracts in the Token-Audit repository and those in Token-Airdrop repository. The contracts in the first one use docstrings, libraries like OpenZeppelin\u2019s  SafeMath , and 2-space indentation. The latter, on the other hand, has no comments in the source code nor takes security considerations into account by using already audited libraries, and uses 4-space indentation. Consider following best practices and applying the same style guidelines across all files.", "body": "There is a significant coding-style difference between the contracts in the Token-Audit repository and those in Token-Airdrop repository. The contracts in the first one use docstrings, libraries like OpenZeppelin\u2019s  SafeMath , and 2-space indentation. The latter, on the other hand, has no comments in the source code nor takes security considerations into account by using already audited libraries, and uses 4-space indentation. Consider following best practices and applying the same style guidelines across all files.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#there-is-a-significant-coding-style-difference-between-the-contracts-in-the-token-audit-repository-and-those-in-token-airdrop-repository.-the-contracts-in-the-first-one-use-docstrings,-libraries-like-openzeppelin\u2019s--safemath-,-and-2-space-indentation.-the-latter,-on-the-other-hand,-has-no-comments-in-the-source-code-nor-takes-security-considerations-into-account-by-using-already-audited-libraries,-and-uses-4-space-indentation.-consider-following-best-practices-and-applying-the-same-style-guidelines-across-all-files.", "labels": ["OpenZeppelin"]}, {"title": "Update: both repositories use now a consistent coding style.", "body": "Update: both repositories use now a consistent coding style.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#update:-both-repositories-use-now-a-consistent-coding-style.", "labels": ["OpenZeppelin"]}, {"title": "The addresses of job funders are presumably meant to be tracked off-chain, but consider adding an event-based tracking layer as a failsafe (i.e., _emitting an event identifying the contributor in RenderToken\u2018s holdInEscrow function)._Update: an event is now emitted.", "body": "The addresses of job funders are presumably meant to be tracked off-chain, but consider adding an event-based tracking layer as a failsafe (i.e., _emitting an event identifying the contributor in RenderToken\u2018s holdInEscrow function)._Update: an event is now emitted.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#the-addresses-of-job-funders-are-presumably-meant-to-be-tracked-off-chain,-but-consider-adding-an-event-based-tracking-layer-as-a-failsafe-(i.e.,-_emitting-an-event-identifying-the-contributor-in-rendertoken\u2018s-holdinescrow-function)._update:-an-event-is-now-emitted.", "labels": ["OpenZeppelin"]}, {"title": "In the Airdrop contract, consider prefixing all internal functions with an underscore to clearly denote their visibility.Update: internal functions are now prefixed with an underscore.", "body": "In the Airdrop contract, consider prefixing all internal functions with an underscore to clearly denote their visibility.Update: internal functions are now prefixed with an underscore.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#in-the-airdrop-contract,-consider-prefixing-all-internal-functions-with-an-underscore-to-clearly-denote-their-visibility.update:-internal-functions-are-now-prefixed-with-an-underscore.", "labels": ["OpenZeppelin"]}, {"title": "Several public functions can be restricted to external. In particular: functions fundJob, changeDisbursalAddress, changeRenderTokenAddress, disburseJob, and jobBalance in the Escrow contract, and functions addManyUsers, payManyUsers, finalizeList, returnTokens and getUserCount in the AirDrop contract.Update: these functions were restricted to external.", "body": "Several public functions can be restricted to external. In particular: functions fundJob, changeDisbursalAddress, changeRenderTokenAddress, disburseJob, and jobBalance in the Escrow contract, and functions addManyUsers, payManyUsers, finalizeList, returnTokens and getUserCount in the AirDrop contract.Update: these functions were restricted to external.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#several-public-functions-can-be-restricted-to-external.-in-particular:-functions-fundjob,-changedisbursaladdress,-changerendertokenaddress,-disbursejob,-and-jobbalance-in-the-escrow-contract,-and-functions-addmanyusers,-paymanyusers,-finalizelist,-returntokens-and-getusercount-in-the-airdrop-contract.update:-these-functions-were-restricted-to-external.", "labels": ["OpenZeppelin"]}, {"title": "Consider including brackets in all control flow statements (e.g. in Airdrop.sol ) , to prevent issues with future versions of the language.Update: brackets were added.", "body": "Consider including brackets in all control flow statements (e.g. in Airdrop.sol ) , to prevent issues with future versions of the language.Update: brackets were added.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-including-brackets-in-all-control-flow-statements-(e.g.-in-airdrop.sol-)-,-to-prevent-issues-with-future-versions-of-the-language.update:-brackets-were-added.", "labels": ["OpenZeppelin"]}, {"title": "Consider declaring the canDisburse modifier before all function definitions.Update: the modifier was moved before all functions.", "body": "Consider declaring the canDisburse modifier before all function definitions.Update: the modifier was moved before all functions.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-declaring-the-candisburse-modifier-before-all-function-definitions.update:-the-modifier-was-moved-before-all-functions.", "labels": ["OpenZeppelin"]}, {"title": "Consider making all instances of uint explicitly uint256 (see Escrow.sol :L72 and Airdrop.sol :L47 ).Update: all uint types are now explicitly uint256.", "body": "Consider making all instances of uint explicitly uint256 (see Escrow.sol :L72 and Airdrop.sol :L47 ).Update: all uint types are now explicitly uint256.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-making-all-instances-of-uint-explicitly-uint256-(see-escrow.sol-:l72-and-airdrop.sol-:l47-).update:-all-uint-types-are-now-explicitly-uint256.", "labels": ["OpenZeppelin"]}, {"title": "Variables listFinalized and nextUserToBePaid are explicitly initialized in AirDrop, but totalBonus is not. Consider initializing this last variable explicitly as well for code consistency.Update: totalBonus is now initialized.", "body": "Variables listFinalized and nextUserToBePaid are explicitly initialized in AirDrop, but totalBonus is not. Consider initializing this last variable explicitly as well for code consistency.Update: totalBonus is now initialized.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#variables-listfinalized-and-nextusertobepaid-are-explicitly-initialized-in-airdrop,-but-totalbonus-is-not.-consider-initializing-this-last-variable-explicitly-as-well-for-code-consistency.update:-totalbonus-is-now-initialized.", "labels": ["OpenZeppelin"]}, {"title": "Consider explicitly marking all contract variables as private and defining getters/setters where appropriate, or at least explicit setting the visibility of all contract variables (e.g. jobBalances in theEscrow contract is not declared as public)._Update: jobBalances is now declared as private.", "body": "Consider explicitly marking all contract variables as private and defining getters/setters where appropriate, or at least explicit setting the visibility of all contract variables (e.g. jobBalances in theEscrow contract is not declared as public)._Update: jobBalances is now declared as private.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#consider-explicitly-marking-all-contract-variables-as-private-and-defining-getters/setters-where-appropriate,-or-at-least-explicit-setting-the-visibility-of-all-contract-variables-(e.g.-jobbalances-in-theescrow-contract-is-not-declared-as-public)._update:-jobbalances-is-now-declared-as-private.", "labels": ["OpenZeppelin"]}, {"title": "In order to load the Airdrop contract to execute the payments, it is necessary that someone with minting privileges or enough tokens adds balance from a RenderToken contract to the address of the recently deployed Airdrop contract. For clarity purposes, consider expanding step number five on the instructions in Token-Airdrop/README.md file to clearly state this precondition.Update: the README file has updated wording on this point.", "body": "In order to load the Airdrop contract to execute the payments, it is necessary that someone with minting privileges or enough tokens adds balance from a RenderToken contract to the address of the recently deployed Airdrop contract. For clarity purposes, consider expanding step number five on the instructions in Token-Airdrop/README.md file to clearly state this precondition.Update: the README file has updated wording on this point.", "html_url": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849#in-order-to-load-the-airdrop-contract-to-execute-the-payments,-it-is-necessary-that-someone-with-minting-privileges-or-enough-tokens-adds-balance-from-a-rendertoken-contract-to-the-address-of-the-recently-deployed-airdrop-contract.-for-clarity-purposes,-consider-expanding-step-number-five-on-the-instructions-in-token-airdrop/readme.md-file-to-clearly-state-this-precondition.update:-the-readme-file-has-updated-wording-on-this-point.", "labels": ["OpenZeppelin"]}, {"title": "CRITICAL: Incorrect library addresses can be injected while linking.", "body": "CRITICAL: Incorrect library addresses can be injected while linking.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#critical:-incorrect-library-addresses-can-be-injected-while-linking.", "labels": ["OpenZeppelin"]}, {"title": "CRITICAL: Comments can be disguised as executable code.", "body": "CRITICAL: Comments can be disguised as executable code.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#critical:-comments-can-be-disguised-as-executable-code.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: Model is very complex and could use more documentation.", "body": "HIGH: Model is very complex and could use more documentation.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-model-is-very-complex-and-could-use-more-documentation.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: Known issues only emit warnings for backwards compatibility.", "body": "HIGH: Known issues only emit warnings for backwards compatibility.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-known-issues-only-emit-warnings-for-backwards-compatibility.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: There is no report of unit test coverage.", "body": "HIGH: There is no report of unit test coverage.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-there-is-no-report-of-unit-test-coverage.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: Low unit test coverage.", "body": "HIGH: Low unit test coverage.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-low-unit-test-coverage.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: All strings are UTF-8.", "body": "HIGH: All strings are UTF-8.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-all-strings-are-utf-8.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: Modifiers can be overridden with no special syntax or warnings.", "body": "HIGH: Modifiers can be overridden with no special syntax or warnings.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-modifiers-can-be-overridden-with-no-special-syntax-or-warnings.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: solc-js output with optimizations is non-deterministic in some environments.", "body": "HIGH: solc-js output with optimizations is non-deterministic in some environments.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-solc-js-output-with-optimizations-is-non-deterministic-in-some-environments.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: No error message on uninitialized storage references.", "body": "HIGH: No error message on uninitialized storage references.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-no-error-message-on-uninitialized-storage-references.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: Missing return statement on a function does not issue an error.", "body": "HIGH: Missing return statement on a function does not issue an error.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-missing-return-statement-on-a-function-does-not-issue-an-error.", "labels": ["OpenZeppelin"]}, {"title": "HIGH: Fuzzing setup is broken.", "body": "HIGH: Fuzzing setup is broken.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#high:-fuzzing-setup-is-broken.", "labels": ["OpenZeppelin"]}, {"title": "Medium severity", "body": "Medium severity", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium-severity", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Insecure system call may lead to command execution.", "body": "MEDIUM: Insecure system call may lead to command execution.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-insecure-system-call-may-lead-to-command-execution.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Swarm hash implementation is outdated.", "body": "MEDIUM: Swarm hash implementation is outdated.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-swarm-hash-implementation-is-outdated.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Fallback mechanism in imports is not working properly.", "body": "MEDIUM: Fallback mechanism in imports is not working properly.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-fallback-mechanism-in-imports-is-not-working-properly.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Coinspect audit still has unaddressed issues.", "body": "MEDIUM: Coinspect audit still has unaddressed issues.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-coinspect-audit-still-has-unaddressed-issues.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Bus factor is 2.", "body": "MEDIUM: Bus factor is 2.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-bus-factor-is-2.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: There is no code of conduct.", "body": "MEDIUM: There is no code of conduct.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-there-is-no-code-of-conduct.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: There is no clear test structure.", "body": "MEDIUM: There is no clear test structure.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-there-is-no-clear-test-structure.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: There is no intermediate language.", "body": "MEDIUM: There is no intermediate language.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-there-is-no-intermediate-language.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: The syntax for the fallback function is prone to confusion.", "body": "MEDIUM: The syntax for the fallback function is prone to confusion.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-the-syntax-for-the-fallback-function-is-prone-to-confusion.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Some public functions cannot be made external.", "body": "MEDIUM: Some public functions cannot be made external.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-some-public-functions-cannot-be-made-external.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: State variables can be shadowed.", "body": "MEDIUM: State variables can be shadowed.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-state-variables-can-be-shadowed.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Optional optimizations may not be safe.", "body": "MEDIUM: Optional optimizations may not be safe.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-optional-optimizations-may-not-be-safe.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Optimizations code in the assembler (libevmasm) is hard to read.", "body": "MEDIUM: Optimizations code in the assembler (libevmasm) is hard to read.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-optimizations-code-in-the-assembler-(libevmasm)-is-hard-to-read.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Fragile code in the CSE optimizer.", "body": "MEDIUM: Fragile code in the CSE optimizer.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-fragile-code-in-the-cse-optimizer.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: All optimizations are very low level.", "body": "MEDIUM: All optimizations are very low level.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-all-optimizations-are-very-low-level.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Modifiers can return.", "body": "MEDIUM: Modifiers can return.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-modifiers-can-return.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: No error when externally calling contract code from a constructor.", "body": "MEDIUM: No error when externally calling contract code from a constructor.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-no-error-when-externally-calling-contract-code-from-a-constructor.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: No dead code warning.", "body": "MEDIUM: No dead code warning.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-no-dead-code-warning.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Crash when trying to declare an already declared variable with the same name.", "body": "MEDIUM: Crash when trying to declare an already declared variable with the same name.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-crash-when-trying-to-declare-an-already-declared-variable-with-the-same-name.", "labels": ["OpenZeppelin"]}, {"title": "MEDIUM: Crash when converting signed rational using ABIEncoderV2", "body": "MEDIUM: Crash when converting signed rational using ABIEncoderV2", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#medium:-crash-when-converting-signed-rational-using-abiencoderv2", "labels": ["OpenZeppelin"]}, {"title": "Low severity", "body": "Low severity", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low-severity", "labels": ["OpenZeppelin"]}, {"title": "LOW: Coding style hinders readability and may lead to programming errors.", "body": "LOW: Coding style hinders readability and may lead to programming errors.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-coding-style-hinders-readability-and-may-lead-to-programming-errors.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Insecure string handling.", "body": "LOW: Insecure string handling.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-insecure-string-handling.", "labels": ["OpenZeppelin"]}, {"title": "LOW: The quality of sourcemaps could be improved.", "body": "LOW: The quality of sourcemaps could be improved.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-the-quality-of-sourcemaps-could-be-improved.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are many assertThrow usages without a message", "body": "LOW: There are many assertThrow usages without a message", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-many-assertthrow-usages-without-a-message", "labels": ["OpenZeppelin"]}, {"title": "LOW: Storage of small value types is unnecessarily costly.", "body": "LOW: Storage of small value types is unnecessarily costly.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-storage-of-small-value-types-is-unnecessarily-costly.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are issues tagged as Soon that have not been updated in a long time.", "body": "LOW: There are issues tagged as Soon that have not been updated in a long time.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-issues-tagged-as-soon-that-have-not-been-updated-in-a-long-time.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are many untriaged issues.", "body": "LOW: There are many untriaged issues.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-many-untriaged-issues.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are few issues tagged as Good first issue.", "body": "LOW: There are few issues tagged as Good first issue.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-few-issues-tagged-as-good-first-issue.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are many open pull requests with multiple comments.", "body": "LOW: There are many open pull requests with multiple comments.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-many-open-pull-requests-with-multiple-comments.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are many stale branches.", "body": "LOW: There are many stale branches.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-many-stale-branches.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is no stable release cadence.", "body": "LOW: There is no stable release cadence.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-no-stable-release-cadence.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is no site for news about the project.", "body": "LOW: There is no site for news about the project.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-no-site-for-news-about-the-project.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is a lot of inconsistency on the Julia, IULIA, Yul name.", "body": "LOW: There is a lot of inconsistency on the Julia, IULIA, Yul name.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-a-lot-of-inconsistency-on-the-julia,-iulia,-yul-name.", "labels": ["OpenZeppelin"]}, {"title": "LOW: The status of Yul is not clear.", "body": "LOW: The status of Yul is not clear.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-the-status-of-yul-is-not-clear.", "labels": ["OpenZeppelin"]}, {"title": "LOW: The main project README is missing important information.", "body": "LOW: The main project README is missing important information.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-the-main-project-readme-is-missing-important-information.", "labels": ["OpenZeppelin"]}, {"title": "LOW: The main page of the user documentation has many links.", "body": "LOW: The main page of the user documentation has many links.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-the-main-page-of-the-user-documentation-has-many-links.", "labels": ["OpenZeppelin"]}, {"title": "LOW: It is unclear which files are included in a GitHub release.", "body": "LOW: It is unclear which files are included in a GitHub release.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-it-is-unclear-which-files-are-included-in-a-github-release.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Whiskers is documented as part of the contribution guidelines.", "body": "LOW: Whiskers is documented as part of the contribution guidelines.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-whiskers-is-documented-as-part-of-the-contribution-guidelines.", "labels": ["OpenZeppelin"]}, {"title": "LOW: The process for helping with translations is not documented.", "body": "LOW: The process for helping with translations is not documented.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-the-process-for-helping-with-translations-is-not-documented.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Documentation translations are hosted on independent sites.", "body": "LOW: Documentation translations are hosted on independent sites.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-documentation-translations-are-hosted-on-independent-sites.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is no documentation explaining how to help testing the nightly build.", "body": "LOW: There is no documentation explaining how to help testing the nightly build.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-no-documentation-explaining-how-to-help-testing-the-nightly-build.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is no documentation on how tests are run on Continuous Integration.", "body": "LOW: There is no documentation on how tests are run on Continuous Integration.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-no-documentation-on-how-tests-are-run-on-continuous-integration.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is no clear documentation for experimental features.", "body": "LOW: There is no clear documentation for experimental features.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-no-clear-documentation-for-experimental-features.", "labels": ["OpenZeppelin"]}, {"title": "LOW: No documentation available for libsolc.", "body": "LOW: No documentation available for libsolc.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-no-documentation-available-for-libsolc.", "labels": ["OpenZeppelin"]}, {"title": "LOW: README for Yul optimizations is incomplete.", "body": "LOW: README for Yul optimizations is incomplete.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-readme-for-yul-optimizations-is-incomplete.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Missing information for successfully building Solidity\u2019s fuzzer AFL.", "body": "LOW: Missing information for successfully building Solidity\u2019s fuzzer AFL.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-missing-information-for-successfully-building-solidity\u2019s-fuzzer-afl.", "labels": ["OpenZeppelin"]}, {"title": "LOW: soltest custom command line arguments are not listed in help.", "body": "LOW: soltest custom command line arguments are not listed in help.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-soltest-custom-command-line-arguments-are-not-listed-in-help.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There is no clear documentation about the constructor not being part of the deployed code.", "body": "LOW: There is no clear documentation about the constructor not being part of the deployed code.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-is-no-clear-documentation-about-the-constructor-not-being-part-of-the-deployed-code.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Contracts from external projects are duplicated in the Solidity code repository.", "body": "LOW: Contracts from external projects are duplicated in the Solidity code repository.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-contracts-from-external-projects-are-duplicated-in-the-solidity-code-repository.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Some tests are run twice on different Continuous Integration systems.", "body": "LOW: Some tests are run twice on different Continuous Integration systems.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-some-tests-are-run-twice-on-different-continuous-integration-systems.", "labels": ["OpenZeppelin"]}, {"title": "LOW: There are no static tests enforcing a consistent code style.", "body": "LOW: There are no static tests enforcing a consistent code style.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-there-are-no-static-tests-enforcing-a-consistent-code-style.", "labels": ["OpenZeppelin"]}, {"title": "LOW: It is very difficult to run tests locally.", "body": "LOW: It is very difficult to run tests locally.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-it-is-very-difficult-to-run-tests-locally.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Building in some Linux distributions fails.", "body": "LOW: Building in some Linux distributions fails.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-building-in-some-linux-distributions-fails.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Missing file on compilation when using SANITIZE.", "body": "LOW: Missing file on compilation when using SANITIZE.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-missing-file-on-compilation-when-using-sanitize.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Insecure environment variable handling", "body": "LOW: Insecure environment variable handling", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-insecure-environment-variable-handling", "labels": ["OpenZeppelin"]}, {"title": "LOW: No errors on missing output option.", "body": "LOW: No errors on missing output option.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-no-errors-on-missing-output-option.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Inconsistent AST output.", "body": "LOW: Inconsistent AST output.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-inconsistent-ast-output.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Confusing options naming.", "body": "LOW: Confusing options naming.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-confusing-options-naming.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Undocumented clone contract feature.", "body": "LOW: Undocumented clone contract feature.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-undocumented-clone-contract-feature.", "labels": ["OpenZeppelin"]}, {"title": "LOW: General CLI inconsistencies and confusing options.", "body": "LOW: General CLI inconsistencies and confusing options.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-general-cli-inconsistencies-and-confusing-options.", "labels": ["OpenZeppelin"]}, {"title": "LOW: No mechanism to prevent functions from being overridden.", "body": "LOW: No mechanism to prevent functions from being overridden.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-no-mechanism-to-prevent-functions-from-being-overridden.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Invalid UTF-8 sequences are allowed in comments.", "body": "LOW: Invalid UTF-8 sequences are allowed in comments.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-invalid-utf-8-sequences-are-allowed-in-comments.", "labels": ["OpenZeppelin"]}, {"title": "LOW: It is not possible to declare constant variables inside functions.", "body": "LOW: It is not possible to declare constant variables inside functions.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-it-is-not-possible-to-declare-constant-variables-inside-functions.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Base fallback function cannot be extended.", "body": "LOW: Base fallback function cannot be extended.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-base-fallback-function-cannot-be-extended.", "labels": ["OpenZeppelin"]}, {"title": "LOW: No mechanism to ensure abstract contracts.", "body": "LOW: No mechanism to ensure abstract contracts.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-no-mechanism-to-ensure-abstract-contracts.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Low coverage for optimization-specific end-to-end tests", "body": "LOW: Low coverage for optimization-specific end-to-end tests", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-low-coverage-for-optimization-specific-end-to-end-tests", "labels": ["OpenZeppelin"]}, {"title": "LOW: Erroneous mutability detection when dead code is involved.", "body": "LOW: Erroneous mutability detection when dead code is involved.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-erroneous-mutability-detection-when-dead-code-is-involved.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Misleading error message on overload resolution failure.", "body": "LOW: Misleading error message on overload resolution failure.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-misleading-error-message-on-overload-resolution-failure.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Misleading error when externally referencing a state variable.", "body": "LOW: Misleading error when externally referencing a state variable.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-misleading-error-when-externally-referencing-a-state-variable.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Misleading error when internally calling an external function.", "body": "LOW: Misleading error when internally calling an external function.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-misleading-error-when-internally-calling-an-external-function.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Fuzzer.cpp and solfuzzer have counterintuitive naming.", "body": "LOW: Fuzzer.cpp and solfuzzer have counterintuitive naming.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-fuzzer.cpp-and-solfuzzer-have-counterintuitive-naming.", "labels": ["OpenZeppelin"]}, {"title": "LOW: AFL example from the documentation doesn\u2019t work.", "body": "LOW: AFL example from the documentation doesn\u2019t work.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-afl-example-from-the-documentation-doesn\u2019t-work.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Fuzz testing scheduling and visibility", "body": "LOW: Fuzz testing scheduling and visibility", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-fuzz-testing-scheduling-and-visibility", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when requested type is not present.", "body": "LOW: Crash when requested type is not present.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-requested-type-is-not-present.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when accessing empty name variable slot.", "body": "LOW: Crash when accessing empty name variable slot.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-accessing-empty-name-variable-slot.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when type not set for parameter return value.", "body": "LOW: Crash when type not set for parameter return value.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-type-not-set-for-parameter-return-value.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when type not set for parameter function value.", "body": "LOW: Crash when type not set for parameter function value.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-type-not-set-for-parameter-function-value.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when accessing a slot of a function in assembly block.", "body": "LOW: Crash when accessing a slot of a function in assembly block.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-accessing-a-slot-of-a-function-in-assembly-block.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when calling a non callable type on a non primitive type double assignment.", "body": "LOW: Crash when calling a non callable type on a non primitive type double assignment.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-calling-a-non-callable-type-on-a-non-primitive-type-double-assignment.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when using assembly jump instruction inside a constructor or function with same name as contract.", "body": "LOW: Crash when using assembly jump instruction inside a constructor or function with same name as contract.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-using-assembly-jump-instruction-inside-a-constructor-or-function-with-same-name-as-contract.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when declaring external function with array of struct that possesses arrays.", "body": "LOW: Crash when declaring external function with array of struct that possesses arrays.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-declaring-external-function-with-array-of-struct-that-possesses-arrays.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when using struct as external function parameter using ABIEncoderV2.", "body": "LOW: Crash when using struct as external function parameter using ABIEncoderV2.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-using-struct-as-external-function-parameter-using-abiencoderv2.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when converting fixed point type using ABIEncoderV2.", "body": "LOW: Crash when converting fixed point type using ABIEncoderV2.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-converting-fixed-point-type-using-abiencoderv2.", "labels": ["OpenZeppelin"]}, {"title": "LOW: Crash when array index value is too large.", "body": "LOW: Crash when array index value is too large.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-crash-when-array-index-value-is-too-large.", "labels": ["OpenZeppelin"]}, {"title": "LOW: High CPU usage on conversion between numeric literal and others.", "body": "LOW: High CPU usage on conversion between numeric literal and others.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-high-cpu-usage-on-conversion-between-numeric-literal-and-others.", "labels": ["OpenZeppelin"]}, {"title": "LOW: High CPU usage when using large variable names.", "body": "LOW: High CPU usage when using large variable names.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#low:-high-cpu-usage-when-using-large-variable-names.", "labels": ["OpenZeppelin"]}, {"title": "Notes", "body": "Notes", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#notes", "labels": ["OpenZeppelin"]}, {"title": "NOTE: Non-functional requirements.", "body": "NOTE: Non-functional requirements.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-non-functional-requirements.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: Micropayment Channel example is not written.", "body": "NOTE: Micropayment Channel example is not written.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-micropayment-channel-example-is-not-written.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: Consider reviewing the language design process and adding high-level goals.", "body": "NOTE: Consider reviewing the language design process and adding high-level goals.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-consider-reviewing-the-language-design-process-and-adding-high-level-goals.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: Tests hang if cpp-ethereum is not in $PATH.", "body": "NOTE: Tests hang if cpp-ethereum is not in $PATH.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-tests-hang-if-cpp-ethereum-is-not-in-$path.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: The help string for the\u200a\u2014\u200alibraries option is wrong.", "body": "NOTE: The help string for the\u200a\u2014\u200alibraries option is wrong.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-the-help-string-for-the\u200a\u2014\u200alibraries-option-is-wrong.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: The deprecated var keyword is documented.", "body": "NOTE: The deprecated var keyword is documented.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-the-deprecated-var-keyword-is-documented.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: Deprecated constructors found in examples.", "body": "NOTE: Deprecated constructors found in examples.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-deprecated-constructors-found-in-examples.", "labels": ["OpenZeppelin"]}, {"title": "NOTE: Warnings for unassigned arrays are not truncated.", "body": "NOTE: Warnings for unassigned arrays are not truncated.", "html_url": "https://blog.openzeppelin.com/solidity-compiler-audit-8cfc0316a420#note:-warnings-for-unassigned-arrays-are-not-truncated.", "labels": ["OpenZeppelin"]}, {"title": "None.", "body": "None.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#none.", "labels": ["OpenZeppelin"]}, {"title": "Buyers can lock funds indefinitely", "body": "Buyers can lock funds indefinitely", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#buyers-can-lock-funds-indefinitely", "labels": ["OpenZeppelin"]}, {"title": "Escrow_v1_0 contract are described by the", "body": "Escrow_v1_0 contract are described by the", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#escrow_v1_0-contract-are-described-by-the", "labels": ["OpenZeppelin"]}, {"title": "Transaction struct. Among its fields,", "body": "Transaction struct. Among its fields,", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#transaction-struct.-among-its-fields,", "labels": ["OpenZeppelin"]}, {"title": "timeoutHours is used to set a timeout after which a seller can execute the transaction without the need for the buyer\u2019s or the moderator\u2019s signatures. In order to do this, the seller calls the", "body": "timeoutHours is used to set a timeout after which a seller can execute the transaction without the need for the buyer\u2019s or the moderator\u2019s signatures. In order to do this, the seller calls the", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#timeouthours-is-used-to-set-a-timeout-after-which-a-seller-can-execute-the-transaction-without-the-need-for-the-buyer\u2019s-or-the-moderator\u2019s-signatures.-in-order-to-do-this,-the-seller-calls-the", "labels": ["OpenZeppelin"]}, {"title": "execute function, which itself calls", "body": "execute function, which itself calls", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#execute-function,-which-itself-calls", "labels": ["OpenZeppelin"]}, {"title": "verifyTransaction, which finally calls", "body": "verifyTransaction, which finally calls", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#verifytransaction,-which-finally-calls", "labels": ["OpenZeppelin"]}, {"title": "isTimeLockExpired. This last function verifies that the time elapsed since the last modification of the transaction, tracked by the", "body": "isTimeLockExpired. This last function verifies that the time elapsed since the last modification of the transaction, tracked by the", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#istimelockexpired.-this-last-function-verifies-that-the-time-elapsed-since-the-last-modification-of-the-transaction,-tracked-by-the", "labels": ["OpenZeppelin"]}, {"title": "lastModified field in the", "body": "lastModified field in the", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#lastmodified-field-in-the", "labels": ["OpenZeppelin"]}, {"title": "A malicious buyer trying to prevent a transaction from being executed can periodically update it by adding tiny amounts of Ether or tokens to its value through the addFundsToTransaction or addTokensToTransaction functions respectively. These calls will reset the lastModified field of the transaction, thus preventing it from ever reaching the time lock. If the transaction requires only two signatures, a seller can appeal to the moderator to execute it. If the transaction requires three signatures, however, the funds will be effectively locked until the buyer ceases to update it.", "body": "A malicious buyer trying to prevent a transaction from being executed can periodically update it by adding tiny amounts of Ether or tokens to its value through the addFundsToTransaction or addTokensToTransaction functions respectively. These calls will reset the lastModified field of the transaction, thus preventing it from ever reaching the time lock. If the transaction requires only two signatures, a seller can appeal to the moderator to execute it. If the transaction requires three signatures, however, the funds will be effectively locked until the buyer ceases to update it.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#a-malicious-buyer-trying-to-prevent-a-transaction-from-being-executed-can-periodically-update-it-by-adding-tiny-amounts-of-ether-or-tokens-to-its-value-through-the-addfundstotransaction-or-addtokenstotransaction-functions-respectively.-these-calls-will-reset-the-lastmodified-field-of-the-transaction,-thus-preventing-it-from-ever-reaching-the-time-lock.-if-the-transaction-requires-only-two-signatures,-a-seller-can-appeal-to-the-moderator-to-execute-it.-if-the-transaction-requires-three-signatures,-however,-the-funds-will-be-effectively-locked-until-the-buyer-ceases-to-update-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider keeping track of, and limiting, the number of times a transaction can be modified in order to prevent the indefinite locking of funds by buyers.", "body": "Consider keeping track of, and limiting, the number of times a transaction can be modified in order to prevent the indefinite locking of funds by buyers.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-keeping-track-of,-and-limiting,-the-number-of-times-a-transaction-can-be-modified-in-order-to-prevent-the-indefinite-locking-of-funds-by-buyers.", "labels": ["OpenZeppelin"]}, {"title": "Signature ordering may prevent transaction verification", "body": "Signature ordering may prevent transaction verification", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#signature-ordering-may-prevent-transaction-verification", "labels": ["OpenZeppelin"]}, {"title": "In the verifyTransaction function, an if clause defines the conditions under which transactions fail to be verified (and the associated Ethereum transaction reverts). One way to have transactions verified is to call the execute function with a number of signatures above the transaction threshold. Another, meant as a failsafe, consists of having the transaction executed with just the seller\u2019s signature once the time lock is expired.", "body": "In the verifyTransaction function, an if clause defines the conditions under which transactions fail to be verified (and the associated Ethereum transaction reverts). One way to have transactions verified is to call the execute function with a number of signatures above the transaction threshold. Another, meant as a failsafe, consists of having the transaction executed with just the seller\u2019s signature once the time lock is expired.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#in-the-verifytransaction-function,-an-if-clause-defines-the-conditions-under-which-transactions-fail-to-be-verified-(and-the-associated-ethereum-transaction-reverts).-one-way-to-have-transactions-verified-is-to-call-the-execute-function-with-a-number-of-signatures-above-the-transaction-threshold.-another,-meant-as-a-failsafe,-consists-of-having-the-transaction-executed-with-just-the-seller\u2019s-signature-once-the-time-lock-is-expired.", "labels": ["OpenZeppelin"]}, {"title": "Consider an implementation that is agnostic to signature ordering in order to fully match the specification.", "body": "Consider an implementation that is agnostic to signature ordering in order to fully match the specification.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-an-implementation-that-is-agnostic-to-signature-ordering-in-order-to-fully-match-the-specification.", "labels": ["OpenZeppelin"]}, {"title": "Convoluted transaction verification implementation", "body": "Convoluted transaction verification implementation", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#convoluted-transaction-verification-implementation", "labels": ["OpenZeppelin"]}, {"title": "execute is the function responsible for releasing funds to destination addresses, once all the necessary verification steps are taken. Currently, the entire process for verifying a transaction is divided and scattered throughout separate parts of the code, making it difficult for users to understand what requirements a transaction should meet in order for it to be approved, and rendering the code more error-prone and difficult to test.", "body": "execute is the function responsible for releasing funds to destination addresses, once all the necessary verification steps are taken. Currently, the entire process for verifying a transaction is divided and scattered throughout separate parts of the code, making it difficult for users to understand what requirements a transaction should meet in order for it to be approved, and rendering the code more error-prone and difficult to test.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#execute-is-the-function-responsible-for-releasing-funds-to-destination-addresses,-once-all-the-necessary-verification-steps-are-taken.-currently,-the-entire-process-for-verifying-a-transaction-is-divided-and-scattered-throughout-separate-parts-of-the-code,-making-it-difficult-for-users-to-understand-what-requirements-a-transaction-should-meet-in-order-for-it-to-be-approved,-and-rendering-the-code-more-error-prone-and-difficult-to-test.", "labels": ["OpenZeppelin"]}, {"title": "require clause of its own, the", "body": "require clause of its own, the", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#require-clause-of-its-own,-the", "labels": ["OpenZeppelin"]}, {"title": "verifyTransaction function is called. This function in turn call", "body": "verifyTransaction function is called. This function in turn call", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#verifytransaction-function-is-called.-this-function-in-turn-call", "labels": ["OpenZeppelin"]}, {"title": "verifySignatures, which has several require statements, and then", "body": "verifySignatures, which has several require statements, and then", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#verifysignatures,-which-has-several-require-statements,-and-then", "labels": ["OpenZeppelin"]}, {"title": "isTimeLockExpired, to finally reach an", "body": "isTimeLockExpired, to finally reach an", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#istimelockexpired,-to-finally-reach-an", "labels": ["OpenZeppelin"]}, {"title": "if clause that obscurely checks for further conditions using nested", "body": "if clause that obscurely checks for further conditions using nested", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#if-clause-that-obscurely-checks-for-further-conditions-using-nested", "labels": ["OpenZeppelin"]}, {"title": "transferFunds function is called within a require statement, which performs", "body": "transferFunds function is called within a require statement, which performs", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#transferfunds-function-is-called-within-a-require-statement,-which-performs", "labels": ["OpenZeppelin"]}, {"title": "additional", "body": "additional", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#additional", "labels": ["OpenZeppelin"]}, {"title": "verifications\u00a0distributed in", "body": "verifications\u00a0distributed in", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#verifications\u00a0distributed-in", "labels": ["OpenZeppelin"]}, {"title": "several", "body": "require statements, and then  isTimeLockExpired, to finally reach an  if clause that obscurely checks for further conditions using nested  transferFunds function is called within a require statement, which performs  additional  verifications distributed in    require clauses within loops.  Consider decoupling the verification of transaction requirements from the business logic as much as possible, encapsulating validations in specific straightforward functions that can be easily reused and tested.  Low Severity  Dead code in transferFunds function  transferFunds function,  a multiple conditional is used to determine the transaction type (  else  clause is included as a fallback to revert the Ethereum transaction in case the received transaction type does not match a known value. However, given that transaction types can only be set by the smart contract (see  L142 and  L194), this  To improve readability and avoid confusion, consider removing all segments of code that are not to be executed under any circumstances.  Lack of explicit return statements  Several functions in the codebase have implicit return statements (checkBeneficiary, calculateRedeemScriptHash, transferFunds, verifySignatures and isTimeLockExpired).  Not using explicit return statements on functions that are expected to return values can lead to problems in future changes to the codebase. Should a return parameters name be eventually removed (for instance if returns (bool check) is replaced with returns (bool)), no compilation-time warnings will be thrown by the Solidity compiler. In this scenario, the functions return value will be always automatically set to the default value of the return type, in this case false, which could lead to unforeseen issues.  Consider modifying the listed functions to include explicit return statements.  Unnecessary field in Transaction struct  The scriptHash field is being unnecessarily stored within the Transaction struct. Considering that it is never used other than as an index to access Transactions in mappings, this field can safely be removed from the struct to avoid duplication.  Wrong error message on transaction verification failure  The verifyTransaction function implements  checks to verify the conditions under which transactions should be accepted or rejected. One complex validation is performed in a single if clause, which has an associated error message that does not cover all possible causes of failure.  Consider refactoring the if clause in order to include specific error messages for each checked condition.  Misleading comment in execute function  The docstrings for execute function hints at moderators being the ones responsible for executing transactions. Yet, the function does not validate who the calling account actually is, meaning that execute can be called by anyone\u200a\u200aincluding actors not involved in the transaction.  Consider clarifying this situation in the docstrings.  Dispute state is not among possible transaction states  The error message in the inFundedState modifier mentions dispute as a possible transaction state. The enum in charge of defining transaction states, however, only lists FUNDED and RELEASED as possible states.  Consider either including this third state in the enum\u200a\u200aalong with the necessary logic to support it\u200a\u200aor suitably modifying the error message.  Inconsistent coding style  There is a significant coding style difference between code segments:  The wrapping of statement structures varies widely (as seen in events L29 and L35).  Indentation in if clauses is inconsistent.  There is inconsistent spacing between typing, such as in lines: 4951, 54 and 59.  There is no ruling standard defining line wrapping (e.g. line 241). Recommended is 80 columns.  There is an inconsistent ordering of visibility and custom modifiers (e.g. addTransaction and addFundsToTransaction).  Consider following best practices and applying the same style guidelines across the codebase (see Soliditys style guide for reference).  Grammatical errors in code and comments  Many comments are poorly written, with some containing grammatical or typing errors (e.g. desgined, transaction does not exists, singatures). This extends to the transactionDoesNotExists modifier name, which also has a grammatical error.  Consider fixing these to improve code readability.  Notes & Additional Information  The transferFunds function is in charge of transferring funds to the corresponding beneficiaries when executing a transaction. In the case of Ether transactions, this is achieved via the push-payment pattern (i.e. a transfer is done to each of the destination addresses), which is always discouraged in favor of a pull-payment pattern. Potential consequences stemming from the implementation of this pattern are acknowledged in the documentation, where all risk associated with attack vectors regarding the push-payment pattern is accepted. Nonetheless, it is still relevant to emphasize that a pull-payment strategy should be further studied and considered, since the current implementation might lead to the lockout of funds sent to the Escrow contract. In the case such strategy is pursued, contemplate building upon OpenZeppelins PullPayment contract.  Consider indexing the scriptHash argument in all events to allow users to search and filter events using this field.  The function isTimeLockedExpired returns false when the parameter timeoutHours from the transaction equals 0. This implies an infinite timeout, as opposed to an immediate one. Ensure that this is expected behavior and properly document it.  verifySignatures is provided with the r, s, and v outputs of the ECDSA signatures trying to execute a transaction, and then verifies each one of them. Consider using the thoroughly tested OpenZeppelins ECRecovery library to avoid the need of splitting the signatures before the call and improving code legibility.  In both addTokensToTransaction and addFundsToTransaction a local variable _value is defined to track the transaction value. In neither case is this definition necessary, with the value already tracked by the parameter that is passed to the function in the first case (value), and by the msg.value variable in the second.  addTokensToTransaction uses both msg.sender and transactions[scriptHash].buyer to represent the buyer interchangeably. Consider using only msg.sender (which is already used in addFundsToTransaction), and adding a comment on each functions docstring about this.  In _addTransaction, after a Transaction has been created and stored, the owners are also added by setting the isOwner attribute of the current transaction. On line 634, the moderator address is set as owner even if it is equal to address(0) (no moderator case). Consider checking for the moderators address validity before registering it as owner.  Consider prefixing all private and internal functions with an underscore to clearly denote their visibility (e.g. verifyTransaction and transferFunds).  If public state variables are not expected to be read from outside the contract, consider restricting their visibility to private, in particular if getters to read such data are already defined (e.g. getAllTransactionsForParty).  To improve code readability, consider using address(this) instead of just this in L201, L289, L391, L403 and L521.  The transaction field threshold (which represents the minimum number of signatures required to release funds) would benefit from a name that better reflects what the variable represents.  There are code segments where a single require clause includes multiple conditions. Consider isolating each condition in its own require clause, and having more specific error messages for each.  Parameter order in addTransaction and addTokenTransaction is different from each functions documented @param list. Consider documenting parameters in the same order as they are defined in each functions signature  calculateRedeemScriptHashs docstring states how the script hash is to be obtained. While the Escrow contracts address is being used in the hash calculation, it is currently missing from the docstring, consider adding it.  The contracts docstring would benefit from a more thorough and clearer description of its purpose and use cases.  Consider adding a comment specifying the time units in which the lastModified field of a transaction is measured.  Even though test files were out of the audits scope, they were used as a guide to develop and test specific behaviors during the audit. In them, tests with wrong messages in asserts were found (Transaction was sent from buyers address, where it should be was not sent). Furthermore, two test cases, L149 and L198, with the same name but different content were found. Consider ensuring all messages correspond with what is being evaluated, and expanding test case descriptions to be more precise.  Conclusion  No critical and one high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#several", "labels": ["OpenZeppelin"]}, {"title": "require clauses within loops.", "body": "require clauses within loops.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#require-clauses-within-loops.", "labels": ["OpenZeppelin"]}, {"title": "Consider decoupling the verification of transaction requirements from the business logic as much as possible, encapsulating validations in specific straightforward functions that can be easily reused and tested.", "body": "Consider decoupling the verification of transaction requirements from the business logic as much as possible, encapsulating validations in specific straightforward functions that can be easily reused and tested.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-decoupling-the-verification-of-transaction-requirements-from-the-business-logic-as-much-as-possible,-encapsulating-validations-in-specific-straightforward-functions-that-can-be-easily-reused-and-tested.", "labels": ["OpenZeppelin"]}, {"title": "Dead code in transferFunds function", "body": "Dead code in transferFunds function", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#dead-code-in-transferfunds-function", "labels": ["OpenZeppelin"]}, {"title": "transferFunds function,", "body": "transferFunds function,", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#transferfunds-function,", "labels": ["OpenZeppelin"]}, {"title": "a multiple conditional is used to determine the transaction type (", "body": "a multiple conditional is used to determine the transaction type (", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#a-multiple-conditional-is-used-to-determine-the-transaction-type-(", "labels": ["OpenZeppelin"]}, {"title": "else", "body": "else", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#else", "labels": ["OpenZeppelin"]}, {"title": "clause is included as a fallback to revert the Ethereum transaction in case the received transaction type does not match a known value. However, given that transaction types can only be set by the smart contract (see", "body": "clause is included as a fallback to revert the Ethereum transaction in case the received transaction type does not match a known value. However, given that transaction types can only be set by the smart contract (see", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#clause-is-included-as-a-fallback-to-revert-the-ethereum-transaction-in-case-the-received-transaction-type-does-not-match-a-known-value.-however,-given-that-transaction-types-can-only-be-set-by-the-smart-contract-(see", "labels": ["OpenZeppelin"]}, {"title": "L142 and", "body": "L142 and", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#l142-and", "labels": ["OpenZeppelin"]}, {"title": "L194), this", "body": "L194), this", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#l194),-this", "labels": ["OpenZeppelin"]}, {"title": "To improve readability and avoid confusion, consider removing all segments of code that are not to be executed under any circumstances.", "body": "To improve readability and avoid confusion, consider removing all segments of code that are not to be executed under any circumstances.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#to-improve-readability-and-avoid-confusion,-consider-removing-all-segments-of-code-that-are-not-to-be-executed-under-any-circumstances.", "labels": ["OpenZeppelin"]}, {"title": "Lack of explicit return statements", "body": "Lack of explicit return statements", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#lack-of-explicit-return-statements", "labels": ["OpenZeppelin"]}, {"title": "Several functions in the codebase have implicit return statements (checkBeneficiary, calculateRedeemScriptHash, transferFunds, verifySignatures and isTimeLockExpired).", "body": "Several functions in the codebase have implicit return statements (checkBeneficiary, calculateRedeemScriptHash, transferFunds, verifySignatures and isTimeLockExpired).", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#several-functions-in-the-codebase-have-implicit-return-statements-(checkbeneficiary,-calculateredeemscripthash,-transferfunds,-verifysignatures-and-istimelockexpired).", "labels": ["OpenZeppelin"]}, {"title": "Not using explicit return statements on functions that are expected to return values can lead to problems in future changes to the codebase. Should a return parameter\u2019s name be eventually removed (for instance if returns (bool check) is replaced with returns (bool)), no compilation-time warnings will be thrown by the Solidity compiler. In this scenario, the function\u2019s return value will be always automatically set to the default value of the return type, in this case false, which could lead to unforeseen issues.", "body": "Not using explicit return statements on functions that are expected to return values can lead to problems in future changes to the codebase. Should a return parameter\u2019s name be eventually removed (for instance if returns (bool check) is replaced with returns (bool)), no compilation-time warnings will be thrown by the Solidity compiler. In this scenario, the function\u2019s return value will be always automatically set to the default value of the return type, in this case false, which could lead to unforeseen issues.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#not-using-explicit-return-statements-on-functions-that-are-expected-to-return-values-can-lead-to-problems-in-future-changes-to-the-codebase.-should-a-return-parameter\u2019s-name-be-eventually-removed-(for-instance-if-returns-(bool-check)-is-replaced-with-returns-(bool)),-no-compilation-time-warnings-will-be-thrown-by-the-solidity-compiler.-in-this-scenario,-the-function\u2019s-return-value-will-be-always-automatically-set-to-the-default-value-of-the-return-type,-in-this-case-false,-which-could-lead-to-unforeseen-issues.", "labels": ["OpenZeppelin"]}, {"title": "Consider modifying the listed functions to include explicit return statements.", "body": "Consider modifying the listed functions to include explicit return statements.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-modifying-the-listed-functions-to-include-explicit-return-statements.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary field in Transaction struct", "body": "Unnecessary field in Transaction struct", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#unnecessary-field-in-transaction-struct", "labels": ["OpenZeppelin"]}, {"title": "The scriptHash field is being unnecessarily stored within the Transaction struct. Considering that it is never used other than as an index to access Transactions in mappings, this field can safely be removed from the struct to avoid duplication.", "body": "The scriptHash field is being unnecessarily stored within the Transaction struct. Considering that it is never used other than as an index to access Transactions in mappings, this field can safely be removed from the struct to avoid duplication.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-scripthash-field-is-being-unnecessarily-stored-within-the-transaction-struct.-considering-that-it-is-never-used-other-than-as-an-index-to-access-transactions-in-mappings,-this-field-can-safely-be-removed-from-the-struct-to-avoid-duplication.", "labels": ["OpenZeppelin"]}, {"title": "Wrong error message on transaction verification failure", "body": "Wrong error message on transaction verification failure", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#wrong-error-message-on-transaction-verification-failure", "labels": ["OpenZeppelin"]}, {"title": "The verifyTransaction function implements several checks to verify the conditions under which transactions should be accepted or rejected. One complex validation is performed in a single if clause, which has an associated error message that does not cover all possible causes of failure.", "body": "The verifyTransaction function implements several checks to verify the conditions under which transactions should be accepted or rejected. One complex validation is performed in a single if clause, which has an associated error message that does not cover all possible causes of failure.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-verifytransaction-function-implements-several-checks-to-verify-the-conditions-under-which-transactions-should-be-accepted-or-rejected.-one-complex-validation-is-performed-in-a-single-if-clause,-which-has-an-associated-error-message-that-does-not-cover-all-possible-causes-of-failure.", "labels": ["OpenZeppelin"]}, {"title": "Consider refactoring the if clause in order to include specific error messages for each checked condition.", "body": "Consider refactoring the if clause in order to include specific error messages for each checked condition.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-refactoring-the-if-clause-in-order-to-include-specific-error-messages-for-each-checked-condition.", "labels": ["OpenZeppelin"]}, {"title": "Misleading comment in execute\u00a0function", "body": "Misleading comment in execute\u00a0function", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#misleading-comment-in-execute\u00a0function", "labels": ["OpenZeppelin"]}, {"title": "The docstrings for execute function hints at moderators being the ones responsible for executing transactions. Yet, the function does not validate who the calling account actually is, meaning that execute can be called by anyone\u200a\u2014\u200aincluding actors not involved in the transaction.", "body": "The docstrings for execute function hints at moderators being the ones responsible for executing transactions. Yet, the function does not validate who the calling account actually is, meaning that execute can be called by anyone\u200a\u2014\u200aincluding actors not involved in the transaction.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-docstrings-for-execute-function-hints-at-moderators-being-the-ones-responsible-for-executing-transactions.-yet,-the-function-does-not-validate-who-the-calling-account-actually-is,-meaning-that-execute-can-be-called-by-anyone\u200a\u2014\u200aincluding-actors-not-involved-in-the-transaction.", "labels": ["OpenZeppelin"]}, {"title": "Consider clarifying this situation in the docstrings.", "body": "Consider clarifying this situation in the docstrings.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-clarifying-this-situation-in-the-docstrings.", "labels": ["OpenZeppelin"]}, {"title": "\u201cDispute\u201d state is not among possible transaction states", "body": "\u201cDispute\u201d state is not among possible transaction states", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#\u201cdispute\u201d-state-is-not-among-possible-transaction-states", "labels": ["OpenZeppelin"]}, {"title": "The error message in the inFundedState modifier mentions \u201cdispute\u201d as a possible transaction state. The enum in charge of defining transaction states, however, only lists \u201cFUNDED\u201d and \u201cRELEASED\u201d as possible states.", "body": "The error message in the inFundedState modifier mentions \u201cdispute\u201d as a possible transaction state. The enum in charge of defining transaction states, however, only lists \u201cFUNDED\u201d and \u201cRELEASED\u201d as possible states.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-error-message-in-the-infundedstate-modifier-mentions-\u201cdispute\u201d-as-a-possible-transaction-state.-the-enum-in-charge-of-defining-transaction-states,-however,-only-lists-\u201cfunded\u201d-and-\u201creleased\u201d-as-possible-states.", "labels": ["OpenZeppelin"]}, {"title": "Consider either including this third state in the enum\u200a\u2014\u200aalong with the necessary logic to support it\u200a\u2014\u200aor suitably modifying the error message.", "body": "Consider either including this third state in the enum\u200a\u2014\u200aalong with the necessary logic to support it\u200a\u2014\u200aor suitably modifying the error message.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-either-including-this-third-state-in-the-enum\u200a\u2014\u200aalong-with-the-necessary-logic-to-support-it\u200a\u2014\u200aor-suitably-modifying-the-error-message.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent coding\u00a0style", "body": "Inconsistent coding\u00a0style", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#inconsistent-coding\u00a0style", "labels": ["OpenZeppelin"]}, {"title": "There is a significant coding style difference between code segments:", "body": "There is a significant coding style difference between code segments:", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#there-is-a-significant-coding-style-difference-between-code-segments:", "labels": ["OpenZeppelin"]}, {"title": "The wrapping of statement structures varies widely (as seen in events L29 and L35).", "body": "The wrapping of statement structures varies widely (as seen in events L29 and L35).", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-wrapping-of-statement-structures-varies-widely-(as-seen-in-events-l29-and-l35).", "labels": ["OpenZeppelin"]}, {"title": "Indentation in if clauses is inconsistent.", "body": "Indentation in if clauses is inconsistent.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#indentation-in-if-clauses-is-inconsistent.", "labels": ["OpenZeppelin"]}, {"title": "There is inconsistent spacing between typing, such as in lines: 49\u201351, 54 and 59.", "body": "There is inconsistent spacing between typing, such as in lines: 49\u201351, 54 and 59.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#there-is-inconsistent-spacing-between-typing,-such-as-in-lines:-49\u201351,-54-and-59.", "labels": ["OpenZeppelin"]}, {"title": "There is no ruling standard defining line wrapping (e.g. line 241). Recommended is 80 columns.", "body": "There is no ruling standard defining line wrapping (e.g. line 241). Recommended is 80 columns.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#there-is-no-ruling-standard-defining-line-wrapping-(e.g.-line-241).-recommended-is-80-columns.", "labels": ["OpenZeppelin"]}, {"title": "There is an inconsistent ordering of visibility and custom modifiers (e.g. addTransaction and addFundsToTransaction).", "body": "There is an inconsistent ordering of visibility and custom modifiers (e.g. addTransaction and addFundsToTransaction).", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#there-is-an-inconsistent-ordering-of-visibility-and-custom-modifiers-(e.g.-addtransaction-and-addfundstotransaction).", "labels": ["OpenZeppelin"]}, {"title": "Consider following best practices and applying the same style guidelines across the codebase (see Solidity\u2019s style guide for reference).", "body": "Consider following best practices and applying the same style guidelines across the codebase (see Solidity\u2019s style guide for reference).", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-following-best-practices-and-applying-the-same-style-guidelines-across-the-codebase-(see-solidity\u2019s-style-guide-for-reference).", "labels": ["OpenZeppelin"]}, {"title": "Grammatical errors in code and\u00a0comments", "body": "Grammatical errors in code and\u00a0comments", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#grammatical-errors-in-code-and\u00a0comments", "labels": ["OpenZeppelin"]}, {"title": "Many comments are poorly written, with some containing grammatical or typing errors (e.g. \u201cdesgined\u201d, \u201ctransaction does not exists\u201d, \u201csingatures\u201d). This extends to the \u201ctransactionDoesNotExists\u201d modifier name, which also has a grammatical error.", "body": "Many comments are poorly written, with some containing grammatical or typing errors (e.g. \u201cdesgined\u201d, \u201ctransaction does not exists\u201d, \u201csingatures\u201d). This extends to the \u201ctransactionDoesNotExists\u201d modifier name, which also has a grammatical error.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#many-comments-are-poorly-written,-with-some-containing-grammatical-or-typing-errors-(e.g.-\u201cdesgined\u201d,-\u201ctransaction-does-not-exists\u201d,-\u201csingatures\u201d).-this-extends-to-the-\u201ctransactiondoesnotexists\u201d-modifier-name,-which-also-has-a-grammatical-error.", "labels": ["OpenZeppelin"]}, {"title": "Consider fixing these to improve code readability.", "body": "Consider fixing these to improve code readability.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-fixing-these-to-improve-code-readability.", "labels": ["OpenZeppelin"]}, {"title": "The transferFunds function is in charge of transferring funds to the corresponding beneficiaries when executing a transaction. In the case of Ether transactions, this is achieved via the push-payment pattern (i.e. a\u00a0transfer is done to each of the destination addresses), which is always discouraged in favor of a pull-payment pattern. Potential consequences stemming from the implementation of this pattern are acknowledged in the documentation, where all risk associated with attack vectors regarding the push-payment pattern is accepted. Nonetheless, it is still relevant to emphasize that a pull-payment strategy should be further studied and considered, since the current implementation might lead to the lockout of funds sent to the Escrow contract. In the case such strategy is pursued, contemplate building upon OpenZeppelin\u2019s PullPayment contract.", "body": "The transferFunds function is in charge of transferring funds to the corresponding beneficiaries when executing a transaction. In the case of Ether transactions, this is achieved via the push-payment pattern (i.e. a\u00a0transfer is done to each of the destination addresses), which is always discouraged in favor of a pull-payment pattern. Potential consequences stemming from the implementation of this pattern are acknowledged in the documentation, where all risk associated with attack vectors regarding the push-payment pattern is accepted. Nonetheless, it is still relevant to emphasize that a pull-payment strategy should be further studied and considered, since the current implementation might lead to the lockout of funds sent to the Escrow contract. In the case such strategy is pursued, contemplate building upon OpenZeppelin\u2019s PullPayment contract.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-transferfunds-function-is-in-charge-of-transferring-funds-to-the-corresponding-beneficiaries-when-executing-a-transaction.-in-the-case-of-ether-transactions,-this-is-achieved-via-the-push-payment-pattern-(i.e.-a\u00a0transfer-is-done-to-each-of-the-destination-addresses),-which-is-always-discouraged-in-favor-of-a-pull-payment-pattern.-potential-consequences-stemming-from-the-implementation-of-this-pattern-are-acknowledged-in-the-documentation,-where-all-risk-associated-with-attack-vectors-regarding-the-push-payment-pattern-is-accepted.-nonetheless,-it-is-still-relevant-to-emphasize-that-a-pull-payment-strategy-should-be-further-studied-and-considered,-since-the-current-implementation-might-lead-to-the-lockout-of-funds-sent-to-the-escrow-contract.-in-the-case-such-strategy-is-pursued,-contemplate-building-upon-openzeppelin\u2019s-pullpayment-contract.", "labels": ["OpenZeppelin"]}, {"title": "Consider indexing the scriptHash argument in all events to allow users to search and filter events using this field.", "body": "Consider indexing the scriptHash argument in all events to allow users to search and filter events using this field.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-indexing-the-scripthash-argument-in-all-events-to-allow-users-to-search-and-filter-events-using-this-field.", "labels": ["OpenZeppelin"]}, {"title": "The function isTimeLockedExpired returns false when the parameter timeoutHours from the transaction equals 0. This implies an infinite timeout, as opposed to an immediate one. Ensure that this is expected behavior and properly document it.", "body": "The function isTimeLockedExpired returns false when the parameter timeoutHours from the transaction equals 0. This implies an infinite timeout, as opposed to an immediate one. Ensure that this is expected behavior and properly document it.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-function-istimelockedexpired-returns-false-when-the-parameter-timeouthours-from-the-transaction-equals-0.-this-implies-an-infinite-timeout,-as-opposed-to-an-immediate-one.-ensure-that-this-is-expected-behavior-and-properly-document-it.", "labels": ["OpenZeppelin"]}, {"title": "verifySignatures is provided with the r, s, and v\u00a0outputs of the ECDSA signatures trying to execute a transaction, and then verifies each one of them. Consider using the thoroughly tested OpenZeppelin\u2019s ECRecovery library to avoid the need of splitting the signatures before the call and improving code legibility.", "body": "verifySignatures is provided with the r, s, and v\u00a0outputs of the ECDSA signatures trying to execute a transaction, and then verifies each one of them. Consider using the thoroughly tested OpenZeppelin\u2019s ECRecovery library to avoid the need of splitting the signatures before the call and improving code legibility.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#verifysignatures-is-provided-with-the-r,-s,-and-v\u00a0outputs-of-the-ecdsa-signatures-trying-to-execute-a-transaction,-and-then-verifies-each-one-of-them.-consider-using-the-thoroughly-tested-openzeppelin\u2019s-ecrecovery-library-to-avoid-the-need-of-splitting-the-signatures-before-the-call-and-improving-code-legibility.", "labels": ["OpenZeppelin"]}, {"title": "In both addTokensToTransaction and addFundsToTransaction a local variable _value is defined to track the transaction value. In neither case is this definition necessary, with the value already tracked by the parameter that is passed to the function in the first case (value), and by the msg.value variable in the second.", "body": "In both addTokensToTransaction and addFundsToTransaction a local variable _value is defined to track the transaction value. In neither case is this definition necessary, with the value already tracked by the parameter that is passed to the function in the first case (value), and by the msg.value variable in the second.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#in-both-addtokenstotransaction-and-addfundstotransaction-a-local-variable-_value-is-defined-to-track-the-transaction-value.-in-neither-case-is-this-definition-necessary,-with-the-value-already-tracked-by-the-parameter-that-is-passed-to-the-function-in-the-first-case-(value),-and-by-the-msg.value-variable-in-the-second.", "labels": ["OpenZeppelin"]}, {"title": "addTokensToTransaction uses both msg.sender and transactions[scriptHash].buyer to represent the buyer interchangeably. Consider using only msg.sender (which is already used in addFundsToTransaction), and adding a comment on each function\u2019s docstring about this.", "body": "addTokensToTransaction uses both msg.sender and transactions[scriptHash].buyer to represent the buyer interchangeably. Consider using only msg.sender (which is already used in addFundsToTransaction), and adding a comment on each function\u2019s docstring about this.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#addtokenstotransaction-uses-both-msg.sender-and-transactions[scripthash].buyer-to-represent-the-buyer-interchangeably.-consider-using-only-msg.sender-(which-is-already-used-in-addfundstotransaction),-and-adding-a-comment-on-each-function\u2019s-docstring-about-this.", "labels": ["OpenZeppelin"]}, {"title": "In _addTransaction, after a Transaction has been created and stored, the owners are also added by setting the isOwner attribute of the current transaction. On line 634, the moderator address is set as owner even if it is equal to address(0) (no moderator case). Consider checking for the moderator\u2019s address validity before registering it as owner.", "body": "In _addTransaction, after a Transaction has been created and stored, the owners are also added by setting the isOwner attribute of the current transaction. On line 634, the moderator address is set as owner even if it is equal to address(0) (no moderator case). Consider checking for the moderator\u2019s address validity before registering it as owner.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#in-_addtransaction,-after-a-transaction-has-been-created-and-stored,-the-owners-are-also-added-by-setting-the-isowner-attribute-of-the-current-transaction.-on-line-634,-the-moderator-address-is-set-as-owner-even-if-it-is-equal-to-address(0)-(no-moderator-case).-consider-checking-for-the-moderator\u2019s-address-validity-before-registering-it-as-owner.", "labels": ["OpenZeppelin"]}, {"title": "Consider prefixing all private and internal functions with an underscore to clearly denote their visibility (e.g. verifyTransaction and transferFunds).", "body": "Consider prefixing all private and internal functions with an underscore to clearly denote their visibility (e.g. verifyTransaction and transferFunds).", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-prefixing-all-private-and-internal-functions-with-an-underscore-to-clearly-denote-their-visibility-(e.g.-verifytransaction-and-transferfunds).", "labels": ["OpenZeppelin"]}, {"title": "If public state variables are not expected to be read from outside the contract, consider restricting their visibility to private, in particular if getters to read such data are already defined (e.g. getAllTransactionsForParty).", "body": "If public state variables are not expected to be read from outside the contract, consider restricting their visibility to private, in particular if getters to read such data are already defined (e.g. getAllTransactionsForParty).", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#if-public-state-variables-are-not-expected-to-be-read-from-outside-the-contract,-consider-restricting-their-visibility-to-private,-in-particular-if-getters-to-read-such-data-are-already-defined-(e.g.-getalltransactionsforparty).", "labels": ["OpenZeppelin"]}, {"title": "To improve code readability, consider using address(this) instead of just this in L201, L289, L391, L403 and L521.", "body": "To improve code readability, consider using address(this) instead of just this in L201, L289, L391, L403 and L521.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#to-improve-code-readability,-consider-using-address(this)-instead-of-just-this-in-l201,-l289,-l391,-l403-and-l521.", "labels": ["OpenZeppelin"]}, {"title": "The transaction field threshold (which represents the minimum number of signatures required to release funds) would benefit from a name that better reflects what the variable represents.", "body": "The transaction field threshold (which represents the minimum number of signatures required to release funds) would benefit from a name that better reflects what the variable represents.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-transaction-field-threshold-(which-represents-the-minimum-number-of-signatures-required-to-release-funds)-would-benefit-from-a-name-that-better-reflects-what-the-variable-represents.", "labels": ["OpenZeppelin"]}, {"title": "There are code segments where a single require clause includes multiple conditions. Consider isolating each condition in its own require clause, and having more specific error messages for each.", "body": "There are code segments where a single require clause includes multiple conditions. Consider isolating each condition in its own require clause, and having more specific error messages for each.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#there-are-code-segments-where-a-single-require-clause-includes-multiple-conditions.-consider-isolating-each-condition-in-its-own-require-clause,-and-having-more-specific-error-messages-for-each.", "labels": ["OpenZeppelin"]}, {"title": "Parameter order in addTransaction and addTokenTransaction is different from each function\u2019s documented @param list. Consider documenting parameters in the same order as they are defined in each function\u2019s signature", "body": "Parameter order in addTransaction and addTokenTransaction is different from each function\u2019s documented @param list. Consider documenting parameters in the same order as they are defined in each function\u2019s signature", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#parameter-order-in-addtransaction-and-addtokentransaction-is-different-from-each-function\u2019s-documented-@param-list.-consider-documenting-parameters-in-the-same-order-as-they-are-defined-in-each-function\u2019s-signature", "labels": ["OpenZeppelin"]}, {"title": "calculateRedeemScriptHash\u2018s docstring states how the script hash is to be obtained. While the Escrow contract\u2019s address is being used in the hash calculation, it is currently missing from the docstring, consider adding it.", "body": "calculateRedeemScriptHash\u2018s docstring states how the script hash is to be obtained. While the Escrow contract\u2019s address is being used in the hash calculation, it is currently missing from the docstring, consider adding it.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#calculateredeemscripthash\u2018s-docstring-states-how-the-script-hash-is-to-be-obtained.-while-the-escrow-contract\u2019s-address-is-being-used-in-the-hash-calculation,-it-is-currently-missing-from-the-docstring,-consider-adding-it.", "labels": ["OpenZeppelin"]}, {"title": "The contract\u2019s docstring would benefit from a more thorough and clearer description of its purpose and use cases.", "body": "The contract\u2019s docstring would benefit from a more thorough and clearer description of its purpose and use cases.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#the-contract\u2019s-docstring-would-benefit-from-a-more-thorough-and-clearer-description-of-its-purpose-and-use-cases.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a comment specifying the time units in which the lastModified field of a transaction is measured.", "body": "Consider adding a comment specifying the time units in which the lastModified field of a transaction is measured.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#consider-adding-a-comment-specifying-the-time-units-in-which-the-lastmodified-field-of-a-transaction-is-measured.", "labels": ["OpenZeppelin"]}, {"title": "Even though test files were out of the audit\u2019s scope, they were used as a guide to develop and test specific behaviors during the audit. In them, tests with wrong messages in asserts were found (\u201cTransaction was sent from buyer\u2019s address\u201d, where it should be \u201cwas not sent\u201d). Furthermore, two test cases, L149 and L198, with the same name but different content were found. Consider ensuring all messages correspond with what is being evaluated, and expanding test case descriptions to be more precise.", "body": "Even though test files were out of the audit\u2019s scope, they were used as a guide to develop and test specific behaviors during the audit. In them, tests with wrong messages in asserts were found (\u201cTransaction was sent from buyer\u2019s address\u201d, where it should be \u201cwas not sent\u201d). Furthermore, two test cases, L149 and L198, with the same name but different content were found. Consider ensuring all messages correspond with what is being evaluated, and expanding test case descriptions to be more precise.", "html_url": "https://blog.openzeppelin.com/openbazaars-escrow-audit#even-though-test-files-were-out-of-the-audit\u2019s-scope,-they-were-used-as-a-guide-to-develop-and-test-specific-behaviors-during-the-audit.-in-them,-tests-with-wrong-messages-in-asserts-were-found-(\u201ctransaction-was-sent-from-buyer\u2019s-address\u201d,-where-it-should-be-\u201cwas-not-sent\u201d).-furthermore,-two-test-cases,-l149-and-l198,-with-the-same-name-but-different-content-were-found.-consider-ensuring-all-messages-correspond-with-what-is-being-evaluated,-and-expanding-test-case-descriptions-to-be-more-precise.", "labels": ["OpenZeppelin"]}, {"title": "Anybody can mint DebtToken", "body": "Anybody can mint DebtToken", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#anybody-can-mint-debttoken", "labels": ["OpenZeppelin"]}, {"title": "DebtToken extends MintableNonFungibleToken and thus inherits a public mint function that allows the caller to create new tokens.", "body": "DebtToken extends MintableNonFungibleToken and thus inherits a public mint function that allows the caller to create new tokens.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#debttoken-extends-mintablenonfungibletoken-and-thus-inherits-a-public-mint-function-that-allows-the-caller-to-create-new-tokens.", "labels": ["OpenZeppelin"]}, {"title": "Given that there is an additional create function defined in DebtToken which requires authorization, it\u2019s clear to us that mint should require the same. Otherwise, it can be called by anyone with an arbitrary token id.", "body": "Given that there is an additional create function defined in DebtToken which requires authorization, it\u2019s clear to us that mint should require the same. Otherwise, it can be called by anyone with an arbitrary token id.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#given-that-there-is-an-additional-create-function-defined-in-debttoken-which-requires-authorization,-it\u2019s-clear-to-us-that-mint-should-require-the-same.-otherwise,-it-can-be-called-by-anyone-with-an-arbitrary-token-id.", "labels": ["OpenZeppelin"]}, {"title": "A consequence of this function being public is that anyone is able to impede the filling of a debt order, by minting a token with the corresponding issuance hash as id before the order is attempted to be filled. The entire system can be put to a halt in this way.", "body": "A consequence of this function being public is that anyone is able to impede the filling of a debt order, by minting a token with the corresponding issuance hash as id before the order is attempted to be filled. The entire system can be put to a halt in this way.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#a-consequence-of-this-function-being-public-is-that-anyone-is-able-to-impede-the-filling-of-a-debt-order,-by-minting-a-token-with-the-corresponding-issuance-hash-as-id-before-the-order-is-attempted-to-be-filled.-the-entire-system-can-be-put-to-a-halt-in-this-way.", "labels": ["OpenZeppelin"]}, {"title": "To fix this, add to mint the same authorization check seen increate.", "body": "To fix this, add to mint the same authorization check seen increate.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#to-fix-this,-add-to-mint-the-same-authorization-check-seen-increate.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in 97690a9 by making\u00a0mint an internal function in\u00a0MintableNonFungibleToken.", "body": "Update: Fixed in 97690a9 by making\u00a0mint an internal function in\u00a0MintableNonFungibleToken.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-97690a9-by-making\u00a0mint-an-internal-function-in\u00a0mintablenonfungibletoken.", "labels": ["OpenZeppelin"]}, {"title": "Use of block numbers to express moments in\u00a0time", "body": "Use of block numbers to express moments in\u00a0time", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#use-of-block-numbers-to-express-moments-in\u00a0time", "labels": ["OpenZeppelin"]}, {"title": "Implementors of the TermsContracts interface are expected to define repayment terms as a function of block numbers, as documented and seen in the function signatures of getExpectedRepaymentValue and getValueRepaid. To aid in this, entries in DebtRegistry record the issuance block number.", "body": "Implementors of the TermsContracts interface are expected to define repayment terms as a function of block numbers, as documented and seen in the function signatures of getExpectedRepaymentValue and getValueRepaid. To aid in this, entries in DebtRegistry record the issuance block number.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#implementors-of-the-termscontracts-interface-are-expected-to-define-repayment-terms-as-a-function-of-block-numbers,-as-documented-and-seen-in-the-function-signatures-of-getexpectedrepaymentvalue-and-getvaluerepaid.-to-aid-in-this,-entries-in-debtregistry-record-the-issuance-block-number.", "labels": ["OpenZeppelin"]}, {"title": "Block timestamps have a small risk of miner manipulation within a range of minutes, so it is recommended to use block numbers for certain usecases where this manipulation is a security risk. It should be noted, however, that block times are not fixed, and thus block numbers are not a reliable unit of time. For example, the constant SEVEN_DAYS_IN_BLOCKS will not always represent the timespan of seven days that it is meant to.", "body": "Block timestamps have a small risk of miner manipulation within a range of minutes, so it is recommended to use block numbers for certain usecases where this manipulation is a security risk. It should be noted, however, that block times are not fixed, and thus block numbers are not a reliable unit of time. For example, the constant SEVEN_DAYS_IN_BLOCKS will not always represent the timespan of seven days that it is meant to.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#block-timestamps-have-a-small-risk-of-miner-manipulation-within-a-range-of-minutes,-so-it-is-recommended-to-use-block-numbers-for-certain-usecases-where-this-manipulation-is-a-security-risk.-it-should-be-noted,-however,-that-block-times-are-not-fixed,-and-thus-block-numbers-are-not-a-reliable-unit-of-time.-for-example,-the-constant-seven_days_in_blocks-will-not-always-represent-the-timespan-of-seven-days-that-it-is-meant-to.", "labels": ["OpenZeppelin"]}, {"title": "For the specific use case of determining repayment dates we think that the predictability of timestamps is preferable, and that it does not compromise the security of the system. Consider changing interfaces and data structures to use timestamps instead of block numbers.", "body": "For the specific use case of determining repayment dates we think that the predictability of timestamps is preferable, and that it does not compromise the security of the system. Consider changing interfaces and data structures to use timestamps instead of block numbers.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#for-the-specific-use-case-of-determining-repayment-dates-we-think-that-the-predictability-of-timestamps-is-preferable,-and-that-it-does-not-compromise-the-security-of-the-system.-consider-changing-interfaces-and-data-structures-to-use-timestamps-instead-of-block-numbers.", "labels": ["OpenZeppelin"]}, {"title": "Update: Changed to timestamps in d4dc030.", "body": "Update: Changed to timestamps in d4dc030.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-changed-to-timestamps-in-d4dc030.", "labels": ["OpenZeppelin"]}, {"title": "Unbounded loop in PermissionsLib", "body": "Unbounded loop in PermissionsLib", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#unbounded-loop-in-permissionslib", "labels": ["OpenZeppelin"]}, {"title": "The revokeAuthorization function in PermissionsLib performs a linear search over an array of unbounded size. Through subsequent calls to authorize, the array could grow to a size so large that a call to revokeAuthorization would be prohibitively expensive and not fit in a block.", "body": "The revokeAuthorization function in PermissionsLib performs a linear search over an array of unbounded size. Through subsequent calls to authorize, the array could grow to a size so large that a call to revokeAuthorization would be prohibitively expensive and not fit in a block.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-revokeauthorization-function-in-permissionslib-performs-a-linear-search-over-an-array-of-unbounded-size.-through-subsequent-calls-to-authorize,-the-array-could-grow-to-a-size-so-large-that-a-call-to-revokeauthorization-would-be-prohibitively-expensive-and-not-fit-in-a-block.", "labels": ["OpenZeppelin"]}, {"title": "Consider modifying the Permissions struct to include a mapping to save the index of each authorized address in the authorizedAgents array. In this way it will not be necessary to perform a linear search at all.", "body": "Consider modifying the Permissions struct to include a mapping to save the index of each authorized address in the authorizedAgents array. In this way it will not be necessary to perform a linear search at all.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#consider-modifying-the-permissions-struct-to-include-a-mapping-to-save-the-index-of-each-authorized-address-in-the-authorizedagents-array.-in-this-way-it-will-not-be-necessary-to-perform-a-linear-search-at-all.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed across several commits.", "body": "Update: Fixed across several commits.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-across-several-commits.", "labels": ["OpenZeppelin"]}, {"title": "Duplication of owner logic in DebtToken", "body": "Duplication of owner logic in DebtToken", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#duplication-of-owner-logic-in-debttoken", "labels": ["OpenZeppelin"]}, {"title": "DebtToken extends NonFungibleToken and redefines the latter\u2019s setTokenOwne and ownerO internal functions, so that they modify the DebtRegistry instead of the NFT\u2019s own tracking of ownership. This seems to result in coherent behavior, but we think it\u2019s an unnecessary meddling with NonFungibleToken\u2019s semantics, and could eventually cause some obscure hard-to-spot issues.", "body": "DebtToken extends NonFungibleToken and redefines the latter\u2019s setTokenOwne and ownerO internal functions, so that they modify the DebtRegistry instead of the NFT\u2019s own tracking of ownership. This seems to result in coherent behavior, but we think it\u2019s an unnecessary meddling with NonFungibleToken\u2019s semantics, and could eventually cause some obscure hard-to-spot issues.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#debttoken-extends-nonfungibletoken-and-redefines-the-latter\u2019s-settokenowne-and-ownero-internal-functions,-so-that-they-modify-the-debtregistry-instead-of-the-nft\u2019s-own-tracking-of-ownership.-this-seems-to-result-in-coherent-behavior,-but-we-think-it\u2019s-an-unnecessary-meddling-with-nonfungibletoken\u2019s-semantics,-and-could-eventually-cause-some-obscure-hard-to-spot-issues.", "labels": ["OpenZeppelin"]}, {"title": "We would suggest to remove the redefinition of _ownerOf, and to modify _setTokenOwner so that it runs super._setTokenOwner() additionally to the calls on the registry. In this way the registry is kept in sync with the token\u2019s tracking of ownership, but merely by intercepting changes of ownership, instead of entirely replacing that part of the token\u2019s implementation.", "body": "We would suggest to remove the redefinition of _ownerOf, and to modify _setTokenOwner so that it runs super._setTokenOwner() additionally to the calls on the registry. In this way the registry is kept in sync with the token\u2019s tracking of ownership, but merely by intercepting changes of ownership, instead of entirely replacing that part of the token\u2019s implementation.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#we-would-suggest-to-remove-the-redefinition-of-_ownerof,-and-to-modify-_settokenowner-so-that-it-runs-super._settokenowner()-additionally-to-the-calls-on-the-registry.-in-this-way-the-registry-is-kept-in-sync-with-the-token\u2019s-tracking-of-ownership,-but-merely-by-intercepting-changes-of-ownership,-instead-of-entirely-replacing-that-part-of-the-token\u2019s-implementation.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in 7a618cf.", "body": "Update: Fixed in 7a618cf.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-7a618cf.", "labels": ["OpenZeppelin"]}, {"title": "DebtRegistry assumption could be\u00a0broken", "body": "DebtRegistry assumption could be\u00a0broken", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#debtregistry-assumption-could-be\u00a0broken", "labels": ["OpenZeppelin"]}, {"title": "The contracts in the system assume that a valid Entry in the DebtRegistry will never have a null address for beneficiary. This assumption is used, for example, in RepaymentRouter\u2019s repay to ensure a repayment is done for a valid issuance, as well as in DebtRegistry itself to check that an inserted entry is new and doesn\u2019t clash with a previous one.", "body": "The contracts in the system assume that a valid Entry in the DebtRegistry will never have a null address for beneficiary. This assumption is used, for example, in RepaymentRouter\u2019s repay to ensure a repayment is done for a valid issuance, as well as in DebtRegistry itself to check that an inserted entry is new and doesn\u2019t clash with a previous one.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-contracts-in-the-system-assume-that-a-valid-entry-in-the-debtregistry-will-never-have-a-null-address-for-beneficiary.-this-assumption-is-used,-for-example,-in-repaymentrouter\u2019s-repay-to-ensure-a-repayment-is-done-for-a-valid-issuance,-as-well-as-in-debtregistry-itself-to-check-that-an-inserted-entry-is-new-and-doesn\u2019t-clash-with-a-previous-one.", "labels": ["OpenZeppelin"]}, {"title": "An authorized agent could, however, insert an entry with a null beneficiary through insert, or set the beneficiary of an existing entry to the null one through modifyBeneficiary. Thus, the assumption can be broken.", "body": "An authorized agent could, however, insert an entry with a null beneficiary through insert, or set the beneficiary of an existing entry to the null one through modifyBeneficiary. Thus, the assumption can be broken.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#an-authorized-agent-could,-however,-insert-an-entry-with-a-null-beneficiary-through-insert,-or-set-the-beneficiary-of-an-existing-entry-to-the-null-one-through-modifybeneficiary.-thus,-the-assumption-can-be-broken.", "labels": ["OpenZeppelin"]}, {"title": "Add checks in insert and in modifyBeneficiary to reject null beneficiaries.", "body": "Add checks in insert and in modifyBeneficiary to reject null beneficiaries.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#add-checks-in-insert-and-in-modifybeneficiary-to-reject-null-beneficiaries.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in d314446.", "body": "Update: Fixed in d314446.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-d314446.", "labels": ["OpenZeppelin"]}, {"title": "External query gas limit may be problematic", "body": "External query gas limit may be problematic", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#external-query-gas-limit-may-be-problematic", "labels": ["OpenZeppelin"]}, {"title": "In DebtKernel, the functions getBalance and getAllowance are used to query the balance and allowance of any arbitrary token used to fill a debt order. The query is done by calling the ERC20 balanceOf and allowance functions on said token contract with a gas limit of EXTERNAL_QUERY_GAS_LIMIT. (Although getAllowance doesn\u2019t limit the gas, a comment implies that it should be doing so.)", "body": "In DebtKernel, the functions getBalance and getAllowance are used to query the balance and allowance of any arbitrary token used to fill a debt order. The query is done by calling the ERC20 balanceOf and allowance functions on said token contract with a gas limit of EXTERNAL_QUERY_GAS_LIMIT. (Although getAllowance doesn\u2019t limit the gas, a comment implies that it should be doing so.)", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#in-debtkernel,-the-functions-getbalance-and-getallowance-are-used-to-query-the-balance-and-allowance-of-any-arbitrary-token-used-to-fill-a-debt-order.-the-query-is-done-by-calling-the-erc20-balanceof-and-allowance-functions-on-said-token-contract-with-a-gas-limit-of-external_query_gas_limit.-(although-getallowance-doesn\u2019t-limit-the-gas,-a-comment-implies-that-it-should-be-doing-so.)", "labels": ["OpenZeppelin"]}, {"title": "The EXTERNAL_QUERY_GAS_LIMIT constant has a value of 4999, justified by the fact that changes to state require at least 5000 gas. Although we share the concern that an external call such as a balance check could cause a re-entrancy attack, the reality is that gas limits are not part of the ERC20 spec, and a token is free to implement a balance check that costs more than 4999 gas. In fact, quick tests show us that a balance check in a recently cloned MiniMe token (a popular token implementation) costs around 4320 gas, which is dangerously close to the constant limit imposed.", "body": "The EXTERNAL_QUERY_GAS_LIMIT constant has a value of 4999, justified by the fact that changes to state require at least 5000 gas. Although we share the concern that an external call such as a balance check could cause a re-entrancy attack, the reality is that gas limits are not part of the ERC20 spec, and a token is free to implement a balance check that costs more than 4999 gas. In fact, quick tests show us that a balance check in a recently cloned MiniMe token (a popular token implementation) costs around 4320 gas, which is dangerously close to the constant limit imposed.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-external_query_gas_limit-constant-has-a-value-of-4999,-justified-by-the-fact-that-changes-to-state-require-at-least-5000-gas.-although-we-share-the-concern-that-an-external-call-such-as-a-balance-check-could-cause-a-re-entrancy-attack,-the-reality-is-that-gas-limits-are-not-part-of-the-erc20-spec,-and-a-token-is-free-to-implement-a-balance-check-that-costs-more-than-4999-gas.-in-fact,-quick-tests-show-us-that-a-balance-check-in-a-recently-cloned-minime-token-(a-popular-token-implementation)-costs-around-4320-gas,-which-is-dangerously-close-to-the-constant-limit-imposed.", "labels": ["OpenZeppelin"]}, {"title": "We would recommend to look into the recent new opcode STATICCALL to use as an alternative to limiting gas. This opcode will eliminate the risk of re-entrancy by ensuring that an external call performs no state changes, which is fine to assume for ERC20 functions balanceOf and allowance, as they are constant functions.", "body": "We would recommend to look into the recent new opcode STATICCALL to use as an alternative to limiting gas. This opcode will eliminate the risk of re-entrancy by ensuring that an external call performs no state changes, which is fine to assume for ERC20 functions balanceOf and allowance, as they are constant functions.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#we-would-recommend-to-look-into-the-recent-new-opcode-staticcall-to-use-as-an-alternative-to-limiting-gas.-this-opcode-will-eliminate-the-risk-of-re-entrancy-by-ensuring-that-an-external-call-performs-no-state-changes,-which-is-fine-to-assume-for-erc20-functions-balanceof-and-allowance,-as-they-are-constant-functions.", "labels": ["OpenZeppelin"]}, {"title": "Update: Due to the unavailability of STATICCALL in high-level Solidity code as of yet, the team has decided to stick with a simple gas limit. However, the limit was raised to 8000 and the missing check was added in ff1a22e.", "body": "Update: Due to the unavailability of STATICCALL in high-level Solidity code as of yet, the team has decided to stick with a simple gas limit. However, the limit was raised to 8000 and the missing check was added in ff1a22e.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-due-to-the-unavailability-of-staticcall-in-high-level-solidity-code-as-of-yet,-the-team-has-decided-to-stick-with-a-simple-gas-limit.-however,-the-limit-was-raised-to-8000-and-the-missing-check-was-added-in-ff1a22e.", "labels": ["OpenZeppelin"]}, {"title": "SimpleInterestTermsContract will silently accept other\u00a0tokens", "body": "SimpleInterestTermsContract will silently accept other\u00a0tokens", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#simpleinteresttermscontract-will-silently-accept-other\u00a0tokens", "labels": ["OpenZeppelin"]}, {"title": "The function registerRepayment implemented in SimpleInterestTermsContract is meant to be called by the RepaymentRouter whenever a debtor repays part of an issued debt. Although said terms contract requires repayments to be done in a specific token repaymentToken, registerRepayment could be called with a different token as parameter. This is recognized by the contract, since the valueRepaid is only updated when the correct token is used, but the function will silently accept any other token. We would recommend to reject any other token, by returning false from registerRepayment.", "body": "The function registerRepayment implemented in SimpleInterestTermsContract is meant to be called by the RepaymentRouter whenever a debtor repays part of an issued debt. Although said terms contract requires repayments to be done in a specific token repaymentToken, registerRepayment could be called with a different token as parameter. This is recognized by the contract, since the valueRepaid is only updated when the correct token is used, but the function will silently accept any other token. We would recommend to reject any other token, by returning false from registerRepayment.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-function-registerrepayment-implemented-in-simpleinteresttermscontract-is-meant-to-be-called-by-the-repaymentrouter-whenever-a-debtor-repays-part-of-an-issued-debt.-although-said-terms-contract-requires-repayments-to-be-done-in-a-specific-token-repaymenttoken,-registerrepayment-could-be-called-with-a-different-token-as-parameter.-this-is-recognized-by-the-contract,-since-the-valuerepaid-is-only-updated-when-the-correct-token-is-used,-but-the-function-will-silently-accept-any-other-token.-we-would-recommend-to-reject-any-other-token,-by-returning-false-from-registerrepayment.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in 1bfa459.", "body": "Update: Fixed in 1bfa459.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-1bfa459.", "labels": ["OpenZeppelin"]}, {"title": "Mismatch between signature and implementation of getValueRepaid", "body": "Mismatch between signature and implementation of getValueRepaid", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#mismatch-between-signature-and-implementation-of-getvaluerepaid", "labels": ["OpenZeppelin"]}, {"title": "The documented semantics of TermsContract\u2019s getValueRepaid is that it returns \u201cthe cumulative units-of-value repaid by the point at which a given blockNumber has passed\u201d, where blockNumber is one of the function arguments. Both SimpleInterestTermsContract and NFTTermsContract do not implement this semantics: they ignore the blockNumber argument and return the value corresponding to the moment when the function is called. Consider either changing the interface and documentation, or implementing the documented behavior.", "body": "The documented semantics of TermsContract\u2019s getValueRepaid is that it returns \u201cthe cumulative units-of-value repaid by the point at which a given blockNumber has passed\u201d, where blockNumber is one of the function arguments. Both SimpleInterestTermsContract and NFTTermsContract do not implement this semantics: they ignore the blockNumber argument and return the value corresponding to the moment when the function is called. Consider either changing the interface and documentation, or implementing the documented behavior.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-documented-semantics-of-termscontract\u2019s-getvaluerepaid-is-that-it-returns-\u201cthe-cumulative-units-of-value-repaid-by-the-point-at-which-a-given-blocknumber-has-passed\u201d,-where-blocknumber-is-one-of-the-function-arguments.-both-simpleinteresttermscontract-and-nfttermscontract-do-not-implement-this-semantics:-they-ignore-the-blocknumber-argument-and-return-the-value-corresponding-to-the-moment-when-the-function-is-called.-consider-either-changing-the-interface-and-documentation,-or-implementing-the-documented-behavior.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in 6db0eee.", "body": "Update: Fixed in 6db0eee.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-6db0eee.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Pausable operations in DebtRegistry and DebtToken", "body": "Inconsistent Pausable operations in DebtRegistry and DebtToken", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#inconsistent-pausable-operations-in-debtregistry-and-debttoken", "labels": ["OpenZeppelin"]}, {"title": "The main functionality of DebtRegistry is correctly guarded with whenNotPaused modifiers to ensure they cannot be used when the contract is in \u201cpaused\u201d state. There are other non-constant functions in the contract (those related to permissions) which are inconsistently guarded: revokeInsertAgentAuthorization has the whenNotPaused modifier, but none of the others do. Consider either removing the modifier in this function or adding it to the other three permissions-related functions in the contract for consistency.", "body": "The main functionality of DebtRegistry is correctly guarded with whenNotPaused modifiers to ensure they cannot be used when the contract is in \u201cpaused\u201d state. There are other non-constant functions in the contract (those related to permissions) which are inconsistently guarded: revokeInsertAgentAuthorization has the whenNotPaused modifier, but none of the others do. Consider either removing the modifier in this function or adding it to the other three permissions-related functions in the contract for consistency.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-main-functionality-of-debtregistry-is-correctly-guarded-with-whennotpaused-modifiers-to-ensure-they-cannot-be-used-when-the-contract-is-in-\u201cpaused\u201d-state.-there-are-other-non-constant-functions-in-the-contract-(those-related-to-permissions)-which-are-inconsistently-guarded:-revokeinsertagentauthorization-has-the-whennotpaused-modifier,-but-none-of-the-others-do.-consider-either-removing-the-modifier-in-this-function-or-adding-it-to-the-other-three-permissions-related-functions-in-the-contract-for-consistency.", "labels": ["OpenZeppelin"]}, {"title": "Likewise, the contract DebtToken prevents all kinds of transfers during the \u201cpaused\u201d state by adding the modifier to the _clearApprovalAndTransfer function. There is one additional operation which should likely be affected by pausing as well: approve. Consider adding the whenNotPaused modifier to the approve function in DebtToken.", "body": "Likewise, the contract DebtToken prevents all kinds of transfers during the \u201cpaused\u201d state by adding the modifier to the _clearApprovalAndTransfer function. There is one additional operation which should likely be affected by pausing as well: approve. Consider adding the whenNotPaused modifier to the approve function in DebtToken.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#likewise,-the-contract-debttoken-prevents-all-kinds-of-transfers-during-the-\u201cpaused\u201d-state-by-adding-the-modifier-to-the-_clearapprovalandtransfer-function.-there-is-one-additional-operation-which-should-likely-be-affected-by-pausing-as-well:-approve.-consider-adding-the-whennotpaused-modifier-to-the-approve-function-in-debttoken.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in 1ec4f35.", "body": "Update: Fixed in 1ec4f35.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-1ec4f35.", "labels": ["OpenZeppelin"]}, {"title": "Edge case in PermissionsLib leaves data in\u00a0storage", "body": "Edge case in PermissionsLib leaves data in\u00a0storage", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#edge-case-in-permissionslib-leaves-data-in\u00a0storage", "labels": ["OpenZeppelin"]}, {"title": "The revokeAuthorization function in PermissionsLib removes the given address from the authorizedAgents array. The algorithm does not correctly consider the edge case when the array is reduced from length 1 to length 0. The new array length is correctly set to 0, but the address previously in the list will remain in storage, out of bounds.", "body": "The revokeAuthorization function in PermissionsLib removes the given address from the authorizedAgents array. The algorithm does not correctly consider the edge case when the array is reduced from length 1 to length 0. The new array length is correctly set to 0, but the address previously in the list will remain in storage, out of bounds.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-revokeauthorization-function-in-permissionslib-removes-the-given-address-from-the-authorizedagents-array.-the-algorithm-does-not-correctly-consider-the-edge-case-when-the-array-is-reduced-from-length-1-to-length-0.-the-new-array-length-is-correctly-set-to-0,-but-the-address-previously-in-the-list-will-remain-in-storage,-out-of-bounds.", "labels": ["OpenZeppelin"]}, {"title": "Although this is unlikely to cause a problem for the semantics of the contracts, consider zeroing out the last slot in the array before decrementing its length, similarly to what NonFungibleToken does.", "body": "Although this is unlikely to cause a problem for the semantics of the contracts, consider zeroing out the last slot in the array before decrementing its length, similarly to what NonFungibleToken does.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#although-this-is-unlikely-to-cause-a-problem-for-the-semantics-of-the-contracts,-consider-zeroing-out-the-last-slot-in-the-array-before-decrementing-its-length,-similarly-to-what-nonfungibletoken-does.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in f9ef4d9.", "body": "Update: Fixed in f9ef4d9.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-f9ef4d9.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary use of\u00a0var", "body": "Unnecessary use of\u00a0var", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#unnecessary-use-of\u00a0var", "labels": ["OpenZeppelin"]}, {"title": "In getExpectedRepaymentValue of SimpleInterestTermsContract, var is used in the destructuring of a tuple.", "body": "In getExpectedRepaymentValue of SimpleInterestTermsContract, var is used in the destructuring of a tuple.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#in-getexpectedrepaymentvalue-of-simpleinteresttermscontract,-var-is-used-in-the-destructuring-of-a-tuple.", "labels": ["OpenZeppelin"]}, {"title": "It is encouraged to declare types explicitly, to avoid surprises with regards to integer sizes and their overflow semantics. In Solidity, var allows types to be deduced from the values on the right hand side of an assignment, and its use is discouraged.", "body": "It is encouraged to declare types explicitly, to avoid surprises with regards to integer sizes and their overflow semantics. In Solidity, var allows types to be deduced from the values on the right hand side of an assignment, and its use is discouraged.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#it-is-encouraged-to-declare-types-explicitly,-to-avoid-surprises-with-regards-to-integer-sizes-and-their-overflow-semantics.-in-solidity,-var-allows-types-to-be-deduced-from-the-values-on-the-right-hand-side-of-an-assignment,-and-its-use-is-discouraged.", "labels": ["OpenZeppelin"]}, {"title": "To perform the same destructuring but with explicit types, first declare the variables principalPlusInterest and termLengthInBlocks with their explicit types (uint128), and then use those variables in a destructuring assignment without var: (principalPlusInterest, termLengthInBlocks) = unpackParameters(parameters).", "body": "To perform the same destructuring but with explicit types, first declare the variables principalPlusInterest and termLengthInBlocks with their explicit types (uint128), and then use those variables in a destructuring assignment without var: (principalPlusInterest, termLengthInBlocks) = unpackParameters(parameters).", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#to-perform-the-same-destructuring-but-with-explicit-types,-first-declare-the-variables-principalplusinterest-and-termlengthinblocks-with-their-explicit-types-(uint128),-and-then-use-those-variables-in-a-destructuring-assignment-without-var:-(principalplusinterest,-termlengthinblocks)-=-unpackparameters(parameters).", "labels": ["OpenZeppelin"]}, {"title": "Update: All uses of var were removed.", "body": "Update: All uses of var were removed.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-all-uses-of-var-were-removed.", "labels": ["OpenZeppelin"]}, {"title": "Duplicate declaration of data structures", "body": "Duplicate declaration of data structures", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#duplicate-declaration-of-data-structures", "labels": ["OpenZeppelin"]}, {"title": "There are two Issuance structs, one defined in DebtKernel and another one in DebtRegistry, which are basically the same, except for one member. This duplication could cause problems if the two data structure definitions ever get out of sync during development. Consider having one definition in a central place, together with the relevant operations defined as functions.", "body": "There are two Issuance structs, one defined in DebtKernel and another one in DebtRegistry, which are basically the same, except for one member. This duplication could cause problems if the two data structure definitions ever get out of sync during development. Consider having one definition in a central place, together with the relevant operations defined as functions.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#there-are-two-issuance-structs,-one-defined-in-debtkernel-and-another-one-in-debtregistry,-which-are-basically-the-same,-except-for-one-member.-this-duplication-could-cause-problems-if-the-two-data-structure-definitions-ever-get-out-of-sync-during-development.-consider-having-one-definition-in-a-central-place,-together-with-the-relevant-operations-defined-as-functions.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in 0566271.", "body": "Update: Fixed in 0566271.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#update:-fixed-in-0566271.", "labels": ["OpenZeppelin"]}, {"title": "In the description of Debt Issuance Commitments in the whitepaper, the termsContractParameters field is documented as a string, inconsistently with elsewhere (including the implementation) where it is a bytes32 value.", "body": "In the description of Debt Issuance Commitments in the whitepaper, the termsContractParameters field is documented as a string, inconsistently with elsewhere (including the implementation) where it is a bytes32 value.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#in-the-description-of-debt-issuance-commitments-in-the-whitepaper,-the-termscontractparameters-field-is-documented-as-a-string,-inconsistently-with-elsewhere-(including-the-implementation)-where-it-is-a-bytes32-value.", "labels": ["OpenZeppelin"]}, {"title": "DebtToken has three unused state variables: brokeredTokenId, tokenBrokeragePermissions, tokenExchangePermissions. Consider removing them.Update: The variables have been removed.", "body": "DebtToken has three unused state variables: brokeredTokenId, tokenBrokeragePermissions, tokenExchangePermissions. Consider removing them.Update: The variables have been removed.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#debttoken-has-three-unused-state-variables:-brokeredtokenid,-tokenbrokeragepermissions,-tokenexchangepermissions.-consider-removing-them.update:-the-variables-have-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "The TermsContract interface does not mention in its documentation that implementors must expect repayments to come through the RepaymentRouter. Consider making it explicit.", "body": "The TermsContract interface does not mention in its documentation that implementors must expect repayments to come through the RepaymentRouter. Consider making it explicit.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#the-termscontract-interface-does-not-mention-in-its-documentation-that-implementors-must-expect-repayments-to-come-through-the-repaymentrouter.-consider-making-it-explicit.", "labels": ["OpenZeppelin"]}, {"title": "There is two different names used to refer to the same concept: issuanceHash and agreementId. Consider consolidating to a single name.", "body": "There is two different names used to refer to the same concept: issuanceHash and agreementId. Consider consolidating to a single name.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#there-is-two-different-names-used-to-refer-to-the-same-concept:-issuancehash-and-agreementid.-consider-consolidating-to-a-single-name.", "labels": ["OpenZeppelin"]}, {"title": "ERC721 is a moving target, and by now the interface implemented by the NonFungibleToken used is obsolete. For example, implementsERC721 is now an optional function, and the functions getApproved and transferFrom (which is necessary for the correct functioning of TokenTransferProxy) are no longer part of the specification. Please keep this in mind for further development.", "body": "ERC721 is a moving target, and by now the interface implemented by the NonFungibleToken used is obsolete. For example, implementsERC721 is now an optional function, and the functions getApproved and transferFrom (which is necessary for the correct functioning of TokenTransferProxy) are no longer part of the specification. Please keep this in mind for further development.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#erc721-is-a-moving-target,-and-by-now-the-interface-implemented-by-the-nonfungibletoken-used-is-obsolete.-for-example,-implementserc721-is-now-an-optional-function,-and-the-functions-getapproved-and-transferfrom-(which-is-necessary-for-the-correct-functioning-of-tokentransferproxy)-are-no-longer-part-of-the-specification.-please-keep-this-in-mind-for-further-development.", "labels": ["OpenZeppelin"]}, {"title": "There is no documentation in DebtKernel or in the whitepaper of the order in which the different cryptographic signatures used in fillDebtOrder must be sent. Consider documenting it.", "body": "There is no documentation in DebtKernel or in the whitepaper of the order in which the different cryptographic signatures used in fillDebtOrder must be sent. Consider documenting it.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#there-is-no-documentation-in-debtkernel-or-in-the-whitepaper-of-the-order-in-which-the-different-cryptographic-signatures-used-in-filldebtorder-must-be-sent.-consider-documenting-it.", "labels": ["OpenZeppelin"]}, {"title": "There is a limit on the number of arguments to a Solidity function which was apparently met in fillDebtOrder, which forced the interface to receive arrays of the different types of values. A yet experimental feature of the Solidity compiler called ABIEncoderV2 will allow declaring external functions that receive structs as parameters. We would suggest to use this feature once it\u2019s available.", "body": "There is a limit on the number of arguments to a Solidity function which was apparently met in fillDebtOrder, which forced the interface to receive arrays of the different types of values. A yet experimental feature of the Solidity compiler called ABIEncoderV2 will allow declaring external functions that receive structs as parameters. We would suggest to use this feature once it\u2019s available.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#there-is-a-limit-on-the-number-of-arguments-to-a-solidity-function-which-was-apparently-met-in-filldebtorder,-which-forced-the-interface-to-receive-arrays-of-the-different-types-of-values.-a-yet-experimental-feature-of-the-solidity-compiler-called-abiencoderv2-will-allow-declaring-external-functions-that-receive-structs-as-parameters.-we-would-suggest-to-use-this-feature-once-it\u2019s-available.", "labels": ["OpenZeppelin"]}, {"title": "SimpleInterestTermsContract and NFTTermsContract are abstract contracts because they don\u2019t implement all of the functions declared in the parent TermsContract interface. This part of the system is likely still in development.", "body": "SimpleInterestTermsContract and NFTTermsContract are abstract contracts because they don\u2019t implement all of the functions declared in the parent TermsContract interface. This part of the system is likely still in development.", "html_url": "https://blog.openzeppelin.com/dharma-audit-2f1386455688#simpleinteresttermscontract-and-nfttermscontract-are-abstract-contracts-because-they-don\u2019t-implement-all-of-the-functions-declared-in-the-parent-termscontract-interface.-this-part-of-the-system-is-likely-still-in-development.", "labels": ["OpenZeppelin"]}, {"title": "Centralized issuance, requires trust in US government", "body": "Centralized issuance, requires trust in US government", "html_url": "https://blog.openzeppelin.com/us-dollar-audit-90dbcbb0258f#centralized-issuance,-requires-trust-in-us-government", "labels": ["OpenZeppelin"]}]