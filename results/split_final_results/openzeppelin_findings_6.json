[{"title": "In the same function,\u00a0_liveness\u00a0is checked to be greater than zero, in line with the Optimistic Oracle\u2019s\u00a0lower bound\u00a0requirement. However,\u00a0setUp\u00a0does not check that\u00a0_liveness\u00a0is less than 5200 weeks, which is the Optimistic Oracle\u2019s\u00a0upper bound\u00a0requirement.", "body": "In the same function,\u00a0_liveness\u00a0is checked to be greater than zero, in line with the Optimistic Oracle\u2019s\u00a0lower bound\u00a0requirement. However,\u00a0setUp\u00a0does not check that\u00a0_liveness\u00a0is less than 5200 weeks, which is the Optimistic Oracle\u2019s\u00a0upper bound\u00a0requirement.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the-same-function,\u00a0_liveness\u00a0is-checked-to-be-greater-than-zero,-in-line-with-the-optimistic-oracle\u2019s\u00a0lower-bound\u00a0requirement.-however,\u00a0setup\u00a0does-not-check-that\u00a0_liveness\u00a0is-less-than-5200-weeks,-which-is-the-optimistic-oracle\u2019s\u00a0upper-bound\u00a0requirement.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0setLiveness\u00a0and\u00a0setRules\u00a0functions have the same sort of lacking input validation as\u00a0setUp\u00a0does.", "body": "The\u00a0setLiveness\u00a0and\u00a0setRules\u00a0functions have the same sort of lacking input validation as\u00a0setUp\u00a0does.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0setliveness\u00a0and\u00a0setrules\u00a0functions-have-the-same-sort-of-lacking-input-validation-as\u00a0setup\u00a0does.", "labels": ["OpenZeppelin"]}, {"title": "Both the\u00a0setUp\u00a0and\u00a0setBond\u00a0functions allow a zero bond, which the\u00a0OptimisticOracle\u00a0will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.", "body": "Both the\u00a0setUp\u00a0and\u00a0setBond\u00a0functions allow a zero bond, which the\u00a0OptimisticOracle\u00a0will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#both-the\u00a0setup\u00a0and\u00a0setbond\u00a0functions-allow-a-zero-bond,-which-the\u00a0optimisticoracle\u00a0will-accept.-however,-because-of-the-overall-lack-of-input-validation,-it-becomes-difficult-to-discern-if-a-zero-bond-is-a-legitimately-acceptable-value-or-simply-an-oversight-of-the-validation-logic.", "labels": ["OpenZeppelin"]}, {"title": "To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.", "body": "To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-avoid-errors-and-unexpected-system-behavior,-consider-implementing-require-statements-to-validate-all-user-controlled-input.-where-zero-values-are-acceptable,-consider-leaving-inline-documentation-to-that-effect-to-avoid-ambiguity.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0661b984edcbab12b7e0ed9f9e9739169cb732c33\u00a0in\u00a0pull request #3915, commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914, commit\u00a055e8f77e748619052b885ce191fee18984a44f29\u00a0in\u00a0pull request #3950\u00a0and commit\u00a0f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe\u00a0in\u00a0pull request #3962.", "body": "Update:\u00a0Fixed as of commit\u00a0661b984edcbab12b7e0ed9f9e9739169cb732c33\u00a0in\u00a0pull request #3915, commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914, commit\u00a055e8f77e748619052b885ce191fee18984a44f29\u00a0in\u00a0pull request #3950\u00a0and commit\u00a0f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe\u00a0in\u00a0pull request #3962.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0661b984edcbab12b7e0ed9f9e9739169cb732c33\u00a0in\u00a0pull-request-#3915,-commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull-request-#3914,-commit\u00a055e8f77e748619052b885ce191fee18984a44f29\u00a0in\u00a0pull-request-#3950\u00a0and-commit\u00a0f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe\u00a0in\u00a0pull-request-#3962.", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0UMIP-152, the documentation of several data structures is significantly different from their implementation in\u00a0OptmisticGovenor.sol.", "body": "In\u00a0UMIP-152, the documentation of several data structures is significantly different from their implementation in\u00a0OptmisticGovenor.sol.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in\u00a0umip-152,-the-documentation-of-several-data-structures-is-significantly-different-from-their-implementation-in\u00a0optmisticgovenor.sol.", "labels": ["OpenZeppelin"]}, {"title": "Differences can be found in the\u00a0Transaction\u00a0and\u00a0Proposal\u00a0structs as well as the data format of\u00a0ancilliaryData.", "body": "Differences can be found in the\u00a0Transaction\u00a0and\u00a0Proposal\u00a0structs as well as the data format of\u00a0ancilliaryData.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#differences-can-be-found-in-the\u00a0transaction\u00a0and\u00a0proposal\u00a0structs-as-well-as-the-data-format-of\u00a0ancilliarydata.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the\u00a0module\u00a0address from\u00a0ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.", "body": "Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the\u00a0module\u00a0address from\u00a0ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-updating-the-documentation-to-correspond-to-the-implementation.-additionally,-in-light-of-the-removal-of-the\u00a0module\u00a0address-from\u00a0ancilliarydata,-consider-adding-further-documentation-to-explain-how-uniqueness-of-a-proposal-identifier-across-all-users-of-the-optimistic-oracle-is-maintained.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0not fixed, UMA\u2019s reply: \u201cwill be fixed in separate PR updating the UMIP after code is finalized\u201d.", "body": "Update:\u00a0not fixed, UMA\u2019s reply: \u201cwill be fixed in separate PR updating the UMIP after code is finalized\u201d.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0not-fixed,-uma\u2019s-reply:-\u201cwill-be-fixed-in-separate-pr-updating-the-umip-after-code-is-finalized\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Low Severity", "body": "Low Severity", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#low-severity", "labels": ["OpenZeppelin"]}, {"title": "Events lacking information", "body": "We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function wou", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#events-lacking-information", "labels": ["OpenZeppelin"]}, {"title": "We identified two events which could benefit from being more complete. Specifically, the\u00a0ProposalDeleted\u00a0and\u00a0TransactionsProposed\u00a0events.", "body": "We identified two events which could benefit from being more complete. Specifically, the\u00a0ProposalDeleted\u00a0and\u00a0TransactionsProposed\u00a0events.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#we-identified-two-events-which-could-benefit-from-being-more-complete.-specifically,-the\u00a0proposaldeleted\u00a0and\u00a0transactionsproposed\u00a0events.", "labels": ["OpenZeppelin"]}, {"title": "Currently,\u00a0ProposalDeleted\u00a0event emissions have an ambiguous interpretation. This is because such emissions can originate from either the\u00a0deleteRejectedProposal\u00a0function or the\u00a0deleteProposal\u00a0function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the\u00a0msg.sender\u00a0when a proposal is deleted.", "body": "Currently,\u00a0ProposalDeleted\u00a0event emissions have an ambiguous interpretation. This is because such emissions can originate from either the\u00a0deleteRejectedProposal\u00a0function or the\u00a0deleteProposal\u00a0function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the\u00a0msg.sender\u00a0when a proposal is deleted.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#currently,\u00a0proposaldeleted\u00a0event-emissions-have-an-ambiguous-interpretation.-this-is-because-such-emissions-can-originate-from-either-the\u00a0deleterejectedproposal\u00a0function-or-the\u00a0deleteproposal\u00a0function-under-different-circumstances.-to-reduce-ambiguity,-consider-augmenting-the-event-so-that-it-also-emits-details-about-the-proposal-status-and-the\u00a0msg.sender\u00a0when-a-proposal-is-deleted.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0TransactionsProposed\u00a0event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.", "body": "The\u00a0TransactionsProposed\u00a0event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0transactionsproposed\u00a0event-currently-emits-the-time-at-which-a-proposal-is-created,-but-it-does-not-emit-the-liveness-time-the-proposal-is-subject-to-or-a-timestamp-that-indicates-when-the-proposal-needs-to-be-disputed-by.-as-this-is-likely-to-be-of-interest-at-the-time-a-proposal-is-created,-consider-emitting-enough-information-to-determine-when-a-proposal-must-be-disputed-by.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0c3ae271a3e9a10dd69fe33ef44417633e53043ec\u00a0in\u00a0pull request #3916.", "body": "Update:\u00a0Fixed as of commit\u00a0c3ae271a3e9a10dd69fe33ef44417633e53043ec\u00a0in\u00a0pull request #3916.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0c3ae271a3e9a10dd69fe33ef44417633e53043ec\u00a0in\u00a0pull-request-#3916.", "labels": ["OpenZeppelin"]}, {"title": "Duplicated code", "body": "There are instances of duplicated code within the codebase.  can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those ass", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.", "body": "There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#there-are-instances-of-duplicated-code-within-the-codebase.-duplicated-code-can-lead-to-issues-later-in-the-development-lifecycle-and-leaves-the-project-more-prone-to-the-introduction-of-errors-later-if-functionality-changes-are-not-replicated-across-all-instances-of-code-that-should-be-identical.", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0OptimisticGovernor\u00a0contract the\u00a0setUp\u00a0function repeats code found in\u00a0several of the\u00a0set*\u00a0\u201csetter\u201d functions.", "body": "Within the\u00a0OptimisticGovernor\u00a0contract the\u00a0setUp\u00a0function repeats code found in\u00a0several of the\u00a0set*\u00a0\u201csetter\u201d functions.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#within-the\u00a0optimisticgovernor\u00a0contract-the\u00a0setup\u00a0function-repeats-code-found-in\u00a0several-of-the\u00a0set*\u00a0\u201csetter\u201d-functions.", "labels": ["OpenZeppelin"]}, {"title": "Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.", "body": "Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#rather-than-duplicating-code,-consider-reusing-existing-functions-as-needed-or-having-just-one-contract-or-library-containing-the-duplicated-code-and-using-it-whenever-the-duplicated-functionality-is-required.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "body": "Update:\u00a0Fixed as of commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull-request-#3914.", "labels": ["OpenZeppelin"]}, {"title": "Misleading inline documentation", "body": "There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide a", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#misleading-inline-documentation", "labels": ["OpenZeppelin"]}, {"title": "There are instances of misleading or imprecise documentation throughout the codebase.", "body": "There are instances of misleading or imprecise documentation throughout the codebase.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#there-are-instances-of-misleading-or-imprecise-documentation-throughout-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "In particular, in\u00a0OptimisticGovernor.sol:", "body": "In particular, in\u00a0OptimisticGovernor.sol:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-particular,-in\u00a0optimisticgovernor.sol:", "labels": ["OpenZeppelin"]}, {"title": "The public\u00a0sync\u00a0function has a comment beneath it that reads, \u201cSync the oracle contract addresses as well as the final fee.\u201d In fact, the function merely makes a call to the internal\u00a0_sync\u00a0function that then sets only the\u00a0optimisticOracle\u00a0address. No other address or final fee value is stored.", "body": "The public\u00a0sync\u00a0function has a comment beneath it that reads, \u201cSync the oracle contract addresses as well as the final fee.\u201d In fact, the function merely makes a call to the internal\u00a0_sync\u00a0function that then sets only the\u00a0optimisticOracle\u00a0address. No other address or final fee value is stored.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-public\u00a0sync\u00a0function-has-a-comment-beneath-it-that-reads,-\u201csync-the-oracle-contract-addresses-as-well-as-the-final-fee.\u201d-in-fact,-the-function-merely-makes-a-call-to-the-internal\u00a0_sync\u00a0function-that-then-sets-only-the\u00a0optimisticoracle\u00a0address.-no-other-address-or-final-fee-value-is-stored.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 69\u00a0the NatSpec states, \u201cBond required (must be at least as large as final fee for collateral type)\u201d. However, there is no comparison made.", "body": "On\u00a0line 69\u00a0the NatSpec states, \u201cBond required (must be at least as large as final fee for collateral type)\u201d. However, there is no comparison made.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-69\u00a0the-natspec-states,-\u201cbond-required-(must-be-at-least-as-large-as-final-fee-for-collateral-type)\u201d.-however,-there-is-no-comparison-made.", "labels": ["OpenZeppelin"]}, {"title": "The NatSpec of the\u00a0_originalTime\u00a0parameter of the\u00a0deleteRejectedProposal\u00a0function is a copy paste error from the line above describing the\u00a0_proposalId\u00a0parameter.", "body": "The NatSpec of the\u00a0_originalTime\u00a0parameter of the\u00a0deleteRejectedProposal\u00a0function is a copy paste error from the line above describing the\u00a0_proposalId\u00a0parameter.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-natspec-of-the\u00a0_originaltime\u00a0parameter-of-the\u00a0deleterejectedproposal\u00a0function-is-a-copy-paste-error-from-the-line-above-describing-the\u00a0_proposalid\u00a0parameter.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 246\u00a0and\u00a0line 279\u00a0there is an inline comment that reads, \u201cThis will revert if the price has not settled\u201d. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.", "body": "On\u00a0line 246\u00a0and\u00a0line 279\u00a0there is an inline comment that reads, \u201cThis will revert if the price has not settled\u201d. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-246\u00a0and\u00a0line-279\u00a0there-is-an-inline-comment-that-reads,-\u201cthis-will-revert-if-the-price-has-not-settled\u201d.-this-is-not-as-nuanced-as-it-could-be.-the-calls-the-comments-refer-to-will-revert-if-the-price-has-not-and-can-not-currently-be-settled;-the-calls-can-actually-settle-the-the-request-if-the-price-has-not-yet-been-settled-but-is-settle-able.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, in\u00a0OptimisticOracle.sol:", "body": "Additionally, in\u00a0OptimisticOracle.sol:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#additionally,-in\u00a0optimisticoracle.sol:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 172\u00a0the comment explains the inequality check that follows as: \u201cThis ensures that the ancillary data is below the OO limit\u201d. In fact, the inequality test that the ancillary data is less than\u00a0or equal to\u00a0the Optimistic Oracle (OO) ancillary data limit.", "body": "On\u00a0line 172\u00a0the comment explains the inequality check that follows as: \u201cThis ensures that the ancillary data is below the OO limit\u201d. In fact, the inequality test that the ancillary data is less than\u00a0or equal to\u00a0the Optimistic Oracle (OO) ancillary data limit.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-172\u00a0the-comment-explains-the-inequality-check-that-follows-as:-\u201cthis-ensures-that-the-ancillary-data-is-below-the-oo-limit\u201d.-in-fact,-the-inequality-test-that-the-ancillary-data-is-less-than\u00a0or-equal-to\u00a0the-optimistic-oracle-(oo)-ancillary-data-limit.", "labels": ["OpenZeppelin"]}, {"title": "Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.", "body": "Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#clear-inline-documentation-is-fundamental-to-outline-the-intentions-of-the-code.-mismatches-between-them-and-the-implementation-can-lead-to-serious-misconceptions-about-how-the-system-is-expected-to-behave.-therefore,-consider-fixing-these-errors-to-avoid-potential-confusion-for-developers,-users,-auditors-alike.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a06a3e00d72832e663f191920a796b5cbe52aea774\u00a0in\u00a0pull request #3917\u00a0and commit\u00a0d1a6421e4331861708a5f5bb7b20072d042d17ff\u00a0in\u00a0pull request #3963.", "body": "Update:\u00a0Fixed as of commit\u00a06a3e00d72832e663f191920a796b5cbe52aea774\u00a0in\u00a0pull request #3917\u00a0and commit\u00a0d1a6421e4331861708a5f5bb7b20072d042d17ff\u00a0in\u00a0pull request #3963.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a06a3e00d72832e663f191920a796b5cbe52aea774\u00a0in\u00a0pull-request-#3917\u00a0and-commit\u00a0d1a6421e4331861708a5f5bb7b20072d042d17ff\u00a0in\u00a0pull-request-#3963.", "labels": ["OpenZeppelin"]}, {"title": "Proposals can be deleted repeatedly", "body": "In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder var", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#proposals-can-be-deleted-repeatedly", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticGovernor\u00a0contract there is no check that a proposal exists before it is deleted with the\u00a0deleteProposal\u00a0function. Similarly, a rejected proposal can be deleted repeatedly via the\u00a0deleteRejectedProposal\u00a0function.", "body": "In the\u00a0OptimisticGovernor\u00a0contract there is no check that a proposal exists before it is deleted with the\u00a0deleteProposal\u00a0function. Similarly, a rejected proposal can be deleted repeatedly via the\u00a0deleteRejectedProposal\u00a0function.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticgovernor\u00a0contract-there-is-no-check-that-a-proposal-exists-before-it-is-deleted-with-the\u00a0deleteproposal\u00a0function.-similarly,-a-rejected-proposal-can-be-deleted-repeatedly-via-the\u00a0deleterejectedproposal\u00a0function.", "labels": ["OpenZeppelin"]}, {"title": "Although there is no clear economic incentive to do delete a proposal numerous times \u2013 in fact it will waste gas \u2013 the repeated emission of identical\u00a0ProposalDeleted\u00a0events could be confusing for parties monitoring for such events.", "body": "Although there is no clear economic incentive to do delete a proposal numerous times \u2013 in fact it will waste gas \u2013 the repeated emission of identical\u00a0ProposalDeleted\u00a0events could be confusing for parties monitoring for such events.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#although-there-is-no-clear-economic-incentive-to-do-delete-a-proposal-numerous-times-\u2013-in-fact-it-will-waste-gas-\u2013-the-repeated-emission-of-identical\u00a0proposaldeleted\u00a0events-could-be-confusing-for-parties-monitoring-for-such-events.", "labels": ["OpenZeppelin"]}, {"title": "Consider allowing proposals to be deleted only if they have not already been deleted.", "body": "Consider allowing proposals to be deleted only if they have not already been deleted.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-allowing-proposals-to-be-deleted-only-if-they-have-not-already-been-deleted.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0deeb7386be6d1f14c8999fe5316c9feb80b5d0d2\u00a0in\u00a0pull request #3918.", "body": "Update:\u00a0Fixed as of commit\u00a0deeb7386be6d1f14c8999fe5316c9feb80b5d0d2\u00a0in\u00a0pull request #3918.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0deeb7386be6d1f14c8999fe5316c9feb80b5d0d2\u00a0in\u00a0pull-request-#3918.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0deleteProposal\u00a0function may not work as expected with all avatars", "body": "The\u00a0deleteProposal\u00a0function may not work as expected with all avatars", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0deleteproposal\u00a0function-may-not-work-as-expected-with-all-avatars", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0deleteProposal\u00a0function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the\u00a0OptimisticGovernor\u00a0contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.", "body": "The\u00a0deleteProposal\u00a0function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the\u00a0OptimisticGovernor\u00a0contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0deleteproposal\u00a0function-allows-the-owner-to-delete-a-particular-proposal-so-that-it-will-not-be-executed.-in-the-current-implementation-of-the\u00a0optimisticgovernor\u00a0contract-the-owner-and-the-avatar-are-the-same-address.-in-general,-an-avatar-does-not-necessarily-have-the-ability-to-send-arbitrary-transactions-without-having-enabled-some-module-specifically-for-this-purpose.", "labels": ["OpenZeppelin"]}, {"title": "If an avatar were to have only the\u00a0OptimisticGovernor\u00a0module enabled, then it could not initiate a transaction in any way other than calling the\u00a0proposeTransactions\u00a0function. However, in this case the\u00a0deleteProposal\u00a0function would not work as expected.", "body": "If an avatar were to have only the\u00a0OptimisticGovernor\u00a0module enabled, then it could not initiate a transaction in any way other than calling the\u00a0proposeTransactions\u00a0function. However, in this case the\u00a0deleteProposal\u00a0function would not work as expected.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-an-avatar-were-to-have-only-the\u00a0optimisticgovernor\u00a0module-enabled,-then-it-could-not-initiate-a-transaction-in-any-way-other-than-calling-the\u00a0proposetransactions\u00a0function.-however,-in-this-case-the\u00a0deleteproposal\u00a0function-would-not-work-as-expected.", "labels": ["OpenZeppelin"]}, {"title": "Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:", "body": "Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-a-scenario-where-an-owner-would-like-to-delete-an-existing-proposal-via-creating-a-new-proposal:", "labels": ["OpenZeppelin"]}, {"title": "If the owner creates a proposal to call\u00a0deleteProposal\u00a0via\u00a0proposeTransactions, then the expiration time of the\u00a0deleteProposal\u00a0proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.", "body": "If the owner creates a proposal to call\u00a0deleteProposal\u00a0via\u00a0proposeTransactions, then the expiration time of the\u00a0deleteProposal\u00a0proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-owner-creates-a-proposal-to-call\u00a0deleteproposal\u00a0via\u00a0proposetransactions,-then-the-expiration-time-of-the\u00a0deleteproposal\u00a0proposal-will-be-greater-than-expire-time-of-the-original-proposal-which-the-owner-wished-to-delete.-thus-the-owner-would-not-be-guaranteed-to-be-able-delete-the-original-proposal-because-it-could-be-executed-before-the-deletion-proposal-passed-the-liveness-threshold.", "labels": ["OpenZeppelin"]}, {"title": "If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal \u201ctechnically\u201d followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.", "body": "If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal \u201ctechnically\u201d followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-owner-wanted-to-dispute-the-proposal-they-were-trying-to-delete,-then-they-could-do-so.-but-the-assumption-that-only-proposals-which-break-the-rules-may-not-alway-hold.-additionally,-if-the-proposal-\u201ctechnically\u201d-followed-the-rules,-but-only-elucidated-how-the-rules-themselves-needed-to-be-updated,-any-such-rule-update-proposal-would-also-run-into-the-same-sort-of-liveness-delay-dilemma.", "labels": ["OpenZeppelin"]}, {"title": "Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an\u00a0OptimisticGovernor\u00a0module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.", "body": "Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an\u00a0OptimisticGovernor\u00a0module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-better-documenting-assumptions-about-the-capabilities-of-the-avatar-and-what-may-happen-if-those-assumptions-do-not-hold.-additionally,-if-having-an-avatar-exclusively-controlled-by-an\u00a0optimisticgovernor\u00a0module-is-a-reasonable-use-case,-then-consider-allowing-some-other-form-of-proposal-deletion-capabilities-that-can-bypass-the-standard-liveness-condition-in-case-of-emergencies.", "labels": ["OpenZeppelin"]}, {"title": "Notes & Additional Information", "body": "Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#notes-&-additional-information", "labels": ["OpenZeppelin"]}, {"title": "Commented out code", "body": "The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the valu", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0proposeTransactions\u00a0and\u00a0executeProposal\u00a0functions in the\u00a0OptimisticGovernor\u00a0contract include commented out lines of code.", "body": "The\u00a0proposeTransactions\u00a0and\u00a0executeProposal\u00a0functions in the\u00a0OptimisticGovernor\u00a0contract include commented out lines of code.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0proposetransactions\u00a0and\u00a0executeproposal\u00a0functions-in-the\u00a0optimisticgovernor\u00a0contract-include-commented-out-lines-of-code.", "labels": ["OpenZeppelin"]}, {"title": "As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.", "body": "As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#as-the-purpose-of-these-lines-is-unclear-and-may-confuse-future-developers-and-external-contributors,-consider-removing-them-from-the-codebase.-if-they-are-meant-to-provide-alternate-implementation-options,-then-consider-extracting-them-to-a-separate-document-where-they-can-be-accompanied-by-a-more-thorough-explanation-of-their-purpose.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3919.", "body": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3919.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull-request-#3919.", "labels": ["OpenZeppelin"]}, {"title": "Coding style deviates from Solidity Style Guide", "body": "Coding style deviates from Solidity Style Guide", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#coding-style-deviates-from-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "OptimisticGovernor\u00a0contract the", "body": "OptimisticGovernor\u00a0contract the", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticgovernor\u00a0contract-the", "labels": ["OpenZeppelin"]}, {"title": "_getOptimisticOracle\u00a0and", "body": "_getOptimisticOracle\u00a0and", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#_getoptimisticoracle\u00a0and", "labels": ["OpenZeppelin"]}, {"title": "_isContract\u00a0functions are declared", "body": "_isContract\u00a0functions are declared", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#_iscontract\u00a0functions-are-declared", "labels": ["OpenZeppelin"]}, {"title": "internal\u00a0functions.", "body": "internal\u00a0functions.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#internal\u00a0functions.", "labels": ["OpenZeppelin"]}, {"title": "This function order deviates from the\u00a0recommended order of: constructor, receive, fallback, external, public, internal, private.", "body": "This function order deviates from the\u00a0recommended order of: constructor, receive, fallback, external, public, internal, private.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#this-function-order-deviates-from-the\u00a0recommended-order-of:-constructor,-receive,-fallback,-external,-public,-internal,-private.", "labels": ["OpenZeppelin"]}, {"title": "To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.", "body": "To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-increase-overall-code-readability,-consider-reordering-these-functions-and-conforming-to-the-solidity-style-guide-where-possible.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3920.", "body": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3920.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull-request-#3920.", "labels": ["OpenZeppelin"]}, {"title": "Disabling reentrancy protection is prone to error", "body": "In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull ", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#disabling-reentrancy-protection-is-prone-to-error", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticOracle\u00a0contract all external functions are protected with a\u00a0nonReentrant\u00a0modifier. However, in designated places the user is allowed to perform a callback into the\u00a0OptimisticOracle\u00a0contract. This is achieved via the functions\u00a0_startReentrantGuardDisabled\u00a0and\u00a0_endReentrantGuardDisabled\u00a0which temporarily disables and manually re-enables reentrancy protection, respectively.", "body": "In the\u00a0OptimisticOracle\u00a0contract all external functions are protected with a\u00a0nonReentrant\u00a0modifier. However, in designated places the user is allowed to perform a callback into the\u00a0OptimisticOracle\u00a0contract. This is achieved via the functions\u00a0_startReentrantGuardDisabled\u00a0and\u00a0_endReentrantGuardDisabled\u00a0which temporarily disables and manually re-enables reentrancy protection, respectively.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticoracle\u00a0contract-all-external-functions-are-protected-with-a\u00a0nonreentrant\u00a0modifier.-however,-in-designated-places-the-user-is-allowed-to-perform-a-callback-into-the\u00a0optimisticoracle\u00a0contract.-this-is-achieved-via-the-functions\u00a0_startreentrantguarddisabled\u00a0and\u00a0_endreentrantguarddisabled\u00a0which-temporarily-disables-and-manually-re-enables-reentrancy-protection,-respectively.", "labels": ["OpenZeppelin"]}, {"title": "These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.", "body": "These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#these-functions-must-be-used-in-pairs-to-perform-as-expected;-that-process-is-manual-and-potentially-error-prone.", "labels": ["OpenZeppelin"]}, {"title": "To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching\u00a0_start\u00a0and\u00a0_end\u00a0functions and for containment within a function that uses a\u00a0nonReentrant\u00a0modifier.", "body": "To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching\u00a0_start\u00a0and\u00a0_end\u00a0functions and for containment within a function that uses a\u00a0nonReentrant\u00a0modifier.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-reduce-the-likelihood-of-error,-consider-including-a-continuous-integration-or-custom-linter-check-for-pairwise-matching\u00a0_start\u00a0and\u00a0_end\u00a0functions-and-for-containment-within-a-function-that-uses-a\u00a0nonreentrant\u00a0modifier.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0acknowledged by UMA: \u201cThis sort of linting would be helpful, but at the moment, it\u2019s unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.\u201d; no immediate code changes are needed.", "body": "Update:\u00a0acknowledged by UMA: \u201cThis sort of linting would be helpful, but at the moment, it\u2019s unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.\u201d; no immediate code changes are needed.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0acknowledged-by-uma:-\u201cthis-sort-of-linting-would-be-helpful,-but-at-the-moment,-it\u2019s-unclear-how-something-like-this-could-be-implemented-without-a-linter-that-can-interpret-solidity-that-also-supports-custom-plugins.\u201d;-no-immediate-code-changes-are-needed.", "labels": ["OpenZeppelin"]}, {"title": "immutable\u00a0value could be used", "body": "immutable\u00a0value could be used", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#immutable\u00a0value-could-be-used", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticGovernor\u00a0contract the\u00a0finder\u00a0variable is only ever\u00a0set in the\u00a0setUp\u00a0initialization function. The value is not modifiable after deployment.", "body": "In the\u00a0OptimisticGovernor\u00a0contract the\u00a0finder\u00a0variable is only ever\u00a0set in the\u00a0setUp\u00a0initialization function. The value is not modifiable after deployment.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticgovernor\u00a0contract-the\u00a0finder\u00a0variable-is-only-ever\u00a0set-in-the\u00a0setup\u00a0initialization-function.-the-value-is-not-modifiable-after-deployment.", "labels": ["OpenZeppelin"]}, {"title": "In practice, the\u00a0finder\u00a0implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their\u00a0finder\u00a0values. Then, if users do wish to migrate to the new\u00a0finder\u00a0address, they will\u00a0need to deploy a new\u00a0OptimisticGovernor\u00a0module anyway.", "body": "In practice, the\u00a0finder\u00a0implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their\u00a0finder\u00a0values. Then, if users do wish to migrate to the new\u00a0finder\u00a0address, they will\u00a0need to deploy a new\u00a0OptimisticGovernor\u00a0module anyway.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-practice,-the\u00a0finder\u00a0implementation-may-generally-be-modified-solely-by-the-uma-team.-only-after-such-an-update-to-the-implementation-would-users-want-to-update-their\u00a0finder\u00a0values.-then,-if-users-do-wish-to-migrate-to-the-new\u00a0finder\u00a0address,-they-will\u00a0need-to-deploy-a-new\u00a0optimisticgovernor\u00a0module-anyway.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a07aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c\u00a0in\u00a0pull request #3921.", "body": "Update:\u00a0Fixed as of commit\u00a07aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c\u00a0in\u00a0pull request #3921.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a07aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c\u00a0in\u00a0pull-request-#3921.", "labels": ["OpenZeppelin"]}, {"title": "Some\u00a0public\u00a0functions could be\u00a0external", "body": "Some\u00a0public\u00a0functions could be\u00a0external", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#some\u00a0public\u00a0functions-could-be\u00a0external", "labels": ["OpenZeppelin"]}, {"title": "setIdentifier\u00a0functions are marked", "body": "setIdentifier\u00a0functions are marked", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setidentifier\u00a0functions-are-marked", "labels": ["OpenZeppelin"]}, {"title": "Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.", "body": "Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-declaring-functions-with-only-the-most-restrictive-visibility-required-to-reduce-the-overall-surface-for-error-and-better-reflect-intent.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a03fdebf2d48263f5ec9a73255853874535141e220\u00a0in\u00a0pull request #3922.", "body": "Update:\u00a0Fixed as of commit\u00a03fdebf2d48263f5ec9a73255853874535141e220\u00a0in\u00a0pull request #3922.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a03fdebf2d48263f5ec9a73255853874535141e220\u00a0in\u00a0pull-request-#3922.", "labels": ["OpenZeppelin"]}, {"title": "Suboptimal\u00a0struct\u00a0packing", "body": "Suboptimal\u00a0struct\u00a0packing", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#suboptimal\u00a0struct\u00a0packing", "labels": ["OpenZeppelin"]}, {"title": "Transaction", "body": "s in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the  and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and sProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The sProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#transaction", "labels": ["OpenZeppelin"]}, {"title": "member labeled\u00a0operation. This member is implicitly of type", "body": "member labeled\u00a0operation. This member is implicitly of type", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#member-labeled\u00a0operation.-this-member-is-implicitly-of-type", "labels": ["OpenZeppelin"]}, {"title": "to\u00a0in order to take advantage of more efficient", "body": "to\u00a0in order to take advantage of more efficient", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to\u00a0in-order-to-take-advantage-of-more-efficient", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0556cd89217c3b96dde2f6dfc394f67a0742e48b3\u00a0in\u00a0pull request #3923.", "body": "Update:\u00a0Fixed as of commit\u00a0556cd89217c3b96dde2f6dfc394f67a0742e48b3\u00a0in\u00a0pull request #3923.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0556cd89217c3b96dde2f6dfc394f67a0742e48b3\u00a0in\u00a0pull-request-#3923.", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typographical errors:", "body": "The codebase contains the following typographical errors:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-codebase-contains-the-following-typographical-errors:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0OptimisticGovernor.sol:", "body": "On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in\u00a0optimisticgovernor.sol:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 37,\u00a0address need to\u00a0should be\u00a0address needs to.", "body": "On\u00a0line 37,\u00a0address need to\u00a0should be\u00a0address needs to.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-37,\u00a0address-need-to\u00a0should-be\u00a0address-needs-to.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 167,\u00a0proposals\u00a0should be\u00a0proposal's.", "body": "On\u00a0line 167,\u00a0proposals\u00a0should be\u00a0proposal's.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-167,\u00a0proposals\u00a0should-be\u00a0proposal's.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 292,\u00a0overriden\u00a0should be\u00a0overridden.", "body": "On\u00a0line 292,\u00a0overriden\u00a0should be\u00a0overridden.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-292,\u00a0overriden\u00a0should-be\u00a0overridden.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve the overall readability of the codebase.", "body": "Consider correcting these typos to improve the overall readability of the codebase.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-correcting-these-typos-to-improve-the-overall-readability-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0745a64aeb0c0b61b214931310d08fbe8ac155f0f\u00a0in\u00a0pull request #3924.", "body": "Update:\u00a0Fixed as of commit\u00a0745a64aeb0c0b61b214931310d08fbe8ac155f0f\u00a0in\u00a0pull request #3924.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0745a64aeb0c0b61b214931310d08fbe8ac155f0f\u00a0in\u00a0pull-request-#3924.", "labels": ["OpenZeppelin"]}, {"title": "Undocumented implicit approval requirements", "body": "In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#undocumented-implicit-approval-requirements", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticGovernor\u00a0contract, the\u00a0proposeTransactions\u00a0function implicitly assumes that it has been granted an appropriate allowance of\u00a0collateral\u00a0tokens from the\u00a0proposer\u00a0when it attempts to\u00a0safeTransferFrom\u00a0the\u00a0totalBond.", "body": "In the\u00a0OptimisticGovernor\u00a0contract, the\u00a0proposeTransactions\u00a0function implicitly assumes that it has been granted an appropriate allowance of\u00a0collateral\u00a0tokens from the\u00a0proposer\u00a0when it attempts to\u00a0safeTransferFrom\u00a0the\u00a0totalBond.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticgovernor\u00a0contract,-the\u00a0proposetransactions\u00a0function-implicitly-assumes-that-it-has-been-granted-an-appropriate-allowance-of\u00a0collateral\u00a0tokens-from-the\u00a0proposer\u00a0when-it-attempts-to\u00a0safetransferfrom\u00a0the\u00a0totalbond.", "labels": ["OpenZeppelin"]}, {"title": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "body": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-favor-of-explicitness-and-to-improve-the-overall-clarity-of-the-codebase,-consider-documenting-all-approval-requirements-in-the-relevant-functions\u2019-inline-documentation.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0c6bdb5e02b57d4f4135feca80d08671725141226\u00a0in\u00a0pull request #3925.", "body": "Update:\u00a0Fixed as of commit\u00a0c6bdb5e02b57d4f4135feca80d08671725141226\u00a0in\u00a0pull request #3925.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0c6bdb5e02b57d4f4135feca80d08671725141226\u00a0in\u00a0pull-request-#3925.", "labels": ["OpenZeppelin"]}, {"title": "Unexplained and unused constants", "body": "Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unexplained-and-unused-constants", "labels": ["OpenZeppelin"]}, {"title": "Throughout the\u00a0OptimisticGovernor\u00a0contract, to check if a proposal has been approved by the Optimistic Oracle the literal value\u00a0int256\u00a01e18\u00a0is used, where\u00a01e18\u00a0signifies that a proposal was not rejected by the Optimistic Oracle.", "body": "Throughout the\u00a0OptimisticGovernor\u00a0contract, to check if a proposal has been approved by the Optimistic Oracle the literal value\u00a0int256\u00a01e18\u00a0is used, where\u00a01e18\u00a0signifies that a proposal was not rejected by the Optimistic Oracle.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#throughout-the\u00a0optimisticgovernor\u00a0contract,-to-check-if-a-proposal-has-been-approved-by-the-optimistic-oracle-the-literal-value\u00a0int256\u00a01e18\u00a0is-used,-where\u00a01e18\u00a0signifies-that-a-proposal-was-not-rejected-by-the-optimistic-oracle.", "labels": ["OpenZeppelin"]}, {"title": "Similarly, in the update to the\u00a0OptimisticOracle\u00a0contract the function\u00a0proposedPrice\u00a0uses a magic value\u00a0type(int256).min\u00a0to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.", "body": "Similarly, in the update to the\u00a0OptimisticOracle\u00a0contract the function\u00a0proposedPrice\u00a0uses a magic value\u00a0type(int256).min\u00a0to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#similarly,-in-the-update-to-the\u00a0optimisticoracle\u00a0contract-the-function\u00a0proposedprice\u00a0uses-a-magic-value\u00a0type(int256).min\u00a0to-indicate-that-an-event-based-proposal-cannot-be-resolved,-because-the-event-has-not-yet-taken-place.", "labels": ["OpenZeppelin"]}, {"title": "Lastly, in the\u00a0OptimisticOracle\u00a0contract the\u00a0MAX_ADDED_ANCILLARY_DATA\u00a0constant is declared on\u00a0line 129. On the\u00a0next line\u00a0the constant should be used, but instead the\u00a0value\u00a0of the constant is used directly to derive another constant.", "body": "Lastly, in the\u00a0OptimisticOracle\u00a0contract the\u00a0MAX_ADDED_ANCILLARY_DATA\u00a0constant is declared on\u00a0line 129. On the\u00a0next line\u00a0the constant should be used, but instead the\u00a0value\u00a0of the constant is used directly to derive another constant.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lastly,-in-the\u00a0optimisticoracle\u00a0contract-the\u00a0max_added_ancillary_data\u00a0constant-is-declared-on\u00a0line-129.-on-the\u00a0next-line\u00a0the-constant-should-be-used,-but-instead-the\u00a0value\u00a0of-the-constant-is-used-directly-to-derive-another-constant.", "labels": ["OpenZeppelin"]}, {"title": "To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.", "body": "To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-improve-the-overall-readability-of-the-codebase-and-to-facilitate-refactoring,-consider-defining-a-constant-for-every-literal-or-magic-value-used,-giving-it-a-clear-and-self-explanatory-name,-and-then-using-it-in-place-of-literal-values.-also-consider-adding-an-inline-comment-explaining-how-literal-values-were-calculated-or-why-they-were-chosen.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0c7babc3d3082200b55901783f4ceabae82df1cea\u00a0in\u00a0pull request #3909.", "body": "Update:\u00a0Fixed as of commit\u00a0c7babc3d3082200b55901783f4ceabae82df1cea\u00a0in\u00a0pull request #3909.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0c7babc3d3082200b55901783f4ceabae82df1cea\u00a0in\u00a0pull-request-#3909.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary cast", "body": "In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unnecessary-cast", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0setUp\u00a0function of the\u00a0OptimisticGovernor\u00a0contract,\u00a0_collateral\u00a0is unnecessarily cast to an\u00a0address\u00a0type.", "body": "In the\u00a0setUp\u00a0function of the\u00a0OptimisticGovernor\u00a0contract,\u00a0_collateral\u00a0is unnecessarily cast to an\u00a0address\u00a0type.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0setup\u00a0function-of-the\u00a0optimisticgovernor\u00a0contract,\u00a0_collateral\u00a0is-unnecessarily-cast-to-an\u00a0address\u00a0type.", "labels": ["OpenZeppelin"]}, {"title": "To improve the overall legibility of the codebase, consider removing this unnecessary cast.", "body": "To improve the overall legibility of the codebase, consider removing this unnecessary cast.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-improve-the-overall-legibility-of-the-codebase,-consider-removing-this-unnecessary-cast.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a02819d071df9a3bbcc8a2d15700d6140ae8e5ad9d\u00a0in\u00a0pull request #3928.", "body": "Update:\u00a0Fixed as of commit\u00a02819d071df9a3bbcc8a2d15700d6140ae8e5ad9d\u00a0in\u00a0pull request #3928.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a02819d071df9a3bbcc8a2d15700d6140ae8e5ad9d\u00a0in\u00a0pull-request-#3928.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary imports", "body": "The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unnecessary-imports", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following unnecessary imports:", "body": "The codebase contains the following unnecessary imports:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-codebase-contains-the-following-unnecessary-imports:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 13\u00a0OptimisticOracle.sol\u00a0is unnecessarily imported.", "body": "On\u00a0line 13\u00a0OptimisticOracle.sol\u00a0is unnecessarily imported.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-13\u00a0optimisticoracle.sol\u00a0is-unnecessarily-imported.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing unnecessary imports to improve code clarity.", "body": "Consider removing unnecessary imports to improve code clarity.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-removing-unnecessary-imports-to-improve-code-clarity.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05833fce724930ba27a01855dcbaf03bcfe7fa7a2\u00a0in\u00a0pull request #3927.", "body": "Update:\u00a0Fixed as of commit\u00a05833fce724930ba27a01855dcbaf03bcfe7fa7a2\u00a0in\u00a0pull request #3927.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a05833fce724930ba27a01855dcbaf03bcfe7fa7a2\u00a0in\u00a0pull-request-#3927.", "labels": ["OpenZeppelin"]}, {"title": "Unused \u201cusing for\u201d directive", "body": "The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unused-\u201cusing-for\u201d-directive", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0OptimisticOracle\u00a0contract includes the directive\u00a0using\u00a0AncillaryData\u00a0for\u00a0bytes, even though none of the library methods are ever used directly on a bytes value.", "body": "The\u00a0OptimisticOracle\u00a0contract includes the directive\u00a0using\u00a0AncillaryData\u00a0for\u00a0bytes, even though none of the library methods are ever used directly on a bytes value.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0optimisticoracle\u00a0contract-includes-the-directive\u00a0using\u00a0ancillarydata\u00a0for\u00a0bytes,-even-though-none-of-the-library-methods-are-ever-used-directly-on-a-bytes-value.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing the directive if it will remain unused.", "body": "Consider removing the directive if it will remain unused.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-removing-the-directive-if-it-will-remain-unused.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a02ee3f4b2affb7049a156c93705d9918ce5c3a670\u00a0in\u00a0pull request #3910.", "body": "Update:\u00a0Fixed as of commit\u00a02ee3f4b2affb7049a156c93705d9918ce5c3a670\u00a0in\u00a0pull request #3910.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a02ee3f4b2affb7049a156c93705d9918ce5c3a670\u00a0in\u00a0pull-request-#3910.", "labels": ["OpenZeppelin"]}, {"title": "Conclusions", "body": "0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#conclusions", "labels": ["OpenZeppelin"]}, {"title": "0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "body": "0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#0-critical-and-0-high-severity-issues-were-found.-some-changes-were-proposed-to-follow-best-practices-and-reduce-the-potential-attack-surface.", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#appendix", "labels": ["OpenZeppelin"]}, {"title": "Severity Levels", "body": "Severity Levels", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#severity-levels", "labels": ["OpenZeppelin"]}, {"title": "The deleteProposal function may not work as expected with all avatars", "body": "The deleteProposal function may not work as expected with all avatars", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-deleteproposal-function-may-not-work-as-expected-with-all-avatars", "labels": ["OpenZeppelin"]}, {"title": "immutable value could be used", "body": "immutable value could be used", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#immutable-value-could-be-used", "labels": ["OpenZeppelin"]}, {"title": "Some public functions could be external", "body": "Some public functions could be external", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#some-public-functions-could-be-external", "labels": ["OpenZeppelin"]}, {"title": "Suboptimal struct packing", "body": "Suboptimal struct packing", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#suboptimal-struct-packing", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "Solidity  Governance  oracle  Thi ecurity aement wa prepared by OpenZeppelin, protecting the open economy.  Table of Content  Table of Content  Summary  Scope  Sytem Overview  Privileged Role  Security Conideration  Finding  Medium Severity  Change of collateral could reult in unintended bond value Lack of event emiion after enitive action Lack of input validation Mimatche between UMIP and implementation  Low Severity  Event lacking information Duplicated code Mileading inline documentation Propoal can be deleted repeatedly The deletePropoal function may not work a expected with all avatar  Note & Additional Information  Commented out code Coding tyle deviate from Solidity Style Guide Diabling reentrancy protection i prone to error immutable value could be ued Some public function could be external Suboptimal truct packing Typographical error Undocumented implicit approval requirement Unexplained and unued contant Unneceary cat Unneceary import Unued uing for directive  Concluion  Appendix  Severity Level  Summary  Governance/Oracle  From 2022-04-25  To 2022-05-10  Solidity  21 (18 reolved)  0 (0 reolved)  0 (0 reolved)  4 (3 reolved)  5 (4 reolved)  12 (11 reolved)  Scope  We audited three eparate et of code, pecifically:  The UMAprotocol/protocol repoitory at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In cope were the following contract:  OptimiticGovernor.ol  The UMAprotocol/protocol repoitory PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In cope were the following contract:  Lockable.ol OptimiticOracle.ol OptimiticOracleInterface.ol  After the initial audit UMA requeted u to audit the UMAprotocol/protocol repoitory PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in cope and audited it.  Sytem Overview  The Optimitic Governor contract i meant to control an avatar that complie with the Gnoi Zodiac framework. The target ue cae i that the avatar i a Gnoi Safe that hold DAO fund and i capable of controlling DAO operation. The Optimitic Governor aim to allow anyone to control DAO fund and activitie a long a their propoed activitie conform to a et of natural language rule that the DAO ha made publicly available. Thi i facilitated via the UMA Optimitic Oracle, which become the final arbiter in cae propoal are conteted for not conforming to DAO rule. In the cae where propoal are not conteted during their livene period, they then become executable by anyone.  The unrelated Optimitic Oracle PR we were aked to review add a mechanim to upend reentrancy guard protection to allow for callback in the body of nonRentrant function (where uch callback would not otherwie be permiable). Additionally, the Oracle wa modified to upport event-baed price requet  that i price requet after ome event in the future occur, rather than at a pecific point in time.  Privileged Role  The Optimitic Governor contract ha only one privileged role, which i that of the contract owner. The owner i able to et the bond amount and bond collateral token required to initiate a propoal. The owner can alo et the rule that propoal mut conform to, et the livene time (window in which a propoal i contetable), and et the identifier ued by the Optimitic Oracle to upport Optimitic Governance propoal. Finally, the owner can delete pecific propoal at any time and can renounce and tranfer ownerhip.  Security Conideration  The UMA team clearly pent time conidering ecurity implication of the Optimitic Governor a evidenced by the UMIP that i required for the Optimitic Oracle to upport thi new ue cae. However, not all ecurity implication are touched on in the UMIP. Some additional conideration follow:  Firt and foremot, the theoretical poibility of corrupting the Optimitic Oracle itelf, by eentially bribing UMA token holder to enrich themelve at the expene of Optimitically Governed DAO() can not be diregarded. The UMA team ha a good undertanding of how to increae the cot of uch corruption, in fact their whitepaper cover the topic at length, but at thi time it i unclear if all of the corruption mitigation mechanim are fully in place and actively enforced. The rik of corruption, a well a any countermeaure in place, need to be well undertood by DAO looking to ue the Optimitic Governor in production.  Additionally, becaue the protocol i o flexible, DAO that ue it need to be fully aware of what the protocol can guarantee and what it cannot. DAO have an immene reponibility not jut for making ure that their rule are a explicit and well-defined a poible, but alo for chooing where to hot uch rule. The protocol allow for rule to be ubmitted a a URI, in which cae the DAO need to conider if thoe rule are immune from being tampered with or are at rik of being taken off line. The flexible nature of the rule argument alo allow rule  or a ubet of rule  to be tored on chain. Thi approach may be worth the aociated cot depending on the individual DAO.  If the avatar i managed by ome mean other than the Optimitic Governor, for intance if ", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#s", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Governance/Oracles  From 2022-04-25  To 2022-05-10  Solidity  21 (18 resolved)  0 (0 resolved)  0 (0 resolved)  4 (3 resolved)  5 (4 resolved)  12 (11 resolved)  Scope  We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was m", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "Governance/Oracles", "body": "Governance/Oracles", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#governance/oracles", "labels": ["OpenZeppelin"]}, {"title": "From 2022-04-25", "body": "From 2022-04-25", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#from-2022-04-25", "labels": ["OpenZeppelin"]}, {"title": "To 2022-05-10", "body": "To 2022-05-10", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-2022-05-10", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "Style Guide Disabling reentrancy protection is prone to error immutable value could be used Some public functions could be external Suboptimal struct packing Typographical errors Undocumented implicit approval requirements Unexplained and unused constants Unnecessary cast Unnecessary imports Unused using for directive  Conclusions  Appendix  Severity Levels  Summary  Governance/Oracles  From 2022-04-25  To 2022-05-10    21 (18 resolved)  0 (0 resolved)  0 (0 resolved)  4 (3 resolved)  5 (4 resolved)  12 (11 resolved)  Scope  We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it ", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "21 (18 resolved)", "body": "21 (18 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#21-(18-resolved)", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "4 (3 resolved)  5 (4 resolved)  12 (11 resolved)  Scope  We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vi", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "4 (3 resolved)", "body": "4 (3 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#4-(3-resolved)", "labels": ["OpenZeppelin"]}, {"title": "5 (4 resolved)", "body": "5 (4 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#5-(4-resolved)", "labels": ["OpenZeppelin"]}, {"title": "12 (11 resolved)", "body": "12 (11 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#12-(11-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Scope", "body": "We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upg", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#scope", "labels": ["OpenZeppelin"]}, {"title": "We audited three separate sets of code, specifically:", "body": "We audited three separate sets of code, specifically:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#we-audited-three-separate-sets-of-code,-specifically:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0UMAprotocol/protocol\u00a0repository at commit\u00a0fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:", "body": "The\u00a0UMAprotocol/protocol\u00a0repository at commit\u00a0fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0umaprotocol/protocol\u00a0repository-at-commit\u00a0fca8e24275e928f7ddf660b5651eb93b87f70afb.in-scope-were-the-following-contracts:", "labels": ["OpenZeppelin"]}, {"title": "OptimisticGovernor.sol", "body": ":  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more t", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticgovernor.sol", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3880\u00a0at commit\u00a0acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:", "body": "The\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3880\u00a0at commit\u00a0acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0umaprotocol/protocol\u00a0repository\u00a0pr-#3880\u00a0at-commit\u00a0acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.in-scope-were-the-following-contracts:", "labels": ["OpenZeppelin"]}, {"title": "Lockable.sol", "body": "Lockable.sol", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lockable.sol", "labels": ["OpenZeppelin"]}, {"title": "OptimisticOracle.sol", "body": ":  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuard", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticoracle.sol", "labels": ["OpenZeppelin"]}, {"title": "OptimisticOracleInterface.sol", "body": "OptimisticOracleInterface.sol", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticoracleinterface.sol", "labels": ["OpenZeppelin"]}, {"title": "After the initial audit UMA requested us to audit the\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3911\u00a0at commit\u00a075bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.", "body": "After the initial audit UMA requested us to audit the\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3911\u00a0at commit\u00a075bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#after-the-initial-audit-uma-requested-us-to-audit-the\u00a0umaprotocol/protocol\u00a0repository\u00a0pr-#3911\u00a0at-commit\u00a075bdffecdae5c3f0c7a7546e65c99b0be02be223.-we-included-pr-in-scope-and-audited-it.", "labels": ["OpenZeppelin"]}, {"title": "System Overview", "body": "The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and inter", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#system-overview", "labels": ["OpenZeppelin"]}, {"title": "The Optimistic Governor contract is meant to control an \u201cavatar\u201d that complies with the\u00a0Gnosis\u2019 Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their \u201cliveness\u201d period, they then become executable by anyone.", "body": "The Optimistic Governor contract is meant to control an \u201cavatar\u201d that complies with the\u00a0Gnosis\u2019 Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their \u201cliveness\u201d period, they then become executable by anyone.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-optimistic-governor-contract-is-meant-to-control-an-\u201cavatar\u201d-that-complies-with-the\u00a0gnosis\u2019-zodiac-framework.-the-target-use-case-is-that-the-avatar-is-a-gnosis-safe-that-holds-dao-funds-and-is-capable-of-controlling-dao-operations.-the-optimistic-governor-aims-to-allow-anyone-to-control-dao-funds-and-activities-as-long-as-their-proposed-activities-conform-to-a-set-of-natural-language-rules-that-the-dao-has-made-publicly-available.-this-is-facilitated-via-the-uma-optimistic-oracle,-which-becomes-the-final-arbiter-in-case-proposals-are-contested-for-not-conforming-to-dao-rules.-in-the-case-where-proposals-are-not-contested-during-their-\u201cliveness\u201d-period,-they-then-become-executable-by-anyone.", "labels": ["OpenZeppelin"]}, {"title": "The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of\u00a0nonRentrant\u00a0functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support \u201cevent-based\u201d price requests \u2013 that is price requests after some event in the future occurs, rather than at a specific point in time.", "body": "The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of\u00a0nonRentrant\u00a0functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support \u201cevent-based\u201d price requests \u2013 that is price requests after some event in the future occurs, rather than at a specific point in time.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-unrelated-optimistic-oracle-pr-we-were-asked-to-review-adds-a-mechanism-to-suspend-reentrancy-guard-protections-to-allow-for-callbacks-in-the-body-of\u00a0nonrentrant\u00a0functions-(where-such-callbacks-would-not-otherwise-be-permissable).-additionally,-the-oracle-was-modified-to-support-\u201cevent-based\u201d-price-requests-\u2013-that-is-price-requests-after-some-event-in-the-future-occurs,-rather-than-at-a-specific-point-in-time.", "labels": ["OpenZeppelin"]}, {"title": "Privileged Roles", "body": "The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than inten", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#privileged-roles", "labels": ["OpenZeppelin"]}, {"title": "The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the \u201cliveness\u201d time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.", "body": "The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the \u201cliveness\u201d time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-optimistic-governor-contract-has-only-one-privileged-role,-which-is-that-of-the-contract-owner.-the-owner-is-able-to-set-the-bond-amount-and-bond-collateral-token-required-to-initiate-a-proposal.-the-owner-can-also-set-the-rules-that-proposals-must-conform-to,-set-the-\u201cliveness\u201d-time-(window-in-which-a-proposal-is-contestable),-and-set-the-identifier-used-by-the-optimistic-oracle-to-support-optimistic-governance-proposals.-finally,-the-owner-can-delete-specific-proposals-at-any-time-and-can-renounce-and-transfer-ownership.", "labels": ["OpenZeppelin"]}, {"title": "Security Considerations", "body": "The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to fa", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#security-considerations", "labels": ["OpenZeppelin"]}, {"title": "The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the\u00a0UMIP that is required\u00a0for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:", "body": "The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the\u00a0UMIP that is required\u00a0for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-uma-team-clearly-spent-time-considering-security-implications-of-the-optimistic-governor-as-evidenced-by-the\u00a0umip-that-is-required\u00a0for-the-optimistic-oracle-to-support-this-new-use-case.-however,-not-all-security-implications-are-touched-on-in-the-umip.-some-additional-considerations-follow:", "labels": ["OpenZeppelin"]}, {"title": "First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.", "body": "First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#first-and-foremost,-the-theoretical-possibility-of-corrupting-the-optimistic-oracle-itself,-by-essentially-bribing-uma-token-holders-to-enrich-themselves-at-the-expense-of-optimistically-governed-dao(s)-can-not-be-disregarded.-the-uma-team-has-a-good-understanding-of-how-to-increase-the-costs-of-such-corruption,-in-fact-their-whitepaper-covers-the-topic-at-length,-but-at-this-time-it-is-unclear-if-all-of-the-corruption-mitigation-mechanisms-are-fully-in-place-and-actively-enforced.-the-risks-of-corruption,-as-well-as-any-countermeasures-in-place,-need-to-be-well-understood-by-daos-looking-to-use-the-optimistic-governor-in-production.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the \u201crule\u201d argument also allows rules \u2013 or a subset of rules \u2013 to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.", "body": "Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the \u201crule\u201d argument also allows rules \u2013 or a subset of rules \u2013 to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#additionally,-because-the-protocol-is-so-flexible,-daos-that-use-it-need-to-be-fully-aware-of-what-the-protocol-can-guarantee-and-what-it-cannot.-daos-have-an-immense-responsibility-not-just-for-making-sure-that-their-rules-are-as-explicit-and-well-defined-as-possible,-but-also-for-choosing-where-to-host-such-rules.-the-protocol-allows-for-rules-to-be-submitted-as-a-uri,-in-which-case-the-dao-needs-to-consider-if-those-rules-are-immune-from-being-tampered-with-or-are-at-risk-of-being-taken-off-line.-the-flexible-nature-of-the-\u201crule\u201d-argument-also-allows-rules-\u2013-or-a-subset-of-rules-\u2013-to-be-stored-on-chain.-this-approach-may-be-worth-the-associated-costs-depending-on-the-individual-dao.", "labels": ["OpenZeppelin"]}, {"title": "If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an \u201cowner\u201d, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.", "body": "If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an \u201cowner\u201d, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-avatar-is-managed-by-some-means-other-than-the-optimistic-governor,-for-instance-if-it-has-an-\u201cowner\u201d,-then-optimistic-governance-can-only-work-as-long-as-the-other-means-of-avatar-management-do-not-interfere.-the-ability-to-outright-delete-proposals-and-modify-parameters-for-making-proposals-can-undermine-the-entire-optimistic-governance-model-depending-on-how-those-permissions-are-managed-independently-of-the-optimistic-governor.", "labels": ["OpenZeppelin"]}, {"title": "On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.", "body": "On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on-the-other-hand,-if-the-optimistic-governor-is-the-sole-means-of-managing-an-avatar,-it-becomes-even-more-essential-that-the-nuances-and-limitations-of-the-model-are-well-understood.-even-ostensibly-rule-abiding-proposals-could-be-dangerous.-if-the-transactions-to-be-executed-as-part-of-a-proposal-involve-upgradeable-contracts,-then-the-code-that-ends-up-being-executed-could-well-be-different-than-that-which-existed-at-the-time-the-proposal-was-made.-savvy-or-malicious-actors-could-frontrun-execution-calls-with-contract-logic-upgrade-calls.-daos-must-be-vigilant-against-this-and-should-consider-how-to-handle-upgradeable-code-explicitly-in-their-rules.", "labels": ["OpenZeppelin"]}, {"title": "Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.", "body": "Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#transactions-could-be-crafted-to-look-safe-or-even-desirable-when-called,-but-then-be-completely-malicious-if-they-are-delegate-called.-which-context-a-call-is-executed-in-comes-down-to-a-simple-uint-flag-attached-to-a-transaction.-daos-using-the-optimistic-oracle-need-to-be-vigilant-against-potential-transaction-phishing-attacks-that-use-the-wrong-context-for-a-call.", "labels": ["OpenZeppelin"]}, {"title": "Finally, the Zodiac framework allows for additional modules, modifiers, and guards \u2013 essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These\u00a0entire\u00a0code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.", "body": "Finally, the Zodiac framework allows for additional modules, modifiers, and guards \u2013 essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These\u00a0entire\u00a0code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#finally,-the-zodiac-framework-allows-for-additional-modules,-modifiers,-and-guards-\u2013-essentially-smart-contract-middleware-that-can-sit-between-eoa-interactions-with-the-optimistic-governor-and-interactions-with-the-avatar.-these\u00a0entire\u00a0code-chains-must-be-well-understood-as-they-could-potentially-modify-the-final-behavior-of-the-avatar-in-ways-that-inspection-of-proposals-and-of-the-optimistic-governor-on-its-own-cannot-anticipate.", "labels": ["OpenZeppelin"]}, {"title": "Findings", "body": "Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#findings", "labels": ["OpenZeppelin"]}, {"title": "Here we present our findings.", "body": "Here we present our findings.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#here-we-present-our-findings.", "labels": ["OpenZeppelin"]}, {"title": "Medium Severity", "body": "Medium Severity", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#medium-severity", "labels": ["OpenZeppelin"]}, {"title": "Locked assets in contracts", "body": "Once the protocol is deployed, the Comet and Bulker contracts will be two important pieces of the system. Comet is the main protocol contract while the Bulker is a useful tool to execute multiple protocol calls into one single transaction.  delegation toward the  receive payable function to accept ETH which is needed to be used in the  docstrings. In this case, any ETH sent through the  withdrawEthTo function. This function unwraps WETH by sending tokens to the WETH contract and receiving back ETH in the same amount in the  Lastly, a separate reference must also be done on ERC20 tokens. The Comet contract has the approveThis function which is enough to let a manager move any ERC20 funds that might get lost in the Comet balance. However, this is not the case for the Bulker contract, where ERC20 tokens might also get lost.  Consider establishing mechanisms to avoid such scenarios, as it results in a direct loss of user funds.  Update: Partially fixed in commit 3681613. In the words of the team: We think its a good idea to add sweep functions to the Bulker to prevent funds from being locked in there. As for Comet, we purposely made the receive function payable in case we ever wanted to support a payable function in CometExt. Doing so allows us to add a payable function to CometExt without having to also upgrade Comet. Since Comet is upgradeable, I dont think we need to support a way to sweep ETH out of the contract right off the bat.  Medium Severity  governor can approve anyone to transfer the base and collateral assets within the Comet contract  The COMP token, the governance module (GovernorBravo) and the Timelock are the three components that make up Compound governance, allowing for the management and upgrade of the protocol.  Comet implementation, there is a variable called  approveThis that only the governor can execute and it approves anyone to transfer the base and collateral assets outside the  Beanstalk and  Curve cases), user funds could be at risk.  If the function is meant to be used for specific purposes and cant be removed, consider properly documenting this risk and establish verification measures on governance proposals to avoid misuse of this feature. To reduce the possibilities of a governance attack, be sure to always rely on a delay mechanism for proposals to be executed and eventually a pause guardian that can take action if a malicious proposal is spotted.  Update: Fixed. The team has improved the docstrings in PR#414. In the words of the team: The main intention for approveThis is to allow governance to transfer out any ERC20s accidentally sent to Comet. We do recognize the ability for governance to give approval for the base and collateral assets and transfer out user funds. However, as OpenZeppelin has noted, this will likely require a governance attack. Wed like to point out that in the case of a governance attack, the attacker would not even need approveThis to steal user funds as they could upgrade the implementation of Comet to whatever they please.  The protocol may end up holding collateral assets in an unwanted manner  The Comet contract has an immutable value that defines the target amount of reserves of the base token. This value is closely related to the buyCollateral function. This function cannot be called successful if the protocol reserves are greater than or equal to this target.  If targetReserves is set to a small value, the contract could easily reach the level. The problem is that the absorptions can continue but the protocol will not be able to sell the collateral because the buyCollateral function cannot be used and the protocol could be in a situation where it would hold assets that may lose value over time.  In the opposite case, where targetReserves is set to a large value, the chance of reaching this level would be much lower so it could be a useless constraint.  Keeping in mind that setting this variable to a small value is more of a problem, be sure to set it to a large value. Also if the value of the target is too high to not have a useful or practical use, consider re-design the system to not make use of it.  Update: Acknowledged. In the words of the team: We intend for targetReserves to be a pretty large value so the protocol can use liquidations to build up a sizable reserve. Once reserves have reached targetReserves, we believe it may be advantageous for the protocol to start HODLing the collateral assets. Weve run backtesting simulations to identify this as the best strategy for the protocol to build up reserves, but this strategy can definitely change as we conduct more research around liquidation auction strategies.  Incorrect accounting of used gas  The asborbInternal function of the Comet contract contains important logic of the protocol where users that are liquidatable have their debts absorbed by the protocol. To do this task frequently and maintain health in the system, users will call this function whenever they detect a liquidatable user pos", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#locked-assets-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "governor can approve anyone to transfer the base and collateral assets within the Comet contract", "body": "governor can approve anyone to transfer the base and collateral assets within the Comet contract", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#governor-can-approve-anyone-to-transfer-the-base-and-collateral-assets-within-the-comet-contract", "labels": ["OpenZeppelin"]}, {"title": "The protocol may end up holding collateral assets in an unwanted manner", "body": "The Comet contract has an immutable value that defines the target amount of reserves of the base token. This value is closely related to the buyCollateral function. This function cannot be called successful if the protocol reserves are greater than or equal to this target.  If targetReserves is set to a small value, the contract could easily reach the level. The problem is that the absorptions can continue but the protocol will not be able to sell the collateral because the buyCollateral function cannot be used and the protocol could be in a situation where it would hold assets that may lose value over time.  In the opposite case, where targetReserves is set to a large value, the chance of reaching this level would be much lower so it could be a useless constraint.  Keeping in mind that setting this variable to a small value is more of a problem, be sure to set it to a large value. Also if the value of the target is too high to not have a useful or practical use, consider re-design the system to not make use of it.  Update: Acknowledged. In the words of the team: We intend for targetReserves to be a pretty large value so the protocol can use liquidations to build up a sizable reserve. Once reserves have reached targetReserves, we believe it may be advantageous for the protocol to start HODLing the collateral assets. Weve run backtesting simulations to identify this as the best strategy for the protocol to build up reserves, but this strategy can definitely change as we conduct more research around liquidation auction strategies.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#the-protocol-may-end-up-holding-collateral-assets-in-an-unwanted-manner", "labels": ["OpenZeppelin"]}, {"title": "Incorrect accounting of used gas", "body": "The asborbInternal function of the Comet contract contains important logic of the protocol where users that are liquidatable have their debts absorbed by the protocol. To do this task frequently and maintain health in the system, users will call this function whenever they detect a liquidatable user position.  As a reward for doing this task recurrently, absorbers (users calling the absorb function) are accounted for their gas expenditure into liquidation points, with the promise of redeeming those points for reward tokens in a separate contract.  The reward mechanism for the liquidation points is out of the scope for the current audit so we cant assess the incentives alignments in performing this task with profitable rewards.  However, how the gas used is measured doesnt reflect entirely the actual transaction cost for the user. In particular:  The priority fee is not taken into account. Absorbers will probably have to compete with each other and be as fast as possible in running absorbs. For this is likely to have a priority fee set as a miners tip in the transaction. Currently, the protocol only uses block.basefee but tx.gasprice = block.basefee + priority fee should be used instead.  Other operations are performed after the gas spent is measured, consuming more gas which is not taken into account.  Potentially, a user could deposit a minimum amount of each of the collateral assets supported by the protocol to increase the cost of the transaction, since it implies iteration over all supported assets recursively. Doing so, the rewards increase proportionally to the cost and it might be used maliciously by an underwater account since they might absorb their own position to earn rewards and potentially reduce damage from the liquidation.  Consider taking these suggestions into account and changing the way the gas used is measured to improve transparency and design correctness.  Update: Acknowledged. The team has improved docstrings in commit 14fbc27.  Low Severity", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#incorrect-accounting-of-used-gas", "labels": ["OpenZeppelin"]}, {"title": "Everyone can deploy new Comet instances", "body": "Each Comet contract implementation that the protocol might decide to create is meant to be deployed in the Configurator contract.  This contract is an intermediate logic to bootstrap the entire protocol configuration and then apply it to a newly deployed Comet contract.  To do this, the Configurator makes use of a CometFactory contract which has a clone function whose sole role is to create a new Comet contract and return its address.  Whenever all protocol parameters are set, the deploy function in the Configurator contract is called. This function calls the clone function in the factory and emits an event to signal that a new Comet is ready with the configuration set so far.  The deploy and clone functions are both public callable functions, so anyone can, at any moment, generate the Comet instance either in the factory, passing arbitrary configurations, or either through the Configurator with the configuration set until that moment.  Is not clear why those functions are public as there is no benefit for users to call them. Moreover, leaving open the door for anyone to deploy instances of Comet with arbitrary configuration or emitting arbitrary events through the Configurator is a concern to take into account as it might be misused by malicious actors trying to create pishing-like attacks.  Consider restricting access to those functions and let them be called only by the governor or consider properly documenting such a design decision, raising awareness over the way it might be misused.  Update: Not fixed. The team acknowledge the issue and in their words: We considered making Configurator.deploy() a governor-only function, however it would require adding a storage slot and complicating the Configurator which does not seem worth the tradeoff. It also doesnt make sense to change CometFactory.clone() to be governor-only as the CometFactory is a stateless contract. We note for future reference that there isnt a great way to get a list of official Comet instances from on-chain, however the canonical repository does have a list (roots.json) for each chain, which seems sufficient until a better solution is established.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#everyone-can-deploy-new-comet-instances", "labels": ["OpenZeppelin"]}, {"title": "Gas inefficiencies", "body": "There are many places throughout the codebase where changes can be made to improve gas consumption. For example:  The for loops inside absorb and invoke functions do not cache the length of the array and perform unnecessary operations on each iteration.  The unchecked blocks for loop counters are not used consistently throughout the codebase. It is only used in the Invoke function, although it could be implemented in loops of the rest of the protocol contracts.  updateBasePrincipal in Comet should not check principal = 0 because in that case nothing will happen and gas will be wasted.  It is advisable that if a variable from the contracts storage is going to be read within a function several times, a copy in memory should first be created since reading to the storage directly is expensive. However, if you are only querying for the value once, as in accrueInternal and Comets fallback, it is recommended to read directly from storage without any intermediate steps.  In transferCollateral within the Comet contract, it is recommended to consult with getAssetInfoByAddress at the beginning of the function so that in case the token passed by the parameters is not within the collaterals of the protocol, the function fails early and without wasting gas unnecessarily.  Use unchecked { ++i; } over unchecked { i++; }.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Partially fixed in commit 90ca4d0.  Inconvenient use of immutable keyword  For accounts that use the protocol, the protocol provides a built-in system for tracking rewards. Comet contracts keep account of all accrued incentives for suppliers and borrowers of the base token, and users can claim them on CometRewards contract. It should be emphasized that all rewards from all the Comets from the same chain are claimed in the same CometRewards contract.  The latter has a governor variable defined which is the role that can set the reward settings and withdraw rewards from the contract. Since the contract does not have an upgradeability mechanism, it is inconvenient to define this variable as immutable. If the governor needs to be changed, a new contract must be deployed and the old contracts state must be migrated to the new one.  Consider adding this variable to the contract storage and specifying a setter function so that the governor can be changed any time it is needed.  Update: Fixed in commits 43b5502 and 4d1c1a4.  Logic contracts initialization allowed  The Configurator contract has an initializable function that is meant to be called by the proxy. However, nothing prevents users from directly calling the initialize function on the contract implementation. If someone does so, the state of the implementation would be initialized to some meaningful value.  We suggest adding a constructor that sets the version to an incredibly high number so that any attempt to call the implementation at the initialize function would revert with an AlreadyInitialized error or even a specific one to signal that initializing the implementation is prohibited.  Leaving an implementation contract not initialized is generally an insecure pattern to follow. In this case, it might lead to a situation where an attacker can take control over the implementation contract by passing himself as governor and try to mislead users toward malicious contracts. This is not a security issue on its own but we strongly suggest avoiding such scenarios in all implementation contracts.  As a source of inspiration, here theres an example of how the scenario can be avoided in general situations.  Update: Fixed in commit 79f59e5.  Missing validations  There are some places in the code base that might benefit from some sanity checks on the input provided:  The transferGovernor and setGovernor functions of the Configurator are not checking the address to be non-zero.  The CometRewards constructor is missing the same check over the address parameter.  In line 260 of the Comet contract, the priceFeed is set but is not checked to retrieve a valid price.  withdrawAndBorrowAmount and repayAndSupplyAmount functions assume certain values over the newPrincipal but those should be required instead.  To reduce possible errors and make the code more rodust, consider adding sanity checks where needed.  Update: Partially fixed in PR 455, merged commit bf20ccf. withdrawAndBorrowAmount and repayAndSupplyAmount have new validations but the rest of the items will not be fixed. In the words of the team: There are arbitrarily many bad addresses which can be set, checking for the zero address seems like added complexity for little gain. In addition, while further checks in Comet.sol could be added, the contract is being optimized for efficiency and is up against a size limit, so we favor the current approach.  Potential function", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "Inconvenient use of immutable keyword", "body": "Inconvenient use of immutable keyword", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#inconvenient-use-of-immutable-keyword", "labels": ["OpenZeppelin"]}, {"title": "Logic contracts initialization allowed", "body": "The Configurator contract has an initializable function that is meant to be called by the proxy. However, nothing prevents users from directly calling the initialize function on the contract implementation. If someone does so, the state of the implementation would be initialized to some meaningful value.  We suggest adding a constructor that sets the version to an incredibly high number so that any attempt to call the implementation at the initialize function would revert with an AlreadyInitialized error or even a specific one to signal that initializing the implementation is prohibited.  Leaving an implementation contract not initialized is generally an insecure pattern to follow. In this case, it might lead to a situation where an attacker can take control over the implementation contract by passing himself as governor and try to mislead users toward malicious contracts. This is not a security issue on its own but we strongly suggest avoiding such scenarios in all implementation contracts.  As a source of inspiration, here theres an example of how the scenario can be avoided in general situations.  Update: Fixed in commit 79f59e5.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#logic-contracts-initialization-allowed", "labels": ["OpenZeppelin"]}, {"title": "Missing validations", "body": "There are some places in the code base that might benefit from some sanity checks on the input provided:  The transferGovernor and setGovernor functions of the Configurator are not checking the address to be non-zero.  The CometRewards constructor is missing the same check over the address parameter.  In line 260 of the Comet contract, the priceFeed is set but is not checked to retrieve a valid price.  withdrawAndBorrowAmount and repayAndSupplyAmount functions assume certain values over the newPrincipal but those should be required instead.  To reduce possible errors and make the code more rodust, consider adding sanity checks where needed.  Update: Partially fixed in PR 455, merged commit bf20ccf. withdrawAndBorrowAmount and repayAndSupplyAmount have new validations but the rest of the items will not be fixed. In the words of the team: There are arbitrarily many bad addresses which can be set, checking for the zero address seems like added complexity for little gain. In addition, while further checks in Comet.sol could be added, the contract is being optimized for efficiency and is up against a size limit, so we favor the current approach.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#missing-validations", "labels": ["OpenZeppelin"]}, {"title": "Potential function clashes", "body": "The TransparentUpgradeableConfiguratorProxy overrides the _beforeCallback function.  Concretely, the _beforeCallback function is implemented in the TransparentUpgradeableProxy contract to avoid the admin of the contract to call the implementation logic directly.  deployAndUpgrade function of the  This is not a security issue on its own but it opens the door for potential clashes to happen. If one function is added either on the proxy or the logic contract, this can clash with any of the other contract functions. At this point, the admin will stop to be able to call the implementation contract (users will still be directed toward the implementation because of the ifAdmin modifier).  This article specifies how crafting clashes may not be too hard of a computational task. This article showcases how a new function in the proxy might actually enable clashes.  To avoid any unwanted behaviors, consider ensuring that the upgrade mechanism for Configurator always checks for potential clashes between the logic implementation and the proxy, especially if new functions are added.  Update: Fixed. The team added an off-chain check to avoid collisions in PR#430. Also, the team acknowledges the issue providing the following comments: The two types of clashes that can happen are:  New function on proxy is introduced that clashes with an existing function in the Configurator. Admin is no longer able to call the function on the Configurator. To recover: The admin should still be able to upgrade the implementation of the proxy because that function lives on the proxy. Governance can simply introduce a new version of Configurator without the clash and upgrade the proxy to this new implementation.  New function on Configurator is introduced that clashes with an existing function on the proxy. Admin cannot call this new Configurator function.To recover: Same recovery path as above. Function clashes only prevent the admin from calling a function on the Configurator, so the admin is still able to call the upgrade function on the proxy itself.  In either case, the contracts are in a recoverable state and nothing malicious can happen unless the admin is malicious.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#potential-function-clashes", "labels": ["OpenZeppelin"]}, {"title": "Underwater accounts can minimize losses", "body": "In the Comet contract, during an absorbeInternal call, the updateBasePrincipal function is called, updating the accrued interests on the liquidated user position.  If the seizing of collateral brought the new users balance to positive values the user will:  Have his excess collateral exchanged for the base asset (during an absorb this might be beneficial if the collateral price is crashing).  Have supply interest and tracking indexes accrued straight away after the absorb, over the excess collateral converted into the base asset. Concretely, the accrueInternal will update interest rates and the updateBasePrincipal will update the tracking indexes.  Moreover, an underwater can decide to even liquidate himself, earning additional liquidation points.  Consider the extra value that an underwater can extract from his position to determine if this can be leveraged to create some attacks. If those are intended behaviors, consider improving the docstrings around the absorption mechanism to reflect these details.  Update: Acknowledged. In the words of the team: It sounds like the concern is that a user might absorb themselves for liquidator points and to sell off their collateral to the protocol quickly during a market downturn. In that case, its the purpose of the collateral factor to ensure a buffer in which the account becomes liquidatable and is still profitable to the protocol to liquidate. If a user chooses to absorb themselves it would economically imply governance has somehow created an absorption incentive greater than the liquidation penalty.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#underwater-accounts-can-minimize-losses", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary complexity", "body": "The Comet contract delegates some feature implementations into the CometExt contract. This contract is meant to be an actual extension of Comet logic and implement some functions and parameters, including the version parameter.  At the same time, Comet is built through an upgradeable proxy pattern that requires a new Comet version to be deployed and the proxy pointed toward the new implementation.  During an upgrade, it is convenient to upgrade the version number to a greater value and to do so the protocol must deploy also a new CometExt implementation contract to indicate a new version.  This is because the version parameter is declared as constant and cant be changed as a result of an upgrade mechanism without actually changing it in the contracts code.  In the worst-case scenario, an error is performed in the upgrade mechanism, the version number is not incremented and potential systems integrated with the protocol might depend on that version number to establish some other logic.  To avoid deploying a new CometExt even if its implementation didnt change, consider moving the version parameter into the Comet contract code.  Eventually consider keeping version in both contracts to differentiate between them, as both contracts might require some implementation changes.  Update: Acknowledged. In the words of the team: The version in CometExt is meant specifically as part of the EIP712Domain of the contract. Only changes which affect this domain should be reflected in this version. Furthermore the logic relating to the domain is currently isolated to the extension contract, which is useful because it reduces the main contract size, and the size of the main factory.  Notes & Additional Information  Anyone can set baseTrackingIndex  In the Comet contract, the accrueAccount function is publicly callable and it accrues interest rates and updates tracking indexes on the account specified as the input parameter.  Specifically, the tracking indexes are updated in the updateBasePrincipal function where if newPrincipal >= 0 then the baseTrackingIndex is set to a meaningful value.  So anyone is able to set this value for accounts that do not even exist on the protocol. Even if it is not a security issue on its own, consider restricting this function to users that have a principal strictly greater than zero.  Update: Not fixed. However, the team added a unit test in commit d4abcb2 to check that it doesnt affect the protocol.  Inconsistent coding style  Inconsistencies in coding style were identified throughout the code base. Some examples are:  constants variables version and name and not in UPPER_CASE like other constant variables  The convention of functions named with the _ prefix is not clear. Sometimes it is used for admin functions and other times for internal functions  Some structs use _reserved to fill slots, but others do not.  It is not clear what convention is used for the naming of codebase interfaces. Sometimes the letter I is used as a prefix, sometimes the word Interface at the end or in some cases the contract even misses both.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.  Update: Partially fixed. Only the second item has been fixed in commit c04c056.  CometMath is not used consistently  Many functions that could be in CometMath, a utility contract that contains pure mathematical functions, are scattered throughout the codebase and min, one of the functions within the contract, is not being used.  Consider consolidating all the helper math functions in one place and removing unused ones.  Update: Partially fixed in commit 16d213f. The min function has been removed.  Compilation warnings  While compiling the codebase contracts. The compiler raises some warnings. Specifically:  The totalSupply and totalBorrow variables of the getUtilization and of the getReserves functions have the same name as the totalSupply and totalBorrow public functions.  The withdrawAndBorrowAmount function visibility can be restricted to pure.  Consider resolving all compiler warnings.  Update: Fixed in commit 9e2b195.  Incorrect or missing docstrings  Across the codebase, some contracts lack proper documentation and docstrings. In particular, the IWETH9 and CometMath functions or the CometConfiguration and CometStorage variables are having little comments or nothing at all.  Consider thoroughly documenting all functions and parameters that are part of the contracts public API. Functions or parameters implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  have no setters but it doesnt specify where those are set, eventually in the  passed as input in the Configurator initialization.  Consider writing this in the docstrings of the initialize functi", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#unnecessary-complexity", "labels": ["OpenZeppelin"]}, {"title": "Anyone can set baseTrackingIndex", "body": "Anyone can set baseTrackingIndex", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#anyone-can-set-basetrackingindex", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent coding style", "body": "Inconsistencies in coding style were identified throughout the code base. Some examples are:  constants variables version and name and not in UPPER_CASE like other constant variables  The convention of functions named with the _ prefix is not clear. Sometimes it is used for admin functions and other times for internal functions  Some structs use _reserved to fill slots, but others do not.  It is not clear what convention is used for the naming of codebase interfaces. Sometimes the letter I is used as a prefix, sometimes the word Interface at the end or in some cases the contract even misses both.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.  Update: Partially fixed. Only the second item has been fixed in commit c04c056.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "CometMath is not used consistently", "body": "Many functions that could be in CometMath, a utility contract that contains pure mathematical functions, are scattered throughout the codebase and min, one of the functions within the contract, is not being used.  Consider consolidating all the helper math functions in one place and removing unused ones.  Update: Partially fixed in commit 16d213f. The min function has been removed.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#cometmath-is-not-used-consistently", "labels": ["OpenZeppelin"]}, {"title": "Compilation warnings", "body": "While compiling the codebase contracts. The compiler raises some warnings. Specifically:  The totalSupply and totalBorrow variables of the getUtilization and of the getReserves functions have the same name as the totalSupply and totalBorrow public functions.  The withdrawAndBorrowAmount function visibility can be restricted to pure.  Consider resolving all compiler warnings.  Update: Fixed in commit 9e2b195.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#compilation-warnings", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or missing docstrings", "body": "Across the codebase, some contracts lack proper documentation and docstrings. In particular, the IWETH9 and CometMath functions or the CometConfiguration and CometStorage variables are having little comments or nothing at all.  Consider thoroughly documenting all functions and parameters that are part of the contracts public API. Functions or parameters implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  have no setters but it doesnt specify where those are set, eventually in the  passed as input in the Configurator initialization.  Consider writing this in the docstrings of the initialize function to improve clarity.  Update: Partially fixed in commit 9227075. Docstring was only changed in the Configurator contract.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#incorrect-or-missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "The CometDeployed, GovernorTransferred, SetFactory, SetGovernor, SetPauseGuardian, SetBaseTokenPriceFeed, SetExtensionsDelegate events lack of any indexed parameter.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Fixed in commit 7124b98.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Contracts folder is not properly organized", "body": "There is no convenient structure in the contracts folder to easily navigate between them. All contracts, regardless of their type or module they belong to, are mixed in a single folder.  To favor the developer experience and the maintenance of the codebase, consider adding additional folders following the structure within the vendor directory or separating protocol components into different internal folders.  Update: Acknowledged. In the words of the team: The code actually is logically organized in that the protocol code sits at the top-level, with test and vendored contracts being secondary and sitting in subdirectories. In the future, the team might reorganize into subdirectories but not at this time.  rewardsClaimed can be mixed between different tokens  In CometRewards it is possible to change the reward token of each Comet through _setRewardConfig. However, if the reward token is changed, the number of previous reward tokens claimed will persist and once someone claims their new reward asset, it will be added to rewardsClaimed despite being different assets.  Consider removing the ability to change the reward asset once set or changing the way the claimed rewards are stored if the reward asset changes.  Update: Fixed in commit ced8026.  Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Here are some examples:  The name CometProxyAdmin suggests that it is only the admin of the Comet proxy, but in reality, it will also have the same role on the Configurator proxy. Choose another name to avoid confusion.  TransparentUpgradeableConfiguratorProxy can be called ConfiguratorProxy. There is no need to use the inherited contract name as a prefix.  In CometMath, change InvalidUInt to InvalidUint and toUInt to toUint.  rescale and descale have different names but the same value, consider using one variable name scale.  Update: Partially fixed in commit b5a64d0.  Use of Global imports  Non-explicit imports are used throughout all protocol contracts, which reduces code readability and could lead to conflicts between names defined locally and the ones imported.  The inheritance chains within the protocol are long, and for this, the codebase would benefit from refactoring specifically which definitions are being imported in each contract.  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged. In the words of the team: We do not consider this important or worth the effort of refactoring at this time.  Potential front-run  The deployAndUpgrade function of the CometProxyAdmin is restricted in access to be called exclusively by the governance. It deploys a new Comet instance through the Configurator and upgrades the implementation address in the proxy.  However, it doesnt call the initializeStorage function of the Comet contract through the proxy, leaving the new implementation not initialized. The function doesnt take any input parameter and it is meant to be called only once without the need to call it again on new implementation upgrades.  Whether the first initialization is performed on a separate transaction or if in the future it will be possible to re-initialize the Comet instance with some input values, any user can front-run any governance attempt to initialize the new deployed Comet.  Consider taking into account that deployAndUpgrade and initializeStorage should be done in one unique transaction to avoid the front-run scenario, especially if input parameters or re-initializations are meant to happen in future developments.  Update: Acknowledged. The team added a scenario in PR#431 to test the governance flow for upgrading to a new version of Comet and calling its initialize function via one proposal.  Potential reentrancies  In the codebase, we found two places where reentrancy can occur. However, those do not pose any security issue or concern but awareness should be raised:  The invoke function of the Bulker contract can be re-entered.  The doTransferIn function of the Comet contract is often executed at the very beginning of executions, being it an anti-pattern to follow against reentrancy. Even if re-entering the same doTransferIn cant be used as vector attack in this case, one can re-enter a different function, modifying the state in an unexpected manner. Making external calls is always suggested to be done after checks and effects.  To improve clarity, consider either reducing the attack surface by making those functions non-reentrant or document and raise awarness on such scenarios.  Update: Acknowledged. The team understands the concerns and replies: Specific concerns due to reentrancies should be addressed with tests, static analysis or formal verification or code changes. Excessive documentation notes about universal theoretical concerns dont likely add much except make the documentation harder ", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#contracts-folder-is-not-properly-organized", "labels": ["OpenZeppelin"]}, {"title": "rewardsClaimed can be mixed between different tokens", "body": "rewardsClaimed can be mixed between different tokens", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#rewardsclaimed-can-be-mixed-between-different-tokens", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Here are some examples:  The name CometProxyAdmin suggests that it is only the admin of the Comet proxy, but in reality, it will also have the same role on the Configurator proxy. Choose another name to avoid confusion.  TransparentUpgradeableConfiguratorProxy can be called ConfiguratorProxy. There is no need to use the inherited contract name as a prefix.  In CometMath, change InvalidUInt to InvalidUint and toUInt to toUint.  rescale and descale have different names but the same value, consider using one variable name scale.  Update: Partially fixed in commit b5a64d0.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "Use of Global imports", "body": "Non-explicit imports are used throughout all protocol contracts, which reduces code readability and could lead to conflicts between names defined locally and the ones imported.  The inheritance chains within the protocol are long, and for this, the codebase would benefit from refactoring specifically which definitions are being imported in each contract.  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged. In the words of the team: We do not consider this important or worth the effort of refactoring at this time.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#use-of-global-imports", "labels": ["OpenZeppelin"]}, {"title": "Potential front-run", "body": "The deployAndUpgrade function of the CometProxyAdmin is restricted in access to be called exclusively by the governance. It deploys a new Comet instance through the Configurator and upgrades the implementation address in the proxy.  However, it doesnt call the initializeStorage function of the Comet contract through the proxy, leaving the new implementation not initialized. The function doesnt take any input parameter and it is meant to be called only once without the need to call it again on new implementation upgrades.  Whether the first initialization is performed on a separate transaction or if in the future it will be possible to re-initialize the Comet instance with some input values, any user can front-run any governance attempt to initialize the new deployed Comet.  Consider taking into account that deployAndUpgrade and initializeStorage should be done in one unique transaction to avoid the front-run scenario, especially if input parameters or re-initializations are meant to happen in future developments.  Update: Acknowledged. The team added a scenario in PR#431 to test the governance flow for upgrading to a new version of Comet and calling its initialize function via one proposal.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#potential-front-run", "labels": ["OpenZeppelin"]}, {"title": "Potential reentrancies", "body": "In the codebase, we found two places where reentrancy can occur. However, those do not pose any security issue or concern but awareness should be raised:  The invoke function of the Bulker contract can be re-entered.  The doTransferIn function of the Comet contract is often executed at the very beginning of executions, being it an anti-pattern to follow against reentrancy. Even if re-entering the same doTransferIn cant be used as vector attack in this case, one can re-enter a different function, modifying the state in an unexpected manner. Making external calls is always suggested to be done after checks and effects.  To improve clarity, consider either reducing the attack surface by making those functions non-reentrant or document and raise awarness on such scenarios.  Update: Acknowledged. The team understands the concerns and replies: Specific concerns due to reentrancies should be addressed with tests, static analysis or formal verification or code changes. Excessive documentation notes about universal theoretical concerns dont likely add much except make the documentation harder to read and maintain.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#potential-reentrancies", "labels": ["OpenZeppelin"]}, {"title": "Repetitive code", "body": "In many parts of the codebase, repeated or similar lines of code can be seen. Here are some examples:  In Comet, lines 520-525, 555-561, 593-598 and 628-634 are repeated and loops after those sections have strong similarities.  timeElapsed > 0 check is performed two times, when accrueInternal is called, and when internally accruedInterestIndices is called.  allow and approve in CometExt do the same thing.  Consider reusing the same code defined in just one place or, if appropriate, removing duplicate code.  Update: Acknowledged. In the words of the team: We gave considerable thought to how redundant sections of the code were organized and tried various permutations. Although seemingly redundant, the current form is overall the best we found in terms of the properties we were evaluating (namely clarity, code size, gas cost).", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#repetitive-code", "labels": ["OpenZeppelin"]}, {"title": "Typos", "body": "Line 96 of the CometExt contract has a typo whi and the number of decimals showed here is wrong, as it should be one zero less.  To improve correctness and readability, consider reviewing both the contracts and the documentation for typos.  Update: Fixed in commit a1bd99f.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#typos", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary return values", "body": "In the Comet contract, there are functions like the supply or withdraw that return calls to internal functions even if theres no actual final value returned at the end.  Consider reviewing all the occurrences where this happens and avoid returning when not necessary. This will improve readability and correctness.  Update: Acknowledged. In the words of the team: These are used to handoff control flow and can actually improve readability with that understanding.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#unnecessary-return-values", "labels": ["OpenZeppelin"]}, {"title": "Lack of explicitness on data type sizes", "body": "The protocol heavily relies on different sized variables, which can have also positive or negative values and different scaling factors. Thanks to this, the deployment and execution of the codebase will decrease gas costs.  Given the fact that it adds some complexity and undermines the readability of the codebase, it is of utter importance to maintain explicitness and consistency across different contracts.  Specifically, implicit castings and sizes should be avoided.  To improve the overall quality of the codebase, consider reviewing it in its entirety, changing all occurrences of uint to uint256 and of int to int256. Consider also reviewing implicit castings from small to bigger sizes and always use the appropriate size for each variable.  Update: Partially fixed in PR#421. The team will continue to use the aliases uint and int as they consider them more readable. In their words: We removed all occurrences of implicit upscaling. We accept that uint256 and uint are interchangeable in Solidity and that authors are aware of this. Also, in PR#454, the team fixed an unsafe cast and improved gas usage.  PRICE_SCALE constant is not used  A constant called PRICE_SCALE is defined in the CometCore contract and is supposed to be used to scale the prices returned by Chainlink aggregators.  Although the function priceScale returns the value stored in the bytecode, the constant is not used anywhere else.  Consider removing this constant or alternatively integrating it into the codebase.  Update: Ackwnoledged. The team response: PRICE_SCALE is not used internally, but it is exposed via the priceScale function, which could be used to understand the results of the getPrice function.  Wrong value emitted in event  Lines 1219-1221 of the asborbInternal function in the Comet contract are:  uint104  debtAbsorbed  = unsigned104  (newBalance  oldBalance  );  uint  valueOfDebtAbsorbed  = mulPrice  (debtAbsorbed  , basePrice  uint64  (baseScale  )); emit AbsorbDebt  (absorber  , account  , debtAbsorbed  , valueOfDebtAbsorbed  );  Consider emitting the correct value in the AsborbDebt event or renaming the debtAbsorbed variable to reflect that it does not account only for the debt absorbed but also the excess collateral exchanged for the base asset.  Update: Fixed in commit edc5a0a.  Conclusions  No critical severity issues have been found, along with one high severity issue and many others lower in severity. We strongly recommend addressing even the lowest in severity since they would drastically improve the overall quality, clarity, and security of the protocol.  Update: The team has addressed all issues either fixing them or providing improved docstrings and proper explanation arguments. Some of the changes introduced in the codebase are still open as pull requests and not incorporated into the main codebase. We assume those changes that we reviewed to be merged as they are without introducing any new change that might create new issues.  Appendix  Monitoring Recommendation  The active monitoring of smart contracts is an important practice that can represent additional protection for a project, allowing an immediate response to unforeseen incidents. We recommend implementing monitoring for all sensitive actions and the state of critical variables. For instance:  Monitor if Comet contract reaches the targetReserves. At that point, the collateral tokens seized with the liquidation will be retained by the protocol, and this could represent a risk if it relates to market prices precipitating in prices.  Monitor callable governance functions, especially approveThis, and upgrades to malicious implementations in governance attack scenarios.  Direct transfers of base asset to Comet contract (either to report an erroneous transaction or attempted manipulation).  Large capital liquidations. Either the absorb function is executed for a large position or the position exceeds the borrowCollateralFactor and is at risk. This should inform a possible strong market price drop or the liquidation of a large entity.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#lack-of-explicitness-on-data-type-sizes", "labels": ["OpenZeppelin"]}, {"title": "PRICE_SCALE constant is not used", "body": "PRICE_SCALE constant is not used", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#price_scale-constant-is-not-used", "labels": ["OpenZeppelin"]}, {"title": "Wrong value emitted in event", "body": "Lines 1219-1221 of the asborbInternal function in the Comet contract are:  uint104  debtAbsorbed  = unsigned104  (newBalance  oldBalance  );  uint  valueOfDebtAbsorbed  = mulPrice  (debtAbsorbed  , basePrice  uint64  (baseScale  )); emit AbsorbDebt  (absorber  , account  , debtAbsorbed  , valueOfDebtAbsorbed  );  Consider emitting the correct value in the AsborbDebt event or renaming the debtAbsorbed variable to reflect that it does not account only for the debt absorbed but also the excess collateral exchanged for the base asset.  Update: Fixed in commit edc5a0a.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#wrong-value-emitted-in-event", "labels": ["OpenZeppelin"]}, {"title": "Extending the staking duration discards rewards", "body": "OgvStaking contract, updating a users rewards is a two step process: First, the internal function  _collectRewards must be called, which updates the accumulated per share rewards for all users and then computes and transfers an individual users total outstanding rewards. The computation of a users outstanding rewards uses the mapping  The function extend only performs an update on rewardDebt without a prior call to _collectRewards. Hence, it always discards the rewards earned by a user instead of paying them out.  While calling _collectRewards within the extend function would mitigate the issue, consider instead solving the root cause by migrating to a mapping rewardDebtPerShare. This mapping can be updated within the _collectRewards function, which does not need to account for changes in the users balance, thereby avoiding any future mismatches in reward accounting.  Update: Fixed by the changes made in pull requests #88 and #98.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#extending-the-staking-duration-discards-rewards", "labels": ["OpenZeppelin"]}, {"title": "Strongly coupled contracts can break core functionality", "body": "The OgvStaking contract is strongly coupled with the RewardsSource contract:  In OgvStaking the external functions stake, unstake and extend must call the internal function _collectRewards to update and transfer a users rewards.  _collectRewards calls RewardsSource.collectRewards to update the accRewardPerShare variable and receive all rewards that accrued within RewardsSource since the last call to collectRewards.  In consequence, any issue within the rewards distribution of the RewardsSource.collectRewards function will escalate into the governance-related functions of the OgvStaking contract.  RewardsSource.setRewardsTarget function, which contains the comment Okay to be zero, just disables collecting rewards. However, setting the  Consider wrapping the external call to RewardsSource.collectReward into a try/catch block to achieve decoupling of reward mechanics and staking-based governance. Additionally, consider removing the noRewards parameter of the unstake function which was originally intended for emergency withdrawals.  Update: Fixed in pull request #97. In addition, consider catching the error reason and emitting it as an event parameter to allow detection of the otherwise silent error.  Medium Severity", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#strongly-coupled-contracts-can-break-core-functionality", "labels": ["OpenZeppelin"]}, {"title": "Staking function can lead to loss of funds", "body": "OgvStaking contract the function  stake allows anybody to stake  If a user wants to simply stake for themselves, this leaves them with the option to call either stake(amount, duration, msg.sender) or stake(amount, duration, 0x0), both of which are surprising. Moreover, if the user wants to stake on behalf of another address, there are no checks to ensure the supplied account (which may be a contract) is able to call the unstake function or interact with OGV tokens. This behavior may lead to the loss of staked funds.  Consider migrating the staking logic to an internal function _stake and creating two external functions stake(uint256 amount, uint256 duration) and stakeFor(uint256 amount, uint256 duration, address receiver). Optionally, add the onlyGovernor modifier to the latter function to limit staking on behalf of another user to official airdrops. Further, consider verifying, either within the contract or off-chain, that a smart contract receiver can operate on the received stake to prevent an unintended loss of funds.  Update: Partially fixed in pull request #89. It is now simpler and more intuitive for a user to stake for themselves. However, staked funds may still be lost if a smart contract receiver is not designed to operate on the staked funds.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#staking-function-can-lead-to-loss-of-funds", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission", "body": "The following functions do not emit relevant events after executing sensitive actions:  The setRewardsTarget function changes the address OGV tokens are minted to as part of the staking reward system.  The setInflation function deletes and optionally updates the rewards slopes.  Consider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed in pull request #96. In addition, consider indexing the event parameters.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#lack-of-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Incomplete test suite", "body": "The testing suite covering in-scope contracts is incomplete. Although OgvStaking.t.sol and Rewards.t.sol test files were provided, the instructions in the README for the project do not sufficiently provide guidance on how to run comprehensive tests for the repo.  As the test suite was left outside the audits scope, please consider thoroughly reviewing the test suite to make sure all tests run successfully after following the instructions in the README file. Extensive unit tests aiming at 95% coverage are recommended in order for the security of the project to be assessed in a future audit. Integrating test coverage reports in every single pull request of the project is also highly advisable.  Update: Fixed in pull request #100.  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#incomplete-test-suite", "labels": ["OpenZeppelin"]}, {"title": "Lack of documentation", "body": "Throughout the codebase, we found several instances where documentation was lacking. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. For instance:  The functions and variables in the OgvStaking contract lack documentation.  The functions and some variables in the RewardsSource contract lack documentation.  The setInflation function should explicitly state:  The start time of the first slope may lie in the future, which allows an implicit configuration of a zero slope before the first start time. The end time of the end slope will always be set to infinity (type(uint64).max), which implies that unless Slope.ratePerDay is set to zero in the last slope a potentially unbounded number of OGV tokens could be minted.  In the OgvStaking contract, when a user stakes OGV tokens before the epoch time is reached, the tokens are locked for the specified duration after epoch. Hence, the tokens are locked for longer than expected. Users might be unaware of this behavior, so consider documenting it explicitly.  Consider thoroughly documenting the aforementioned code using the NatSpec format to increase the understandability of the codebase.  Update: Fixed in pull request #102.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#lack-of-documentation", "labels": ["OpenZeppelin"]}, {"title": "Voting token name and symbol are mixed up", "body": "In the OgvStaking contract the return values of the name and symbol functions are mixed up. Also, following this blog post from March 29, 2022, it is stated that the token symbol will be veOGV instead of OGVe.  Consider swapping the return values to correctly reflect the token parameters as well as renaming the symbol to match the announcement.  Update: Fixed in pull request #93.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#voting-token-name-and-symbol-are-mixed-up", "labels": ["OpenZeppelin"]}, {"title": "Gas savings", "body": "Throughout the codebase we found some instances that could be improved to save gas:  In the setInflation function of the RewardsSource contract, gas can be saved with the following changes:  Consider writing slopes.length to the stack with uint256 slopesLength = slopes.length; and using that variable instead of reading from memory each time. Additionally, the last overwrite of minSlopeStart for index i = slopes.length - 1 is not needed. Consider moving it within the condition two lines above for a minor gas optimization.  To calculate staking rewards the internal function _calcRewards iterates through an array of up to 48 slopes to compute the results that have been accumulated since it was last called. While the computation appears to be correct, many conditions lead to an unnecessary iteration of the entire array:  The gas optimization to return zero for the nextSlopeIndex has not been applied consistently, it is missing for the condition last >= block.timestamp. The condition rangeEnd < slopeStart leads the loop to continue with the next iteration, while the correct behavior would be to break, because no future slope can match a rangeEnd in the past. The condition slopeEnd < rangeEnd will never be true and is not the condition that corresponds to the comment No future slope could match. Consider replacing it with the condition rangeEnd < slopeEnd which holds when no future slope can match. To skip slope iterations when range limits match the slope limits, the conditions need to include the equal case. Hence, change to rangeStart >= slopeEnd, rangeEnd <= slopeStart, and slopeEnd >= rangeEnd.  Consider applying the above changes to make the code more gas efficient while maintaining its readability.  Update: Partially fixed in pull request #86 and #87. The unnecessary slopeEnd < rangeEnd check is unchanged. In addition, the slope iterations are still not skipped when range limits match slope limits.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#gas-savings", "labels": ["OpenZeppelin"]}, {"title": "Undocumented magic numbers", "body": "In the Governance contract the constructor uses several magic numbers to define key characteristics of the deployed system. This includes proposal delay, voting period, and voting threshold as well as the time extension in the case of a late quorum. Moreover, the magic numbers lack documentation and implicitly assume a fixed block time of 15 seconds.  Consider documenting these numbers more explicitly by describing their purpose and provide contextual information regarding time spans and average block times, such that it is easier for anyone to understand the characteristics.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#undocumented-magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "In RewardsSource the following imports are not used:  ERC20Votes  ERC20Permit  PRBMathUD60x18  Consider removing the imports.  ogv. However, no ERC20-functions are called on it. Consider declaring  Update: Fixed in pull request #94.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Missing license identifier", "body": "In the RewardsSource.sol and OgvStaking.sol files, a SPDX-license-identifier comment is missing.  Consider adding the MIT license identifier in accordance with the rest of the codebase.  Update: Fixed in pull request #95.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#missing-license-identifier", "labels": ["OpenZeppelin"]}, {"title": "Operators are implicitly trusted", "body": "In the current design of the payment system, the operator role wields a significant amount of power. A buyer cannot initiate a payment without the approval of an operator, and a seller must rely on an operator to vouch for the transfer of their asset.  to be good actors in the system. However, there are four possible scenarios where operators could behave maliciously:  Operator as a buyer: Both the buyer and operator need to agree upon the PaymentInput data. But theres nothing restricting an operator from also acting as a buyer, in which case they can approve their own transactions. More importantly, acting as a buyer an operator could defraud a seller by obtaining a refund even though the asset was received. After the sellers asset is transferred, the operator could either create a signed AssetTransferResult with the wasSuccessful field set to false, or not sign an AssetTransferResult at all. The operator could then call refund or refundAndWithdraw after the payment window has expired, and obtain their full payment amount even though the sellers item was successfully transferred.  Operator as a seller: The contracts do not restrict an operator from also being a seller in a transaction they are responsible for monitoring. In this case, an operator could register as a seller and post an item for sale. After a buyer initiates payment, the operator could craft an AssetTransferResult with the wasSuccessful field set to true, but then choose not to transfer the asset. The operator could then call finalize or finalizeAndWithdraw with the signed AssetTransferResult, prior to the payment window expiring, thus receiving payment for an asset that was never delivered.  Operator colluding with a buyer: Similar to the case where the operator and the buyer are the same, an operator could work together with a buyer in an attempt to obtain a refund for a transferred asset. As before, the operator could create a signed AssetTransferResult with wasSuccessful set to false, even though the asset was transferred.  Operator colluding with a seller: Similar to the case where the operator and the seller are the same, an operator could work in conjunction with a seller who owns an item of value. As before, the operator would create a signed AssetTransferResult with wasSuccessful set to true, even though the seller did not transfer the asset.  An operator should always be an observer of transactions and never participate as a buyer or seller. To prevent misuse of the power granted to an operator, consider adding checks which ensure that the buyer and seller addresses in the PaymentInput struct can never be the same as the operator address for the same payment transaction. Also consider revisiting the trust assumptions that allow an operator entity to independently vouch for the success or failure of an asset transfer via the AssetTransferResult mechanism, and how the system can guarantee that an asset transfer result is always produced.  Update: Not an issue. After discussing with the Freeverse team, we have concluded that the system is designed with a trust assumption that the role of operator will always be in the favor of the system. Additionally, the team has applied the fixes in the codebase to ensure that an operator cannot be a buyer or a seller, this is fixed as of commit 714e99e of PR #2.  Medium Severity", "html_url": "https://blog.openzeppelin.com/freeverse-audit#operators-are-implicitly-trusted", "labels": ["OpenZeppelin"]}, {"title": "Potential loss of access to funds if payment window is incorrectly set", "body": "The _paymentWindow variable within the PaymentsERC20 contract stores the maximum amount of time allowed for an asset transfer to be completed once a payment starts. The default value is 30 days and during this time, the buyers funds remain locked. If the buyer tries to obtain a refund before the payment window has expired, the refund request will not be accepted.  The PaymentsERC20 contract has a setPaymentWindow function that allows the contract owner to adjust the payment window for future payments. This function does not impose a limit on the chosen window size, making it possible to set the value so high that obtaining a refund from an asset transfer that failed to complete would effectively be impossible.  To prevent potential loss of access to funds, within the setPaymentWindow function, consider adding an upper limit on the payment window duration that the function will accept.  Update: Fixed as of commit a476fa1 of PR #3.  Low Severity", "html_url": "https://blog.openzeppelin.com/freeverse-audit#potential-loss-of-access-to-funds-if-payment-window-is-incorrectly-set", "labels": ["OpenZeppelin"]}, {"title": "Duplicate code", "body": "Duplication of code is error prone because the repeated implementations can get out of sync as the codebase evolves, potentially leading to unexpected behavior. There two instances of code duplication in the PaymentsERC20 contract:  The majority of the code in the pay and relayedPay functions in PaymentsERC20 is duplicated. Once the initial checks are completed in each case, all of the remaining steps are identical. Lines 102-123 in relayedPay are nearly identical to lines 141-162 in pay, with the only difference being line 106 vs line 145, which are functionally equivalent in setting the operator. Consider creating a shared private function for this duplicate code.  The maxFundsAvailable function makes calls to the external ERC20 contract in order to obtain the buyers approved spend allowance for the PaymentERC20 contract and the buyers token balance in their wallet. To obtain allowance and balance information from the external contract, PaymentERC20 implements allowance and erc20BalanceOf view functions that make respective calls to the allowance and balanceOf functions of the IERC20 interface. However, when maxFundsAvailable performs the allowance and balance queries, it calls the provided allowance function, but not the provided balanceOf function. In the latter case, IERC20.balanceOf() is called directly, duplicating the code in the erc20BalanceOf function. Consider using the erc20BalanceOf function to obtain the external token balance erc20Balance.  Update: Fixed as of commit 645f3f4 of PR #1.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#duplicate-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent and lack of indexed event parameters", "body": "Paid event has an unindexed  BuyerRefunded and  Payin events.  DefaultFeesCollector and  UniversalFeesCollector events do not apply the  DefaultOperator and  UniverseOperator events do not apply the  Indexed parameters are useful for quick offchain indexing of logs. Consider indexing applicable event parameters to support the searching and filtering abilities of offchain services.  Update: Fixed as of commit 745c035 of PR #4.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#inconsistent-and-lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The following functions in the codebase lack documentation:  All the functions, events, and state variables in the FeesCollectors contract are missing docstrings  All the functions, events, and state variables in the Operators contract are missing docstrings  The PaymentInput and AssetTransferResult structs in the IEIP712Verifier interface have no comments explaining any of the fields  None of the events in the IPaymentsERC20 interface have any documentation  There are no docstrings in the MyToken contract to explain the contracts purpose  This lack of documentation hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Fixed as of commit d311775 of PR #5. However, there are a few typographical errors in the newly added docstrings:  In the docstring above the MyToken contract, implementation is misspelled as implentation  In the docstring above the AssetTransferResult struct, ASSET_TRANSFERRING is misspelled as ASSET_TRANSFERING; PR #26 moves this line to ISignableStructs.sol", "html_url": "https://blog.openzeppelin.com/freeverse-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "No check that seller is already registered", "body": "The registerAsSeller function in the PaymentsERC20 contract emits a NewSeller event when a user calls it. There is no check in registerAsSeller to determine if a user address is already registered, so this function will emit a NewSeller event every time it is called. Depending on how the event log is used, this may lead to incorrect behavior by external observers of the contract if a user calls the function more than once.  Consider checking the existing bool value of _isRegisteredSeller when registerAsSeller is called, and reverting if the user is already registered.  Update: Fixed as of commit 6c7a698 of PR #6.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#no-check-that-seller-is-already-registered", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Some suggestions are:  States enum in the IPaymentsERC20 interface should be State enum  In the EIP712Verifier, the variable name inp is confusing as it indicates both PaymentInput and AssetTransferResult structs. Consider having different names for different parameters.  Throughout the PaymentsERC20 contract, the local variable name for Payment struct is p.  Consider having a meaningful naming convention for variables instead of using single letters such as p or abbreviated words such as inp.  Update: Fixed as of commit 4c2dc66 of PR #7.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Registration process is not clearly documented", "body": "The PaymentsERC20 contract allows a seller to register themselves by calling the registerAsSeller function. However, the system allows purchase of assets from unregistered sellers if the _isSellerRegistrationRequired flag is not set. In the scenario where _isSellerRegistrationRequired is set to false, any calls to registerAsSeller would be meaningless and would result in seller paying for the gas used for making this unnecessary transaction.  The codebase fails to document the meaning of registration, the advantage of being a registered seller, and why is it okay to disable this process.  Consider adding proper documentation as to why this process is required in the system and the scenarios in which it can be changed or disabled.  Update: Fixed as of commit 65269d9 of PR #8. However, there is a typographical error in the newly added docstring. In the README and docstring in the PaymentsERC20 contract, executed is misspelled as exectuted.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/freeverse-audit#registration-process-is-not-clearly-documented", "labels": ["OpenZeppelin"]}, {"title": "Constant set by constructor not marked immutable", "body": "The PaymentsERC20 contract sets the value of the _erc20 storage variable at construction time and has no mechanism to change the value afterward. This variable can be marked as immutable to save on gas costs when reading the value.  Consider marking this variable immutable in order to save users gas fees.  Update: Fixed as of commit 0f8028c of PR #10.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#constant-set-by-constructor-not-marked-immutable", "labels": ["OpenZeppelin"]}, {"title": "Contract file and contract name do not match", "body": "The ERC20Token.sol file, which is used only for test purposes and is not deployed, contains the MyToken contract. To follow common coding conventions, consider renaming ERC20Token.sol to MyToken.sol so that the contract name and the filename are the same.  Update: Fixed as of commit 2172356 of PR #11.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#contract-file-and-contract-name-do-not-match", "labels": ["OpenZeppelin"]}, {"title": "Use of draft EIP code", "body": "uses OpenZeppelins  implementation of the draft  EIP712 standard for hashing and signing of struct data. Until the EIP712 proposal is finalized, it is possible that the standard will change, which could require updates to the  Consider refactoring the code to allow EIP712Verifier to be deployed as a separate contract that could be upgraded in isolation in the event of a change to the draft EIP712 standard.  Update: Fixed as of commit d08c9f0 of PR #26.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#use-of-draft-eip-code", "labels": ["OpenZeppelin"]}, {"title": "Imports not grouped together", "body": "The following contracts have a docstring inserted in between the import statements:  EIP712Verifier.sol  import on line 16 is separated from the imports on lines 4-5  IPaymentsERC20.sol  import on line 41 is separated from the imports on lines 4-6  PaymentsERC20.sol  import on line 41 is separated from the imports on lines 4-6  To favor code clarity, consider rearranging the file contents in each case to group all of the import statements together.  Update: Fixed as of commit 2bba4d4 of PR #13.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#imports-not-grouped-together", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "For clarity, consider revising the following comments which may cause confusion:  In IEIP712Verifier.sol, lines 10-11 state:  However, the contract defines two structures and two verify functions, not just PaymentInput and verifyPayment as indicated by the docstring.  However, the contract defines two structures and two verify functions, not just PaymentInput and verifyPayment as indicated by the docstring.  In PaymentsERC20.sol, lines 18-20:  This docstring could be misinterpreted to mean that both buyerSig and operatorSig are required to start a payment, i.e. that both functions must be called. If buyerSig is provided, the operators signature is provided by signing the relayedPay transaction, and similarly if operatorSig is provided, the buyers signature is provided by signing the pay transaction. This comment is also repeated in IPaymentsERC20.sol and README.md.  Update: Fixed as of commit f580cf5 of PR #14.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Mismatched parameter name between interface and contract", "body": "AssetTransferResult calldata inp, but the corresponding  names the same parameter result instead of  @inheritdoc tag used for  To avoid confusion, consider renaming these parameters so that the names match each other, and match the corresponding docstring @param tag.  Update: Fixed as of commit 4c2dc66 of PR #7.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#mismatched-parameter-name-between-interface-and-contract", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors:  In IPaymentsERC20.sol:  line 12: success of failure should be success or failure  line 16: all of buyers received tokens should be all tokens received from the buyer  line 24: has non-zero local balance should be has a non-zero local balance  line 28: States Machine should be State Machine  line 34: the a payment should be the payment  line 36: throught should be throughout  line 47: Payin should be PayIn  line 232: ot check should be to check  In PaymentsERC20.sol:  line 12: success of failure should be success or failure  line 16: all of buyers received tokens should be all tokens received from the buyer  line 24: has non-zero local balance should be has a non-zero local balance  line 28: States Machine should be State Machine  line 34: the a payment should be the payment  line 36: throught should be throughout  In README.md:  line 16: success of failure should be success or failure  line 19: recevied should be received  line 20: all of buyers received tokens should be all tokens received from the buyer  line 28: has non-zero local balance should be has a non-zero local balance  line 32 and line 46: States Machine should be State Machine  line 40: throught should be throughout  Update: Fixed as of commit fa5cb16 of PR #15.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary use of uint16", "body": "feeBPS variable whose type is  expects feeBPS to be a uint256 value, so  an explicit cast to uint256 is performed when the function is called by  Consider changing the feeBPS variable type from uint16 to uint256.  Update: Fixed as of commit 3e21d35 of PR #17.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#unnecessary-use-of-uint16", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary inheritance", "body": "The FeesCollectors contract inherits from the Operators contract, effectively concatenating the two independent contracts. These contracts do not share any state or functions that require the use of inheritance.  Ownable, and  PaymentsERC20 to inherit from both  Update: Fixed as of commit cf5e0ea of PR #18.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#unnecessary-inheritance", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "To improve readability and avoid confusion, consider removing the following unused imports:  In the IPaymentsERC20 contract:  IERC20.sol  FeesCollectors.sol  EIP712Verifier.sol  In the IEIP712Verifier contract:  draft-EIP712.sol  ECDSA.sol  Update: Fixed as of commit b633fdc of PR #19.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "No functionality to withdraw portion of funds", "body": "finalizeAndWithdraw,  refundAndWithdraw or the  withdraw functions which in-turn calls the private  _withdraw function. This  checks the balance of the caller and  transfers the entire balance to the callers address.  Although there are no security concerns with withdrawing the entire balance, it might be advisable to have an option of withdrawing a portion of funds to provide a better user experience. For example, if a user has made a profit on selling an asset, they might want to withdraw only the profitable amount and reuse the remaining funds for future trades. In the current scenario, the user would be forced to take out all of their balance and then transfer funds back to the system in order to engage with future trades, and subsequently pay for the gas for making the additional transaction.  Consider adding functionality that allows the users to withdraw a portion of their funds.  Update: Fixed as of commit 20af988 of PR #23.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#no-functionality-to-withdraw-portion-of-funds", "labels": ["OpenZeppelin"]}, {"title": "Invalid Beneficiary", "body": "The setPaymentDelegation function of the Accounts contract allows a validator to set the zero address as their beneficiary with a non-zero payment fraction. In this scenario, the reward distribution mechanism will attempt to mint tokens to the zero address, which will revert. Consequently, neither the validator nor their group will receive the epoch payment.  Consider preventing validators from setting a zero beneficiary with a non-zero payment fraction. Additionally, in the interest of clearly signaling user intentions, consider introducing a deletePaymentDelegation function so the setPaymentDelegation function can disallow any zero beneficiary.  Update: Fixed in pull request #9283.  Low Severity", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#invalid-beneficiary", "labels": ["OpenZeppelin"]}, {"title": "Version not incremented", "body": "PR #8993 adds new rewards delegation functionality to the Accounts and Validators contracts, but does not increment the version functions. Consider incrementing the MINOR version of both contracts in line with the contract versioning system.  Update: Fixed in pull request #9256. The PR also increments the MAJOR version of the ExchangeBRL contract.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#version-not-incremented", "labels": ["OpenZeppelin"]}, {"title": "Comments should be linted", "body": "In PR #9041, both the ExchangeBRL and StableTokenBRL contracts have inconsistent indentation.  Consider linting the comments in order to increase readability of the codebase.  Update: Fixed in pull request #9285.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#comments-should-be-linted", "labels": ["OpenZeppelin"]}, {"title": "Inadequate NatSpec", "body": "We identified the following instances of incorrect or incomplete NatSpec comments:  in the getPaymentDelegation function of the Accounts contract:  the @param account statement is missing the @return statement describes both values returned as a single value instead of two separate values the @return statement should note that the fraction parameter is a FixidityLib value, or has 24 decimals of precision  in the initialize function of the Exchange contract:  the @param stableTokenIdentifier statement is in the wrong order.  throughout the codebase, the getVersionNumber functions share a common issue:  the @return statement describes all four values returned as a single value instead of four separate values during this review we identified this issue in the ExchangeBRL, StableTokenBRL, Validators, Exchange, and ExchangeEUR contracts this issue is replicated across the codebase and is found in code outside the scope of this review  In order to keep the codebase well documented, consider updating the NatSpec comments.  Update: Partially fixed in pull request #9270. The remaining fixes are being tracked in issue #9242 and issue #9268.  The Celo team states:  The issue with @return statements exists throughout the contracts code base, including many contracts that were outside the scope of this audit. For consistency, and to get them all in one go, well keep singular @returns for now, but have created #9268 to fix this throughout our smart contracts in the immediate future.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#inadequate-natspec", "labels": ["OpenZeppelin"]}, {"title": "Recalculated constant", "body": "The grandamento test file imports the SECONDS_IN_A_WEEK variable, but recalculates its value multiple times. For improved code clarity, consider using the constant.  Update: Fixed in pull request #9269.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#recalculated-constant", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains the following typographical errors:  FixidyLib should be FixidityLib  vaidator should be validator  Consider correcting these errors to improve code readability.  Update: Fixed in pull request #9250.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Improper use of solhint-disable", "body": "solhint-disable will disable a feature of solhint until it is re-enabled with solhint-enable or until the end of the file. Using solhint-disable with an unmatched solhint-enable creates code that is prone to errors when updating it in the future.  PR #9041, both the  ExchangeBRLProxy and  StableTokenBRLProxy contracts use  Update: Issue is scheduled for a future fix, it is tracked by issue #9245.  The Celo team states:  Agreed that solhint-disable-next-line would be better. That said, the current risk of these unmatched solhint-disableds causing problems is minimal  these contracts exist solely to create new named proxies, and are meant to have exactly the code of the original Proxy contract, so they inherit from it and add nothing new, and we dont expect ever modifying them to add anything new.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#improper-use-of-solhint-disable", "labels": ["OpenZeppelin"]}, {"title": "Missing oracle can cause unexpected behavior", "body": "Prior to pull request #9367, the addToken function in the Reserve contract checked that an oracle exists for the token being added, and the oracle returns a non-zero exchange rate. These checks ensured that every token in the _tokens array had a corresponding oracle.  With the oracle checks removed from addToken by this pull request, it is possible to enter a state where the token has been added but the oracle doesnt exist yet. However, the getReserveRatio function in the Reserve contract assumes that every token has a corresponding oracle that returns non-zero exchange rate values. If no oracle exists for a specific token, the converted price calculation will result in a divide-by-zero error.  The following contracts also contain code which can incorrectly divide by zero if queried with an oracle that is returning zero:  getGasPriceMinimum of GasPriceMinimum  getTargetTotalEpochPaymentsInGold of EpochRewards  Consider implementing additional logic that excludes tokens without oracles from the reserve ratio calculation, as well as including checks to ensure helpful errors are thrown rather than divide-by-zero errors.  Update: Partially fixed. The getReserveRatio function was fixed in PR #9527. Both getGasPriceMinimum and getTargetTotalEpochPaymentsInGold remain unchanged. Celos statement for this issue:  Updating getGasPriceMinimum is not critical, as the only reasonable behavior when there is no oracle report is to revert (could be nicer to fail with a relevant require message, but this is an edge case). Updating getTargetTotalEpochPaymentsInGold is not necessary as it only ever converts from cUSD (not other cStables), which already has an oracle rate.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#missing-oracle-can-cause-unexpected-behavior", "labels": ["OpenZeppelin"]}, {"title": "Incorrect version number", "body": "Pull request #9252 changes the behavior of the setSpread function in Exchange.sol, but does not update the version reported by the getVersionNumber function.  Consider incrementing the patch number returned by getVersionNumber in order to adhere to the smart contract release process.  Update: Fixed in PR #8334.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#incorrect-version-number", "labels": ["OpenZeppelin"]}, {"title": "Documentation mismatch", "body": "it is required to have at least one oracle report. The documentation points to  line number 223 in the  #9367 removed that code from the  Consider updating the online Celo documentation to accurately reflect the new behavior of the addToken function.  Update: Fixed in PR #312 of the celo-org/docs repository.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#documentation-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent code", "body": "In pull request #9252, code was added in order to ensure newly set spread values are valid. The change updated the setSpread function in the Exchange contract.  Similar to the Exchange contract, the GrandaMento contract includes an implementation of setSpread which already has a bounds check, however the two implementations differ in terms of logic and error messages.  In favor of consistent code across the repository, consider updating the code to make both implementations match.  Update: Fixed in PR #9459.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#inconsistent-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent test coverage", "body": "#9369 introduced a new  getPendingWithdrawals function can run out of gas if the number of pending withdrawals is excessive. In the pull request, a new test case for  lockedgold.ts, but the corresponding test for  To improve code coverage, consider restoring the test that was removed and providing equivalent test cases for both functions.  Update: Fixed in PR #9460.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#inconsistent-test-coverage", "labels": ["OpenZeppelin"]}, {"title": "Malicious user can register a scanner under any owner", "body": "The ScannerRegistryCore contract implements the functionality to allow the registration and minting of new scanners.  New scanners are meant to be registered by either calling the register function from the scanners address or through the trusted forwarder, or by the admin when calling the adminRegister function. These functions then call the _register function which implements the rest of the registration.  However, this _register function is marked as a public function, meaning that any user could skip the checks and register a scanner in the same way as the admin does it.  In favor of restricting the admin functionalities to regular users, consider changing the visibility of the _register function to internal.  Update: Fixed on commit 11bb25a9034f19be44315203713bf94d138698b8 in pull request 49.  Medium Severity  __gap missing in upgradeable contracts  The contracts VestingWallet and VestingWalletV2 do not contain a __gap variable although they are upgradeable.  Consider adding a correct __gap variable to these contracts, or documenting a plan for managing storage collisions when upgrading the Vesting Wallet. Additionally, since upgradeable contracts with __gaps are used in many places within the contracts, consider implementing quality control steps for upgradeable contract development. For instance, make it a priority to check all __gap variables before pushing any new code commits, as well as leaving comments next to all variables in a contract indicating which storage slots they belong in. Consider leaving deprecated variables in the code, and leaving comments about the fact that they were deprecated to avoid confusion for future developers. Finally, consider implementing a predictable inheritance structure for all contracts and documenting it within each contract. Implementing these steps will reduce the surface for error and in the long run may save developer time by removing confusion about the storage layout of the contracts.  Update: Fixed on commit 9b37ac5d4b852954552c69e33bf7f35de051d5b3 in pull request 50. The original VestingWallet contract without upgradeability slots was kept as the VestingWalletV0 contract and further extensions of it now include the __gap slots variable.  Lack of event emission after sensitive actions  The following function do not emit relevant events after executing sensitive actions.  The sweep function of the FortaStaking contract, after the SWEEPER_ROLE role withdraws all mistakenly sent tokens to the contract.  Consider emitting events after sensitive changes take place (including the first event emission in the constructor when appropriate), to facilitate tracking and notify off-chain clients following the contracts activity  Update: Fixes on commit d0934556c8331ccb806a606622bbd8b9f10c301b in pull request 51.  Unclear initialization of inherited contracts  The StakeAwareUpgradeable contract is inherited by a few contracts, such as the ScannerRegistryEnable contract, and therefore any other contract that inherits from those, such as the ScannerRegistry contract.  However, even though the ScannerRegistry contract implements the initialize function that initializes all the respective imports, there is no call to the __StakeAwareUpgradeable_init function from the StakeAwareUpgradeable contract. Furthermore, there is no single location in the whole codebase that would call the initializer to set the respective stake controller.  Moreover, the FortaStaking contract is inheriting the functionalities from the ERC1155SupplyUpgradeable contract but its __ERC1155Supply_init function is never initialized.  Consider calling all the respective initialization functions when inheriting functionalities from other contracts.  Update: Fixed on commit b7f5eb26fdb87a5c45392d6a6468d873a86ea450 in pull request 52. More documentation was added to describe the lack of initialization on upgraded contracts.  Lack of validation  Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:  In the Router contract, when adding or removing an element from the routing table, the methods return a boolean to inform the success of the call, but this output is never used or validated by the Router contract.  Similarly to the case from above, in the ScannerRegistryManaged contract, when adding or removing a manager from storage, its methods output is never validated.  In Routed.sol, the variable assignment in lines 13 and 25 are not validating if the address corresponds to a contract or if it is the zero address.  In the FortaStaking contract it is possible to initiate a withdrawal and set in storage a deadline for a inexistent stake, emit several events during the process, and trigger an external hook.  A lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider adding input and output validation to address the concerns raised above and in any other place when app", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#malicious-user-can-register-a-scanner-under-any-owner", "labels": ["OpenZeppelin"]}, {"title": "__gap missing in upgradeable contracts", "body": "__gap missing in upgradeable contracts", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#__gap-missing-in-upgradeable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive actions", "body": "The following function do not emit relevant events after executing sensitive actions.  The sweep function of the FortaStaking contract, after the SWEEPER_ROLE role withdraws all mistakenly sent tokens to the contract.  Consider emitting events after sensitive changes take place (including the first event emission in the constructor when appropriate), to facilitate tracking and notify off-chain clients following the contracts activity  Update: Fixes on commit d0934556c8331ccb806a606622bbd8b9f10c301b in pull request 51.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Unclear initialization of inherited contracts", "body": "The StakeAwareUpgradeable contract is inherited by a few contracts, such as the ScannerRegistryEnable contract, and therefore any other contract that inherits from those, such as the ScannerRegistry contract.  However, even though the ScannerRegistry contract implements the initialize function that initializes all the respective imports, there is no call to the __StakeAwareUpgradeable_init function from the StakeAwareUpgradeable contract. Furthermore, there is no single location in the whole codebase that would call the initializer to set the respective stake controller.  Moreover, the FortaStaking contract is inheriting the functionalities from the ERC1155SupplyUpgradeable contract but its __ERC1155Supply_init function is never initialized.  Consider calling all the respective initialization functions when inheriting functionalities from other contracts.  Update: Fixed on commit b7f5eb26fdb87a5c45392d6a6468d873a86ea450 in pull request 52. More documentation was added to describe the lack of initialization on upgraded contracts.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#unclear-initialization-of-inherited-contracts", "labels": ["OpenZeppelin"]}, {"title": "Lack of validation", "body": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:  In the Router contract, when adding or removing an element from the routing table, the methods return a boolean to inform the success of the call, but this output is never used or validated by the Router contract.  Similarly to the case from above, in the ScannerRegistryManaged contract, when adding or removing a manager from storage, its methods output is never validated.  In Routed.sol, the variable assignment in lines 13 and 25 are not validating if the address corresponds to a contract or if it is the zero address.  In the FortaStaking contract it is possible to initiate a withdrawal and set in storage a deadline for a inexistent stake, emit several events during the process, and trigger an external hook.  A lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider adding input and output validation to address the concerns raised above and in any other place when appropriate.  Update: Partially fixed on commit 85d6bd7518efd3a759789225b7dc07d4c26fa7fd in pull request 53. The team has acknowledged the lack of validation but it will not be enforced on all the mentioned places. The teams response for the issue:  NOTE: ignoring EnumerableSet.add() bool output; We dont care if already added.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#lack-of-validation", "labels": ["OpenZeppelin"]}, {"title": "Staked funds might get soft-stuck", "body": "FortaStaking contract implements the functionality to allow holders to stake their funds (vested or not) into a subject and collect rewards by doing so. The contract uses 2 different accounting systems to handle the assets: a  Distribution type based for the asset in stake units and the inner  ERC1155 accounting system for the associated shares. When a user  stakes, the contract  mints new active shares. When a user  wants to withdraw, the contract  burns those active shares and  mints inactive ones.  When minting these ERC1155, the _doSafeTransferAcceptanceCheck hook will get triggered and it would check if the destinatary is a ERC1155Receiver implementer or not when it detects that the address has code in it.  However, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the FortaStaking contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the same _doSafeTransferAcceptanceCheck hook as it will get triggered, failing at the same validation that was skipped on the first deposit.  This means that when the wallet starts the process to withdraw the assets, the transaction will fail during the minting of inactive shares. Nevertheless, the user may transfer those active shares to a fully compatible wallet to then initiate the withdrawal process once again.  In favor of improving the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed.  Update: Fixed on commit d13be24e8b84ffc59eb04ded2d03841a69996434 in pull request 54.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#staked-funds-might-get-soft-stuck", "labels": ["OpenZeppelin"]}, {"title": "L2 tokens could get stuck", "body": "The release function in the StakingEscrow contract allows users to send tokens from the StakingEscrow contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are NOT allowed to be transferred unless they have been accounted for by pendingReward.  Typically if tokens are received as rewards from the staking contract, pendingReward will be increased. However, if tokens are sent directly to this contract, it will not increase pendingReward and the tokens will not be transferable. Instead, users will only be able to bridge their FORT tokens, subjecting them to the vesting schedule on L1.  Consider implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the release function. Alternatively, consider making a clear warning to any StakingEscrow contract users that FORT tokens transferred to the contract will not be release-able and will be subjected to vesting.  Update: Fixed on commit 9d821024623005808eddd6765d8260f1d2a2301d in pull request 55. A warning has been added to let users know about this behavior.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#l2-tokens-could-get-stuck", "labels": ["OpenZeppelin"]}, {"title": "Slashing process could be reverted", "body": "When a certain subject under-performed or has done actions against the correct operation of the protocol, the SLASHER_ROLE role can slash that subject and all the users that have staked on it by calling the slash function from the FortaStaking contract. After the value that should be taken from inactive and active stake is computed, the slashed funds are transferred to the _treasury address.  initialization of the contract or by the  setTreasury function, the whole slashing mechanism will not work because the  does not allow to transfer tokens to the zero address.  In order to prevent the possible reversion of the slashing process, consider always validating that the _treasury address is not zero when initializing the contract or when a new treasury address is being set.  Update: Fixed on commit b2c4d5aa398530d1ae5af14cf84eb438a377af5e in pull request 56.  Low Severity", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#slashing-process-could-be-reverted", "labels": ["OpenZeppelin"]}, {"title": "TODOs and comments implying unfinished code", "body": "There are TODO comments and other comments implying unfinished codes in the codebase. These should be tracked in the projects issues backlog. In particular:  Line 38 of AgentRegistryCore.sol.  Line 54 of AgentRegistryCore.sol.  Line 35 of Router.sol, which seems to imply the development effort here is unfinished.  During development, having well described TODO comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.  These TODO comments should at least have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.  Consider updating these comments to add this information. For completeness and traceability, a signature and a timestamp can be added.  Update: Fixed on commit d02065f071cd94d1361e00ff2b5208f71d76d014 in pull request 73 and on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. However, now the AGENT_ADMIN_ROLE role can ban any creation by frontrunning the senders transaction and changing the frontRunningDelay variable.  Add information in _emitHook calls  _emitHook function for the hook hook_afterStakeChanged. However, this hook only includes two parameters:  deposit,  initiateWithdrawal,  withdraw, and the  slash functions.  If it is eventually needed to determine which user triggered a stake change, which users stake has changed, by how much a stake has changed, or what function resulted in the stake change, a call into the FortaStaking contract will be needed, possibly alongside complex logic in an external contract.  Consider passing relevant data with the calls to _emitHook, such as _msgSender and changeInStake. Doing so will make it easier for the contract receiving the hook to interpret what has happened. Additionally, consider documenting the purposes of the hooks for future development, so it is clear exactly which data may be needed from the hook_afterStakeChanged call.  Update: Fixed on commit 0d91a544de1540459b71167dfdf318bb11acf6a6 in pull request 76.  Inconsistent slot size for upgrades  Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.  However, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:  The ScannerRegistryManaged contract whose sum adds up to 45.  The StakeAwareUpgradeable contract whose sum adds up to 5.  The AgentRegistryCore contract whose sum adds up to 45.  In order to improve the codes readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the __gap variable as an exercise to double corroborate its final length.  Update: Fixed in pull request 45 and on commit 4a49ba4bdc53702fe199d06d249a0e961ee8385b in pull request 77. The team has explicitly described the slot usages in those files and added upgradeability information in the README.md file to mitigate future problems.  Potential for hash collisions with frontrun protection  Within AgentRegistryCore.sol, calls to the frontrunProtected modifier utilize abi.encodePacked to create a unique hash of some commited data.  However, by using two dynamic parameters next to each other (both in createAgent and in updateAgent), hashes can be easily forged simply by adjusting metadata and chainIds, such that an agent may be created or updated incorrectly.  By simply using abi.encode rather than abi.encodePacked, such collisions from dynamic parameters being adjacent can be avoided. Consider using abi.encode here instead.  Update: Fixed on commit 2a7391dff896384174ca49ff960d889120961a4e in pull request 57.  Implement a remove-whitelist functionality  Currently, to prevent tokens from being transferred while within the vesting schedule, a WHITELIST_ROLE is defined and checked in FortaCommon._beforeTokenTransfer. The user or contract can only transfer tokens if whitelisted. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.  Since contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled remove whitelist functionality in the existing contract which disables the whitelist. This will also give users greater conf", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#todos-and-comments-implying-unfinished-code", "labels": ["OpenZeppelin"]}, {"title": "Add information in _emitHook calls", "body": "Add information in _emitHook calls", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#add-information-in-_emithook-calls", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent slot size for upgrades", "body": "Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.  However, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:  The ScannerRegistryManaged contract whose sum adds up to 45.  The StakeAwareUpgradeable contract whose sum adds up to 5.  The AgentRegistryCore contract whose sum adds up to 45.  In order to improve the codes readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the __gap variable as an exercise to double corroborate its final length.  Update: Fixed in pull request 45 and on commit 4a49ba4bdc53702fe199d06d249a0e961ee8385b in pull request 77. The team has explicitly described the slot usages in those files and added upgradeability information in the README.md file to mitigate future problems.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#inconsistent-slot-size-for-upgrades", "labels": ["OpenZeppelin"]}, {"title": "Potential for hash collisions with frontrun protection", "body": "Within AgentRegistryCore.sol, calls to the frontrunProtected modifier utilize abi.encodePacked to create a unique hash of some commited data.  However, by using two dynamic parameters next to each other (both in createAgent and in updateAgent), hashes can be easily forged simply by adjusting metadata and chainIds, such that an agent may be created or updated incorrectly.  By simply using abi.encode rather than abi.encodePacked, such collisions from dynamic parameters being adjacent can be avoided. Consider using abi.encode here instead.  Update: Fixed on commit 2a7391dff896384174ca49ff960d889120961a4e in pull request 57.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#potential-for-hash-collisions-with-frontrun-protection", "labels": ["OpenZeppelin"]}, {"title": "Implement a remove-whitelist functionality", "body": "Currently, to prevent tokens from being transferred while within the vesting schedule, a WHITELIST_ROLE is defined and checked in FortaCommon._beforeTokenTransfer. The user or contract can only transfer tokens if whitelisted. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.  Since contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled remove whitelist functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.  Update: Fixed on commit dd558f1017eee429e8d66d9d151de3adf1d02a6d in pull request 58.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#implement-a-remove-whitelist-functionality", "labels": ["OpenZeppelin"]}, {"title": "Implicit casting", "body": "Throughout the codebase, an instance of implicit casting between types has been detected.  FortaStakingUtils library, in lines  10 and  18, the  Whenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelins SafeCast library which provides overflow checking when casting from one type of number to another.  Update: Fixed on commit 2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd in pull request 59.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#implicit-casting", "labels": ["OpenZeppelin"]}, {"title": "Incomplete interfaces", "body": "The IRouter interface should have an externally accessed function which is not being declared in the interface, the version getter function.  Consider declaring all externally accessed functions without access control so users and developers can make use of interfaces when using the protocol.  Update: Fixed on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. Versioned contracts now inherit from the IVersioned interface which declares the getter.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#incomplete-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Disabled scanners and agents may appear to be linked", "body": "Within Dispatch.sol, the mappings scannerToAgents and agentToScanners should store correct linkages between agents and scanners.  If an agent or scanner is disabled, they are not allowed to be linked. Thus, it follows that if scanners or agents which are linked are then disabled, the link should be removed. However, this is not enforced  a scanner or agent may be disabled, but the values in scannerToAgents and agentsToScanners may not reflect this.  Consider adding a programmatical way to remove links whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, the unlinking process may involve calling unlink multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.  Update: Acknowledge, but will not fix. The Forta teams statement for the issue:  Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#disabled-scanners-and-agents-may-appear-to-be-linked", "labels": ["OpenZeppelin"]}, {"title": "Magic numbers are used", "body": "Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get the maximum slashable stake in the FortaStaking contract uses explicit numbers during the calculation without documenting the reasons of such values.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.  Update: Fixed on commit 802b183505f637d1f4ec97a64b2c8b3d58057096 in pull request 60.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Non-registered scanners default to non-disabled states", "body": "The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.  enabling a scanner, the  _scannerEnable internal function uses the inverse assignment, meaning that a  registered as a ERC721 and have  enough stake on top of it, its default un-registered behavior resembles a non-disabled scanner.  Even though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we cant invert the logic of _disableFlags without downtime. _disableFlag at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (uint8, or rather Permission enum) so having a value that means scanner registered the first time but not enabled yet might complicate things further.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#non-registered-scanners-default-to-non-disabled-states", "labels": ["OpenZeppelin"]}, {"title": "Semantic overload", "body": "The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, but it also extends the functionality of the registration process.  When registering a new scanner, the contract checks if the minimum stake for the scanner type is greater than zero. This value is changed by the admin in the FortaStaking contract and it is meant to define a threshold value instead of an enabled status.  This is known as Semantic Overload. If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.  Consider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.  Update: Fixed on commit 1869a5ab8461c106e283a2d23e857d8435a8587b in pull request 78. Now, the scanner registration process checks if a certain chain is activated by using an explicit flag.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#semantic-overload", "labels": ["OpenZeppelin"]}, {"title": "Deviation from specifications", "body": "The StakingEscrow contract implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling the release function, where the documentation states that even if these assets are sent to a non-whitelisted address, the tokens will arrive but those will get stuck.  However, due to the _beforeTokenTransfer function hook being called during any regular transfer of ERC20 tokens, it will not be possible to send those assets to a non-whitelisted address.  Consider either updating the documentation to reflect the current behavior of the protocol or fixing the implementation to follow the specifications.  Update: Fixed. Now the documentation reflects what it is implemented in the code.  Reentrancy possibility due to _doSafeTransferAcceptanceCheck  After calling the _mint function in the FortaStaking contract, the function _doSafeTransferAcceptanceCheck from the ERC1155Upgradeable contract will get called, which will hand over control to the to address.  deposit and  initiateWithdrawal functions both make a call to the  Update: Fixed on commit 0d91a544de1540459b71167dfdf318bb11acf6a6 in pull request 76. Some hooks have been removed until an implementation makes use of them.  Notes & Additional Information  Add bridge exit instructions  Currently in the codebase, there is no obvious way to release tokens from the Polygon POS bridge. According to their documentation, the exit function will need to be called on Ethereum to release tokens sent from Polygon to Ethereum.  This may not be clear to users who transfer tokens from L2 to L1. The only locations in the code referencing the exit function are within the IRootChainManager interface and within the mock for RootChainManager. Notably, in the mock, the function is not implemented. It appears that the exit functionality may not have been fully implemented as intended.  Consider implementing instructions for users to exit from the Polygon bridge. To make it easier for users, consider calling the function from within contracts they are already interacting with, and ensure that instructions for using these functions are clear. Make sure to test all exit functionality thoroughly. Alternatively, consider writing a guide for users to exit on their own, and include it within the Forta documentation. Tests for such instructions should also be performed.  Update: Not fixed. The Forta team has acknowledged the issue and will fix it in the future. Their response for the issue:  We will add this to the public docs, thanks for the note.  Suggestion: add hooks which revert on failure  Currently in the codebase, the Router and Routed contracts allow for adding hooks via the _emitHook function to different contracts throughout the Forta codebase. Notably, different target contracts can be added and changed for each hook at any time, and all hooks will not revert the overall call if they revert.  It appears that this architecture exists for handling an unplanned future architecture. Therefore, consider also adding functionality which allows for hooks which MUST succeed, or revert the outer call if they revert. Note that this suggestion is merely for better future development experience, and does not arise from any security issue.  Update: Fixed on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. Now, depending on how the routing table is set, a certain signature may require that the external transaction has to be successful in order to proceed.  Add explicit warning about the Forwarder  The Forwarder contract allows for users to sign messages, and for them to be executed by other EOAs by presenting a valid signature. It includes nonces for replay protection for such transactions. However, users should be made explicitly aware that failing transactions will NOT consume a nonce. This is because the _verifyAndConsumeNonce function cannot store any data within a reverting transaction. Meaning, any transactions which revert can be broadcast again at any point in the future, by any user, and may succeed at that time.  Although this is briefly mentioned in the linked README, consider adding an explicit inline warning that nonces are not consumed in failing transactions, unlike normal ethereum transactions. Users should be made aware that to remedy this, they should make use of the deadline functionality, or that they will need to successfully broadcast a transaction which succeeds with the same nonce to cancel another. Additionally, consider adding a cancelTransaction function, which simply validates a signature and consumes the nonce.  Update: Not fixed. After discussing potential solutions, the security implications of a fix were deemed non-trivial and would require more time. The Forta team plans to address this in future development efforts.  Gas optimizations  There are a few spots identified in t", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#deviation-from-specifications", "labels": ["OpenZeppelin"]}, {"title": "Reentrancy possibility due to _doSafeTransferAcceptanceCheck", "body": "Reentrancy possibility due to _doSafeTransferAcceptanceCheck", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#reentrancy-possibility-due-to-_dosafetransferacceptancecheck", "labels": ["OpenZeppelin"]}, {"title": "Add bridge exit instructions", "body": "Currently in the codebase, there is no obvious way to release tokens from the Polygon POS bridge. According to their documentation, the exit function will need to be called on Ethereum to release tokens sent from Polygon to Ethereum.  This may not be clear to users who transfer tokens from L2 to L1. The only locations in the code referencing the exit function are within the IRootChainManager interface and within the mock for RootChainManager. Notably, in the mock, the function is not implemented. It appears that the exit functionality may not have been fully implemented as intended.  Consider implementing instructions for users to exit from the Polygon bridge. To make it easier for users, consider calling the function from within contracts they are already interacting with, and ensure that instructions for using these functions are clear. Make sure to test all exit functionality thoroughly. Alternatively, consider writing a guide for users to exit on their own, and include it within the Forta documentation. Tests for such instructions should also be performed.  Update: Not fixed. The Forta team has acknowledged the issue and will fix it in the future. Their response for the issue:  We will add this to the public docs, thanks for the note.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#add-bridge-exit-instructions", "labels": ["OpenZeppelin"]}, {"title": "Suggestion: add hooks which revert on failure", "body": "Currently in the codebase, the Router and Routed contracts allow for adding hooks via the _emitHook function to different contracts throughout the Forta codebase. Notably, different target contracts can be added and changed for each hook at any time, and all hooks will not revert the overall call if they revert.  It appears that this architecture exists for handling an unplanned future architecture. Therefore, consider also adding functionality which allows for hooks which MUST succeed, or revert the outer call if they revert. Note that this suggestion is merely for better future development experience, and does not arise from any security issue.  Update: Fixed on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. Now, depending on how the routing table is set, a certain signature may require that the external transaction has to be successful in order to proceed.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#suggestion:-add-hooks-which-revert-on-failure", "labels": ["OpenZeppelin"]}, {"title": "Add explicit warning about the Forwarder", "body": "The Forwarder contract allows for users to sign messages, and for them to be executed by other EOAs by presenting a valid signature. It includes nonces for replay protection for such transactions. However, users should be made explicitly aware that failing transactions will NOT consume a nonce. This is because the _verifyAndConsumeNonce function cannot store any data within a reverting transaction. Meaning, any transactions which revert can be broadcast again at any point in the future, by any user, and may succeed at that time.  Although this is briefly mentioned in the linked README, consider adding an explicit inline warning that nonces are not consumed in failing transactions, unlike normal ethereum transactions. Users should be made aware that to remedy this, they should make use of the deadline functionality, or that they will need to successfully broadcast a transaction which succeeds with the same nonce to cancel another. Additionally, consider adding a cancelTransaction function, which simply validates a signature and consumes the nonce.  Update: Not fixed. After discussing potential solutions, the security implications of a fix were deemed non-trivial and would require more time. The Forta team plans to address this in future development efforts.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#add-explicit-warning-about-the-forwarder", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "There are a few spots identified in the code which could be optimized for gas consumption.  On line 372 of FortaStaking.sol, a call to the availableReward function is made. This calls the subjectToActive method. On line 373, another call to the subjectToActive method is made. Making a single call to subjectToActive to utilize in both locations could save gas.  In StakingEscrowFactory.sol, the immutable value template is declared as an instance of the StakingEscrow contract. However, it is only ever used in the codebase when it is casted to an address. Instead of storing it as type StaingEscrow, store it as type address to save gas during the deployment and the runtime execution.  Consider correcting these two instances for more efficient gas usage when interacting with the Forta codebase.  Update: Fixed on commmit f60dec0d8beaf0153af55dabbffd647eb04db0ab in pull request 62.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent format in error messages", "body": "Error messages throughout the code base were found to be following different formats. In particular, some messages are formatted Contract name::function name: error message, whereas others are not.  So as to favor readability and ease debugging, consider always following a consistent format in error messages and, furthermore, consider adapting all revert messages to the \"Contract name::function name: error message\" format.  Update: Fixed on commit 2004980310db61537c0fac7be8f62b0de0aa6fb6 in pull request 79.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#inconsistent-format-in-error-messages", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "Throughout the codebase, there are places of misleading documentation. In particular:  The FortaBridgedPolygon contract implements the functionality to handle the bridge of asset between the 2 networks. When depositing funds in the root chain, the childChainManagerProxy address will call the deposit function to mint the respective tokens in the child chain. The in-line documentation also states that To avoid token locked on the parent chains not being correctly represented on the child chain, this should NEVER revert. Consequently, we might have to temporarily grant WHITELIST_ROLE to the receiver, however the _mint function can revert if the _maxSupply value is reached.  In the Router contract, the in-line documentation states that the contract should be BaseComponentUpgradeable, because BaseComponentUpgradeable is Routed where it should say shouldnt be instead.  In the FortaStaking contract, the sweep function allows to withdraw any token that was mistakenly sent to the contract. However, the documentation suggest that the function sweeps all the tokens at the same time, even though the function takes one at a time.  Consider fixing the documentation so users are aware of the real behavior of the protocol.  Update: Fixed on commit ab3fdc505ea5804d0e4991e28d0f0b143ef56a64 in pull request 63.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Many of the contracts and functions in the Forta Token codebase lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Fixed on commit 8d89e975f27328ddcfa98147751e4745b95df877 in pull request 80.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "There are many areas in the codebase which we feel better naming could greatly benefit development and reviewers understanding of the code. In particular:  Within Forwarder.sol, there are two functions named getNonce. Consider renaming one or both of them to indicate the difference between the two functions.  Within Dispatch.sol, function agentsFor should be renamed to numAgentsFor since it returns the number of agents for a scanner. Similarly, function scannersFor should be renamed to numScannersFor.  Within Dispatch.sol, function agentsAt should be renamed to agentAt since it returns only a single agent. Similarly, function scannersAt should be renamed to scannerAt.  Within VestingWalletV2.sol, function setHistoricalBalanceBridged should be renamed to setHistoricalBalanceMin to better represent what it does. Similarly, function updateHistoricalBalanceBridged should be renamed to updateHistoricalBalanceMin.  Note also that in a previous round of auditing, the issue was reported that many upgradeable contracts had filenames which did not indicate upgradeability. Consider making the suggested naming changes to better explain the codes purpose and reduce confusion for reviewers and developers.  Update: Partially fixed on commit 97f51b7eaec9310c17e82fc58ccef859d80c58cd in pull request 64 and on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. The Fortas team statement for the issue:  Having 2 getNonce methods with different parameters is a valid example of static polymorphism. The possible confusion will be mitigated by adding NatSpec in [N07].  As we said in the previous review, we signal that a contract is upgradeable when they inherit from BaseContractUpgradeable (or other Upgradeables in Routers case). Adding the suffix to every contract may be very noisy, especially when using long contract names.  Lack of _commits getter  The FrontRunningProtection contract utilizes a mapping, _commits, to track hashes for a commit-reveal scheme.  However, there is no easy way to access the _commits mapping on-chain. Consider adding a getter for the _commits mapping to ease the user and developer experience. Alternatively, if there is a reason for keeping the _commits mapping as private, consider explaining it in a comment.  Update: Fixed on commit ba8f8dcef73c27ec6dcb5bb2c05b7aabacde0d0a in pull request 65. However, now off-chain tracking services will not be able to detect when a commit hash has been submitted by using the events due to the removal of it.  Pragma statement is not consistent  Although most of the contracts in the codebase use a pragma statement of ^0.8.0, the index.sol file uses a >=0.8.4 version instead.  Although this does not represent a security risk per se, it is always recommended to use the same pragma statement for all the codebase.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they are consistent.  Update: Fixed on commit d638bd6622d1d2776d1a4f5d2bd31a568ad436ba in pull request 66.  Unneeded public visibility  Some functions in the codebase have public visibility, although it is unneeded since they are not called within the contract they exist in. For example:  Both getNonce functions within Forwarder.sol.  The execute function within Forwarder.sol.  The mint function within Forta.sol.  Consider changing the visibility of these functions to external to better indicate their role in the codebase, and to follow Solidity best practices. Alternatively, if the functions are needed to be public, consider documenting this with a comment.  Update: Fixed on commit 0b15e86ba7fe1dacc515884e88b578c806cddb3d in pull request 67.  Inconsistent use of roles  Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.  Multiple contracts per file  The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.  Styling issues  Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an ext", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "Lack of _commits getter", "body": "Lack of _commits getter", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#lack-of-_commits-getter", "labels": ["OpenZeppelin"]}, {"title": "Pragma statement is not consistent", "body": "Although most of the contracts in the codebase use a pragma statement of ^0.8.0, the index.sol file uses a >=0.8.4 version instead.  Although this does not represent a security risk per se, it is always recommended to use the same pragma statement for all the codebase.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they are consistent.  Update: Fixed on commit d638bd6622d1d2776d1a4f5d2bd31a568ad436ba in pull request 66.  Unneeded public visibility  Some functions in the codebase have public visibility, although it is unneeded since they are not called within the contract they exist in. For example:  Both getNonce functions within Forwarder.sol.  The execute function within Forwarder.sol.  The mint function within Forta.sol.  Consider changing the visibility of these functions to external to better indicate their role in the codebase, and to follow Solidity best practices. Alternatively, if the functions are needed to be public, consider documenting this with a comment.  Update: Fixed on commit 0b15e86ba7fe1dacc515884e88b578c806cddb3d in pull request 67.  Inconsistent use of roles  Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.  Multiple contracts per file  The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.  Styling issues  Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an extra line at ScannerNodeVersion.sol line 33.  The _setStakeController private function is placed before public functions in StakeAware.sol.  Within the initialize function of VestingWallet.sol, input parameter names contain a trailing underscore, unlike other initialize functions in the codebase which use two leading underscores for their input parameter names.  Throughout the codebase, there is relatively common usage of the expression ++i in places where i++ would function identically. For example, within a for loop in AgentRegistryCore.sol. This is in contrast to i++ which is also frequently used, for instance in the for loop in BatchRelayer.sol. Consider using only one style whenever possible, and when necessary to use the other style, including an explanatory comment.  In StakingEscrow.sol, there are two deposit functions (one for a full deposit and one for a partial deposit). However, the initiateWithdrawal function and its partner, initiateFullWithdrawal do not match this pattern. Consider overloading the initiateWithdrawal function as well, to match the style of the overloaded deposit function.  Update: Fixed on commit 3efd28b2a4ec84f1569f807bfb636ddfabc92753 in pull request 70.  Typos and erroneous comments  Several typographical errors were found in the codebase which should be corrected. In particular:  Line 26 of FullMath.sol says Remiander instead of Remainder.  Line 29 of FortaStaking.sol says elligible instead of eligible.  Line 401 of ForaStaking.sol says cal instead of can.  Line 49 of StakingEscrow.sol mentions __l1vesting in the error message, instead of __l2manager.  Line 112 of StakingEscrow.sol references the beneficiary, but should instead say manager.  Line 67 of VestingWalletV2.sol says explicitelly instead of explicitly.  Consider correcting the listed typos and errors within comments. Consider utilizing a spell-checker, such as codespell for future changes to the codebase.  Update: Partially fixed on commit 5c273497f71785d1d34f67d083ec494dbfdb99d3 in pull request 71. Some other typos were found and fixed by the Forta team, but the identified instances in FortaStaking.sol and StakingEscrow.sol were not addressed.  Unneeded or unclear frontrunning protection to update an agent  The FrontRunningProtection contract implement the functionality to allow a commit-reveal scheme to run frontrunning-protected actions in the protocol. Between those, are the ones to create and update an agent in the AgentRegistryCore contract.  Although it may be necessary to have such scheme to create ", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#pragma-statement-is-not-consistent", "labels": ["OpenZeppelin"]}, {"title": "Unneeded public visibility", "body": "Unneeded public visibility", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#unneeded-public-visibility", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of roles", "body": "Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#inconsistent-use-of-roles", "labels": ["OpenZeppelin"]}, {"title": "Multiple contracts per file", "body": "The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#multiple-contracts-per-file", "labels": ["OpenZeppelin"]}, {"title": "Styling issues", "body": "Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an extra line at ScannerNodeVersion.sol line 33.  The _setStakeController private function is placed before public functions in StakeAware.sol.  Within the initialize function of VestingWallet.sol, input parameter names contain a trailing underscore, unlike other initialize functions in the codebase which use two leading underscores for their input parameter names.  Throughout the codebase, there is relatively common usage of the expression ++i in places where i++ would function identically. For example, within a for loop in AgentRegistryCore.sol. This is in contrast to i++ which is also frequently used, for instance in the for loop in BatchRelayer.sol. Consider using only one style whenever possible, and when necessary to use the other style, including an explanatory comment.  In StakingEscrow.sol, there are two deposit functions (one for a full deposit and one for a partial deposit). However, the initiateWithdrawal function and its partner, initiateFullWithdrawal do not match this pattern. Consider overloading the initiateWithdrawal function as well, to match the style of the overloaded deposit function.  Update: Fixed on commit 3efd28b2a4ec84f1569f807bfb636ddfabc92753 in pull request 70.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#styling-issues", "labels": ["OpenZeppelin"]}, {"title": "Typos and erroneous comments", "body": "Several typographical errors were found in the codebase which should be corrected. In particular:  Line 26 of FullMath.sol says Remiander instead of Remainder.  Line 29 of FortaStaking.sol says elligible instead of eligible.  Line 401 of ForaStaking.sol says cal instead of can.  Line 49 of StakingEscrow.sol mentions __l1vesting in the error message, instead of __l2manager.  Line 112 of StakingEscrow.sol references the beneficiary, but should instead say manager.  Line 67 of VestingWalletV2.sol says explicitelly instead of explicitly.  Consider correcting the listed typos and errors within comments. Consider utilizing a spell-checker, such as codespell for future changes to the codebase.  Update: Partially fixed on commit 5c273497f71785d1d34f67d083ec494dbfdb99d3 in pull request 71. Some other typos were found and fixed by the Forta team, but the identified instances in FortaStaking.sol and StakingEscrow.sol were not addressed.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#typos-and-erroneous-comments", "labels": ["OpenZeppelin"]}, {"title": "Unneeded or unclear frontrunning protection to update an agent", "body": "The FrontRunningProtection contract implement the functionality to allow a commit-reveal scheme to run frontrunning-protected actions in the protocol. Between those, are the ones to create and update an agent in the AgentRegistryCore contract.  Although it may be necessary to have such scheme to create a new agent, so no one can own it beforehand, it is not clear why would it be necessary to have the same procedure to update an agent, taking into account that only the owner of such agent is able to perform the update.  In order to improve the readability of the code and the UX of the protocol, consider documenting the reasoning behind the need of the commit-reveal scheme during agent updates.  Update: Fixed on commit ac296e0ce7d5c6c81f772be88cd6fc74fdd2b429 in pull request 72. The unneeded check has been removed.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#unneeded-or-unclear-frontrunning-protection-to-update-an-agent", "labels": ["OpenZeppelin"]}, {"title": "Vesting schedule is changeable", "body": "VestingWallet or  VestingWalletV2 contracts, users should note that their  vestedAmount value is dependent on _historicalBalance output, which may change. If they transfer tokens to the  increase the _historicalBalance output which will result in a changed vesting schedule. Specifically, it will treat the new token amount as vested as well, and it will be released to the user following the vesting schedule. This has the effect of locking up some of the users funds temporarily if they accidentally transfer them to the  This is made more complicated by the fact that the staking system is set up to only allow funds to be transferred back to the VestingWallet contract. So, users must transfer their tokens back to the VestingWallet contract in order to be able to transfer them freely, and at that point they will be re-vested.  Furthermore, any change in the staked value in L2, e.g. funds get slashed, will not be addressed in L1 due to the historicalBalanceMin variable, off-syncing the balances between both chains even if all the remaining staked funds in L2 are bridged back to L1.  Users should also be made aware of the existence of the setHistoricalBalanceBridged function and the updateHistoricalBalanceBridged function, which give the owner role power to instantly affect the vesting schedule, specifically changing its speed.  Consider refactoring the vesting schedule logic to make it more predictable and user-friendly. For example, consider tracking the remaining vesting balance independently from the balance of the contract, so that tokens which are transferred to the VestingWallet contract from L2 are not re-vested. Additionally, consider defining predictable contract logic for calling the setHistoricalBalanceBridged and updateHistoricalBalanceBridged functions so that users can be assured their vesting schedules will not be tampered with maliciously. Finally, consider the legal implications of changing a vesting schedule based on both user and admin actions, as well as the tax implications for a user whose vesting schedule may change without warning.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  There is a limited number of users relying on these contracts, so for those that want to use the staking features we will just need to upgrade the vesting wallets, at which time such users can be thoroughly informed of the functionalities and risks of the upgrade and agree to them. Thanks for the warning!", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#vesting-schedule-is-changeable", "labels": ["OpenZeppelin"]}, {"title": "Slow relays on multiple chains", "body": "Slow relays on multiple chains", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#slow-relays-on-multiple-chains", "labels": ["OpenZeppelin"]}, {"title": "In each root bundle, the\u00a0slowRelayRoot\u00a0represents all the slow relays in a batch, which could involve multiple tokens and spoke pools. A valid root bundle would ensure\u00a0the\u00a0poolRebalanceRoot\u00a0has a leaf for every spoke chain. When this rebalance leaf is processed, the\u00a0slowRelayRoot\u00a0will also be\u00a0sent to the corresponding spoke pool.", "body": "In each root bundle, the\u00a0slowRelayRoot\u00a0represents all the slow relays in a batch, which could involve multiple tokens and spoke pools. A valid root bundle would ensure\u00a0the\u00a0poolRebalanceRoot\u00a0has a leaf for every spoke chain. When this rebalance leaf is processed, the\u00a0slowRelayRoot\u00a0will also be\u00a0sent to the corresponding spoke pool.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-each-root-bundle,-the\u00a0slowrelayroot\u00a0represents-all-the-slow-relays-in-a-batch,-which-could-involve-multiple-tokens-and-spoke-pools.-a-valid-root-bundle-would-ensure\u00a0the\u00a0poolrebalanceroot\u00a0has-a-leaf-for-every-spoke-chain.-when-this-rebalance-leaf-is-processed,-the\u00a0slowrelayroot\u00a0will-also-be\u00a0sent-to-the-corresponding-spoke-pool.", "labels": ["OpenZeppelin"]}, {"title": "Notably, every spoke pool receives the same\u00a0slowRelayRoot, which represents all slow relays in the batch across the whole system. When\u00a0the slow relay is executed, the Spoke Pool does not filter on the destination chain id, which means that any slow relay can be executed on any spoke chain where the Spoke Pool has sufficient funds in the\u00a0destinationToken. Consider including the destination chain ID in the slow relay details so the Spoke Pool can filter out relays that are intended for other chains.", "body": "Notably, every spoke pool receives the same\u00a0slowRelayRoot, which represents all slow relays in the batch across the whole system. When\u00a0the slow relay is executed, the Spoke Pool does not filter on the destination chain id, which means that any slow relay can be executed on any spoke chain where the Spoke Pool has sufficient funds in the\u00a0destinationToken. Consider including the destination chain ID in the slow relay details so the Spoke Pool can filter out relays that are intended for other chains.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#notably,-every-spoke-pool-receives-the-same\u00a0slowrelayroot,-which-represents-all-slow-relays-in-the-batch-across-the-whole-system.-when\u00a0the-slow-relay-is-executed,-the-spoke-pool-does-not-filter-on-the-destination-chain-id,-which-means-that-any-slow-relay-can-be-executed-on-any-spoke-chain-where-the-spoke-pool-has-sufficient-funds-in-the\u00a0destinationtoken.-consider-including-the-destination-chain-id-in-the-slow-relay-details-so-the-spoke-pool-can-filter-out-relays-that-are-intended-for-other-chains.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #79\u00a0as of commit\u00a02a41086f0d61caf0be8c2f3d1cdaf96e4f67f718.", "body": "Relayers may request invalid repayments  When a relayer fills a relay, they specify a repaymentChainId to indicate which chain they want to be refunded on. However, the repaymentChainId is not validated against any set of acceptable values. Instead, it is included in the _emitFillRelay event, which is used for generating root bundles in the system.  Since not all tokens may exist on all chains, and some chain IDs may not exist or be a part of the Across V2 system, consider specifying valid values for repaymentChainId for a given token, and implementing logic similar to that for enabledDepositRoutes to use for checking repaymentChainId. Alternatively, consider specifying in the UMIP some procedures for root bundle proposers to determine whether a repaymentChainId is valid, and what to do if it is not. In this case, invalid repaymentChainIds may mean a repayment is simply not repaid  if this is chosen, ensure that this is made very clear in any documentation about the system, so that users are not surprised by losing funds.  Update: Acknowledged. The UMA team intends to address this off-chain. They state:  We believe that this issue can be resolved in a well-defined UMIP that lists valid repayment chain IDs (or points to where to find them), and provide a default repayment chain ID for invalid ones. For example, the UMIP could stipulate that any invalid repayment chain IDs are repaid on mainnet.  Confusing removeLiquidity behavior could lock funds  The removeLiquidity function in the HubPool contract accepts a boolean argument sendEth. This should be set to true if L1 token is WETH and user wants to receive ETH.  However, if the user is a smart contract, even if the L1 token is WETH and the sendEth argument is true, WETH, not ETH, will ultimately be sent back.  This is the case because if sendEth is true, then the _unwrapWETHTo function is called. That function checks if the intended recipient is a smart contract, and, if so, sends WETH.  If the receiving smart contract has no mechanism to handle WETH and was only expecting ETH in return, as was explicitly specified by the sendEth argument submitted, then any WETH sent to such a contract could become inaccessible.  To avoid unnecessary confusion and the potential loss of funds, consider either reverting if a smart contract calls removeLiquidity with the sendEth argument set to true or modifying the _unwrapWETHTo function so that it can also be provided with and abide by an explicit sendEth argument.  Update: Fixed in pull request #90 as of commit a1d1269e8a65e2b08c95c261de3d074abc57444d and pull request #139 as of commit f4f87583a4af71607bacf7292fee1ffa8fc2c81d.  whitelistedRoutes for Ethereum_SpokePool affect other routes  executeRootBundle function, tokens are moved between spokes in order to  complete rebalances of the different spoke pools. These token transfers happen within the  _sendTokensToChainAndUpdatePooledTokenTrackers function, but in order to complete a rebalance the route from the  must be whitelisted.  The issue comes from the conflation of two slightly different requirements. When whitelisting a route, a combination of origin chain, destination chain, and origin token are whitelisted. However, when rebalancing tokens, the specific route where origin chain is the HubPools chain must be whitelisted for that token and destination chain pairing.  This means that if other routes are to be enabled for rebalancing, the route from the Ethereum_SpokePool to some destination chains SpokePool must be enabled as well. This may allow undesired transfers to the Ethereum_SpokePool. Additionally, it may cause problems if some token is to be allowed to move between chains aside from Ethereum, but specifically not Ethereum. It would be impossible to disable transfers to the Ethereum_SpokePool without also disabling transfers between separate spoke pools for the same token.  Also note that whitelisting a route does not necessarily whitelist the route from Ethereum to the same destination chain. This means that a separate transaction may need to be sent to enable rebalances to/from that destination, by whitelisting the Ethereum-as-origin route. This is confusing and could lead to unexpected reversions if forgotten about.  Consider modifying the whitelist scheme so that rebalances to specific chains are automatically enabled when enabling certain routes. For example, if the route for some token to move from Arbitrum to Optimism is enabled, then the route from the Hub to Optimism should also be enabled. Additionally, consider implementing some special logic to differentiate routes from the HubPool and routes from the Ethereum_SpokePool, so that either route can be enabled independently of the other.  Update: Fixed in pull request #89 as of commit 2d0adf78647070e4dd20690f67f46daaa6fc82c4.  Low Severity  chainId function is not virtual  Within SpokePool.sol, the function chainId is marked override. However, the comments above it indicate that the function should als", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#79\u00a0as-of-commit\u00a02a41086f0d61caf0be8c2f3d1cdaf96e4f67f718.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent signature checking", "body": "Inconsistent signature checking", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#inconsistent-signature-checking", "labels": ["OpenZeppelin"]}, {"title": "update the relay fee\u00a0associated with their transfer by signing a message describing this intention. The message is", "body": "update the relay fee\u00a0associated with their transfer by signing a message describing this intention. The message is", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update-the-relay-fee\u00a0associated-with-their-transfer-by-signing-a-message-describing-this-intention.-the-message-is", "labels": ["OpenZeppelin"]}, {"title": "verified on the origin chain\u00a0before emitting the event that notifies relayers, and", "body": "verified on the origin chain\u00a0before emitting the event that notifies relayers, and", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#verified-on-the-origin-chain\u00a0before-emitting-the-event-that-notifies-relayers,-and", "labels": ["OpenZeppelin"]}, {"title": "verified again on the destination chain\u00a0before the new fee can be used to fill the relay. If the depositor used a static ECDSA signature and both chains support the", "body": "verified again on the destination chain\u00a0before the new fee can be used to fill the relay. If the depositor used a static ECDSA signature and both chains support the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#verified-again-on-the-destination-chain\u00a0before-the-new-fee-can-be-used-to-fill-the-relay.-if-the-depositor-used-a-static-ecdsa-signature-and-both-chains-support-the", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin Signature Checker\u00a0library, which also supports", "body": "OpenZeppelin Signature Checker\u00a0library, which also supports", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#openzeppelin-signature-checker\u00a0library,-which-also-supports", "labels": ["OpenZeppelin"]}, {"title": "EIP-1271\u00a0validation for smart contracts. If the smart contract validation behaves differently on the two chains, valid contract signatures may be rejected on the destination chain. A plausible example would be a multisignature wallet on the source chain that is not replicated on the destination chain.", "body": "EIP-1271\u00a0validation for smart contracts. If the smart contract validation behaves differently on the two chains, valid contract signatures may be rejected on the destination chain. A plausible example would be a multisignature wallet on the source chain that is not replicated on the destination chain.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#eip-1271\u00a0validation-for-smart-contracts.-if-the-smart-contract-validation-behaves-differently-on-the-two-chains,-valid-contract-signatures-may-be-rejected-on-the-destination-chain.-a-plausible-example-would-be-a-multisignature-wallet-on-the-source-chain-that-is-not-replicated-on-the-destination-chain.", "labels": ["OpenZeppelin"]}, {"title": "Instead of validating the signature on the destination chain, consider including the\u00a0RequestedSpeedUpDeposit\u00a0event\u00a0in the off-chain UMIP specification, so that relayers that comply with the event would be reimbursed. This mitigation would need a mechanism to handle relayers that incorrectly fill relays with excessively large relayer fees, which would prevent the recipient from receiving their full payment. Alternatively, consider removing support for EIP-1271 validation and relying entirely on ECDSA signatures.", "body": "Instead of validating the signature on the destination chain, consider including the\u00a0RequestedSpeedUpDeposit\u00a0event\u00a0in the off-chain UMIP specification, so that relayers that comply with the event would be reimbursed. This mitigation would need a mechanism to handle relayers that incorrectly fill relays with excessively large relayer fees, which would prevent the recipient from receiving their full payment. Alternatively, consider removing support for EIP-1271 validation and relying entirely on ECDSA signatures.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#instead-of-validating-the-signature-on-the-destination-chain,-consider-including-the\u00a0requestedspeedupdeposit\u00a0event\u00a0in-the-off-chain-umip-specification,-so-that-relayers-that-comply-with-the-event-would-be-reimbursed.-this-mitigation-would-need-a-mechanism-to-handle-relayers-that-incorrectly-fill-relays-with-excessively-large-relayer-fees,-which-would-prevent-the-recipient-from-receiving-their-full-payment.-alternatively,-consider-removing-support-for-eip-1271-validation-and-relying-entirely-on-ecdsa-signatures.", "labels": ["OpenZeppelin"]}, {"title": "Relayers may request invalid repayments", "body": "Relayers may request invalid repayments", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#relayers-may-request-invalid-repayments", "labels": ["OpenZeppelin"]}, {"title": "When a relayer\u00a0fills a relay, they specify a\u00a0repaymentChainId\u00a0to indicate which chain they want to be refunded on. However, the\u00a0repaymentChainId\u00a0is not validated against any set of acceptable values. Instead, it is included in the\u00a0_emitFillRelay\u00a0event, which is used for generating root bundles in the system.", "body": "When a relayer\u00a0fills a relay, they specify a\u00a0repaymentChainId\u00a0to indicate which chain they want to be refunded on. However, the\u00a0repaymentChainId\u00a0is not validated against any set of acceptable values. Instead, it is included in the\u00a0_emitFillRelay\u00a0event, which is used for generating root bundles in the system.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#when-a-relayer\u00a0fills-a-relay,-they-specify-a\u00a0repaymentchainid\u00a0to-indicate-which-chain-they-want-to-be-refunded-on.-however,-the\u00a0repaymentchainid\u00a0is-not-validated-against-any-set-of-acceptable-values.-instead,-it-is-included-in-the\u00a0_emitfillrelay\u00a0event,-which-is-used-for-generating-root-bundles-in-the-system.", "labels": ["OpenZeppelin"]}, {"title": "Since not all tokens may exist on all chains, and some chain ID\u2019s may not exist or be a part of the Across V2 system, consider specifying valid values for\u00a0repaymentChainId\u00a0for a given token, and implementing logic similar to that for\u00a0enabledDepositRoutes\u00a0to use for checking\u00a0repaymentChainId. Alternatively, consider specifying in the UMIP some procedures for root bundle proposers to determine whether a\u00a0repaymentChainId\u00a0is valid, and what to do if it is not. In this case, invalid\u00a0repaymentChainIds may mean a repayment is simply not repaid \u2013 if this is chosen, ensure that this is made very clear in any documentation about the system, so that users are not surprised by losing funds.", "body": "Since not all tokens may exist on all chains, and some chain ID\u2019s may not exist or be a part of the Across V2 system, consider specifying valid values for\u00a0repaymentChainId\u00a0for a given token, and implementing logic similar to that for\u00a0enabledDepositRoutes\u00a0to use for checking\u00a0repaymentChainId. Alternatively, consider specifying in the UMIP some procedures for root bundle proposers to determine whether a\u00a0repaymentChainId\u00a0is valid, and what to do if it is not. In this case, invalid\u00a0repaymentChainIds may mean a repayment is simply not repaid \u2013 if this is chosen, ensure that this is made very clear in any documentation about the system, so that users are not surprised by losing funds.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#since-not-all-tokens-may-exist-on-all-chains,-and-some-chain-id\u2019s-may-not-exist-or-be-a-part-of-the-across-v2-system,-consider-specifying-valid-values-for\u00a0repaymentchainid\u00a0for-a-given-token,-and-implementing-logic-similar-to-that-for\u00a0enableddepositroutes\u00a0to-use-for-checking\u00a0repaymentchainid.-alternatively,-consider-specifying-in-the-umip-some-procedures-for-root-bundle-proposers-to-determine-whether-a\u00a0repaymentchainid\u00a0is-valid,-and-what-to-do-if-it-is-not.-in-this-case,-invalid\u00a0repaymentchainids-may-mean-a-repayment-is-simply-not-repaid-\u2013-if-this-is-chosen,-ensure-that-this-is-made-very-clear-in-any-documentation-about-the-system,-so-that-users-are-not-surprised-by-losing-funds.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Acknowledged. The UMA team intends to address this off-chain. They state:", "body": "Update:\u00a0Acknowledged. The UMA team intends to address this off-chain. They state:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0acknowledged.-the-uma-team-intends-to-address-this-off-chain.-they-state:", "labels": ["OpenZeppelin"]}, {"title": "We believe that this issue can be resolved in a well-defined UMIP that lists valid repayment chain IDs (or points to where to find them), and provide a default repayment chain ID for invalid ones. For example, the UMIP could stipulate that any invalid repayment chain IDs are repaid on mainnet.", "body": "We believe that this issue can be resolved in a well-defined UMIP that lists valid repayment chain IDs (or points to where to find them), and provide a default repayment chain ID for invalid ones. For example, the UMIP could stipulate that any invalid repayment chain IDs are repaid on mainnet.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#we-believe-that-this-issue-can-be-resolved-in-a-well-defined-umip-that-lists-valid-repayment-chain-ids-(or-points-to-where-to-find-them),-and-provide-a-default-repayment-chain-id-for-invalid-ones.-for-example,-the-umip-could-stipulate-that-any-invalid-repayment-chain-ids-are-repaid-on-mainnet.", "labels": ["OpenZeppelin"]}, {"title": "Confusing\u00a0removeLiquidity\u00a0behavior could lock funds", "body": "Confusing\u00a0removeLiquidity\u00a0behavior could lock funds", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#confusing\u00a0removeliquidity\u00a0behavior-could-lock-funds", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0removeLiquidity\u00a0function in the\u00a0HubPool\u00a0contract accepts a boolean argument\u00a0sendEth. This should be set to true\u00a0\u201cif L1 token is WETH and user wants to receive ETH\u201d.", "body": "The\u00a0removeLiquidity\u00a0function in the\u00a0HubPool\u00a0contract accepts a boolean argument\u00a0sendEth. This should be set to true\u00a0\u201cif L1 token is WETH and user wants to receive ETH\u201d.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0removeliquidity\u00a0function-in-the\u00a0hubpool\u00a0contract-accepts-a-boolean-argument\u00a0sendeth.-this-should-be-set-to-true\u00a0\u201cif-l1-token-is-weth-and-user-wants-to-receive-eth\u201d.", "labels": ["OpenZeppelin"]}, {"title": "However, if the \u201cuser\u201d is a smart contract, even if the L1 token is WETH and the\u00a0sendEth\u00a0argument is\u00a0true, WETH, not ETH, will ultimately be sent back.", "body": "However, if the \u201cuser\u201d is a smart contract, even if the L1 token is WETH and the\u00a0sendEth\u00a0argument is\u00a0true, WETH, not ETH, will ultimately be sent back.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#however,-if-the-\u201cuser\u201d-is-a-smart-contract,-even-if-the-l1-token-is-weth-and-the\u00a0sendeth\u00a0argument-is\u00a0true,-weth,-not-eth,-will-ultimately-be-sent-back.", "labels": ["OpenZeppelin"]}, {"title": "This is the case because\u00a0if\u00a0sendEth\u00a0is\u00a0true, then the\u00a0_unwrapWETHTo\u00a0function is called. That function checks if the intended recipient is a smart contract, and, if so, sends WETH.", "body": "This is the case because\u00a0if\u00a0sendEth\u00a0is\u00a0true, then the\u00a0_unwrapWETHTo\u00a0function is called. That function checks if the intended recipient is a smart contract, and, if so, sends WETH.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#this-is-the-case-because\u00a0if\u00a0sendeth\u00a0is\u00a0true,-then-the\u00a0_unwrapwethto\u00a0function-is-called.-that-function-checks-if-the-intended-recipient-is-a-smart-contract,-and,-if-so,-sends-weth.", "labels": ["OpenZeppelin"]}, {"title": "If the receiving smart contract has no mechanism to handle WETH and was only expecting ETH in return, as was explicitly specified by the\u00a0sendEth\u00a0argument submitted, then any WETH sent to such a contract could become inaccessible.", "body": "If the receiving smart contract has no mechanism to handle WETH and was only expecting ETH in return, as was explicitly specified by the\u00a0sendEth\u00a0argument submitted, then any WETH sent to such a contract could become inaccessible.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#if-the-receiving-smart-contract-has-no-mechanism-to-handle-weth-and-was-only-expecting-eth-in-return,-as-was-explicitly-specified-by-the\u00a0sendeth\u00a0argument-submitted,-then-any-weth-sent-to-such-a-contract-could-become-inaccessible.", "labels": ["OpenZeppelin"]}, {"title": "To avoid unnecessary confusion and the potential loss of funds, consider either reverting if a smart contract calls\u00a0removeLiquidity\u00a0with the\u00a0sendEth\u00a0argument set to\u00a0true\u00a0or modifying the\u00a0_unwrapWETHTo\u00a0function so that it can also be provided with and abide by an explicit\u00a0sendEth\u00a0argument.", "body": "To avoid unnecessary confusion and the potential loss of funds, consider either reverting if a smart contract calls\u00a0removeLiquidity\u00a0with the\u00a0sendEth\u00a0argument set to\u00a0true\u00a0or modifying the\u00a0_unwrapWETHTo\u00a0function so that it can also be provided with and abide by an explicit\u00a0sendEth\u00a0argument.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#to-avoid-unnecessary-confusion-and-the-potential-loss-of-funds,-consider-either-reverting-if-a-smart-contract-calls\u00a0removeliquidity\u00a0with-the\u00a0sendeth\u00a0argument-set-to\u00a0true\u00a0or-modifying-the\u00a0_unwrapwethto\u00a0function-so-that-it-can-also-be-provided-with-and-abide-by-an-explicit\u00a0sendeth\u00a0argument.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #90\u00a0as of commit\u00a0a1d1269e8a65e2b08c95c261de3d074abc57444d\u00a0and\u00a0pull request #139\u00a0as of commit\u00a0f4f87583a4af71607bacf7292fee1ffa8fc2c81d.", "body": "Update:\u00a0Fixed in\u00a0pull request #90\u00a0as of commit\u00a0a1d1269e8a65e2b08c95c261de3d074abc57444d\u00a0and\u00a0pull request #139\u00a0as of commit\u00a0f4f87583a4af71607bacf7292fee1ffa8fc2c81d.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#90\u00a0as-of-commit\u00a0a1d1269e8a65e2b08c95c261de3d074abc57444d\u00a0and\u00a0pull-request-#139\u00a0as-of-commit\u00a0f4f87583a4af71607bacf7292fee1ffa8fc2c81d.", "labels": ["OpenZeppelin"]}, {"title": "whitelistedRoutes\u00a0for\u00a0Ethereum_SpokePool\u00a0affect other routes", "body": "whitelistedRoutes\u00a0for\u00a0Ethereum_SpokePool\u00a0affect other routes", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#whitelistedroutes\u00a0for\u00a0ethereum_spokepool\u00a0affect-other-routes", "labels": ["OpenZeppelin"]}, {"title": "executeRootBundle\u00a0function, tokens are moved between spokes in order to", "body": "executeRootBundle\u00a0function, tokens are moved between spokes in order to", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#executerootbundle\u00a0function,-tokens-are-moved-between-spokes-in-order-to", "labels": ["OpenZeppelin"]}, {"title": "complete rebalances\u00a0of the different spoke pools. These token transfers happen within the", "body": "complete rebalances\u00a0of the different spoke pools. These token transfers happen within the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#complete-rebalances\u00a0of-the-different-spoke-pools.-these-token-transfers-happen-within-the", "labels": ["OpenZeppelin"]}, {"title": "_sendTokensToChainAndUpdatePooledTokenTrackers\u00a0function, but in order to complete a rebalance the route from the", "body": "_sendTokensToChainAndUpdatePooledTokenTrackers\u00a0function, but in order to complete a rebalance the route from the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#_sendtokenstochainandupdatepooledtokentrackers\u00a0function,-but-in-order-to-complete-a-rebalance-the-route-from-the", "labels": ["OpenZeppelin"]}, {"title": "must be whitelisted.", "body": "must be whitelisted.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#must-be-whitelisted.", "labels": ["OpenZeppelin"]}, {"title": "The issue comes from the conflation of two slightly different requirements. When whitelisting a route, a combination of\u00a0origin chain, destination chain, and origin token are whitelisted. However, when rebalancing tokens, the specific route where origin chain is the\u00a0HubPool\u2018s chain\u00a0must be whitelisted for that token and destination chain pairing.", "body": "The issue comes from the conflation of two slightly different requirements. When whitelisting a route, a combination of\u00a0origin chain, destination chain, and origin token are whitelisted. However, when rebalancing tokens, the specific route where origin chain is the\u00a0HubPool\u2018s chain\u00a0must be whitelisted for that token and destination chain pairing.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the-issue-comes-from-the-conflation-of-two-slightly-different-requirements.-when-whitelisting-a-route,-a-combination-of\u00a0origin-chain,-destination-chain,-and-origin-token-are-whitelisted.-however,-when-rebalancing-tokens,-the-specific-route-where-origin-chain-is-the\u00a0hubpool\u2018s-chain\u00a0must-be-whitelisted-for-that-token-and-destination-chain-pairing.", "labels": ["OpenZeppelin"]}, {"title": "This means that if other routes are to be enabled for rebalancing, the route from the\u00a0Ethereum_SpokePool\u00a0to some destination chain\u2019s\u00a0SpokePool\u00a0must be enabled as well. This may allow undesired transfers to the\u00a0Ethereum_SpokePool. Additionally, it may cause problems if some token is to be allowed to move between chains aside from Ethereum, but specifically not Ethereum. It would be impossible to disable transfers to the\u00a0Ethereum_SpokePool\u00a0without also disabling transfers between separate spoke pools for the same token.", "body": "This means that if other routes are to be enabled for rebalancing, the route from the\u00a0Ethereum_SpokePool\u00a0to some destination chain\u2019s\u00a0SpokePool\u00a0must be enabled as well. This may allow undesired transfers to the\u00a0Ethereum_SpokePool. Additionally, it may cause problems if some token is to be allowed to move between chains aside from Ethereum, but specifically not Ethereum. It would be impossible to disable transfers to the\u00a0Ethereum_SpokePool\u00a0without also disabling transfers between separate spoke pools for the same token.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#this-means-that-if-other-routes-are-to-be-enabled-for-rebalancing,-the-route-from-the\u00a0ethereum_spokepool\u00a0to-some-destination-chain\u2019s\u00a0spokepool\u00a0must-be-enabled-as-well.-this-may-allow-undesired-transfers-to-the\u00a0ethereum_spokepool.-additionally,-it-may-cause-problems-if-some-token-is-to-be-allowed-to-move-between-chains-aside-from-ethereum,-but-specifically-not-ethereum.-it-would-be-impossible-to-disable-transfers-to-the\u00a0ethereum_spokepool\u00a0without-also-disabling-transfers-between-separate-spoke-pools-for-the-same-token.", "labels": ["OpenZeppelin"]}, {"title": "Also note that\u00a0whitelisting a route\u00a0does not\u00a0necessarily\u00a0whitelist the route from Ethereum to the same destination chain. This means that a separate transaction may need to be sent to enable rebalances to/from that destination, by whitelisting the Ethereum-as-origin route. This is confusing and could lead to unexpected reversions if forgotten about.", "body": "Also note that\u00a0whitelisting a route\u00a0does not\u00a0necessarily\u00a0whitelist the route from Ethereum to the same destination chain. This means that a separate transaction may need to be sent to enable rebalances to/from that destination, by whitelisting the Ethereum-as-origin route. This is confusing and could lead to unexpected reversions if forgotten about.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#also-note-that\u00a0whitelisting-a-route\u00a0does-not\u00a0necessarily\u00a0whitelist-the-route-from-ethereum-to-the-same-destination-chain.-this-means-that-a-separate-transaction-may-need-to-be-sent-to-enable-rebalances-to/from-that-destination,-by-whitelisting-the-ethereum-as-origin-route.-this-is-confusing-and-could-lead-to-unexpected-reversions-if-forgotten-about.", "labels": ["OpenZeppelin"]}, {"title": "Consider modifying the whitelist scheme so that rebalances to specific chains are automatically enabled when enabling certain routes. For example, if the route for some token to move from Arbitrum to Optimism is enabled, then the route from the Hub to Optimism should also be enabled. Additionally, consider implementing some special logic to differentiate routes from the\u00a0HubPool\u00a0and routes from the\u00a0Ethereum_SpokePool, so that either route can be enabled independently of the other.", "body": "Consider modifying the whitelist scheme so that rebalances to specific chains are automatically enabled when enabling certain routes. For example, if the route for some token to move from Arbitrum to Optimism is enabled, then the route from the Hub to Optimism should also be enabled. Additionally, consider implementing some special logic to differentiate routes from the\u00a0HubPool\u00a0and routes from the\u00a0Ethereum_SpokePool, so that either route can be enabled independently of the other.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-modifying-the-whitelist-scheme-so-that-rebalances-to-specific-chains-are-automatically-enabled-when-enabling-certain-routes.-for-example,-if-the-route-for-some-token-to-move-from-arbitrum-to-optimism-is-enabled,-then-the-route-from-the-hub-to-optimism-should-also-be-enabled.-additionally,-consider-implementing-some-special-logic-to-differentiate-routes-from-the\u00a0hubpool\u00a0and-routes-from-the\u00a0ethereum_spokepool,-so-that-either-route-can-be-enabled-independently-of-the-other.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #89\u00a0as of commit\u00a02d0adf78647070e4dd20690f67f46daaa6fc82c4.", "body": "Polygon bridger does not enforce chainId requirements  The PolygonTokenBridger contracts primary functions are only intended to be called either on l1 or l2, but not both. In fact, calling the functions on the wrong chain could result in unexpected behavior and unnecessary confusion.  In the best case, the functions will simply revert if called from the wrong chain because they will attempt to interact with other contracts that do not exist on that chain. For example, calling the receive function (by sending the contract some native asset) could trigger reverts on Polygon, but not on Ethereum, because there is a WETH contract at the l1Weth address on the latter but not the former.  However, in the worst case, it is possible that such calls will not revert, but result in lost funds instead. For example, if a WETH-like contract was later deployed to the l1Weth address on Polygon, then the call would not revert. Instead, tokens would be sent to that contract and could remain stuck there.  Although the inline documentation details which function should be called on which chain, consider having the functions in this contract actively enforce these requirements via limiting execution to the correct block.chainid.  Update: Fixed in pull request #115 as of commit b80d7a5396d31662265bb28b61a1a3d09ed76760 and pull request #128 as of commit 811ac20674d28189fd01297c05ce5b9e89f7a183.  Liquidity provisioning can skew fee assessments  In the HubPool contract the enableL1TokenForLiquidityProvision function allows the contract owner to enable an l1token to be added to the protocol for liquidity pooling.  This is allowed even if the l1token is already currently enabled.  As this function also sets the lastLpFeeUpdate variable to the then-current block.timestamp, enabling an already enabled token will skip over the period of time since lastLpFeeUpdate was last set. As a result, any LP fees that should have been assessed for that time period would simply never be assessed.  Consider reverting if this function is called for an l1token that is already enabled.  Update: Fixed in pull request #94 as of commit b1a097748a82c3276619a06fa36358b574f843e1.  Some functions not marked nonReentrant  We have not identified any security issues relating to reentrancy. However, out of an abundance of caution, consider marking the following public functions in the HubPool contract as nonReentrant. Consider that the nonReentrant modifier only works if both the original function, and the re-entered function are marked nonReentrant.  setProtocolFeeCapture  setBond  setLiveness  setIdentifier  whitelistRoute  enableL1TokenForLiquidityProvision  disableL1TokenForLiquidityProvision  addLiquidity  Update: Fixed. Partially addressed in pull request #62 as of commit a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6 and then fully addressed in pull request #92 as of commit 7aa2fa8f46f8d40512857f35dd3ac64587c61f18.  Unexpected proposal cancellation  In the HubPool contract during a call to the disputeRootBundle function, if the bondAmount and finalFee values are the same, then the proposer bond passed to the optimistic oracle is zero.  When this happens, the optimistic oracle unilaterally sets the bond to the finalFee and then attempts to withdraw bond + final fee.  Since the HubPool only sets the allowance for the oracle to bondAmount rather than bondAmount + finalFee, this transfer will fail and, as a result, the proposal will be cancelled.  setBond function if the  proposeRootBundle function if  Update: Partially fixed in pull request #96 as of commit 671d416db0fe6d813e3761bda0e3132cb30a8e1d. The condition is checked in setBond but not in proposeRootBundle.  Time is cast unsafely  _updateAccumulatedLpFees, the return value of  getCurrentTime() is cast to a uint32 value. This means that the value will be truncated to fit within 32 bits, and at some point around Feb 6, 2106, it will roll over and the value returned by casting to  pooledToken.lastLpFeeUpdate to a much lower number than the previous  timeFromLastInteraction calculation will be exceedingly high, and all undistributed fees will be  accounted for as accumulated.  Again, note that this issue will only occur starting in the year 2106. Consider changing the size of the cast from uint32 to a larger number, like uint64. This should be more than enough to not encounter limits within a reasonably distant future. Alternatively, consider documenting the behavior and defining a procedure for what to do if the system is still in operation when the uint32 limit is hit, or for shutting down the system before the year 2106.  Update: Fixed in pull request #95 as of commit 2f59388906346780e729f2b879b643941ea314c9.  Notes & Additional Information  Missing link to referenced code  Within the Ethereum_Adapter, there is a mention of copying code from Governor.sol. It appears that the contract in question is Governor.sol from the UMAprotocol/protocol repository.  Since it is a part of a separate repository, and it is poss", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#89\u00a0as-of-commit\u00a02d0adf78647070e4dd20690f67f46daaa6fc82c4.", "labels": ["OpenZeppelin"]}, {"title": "chainId\u00a0function is not\u00a0virtual", "body": "chainId\u00a0function is not\u00a0virtual", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#chainid\u00a0function-is-not\u00a0virtual", "labels": ["OpenZeppelin"]}, {"title": "Within\u00a0SpokePool.sol, the\u00a0function\u00a0chainId\u00a0is marked\u00a0override. However,\u00a0the comments above it\u00a0indicate that the function should also be\u00a0overridable, meaning that it should be marked\u00a0virtual.", "body": "Within\u00a0SpokePool.sol, the\u00a0function\u00a0chainId\u00a0is marked\u00a0override. However,\u00a0the comments above it\u00a0indicate that the function should also be\u00a0overridable, meaning that it should be marked\u00a0virtual.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#within\u00a0spokepool.sol,-the\u00a0function\u00a0chainid\u00a0is-marked\u00a0override.-however,\u00a0the-comments-above-it\u00a0indicate-that-the-function-should-also-be\u00a0overridable,-meaning-that-it-should-be-marked\u00a0virtual.", "labels": ["OpenZeppelin"]}, {"title": "Consider marking the function\u00a0virtual\u00a0to allow overriding in contracts that inherit\u00a0SpokePool.", "body": "Consider marking the function\u00a0virtual\u00a0to allow overriding in contracts that inherit\u00a0SpokePool.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-marking-the-function\u00a0virtual\u00a0to-allow-overriding-in-contracts-that-inherit\u00a0spokepool.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #82\u00a0as of commit\u00a0cc48e5721ea444a22a84ddeeef8dcbfe191b112c.", "body": "Update:\u00a0Fixed in\u00a0pull request #82\u00a0as of commit\u00a0cc48e5721ea444a22a84ddeeef8dcbfe191b112c.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#82\u00a0as-of-commit\u00a0cc48e5721ea444a22a84ddeeef8dcbfe191b112c.", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "Lack of input validation", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase there are functions lacking sufficient input validation. For instance:", "body": "Throughout the codebase there are functions lacking sufficient input validation. For instance:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#throughout-the-codebase-there-are-functions-lacking-sufficient-input-validation.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0HubPool\u00a0contract the various\u00a0admin functions\u00a0will accept\u00a00\u00a0values for inputs. This could result in the loss of funds and unexpected behaviors if null values are unintentionally provided.", "body": "In the\u00a0HubPool\u00a0contract the various\u00a0admin functions\u00a0will accept\u00a00\u00a0values for inputs. This could result in the loss of funds and unexpected behaviors if null values are unintentionally provided.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0hubpool\u00a0contract-the-various\u00a0admin-functions\u00a0will-accept\u00a00\u00a0values-for-inputs.-this-could-result-in-the-loss-of-funds-and-unexpected-behaviors-if-null-values-are-unintentionally-provided.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0HubPool\u00a0contract the\u00a0setProtocolFeeCapture\u00a0function does not use the\u00a0noActiveRequests\u00a0modifier. This could allow the protocol fee to be increased even for liquidity providers that have already provided liquidity.", "body": "In the\u00a0HubPool\u00a0contract the\u00a0setProtocolFeeCapture\u00a0function does not use the\u00a0noActiveRequests\u00a0modifier. This could allow the protocol fee to be increased even for liquidity providers that have already provided liquidity.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0hubpool\u00a0contract-the\u00a0setprotocolfeecapture\u00a0function-does-not-use-the\u00a0noactiverequests\u00a0modifier.-this-could-allow-the-protocol-fee-to-be-increased-even-for-liquidity-providers-that-have-already-provided-liquidity.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0MerkleLib\u00a0library the\u00a0isClaimed1D\u00a0function does not work as expected if an\u00a0index\u00a0is greater than 255. In such a case, it will return\u00a0true\u00a0despite the fact that those values are not actually claimed.", "body": "In the\u00a0MerkleLib\u00a0library the\u00a0isClaimed1D\u00a0function does not work as expected if an\u00a0index\u00a0is greater than 255. In such a case, it will return\u00a0true\u00a0despite the fact that those values are not actually claimed.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0merklelib\u00a0library-the\u00a0isclaimed1d\u00a0function-does-not-work-as-expected-if-an\u00a0index\u00a0is-greater-than-255.-in-such-a-case,-it-will-return\u00a0true\u00a0despite-the-fact-that-those-values-are-not-actually-claimed.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0SpokePool\u00a0contract the\u00a0deposit\u00a0function does not enforce the requirement suggested by the\u00a0deploymentTime\u00a0comment\u00a0which says that relays cannot have a quote time before\u00a0deploymentTime.", "body": "In the\u00a0SpokePool\u00a0contract the\u00a0deposit\u00a0function does not enforce the requirement suggested by the\u00a0deploymentTime\u00a0comment\u00a0which says that relays cannot have a quote time before\u00a0deploymentTime.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0spokepool\u00a0contract-the\u00a0deposit\u00a0function-does-not-enforce-the-requirement-suggested-by-the\u00a0deploymenttime\u00a0comment\u00a0which-says-that-relays-cannot-have-a-quote-time-before\u00a0deploymenttime.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0SpokePool\u00a0contract the\u00a0speedUpDeposit\u00a0function does not restrict the\u00a0newRelayerFeePct\u00a0to be less than 50% like the\u00a0regular deposit does. In practice, the\u00a0_fillRelay\u00a0function won\u2019t accept a fee that is too high, but this should still be enforced within\u00a0speedUpDeposit.", "body": "In the\u00a0SpokePool\u00a0contract the\u00a0speedUpDeposit\u00a0function does not restrict the\u00a0newRelayerFeePct\u00a0to be less than 50% like the\u00a0regular deposit does. In practice, the\u00a0_fillRelay\u00a0function won\u2019t accept a fee that is too high, but this should still be enforced within\u00a0speedUpDeposit.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0spokepool\u00a0contract-the\u00a0speedupdeposit\u00a0function-does-not-restrict-the\u00a0newrelayerfeepct\u00a0to-be-less-than-50%-like-the\u00a0regular-deposit-does.-in-practice,-the\u00a0_fillrelay\u00a0function-won\u2019t-accept-a-fee-that-is-too-high,-but-this-should-still-be-enforced-within\u00a0speedupdeposit.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0PolygonTokenBridger\u00a0contract the \u201cnormal\u201d use case of\u00a0send\u00a0involves the caller,\u00a0Polygon_SpokePool,\u00a0evaluating\u00a0if the token it is sending is wrapped matic in order to set the\u00a0isMatic\u00a0flag appropriately. However, for any other caller, if they forget to set this flag while sending wrapped matic, then their tokens would be unwrapped but not sent anywhere. For more predictable behavior, consider checking for wrapped matic inline rather than relying on the\u00a0isMatic\u00a0argument.", "body": "In the\u00a0PolygonTokenBridger\u00a0contract the \u201cnormal\u201d use case of\u00a0send\u00a0involves the caller,\u00a0Polygon_SpokePool,\u00a0evaluating\u00a0if the token it is sending is wrapped matic in order to set the\u00a0isMatic\u00a0flag appropriately. However, for any other caller, if they forget to set this flag while sending wrapped matic, then their tokens would be unwrapped but not sent anywhere. For more predictable behavior, consider checking for wrapped matic inline rather than relying on the\u00a0isMatic\u00a0argument.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0polygontokenbridger\u00a0contract-the-\u201cnormal\u201d-use-case-of\u00a0send\u00a0involves-the-caller,\u00a0polygon_spokepool,\u00a0evaluating\u00a0if-the-token-it-is-sending-is-wrapped-matic-in-order-to-set-the\u00a0ismatic\u00a0flag-appropriately.-however,-for-any-other-caller,-if-they-forget-to-set-this-flag-while-sending-wrapped-matic,-then-their-tokens-would-be-unwrapped-but-not-sent-anywhere.-for-more-predictable-behavior,-consider-checking-for-wrapped-matic-inline-rather-than-relying-on-the\u00a0ismatic\u00a0argument.", "labels": ["OpenZeppelin"]}, {"title": "To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input, even that of admin accounts considering that some clients may default to sending null parameters if none are specified.", "body": "To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input, even that of admin accounts considering that some clients may default to sending null parameters if none are specified.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#to-avoid-errors-and-unexpected-system-behavior,-consider-implementing-require-statements-to-validate-all-user-controlled-input,-even-that-of-admin-accounts-considering-that-some-clients-may-default-to-sending-null-parameters-if-none-are-specified.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed with\u00a0pull request #113\u00a0as of commit\u00a04c4928866149dcec5bd6008c5ac8050f30898b7f\u00a0and\u00a0pull request #142\u00a0as of commit\u00a02b5cbc520415f4a2b16903504a29a9992a63d41c.", "body": "Update:\u00a0Fixed with\u00a0pull request #113\u00a0as of commit\u00a04c4928866149dcec5bd6008c5ac8050f30898b7f\u00a0and\u00a0pull request #142\u00a0as of commit\u00a02b5cbc520415f4a2b16903504a29a9992a63d41c.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-with\u00a0pull-request-#113\u00a0as-of-commit\u00a04c4928866149dcec5bd6008c5ac8050f30898b7f\u00a0and\u00a0pull-request-#142\u00a0as-of-commit\u00a02b5cbc520415f4a2b16903504a29a9992a63d41c.", "labels": ["OpenZeppelin"]}, {"title": "No good way to disable routes in HubPool", "body": "No good way to disable routes in HubPool", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#no-good-way-to-disable-routes-in-hubpool", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0SpokePool\u00a0there exists the\u00a0enabledDepositRoutes\u00a0mapping, which lists routes that have been approved for deposits (allowing a user to deposit in one spoke pool and withdraw the deposit from another). The\u00a0setEnableRoute\u00a0function\u00a0can be used to enable or disable these routes.", "body": "Within the\u00a0SpokePool\u00a0there exists the\u00a0enabledDepositRoutes\u00a0mapping, which lists routes that have been approved for deposits (allowing a user to deposit in one spoke pool and withdraw the deposit from another). The\u00a0setEnableRoute\u00a0function\u00a0can be used to enable or disable these routes.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#within-the\u00a0spokepool\u00a0there-exists-the\u00a0enableddepositroutes\u00a0mapping,-which-lists-routes-that-have-been-approved-for-deposits-(allowing-a-user-to-deposit-in-one-spoke-pool-and-withdraw-the-deposit-from-another).-the\u00a0setenableroute\u00a0function\u00a0can-be-used-to-enable-or-disable-these-routes.", "labels": ["OpenZeppelin"]}, {"title": "whitelistedRoutes\u00a0mapping, which determines", "body": "whitelistedRoutes\u00a0mapping, which determines", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#whitelistedroutes\u00a0mapping,-which-determines", "labels": ["OpenZeppelin"]}, {"title": "whether tokens can be sent to a certain spoke during rebalances. The only way to affect the", "body": "whether tokens can be sent to a certain spoke during rebalances. The only way to affect the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#whether-tokens-can-be-sent-to-a-certain-spoke-during-rebalances.-the-only-way-to-affect-the", "labels": ["OpenZeppelin"]}, {"title": "whitelistRoute, which includes a call to", "body": "whitelistRoute, which includes a call to", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#whitelistroute,-which-includes-a-call-to", "labels": ["OpenZeppelin"]}, {"title": "enable the\u00a0originToken/destinationChainId\u00a0pair\u00a0within the Spoke. This means that there is no good way to disable a whitelisted route in the hub without \u201cenabling\u201d the same route in the", "body": "enable the\u00a0originToken/destinationChainId\u00a0pair\u00a0within the Spoke. This means that there is no good way to disable a whitelisted route in the hub without \u201cenabling\u201d the same route in the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#enable-the\u00a0origintoken/destinationchainid\u00a0pair\u00a0within-the-spoke.-this-means-that-there-is-no-good-way-to-disable-a-whitelisted-route-in-the-hub-without-\u201cenabling\u201d-the-same-route-in-the", "labels": ["OpenZeppelin"]}, {"title": "Assuming that there may be cases in the future where it would be desirable to disable a certain deposit route, consider adding a function which can disable a\u00a0whitelistedRoutes\u00a0element (by setting the value in the mapping to\u00a0address(0)) without enabling the route in the SpokePool. It may be desirable to disable both atomically from the HubPool, or to establish a procedure to disable them independently in a specific order. Consider designing a procedure for valid cross-chain token transfers in the case that only one mapping has a certain route marked as \u201cdisabled\u201d, and including this in the UMIP for dispute resolution. Finally, note that any \u201catomic\u201d cancellations will still include a delay between when the message is initiated on the hub chain and when execution can be considered finalized on the spoke chain.", "body": "Assuming that there may be cases in the future where it would be desirable to disable a certain deposit route, consider adding a function which can disable a\u00a0whitelistedRoutes\u00a0element (by setting the value in the mapping to\u00a0address(0)) without enabling the route in the SpokePool. It may be desirable to disable both atomically from the HubPool, or to establish a procedure to disable them independently in a specific order. Consider designing a procedure for valid cross-chain token transfers in the case that only one mapping has a certain route marked as \u201cdisabled\u201d, and including this in the UMIP for dispute resolution. Finally, note that any \u201catomic\u201d cancellations will still include a delay between when the message is initiated on the hub chain and when execution can be considered finalized on the spoke chain.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#assuming-that-there-may-be-cases-in-the-future-where-it-would-be-desirable-to-disable-a-certain-deposit-route,-consider-adding-a-function-which-can-disable-a\u00a0whitelistedroutes\u00a0element-(by-setting-the-value-in-the-mapping-to\u00a0address(0))-without-enabling-the-route-in-the-spokepool.-it-may-be-desirable-to-disable-both-atomically-from-the-hubpool,-or-to-establish-a-procedure-to-disable-them-independently-in-a-specific-order.-consider-designing-a-procedure-for-valid-cross-chain-token-transfers-in-the-case-that-only-one-mapping-has-a-certain-route-marked-as-\u201cdisabled\u201d,-and-including-this-in-the-umip-for-dispute-resolution.-finally,-note-that-any-\u201catomic\u201d-cancellations-will-still-include-a-delay-between-when-the-message-is-initiated-on-the-hub-chain-and-when-execution-can-be-considered-finalized-on-the-spoke-chain.", "labels": ["OpenZeppelin"]}, {"title": "Polygon bridger does not enforce\u00a0chainId\u00a0requirements", "body": "Polygon bridger does not enforce\u00a0chainId\u00a0requirements", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#polygon-bridger-does-not-enforce\u00a0chainid\u00a0requirements", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0PolygonTokenBridger\u00a0contract\u2019s primary functions are only intended to be called either on l1\u00a0or\u00a0l2, but not both. In fact, calling the functions on the wrong chain could result in unexpected behavior and unnecessary confusion.", "body": "The\u00a0PolygonTokenBridger\u00a0contract\u2019s primary functions are only intended to be called either on l1\u00a0or\u00a0l2, but not both. In fact, calling the functions on the wrong chain could result in unexpected behavior and unnecessary confusion.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0polygontokenbridger\u00a0contract\u2019s-primary-functions-are-only-intended-to-be-called-either-on-l1\u00a0or\u00a0l2,-but-not-both.-in-fact,-calling-the-functions-on-the-wrong-chain-could-result-in-unexpected-behavior-and-unnecessary-confusion.", "labels": ["OpenZeppelin"]}, {"title": "In the best case, the functions will simply revert if called from the wrong chain because they will attempt to interact with other contracts that do not exist on that chain. For example, calling the\u00a0receive\u00a0function\u00a0(by sending the contract some native asset) could trigger reverts on Polygon, but not on Ethereum, because there is a WETH contract at the\u00a0l1Weth\u00a0address on the latter but not the former.", "body": "In the best case, the functions will simply revert if called from the wrong chain because they will attempt to interact with other contracts that do not exist on that chain. For example, calling the\u00a0receive\u00a0function\u00a0(by sending the contract some native asset) could trigger reverts on Polygon, but not on Ethereum, because there is a WETH contract at the\u00a0l1Weth\u00a0address on the latter but not the former.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the-best-case,-the-functions-will-simply-revert-if-called-from-the-wrong-chain-because-they-will-attempt-to-interact-with-other-contracts-that-do-not-exist-on-that-chain.-for-example,-calling-the\u00a0receive\u00a0function\u00a0(by-sending-the-contract-some-native-asset)-could-trigger-reverts-on-polygon,-but-not-on-ethereum,-because-there-is-a-weth-contract-at-the\u00a0l1weth\u00a0address-on-the-latter-but-not-the-former.", "labels": ["OpenZeppelin"]}, {"title": "However, in the worst case, it is possible that such calls will\u00a0not\u00a0revert, but result in lost funds instead. For example, if a WETH-like contract was later deployed to the\u00a0l1Weth\u00a0address on Polygon, then the call would not revert. Instead, tokens would be sent to that contract and could remain stuck there.", "body": "However, in the worst case, it is possible that such calls will\u00a0not\u00a0revert, but result in lost funds instead. For example, if a WETH-like contract was later deployed to the\u00a0l1Weth\u00a0address on Polygon, then the call would not revert. Instead, tokens would be sent to that contract and could remain stuck there.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#however,-in-the-worst-case,-it-is-possible-that-such-calls-will\u00a0not\u00a0revert,-but-result-in-lost-funds-instead.-for-example,-if-a-weth-like-contract-was-later-deployed-to-the\u00a0l1weth\u00a0address-on-polygon,-then-the-call-would-not-revert.-instead,-tokens-would-be-sent-to-that-contract-and-could-remain-stuck-there.", "labels": ["OpenZeppelin"]}, {"title": "Although the inline documentation details which function should be called on which chain, consider having the functions in this contract actively enforce these requirements via limiting execution to the correct\u00a0block.chainid.", "body": "Although the inline documentation details which function should be called on which chain, consider having the functions in this contract actively enforce these requirements via limiting execution to the correct\u00a0block.chainid.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#although-the-inline-documentation-details-which-function-should-be-called-on-which-chain,-consider-having-the-functions-in-this-contract-actively-enforce-these-requirements-via-limiting-execution-to-the-correct\u00a0block.chainid.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #115\u00a0as of commit\u00a0b80d7a5396d31662265bb28b61a1a3d09ed76760\u00a0and\u00a0pull request #128\u00a0as of commit\u00a0811ac20674d28189fd01297c05ce5b9e89f7a183.", "body": "Update:\u00a0Fixed in\u00a0pull request #115\u00a0as of commit\u00a0b80d7a5396d31662265bb28b61a1a3d09ed76760\u00a0and\u00a0pull request #128\u00a0as of commit\u00a0811ac20674d28189fd01297c05ce5b9e89f7a183.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#115\u00a0as-of-commit\u00a0b80d7a5396d31662265bb28b61a1a3d09ed76760\u00a0and\u00a0pull-request-#128\u00a0as-of-commit\u00a0811ac20674d28189fd01297c05ce5b9e89f7a183.", "labels": ["OpenZeppelin"]}, {"title": "Liquidity provisioning can skew fee assessments", "body": "Liquidity provisioning can skew fee assessments", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#liquidity-provisioning-can-skew-fee-assessments", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0HubPool\u00a0contract the\u00a0enableL1TokenForLiquidityProvision\u00a0function allows the contract\u00a0owner\u00a0to enable an\u00a0l1token\u00a0to be added to the protocol for liquidity pooling.", "body": "In the\u00a0HubPool\u00a0contract the\u00a0enableL1TokenForLiquidityProvision\u00a0function allows the contract\u00a0owner\u00a0to enable an\u00a0l1token\u00a0to be added to the protocol for liquidity pooling.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0hubpool\u00a0contract-the\u00a0enablel1tokenforliquidityprovision\u00a0function-allows-the-contract\u00a0owner\u00a0to-enable-an\u00a0l1token\u00a0to-be-added-to-the-protocol-for-liquidity-pooling.", "labels": ["OpenZeppelin"]}, {"title": "This is allowed even if the\u00a0l1token\u00a0is\u00a0already\u00a0currently enabled.", "body": "This is allowed even if the\u00a0l1token\u00a0is\u00a0already\u00a0currently enabled.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#this-is-allowed-even-if-the\u00a0l1token\u00a0is\u00a0already\u00a0currently-enabled.", "labels": ["OpenZeppelin"]}, {"title": "As this function also\u00a0sets the\u00a0lastLpFeeUpdate\u00a0variable\u00a0to the then-current\u00a0block.timestamp, enabling an already enabled token will skip over the period of time since\u00a0lastLpFeeUpdate\u00a0was last set. As a result, any LP fees that should have been assessed for that time period would simply never be assessed.", "body": "As this function also\u00a0sets the\u00a0lastLpFeeUpdate\u00a0variable\u00a0to the then-current\u00a0block.timestamp, enabling an already enabled token will skip over the period of time since\u00a0lastLpFeeUpdate\u00a0was last set. As a result, any LP fees that should have been assessed for that time period would simply never be assessed.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#as-this-function-also\u00a0sets-the\u00a0lastlpfeeupdate\u00a0variable\u00a0to-the-then-current\u00a0block.timestamp,-enabling-an-already-enabled-token-will-skip-over-the-period-of-time-since\u00a0lastlpfeeupdate\u00a0was-last-set.-as-a-result,-any-lp-fees-that-should-have-been-assessed-for-that-time-period-would-simply-never-be-assessed.", "labels": ["OpenZeppelin"]}, {"title": "Consider reverting if this function is called for an\u00a0l1token\u00a0that is already enabled.", "body": "Consider reverting if this function is called for an\u00a0l1token\u00a0that is already enabled.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-reverting-if-this-function-is-called-for-an\u00a0l1token\u00a0that-is-already-enabled.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #94\u00a0as of commit\u00a0b1a097748a82c3276619a06fa36358b574f843e1.", "body": "Update:\u00a0Fixed in\u00a0pull request #94\u00a0as of commit\u00a0b1a097748a82c3276619a06fa36358b574f843e1.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#94\u00a0as-of-commit\u00a0b1a097748a82c3276619a06fa36358b574f843e1.", "labels": ["OpenZeppelin"]}, {"title": "Some functions not marked\u00a0nonReentrant", "body": "Some functions not marked\u00a0nonReentrant", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#some-functions-not-marked\u00a0nonreentrant", "labels": ["OpenZeppelin"]}, {"title": "We have not identified any security issues relating to reentrancy. However, out of an abundance of caution, consider marking the following\u00a0public\u00a0functions in the\u00a0HubPool\u00a0contract as\u00a0nonReentrant. Consider that the\u00a0nonReentrant\u00a0modifier only works if both the original function, and the re-entered function are marked\u00a0nonReentrant.", "body": "We have not identified any security issues relating to reentrancy. However, out of an abundance of caution, consider marking the following\u00a0public\u00a0functions in the\u00a0HubPool\u00a0contract as\u00a0nonReentrant. Consider that the\u00a0nonReentrant\u00a0modifier only works if both the original function, and the re-entered function are marked\u00a0nonReentrant.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#we-have-not-identified-any-security-issues-relating-to-reentrancy.-however,-out-of-an-abundance-of-caution,-consider-marking-the-following\u00a0public\u00a0functions-in-the\u00a0hubpool\u00a0contract-as\u00a0nonreentrant.-consider-that-the\u00a0nonreentrant\u00a0modifier-only-works-if-both-the-original-function,-and-the-re-entered-function-are-marked\u00a0nonreentrant.", "labels": ["OpenZeppelin"]}, {"title": "setProtocolFeeCapture", "body": "setBond  setLiveness  setIdentifier  whitelistRoute  enableL1TokenForLiquidityProvision  disableL1TokenForLiquidityProvision  addLiquidity  Update: Fixed. Partially addressed in pull request #62 as of commit a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6 and then fully addressed in pull request #92 as of commit 7aa2fa8f46f8d40512857f35dd3ac64587c61f18.  Unexpected proposal cancellation  In the HubPool contract during a call to the disputeRootBundle function, if the bondAmount and finalFee values are the same, then the proposer bond passed to the optimistic oracle is zero.  When this happens, the optimistic oracle unilaterally sets the bond to the finalFee and then attempts to withdraw bond + final fee.  Since the HubPool only sets the allowance for the oracle to bondAmount rather than bondAmount + finalFee, this transfer will fail and, as a result, the proposal will be cancelled.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#setprotocolfeecapture", "labels": ["OpenZeppelin"]}, {"title": "setBond", "body": "function if the  proposeRootBundle function if  Update: Partially fixed in pull request #96 as of commit 671d416db0fe6d813e3761bda0e3132cb30a8e1d. The condition is checked in  but not in proposeRootBundle.  Time is cast unsafely  _updateAccumulatedLpFees, the return value of  getCurrentTime() is cast to a uint32 value. This means that the value will be truncated to fit within 32 bits, and at some point around Feb 6, 2106, it will roll over and the value returned by casting to  pooledToken.lastLpFeeUpdate to a much lower number than the previous  timeFromLastInteraction calculation will be exceedingly high, and all undistributed fees will be  accounted for as accumulated.  Again, note that this issue will only occur starting in the year 2106. Consider changing the size of the cast from uint32 to a larger number, like uint64. This should be more than enough to not encounter limits within a reasonably distant future. Alternatively, consider documenting the behavior and defining a procedure for what to do if the system is still in operation when the uint32 limit is hit, or for shutting down the system before the year 2106.  Update: Fixed in pull request #95 as of commit 2f59388906346780e729f2b879b643941ea314c9.  Notes & Additional Information  Missing link to referenced code  Within the Ethereum_Adapter, there is a mention of copying code from Governor.sol. It appears that the contract in question is Governor.sol from the UMAprotocol/protocol repository.  Since it is a part of a separate repository, and it is possible that the code may change in the future, consider including a link to the file, including a commit hash, so that it can be easily referenced by developers and reviewers in the future.  Update: Fixed in pull request #97 as of commit ac9ed389914dc4249f488226fcd94d6d0b44aeb0.  Inconsistent approach to struct definitions  PoolRebalanceLeaf struct is defined in  RootBundle,  PooledToken, and  CrossChainContract structs are all defined in the implementation,  Consider defining all structs for HubPool within the same contract.  Update: Fixed in pull request #100 as of commit 9a98ce1ae5c8c5e95bcfa979666b980008d14d3f.  Inconsistent token metadata versioning  In the LpTokenFactory contract, the LP tokens it creates have inconsistent versioning in their metadata.  While the token symbol is prepended with Av2 (ostensibly for Across version 2), the token name is prepended only with Across and no version number.  Consider adding the version number to the token name, or, alteratively, leaving an inline comment explaining the decision to omit the version number.  Update: Fixed in pull request #101 as of commit 91a08a9bd2b47a1a1319aff8bda53349e8264ce3.  Lack of documentation  Although most of the codebase is thoroughly documented, there are a few instances where documentation is lacking. For instance:  In the HubPool contract the public unclaimedAccumulatedProtocolFees variable has no inline documentation.  In the HubPoolInterface contract the inline documentation accompanying PoolRebalanceLeaf.netSendAmounts, although lengthy, could benefit from additional clarification around the case of negative values. It could clarify further that in such cases the actual netSendAmounts value is ignored, but it should match the amountToReturn parameter in the RelayerRefundLeaf.  Many of the functions in the MerkleLib library are missing NatSpec @return statements.  To further clarify intent and improve overall code readability, consider adding additional inline documentation where indicated above.  Update: Fixed in pull request #102 as of commit e2bfe128ff1a9aeed02bfcebe58a5880ad283698.  Magic values  LpTokenFactory contract, when the  createLpToken function is called, it creates a new ERC20 LP token and adds the  role assignments use the  magic values 1 and 2, which are the  Rather than using these literal values to assign roles, consider using the the ExpandedERC20.addMinter and ExpandedERC20.addBurner functions.  Update: Fixed in pull request #103 as of commit e9d3419ac6eb609b0c9165cdeac3fbff58285d18.  Misleading Comments  HubPool lines 718-719 explain that the whitelistedRoute function returns whitelisted destination tokens, but does not mention that if the token is not whitelisted then the function returns address(0).  The comments in the declaration of the PoolRebalanceLeaf struct appear to refer to a previous version of the struct, making them hard to follow. For example, line 17 implies there are two arrays above it (there is only one), and line 31 suggests there are multiple arrays below it (there is only one).  A comment about HubPool.executeRootBundle states that the function deletes the published root bundle, however it does not.  Within the LPTokenFactory contract, the comments on lines 24 and 25 should say msg.sender or the calling contract rather than this contract.  The comments above the lpFeeRatePerSecond variable suggest that LP fees are released linearly. In fact, they are released sublinearly, because the ", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#setbond", "labels": ["OpenZeppelin"]}, {"title": "setLiveness", "body": "setLiveness", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#setliveness", "labels": ["OpenZeppelin"]}, {"title": "setIdentifier", "body": "setIdentifier", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#setidentifier", "labels": ["OpenZeppelin"]}, {"title": "whitelistRoute", "body": "whitelistRoute", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#whitelistroute", "labels": ["OpenZeppelin"]}, {"title": "enableL1TokenForLiquidityProvision", "body": "disableL1TokenForLiquidityProvision  addLiquidity  Update: Fixed. Partially addressed in pull request #62 as of commit a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6 and then fully addressed in pull request #92 as of commit 7aa2fa8f46f8d40512857f35dd3ac64587c61f18.  Unexpected proposal cancellation  In the HubPool contract during a call to the disputeRootBundle function, if the bondAmount and finalFee values are the same, then the proposer bond passed to the optimistic oracle is zero.  When this happens, the optimistic oracle unilaterally sets the bond to the finalFee and then attempts to withdraw bond + final fee.  Since the HubPool only sets the allowance for the oracle to bondAmount rather than bondAmount + finalFee, this transfer will fail and, as a result, the proposal will be cancelled.  setBond function if the  proposeRootBundle function if  Update: Partially fixed in pull request #96 as of commit 671d416db0fe6d813e3761bda0e3132cb30a8e1d. The condition is checked in setBond but not in proposeRootBundle.  Time is cast unsafely  _updateAccumulatedLpFees, the return value of  getCurrentTime() is cast to a uint32 value. This means that the value will be truncated to fit within 32 bits, and at some point around Feb 6, 2106, it will roll over and the value returned by casting to  pooledToken.lastLpFeeUpdate to a much lower number than the previous  timeFromLastInteraction calculation will be exceedingly high, and all undistributed fees will be  accounted for as accumulated.  Again, note that this issue will only occur starting in the year 2106. Consider changing the size of the cast from uint32 to a larger number, like uint64. This should be more than enough to not encounter limits within a reasonably distant future. Alternatively, consider documenting the behavior and defining a procedure for what to do if the system is still in operation when the uint32 limit is hit, or for shutting down the system before the year 2106.  Update: Fixed in pull request #95 as of commit 2f59388906346780e729f2b879b643941ea314c9.  Notes & Additional Information  Missing link to referenced code  Within the Ethereum_Adapter, there is a mention of copying code from Governor.sol. It appears that the contract in question is Governor.sol from the UMAprotocol/protocol repository.  Since it is a part of a separate repository, and it is possible that the code may change in the future, consider including a link to the file, including a commit hash, so that it can be easily referenced by developers and reviewers in the future.  Update: Fixed in pull request #97 as of commit ac9ed389914dc4249f488226fcd94d6d0b44aeb0.  Inconsistent approach to struct definitions  PoolRebalanceLeaf struct is defined in  RootBundle,  PooledToken, and  CrossChainContract structs are all defined in the implementation,  Consider defining all structs for HubPool within the same contract.  Update: Fixed in pull request #100 as of commit 9a98ce1ae5c8c5e95bcfa979666b980008d14d3f.  Inconsistent token metadata versioning  In the LpTokenFactory contract, the LP tokens it creates have inconsistent versioning in their metadata.  While the token symbol is prepended with Av2 (ostensibly for Across version 2), the token name is prepended only with Across and no version number.  Consider adding the version number to the token name, or, alteratively, leaving an inline comment explaining the decision to omit the version number.  Update: Fixed in pull request #101 as of commit 91a08a9bd2b47a1a1319aff8bda53349e8264ce3.  Lack of documentation  Although most of the codebase is thoroughly documented, there are a few instances where documentation is lacking. For instance:  In the HubPool contract the public unclaimedAccumulatedProtocolFees variable has no inline documentation.  In the HubPoolInterface contract the inline documentation accompanying PoolRebalanceLeaf.netSendAmounts, although lengthy, could benefit from additional clarification around the case of negative values. It could clarify further that in such cases the actual netSendAmounts value is ignored, but it should match the amountToReturn parameter in the RelayerRefundLeaf.  Many of the functions in the MerkleLib library are missing NatSpec @return statements.  To further clarify intent and improve overall code readability, consider adding additional inline documentation where indicated above.  Update: Fixed in pull request #102 as of commit e2bfe128ff1a9aeed02bfcebe58a5880ad283698.  Magic values  LpTokenFactory contract, when the  createLpToken function is called, it creates a new ERC20 LP token and adds the  role assignments use the  magic values 1 and 2, which are the  Rather than using these literal values to assign roles, consider using the the ExpandedERC20.addMinter and ExpandedERC20.addBurner functions.  Update: Fixed in pull request #103 as of commit e9d3419ac6eb609b0c9165cdeac3fbff58285d18.  Misleading Comments  HubPool lines 718-719 explain that the whitelistedRoute function returns whitelisted destination tokens,", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#enablel1tokenforliquidityprovision", "labels": ["OpenZeppelin"]}, {"title": "disableL1TokenForLiquidityProvision", "body": "disableL1TokenForLiquidityProvision", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#disablel1tokenforliquidityprovision", "labels": ["OpenZeppelin"]}, {"title": "addLiquidity", "body": "function, assume the amount transferred in equals the amount received.  ERC777 tokens, which are ERC20-compatible, include hooks on transfers. These hooks are configurable and may be configured to revert in some or all cases. In SpokePool._executeRelayerRefundRoot, a failing transfer for one token could block all other refunds for the specified leaf.  Tokens which are upgradeable may change their implementations to become subject to the above issues, even though they may not have been problematic before being upgraded.  Consider documenting procedures for tokens which behave unexpectedly to be filtered for before whitelisting.  Update: Fixed in pull request #137 as of commit ba6e03974cf722d33b9fb2def4da578129f5baed.  Not using immutable  Within the HubPool contract, the weth, finder, and lpTokenFactory variables are only ever assigned a value in the constructor.  Consider marking these values as immutable to better signal the fact that these values or not meant to change and to reduce the overall gas consumption of the contract.  Update: Fixed in pull request #108 as of commit cccb9556345edcc5d8fc3022ab64a5b368c8d810.  Residual privileged roles  LpTokenFactory contract  creates an ExpandedERC20 token contract, the factory becomes the  owner of that token contract. The factory then proceeds to  assign the minter and burner roles to the  As this is a residual power that is no longer needed by the LpTokenFactory, consider reducing the number of addresses with privileged roles by transferring ownership to the msg.sender.  Update: Fixed in pull request #109 as of commit 21cdccd5cbfffd4f120ab56c2691b8e961a8d323.  Typographical errors  In HubPool.sol:  line 99: Heler should be Helper  line 201: proposal should be Proposal  line 235: its should be its  line 294: disputes.. should be disputes.  line 377: for again should be again.  line 419: access more funds that should be to access more funds than  line 475: to along should be along  line 480: leafs should be leaves  line 532: neccessary should be necessary  line 568: to back should be back  line 569: leafs should be leaves  line 569: wont should be wont  line 865: timeFromLastInteraction ,undistributedLpFees) should be timeFromLastInteraction, undistributedLpFees)  line 866: a fees. should be fees.  line 913: decrease should be decreased  line 962: send should be sent  In HubPoolInterface.sol:  line 13: sent should be send  In MerkleLib.sol:  line 86: \\* should be *  In Polygon_SpokePool.sol:  line 43: priviledges should be privileges  In SpokePool.sol:  line 55: token should be chain  line 67: leafs should be leaves  line 292: users should be users  line 347: receipient. should be recipient.  In SpokePoolInterface.sol:  line 11: inverted. should be negated.  line 27: a the should be the  Update: Fixed in pull request #110 as of commit 813cfeef126484e0ac5b7fb91225560c5edbff7c.  Undocumented implicit approval requirements  Throughout the codebase, when the safeTransferFrom function is used to transfer assets into the system from an external address there is an implicit requirement that the external address has already granted the appropriate approvals.  For instance:  The proposeRootBundle function relies on safeTransferFrom which requires that HubPool has been granted an allowance of bondAmount bondTokens by the caller.  The  function relies on safeTransferFrom, requiring that the HubPool has been granted an l1TokenAmount allowance of the callers l1Token.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed in pull request #111 as of commit 5a3ef77a22b81411a3616bb48acf063acabb4d2c.  Unused code  Throughout the codebase, there are instances of unused code. For example:  The proposerBondRepaid attribute of the HubPool contracts RootBundle struct is never used. Consider removing it.  The events in the Arbitrum_Adapter contract are never used. As the relevant state variables are immutable, consider setting all relevant values in the constructor and emitting these events then. Alternatively, consider adding comments indicating why events are declared but unused.  The L2GasLimitSet event in the Optimism_Adapter is never emitted. Consider emitting it in the constructor, removing it, or adding a comment indicating why it is declared but not used.  The HubPoolChanged event is never used.  Update: Fixed in pull request #78 as of commit f7e8518050a12e478516da6622bcf2357bb2e802 and in pull request #99 as of commit d89b1fb8d491703ef63dae0b29d93abd29d501de.  Unnecessary import statements  The below list outlines contract import statements that are unnecessary:  The WETH9 and Lockable imports are not used in the Ethereum_Adapter contract.  The CrossDomainEnabled, IL1StandardBridge, and Lockable imports are not used in the Polygon_Adapter contract.  The WETH9 and IERC20 imports are not used in the Arbitrum_Adapter contract.  The AdapterInterface ", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#addliquidity", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed. Partially addressed in\u00a0pull request #62\u00a0as of commit\u00a0a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6\u00a0and then fully addressed in\u00a0pull request #92\u00a0as of commit\u00a07aa2fa8f46f8d40512857f35dd3ac64587c61f18.", "body": "Update:\u00a0Fixed. Partially addressed in\u00a0pull request #62\u00a0as of commit\u00a0a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6\u00a0and then fully addressed in\u00a0pull request #92\u00a0as of commit\u00a07aa2fa8f46f8d40512857f35dd3ac64587c61f18.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed.-partially-addressed-in\u00a0pull-request-#62\u00a0as-of-commit\u00a0a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6\u00a0and-then-fully-addressed-in\u00a0pull-request-#92\u00a0as-of-commit\u00a07aa2fa8f46f8d40512857f35dd3ac64587c61f18.", "labels": ["OpenZeppelin"]}, {"title": "Unexpected proposal cancellation", "body": "Unexpected proposal cancellation", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#unexpected-proposal-cancellation", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0HubPool\u00a0contract during a call to the\u00a0disputeRootBundle\u00a0function, if the\u00a0bondAmount\u00a0and\u00a0finalFee\u00a0values are the same, then the proposer bond passed to the optimistic oracle\u00a0is zero.", "body": "In the\u00a0HubPool\u00a0contract during a call to the\u00a0disputeRootBundle\u00a0function, if the\u00a0bondAmount\u00a0and\u00a0finalFee\u00a0values are the same, then the proposer bond passed to the optimistic oracle\u00a0is zero.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0hubpool\u00a0contract-during-a-call-to-the\u00a0disputerootbundle\u00a0function,-if-the\u00a0bondamount\u00a0and\u00a0finalfee\u00a0values-are-the-same,-then-the-proposer-bond-passed-to-the-optimistic-oracle\u00a0is-zero.", "labels": ["OpenZeppelin"]}, {"title": "When this happens, the optimistic oracle unilaterally\u00a0sets the bond to the\u00a0finalFee\u00a0and then attempts to\u00a0withdraw\u00a0bond + final fee.", "body": "When this happens, the optimistic oracle unilaterally\u00a0sets the bond to the\u00a0finalFee\u00a0and then attempts to\u00a0withdraw\u00a0bond + final fee.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#when-this-happens,-the-optimistic-oracle-unilaterally\u00a0sets-the-bond-to-the\u00a0finalfee\u00a0and-then-attempts-to\u00a0withdraw\u00a0bond-+-final-fee.", "labels": ["OpenZeppelin"]}, {"title": "Since the\u00a0HubPool\u00a0only\u00a0sets the allowance for the oracle to\u00a0bondAmount\u00a0rather than\u00a0bondAmount + finalFee, this transfer will fail and, as a result,\u00a0the proposal will be cancelled.", "body": "Since the\u00a0HubPool\u00a0only\u00a0sets the allowance for the oracle to\u00a0bondAmount\u00a0rather than\u00a0bondAmount + finalFee, this transfer will fail and, as a result,\u00a0the proposal will be cancelled.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#since-the\u00a0hubpool\u00a0only\u00a0sets-the-allowance-for-the-oracle-to\u00a0bondamount\u00a0rather-than\u00a0bondamount-+-finalfee,-this-transfer-will-fail-and,-as-a-result,\u00a0the-proposal-will-be-cancelled.", "labels": ["OpenZeppelin"]}, {"title": "setBond\u00a0function if the", "body": "setBond\u00a0function if the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#setbond\u00a0function-if-the", "labels": ["OpenZeppelin"]}, {"title": "proposeRootBundle\u00a0function if", "body": "proposeRootBundle\u00a0function if", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#proposerootbundle\u00a0function-if", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Partially fixed in\u00a0pull request #96\u00a0as of commit\u00a0671d416db0fe6d813e3761bda0e3132cb30a8e1d. The condition is checked in\u00a0setBond\u00a0but not in\u00a0proposeRootBundle.", "body": "Update:\u00a0Partially fixed in\u00a0pull request #96\u00a0as of commit\u00a0671d416db0fe6d813e3761bda0e3132cb30a8e1d. The condition is checked in\u00a0setBond\u00a0but not in\u00a0proposeRootBundle.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0partially-fixed-in\u00a0pull-request-#96\u00a0as-of-commit\u00a0671d416db0fe6d813e3761bda0e3132cb30a8e1d.-the-condition-is-checked-in\u00a0setbond\u00a0but-not-in\u00a0proposerootbundle.", "labels": ["OpenZeppelin"]}, {"title": "Time is cast unsafely", "body": "Time is cast unsafely", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#time-is-cast-unsafely", "labels": ["OpenZeppelin"]}, {"title": "_updateAccumulatedLpFees, the return value of", "body": "_updateAccumulatedLpFees, the return value of", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#_updateaccumulatedlpfees,-the-return-value-of", "labels": ["OpenZeppelin"]}, {"title": "getCurrentTime()\u00a0is cast to a\u00a0uint32\u00a0value. This means that the value will be truncated to fit within 32 bits, and at some point around Feb 6, 2106, it will \u201croll over\u201d and the value returned by casting to", "body": "getCurrentTime()\u00a0is cast to a\u00a0uint32\u00a0value. This means that the value will be truncated to fit within 32 bits, and at some point around Feb 6, 2106, it will \u201croll over\u201d and the value returned by casting to", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#getcurrenttime()\u00a0is-cast-to-a\u00a0uint32\u00a0value.-this-means-that-the-value-will-be-truncated-to-fit-within-32-bits,-and-at-some-point-around-feb-6,-2106,-it-will-\u201croll-over\u201d-and-the-value-returned-by-casting-to", "labels": ["OpenZeppelin"]}, {"title": "pooledToken.lastLpFeeUpdate\u00a0to a much lower number than the previous", "body": "pooledToken.lastLpFeeUpdate\u00a0to a much lower number than the previous", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#pooledtoken.lastlpfeeupdate\u00a0to-a-much-lower-number-than-the-previous", "labels": ["OpenZeppelin"]}, {"title": "timeFromLastInteraction\u00a0calculation\u00a0will be exceedingly high, and all \u201cundistributed\u201d fees will be", "body": "timeFromLastInteraction\u00a0calculation\u00a0will be exceedingly high, and all \u201cundistributed\u201d fees will be", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#timefromlastinteraction\u00a0calculation\u00a0will-be-exceedingly-high,-and-all-\u201cundistributed\u201d-fees-will-be", "labels": ["OpenZeppelin"]}, {"title": "accounted for as accumulated.", "body": "accounted for as accumulated.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#accounted-for-as-accumulated.", "labels": ["OpenZeppelin"]}, {"title": "Again, note that this issue will only occur starting in the year 2106. Consider changing the size of the cast from\u00a0uint32\u00a0to a larger number, like\u00a0uint64. This should be more than enough to not encounter limits within a reasonably distant future. Alternatively, consider documenting the behavior and defining a procedure for what to do if the system is still in operation when the\u00a0uint32\u00a0limit is hit, or for shutting down the system before the year 2106.", "body": "Again, note that this issue will only occur starting in the year 2106. Consider changing the size of the cast from\u00a0uint32\u00a0to a larger number, like\u00a0uint64. This should be more than enough to not encounter limits within a reasonably distant future. Alternatively, consider documenting the behavior and defining a procedure for what to do if the system is still in operation when the\u00a0uint32\u00a0limit is hit, or for shutting down the system before the year 2106.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#again,-note-that-this-issue-will-only-occur-starting-in-the-year-2106.-consider-changing-the-size-of-the-cast-from\u00a0uint32\u00a0to-a-larger-number,-like\u00a0uint64.-this-should-be-more-than-enough-to-not-encounter-limits-within-a-reasonably-distant-future.-alternatively,-consider-documenting-the-behavior-and-defining-a-procedure-for-what-to-do-if-the-system-is-still-in-operation-when-the\u00a0uint32\u00a0limit-is-hit,-or-for-shutting-down-the-system-before-the-year-2106.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #95\u00a0as of commit\u00a02f59388906346780e729f2b879b643941ea314c9.", "body": "Update:\u00a0Fixed in\u00a0pull request #95\u00a0as of commit\u00a02f59388906346780e729f2b879b643941ea314c9.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#95\u00a0as-of-commit\u00a02f59388906346780e729f2b879b643941ea314c9.", "labels": ["OpenZeppelin"]}, {"title": "Missing link to referenced code", "body": "Missing link to referenced code", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#missing-link-to-referenced-code", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0Ethereum_Adapter, there is a mention of\u00a0copying code from \u201cGovernor.sol\u201d. It appears that the contract in question is\u00a0Governor.sol\u00a0from the\u00a0UMAprotocol/protocol\u00a0repository.", "body": "Within the\u00a0Ethereum_Adapter, there is a mention of\u00a0copying code from \u201cGovernor.sol\u201d. It appears that the contract in question is\u00a0Governor.sol\u00a0from the\u00a0UMAprotocol/protocol\u00a0repository.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#within-the\u00a0ethereum_adapter,-there-is-a-mention-of\u00a0copying-code-from-\u201cgovernor.sol\u201d.-it-appears-that-the-contract-in-question-is\u00a0governor.sol\u00a0from-the\u00a0umaprotocol/protocol\u00a0repository.", "labels": ["OpenZeppelin"]}, {"title": "Since it is a part of a separate repository, and it is possible that the code may change in the future, consider including a link to the file, including a commit hash, so that it can be easily referenced by developers and reviewers in the future.", "body": "Since it is a part of a separate repository, and it is possible that the code may change in the future, consider including a link to the file, including a commit hash, so that it can be easily referenced by developers and reviewers in the future.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#since-it-is-a-part-of-a-separate-repository,-and-it-is-possible-that-the-code-may-change-in-the-future,-consider-including-a-link-to-the-file,-including-a-commit-hash,-so-that-it-can-be-easily-referenced-by-developers-and-reviewers-in-the-future.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #97\u00a0as of commit\u00a0ac9ed389914dc4249f488226fcd94d6d0b44aeb0.", "body": "Update:\u00a0Fixed in\u00a0pull request #97\u00a0as of commit\u00a0ac9ed389914dc4249f488226fcd94d6d0b44aeb0.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#97\u00a0as-of-commit\u00a0ac9ed389914dc4249f488226fcd94d6d0b44aeb0.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent approach to\u00a0struct\u00a0definitions", "body": "Inconsistent approach to\u00a0struct\u00a0definitions", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#inconsistent-approach-to\u00a0struct\u00a0definitions", "labels": ["OpenZeppelin"]}, {"title": "PoolRebalanceLeaf\u00a0struct is defined in", "body": "PoolRebalanceLeaf\u00a0struct is defined in", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#poolrebalanceleaf\u00a0struct-is-defined-in", "labels": ["OpenZeppelin"]}, {"title": "RootBundle,", "body": "RootBundle,", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#rootbundle,", "labels": ["OpenZeppelin"]}, {"title": "PooledToken, and", "body": "PooledToken, and", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#pooledtoken,-and", "labels": ["OpenZeppelin"]}, {"title": "CrossChainContract\u00a0structs are all defined in the implementation,", "body": "CrossChainContract\u00a0structs are all defined in the implementation,", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#crosschaincontract\u00a0structs-are-all-defined-in-the-implementation,", "labels": ["OpenZeppelin"]}, {"title": "Consider defining all\u00a0structs for\u00a0HubPool\u00a0within the same contract.", "body": "Consider defining all\u00a0structs for\u00a0HubPool\u00a0within the same contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-defining-all\u00a0structs-for\u00a0hubpool\u00a0within-the-same-contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #100\u00a0as of commit\u00a09a98ce1ae5c8c5e95bcfa979666b980008d14d3f.", "body": "Update:\u00a0Fixed in\u00a0pull request #100\u00a0as of commit\u00a09a98ce1ae5c8c5e95bcfa979666b980008d14d3f.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#100\u00a0as-of-commit\u00a09a98ce1ae5c8c5e95bcfa979666b980008d14d3f.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent token metadata versioning", "body": "Inconsistent token metadata versioning", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#inconsistent-token-metadata-versioning", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0LpTokenFactory\u00a0contract, the LP tokens it creates have inconsistent versioning in their metadata.", "body": "In the\u00a0LpTokenFactory\u00a0contract, the LP tokens it creates have inconsistent versioning in their metadata.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0lptokenfactory\u00a0contract,-the-lp-tokens-it-creates-have-inconsistent-versioning-in-their-metadata.", "labels": ["OpenZeppelin"]}, {"title": "While the token\u00a0symbol\u00a0is\u00a0prepended with\u00a0Av2\u00a0(ostensibly for \u201cAcross version 2\u201d), the token\u00a0name\u00a0is\u00a0prepended only with \u201cAcross\u201d and no version number.", "body": "While the token\u00a0symbol\u00a0is\u00a0prepended with\u00a0Av2\u00a0(ostensibly for \u201cAcross version 2\u201d), the token\u00a0name\u00a0is\u00a0prepended only with \u201cAcross\u201d and no version number.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#while-the-token\u00a0symbol\u00a0is\u00a0prepended-with\u00a0av2\u00a0(ostensibly-for-\u201cacross-version-2\u201d),-the-token\u00a0name\u00a0is\u00a0prepended-only-with-\u201cacross\u201d-and-no-version-number.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding the version number to the token\u00a0name, or, alteratively, leaving an inline comment explaining the decision to omit the version number.", "body": "Consider adding the version number to the token\u00a0name, or, alteratively, leaving an inline comment explaining the decision to omit the version number.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-adding-the-version-number-to-the-token\u00a0name,-or,-alteratively,-leaving-an-inline-comment-explaining-the-decision-to-omit-the-version-number.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #101\u00a0as of commit\u00a091a08a9bd2b47a1a1319aff8bda53349e8264ce3.", "body": "Update:\u00a0Fixed in\u00a0pull request #101\u00a0as of commit\u00a091a08a9bd2b47a1a1319aff8bda53349e8264ce3.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#101\u00a0as-of-commit\u00a091a08a9bd2b47a1a1319aff8bda53349e8264ce3.", "labels": ["OpenZeppelin"]}, {"title": "Lack of documentation", "body": "Lack of documentation", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#lack-of-documentation", "labels": ["OpenZeppelin"]}, {"title": "Although most of the codebase is thoroughly documented, there are a few instances where documentation is lacking. For instance:", "body": "Although most of the codebase is thoroughly documented, there are a few instances where documentation is lacking. For instance:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#although-most-of-the-codebase-is-thoroughly-documented,-there-are-a-few-instances-where-documentation-is-lacking.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0HubPool\u00a0contract the public\u00a0unclaimedAccumulatedProtocolFees\u00a0variable has no inline documentation.", "body": "In the\u00a0HubPool\u00a0contract the public\u00a0unclaimedAccumulatedProtocolFees\u00a0variable has no inline documentation.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0hubpool\u00a0contract-the-public\u00a0unclaimedaccumulatedprotocolfees\u00a0variable-has-no-inline-documentation.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0HubPoolInterface\u00a0contract the inline documentation accompanying\u00a0PoolRebalanceLeaf.netSendAmounts, although lengthy, could benefit from additional clarification around the case of negative values. It could clarify further that in such cases the actual\u00a0netSendAmounts\u00a0value is ignored, but it should match the\u00a0amountToReturn\u00a0parameter in the\u00a0RelayerRefundLeaf.", "body": "In the\u00a0HubPoolInterface\u00a0contract the inline documentation accompanying\u00a0PoolRebalanceLeaf.netSendAmounts, although lengthy, could benefit from additional clarification around the case of negative values. It could clarify further that in such cases the actual\u00a0netSendAmounts\u00a0value is ignored, but it should match the\u00a0amountToReturn\u00a0parameter in the\u00a0RelayerRefundLeaf.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0hubpoolinterface\u00a0contract-the-inline-documentation-accompanying\u00a0poolrebalanceleaf.netsendamounts,-although-lengthy,-could-benefit-from-additional-clarification-around-the-case-of-negative-values.-it-could-clarify-further-that-in-such-cases-the-actual\u00a0netsendamounts\u00a0value-is-ignored,-but-it-should-match-the\u00a0amounttoreturn\u00a0parameter-in-the\u00a0relayerrefundleaf.", "labels": ["OpenZeppelin"]}, {"title": "Many of the functions in the\u00a0MerkleLib\u00a0library are missing NatSpec\u00a0@return\u00a0statements.", "body": "Many of the functions in the\u00a0MerkleLib\u00a0library are missing NatSpec\u00a0@return\u00a0statements.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#many-of-the-functions-in-the\u00a0merklelib\u00a0library-are-missing-natspec\u00a0@return\u00a0statements.", "labels": ["OpenZeppelin"]}, {"title": "To further clarify intent and improve overall code readability, consider adding additional inline documentation where indicated above.", "body": "To further clarify intent and improve overall code readability, consider adding additional inline documentation where indicated above.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#to-further-clarify-intent-and-improve-overall-code-readability,-consider-adding-additional-inline-documentation-where-indicated-above.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #102\u00a0as of commit\u00a0e2bfe128ff1a9aeed02bfcebe58a5880ad283698.", "body": "Update:\u00a0Fixed in\u00a0pull request #102\u00a0as of commit\u00a0e2bfe128ff1a9aeed02bfcebe58a5880ad283698.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#102\u00a0as-of-commit\u00a0e2bfe128ff1a9aeed02bfcebe58a5880ad283698.", "labels": ["OpenZeppelin"]}, {"title": "Magic values", "body": "Magic values", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#magic-values", "labels": ["OpenZeppelin"]}, {"title": "LpTokenFactory\u00a0contract, when the", "body": "LpTokenFactory\u00a0contract, when the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#lptokenfactory\u00a0contract,-when-the", "labels": ["OpenZeppelin"]}, {"title": "createLpToken\u00a0function is called, it creates a new ERC20 LP token and adds the", "body": "createLpToken\u00a0function is called, it creates a new ERC20 LP token and adds the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#createlptoken\u00a0function-is-called,-it-creates-a-new-erc20-lp-token-and-adds-the", "labels": ["OpenZeppelin"]}, {"title": "role assignments\u00a0use the", "body": "role assignments\u00a0use the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#role-assignments\u00a0use-the", "labels": ["OpenZeppelin"]}, {"title": "magic values\u00a01\u00a0and\u00a02, which are the", "body": "magic values\u00a01\u00a0and\u00a02, which are the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#magic-values\u00a01\u00a0and\u00a02,-which-are-the", "labels": ["OpenZeppelin"]}, {"title": "Rather than using these literal values to assign roles, consider using the the\u00a0ExpandedERC20.addMinter\u00a0and\u00a0ExpandedERC20.addBurner\u00a0functions.", "body": "Rather than using these literal values to assign roles, consider using the the\u00a0ExpandedERC20.addMinter\u00a0and\u00a0ExpandedERC20.addBurner\u00a0functions.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#rather-than-using-these-literal-values-to-assign-roles,-consider-using-the-the\u00a0expandederc20.addminter\u00a0and\u00a0expandederc20.addburner\u00a0functions.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #103\u00a0as of commit\u00a0e9d3419ac6eb609b0c9165cdeac3fbff58285d18.", "body": "Update:\u00a0Fixed in\u00a0pull request #103\u00a0as of commit\u00a0e9d3419ac6eb609b0c9165cdeac3fbff58285d18.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#103\u00a0as-of-commit\u00a0e9d3419ac6eb609b0c9165cdeac3fbff58285d18.", "labels": ["OpenZeppelin"]}, {"title": "Misleading Comments", "body": "Misleading Comments", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "HubPool\u00a0lines 718-719\u00a0explain that the\u00a0whitelistedRoute\u00a0function\u00a0returns whitelisted destination tokens, but does not mention that if the token is\u00a0not\u00a0whitelisted then the function returns\u00a0address(0).", "body": "HubPool\u00a0lines 718-719\u00a0explain that the\u00a0whitelistedRoute\u00a0function\u00a0returns whitelisted destination tokens, but does not mention that if the token is\u00a0not\u00a0whitelisted then the function returns\u00a0address(0).", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#hubpool\u00a0lines-718-719\u00a0explain-that-the\u00a0whitelistedroute\u00a0function\u00a0returns-whitelisted-destination-tokens,-but-does-not-mention-that-if-the-token-is\u00a0not\u00a0whitelisted-then-the-function-returns\u00a0address(0).", "labels": ["OpenZeppelin"]}, {"title": "The comments in the declaration of the\u00a0PoolRebalanceLeaf\u00a0struct\u00a0appear to refer to a previous version of the struct, making them hard to follow. For example,\u00a0line 17\u00a0implies there are two arrays above it (there is only one), and\u00a0line 31\u00a0suggests there are multiple arrays below it (there is only one).", "body": "The comments in the declaration of the\u00a0PoolRebalanceLeaf\u00a0struct\u00a0appear to refer to a previous version of the struct, making them hard to follow. For example,\u00a0line 17\u00a0implies there are two arrays above it (there is only one), and\u00a0line 31\u00a0suggests there are multiple arrays below it (there is only one).", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the-comments-in-the-declaration-of-the\u00a0poolrebalanceleaf\u00a0struct\u00a0appear-to-refer-to-a-previous-version-of-the-struct,-making-them-hard-to-follow.-for-example,\u00a0line-17\u00a0implies-there-are-two-arrays-above-it-(there-is-only-one),-and\u00a0line-31\u00a0suggests-there-are-multiple-arrays-below-it-(there-is-only-one).", "labels": ["OpenZeppelin"]}, {"title": "A\u00a0comment about\u00a0HubPool.executeRootBundle\u00a0states that the function deletes the published root bundle, however it does not.", "body": "A\u00a0comment about\u00a0HubPool.executeRootBundle\u00a0states that the function deletes the published root bundle, however it does not.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#a\u00a0comment-about\u00a0hubpool.executerootbundle\u00a0states-that-the-function-deletes-the-published-root-bundle,-however-it-does-not.", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0LPTokenFactory\u00a0contract, the comments on\u00a0lines 24 and 25\u00a0should say \u201cmsg.sender\u201d or \u201cthe calling contract\u201d rather than \u201cthis contract\u201d.", "body": "Within the\u00a0LPTokenFactory\u00a0contract, the comments on\u00a0lines 24 and 25\u00a0should say \u201cmsg.sender\u201d or \u201cthe calling contract\u201d rather than \u201cthis contract\u201d.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#within-the\u00a0lptokenfactory\u00a0contract,-the-comments-on\u00a0lines-24-and-25\u00a0should-say-\u201cmsg.sender\u201d-or-\u201cthe-calling-contract\u201d-rather-than-\u201cthis-contract\u201d.", "labels": ["OpenZeppelin"]}, {"title": "The comments\u00a0above the\u00a0lpFeeRatePerSecond\u00a0variable suggest that LP fees are released linearly. In fact, they are released sublinearly, because the\u00a0_getAccumulatedFees\u00a0function uses a\u00a0fraction of the\u00a0undistributedLpFees\u00a0(which decreases over time for any given loan), rather than the total funds on loan.", "body": "The comments\u00a0above the\u00a0lpFeeRatePerSecond\u00a0variable suggest that LP fees are released linearly. In fact, they are released sublinearly, because the\u00a0_getAccumulatedFees\u00a0function uses a\u00a0fraction of the\u00a0undistributedLpFees\u00a0(which decreases over time for any given loan), rather than the total funds on loan.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the-comments\u00a0above-the\u00a0lpfeeratepersecond\u00a0variable-suggest-that-lp-fees-are-released-linearly.-in-fact,-they-are-released-sublinearly,-because-the\u00a0_getaccumulatedfees\u00a0function-uses-a\u00a0fraction-of-the\u00a0undistributedlpfees\u00a0(which-decreases-over-time-for-any-given-loan),-rather-than-the-total-funds-on-loan.", "labels": ["OpenZeppelin"]}, {"title": "The comment in\u00a0SpokePool\u00a0above the definition of\u00a0claimedBitmap\u00a0state that there are\u00a0256x256 leaves per root. However, due to the\u00a0indexing scheme in\u00a0MerkleLib, there are a maximum of\u00a02^248\u00a0different values of\u00a0claimedWordIndex, with\u00a0256\u00a0different\u00a0claimedBitIndexes. A more clear comment might explain that there are\u00a0256x(2^248)\u00a0leaves per root.", "body": "The comment in\u00a0SpokePool\u00a0above the definition of\u00a0claimedBitmap\u00a0state that there are\u00a0256x256 leaves per root. However, due to the\u00a0indexing scheme in\u00a0MerkleLib, there are a maximum of\u00a02^248\u00a0different values of\u00a0claimedWordIndex, with\u00a0256\u00a0different\u00a0claimedBitIndexes. A more clear comment might explain that there are\u00a0256x(2^248)\u00a0leaves per root.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the-comment-in\u00a0spokepool\u00a0above-the-definition-of\u00a0claimedbitmap\u00a0state-that-there-are\u00a0256x256-leaves-per-root.-however,-due-to-the\u00a0indexing-scheme-in\u00a0merklelib,-there-are-a-maximum-of\u00a02^248\u00a0different-values-of\u00a0claimedwordindex,-with\u00a0256\u00a0different\u00a0claimedbitindexes.-a-more-clear-comment-might-explain-that-there-are\u00a0256x(2^248)\u00a0leaves-per-root.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these comments to make the code easier to understand for reviewers and future developers.", "body": "Consider correcting these comments to make the code easier to understand for reviewers and future developers.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-correcting-these-comments-to-make-the-code-easier-to-understand-for-reviewers-and-future-developers.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #109\u00a0as of commit\u00a021cdccd5cbfffd4f120ab56c2691b8e961a8d323,\u00a0pull request #104\u00a0as of commit\u00a01148796377365a2de52fb89810f769ffb7f8c96f\u00a0and\u00a0pull request #138\u00a0as of commit\u00a0c0b6d4841b86ba8acf3e4a3042a78a1307410e6a.", "body": "Update:\u00a0Fixed in\u00a0pull request #109\u00a0as of commit\u00a021cdccd5cbfffd4f120ab56c2691b8e961a8d323,\u00a0pull request #104\u00a0as of commit\u00a01148796377365a2de52fb89810f769ffb7f8c96f\u00a0and\u00a0pull request #138\u00a0as of commit\u00a0c0b6d4841b86ba8acf3e4a3042a78a1307410e6a.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#109\u00a0as-of-commit\u00a021cdccd5cbfffd4f120ab56c2691b8e961a8d323,\u00a0pull-request-#104\u00a0as-of-commit\u00a01148796377365a2de52fb89810f769ffb7f8c96f\u00a0and\u00a0pull-request-#138\u00a0as-of-commit\u00a0c0b6d4841b86ba8acf3e4a3042a78a1307410e6a.", "labels": ["OpenZeppelin"]}, {"title": "payable\u00a0multicall\u00a0function disallows\u00a0msg.value", "body": "payable\u00a0multicall\u00a0function disallows\u00a0msg.value", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#payable\u00a0multicall\u00a0function-disallows\u00a0msg.value", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0MultiCaller\u00a0contract is inherited by the\u00a0HubPool\u00a0and\u00a0SpokePool\u00a0contracts. It provides the public\u00a0multiCall\u00a0function that facilitates calling multiple methods within the same contract with only a single call.", "body": "The\u00a0MultiCaller\u00a0contract is inherited by the\u00a0HubPool\u00a0and\u00a0SpokePool\u00a0contracts. It provides the public\u00a0multiCall\u00a0function that facilitates calling multiple methods within the same contract with only a single call.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0multicaller\u00a0contract-is-inherited-by-the\u00a0hubpool\u00a0and\u00a0spokepool\u00a0contracts.-it-provides-the-public\u00a0multicall\u00a0function-that-facilitates-calling-multiple-methods-within-the-same-contract-with-only-a-single-call.", "labels": ["OpenZeppelin"]}, {"title": "However, although it is designated as a\u00a0payable\u00a0function, it disallows any calls that send ETH, ie\u00a0where\u00a0msg.value\u00a0is not zero.", "body": "However, although it is designated as a\u00a0payable\u00a0function, it disallows any calls that send ETH, ie\u00a0where\u00a0msg.value\u00a0is not zero.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#however,-although-it-is-designated-as-a\u00a0payable\u00a0function,-it-disallows-any-calls-that-send-eth,-ie\u00a0where\u00a0msg.value\u00a0is-not-zero.", "labels": ["OpenZeppelin"]}, {"title": "This effectively makes the\u00a0payable\u00a0designation moot and the contradictory indications could lead to confusion.", "body": "This effectively makes the\u00a0payable\u00a0designation moot and the contradictory indications could lead to confusion.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#this-effectively-makes-the\u00a0payable\u00a0designation-moot-and-the-contradictory-indications-could-lead-to-confusion.", "labels": ["OpenZeppelin"]}, {"title": "In the context of the\u00a0HubPool, specifically, relays destined for chains where ETH is required and where a call to\u00a0loadEthForL2Calls\u00a0is therefore necessary, will not be multi-callable.", "body": "In the context of the\u00a0HubPool, specifically, relays destined for chains where ETH is required and where a call to\u00a0loadEthForL2Calls\u00a0is therefore necessary, will not be multi-callable.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the-context-of-the\u00a0hubpool,-specifically,-relays-destined-for-chains-where-eth-is-required-and-where-a-call-to\u00a0loadethforl2calls\u00a0is-therefore-necessary,-will-not-be-multi-callable.", "labels": ["OpenZeppelin"]}, {"title": "Consider either explicitly noting this limitation, or removing both the\u00a0require\u00a0statement\u00a0and\u00a0the\u00a0payable\u00a0designation.", "body": "Consider either explicitly noting this limitation, or removing both the\u00a0require\u00a0statement\u00a0and\u00a0the\u00a0payable\u00a0designation.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-either-explicitly-noting-this-limitation,-or-removing-both-the\u00a0require\u00a0statement\u00a0and\u00a0the\u00a0payable\u00a0designation.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #98\u00a0as of commit\u00a07092b8af1da15306994ea760b9669a9bd1f776c1.", "body": "Update:\u00a0Fixed in\u00a0pull request #98\u00a0as of commit\u00a07092b8af1da15306994ea760b9669a9bd1f776c1.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#98\u00a0as-of-commit\u00a07092b8af1da15306994ea760b9669a9bd1f776c1.", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "Naming issues", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "We have identified some areas of the code which could benefit from better naming:", "body": "We have identified some areas of the code which could benefit from better naming:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#we-have-identified-some-areas-of-the-code-which-could-benefit-from-better-naming:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0HubPoolInterface.liquidityUtilizationPostRelay, the parameter\u00a0token\u00a0should be renamed to\u00a0l1Token\u00a0to better match other functions in the interface, as well as the\u00a0function\u2019s implementation in\u00a0HubPool.", "body": "In\u00a0HubPoolInterface.liquidityUtilizationPostRelay, the parameter\u00a0token\u00a0should be renamed to\u00a0l1Token\u00a0to better match other functions in the interface, as well as the\u00a0function\u2019s implementation in\u00a0HubPool.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0hubpoolinterface.liquidityutilizationpostrelay,-the-parameter\u00a0token\u00a0should-be-renamed-to\u00a0l1token\u00a0to-better-match-other-functions-in-the-interface,-as-well-as-the\u00a0function\u2019s-implementation-in\u00a0hubpool.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0RootBundle\u00a0struct,\u00a0requestExpirationTimestamp\u00a0should be renamed to better indicate that it ends the\u00a0\u201cchallenge period\u201d. Consider renaming it to\u00a0ChallengePeriodEndTimestamp\u00a0or similar.", "body": "In the\u00a0RootBundle\u00a0struct,\u00a0requestExpirationTimestamp\u00a0should be renamed to better indicate that it ends the\u00a0\u201cchallenge period\u201d. Consider renaming it to\u00a0ChallengePeriodEndTimestamp\u00a0or similar.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-the\u00a0rootbundle\u00a0struct,\u00a0requestexpirationtimestamp\u00a0should-be-renamed-to-better-indicate-that-it-ends-the\u00a0\u201cchallenge-period\u201d.-consider-renaming-it-to\u00a0challengeperiodendtimestamp\u00a0or-similar.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0RootBundleExecuted\u00a0event\u00a0in\u00a0HubPool.sol\u00a0only names\u00a0one of its array parameters\u00a0in the plural form, but when the\u00a0event is emitted, all array parameters are named in the plural form. Consider changing the event definition so that all array parameters are pluralized.", "body": "The\u00a0RootBundleExecuted\u00a0event\u00a0in\u00a0HubPool.sol\u00a0only names\u00a0one of its array parameters\u00a0in the plural form, but when the\u00a0event is emitted, all array parameters are named in the plural form. Consider changing the event definition so that all array parameters are pluralized.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0rootbundleexecuted\u00a0event\u00a0in\u00a0hubpool.sol\u00a0only-names\u00a0one-of-its-array-parameters\u00a0in-the-plural-form,-but-when-the\u00a0event-is-emitted,-all-array-parameters-are-named-in-the-plural-form.-consider-changing-the-event-definition-so-that-all-array-parameters-are-pluralized.", "labels": ["OpenZeppelin"]}, {"title": "The name of\u00a0function whitelistedRoute\u00a0is vague and does not indicate what it\u2019s output will be. Consider renaming it to something like\u00a0destinationTokenFromRoute\u00a0to better match\u00a0the return value.", "body": "The name of\u00a0function whitelistedRoute\u00a0is vague and does not indicate what it\u2019s output will be. Consider renaming it to something like\u00a0destinationTokenFromRoute\u00a0to better match\u00a0the return value.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the-name-of\u00a0function-whitelistedroute\u00a0is-vague-and-does-not-indicate-what-it\u2019s-output-will-be.-consider-renaming-it-to-something-like\u00a0destinationtokenfromroute\u00a0to-better-match\u00a0the-return-value.", "labels": ["OpenZeppelin"]}, {"title": "When\u00a0weth\u00a0is used in\u00a0Polygon_SpokePool.sol, it\u00a0refers to wrapped MATIC. Consider renaming the\u00a0weth\u00a0variable in\u00a0SpokePool.sol\u00a0to\u00a0wrapped_native_token\u00a0to make it more generalizable. This will make\u00a0Polygon_SpokePool\u00a0less confusing and be more generalizeable for future SpokePools.", "body": "When\u00a0weth\u00a0is used in\u00a0Polygon_SpokePool.sol, it\u00a0refers to wrapped MATIC. Consider renaming the\u00a0weth\u00a0variable in\u00a0SpokePool.sol\u00a0to\u00a0wrapped_native_token\u00a0to make it more generalizable. This will make\u00a0Polygon_SpokePool\u00a0less confusing and be more generalizeable for future SpokePools.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#when\u00a0weth\u00a0is-used-in\u00a0polygon_spokepool.sol,-it\u00a0refers-to-wrapped-matic.-consider-renaming-the\u00a0weth\u00a0variable-in\u00a0spokepool.sol\u00a0to\u00a0wrapped_native_token\u00a0to-make-it-more-generalizable.-this-will-make\u00a0polygon_spokepool\u00a0less-confusing-and-be-more-generalizeable-for-future-spokepools.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0executeSlowRelayRoot\u00a0and\u00a0executeRelayerRefundRoot\u00a0functions\u00a0are executing leaves and should be renamed accordingly.", "body": "The\u00a0executeSlowRelayRoot\u00a0and\u00a0executeRelayerRefundRoot\u00a0functions\u00a0are executing leaves and should be renamed accordingly.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0executeslowrelayroot\u00a0and\u00a0executerelayerrefundroot\u00a0functions\u00a0are-executing-leaves-and-should-be-renamed-accordingly.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0unclaimedPoolRebalanceLeafCount\u00a0parameter\u00a0of the\u00a0ProposeRootBundle\u00a0event should be renamed to\u00a0poolRebalanceLeafCount, since it\u2019s always the total number of leaves in the tree.", "body": "The\u00a0unclaimedPoolRebalanceLeafCount\u00a0parameter\u00a0of the\u00a0ProposeRootBundle\u00a0event should be renamed to\u00a0poolRebalanceLeafCount, since it\u2019s always the total number of leaves in the tree.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0unclaimedpoolrebalanceleafcount\u00a0parameter\u00a0of-the\u00a0proposerootbundle\u00a0event-should-be-renamed-to\u00a0poolrebalanceleafcount,-since-it\u2019s-always-the-total-number-of-leaves-in-the-tree.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0RootBundleCanceled\u00a0event\u00a0names the last parameter as\u00a0disputedAncillaryData, but the proposal is not necessarily disputed. It should just be\u00a0ancillaryData.", "body": "The\u00a0RootBundleCanceled\u00a0event\u00a0names the last parameter as\u00a0disputedAncillaryData, but the proposal is not necessarily disputed. It should just be\u00a0ancillaryData.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0rootbundlecanceled\u00a0event\u00a0names-the-last-parameter-as\u00a0disputedancillarydata,-but-the-proposal-is-not-necessarily-disputed.-it-should-just-be\u00a0ancillarydata.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0_append\u00a0function\u00a0of the\u00a0LpTokenFactory\u00a0could be called\u00a0_concatenate\u00a0to better describe its functionality.", "body": "The\u00a0_append\u00a0function\u00a0of the\u00a0LpTokenFactory\u00a0could be called\u00a0_concatenate\u00a0to better describe its functionality.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0_append\u00a0function\u00a0of-the\u00a0lptokenfactory\u00a0could-be-called\u00a0_concatenate\u00a0to-better-describe-its-functionality.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0onlyEnabledRoute\u00a0modifier\u00a0has a\u00a0destinationId\u00a0parameter that should be\u00a0destinationChainId\u00a0to match the rest of the code base.", "body": "The\u00a0onlyEnabledRoute\u00a0modifier\u00a0has a\u00a0destinationId\u00a0parameter that should be\u00a0destinationChainId\u00a0to match the rest of the code base.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0onlyenabledroute\u00a0modifier\u00a0has-a\u00a0destinationid\u00a0parameter-that-should-be\u00a0destinationchainid\u00a0to-match-the-rest-of-the-code-base.", "labels": ["OpenZeppelin"]}, {"title": "Consider following our renaming suggestions to make the codebase easier for developers and reviewers to understand.", "body": "Consider following our renaming suggestions to make the codebase easier for developers and reviewers to understand.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-following-our-renaming-suggestions-to-make-the-codebase-easier-for-developers-and-reviewers-to-understand.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #105\u00a0as of commit\u00a087b69cdf159a1db5ccfcaa9f27825dfa416e7158.", "body": "Update:\u00a0Fixed in\u00a0pull request #105\u00a0as of commit\u00a087b69cdf159a1db5ccfcaa9f27825dfa416e7158.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#105\u00a0as-of-commit\u00a087b69cdf159a1db5ccfcaa9f27825dfa416e7158.", "labels": ["OpenZeppelin"]}, {"title": "Warning about nonstandard tokens", "body": "Warning about nonstandard tokens", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#warning-about-nonstandard-tokens", "labels": ["OpenZeppelin"]}, {"title": "Although tokens must be enabled to be used in the system, it is important to define what may make a token troublesome so that which tokens can be whitelisted is easier to determine.", "body": "Although tokens must be enabled to be used in the system, it is important to define what may make a token troublesome so that which tokens can be whitelisted is easier to determine.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#although-tokens-must-be-enabled-to-be-used-in-the-system,-it-is-important-to-define-what-may-make-a-token-troublesome-so-that-which-tokens-can-be-whitelisted-is-easier-to-determine.", "labels": ["OpenZeppelin"]}, {"title": "ERC20 tokens which charge fees, or which can charge fees, will result in various accounting issues as the amount\u00a0transferred\u00a0will not match the amount received by the contracts in the system. Many spots in the code, such as\u00a0in the\u00a0addLiquidity\u00a0function, assume the amount transferred in equals the amount received.", "body": "ERC20 tokens which charge fees, or which can charge fees, will result in various accounting issues as the amount\u00a0transferred\u00a0will not match the amount received by the contracts in the system. Many spots in the code, such as\u00a0in the\u00a0addLiquidity\u00a0function, assume the amount transferred in equals the amount received.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#erc20-tokens-which-charge-fees,-or-which-can-charge-fees,-will-result-in-various-accounting-issues-as-the-amount\u00a0transferred\u00a0will-not-match-the-amount-received-by-the-contracts-in-the-system.-many-spots-in-the-code,-such-as\u00a0in-the\u00a0addliquidity\u00a0function,-assume-the-amount-transferred-in-equals-the-amount-received.", "labels": ["OpenZeppelin"]}, {"title": "ERC777 tokens, which are ERC20-compatible, include hooks on transfers. These hooks are configurable and may be configured to revert in some or all cases. In\u00a0SpokePool._executeRelayerRefundRoot, a failing transfer for one token could\u00a0block all other refunds\u00a0for the specified leaf.", "body": "ERC777 tokens, which are ERC20-compatible, include hooks on transfers. These hooks are configurable and may be configured to revert in some or all cases. In\u00a0SpokePool._executeRelayerRefundRoot, a failing transfer for one token could\u00a0block all other refunds\u00a0for the specified leaf.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#erc777-tokens,-which-are-erc20-compatible,-include-hooks-on-transfers.-these-hooks-are-configurable-and-may-be-configured-to-revert-in-some-or-all-cases.-in\u00a0spokepool._executerelayerrefundroot,-a-failing-transfer-for-one-token-could\u00a0block-all-other-refunds\u00a0for-the-specified-leaf.", "labels": ["OpenZeppelin"]}, {"title": "Tokens which are upgradeable may change their implementations to become subject to the above issues, even though they may not have been problematic before being upgraded.", "body": "Tokens which are upgradeable may change their implementations to become subject to the above issues, even though they may not have been problematic before being upgraded.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#tokens-which-are-upgradeable-may-change-their-implementations-to-become-subject-to-the-above-issues,-even-though-they-may-not-have-been-problematic-before-being-upgraded.", "labels": ["OpenZeppelin"]}, {"title": "Consider documenting procedures for tokens which behave unexpectedly to be filtered for before whitelisting.", "body": "Consider documenting procedures for tokens which behave unexpectedly to be filtered for before whitelisting.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-documenting-procedures-for-tokens-which-behave-unexpectedly-to-be-filtered-for-before-whitelisting.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #137\u00a0as of commit\u00a0ba6e03974cf722d33b9fb2def4da578129f5baed.", "body": "Update:\u00a0Fixed in\u00a0pull request #137\u00a0as of commit\u00a0ba6e03974cf722d33b9fb2def4da578129f5baed.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#137\u00a0as-of-commit\u00a0ba6e03974cf722d33b9fb2def4da578129f5baed.", "labels": ["OpenZeppelin"]}, {"title": "Not using\u00a0immutable", "body": "Not using\u00a0immutable", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#not-using\u00a0immutable", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0HubPool\u00a0contract, the\u00a0weth,\u00a0finder, and\u00a0lpTokenFactory\u00a0variables are only ever assigned a value in the\u00a0constructor.", "body": "Within the\u00a0HubPool\u00a0contract, the\u00a0weth,\u00a0finder, and\u00a0lpTokenFactory\u00a0variables are only ever assigned a value in the\u00a0constructor.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#within-the\u00a0hubpool\u00a0contract,-the\u00a0weth,\u00a0finder,-and\u00a0lptokenfactory\u00a0variables-are-only-ever-assigned-a-value-in-the\u00a0constructor.", "labels": ["OpenZeppelin"]}, {"title": "Consider marking these values as\u00a0immutable\u00a0to better signal the fact that these values or not meant to change and to reduce the overall gas consumption of the contract.", "body": "Consider marking these values as\u00a0immutable\u00a0to better signal the fact that these values or not meant to change and to reduce the overall gas consumption of the contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-marking-these-values-as\u00a0immutable\u00a0to-better-signal-the-fact-that-these-values-or-not-meant-to-change-and-to-reduce-the-overall-gas-consumption-of-the-contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #108\u00a0as of commit\u00a0cccb9556345edcc5d8fc3022ab64a5b368c8d810.", "body": "Update:\u00a0Fixed in\u00a0pull request #108\u00a0as of commit\u00a0cccb9556345edcc5d8fc3022ab64a5b368c8d810.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#108\u00a0as-of-commit\u00a0cccb9556345edcc5d8fc3022ab64a5b368c8d810.", "labels": ["OpenZeppelin"]}, {"title": "Residual privileged roles", "body": "Residual privileged roles", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#residual-privileged-roles", "labels": ["OpenZeppelin"]}, {"title": "LpTokenFactory\u00a0contract", "body": ", when the  createLpToken function is called, it creates a new ERC20 LP token and adds the  role assignments use the  magic values 1 and 2, which are the  Rather than using these literal values to assign roles, consider using the the ExpandedERC20.addMinter and ExpandedERC20.addBurner functions.  Update: Fixed in pull request #103 as of commit e9d3419ac6eb609b0c9165cdeac3fbff58285d18.  Misleading Comments  HubPool lines 718-719 explain that the whitelistedRoute function returns whitelisted destination tokens, but does not mention that if the token is not whitelisted then the function returns address(0).  The comments in the declaration of the PoolRebalanceLeaf struct appear to refer to a previous version of the struct, making them hard to follow. For example, line 17 implies there are two arrays above it (there is only one), and line 31 suggests there are multiple arrays below it (there is only one).  A comment about HubPool.executeRootBundle states that the function deletes the published root bundle, however it does not.  Within the LPTokenFactory contract, the comments on lines 24 and 25 should say msg.sender or the calling contract rather than this contract.  The comments above the lpFeeRatePerSecond variable suggest that LP fees are released linearly. In fact, they are released sublinearly, because the _getAccumulatedFees function uses a fraction of the undistributedLpFees (which decreases over time for any given loan), rather than the total funds on loan.  The comment in SpokePool above the definition of claimedBitmap state that there are 256x256 leaves per root. However, due to the indexing scheme in MerkleLib, there are a maximum of 2^248 different values of claimedWordIndex, with 256 different claimedBitIndexes. A more clear comment might explain that there are 256x(2^248) leaves per root.  Consider correcting these comments to make the code easier to understand for reviewers and future developers.  Update: Fixed in pull request #109 as of commit 21cdccd5cbfffd4f120ab56c2691b8e961a8d323, pull request #104 as of commit 1148796377365a2de52fb89810f769ffb7f8c96f and pull request #138 as of commit c0b6d4841b86ba8acf3e4a3042a78a1307410e6a.  payable multicall function disallows msg.value  The MultiCaller contract is inherited by the HubPool and SpokePool contracts. It provides the public multiCall function that facilitates calling multiple methods within the same contract with only a single call.  However, although it is designated as a payable function, it disallows any calls that send ETH, ie where msg.value is not zero.  This effectively makes the payable designation moot and the contradictory indications could lead to confusion.  In the context of the HubPool, specifically, relays destined for chains where ETH is required and where a call to loadEthForL2Calls is therefore necessary, will not be multi-callable.  Consider either explicitly noting this limitation, or removing both the require statement and the payable designation.  Update: Fixed in pull request #98 as of commit 7092b8af1da15306994ea760b9669a9bd1f776c1.  Naming issues  We have identified some areas of the code which could benefit from better naming:  In HubPoolInterface.liquidityUtilizationPostRelay, the parameter token should be renamed to l1Token to better match other functions in the interface, as well as the functions implementation in HubPool.  In the RootBundle struct, requestExpirationTimestamp should be renamed to better indicate that it ends the challenge period. Consider renaming it to ChallengePeriodEndTimestamp or similar.  The RootBundleExecuted event in HubPool.sol only names one of its array parameters in the plural form, but when the event is emitted, all array parameters are named in the plural form. Consider changing the event definition so that all array parameters are pluralized.  The name of function whitelistedRoute is vague and does not indicate what its output will be. Consider renaming it to something like destinationTokenFromRoute to better match the return value.  When weth is used in Polygon_SpokePool.sol, it refers to wrapped MATIC. Consider renaming the weth variable in SpokePool.sol to wrapped_native_token to make it more generalizable. This will make Polygon_SpokePool less confusing and be more generalizeable for future SpokePools.  The executeSlowRelayRoot and executeRelayerRefundRoot functions are executing leaves and should be renamed accordingly.  The unclaimedPoolRebalanceLeafCount parameter of the ProposeRootBundle event should be renamed to poolRebalanceLeafCount, since its always the total number of leaves in the tree.  The RootBundleCanceled event names the last parameter as disputedAncillaryData, but the proposal is not necessarily disputed. It should just be ancillaryData.  The _append function of the LpTokenFactory could be called _concatenate to better describe its functionality.  The onlyEnabledRoute modifier has a destinationId parameter that should be destinationChainId to match the rest of t", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#lptokenfactory\u00a0contract", "labels": ["OpenZeppelin"]}, {"title": "creates an\u00a0ExpandedERC20\u00a0token contract, the factory becomes the", "body": "creates an\u00a0ExpandedERC20\u00a0token contract, the factory becomes the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#creates-an\u00a0expandederc20\u00a0token-contract,-the-factory-becomes-the", "labels": ["OpenZeppelin"]}, {"title": "owner\u00a0of that token contract. The factory then proceeds to", "body": "owner\u00a0of that token contract. The factory then proceeds to", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#owner\u00a0of-that-token-contract.-the-factory-then-proceeds-to", "labels": ["OpenZeppelin"]}, {"title": "assign the\u00a0minter\u00a0and\u00a0burner\u00a0roles\u00a0to the", "body": "assign the\u00a0minter\u00a0and\u00a0burner\u00a0roles\u00a0to the", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#assign-the\u00a0minter\u00a0and\u00a0burner\u00a0roles\u00a0to-the", "labels": ["OpenZeppelin"]}, {"title": "As this is a residual power that is no longer needed by the\u00a0LpTokenFactory, consider reducing the number of addresses with privileged roles by transferring ownership to the\u00a0msg.sender.", "body": "As this is a residual power that is no longer needed by the\u00a0LpTokenFactory, consider reducing the number of addresses with privileged roles by transferring ownership to the\u00a0msg.sender.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#as-this-is-a-residual-power-that-is-no-longer-needed-by-the\u00a0lptokenfactory,-consider-reducing-the-number-of-addresses-with-privileged-roles-by-transferring-ownership-to-the\u00a0msg.sender.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #109\u00a0as of commit\u00a021cdccd5cbfffd4f120ab56c2691b8e961a8d323.", "body": "Update:\u00a0Fixed in\u00a0pull request #109\u00a0as of commit\u00a021cdccd5cbfffd4f120ab56c2691b8e961a8d323.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#109\u00a0as-of-commit\u00a021cdccd5cbfffd4f120ab56c2691b8e961a8d323.", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Typographical errors", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0HubPool.sol:", "body": "In\u00a0HubPool.sol:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0hubpool.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 99: \u201cHeler\u201d should be \u201cHelper\u201d", "body": "line 99: \u201cHeler\u201d should be \u201cHelper\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-99:-\u201cheler\u201d-should-be-\u201chelper\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 201: \u201cproposal\u201d should be \u201cProposal\u201d", "body": "line 201: \u201cproposal\u201d should be \u201cProposal\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-201:-\u201cproposal\u201d-should-be-\u201cproposal\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 235: \u201cits\u201d should be \u201cit\u2019s\u201d", "body": "line 235: \u201cits\u201d should be \u201cit\u2019s\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-235:-\u201cits\u201d-should-be-\u201cit\u2019s\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 294: \u201cdisputes..\u201d should be \u201cdisputes.\u201d", "body": "line 294: \u201cdisputes..\u201d should be \u201cdisputes.\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-294:-\u201cdisputes..\u201d-should-be-\u201cdisputes.\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 377: \u201cfor again\u201d should be \u201cagain.\u201d", "body": "line 377: \u201cfor again\u201d should be \u201cagain.\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-377:-\u201cfor-again\u201d-should-be-\u201cagain.\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 419: \u201caccess more funds that\u201d should be \u201cto access more funds than\u201d", "body": "line 419: \u201caccess more funds that\u201d should be \u201cto access more funds than\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-419:-\u201caccess-more-funds-that\u201d-should-be-\u201cto-access-more-funds-than\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 475: \u201cto along\u201d should be \u201calong\u201d", "body": "line 475: \u201cto along\u201d should be \u201calong\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-475:-\u201cto-along\u201d-should-be-\u201calong\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 480: \u201cleafs\u201d should be \u201cleaves\u201d", "body": "line 480: \u201cleafs\u201d should be \u201cleaves\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-480:-\u201cleafs\u201d-should-be-\u201cleaves\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 532: \u201cneccessary\u201d should be \u201cnecessary\u201d", "body": "line 532: \u201cneccessary\u201d should be \u201cnecessary\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-532:-\u201cneccessary\u201d-should-be-\u201cnecessary\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 568: \u201cto back\u201d should be \u201cback\u201d", "body": "line 568: \u201cto back\u201d should be \u201cback\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-568:-\u201cto-back\u201d-should-be-\u201cback\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 569: \u201cleafs\u201d should be \u201cleaves\u201d", "body": "line 569: \u201cleafs\u201d should be \u201cleaves\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-569:-\u201cleafs\u201d-should-be-\u201cleaves\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 569: \u201cwont\u201d should be \u201cwon\u2019t\u201d", "body": "line 569: \u201cwont\u201d should be \u201cwon\u2019t\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-569:-\u201cwont\u201d-should-be-\u201cwon\u2019t\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 865: \u201ctimeFromLastInteraction ,undistributedLpFees)\u201d should be \u201ctimeFromLastInteraction, undistributedLpFees)\u201d", "body": "line 865: \u201ctimeFromLastInteraction ,undistributedLpFees)\u201d should be \u201ctimeFromLastInteraction, undistributedLpFees)\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-865:-\u201ctimefromlastinteraction-,undistributedlpfees)\u201d-should-be-\u201ctimefromlastinteraction,-undistributedlpfees)\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 866: \u201ca fees.\u201d should be \u201cfees.\u201d", "body": "line 866: \u201ca fees.\u201d should be \u201cfees.\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-866:-\u201ca-fees.\u201d-should-be-\u201cfees.\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 913: \u201cdecrease\u201d should be \u201cdecreased\u201d", "body": "line 913: \u201cdecrease\u201d should be \u201cdecreased\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-913:-\u201cdecrease\u201d-should-be-\u201cdecreased\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 962: \u201csend\u201d should be \u201csent\u201d", "body": "line 962: \u201csend\u201d should be \u201csent\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-962:-\u201csend\u201d-should-be-\u201csent\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0HubPoolInterface.sol:", "body": "In\u00a0HubPoolInterface.sol:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0hubpoolinterface.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 13: \u201csent\u201d should be \u201csend\u201d", "body": "line 13: \u201csent\u201d should be \u201csend\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-13:-\u201csent\u201d-should-be-\u201csend\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0MerkleLib.sol:", "body": "In\u00a0MerkleLib.sol:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0merklelib.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 86: \u201c\\*\u201d should be \u201c*\u201d", "body": "line 86: \u201c\\*\u201d should be \u201c*\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-86:-\u201c\\*\u201d-should-be-\u201c*\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0Polygon_SpokePool.sol:", "body": "In\u00a0Polygon_SpokePool.sol:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0polygon_spokepool.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 43: \u201cpriviledges\u201d should be \u201cprivileges\u201d", "body": "line 43: \u201cpriviledges\u201d should be \u201cprivileges\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-43:-\u201cpriviledges\u201d-should-be-\u201cprivileges\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0SpokePool.sol:", "body": "In\u00a0SpokePool.sol:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0spokepool.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 55: \u201ctoken\u201d should be \u201cchain\u201d", "body": "line 55: \u201ctoken\u201d should be \u201cchain\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-55:-\u201ctoken\u201d-should-be-\u201cchain\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 67: \u201cleafs\u201d should be \u201cleaves\u201d", "body": "line 67: \u201cleafs\u201d should be \u201cleaves\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-67:-\u201cleafs\u201d-should-be-\u201cleaves\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 292: \u201cusers\u201d should be \u201cuser\u2019s\u201d", "body": "line 292: \u201cusers\u201d should be \u201cuser\u2019s\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-292:-\u201cusers\u201d-should-be-\u201cuser\u2019s\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 347: \u201creceipient.\u201d should be \u201crecipient.\u201d", "body": "line 347: \u201creceipient.\u201d should be \u201crecipient.\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-347:-\u201creceipient.\u201d-should-be-\u201crecipient.\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0SpokePoolInterface.sol:", "body": "In\u00a0SpokePoolInterface.sol:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in\u00a0spokepoolinterface.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 11: \u201cinverted.\u201d should be \u201cnegated.\u201d", "body": "line 11: \u201cinverted.\u201d should be \u201cnegated.\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-11:-\u201cinverted.\u201d-should-be-\u201cnegated.\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 27: \u201ca the\u201d should be \u201cthe\u201d", "body": "line 27: \u201ca the\u201d should be \u201cthe\u201d", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#line-27:-\u201ca-the\u201d-should-be-\u201cthe\u201d", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #110\u00a0as of commit\u00a0813cfeef126484e0ac5b7fb91225560c5edbff7c.", "body": "Update:\u00a0Fixed in\u00a0pull request #110\u00a0as of commit\u00a0813cfeef126484e0ac5b7fb91225560c5edbff7c.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#110\u00a0as-of-commit\u00a0813cfeef126484e0ac5b7fb91225560c5edbff7c.", "labels": ["OpenZeppelin"]}, {"title": "Undocumented implicit approval requirements", "body": "Undocumented implicit approval requirements", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#undocumented-implicit-approval-requirements", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, when the\u00a0safeTransferFrom\u00a0function is used to transfer assets into the system from an external address there is an implicit requirement that the external address has already granted the appropriate approvals.", "body": "Throughout the codebase, when the\u00a0safeTransferFrom\u00a0function is used to transfer assets into the system from an external address there is an implicit requirement that the external address has already granted the appropriate approvals.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#throughout-the-codebase,-when-the\u00a0safetransferfrom\u00a0function-is-used-to-transfer-assets-into-the-system-from-an-external-address-there-is-an-implicit-requirement-that-the-external-address-has-already-granted-the-appropriate-approvals.", "labels": ["OpenZeppelin"]}, {"title": "For instance:", "body": "In the HubPool contract the public unclaimedAccumulatedProtocolFees variable has no inline documentation.  In the HubPoolInterface contract the inline documentation accompanying PoolRebalanceLeaf.netSendAmounts, although lengthy, could benefit from additional clarification around the case of negative values. It could clarify further that in such cases the actual netSendAmounts value is ignored, but it should match the amountToReturn parameter in the RelayerRefundLeaf.  Many of the functions in the MerkleLib library are missing NatSpec @return statements.  To further clarify intent and improve overall code readability, consider adding additional inline documentation where indicated above.  Update: Fixed in pull request #102 as of commit e2bfe128ff1a9aeed02bfcebe58a5880ad283698.  Magic values  LpTokenFactory contract, when the  createLpToken function is called, it creates a new ERC20 LP token and adds the  role assignments use the  magic values 1 and 2, which are the  Rather than using these literal values to assign roles, consider using the the ExpandedERC20.addMinter and ExpandedERC20.addBurner functions.  Update: Fixed in pull request #103 as of commit e9d3419ac6eb609b0c9165cdeac3fbff58285d18.  Misleading Comments  HubPool lines 718-719 explain that the whitelistedRoute function returns whitelisted destination tokens, but does not mention that if the token is not whitelisted then the function returns address(0).  The comments in the declaration of the PoolRebalanceLeaf struct appear to refer to a previous version of the struct, making them hard to follow. For example, line 17 implies there are two arrays above it (there is only one), and line 31 suggests there are multiple arrays below it (there is only one).  A comment about HubPool.executeRootBundle states that the function deletes the published root bundle, however it does not.  Within the LPTokenFactory contract, the comments on lines 24 and 25 should say msg.sender or the calling contract rather than this contract.  The comments above the lpFeeRatePerSecond variable suggest that LP fees are released linearly. In fact, they are released sublinearly, because the _getAccumulatedFees function uses a fraction of the undistributedLpFees (which decreases over time for any given loan), rather than the total funds on loan.  The comment in SpokePool above the definition of claimedBitmap state that there are 256x256 leaves per root. However, due to the indexing scheme in MerkleLib, there are a maximum of 2^248 different values of claimedWordIndex, with 256 different claimedBitIndexes. A more clear comment might explain that there are 256x(2^248) leaves per root.  Consider correcting these comments to make the code easier to understand for reviewers and future developers.  Update: Fixed in pull request #109 as of commit 21cdccd5cbfffd4f120ab56c2691b8e961a8d323, pull request #104 as of commit 1148796377365a2de52fb89810f769ffb7f8c96f and pull request #138 as of commit c0b6d4841b86ba8acf3e4a3042a78a1307410e6a.  payable multicall function disallows msg.value  The MultiCaller contract is inherited by the HubPool and SpokePool contracts. It provides the public multiCall function that facilitates calling multiple methods within the same contract with only a single call.  However, although it is designated as a payable function, it disallows any calls that send ETH, ie where msg.value is not zero.  This effectively makes the payable designation moot and the contradictory indications could lead to confusion.  In the context of the HubPool, specifically, relays destined for chains where ETH is required and where a call to loadEthForL2Calls is therefore necessary, will not be multi-callable.  Consider either explicitly noting this limitation, or removing both the require statement and the payable designation.  Update: Fixed in pull request #98 as of commit 7092b8af1da15306994ea760b9669a9bd1f776c1.  Naming issues  We have identified some areas of the code which could benefit from better naming:  In HubPoolInterface.liquidityUtilizationPostRelay, the parameter token should be renamed to l1Token to better match other functions in the interface, as well as the functions implementation in HubPool.  In the RootBundle struct, requestExpirationTimestamp should be renamed to better indicate that it ends the challenge period. Consider renaming it to ChallengePeriodEndTimestamp or similar.  The RootBundleExecuted event in HubPool.sol only names one of its array parameters in the plural form, but when the event is emitted, all array parameters are named in the plural form. Consider changing the event definition so that all array parameters are pluralized.  The name of function whitelistedRoute is vague and does not indicate what its output will be. Consider renaming it to something like destinationTokenFromRoute to better match the return value.  When weth is used in Polygon_SpokePool.sol, it refers to wrapped MATIC. Consider renaming the weth variable in SpokePool.sol to wrapped_nativ", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#for-instance:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0proposeRootBundle\u00a0function relies on\u00a0safeTransferFrom\u00a0which requires that\u00a0HubPool\u00a0has been granted an allowance of\u00a0bondAmount\u00a0bondTokens by the caller.", "body": "The\u00a0proposeRootBundle\u00a0function relies on\u00a0safeTransferFrom\u00a0which requires that\u00a0HubPool\u00a0has been granted an allowance of\u00a0bondAmount\u00a0bondTokens by the caller.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0proposerootbundle\u00a0function-relies-on\u00a0safetransferfrom\u00a0which-requires-that\u00a0hubpool\u00a0has-been-granted-an-allowance-of\u00a0bondamount\u00a0bondtokens-by-the-caller.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0addLiquidity\u00a0function relies on\u00a0safeTransferFrom, requiring that the\u00a0HubPool\u00a0has been granted an\u00a0l1TokenAmount\u00a0allowance of the caller\u2019s\u00a0l1Token.", "body": "The\u00a0addLiquidity\u00a0function relies on\u00a0safeTransferFrom, requiring that the\u00a0HubPool\u00a0has been granted an\u00a0l1TokenAmount\u00a0allowance of the caller\u2019s\u00a0l1Token.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0addliquidity\u00a0function-relies-on\u00a0safetransferfrom,-requiring-that-the\u00a0hubpool\u00a0has-been-granted-an\u00a0l1tokenamount\u00a0allowance-of-the-caller\u2019s\u00a0l1token.", "labels": ["OpenZeppelin"]}, {"title": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "body": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#in-favor-of-explicitness-and-to-improve-the-overall-clarity-of-the-codebase,-consider-documenting-all-approval-requirements-in-the-relevant-functions\u2019-inline-documentation.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #111\u00a0as of commit\u00a05a3ef77a22b81411a3616bb48acf063acabb4d2c.", "body": "Update:\u00a0Fixed in\u00a0pull request #111\u00a0as of commit\u00a05a3ef77a22b81411a3616bb48acf063acabb4d2c.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#111\u00a0as-of-commit\u00a05a3ef77a22b81411a3616bb48acf063acabb4d2c.", "labels": ["OpenZeppelin"]}, {"title": "Unused code", "body": "Unused code", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#unused-code", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, there are instances of unused code. For example:", "body": "Throughout the codebase, there are instances of unused code. For example:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#throughout-the-codebase,-there-are-instances-of-unused-code.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0proposerBondRepaid\u00a0attribute of the\u00a0HubPool\u00a0contract\u2019s\u00a0RootBundle\u00a0struct is never used. Consider removing it.", "body": "The\u00a0proposerBondRepaid\u00a0attribute of the\u00a0HubPool\u00a0contract\u2019s\u00a0RootBundle\u00a0struct is never used. Consider removing it.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0proposerbondrepaid\u00a0attribute-of-the\u00a0hubpool\u00a0contract\u2019s\u00a0rootbundle\u00a0struct-is-never-used.-consider-removing-it.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0events\u00a0in the\u00a0Arbitrum_Adapter\u00a0contract are never used. As the relevant state variables are\u00a0immutable, consider setting\u00a0all relevant values\u00a0in the constructor and emitting these events then. Alternatively, consider adding comments indicating why events are declared but unused.", "body": "The\u00a0events\u00a0in the\u00a0Arbitrum_Adapter\u00a0contract are never used. As the relevant state variables are\u00a0immutable, consider setting\u00a0all relevant values\u00a0in the constructor and emitting these events then. Alternatively, consider adding comments indicating why events are declared but unused.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0events\u00a0in-the\u00a0arbitrum_adapter\u00a0contract-are-never-used.-as-the-relevant-state-variables-are\u00a0immutable,-consider-setting\u00a0all-relevant-values\u00a0in-the-constructor-and-emitting-these-events-then.-alternatively,-consider-adding-comments-indicating-why-events-are-declared-but-unused.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0L2GasLimitSet\u00a0event\u00a0in the\u00a0Optimism_Adapter\u00a0is never emitted. Consider emitting it in the constructor, removing it, or adding a comment indicating why it is declared but not used.", "body": "The\u00a0L2GasLimitSet\u00a0event\u00a0in the\u00a0Optimism_Adapter\u00a0is never emitted. Consider emitting it in the constructor, removing it, or adding a comment indicating why it is declared but not used.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0l2gaslimitset\u00a0event\u00a0in-the\u00a0optimism_adapter\u00a0is-never-emitted.-consider-emitting-it-in-the-constructor,-removing-it,-or-adding-a-comment-indicating-why-it-is-declared-but-not-used.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0HubPoolChanged\u00a0event\u00a0is never used.", "body": "The\u00a0HubPoolChanged\u00a0event\u00a0is never used.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0hubpoolchanged\u00a0event\u00a0is-never-used.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #78\u00a0as of commit\u00a0f7e8518050a12e478516da6622bcf2357bb2e802\u00a0and in\u00a0pull request #99\u00a0as of commit\u00a0d89b1fb8d491703ef63dae0b29d93abd29d501de.", "body": "Update:\u00a0Fixed in\u00a0pull request #78\u00a0as of commit\u00a0f7e8518050a12e478516da6622bcf2357bb2e802\u00a0and in\u00a0pull request #99\u00a0as of commit\u00a0d89b1fb8d491703ef63dae0b29d93abd29d501de.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#78\u00a0as-of-commit\u00a0f7e8518050a12e478516da6622bcf2357bb2e802\u00a0and-in\u00a0pull-request-#99\u00a0as-of-commit\u00a0d89b1fb8d491703ef63dae0b29d93abd29d501de.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary import statements", "body": "Unnecessary import statements", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#unnecessary-import-statements", "labels": ["OpenZeppelin"]}, {"title": "The below list outlines contract import statements that are unnecessary:", "body": "The below list outlines contract import statements that are unnecessary:", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the-below-list-outlines-contract-import-statements-that-are-unnecessary:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0WETH9\u00a0and\u00a0Lockable\u00a0imports are not used in the\u00a0Ethereum_Adapter\u00a0contract.", "body": "The\u00a0WETH9\u00a0and\u00a0Lockable\u00a0imports are not used in the\u00a0Ethereum_Adapter\u00a0contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0weth9\u00a0and\u00a0lockable\u00a0imports-are-not-used-in-the\u00a0ethereum_adapter\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0CrossDomainEnabled,\u00a0IL1StandardBridge, and\u00a0Lockable\u00a0imports are not used in the\u00a0Polygon_Adapter\u00a0contract.", "body": "The\u00a0CrossDomainEnabled,\u00a0IL1StandardBridge, and\u00a0Lockable\u00a0imports are not used in the\u00a0Polygon_Adapter\u00a0contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0crossdomainenabled,\u00a0il1standardbridge,-and\u00a0lockable\u00a0imports-are-not-used-in-the\u00a0polygon_adapter\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0WETH9\u00a0and\u00a0IERC20\u00a0imports are not used in the\u00a0Arbitrum_Adapter\u00a0contract.", "body": "The\u00a0WETH9\u00a0and\u00a0IERC20\u00a0imports are not used in the\u00a0Arbitrum_Adapter\u00a0contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0weth9\u00a0and\u00a0ierc20\u00a0imports-are-not-used-in-the\u00a0arbitrum_adapter\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0AdapterInterface\u00a0interface is\u00a0imported twice\u00a0in the\u00a0Arbitrum_Adapter\u00a0contract.", "body": "The\u00a0AdapterInterface\u00a0interface is\u00a0imported twice\u00a0in the\u00a0Arbitrum_Adapter\u00a0contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0adapterinterface\u00a0interface-is\u00a0imported-twice\u00a0in-the\u00a0arbitrum_adapter\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0WETH9\u00a0and\u00a0SpokePoolInterface\u00a0imports are not used in the\u00a0Ethereum_SpokePool\u00a0contract.", "body": "The\u00a0WETH9\u00a0and\u00a0SpokePoolInterface\u00a0imports are not used in the\u00a0Ethereum_SpokePool\u00a0contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0weth9\u00a0and\u00a0spokepoolinterface\u00a0imports-are-not-used-in-the\u00a0ethereum_spokepool\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0IERC20\u00a0import in the\u00a0LpTokenFactoryInterface\u00a0interface is unused.", "body": "The\u00a0IERC20\u00a0import in the\u00a0LpTokenFactoryInterface\u00a0interface is unused.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0ierc20\u00a0import-in-the\u00a0lptokenfactoryinterface\u00a0interface-is-unused.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0MerkleLib\u00a0is imported twice in the\u00a0SpokePool\u00a0contract.", "body": "The\u00a0MerkleLib\u00a0is imported twice in the\u00a0SpokePool\u00a0contract.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0merklelib\u00a0is-imported-twice-in-the\u00a0spokepool\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing unnecessary import statements to simplify the codebase and increase overall readability.", "body": "Consider removing unnecessary import statements to simplify the codebase and increase overall readability.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-removing-unnecessary-import-statements-to-simplify-the-codebase-and-increase-overall-readability.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed in\u00a0pull request #112\u00a0as of commit\u00a0d81295d3fd433a1f08fdd42c75a0aa3233a77dbe.", "body": "Update:\u00a0Fixed in\u00a0pull request #112\u00a0as of commit\u00a0d81295d3fd433a1f08fdd42c75a0aa3233a77dbe.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#update:\u00a0fixed-in\u00a0pull-request-#112\u00a0as-of-commit\u00a0d81295d3fd433a1f08fdd42c75a0aa3233a77dbe.", "labels": ["OpenZeppelin"]}, {"title": "whitelistedRoute\u00a0can be\u00a0external", "body": "whitelistedRoute\u00a0can be\u00a0external", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#whitelistedroute\u00a0can-be\u00a0external", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0whitelistedRoute\u00a0function\u00a0within\u00a0HubPool\u00a0is marked as\u00a0public. However, it is not called anywhere within the codebase.", "body": "The\u00a0whitelistedRoute\u00a0function\u00a0within\u00a0HubPool\u00a0is marked as\u00a0public. However, it is not called anywhere within the codebase.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#the\u00a0whitelistedroute\u00a0function\u00a0within\u00a0hubpool\u00a0is-marked-as\u00a0public.-however,-it-is-not-called-anywhere-within-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Consider restricting the function to\u00a0external\u00a0to reduce the surface for error and better reflect its intent.", "body": "Consider restricting the function to\u00a0external\u00a0to reduce the surface for error and better reflect its intent.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#consider-restricting-the-function-to\u00a0external\u00a0to-reduce-the-surface-for-error-and-better-reflect-its-intent.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Suggested EIP changes", "body": "[N01] Suggested EIP changes", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n01]-suggested-eip-changes", "labels": ["OpenZeppelin"]}, {"title": "Client reported:\u00a0The Ethereum Foundation made or inspired many of these suggestions during the audit. We include them here for reference.", "body": "Client reported:\u00a0The Ethereum Foundation made or inspired many of these suggestions during the audit. We include them here for reference.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#client-reported:\u00a0the-ethereum-foundation-made-or-inspired-many-of-these-suggestions-during-the-audit.-we-include-them-here-for-reference.", "labels": ["OpenZeppelin"]}, {"title": "Here are some suggestions to improve the precision and clarity of the EIP and associated documentation:", "body": "Here are some suggestions to improve the precision and clarity of the EIP and associated documentation:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#here-are-some-suggestions-to-improve-the-precision-and-clarity-of-the-eip-and-associated-documentation:", "labels": ["OpenZeppelin"]}, {"title": "To prevent cross-chain replay attacks, user operation signatures should depend on the\u00a0chainid. This is handled in the current implementation but not yet included as a requirement in the EIP.", "body": "To prevent cross-chain replay attacks, user operation signatures should depend on the\u00a0chainid. This is handled in the current implementation but not yet included as a requirement in the EIP.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#to-prevent-cross-chain-replay-attacks,-user-operation-signatures-should-depend-on-the\u00a0chainid.-this-is-handled-in-the-current-implementation-but-not-yet-included-as-a-requirement-in-the-eip.", "labels": ["OpenZeppelin"]}, {"title": "After constructing a batch, bundlers should execute\u00a0eth_estimateGas\u00a0with the maximum gas limit. This would mitigate potential\u00a0return bombing\u00a0or other gas manipulation attacks that could cause batches to fail without specifically identifying the offending operation.", "body": "After constructing a batch, bundlers should execute\u00a0eth_estimateGas\u00a0with the maximum gas limit. This would mitigate potential\u00a0return bombing\u00a0or other gas manipulation attacks that could cause batches to fail without specifically identifying the offending operation.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#after-constructing-a-batch,-bundlers-should-execute\u00a0eth_estimategas\u00a0with-the-maximum-gas-limit.-this-would-mitigate-potential\u00a0return-bombing\u00a0or-other-gas-manipulation-attacks-that-could-cause-batches-to-fail-without-specifically-identifying-the-offending-operation.", "labels": ["OpenZeppelin"]}, {"title": "State any restrictions on how bundlers should construct batches, including ensuring all user operations have different senders.", "body": "State any restrictions on how bundlers should construct batches, including ensuring all user operations have different senders.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#state-any-restrictions-on-how-bundlers-should-construct-batches,-including-ensuring-all-user-operations-have-different-senders.", "labels": ["OpenZeppelin"]}, {"title": "State any restrictions on how batches should be arranged or ordered in blocks (e.g. using the access lists) to avoid interference from other transactions.", "body": "State any restrictions on how batches should be arranged or ordered in blocks (e.g. using the access lists) to avoid interference from other transactions.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#state-any-restrictions-on-how-batches-should-be-arranged-or-ordered-in-blocks-(e.g.-using-the-access-lists)-to-avoid-interference-from-other-transactions.", "labels": ["OpenZeppelin"]}, {"title": "Clarify any operations that paymasters can undertake that wallets cannot. Additionally, explain the conditions (e.g. whitelisting) under which a bundler may accept a non-compliant paymaster, such as the\u00a0DepositPaymaster.", "body": "Clarify any operations that paymasters can undertake that wallets cannot. Additionally, explain the conditions (e.g. whitelisting) under which a bundler may accept a non-compliant paymaster, such as the\u00a0DepositPaymaster.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#clarify-any-operations-that-paymasters-can-undertake-that-wallets-cannot.-additionally,-explain-the-conditions-(e.g.-whitelisting)-under-which-a-bundler-may-accept-a-non-compliant-paymaster,-such-as-the\u00a0depositpaymaster.", "labels": ["OpenZeppelin"]}, {"title": "Although implicit in the specification, we believe a complete walkthrough of the lifecycle of a user operation would be instructive.", "body": "Although implicit in the specification, we believe a complete walkthrough of the lifecycle of a user operation would be instructive.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#although-implicit-in-the-specification,-we-believe-a-complete-walkthrough-of-the-lifecycle-of-a-user-operation-would-be-instructive.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#83.", "body": "Update: Fixed in pull request\u00a0#83.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#83.", "labels": ["OpenZeppelin"]}]